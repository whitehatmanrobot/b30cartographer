------------------------------------------------

HRESULT
CCertEncodeCRLDistInfo::_MapName(
    IN BOOL fEncode,
    IN LONG DistPointIndex,
    IN LONG NameIndex,
    OUT CERT_ALT_NAME_ENTRY **ppName)
{
    HRESULT hr;
    LONG *pNameCount;
    CERT_ALT_NAME_ENTRY **paName;

    if (NULL == ppName)
    {
	hr = E_POINTER;
        ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    hr = _MapDistPoint(fEncode, DistPointIndex, &pNameCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    if (*pNameCount <= NameIndex)
    {
	ceERRORPRINTLINE("bad NameIndex parameter", hr);
	hr = E_INVALIDARG;
	goto error;
    }
    *ppName = &(*paName)[NameIndex];

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::Decode -- Decode CRLDistInfo
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    DWORD cbCRLDist;

    _Cleanup();

    if (NULL == strBinary)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode CRL_DIST_POINTS_INFO:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &m_DecodeInfo,
		    &cbCRLDist))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_aValue = m_DecodeInfo->rgDistPoint;
    m_cValue = m_DecodeInfo->cDistPoint;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetDistPointCount -- Get the Distribution Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetDistPointCount(
    /* [out, retval] */ LONG __RPC_FAR *pDistPointCount)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == m_aValue)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    if (NULL == pDistPointCount)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    *pDistPointCount = m_cValue;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetDistPointCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetNameCount -- Get a Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetNameCount(
    /* [in] */ LONG DistPointIndex,
    /* [out, retval] */ LONG __RPC_FAR *pNameCount)
{
    HRESULT hr;
    LONG *pCount;
    CERT_ALT_NAME_ENTRY **paName;

    if (NULL == pNameCount)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    hr = _MapDistPoint(FALSE, DistPointIndex, &pCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    if (NULL == *paName)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    *pNameCount = *pCount;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetNameCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetNameChoice -- Get a Name Choice
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetNameChoice(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameIndex,
    /* [out, retval] */ LONG __RPC_FAR *pNameChoice)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;

    if (NULL == pNameChoice)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    hr = _MapName(FALSE, DistPointIndex, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }
    *pNameChoice = pName->dwAltNameChoice;
    if (0 == pName->dwAltNameChoice)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetNameChoice"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetName -- Get a Name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetName(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameIndex,
    /* [out, retval] */ BSTR __RPC_FAR *pstrName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;
    WCHAR const *pwsz = NULL;
    char const *psz = NULL;

    if (NULL == pstrName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrName);
    hr = _MapName(FALSE, DistPointIndex, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    switch (pName->dwAltNameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	    pwsz = pName->pwszRfc822Name;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    pwsz = pName->pwszDNSName;
	    break;

	case CERT_ALT_NAME_URL:
	    pwsz = pName->pwszURL;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    psz = pName->pszRegisteredID;
	    break;

	//case CERT_ALT_NAME_DIRECTORY_NAME:
	//case CERT_ALT_NAME_OTHER_NAME:
	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
	//case CERT_ALT_NAME_IP_ADDRESS:
	default:
	    assert(0 == pName->dwAltNameChoice);
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    ceERRORPRINTLINE("uninitialized", hr);
	    goto error;
    }

    // we'd better assure 1 and only 1 of these is non null

    if ((NULL != pwsz) ^ (NULL == psz))
    {
       hr = E_UNEXPECTED; 
       _JumpError(hr, error, "((NULL != pwsz) ^ (NULL == psz))");
    }

    hr = E_OUTOFMEMORY;
    if (NULL != pwsz)
    {
	if (!ceConvertWszToBstr(pstrName, pwsz, -1))
	{
	    ceERRORPRINTLINE("no memory", hr);
	    goto error;
	}
    }
    else
    {
	assert(NULL != psz);
	if (!ceConvertSzToBstr(pstrName, psz, -1))
	{
	    ceERRORPRINTLINE("no memory", hr);
	    goto error;
	}
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetName"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::Reset -- clear out data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::Reset(
    /* [in] */ LONG DistPointCount)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE *aNameValue = NULL;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < DistPointCount || 0 > DistPointCount)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    m_aValue = (CRL_DIST_POINT *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				DistPointCount * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = DistPointCount;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::SetNameCount -- Set the Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::SetNameCount(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameCount)
{
    HRESULT hr;
    LONG *pNameCount;
    CERT_ALT_NAME_ENTRY **paName;

    hr = E_INVALIDARG;
    if (!m_fConstructing)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (CENCODEMAX < NameCount || 0 > NameCount)
    {
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    hr = _MapDistPoint(FALSE, DistPointIndex, &pNameCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    if (0 != *pNameCount || NULL != *paName)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    *paName = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				NameCount * sizeof(CERT_ALT_NAME_ENTRY));
    if (NULL == *paName)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    *pNameCount = NameCount;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::SetNameCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::SetNameEntry -- Set a Name Netry
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::SetNameEntry(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameIndex,
    /* [in] */ LONG NameChoice,
    /* [in] */ BSTR const strName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;
    WCHAR **ppwsz = NULL;
    char **ppsz = NULL;

    if (NULL == strName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (!m_fConstructing)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = _MapName(TRUE, DistPointIndex, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    if (NULL != pName->pwszURL)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    switch (NameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	    ppwsz = &pName->pwszRfc822Name;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    ppwsz = &pName->pwszDNSName;
	    break;

	case CERT_ALT_NAME_URL:
	    ppwsz = &pName->pwszURL;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    hr = ceVerifyObjId(strName);
	    if (S_OK != hr)
	    {
		ceERRORPRINTLINE("ceVerifyObjId", hr);
		goto error;
	    }
	    ppsz = &pName->pszRegisteredID;
	    break;

	//case CERT_ALT_NAME_DIRECTORY_NAME:
	//case CERT_ALT_NAME_OTHER_NAME:
	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
	//case CERT_ALT_NAME_IP_ADDRESS:
    }
    if (NULL != ppwsz)
    {
	if (NULL != *ppwsz)
	{
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("string already set", hr);
	    goto error;
	}
	hr = ceVerifyAltNameString(NameChoice, strName);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceVerifyAltNameString", hr);
	    goto error;
	}
	*ppwsz = ceDuplicateString(strName);
	if (NULL == *ppwsz)
	{
	    hr = E_OUTOFMEMORY;
	    ceERRORPRINTLINE("ceDuplicateString", hr);
	    goto error;
	}
    }
    else if (NULL != ppsz)
    {
	if (NULL != *ppsz)
	{
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("string already set", hr);
	    goto error;
	}
	if (!ceConvertWszToSz(ppsz, strName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    ceERRORPRINTLINE("ceConvertWszToSz", hr);
	    goto error;
	}
    }
    else
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad NameChoice parameter", hr);
	goto error;
    }
    pName->dwAltNameChoice = NameChoice;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::SetNameEntry"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_VerifyNames -- Verify names
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

BOOL
CCertEncodeCRLDistInfo::_VerifyNames(
    IN LONG DistPointIndex)
{
    HRESULT hr;
    BOOL fOk = FALSE;
    LONG Count;
    LONG *pNameCount;
    LONG i;
    CERT_ALT_NAME_ENTRY **paName;

    assert(m_fConstructing);

    hr = _MapDistPoint(TRUE, DistPointIndex, &pNameCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    Count = *pNameCount;
    if (0 != Count)
    {
	CERT_ALT_NAME_ENTRY *pName;

	pName = *paName;
	assert(NULL != pName);
	for (i = 0; i < Count; pName++, i++)
	{
	    if (NULL == pName->pwszURL)		// test arbitrary union arm
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		ceERRORPRINTLINE("uninitialized name", hr);
		goto error;
	    }
	}
    }
    fOk = TRUE;

error:
    return(fOk);
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::Encode -- Encode CRLDistInfo
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    LONG i;

    CRLDistInfo.cDistPoint = m_cValue;
    CRLDistInfo.rgDistPoint = m_aValue;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	m_aValue[i].DistPointName.dwDistPointNameChoice =
	    CRL_DIST_POINT_FULL_NAME;

	// Verify all entries are initialized:

	if (!_VerifyNames(i))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    ceERRORPRINTLINE("uninitialized name", hr);
	    goto error;
	}
    }

    // Encode CRL_DIST_POINTS_INFO:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(pstrBinary, (WCHAR const *) pbEncoded, cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeCRLDistInfo::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODECRLDISTINFO,
			    &IID_ICertEncodeCRLDistInfo);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\crldist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crldist.h
//
//--------------------------------------------------------------------------

// crldist.h: Declaration of the CCertEncodeCRLDistInfo


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODECRLDISTINFO wszCLASS_CERTENCODE TEXT("CRLDistInfo")

class CCertEncodeCRLDistInfo: 
    public IDispatchImpl<ICertEncodeCRLDistInfo, &IID_ICertEncodeCRLDistInfo, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeCRLDistInfo>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeCRLDistInfo, &CLSID_CCertEncodeCRLDistInfo>
{
public:
    CCertEncodeCRLDistInfo()
    {
	m_aValue = NULL;
	m_DecodeInfo = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeCRLDistInfo();

BEGIN_COM_MAP(CCertEncodeCRLDistInfo)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeCRLDistInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeCRLDistInfo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeCRLDistInfo,
    wszCLASS_CERTENCODECRLDISTINFO TEXT(".1"),
    wszCLASS_CERTENCODECRLDISTINFO,
    IDS_CERTENCODECRLDIST_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeCRLDistInfo
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetDistPointCount)(
		/* [out, retval] */ LONG __RPC_FAR *pDistPointCount);

    STDMETHOD(GetNameCount)(
		/* [in] */ LONG DistPointIndex,
		/* [out, retval] */ LONG __RPC_FAR *pNameCount);

    STDMETHOD(GetNameChoice)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameIndex,
		/* [out, retval] */ LONG __RPC_FAR *pNameChoice);

    STDMETHOD(GetName)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameIndex,
		/* [out, retval] */ BSTR __RPC_FAR *pstrName);

    STDMETHOD(Reset)(
		/* [in] */ LONG DistPointCount);

    STDMETHOD(SetNameCount)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameCount);

    STDMETHOD(SetNameEntry)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameIndex,
		/* [in] */ LONG NameChoice,
		/* [in] */ BSTR const strName);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    BOOL _VerifyNames(
		IN LONG DistPointIndex);

    HRESULT _MapDistPoint(
		IN BOOL fEncode,
		IN LONG DistPointIndex,
		OUT LONG **ppNameCount,
		OUT CERT_ALT_NAME_ENTRY ***ppaName);

    HRESULT _MapName(
		IN BOOL fEncode,
		IN LONG DistPointIndex,
		IN LONG NameIndex,
		OUT CERT_ALT_NAME_ENTRY **ppName);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    CRL_DIST_POINT	 *m_aValue;
    LONG		  m_cValue;
    CRL_DIST_POINTS_INFO *m_DecodeInfo;
    BOOL		  m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certenc.rc
//
#define IDS_CERTENCODEDATEARRAY_DESC		1
#define IDS_CERTENCODELONGARRAY_DESC		2
#define IDS_CERTENCODEALTNAME_DESC		3
#define IDS_CERTENCODESTRINGARRAY_DESC		4
#define IDS_CERTENCODEBITSTRING_DESC		5
#define IDS_CERTENCODECRLDIST_DESC		6
#define IDS_E_UNEXPECTED			7
#define IDS_UNKNOWN_ERROR_CODE			8


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\ciexit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ciexit.h
//
//--------------------------------------------------------------------------

// ciexit.h : Declaration of the CCertServerExit class


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CertIF

class CCertServerExit: 
    public IDispatchImpl<ICertServerExit, &IID_ICertServerExit, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertServerExit>,
    public CComObjectRoot,
    public CComCoClass<CCertServerExit, &CLSID_CCertServerExit>
{
public:
    CCertServerExit() { m_Context = 0; m_fExtensionValid = FALSE; }
    ~CCertServerExit();

BEGIN_COM_MAP(CCertServerExit)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertServerExit)
END_COM_MAP()

// Remove the comment from following the line if you don't want your object to 
// support aggregation.  The default is to support it.

DECLARE_NOT_AGGREGATABLE(CCertServerExit) 

DECLARE_REGISTRY(
    CCertServerExit,
    wszCLASS_CERTSERVEREXIT TEXT(".1"),
    wszCLASS_CERTSERVEREXIT,
    IDS_CERTSERVERPOLICY_DESC,
    THREADFLAGS_BOTH)

// ICertServerExit
public:
    STDMETHOD(SetContext)(
		    IN LONG Context);

    STDMETHOD(GetRequestProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetRequestAttribute)(
		    IN BSTR const strAttributeName,
		    OUT BSTR __RPC_FAR *pstrAttributeValue);

    STDMETHOD(GetCertificateProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetCertificateExtension)(
		    IN BSTR const strExtensionName,
		    IN LONG Type,
		    OUT VARIANT __RPC_FAR *pvarValue);

    STDMETHOD(GetCertificateExtensionFlags)(
		    OUT LONG __RPC_FAR *pFlags);

    STDMETHOD(EnumerateExtensionsSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateExtensions)(
		    OUT BSTR *pstrExtensionName);

    STDMETHOD(EnumerateExtensionsClose)(VOID);

    STDMETHOD(EnumerateAttributesSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateAttributes)(
		    OUT BSTR *pstrAttributeName);

    STDMETHOD(EnumerateAttributesClose)(VOID);

private:
    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription,
	OPTIONAL IN WCHAR const *pwszPropName);

    LONG   m_Context;
    LONG   m_ExtFlags;
    BOOL   m_fExtensionValid;
    CIENUM m_ciEnumExtensions;
    CIENUM m_ciEnumAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\ciexit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ciexit.cpp
//
//--------------------------------------------------------------------------

// ciexit.cpp: Implementation of CCertServerExit

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"
#include "ciinit.h"
#include <assert.h>

#include "ciexit.h"

extern SERVERCALLBACKS ServerCallBacks;

/////////////////////////////////////////////////////////////////////////////
//

CCertServerExit::~CCertServerExit()
{
    EnumerateExtensionsClose();
    EnumerateAttributesClose();
}


STDMETHODIMP
CCertServerExit::SetContext(
    IN LONG Context)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);

    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "pfnGetProperty NULL");
    }
    if (0 != Context)
    {
	// PROPCALLER_SERVER indicates this call is only for Context validation
	// -- returns a zero RequestId.  This keeps CRL publication exit module
	// notification from failing.

	hr = (*ServerCallBacks.pfnGetProperty)(
				    Context,
				    PROPTYPE_LONG |
					PROPCALLER_SERVER |
					PROPTABLE_REQUEST,
				    wszPROPREQUESTREQUESTID,
				    &var);
	_JumpIfError(hr, error, "GetProperty");
    }
    m_Context = Context;
    hr = S_OK;

error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerExit::SetContext", NULL));
}


STDMETHODIMP
CCertServerExit::GetRequestProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_EXIT | PROPTABLE_REQUEST,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetRequestProperty", strPropertyName));
}


STDMETHODIMP
CCertServerExit::GetRequestAttribute(
    IN BSTR const strAttributeName,
    OUT BSTR __RPC_FAR *pstrAttributeValue)
{
    HRESULT hr;
    VARIANT var;

    var.vt = VT_BYREF | VT_BSTR;
    var.pbstrVal = pstrAttributeValue;

    if (NULL == pstrAttributeValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pstrAttributeValue NULL");
    }

    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				PROPTYPE_STRING |
				    PROPCALLER_EXIT |
				    PROPTABLE_ATTRIBUTE,
				strAttributeName,
				&var);
    if (VT_BSTR == var.vt)
    {
	*pstrAttributeValue = var.bstrVal;
	var.vt = VT_EMPTY;
    }
    else
    if ((VT_BYREF | VT_BSTR) == var.vt)
    {
	*pstrAttributeValue = *var.pbstrVal;
	var.vt = VT_EMPTY;
    }
error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerExit::GetRequestAttribute", strAttributeName));
}


STDMETHODIMP
CCertServerExit::GetCertificateProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_EXIT | PROPTABLE_CERTIFICATE,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetCertificateProperty", strPropertyName));
}


STDMETHODIMP
CCertServerExit::GetCertificateExtension(
    IN BSTR const strExtensionName,
    IN LONG Type,
    OUT VARIANT __RPC_FAR *pvarValue)
{
    HRESULT hr;
    
    m_fExtensionValid = FALSE;
    assert(NULL != ServerCallBacks.pfnGetExtension);
    if (NULL == ServerCallBacks.pfnGetExtension)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetExtension NULL");
    }
    hr = (*ServerCallBacks.pfnGetExtension)(
				m_Context,
				(Type & PROPTYPE_MASK) | PROPCALLER_EXIT,
				strExtensionName,
				(DWORD *) &m_ExtFlags,
				pvarValue);
    if (S_OK == hr)
    {
	m_fExtensionValid = TRUE;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetCertificateExtension", strExtensionName));
}


STDMETHODIMP
CCertServerExit::GetCertificateExtensionFlags(
    OUT LONG __RPC_FAR *pExtFlags)
{
    HRESULT hr = E_INVALIDARG;
    if (NULL == pExtFlags)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pExtFlags NULL");
    }

    *pExtFlags = 0;
    if (m_fExtensionValid)
    {
	*pExtFlags = m_ExtFlags;
	hr = S_OK;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetCertificateExtensionFlags", NULL));
}




STDMETHODIMP
CCertServerExit::EnumerateExtensionsSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_EXTENSIONS |
				    CIE_CALLER_EXIT,
				&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateExtensionsSetup", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateExtensions(
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumExtensions,
				pstrExtensionName);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateExtensions", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateExtensionsClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateExtensionsClose", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateAttributesSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_ATTRIBUTES |
				    CIE_CALLER_EXIT,
				&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateAttributesSetup", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateAttributes(
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumAttributes,
				pstrAttributeName);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateAttributes", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateAttributesClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateAttributesClose", NULL));
}


HRESULT
CCertServerExit::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszPropName)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);

    CSASSERT(NULL != pwszDescription);
    if (NULL == pwszDescription)
    {
        _JumpError(E_POINTER, error, "NULL parm");
    }

    if (FAILED(hrError))
    {
	    HRESULT hr;
	    WCHAR const *pwszLog = pwszDescription;
	    WCHAR *pwszAlloc = NULL;

	    if (NULL != pwszPropName)
	    {
	        pwszAlloc = (WCHAR *) LocalAlloc(
					    LMEM_FIXED, 
					    (wcslen(pwszDescription) +
					     wcslen(pwszPropName) +
					     2 +
					     1) * sizeof(WCHAR));
	        if (NULL != pwszAlloc)
	        {
		    wcscpy(pwszAlloc, pwszDescription);
		    wcscat(pwszAlloc, wszLPAREN);
		    wcscat(pwszAlloc, pwszPropName);
		    wcscat(pwszAlloc, wszRPAREN);
		    pwszLog = pwszAlloc;
	        }
	    }

	    hr = DispatchSetErrorInfo(
			        hrError,
			        pwszLog,
			        wszCLASS_CERTSERVEREXIT,
			        &IID_ICertServerExit);
	    CSASSERT(hr == hrError);
	    if (NULL != pwszAlloc)
	    {
	        LocalFree(pwszAlloc);
	    }
    }
error:
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\certif.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certif.cpp
//
//--------------------------------------------------------------------------

// CertIF.cpp : Implementation of DLL Exports.

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "ciinit.h"


SERVERCALLBACKS ServerCallBacks;

extern "C" DWORD WINAPI
CertificateInterfaceInit(
    IN SERVERCALLBACKS const *psb,
    IN DWORD cbsb)
{
    if (sizeof(ServerCallBacks) != cbsb)
    {
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }
    ServerCallBacks = *psb;
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\cipolicy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       cipolicy.cpp
//
//--------------------------------------------------------------------------

// cipolicy.cpp: Implementation of CCertServerPolicy

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"
#include "ciinit.h"
#include <assert.h>

#include "cipolicy.h"

extern SERVERCALLBACKS ServerCallBacks;

/////////////////////////////////////////////////////////////////////////////
//

CCertServerPolicy::~CCertServerPolicy()
{
    EnumerateExtensionsClose();
    EnumerateAttributesClose();
}


STDMETHODIMP
CCertServerPolicy::SetContext(
    IN LONG Context)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);

    if (0 != Context)
    {
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

	hr = (*ServerCallBacks.pfnGetProperty)(
				    Context,
				    PROPTYPE_LONG |
					PROPCALLER_POLICY |
					PROPTABLE_CERTIFICATE,
				    wszPROPREQUESTREQUESTID,
				    &var);
	_JumpIfError(hr, error, "GetProperty");
    }
    m_Context = Context;
    hr = S_OK;

error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerPolicy::SetContext", NULL));
}


STDMETHODIMP
CCertServerPolicy::GetRequestProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_POLICY | PROPTABLE_REQUEST,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetRequestProperty", strPropertyName));
}


STDMETHODIMP
CCertServerPolicy::GetRequestAttribute(
    IN BSTR const strAttributeName,
    OUT BSTR __RPC_FAR *pstrAttributeValue)
{
    HRESULT hr;
    VARIANT var;

    var.vt = VT_BYREF | VT_BSTR;
    var.pbstrVal = pstrAttributeValue;

    if (NULL == pstrAttributeValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pstrAttributeValue NULL");
    }
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				PROPTYPE_STRING |
				    PROPCALLER_POLICY |
				    PROPTABLE_ATTRIBUTE,
				strAttributeName,
				&var);
    *pstrAttributeValue = NULL;
    if (VT_BSTR == var.vt)
    {
	*pstrAttributeValue = var.bstrVal;
	var.vt = VT_EMPTY;
    }
    else
    if ((VT_BYREF | VT_BSTR) == var.vt)
    {
	*pstrAttributeValue = *var.pbstrVal;
	var.vt = VT_EMPTY;
    }
error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetRequestAttribute", strAttributeName));
}


STDMETHODIMP
CCertServerPolicy::GetCertificateProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_POLICY | PROPTABLE_CERTIFICATE,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetCertificateProperty", strPropertyName));
}


STDMETHODIMP
CCertServerPolicy::SetCertificateProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    IN VARIANT const __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnSetProperty);
    if (NULL == ServerCallBacks.pfnSetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnSetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnSetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_POLICY | PROPTABLE_CERTIFICATE,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::SetCertificateProperty", strPropertyName));
}


STDMETHODIMP
CCertServerPolicy::GetCertificateExtension(
    IN BSTR const strExtensionName,
    IN LONG Type,
    OUT VARIANT __RPC_FAR *pvarValue)
{
    HRESULT hr;
    
    m_fExtensionValid = FALSE;
    assert(NULL != ServerCallBacks.pfnGetExtension);
    if (NULL == ServerCallBacks.pfnGetExtension)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetExtension NULL");
    }
    hr = (*ServerCallBacks.pfnGetExtension)(
				m_Context,
				(Type & PROPTYPE_MASK) | PROPCALLER_POLICY,
				strExtensionName,
				(DWORD *) &m_ExtFlags,
				pvarValue);
    if (S_OK == hr)
    {
	m_fExtensionValid = TRUE;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetCertificateExtension", strExtensionName));
}


STDMETHODIMP
CCertServerPolicy::GetCertificateExtensionFlags(
    OUT LONG __RPC_FAR *pExtFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pExtFlags)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    *pExtFlags = 0;
    if (m_fExtensionValid)
    {
	*pExtFlags = m_ExtFlags;
	hr = S_OK;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetCertificateExtensionFlags", NULL));
}


STDMETHODIMP
CCertServerPolicy::SetCertificateExtension(
    IN BSTR const strExtensionName,
    IN LONG Type,
    IN LONG ExtFlags,
    IN VARIANT const __RPC_FAR *pvarValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnSetExtension);
    if (NULL == ServerCallBacks.pfnSetExtension)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnSetExtension NULL");
    }
    hr = (*ServerCallBacks.pfnSetExtension)(
				m_Context,
				(Type & PROPTYPE_MASK) | PROPCALLER_POLICY,
				strExtensionName,
				(ExtFlags & EXTENSION_POLICY_MASK) |
				    EXTENSION_ORIGIN_POLICY,
				pvarValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::SetCertificateExtension", strExtensionName));
}


STDMETHODIMP
CCertServerPolicy::EnumerateExtensionsSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_EXTENSIONS |
				    CIE_CALLER_POLICY,
				&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateExtensionsSetup", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateExtensions(
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumExtensions,
				pstrExtensionName);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateExtensions", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateExtensionsClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateExtensionsClose", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateAttributesSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_ATTRIBUTES |
				    CIE_CALLER_POLICY,
				&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateAttributesSetup", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateAttributes(
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumAttributes,
				pstrAttributeName);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateAttributes", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateAttributesClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateAttributesClose", NULL));
}


HRESULT
CCertServerPolicy::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszPropName)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);

    CSASSERT(pwszDescription != NULL);
    if (NULL == pwszDescription)
    {
        _JumpError(E_POINTER, error, "NULL parm");
    }

    if (FAILED(hrError))
    {
        HRESULT hr;
	WCHAR const *pwszLog = pwszDescription;
	WCHAR *pwszAlloc = NULL;

	if (NULL != pwszPropName)
	{
	    pwszAlloc = (WCHAR *) LocalAlloc(
					LMEM_FIXED, 
					(wcslen(pwszDescription) +
					 wcslen(pwszPropName) +
					 2 +
					 1) * sizeof(WCHAR));
	    if (NULL != pwszAlloc)
	    {
		wcscpy(pwszAlloc, pwszDescription);
		wcscat(pwszAlloc, wszLPAREN);
		wcscat(pwszAlloc, pwszPropName);
		wcscat(pwszAlloc, wszRPAREN);
		pwszLog = pwszAlloc;
	    }
	}

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszLog,
			    wszCLASS_CERTSERVERPOLICY,
			    &IID_ICertServerPolicy);
	CSASSERT(hr == hrError);
	if (NULL != pwszAlloc)
	{
	    LocalFree(pwszAlloc);
	}
    }
error:
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\cipolicy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       cipolicy.h
//
//--------------------------------------------------------------------------

// cipolicy.h : Declaration of the CCertServerPolicy class


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CertIF

class CCertServerPolicy: 
    public IDispatchImpl<ICertServerPolicy, &IID_ICertServerPolicy, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertServerPolicy>,
    public CComObjectRoot,
    public CComCoClass<CCertServerPolicy,&CLSID_CCertServerPolicy>
{
public:
    CCertServerPolicy() { m_Context = 0; m_fExtensionValid = FALSE; }
    ~CCertServerPolicy();

BEGIN_COM_MAP(CCertServerPolicy)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertServerPolicy)
END_COM_MAP()

// Remove the comment from following the line if you don't want your object to 
// support aggregation.  The default is to support it.

DECLARE_NOT_AGGREGATABLE(CCertServerPolicy) 

DECLARE_REGISTRY(
    CCertServerPolicy,
    wszCLASS_CERTSERVERPOLICY TEXT(".1"),
    wszCLASS_CERTSERVERPOLICY,
    IDS_CERTSERVERPOLICY_DESC,
    THREADFLAGS_BOTH)

// ICertServerPolicy
public:
    STDMETHOD(SetContext)(
		    IN LONG Context);

    STDMETHOD(GetRequestProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetRequestAttribute)(
		    IN BSTR const strAttributeName,
		    OUT BSTR __RPC_FAR *pstrAttributeValue);

    STDMETHOD(GetCertificateProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(SetCertificateProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    IN VARIANT const __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetCertificateExtension)(
		    IN BSTR const strExtensionName,
		    IN LONG Type,
		    OUT VARIANT __RPC_FAR *pvarValue);

    STDMETHOD(GetCertificateExtensionFlags)(
		    OUT LONG __RPC_FAR *pFlags);

    STDMETHOD(SetCertificateExtension)(
		    IN BSTR const strExtensionName,
		    IN LONG Type,
		    IN LONG ExtFlags,
		    IN VARIANT const __RPC_FAR *pvarValue);

    STDMETHOD(EnumerateExtensionsSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateExtensions)(
		    OUT BSTR *pstrExtensionName);

    STDMETHOD(EnumerateExtensionsClose)(VOID);

    STDMETHOD(EnumerateAttributesSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateAttributes)(
		    OUT BSTR *pstrAttributeName);

    STDMETHOD(EnumerateAttributesClose)(VOID);

private:
    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription,
	OPTIONAL IN WCHAR const *pwszPropName);

    LONG   m_Context;
    LONG   m_ExtFlags;
    BOOL   m_fExtensionValid;
    CIENUM m_ciEnumExtensions;
    CIENUM m_ciEnumAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\pch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pch.cpp
//
//--------------------------------------------------------------------------

#define __DIR__		"certif"

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\csif.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csif.h
//
// Contents:    CertIf includes
//
//---------------------------------------------------------------------------

#include "csprop.h"
#include "certif.h"
#include "cipolicy.h"
#include "ciexit.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certif\csifm.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certifm.h
//
// Contents:    CertIf object map entries
//
//---------------------------------------------------------------------------

    OBJECT_ENTRY(CLSID_CCertServerPolicy, CCertServerPolicy)
    OBJECT_ENTRY(CLSID_CCertServerExit, CCertServerExit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\acl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        acl.cpp
//
// Contents:    Access Control helpers for certsrv
//
// History:     11-16-98 petesk created
//              10/99 xtan, major changes
//
//---------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop
#include <ntdsapi.h>
#define SECURITY_WIN32

#include <security.h>
#include <sddl.h>
#include <aclapi.h>

#include "certca.h"
#include "cscsp.h"
#include "certacl.h"
#include "certsd.h"

// defines

const GUID GUID_APPRV_REQ = { /* 0e10c966-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c966,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

const GUID GUID_REVOKE= { /* 0e10c967-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c967,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

// Important, keep enroll GUID in sync with string define in certacl.h
const GUID GUID_ENROLL = { /* 0e10c968-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c968,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

const GUID GUID_AUTOENROLL = { /* a05b8cc2-17bc-4802-a710-e7c15ab866a2 */
    0xa05b8cc2,
    0x17bc,
    0x4802,
    {0xa7, 0x10, 0xe7, 0xc1, 0x5a, 0xb8, 0x66, 0xa2} };

const GUID GUID_READ_DB = { /* 0e10c969-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c969,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

HRESULT
myGetSDFromTemplate(
    IN WCHAR const           *pwszStringSD,
    IN OPTIONAL WCHAR const  *pwszReplace,
    OUT PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT  hr;
    WCHAR   *pwszReplaceSD = NULL;
    WCHAR const *pwszFinalSD = pwszStringSD;  

    CSASSERT(NULL != ppSD);

    if (NULL == ppSD)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "null SD pointer");
    }

    if (NULL != pwszReplace)
    {
        // replace the token

        CSASSERT(NULL != wcsstr(pwszStringSD, L"%ws"));

        pwszReplaceSD = (WCHAR*)LocalAlloc(LMEM_FIXED, 
                            (wcslen(pwszStringSD) +
                             wcslen(pwszReplace) + 1) * sizeof(WCHAR) );
        if (NULL == pwszReplaceSD)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wsprintf(pwszReplaceSD, pwszStringSD, pwszReplace);
        pwszFinalSD = pwszReplaceSD;
    }

    // build the security descriptor including the local machine.
    if (!myConvertStringSecurityDescriptorToSecurityDescriptor(
							pwszFinalSD,
							SDDL_REVISION,
							ppSD,
							NULL))
    {
        hr = myHLastError();
        _JumpError(
		hr,
		error,
		"myConvertStringSecurityDescriptorToSecurityDescriptor");
    }

    DBGPRINT((DBG_SS_CERTLIBI, "security descriptor:%ws\n", pwszFinalSD));

    hr = S_OK;
error:
    if (NULL != pwszReplaceSD)
    {
        LocalFree(pwszReplaceSD);
    }
    return hr;
}

HRESULT
myGetSecurityDescriptorDacl(
    IN PSECURITY_DESCRIPTOR   pSD, 
    OUT PACL                 *ppDacl) // no free
{
    HRESULT  hr;
    PACL     pDacl = NULL; //no free
    BOOL     bDaclPresent = FALSE;
    BOOL     bDaclDefaulted = FALSE;

    CSASSERT(NULL != ppDacl);

    //init
    *ppDacl = NULL;

    // get dacl pointers
    if (!GetSecurityDescriptorDacl(pSD,
                                   &bDaclPresent,
                                   &pDacl,
                                   &bDaclDefaulted))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }
    if(!bDaclPresent || (pDacl == NULL))
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    *ppDacl = pDacl;

    hr = S_OK;
error:
    return hr;
}

HRESULT
myGetSecurityDescriptorSacl(
    IN PSECURITY_DESCRIPTOR   pSD, 
    OUT PACL                 *ppSacl) // no free
{
    HRESULT  hr;
    PACL     pSacl = NULL; //no free
    BOOL     bSaclPresent = FALSE;
    BOOL     bSaclDefaulted = FALSE;

    CSASSERT(NULL != ppSacl);

    //init
    *ppSacl = NULL;

    // get dacl pointers
    if (!GetSecurityDescriptorSacl(pSD,
                                   &bSaclPresent,
                                   &pSacl,
                                   &bSaclDefaulted))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }
    if(!bSaclPresent || (pSacl == NULL))
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    *ppSacl = pSacl;

    hr = S_OK;
error:
    return hr;
}

#define  CERTSRV_DACL_CONTROL_MASK SE_DACL_AUTO_INHERIT_REQ | \
                                   SE_DACL_AUTO_INHERITED | \
                                   SE_DACL_PROTECTED
#define  CERTSRV_SACL_CONTROL_MASK SE_SACL_AUTO_INHERIT_REQ | \
                                   SE_SACL_AUTO_INHERITED | \
                                   SE_SACL_PROTECTED


// Merge parts of a new SD with an old SD based on the SI flags:
// DACL_SECURITY_INFORMATION    - use new SD DACL
// SACL_SECURITY_INFORMATION    - use new SD SACL
// OWNER_SECURITY_INFORMATION   - use new SD owner
// GROUP_SECURITY_INFORMATION   - use new SD group

HRESULT 
myMergeSD(
    IN PSECURITY_DESCRIPTOR   pSDOld,
    IN PSECURITY_DESCRIPTOR   pSDMerge, 
    IN SECURITY_INFORMATION   si,
    OUT PSECURITY_DESCRIPTOR *ppSDNew)
{
    HRESULT              hr;
    PSECURITY_DESCRIPTOR pSDDaclSource = 
        si & DACL_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDSaclSource = 
        si & SACL_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDOwnerSource = 
        si & OWNER_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDGroupSource = 
        si & GROUP_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDNew = NULL;
    PSECURITY_DESCRIPTOR pSDNewRelative = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                 pDacl = NULL; //no free
    PSID                 pGroupSid = NULL; //no free
    BOOL                 fGroupDefaulted = FALSE;
    PSID                 pOwnerSid = NULL; //no free
    BOOL                 fOwnerDefaulted = FALSE;
    DWORD                dwSize;
    BOOL                 fSaclPresent = FALSE;
    BOOL                 fSaclDefaulted = FALSE;
    PACL                 pSacl = NULL; //no free
    DWORD                dwRevision;

    CSASSERT(NULL != pSDOld);
    CSASSERT(NULL != pSDMerge);
    CSASSERT(NULL != ppSDNew);

    *ppSDNew = NULL;

    pSDNew = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, 
                                      SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSDNew == NULL) 
    {     
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!InitializeSecurityDescriptor(pSDNew, SECURITY_DESCRIPTOR_REVISION))
    { 
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    // set SD control
    if (!GetSecurityDescriptorControl(pSDOld, &sdc, &dwRevision))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorControl");
    }

    if (!SetSecurityDescriptorControl(
             pSDNew,
             CERTSRV_DACL_CONTROL_MASK|
             CERTSRV_SACL_CONTROL_MASK,
             sdc &
             (CERTSRV_DACL_CONTROL_MASK|
              CERTSRV_SACL_CONTROL_MASK)))    
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    // get CA security acl info
    hr = myGetSecurityDescriptorDacl(
             pSDDaclSource,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");
    
    // set new SD dacl
    if(!SetSecurityDescriptorDacl(pSDNew, 
                                  TRUE,
                                  pDacl,
                                  FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    // set new SD group
    if(!GetSecurityDescriptorGroup(pSDGroupSource, &pGroupSid, &fGroupDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
    }
    if(!SetSecurityDescriptorGroup(pSDNew, pGroupSid, fGroupDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorGroup");
    }

    // set new SD owner
    if(!GetSecurityDescriptorOwner(pSDOwnerSource, &pOwnerSid, &fOwnerDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
    }
    if(!SetSecurityDescriptorOwner(pSDNew, pOwnerSid, fOwnerDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorGroup");
    }

    // set new SD sacl
    if(!GetSecurityDescriptorSacl(pSDSaclSource, &fSaclPresent, &pSacl, &fSaclDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorSacl");
    }
    if(!SetSecurityDescriptorSacl(pSDNew, fSaclPresent, pSacl, fSaclDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorSacl");
    }

    if (!IsValidSecurityDescriptor(pSDNew))
    {
        hr = myHLastError();
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    dwSize = GetSecurityDescriptorLength(pSDNew);
    pSDNewRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
    if(pSDNewRelative == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!MakeSelfRelativeSD(pSDNew, pSDNewRelative, &dwSize))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!IsValidSecurityDescriptor(pSDNewRelative))
    {
        hr = myHLastError();
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    *ppSDNew = pSDNewRelative;
    pSDNewRelative = NULL;
    hr = S_OK;
error:
    if(pSDNew)
    {
        LocalFree(pSDNew);
    }
    if(pSDNewRelative)
    {
        LocalFree(pSDNewRelative);
    }
    return hr;
}


HRESULT
UpdateServiceSacl(bool fTurnOnAuditing)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSaclSD = NULL;
    PACL pSacl = NULL; // no free
    bool fPrivilegeEnabled = false;

    hr = myGetSDFromTemplate(
        fTurnOnAuditing?
        CERTSRV_SERVICE_SACL_ON:
        CERTSRV_SERVICE_SACL_OFF,
        NULL, // no insertion string
        &pSaclSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = myGetSecurityDescriptorSacl(
        pSaclSD,
        &pSacl);
    _JumpIfError(hr, error, "myGet");


    hr = myEnablePrivilege(SE_SECURITY_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    fPrivilegeEnabled = true;

    hr = SetNamedSecurityInfo(
            wszSERVICE_NAME,
            SE_SERVICE,
            SACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            NULL,
            pSacl);
    if(ERROR_SUCCESS != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "SetNamedSecurityInfo");
    }

error:

    if(fPrivilegeEnabled)
    {
        myEnablePrivilege(SE_SECURITY_NAME, FALSE);
    }
    LOCAL_FREE(pSaclSD);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\admin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       admin.cpp
//
//  Contents:   ICertAdmin IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"


//+------------------------------------------------------------------------
// ICertAdmin dispatch support

//TCHAR szRegKeyAdminClsid[] = wszCLASS_CERTADMIN TEXT("\\Clsid");

//+------------------------------------
// IsValidCertificate method:

static OLECHAR *_apszIsValidCertificate[] = {
    TEXT("IsValidCertificate"),
    TEXT("strConfig"),
    TEXT("strSerialNumber"),
};


//+------------------------------------
// GetRevocationReason method:

static OLECHAR *_apszGetRevocationReason[] = {
    TEXT("GetRevocationReason"),
};

//+------------------------------------
// RevokeCertificate method:

static OLECHAR *_apszRevokeCertificate[] = {
    TEXT("RevokeCertificate"),
    TEXT("strConfig"),
    TEXT("strSerialNumber"),
    TEXT("Reason"),
    TEXT("Date"),
};

//+------------------------------------
// SetRequestAttributes method:

static OLECHAR *_apszSetRequestAttributes[] = {
    TEXT("SetRequestAttributes"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strAttributes"),
};

//+------------------------------------
// SetCertificateExtension method:

static OLECHAR *_apszSetCertificateExtension[] = {
    TEXT("SetCertificateExtension"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strExtensionName"),
    TEXT("Type"),
    TEXT("Flags"),
    TEXT("pvarValue"),
};

//+------------------------------------
// DenyRequest method:

static OLECHAR *_apszDenyRequest[] = {
    TEXT("DenyRequest"),
    TEXT("strConfig"),
    TEXT("RequestId"),
};

//+------------------------------------
// ResubmitRequest method:

static OLECHAR *_apszResubmitRequest[] = {
    TEXT("ResubmitRequest"),
    TEXT("strConfig"),
    TEXT("RequestId"),
};

//+------------------------------------
// PublishCRL method:

static OLECHAR *_apszPublishCRL[] = {
    TEXT("PublishCRL"),
    TEXT("strConfig"),
    TEXT("Date"),
};

//+------------------------------------
// GetCRL method:

static OLECHAR *_apszGetCRL[] = {
    TEXT("GetCRL"),
    TEXT("strConfig"),
    TEXT("Flags"),
};

//+------------------------------------
// ImportCertificate method:

static OLECHAR *_apszImportCertificate[] = {
    TEXT("ImportCertificate"),
    TEXT("strConfig"),
    TEXT("strCertificate"),
    TEXT("Flags"),
};

//+------------------------------------
// PublishCRLs method:

static OLECHAR *_apszPublishCRLs[] = {
    TEXT("PublishCRLs"),
    TEXT("strConfig"),
    TEXT("Date"),
    TEXT("CRLFlags"),
};

//+------------------------------------
// GetCAProperty method:

static OLECHAR *_apszGetCAProperty[] = {
    TEXT("GetCAProperty"),
    TEXT("strConfig"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("Flags"),
};

//+------------------------------------
// SetCAProperty method:

static OLECHAR *_apszSetCAProperty[] = {
    TEXT("SetCAProperty"),
    TEXT("strConfig"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("pvarPropertyValue"),
};

//+------------------------------------
// GetCAPropertyFlags method:

static OLECHAR *_apszGetCAPropertyFlags[] = {
    TEXT("GetCAPropertyFlags"),
    TEXT("strConfig"),
    TEXT("PropId"),
};

//+------------------------------------
// GetCAPropertyDisplayName method:

static OLECHAR *_apszGetCAPropertyDisplayName[] = {
    TEXT("GetCAPropertyDisplayName"),
    TEXT("strConfig"),
    TEXT("PropId"),
};

//+------------------------------------
// GetArchivedKey method:

static OLECHAR *_apszGetArchivedKey[] = {
    TEXT("GetArchivedKey"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("Flags"),
};

//+------------------------------------
// GetConfigEntry method:

static OLECHAR *_apszGetConfigEntry[] = {
    TEXT("GetConfigEntry"),
    TEXT("strConfig"),
    TEXT("strNodePath"),
    TEXT("strEntryName"),
};

//+------------------------------------
// SetConfigEntry method:

static OLECHAR *_apszSetConfigEntry[] = {
    TEXT("SetConfigEntry"),
    TEXT("strConfig"),
    TEXT("strNodePath"),
    TEXT("strEntryName"),
    TEXT("pvarEntry"),
};

//+------------------------------------
// ImportKey method:

static OLECHAR *_apszImportKey[] = {
    TEXT("ImportKey"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strCertHash"),
    TEXT("Flags"),
    TEXT("strKey"),
};

//+------------------------------------
// GetMyRoles method:

static OLECHAR *_apszGetMyRoles[] = {
    TEXT("GetMyRoles"),
    TEXT("strConfig"),
};

//+------------------------------------
// DeleteRow method:

static OLECHAR *_apszDeleteRow[] = {
    TEXT("DeleteRow"),
    TEXT("strConfig"),
    TEXT("Flags"),
    TEXT("Date"),
    TEXT("Table"),
    TEXT("RowId"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtAdmin[] =
{
#define ADMIN_ISVALIDCERTIFICATE	0
    DECLARE_DISPATCH_ENTRY(_apszIsValidCertificate)

#define ADMIN_GETREVOCATIONREASON	1
    DECLARE_DISPATCH_ENTRY(_apszGetRevocationReason)

#define ADMIN_REVOKECERTIFICATE		2
    DECLARE_DISPATCH_ENTRY(_apszRevokeCertificate)

#define ADMIN_SETREQUESTATTRIBUTES	3
    DECLARE_DISPATCH_ENTRY(_apszSetRequestAttributes)

#define ADMIN_SETCERTIFICATEEXTENSION	4
    DECLARE_DISPATCH_ENTRY(_apszSetCertificateExtension)

#define ADMIN_DENYREQUEST		5
    DECLARE_DISPATCH_ENTRY(_apszDenyRequest)

#define ADMIN_RESUBMITREQUEST		6
    DECLARE_DISPATCH_ENTRY(_apszResubmitRequest)

#define ADMIN_PUBLISHCRL		7
    DECLARE_DISPATCH_ENTRY(_apszPublishCRL)

#define ADMIN_GETCRL			8
    DECLARE_DISPATCH_ENTRY(_apszGetCRL)

#define ADMIN_IMPORTCERTIFICATE 	9
    DECLARE_DISPATCH_ENTRY(_apszImportCertificate)

#define ADMIN2_PUBLISHCRLS 		10
    DECLARE_DISPATCH_ENTRY(_apszPublishCRLs)

#define ADMIN2_GETCAPROPERTY 		11
    DECLARE_DISPATCH_ENTRY(_apszGetCAProperty)

#define ADMIN2_SETCAPROPERTY 		12
    DECLARE_DISPATCH_ENTRY(_apszSetCAProperty)

#define ADMIN2_GETCAPROPERTYFLAGS 	13
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyFlags)

#define ADMIN2_GETCAPROPERTYDISPLAYNAME	14
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyDisplayName)

#define ADMIN2_GETARCHIVEDKEY		15
    DECLARE_DISPATCH_ENTRY(_apszGetArchivedKey)

#define ADMIN2_GETCONFIGENTRY		16
    DECLARE_DISPATCH_ENTRY(_apszGetConfigEntry)

#define ADMIN2_SETCONFIGENTRY		17
    DECLARE_DISPATCH_ENTRY(_apszSetConfigEntry)

#define ADMIN2_IMPORTKEY		18
    DECLARE_DISPATCH_ENTRY(_apszImportKey)

#define ADMIN2_GETMYROLES		19
    DECLARE_DISPATCH_ENTRY(_apszGetMyRoles)

#define ADMIN2_DELETEROW		20
    DECLARE_DISPATCH_ENTRY(_apszDeleteRow)
};
#define CADMINDISPATCH	(ARRAYSIZE(s_adtAdmin))
#define CADMINDISPATCH_V1	ADMIN2_PUBLISHCRLS
#define CADMINDISPATCH_V2	CADMINDISPATCH


DWORD s_acAdminDispatch[] = {
    CADMINDISPATCH_V2,
    CADMINDISPATCH_V1,
};

IID const *s_apAdminiid[] = {
    &IID_ICertAdmin2,
    &IID_ICertAdmin,
};


HRESULT
Admin_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiAdmin)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTADMIN,
		&CLSID_CCertAdmin,
		ARRAYSIZE(s_acAdminDispatch),		// cver
		s_apAdminiid,
		s_acAdminDispatch,
		s_adtAdmin,
		pdiAdmin);
    _JumpIfError(hr, error, "DispatchSetup2(ICertAdmin)");

error:
    return(hr);
}


VOID
Admin_Release(
    IN OUT DISPATCHINTERFACE *pdiAdmin)
{
    DispatchRelease(pdiAdmin);
}


HRESULT
AdminVerifyVersion(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    switch (pdiAdmin->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiAdmin->pDispatch ||
		CADMINDISPATCH_V1 == pdiAdmin->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiAdmin->pDispatch ||
		CADMINDISPATCH_V2 == pdiAdmin->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiAdmin->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Admin_IsValidCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strSerialNumber, pwszSerialNumber, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strSerialNumber;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_ISVALIDCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(IsValidCertificate)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->IsValidCertificate(
							    strConfig,
							    strSerialNumber,
							    pDisposition);

	_JumpIfError(hr, error, "ICertAdmin::IsValidCertificate");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
Admin_GetRevocationReason(
    IN DISPATCHINTERFACE *pdiAdmin,
    OUT LONG *pReason)
{
    HRESULT hr;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (NULL != pdiAdmin->pDispatch)
    {
	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_GETREVOCATIONREASON,
			0,
			NULL,
			VT_I4,
			pReason);
	_JumpIfError(hr, error, "Invoke(GetRevocationReason)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->GetRevocationReason(pReason);
	_JumpIfError(hr, error, "ICertAdmin::GetRevocationReason");
    }

error:
    return(hr);
}


HRESULT
Admin_RevokeCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strSerialNumber, pwszSerialNumber, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strSerialNumber;
	avar[2].vt = VT_I4;
	avar[2].lVal = Reason;
	avar[3].vt = VT_DATE;
	avar[3].date = Date;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_REVOKECERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(RevokeCertificate)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->RevokeCertificate(
							    strConfig,
							    strSerialNumber,
							    Reason,
							    Date);
	_JumpIfError(hr, error, "ICertAdmin::RevokeCertificate");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
Admin_SetRequestAttributes(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszAttributes)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strAttributes = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strAttributes, pwszAttributes, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;
	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strAttributes;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_SETREQUESTATTRIBUTES,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetRequestAttributes)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->SetRequestAttributes(
								strConfig,
								RequestId,
								strAttributes);

	_JumpIfError(hr, error, "ICertAdmin::SetRequestAttributes");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strAttributes)
    {
	SysFreeString(strAttributes);
    }
    return(hr);
}


HRESULT
Admin_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG Flags,
    IN VARIANT const *pvarValue)

{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strExtensionName = NULL;

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strExtensionName, pwszExtensionName, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[6];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strExtensionName;

	avar[3].vt = VT_I4;
	avar[3].lVal = Type;

	avar[4].vt = VT_I4;
	avar[4].lVal = Flags;

	avar[5].vt = VT_VARIANT | VT_BYREF;
	avar[5].pvarVal = (VARIANT *) pvarValue;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_SETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetCertificateExtension)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->SetCertificateExtension(
							    strConfig,
							    RequestId,
							    strExtensionName,
							    Type,
							    Flags,
							    pvarValue);
	_JumpIfError(hr, error, "ICertAdmin::SetCertificateExtension");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strExtensionName)
    {
	SysFreeString(strExtensionName);
    }
    return(hr);
}


HRESULT
Admin_DenyRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_DENYREQUEST,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(DenyRequest)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->DenyRequest(
							strConfig,
							RequestId);
	_JumpIfError(hr, error, "ICertAdmin::DenyRequest");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_ResubmitRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_RESUBMITREQUEST,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(ResubmitRequest)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->ResubmitRequest(
							strConfig,
							RequestId,
							pDisposition);
	_JumpIfError(hr, error, "ICertAdmin::ResubmitRequest");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_PublishCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_DATE;
	avar[1].date = Date;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_PUBLISHCRL,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(PublishCRL)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->PublishCRL(
                                                         strConfig,
                                                         Date);
	_JumpIfError(hr, error, "ICertAdmin::PublishCRL");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin2_PublishCRLs(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date,
    IN LONG CRLFlags)		// CA_CRL_*
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_DATE;
	avar[1].date = Date;

	avar[2].vt = VT_I4;
	avar[2].date = CRLFlags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_PUBLISHCRLS,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(PublishCRLs)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->PublishCRLs(
                                                         strConfig,
                                                         Date,
							 CRLFlags);
	_JumpIfError(hr, error, "ICertAdmin2::PublishCRLs");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_GetCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,
    OUT BSTR *pstrCRL)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_GETCRL,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrCRL);
	_JumpIfError(hr, error, "Invoke(GetCRL)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->GetCRL(
						    strConfig,
						    Flags,
						    pstrCRL);
	_JumpIfError(hr, error, "ICertAdmin::GetCRL");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_ImportCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszCertificate,
    IN DWORD cbCertificate,
    IN LONG dwFlags,
    OUT LONG *pRequestId)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strCertificate = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    strCertificate = SysAllocStringByteLen(
				    (CHAR const *) pwszCertificate,
				    cbCertificate);
    if (NULL == strCertificate)
    {
	_JumpError(hr, error, "SysAllocStringByteLen");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strCertificate;
	avar[2].vt = VT_I4;
	avar[2].lVal = dwFlags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_IMPORTCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pRequestId);
	_JumpIfError(hr, error, "Invoke(ImportCertificate)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->ImportCertificate(
						    strConfig,
						    strCertificate,
						    dwFlags,
						    pRequestId);
	_JumpIfError3(
		    hr,
		    error,
		    "ICertAdmin::ImportCertificate",
		    NTE_BAD_SIGNATURE,
		    HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strCertificate)
    {
	SysFreeString(strCertificate);
    }
    return(hr);
}


HRESULT
AdminRevokeCertificate(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date)
{
    HRESULT hr;
    LONG count;
    DISPATCHINTERFACE diAdmin;
    BSTR strConfig = NULL;
    
    if (NULL == pwszConfig)
    {
	hr = ConfigGetConfig(Flags, CC_LOCALACTIVECONFIG, &strConfig);
	_JumpIfError(hr, error, "ConfigGetConfig");

	pwszConfig = strConfig;
    }
    hr = Admin_Init(Flags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    hr = Admin_RevokeCertificate(
			    &diAdmin,
			    pwszConfig,
			    pwszSerialNumber,
			    Reason,
			    Date);
    _JumpIfError(hr, error, "Admin_RevokeCertificate");

error:
    Admin_Release(&diAdmin);
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


#define CCERTADMIN
#include "prop2.cpp"

#if 0
HRESULT
Admin2_SetCAProperty(
    IN WCHAR const *pwszConfig,
    IN LONG PropId,		// CR_PROP_*
    IN LONG PropIndex,
    IN LONG PropType,		// PROPTYPE_*
    IN VARIANT *pvarPropertyValue)
{
}
#endif


HRESULT
Admin2_GetArchivedKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,		// CR_OUT_*
    OUT BSTR *pstrArchivedKey)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;
	avar[2].vt = VT_I4;
	avar[2].lVal = Flags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_GETARCHIVEDKEY,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrArchivedKey);
	_JumpIfError(hr, error, "Invoke(GetArchivedKey)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->GetArchivedKey(
						    strConfig,
						    RequestId,
						    Flags,
						    pstrArchivedKey);
	_JumpIfError(hr, error, "ICertAdmin::GetArchivedKey");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


#if 0
HRESULT
Admin2_GetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    OUT VARIANT *pvarEntry)
{
}
#endif


#if 0
HRESULT
Admin2_SetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    IN VARIANT const *pvarEntry)
{
}
#endif


HRESULT
Admin2_ImportKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszCertHash,
    IN LONG Flags,
    IN WCHAR const *pwszKey,
    IN DWORD cbKey)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strCertHash = NULL;
    BSTR strKey = NULL;

    if (NULL == pwszKey || NULL == pwszConfig)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "NULL parm");
    }
    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pwszCertHash)
    {
	if (!ConvertWszToBstr(&strCertHash, pwszCertHash, -1))
	{
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }
    strKey = SysAllocStringByteLen((CHAR const *) pwszKey, cbKey);
    if (NULL == strKey)
    {
	_JumpError(hr, error, "SysAllocStringByteLen");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[5];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strCertHash;

	avar[3].vt = VT_I4;
	avar[3].lVal = Flags;

	avar[4].vt = VT_BSTR;
	avar[4].bstrVal = strKey;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_IMPORTKEY,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(ImportKey)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->ImportKey(
							strConfig,
							RequestId,
							strCertHash,
							Flags,
							strKey);
	_JumpIfError2(
		hr,
		error,
		"ICertAdmin::ImportKey",
		HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strCertHash)
    {
	SysFreeString(strCertHash);
    }
    if (NULL != strKey)
    {
	SysFreeString(strKey);
    }
    return(hr);
}


HRESULT
Admin2_GetMyRoles(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    OUT LONG *pRoles)		// CA_ACCESS_*
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_GETMYROLES,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pRoles);
	_JumpIfError(hr, error, "Invoke(GetMyRoles)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->GetMyRoles(
							strConfig,
							pRoles);
	_JumpIfError(hr, error, "ICertAdmin::GetMyRoles");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin2_DeleteRow(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,		// CDR_*
    IN DATE Date,
    IN LONG Table,		// CVRC_TABLE_*
    IN LONG RowId,
    OUT LONG *pcDeleted)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[5];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;
	avar[2].vt = VT_DATE;
	avar[2].date = Date;
	avar[3].vt = VT_I4;
	avar[3].lVal = Table;
	avar[4].vt = VT_I4;
	avar[4].lVal = RowId;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_DELETEROW,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pcDeleted);
	_JumpIfError(hr, error, "Invoke(DeleteRow)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->DeleteRow(
						    strConfig,
						    Flags,
						    Date,
						    Table,
						    RowId,
						    pcDeleted);
	_JumpIfError(hr, error, "ICertAdmin::DeleteRow");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\advapi32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       advapi32.cpp
//
//  Contents:   advapi32.dll wrapper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

typedef BOOL (WINAPI FNSTRINGSDTOSD)(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL);

BOOL
myConvertStringSecurityDescriptorToSecurityDescriptor(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL)
{
    HMODULE hModule;
    BOOL f = FALSE;
    DWORD err;
    static FNSTRINGSDTOSD *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	// load dll
	hModule = GetModuleHandle(TEXT("advapi32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSTRINGSDTOSD *) GetProcAddress(
		       hModule,
		       "ConvertStringSecurityDescriptorToSecurityDescriptorW");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    f = (*s_pfn)(
	    StringSecurityDescriptor,
	    StringSDRevision,
	    SecurityDescriptor,
	    SecurityDescriptorSize);
    if (!f)
        goto error;
    
    myRegisterMemAlloc(
        *SecurityDescriptor, 
        ((NULL == SecurityDescriptorSize) ? -1 : *SecurityDescriptorSize), 
        CSM_LOCALALLOC);
error:
    return(f);
}


typedef BOOL (WINAPI FNSIDTOSTRINGSID)(
    IN  PSID    Sid,
    OUT LPWSTR *StringSid);

BOOL
myConvertSidToStringSid(
    IN  PSID    Sid,
    OUT LPWSTR *StringSid)
{
    HMODULE hModule;
    BOOL f = FALSE;
    DWORD err;
    static FNSIDTOSTRINGSID *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	// load dll
	hModule = GetModuleHandle(TEXT("advapi32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSIDTOSTRINGSID *) GetProcAddress(
					       hModule,
					       "ConvertSidToStringSidW");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    f = (*s_pfn)(Sid, StringSid);
    if (!f)
        goto error;

    myRegisterMemAlloc(*StringSid, -1, CSM_LOCALALLOC);

error:
    return(f);
}


typedef BOOL (WINAPI FNSTRINGSIDTOSID)(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid);

BOOL
myConvertStringSidToSid(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid)
{
    HMODULE hModule;
    BOOL f = FALSE;
    DWORD err;
    static FNSTRINGSIDTOSID *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	// load dll
	hModule = GetModuleHandle(TEXT("advapi32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSTRINGSIDTOSID *) GetProcAddress(
					       hModule,
					       "ConvertStringSidToSidW");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    f = (*s_pfn)(StringSid, Sid);
    if (!f)
        goto error;

    myRegisterMemAlloc(*Sid, -1, CSM_LOCALALLOC);

error:
    return(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certdb.h"
#include "cscsp.h"

#include <esent.h>

#define __dwFILE__	__dwFILE_CERTLIB_BACKUP_CPP__


#define _64k		(64 * 1024)


DWORD
_64kBlocks(
    IN DWORD nFileSizeHigh,
    IN DWORD nFileSizeLow)
{
    LARGE_INTEGER li;

    li.HighPart = nFileSizeHigh;
    li.LowPart = nFileSizeLow;
    return((DWORD) ((li.QuadPart + _64k - 1) / _64k));
}


HRESULT
myLargeAlloc(
    OUT DWORD *pcbLargeAlloc,
    OUT BYTE **ppbLargeAlloc)
{
    HRESULT hr;

    // at 512k the server begins doing efficient backups
    *pcbLargeAlloc = 512 * 1024;
    *ppbLargeAlloc = (BYTE *) VirtualAlloc(
				    NULL,
				    *pcbLargeAlloc,
				    MEM_COMMIT,
				    PAGE_READWRITE);
    if (NULL == *ppbLargeAlloc)
    {
        // couldn't alloc a large chunk?  Try 64k...

	*pcbLargeAlloc = _64k;
        *ppbLargeAlloc = (BYTE *) VirtualAlloc(
					NULL,
					*pcbLargeAlloc,
					MEM_COMMIT,
					PAGE_READWRITE);
        if (NULL == *ppbLargeAlloc)
        {
            hr = myHLastError();
	    _JumpError(hr, error, "VirtualAlloc");
        }
    }
    hr = S_OK;

error:
    return(hr);
}


// Files to look for when checking for an existing DB, AND
// Files to delete when clearing out a DB or DB Log directory:
// Do NOT delete certsrv.mdb from Cert server 1.0!

WCHAR const * const g_apwszDBFileMatchPatterns[] =
{
    L"res*.log",
    TEXT(szDBBASENAMEPARM) L"*.log",	// "edb*.log"
    TEXT(szDBBASENAMEPARM) L"*.chk",	// "edb*.chk"
    L"*" wszDBFILENAMEEXT,		// "*.edb"
    NULL
};


HRESULT
myDeleteDBFilesInDir(
    IN WCHAR const *pwszDir)
{
    HRESULT hr;
    WCHAR const * const *ppwsz;

    for (ppwsz = g_apwszDBFileMatchPatterns; NULL != *ppwsz; ppwsz++)
    {
	hr = myDeleteFilePattern(pwszDir, *ppwsz, FALSE);
        _JumpIfError(hr, error, "myDeleteFilePattern");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DoFilesExistInDir(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszPattern,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WCHAR *pwszFindPattern = NULL;
    WIN32_FIND_DATA wfd;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    hr = myBuildPathAndExt(pwszDir, pwszPattern, NULL, &pwszFindPattern);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hf = FindFirstFile(pwszFindPattern, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = S_OK;
	goto error;
    }
    do
    {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}

	//printf("File: %ws\n", wfd.cFileName);
	*pfFilesExist = TRUE;

	if (NULL != ppwszFileInUse)
	{
	    WCHAR *pwszFile;

	    hr = myBuildPathAndExt(pwszDir, wfd.cFileName, NULL, &pwszFile);
	    _JumpIfError(hr, error, "myBuildPathAndExt");

	    if (myIsFileInUse(pwszFile))
	    {
		DBGPRINT((
		    DBG_SS_CERTLIB,
		    "DoFilesExistInDir: File In Use: %ws\n",
		    pwszFile));

		*ppwszFileInUse = pwszFile;
		hr = S_OK;
		goto error;
	    }
	    LocalFree(pwszFile);
	}

    } while (FindNextFile(hf, &wfd));
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    if (NULL != pwszFindPattern)
    {
	LocalFree(pwszFindPattern);
    }
    return(hr);
}


HRESULT
myDoDBFilesExistInDir(
    IN WCHAR const *pwszDir,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    WCHAR const * const *ppwsz;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    hr = S_OK;
    for (ppwsz = g_apwszDBFileMatchPatterns; NULL != *ppwsz; ppwsz++)
    {
	BOOL fFilesExist;

	hr = DoFilesExistInDir(
			    pwszDir,
			    *ppwsz,
			    &fFilesExist,
			    ppwszFileInUse);
	_JumpIfError(hr, error, "DoFilesExistInDir");

	if (fFilesExist)
	{
	    *pfFilesExist = TRUE;
	}
	if (NULL != ppwszFileInUse && NULL != *ppwszFileInUse)
	{
	    break;
	}
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
DoDBFilesExistInRegDir(
    IN WCHAR const *pwszRegName,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    WCHAR *pwszDir = NULL;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    hr = myGetCertRegStrValue(NULL, NULL, NULL, pwszRegName, &pwszDir);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // reg entry doesn't exist, that's fine
            goto done;
        }
        _JumpError(hr, error, "myGetCertRegStrValue");
    }

    hr = myDoDBFilesExistInDir(pwszDir, pfFilesExist, ppwszFileInUse);
    _JumpIfError(hr, error, "myDoDBFilesExistInDir");

done:
    hr = S_OK;
error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    return(hr);
}


HRESULT
BuildDBFileName(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszDBFile)
{
    HRESULT hr;
    WCHAR *pwszDir = NULL;

    *ppwszDBFile = NULL;

    // get existing db path

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBDIRECTORY, &pwszDir);
    _JumpIfError(hr, error, "myGetCertRegStrValue");

    // form existing db file path
    hr = myBuildPathAndExt(
		    pwszDir,
		    pwszSanitizedName,
		    wszDBFILENAMEEXT,
		    ppwszDBFile);
    _JumpIfError(hr, error, "myBuildPathAndExt");

error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    return(hr);
}


WCHAR const * const g_apwszDBRegNames[] =
{
    wszREGDBDIRECTORY,
    wszREGDBLOGDIRECTORY,
    wszREGDBSYSDIRECTORY,
    wszREGDBTEMPDIRECTORY,
    NULL
};


// Verify that the DB and DB Log directories in the registry contain existing
// DB files, to decide whether the DB could be reused by cert server setup.
// Also see if any of the DB files are in use -- we don't want to point to the
// same directory as the DS DB and trash the DS, for example.

HRESULT
myDoDBFilesExist(
    IN WCHAR const *pwszSanitizedName,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    WCHAR const * const *ppwsz;
    WCHAR *pwszDBFile = NULL;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    // this is very primitive, just check for existence

    // get existing db file path

    hr = BuildDBFileName(pwszSanitizedName, &pwszDBFile);
    if (S_OK == hr)
    {
	// If the main DB file doesn't exist, there's no point in continuing!

	if (!myDoesFileExist(pwszDBFile))
	{
	    CSASSERT(S_OK == hr);
	    goto error;
	}
	*pfFilesExist = TRUE;

	if (NULL != ppwszFileInUse && myIsFileInUse(pwszDBFile))
	{
	    *ppwszFileInUse = pwszDBFile;
	    pwszDBFile = NULL;
	    CSASSERT(S_OK == hr);
	    goto error;
	}
    }
    else
    {
        _PrintError(hr, "BuildDBFileName");
    }

    for (ppwsz = g_apwszDBRegNames; NULL != *ppwsz; ppwsz++)
    {
	BOOL fFilesExist;

	hr = DoDBFilesExistInRegDir(*ppwsz, &fFilesExist, ppwszFileInUse);
	_JumpIfError(hr, error, "DoDBFilesExistInRegDir");

	if (fFilesExist)
	{
	    *pfFilesExist = TRUE;
	}
	if (NULL != ppwszFileInUse && NULL != *ppwszFileInUse)
	{
	    CSASSERT(S_OK == hr);
	    goto error;
	}
    }
    CSASSERT(S_OK == hr);

error:
    if (NULL != pwszDBFile)
    {
        LocalFree(pwszDBFile);
    }
    return(hr);
}


HRESULT
BackupCopyDBFile(
    IN HCSBC hcsbc,
    IN WCHAR const *pwszDBFile,
    IN WCHAR const *pwszBackupFile,
    IN DWORD dwPercentCompleteBase,
    IN DWORD dwPercentCompleteDelta,
    OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    HRESULT hr2;
    HANDLE hFileBackup = INVALID_HANDLE_VALUE;
    BOOL fOpen = FALSE;
    LARGE_INTEGER licbFile;
    DWORD cbRead;
    DWORD cbWritten;
    DWORD dwPercentCompleteCurrent;
    DWORD ReadLoopMax;
    DWORD ReadLoopCurrent;
    DWORD cbLargeAlloc;
    BYTE *pbLargeAlloc = NULL;

    hr = myLargeAlloc(&cbLargeAlloc, &pbLargeAlloc);
    _JumpIfError(hr, error, "myLargeAlloc");

    //printf("Copy %ws to %ws\n", pwszDBFile, pwszBackupFile);

    hr = CertSrvBackupOpenFile(hcsbc, pwszDBFile, cbLargeAlloc, &licbFile);
    _JumpIfError(hr, error, "CertSrvBackupOpenFile");

    fOpen = TRUE;

    hFileBackup = CreateFile(
			pwszBackupFile,
			GENERIC_WRITE,
			0,
			NULL,
			CREATE_NEW,
			0,
			NULL);
    if (hFileBackup == INVALID_HANDLE_VALUE)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszBackupFile);
    }

    dwPercentCompleteCurrent = dwPercentCompleteBase;
    ReadLoopMax =
	(DWORD) ((licbFile.QuadPart + cbLargeAlloc - 1) / cbLargeAlloc);

    //printf("BackupDBFile: Percent per Read = %u, read count = %u\n", dwPercentCompleteDelta / ReadLoopMax, ReadLoopMax);

    ReadLoopCurrent = 0;

    while (0 != licbFile.QuadPart)
    {
	hr = CertSrvBackupRead(hcsbc, pbLargeAlloc, cbLargeAlloc, &cbRead);
	_JumpIfError(hr, error, "CertSrvBackupRead");

	//printf("CertSrvBackupRead(%x)\n", cbRead);

	if (!WriteFile(hFileBackup, pbLargeAlloc, cbRead, &cbWritten, NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "WriteFile", pwszBackupFile);
	}
	if (cbWritten != cbRead)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
	    _JumpErrorStr(hr, error, "WriteFile", pwszBackupFile);
	}
	licbFile.QuadPart -= cbRead;

	ReadLoopCurrent++;

	dwPercentCompleteCurrent =
		dwPercentCompleteBase +
		(ReadLoopCurrent * dwPercentCompleteDelta) / ReadLoopMax;
	CSASSERT(dwPercentCompleteCurrent <= dwPercentCompleteBase + dwPercentCompleteDelta);
	CSASSERT(*pdwPercentComplete <= dwPercentCompleteCurrent);
	*pdwPercentComplete = dwPercentCompleteCurrent;
	//printf("BackupDBFile: PercentComplete = %u\n", *pdwPercentComplete);
    }
    CSASSERT(*pdwPercentComplete <= dwPercentCompleteBase + dwPercentCompleteDelta);
    *pdwPercentComplete = dwPercentCompleteBase + dwPercentCompleteDelta;
    //printf("BackupDBFile: PercentComplete = %u (EOF)\n", *pdwPercentComplete);

error:
    if (INVALID_HANDLE_VALUE != hFileBackup)
    {
	CloseHandle(hFileBackup);
    }
    if (fOpen)
    {
	hr2 = CertSrvBackupClose(hcsbc);
	_PrintIfError(hr2, "CertSrvBackupClose");
    }
    if (NULL != pbLargeAlloc)
    {
	VirtualFree(pbLargeAlloc, 0, MEM_RELEASE);
    }
    return(hr);
}


HRESULT
BackupDBFileList(
    IN HCSBC hcsbc,
    IN BOOL fDBFiles,
    IN WCHAR const *pwszDir,
    OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    WCHAR *pwszzList = NULL;
    WCHAR const *pwsz;
    DWORD cfile;
    DWORD cb;
    WCHAR const *pwszFile;
    WCHAR wszPath[MAX_PATH];
    DWORD dwPercentCompleteCurrent;
    DWORD dwPercentComplete1File;

    if (fDBFiles)
    {
	hr = CertSrvBackupGetDatabaseNames(hcsbc, &pwszzList, &cb);
	_JumpIfError(hr, error, "CertSrvBackupGetDatabaseNames");
    }
    else
    {
	hr = CertSrvBackupGetBackupLogs(hcsbc, &pwszzList, &cb);
	_JumpIfError(hr, error, "CertSrvBackupGetBackupLogs");
    }

    // prefix complains this might happen, then deref'd below
    if (pwszzList == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "BackupDBFileList");
    }

    cfile = 0;
    for (pwsz = pwszzList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	cfile++;
    }
    if (0 != cfile)
    {
	dwPercentCompleteCurrent = 0;
	dwPercentComplete1File = 100 / cfile;
	//printf("BackupDBFileList: Percent per File = %u\n", dwPercentComplete1File);
	for (pwsz = pwszzList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    pwszFile = wcsrchr(pwsz, L'\\');
	    if (NULL == pwszFile)
	    {
		pwszFile = pwsz;
	    }
	    else
	    {
		pwszFile++;
	    }
	    wcscpy(wszPath, pwszDir);
	    wcscat(wszPath, L"\\");
	    wcscat(wszPath, pwszFile);

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"BackupDBFileList: %x %ws -> %ws\n",
		*pwsz,
		&pwsz[1],
		wszPath));

	    hr = BackupCopyDBFile(
			    hcsbc,
			    &pwsz[1],
			    wszPath,
			    dwPercentCompleteCurrent,
			    dwPercentComplete1File,
			    pdwPercentComplete);
	    _JumpIfError(hr, error, "BackupCopyDBFile");

	    dwPercentCompleteCurrent += dwPercentComplete1File;
	    CSASSERT(*pdwPercentComplete == dwPercentCompleteCurrent);
	    //printf("BackupDBFileList: PercentComplete = %u\n", *pdwPercentComplete);
	}
    }
    CSASSERT(*pdwPercentComplete <= 100);
    *pdwPercentComplete = 100;
    //printf("BackupDBFileList: PercentComplete = %u (END)\n", *pdwPercentComplete);
    hr = S_OK;

error:
    if (NULL != pwszzList)
    {
	CertSrvBackupFree(pwszzList);
    }
    return(hr);
}


BOOL
myIsDirEmpty(
    IN WCHAR const *pwszDir)
{
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR wszpath[MAX_PATH];
    BOOL fEmpty = TRUE;

    wszpath[0] = L'\0';
    wcscpy(wszpath, pwszDir);
    wcscat(wszpath, L"\\*.*");

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE != hf)
    {
	do {
	    if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	    {
		continue;
	    }
	    fEmpty = FALSE;
	    //printf("File: %ws\n", wfd.cFileName);
	    break;

	} while (FindNextFile(hf, &wfd));
	FindClose(hf);
    }
    return(fEmpty);
}


HRESULT
myForceDirEmpty(
    IN WCHAR const *pwszDir)
{
    HRESULT hr;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR *pwszFile;
    WCHAR wszpath[MAX_PATH];
    wszpath[0] = L'\0';

    wcscpy(wszpath, pwszDir);
    wcscat(wszpath, L"\\*.*");
    pwszFile = &wszpath[wcslen(pwszDir)] + 1;

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "FindFirstFile");
    }
    do {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}
	wcscpy(pwszFile, wfd.cFileName);
	//printf("File: %ws\n", wszpath);
	DeleteFile(wszpath);

    } while (FindNextFile(hf, &wfd));
    FindClose(hf);

    hr = S_OK;

error:
    return(hr);
}


BOOL
myIsDirectory(IN WCHAR const *pwszDirectoryPath)
{
    WIN32_FILE_ATTRIBUTE_DATA data;

    return(
	GetFileAttributesEx(pwszDirectoryPath, GetFileExInfoStandard, &data) &&
	(FILE_ATTRIBUTE_DIRECTORY & data.dwFileAttributes));
}


BOOL
myIsFileInUse(
    IN WCHAR const *pwszFile)
{
    BOOL fInUse = FALSE;
    HANDLE hFile;
    
    hFile = CreateFile(
                pwszFile,
                GENERIC_WRITE, // dwDesiredAccess
                0,             // no share
                NULL,          // lpSecurityAttributes
                OPEN_EXISTING, // open only & fail if doesn't exist
                0,             // dwFlagAndAttributes
                NULL);         // hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
        if (ERROR_SHARING_VIOLATION == GetLastError())
        {
            fInUse = TRUE;
        }
    }
    else
    {
        CloseHandle(hFile);
    }
    return(fInUse);
}


HRESULT
myCreateBackupDir(
    IN WCHAR const *pwszDir,
    IN BOOL fForceOverWrite)
{
    HRESULT hr;

    if (!myIsDirectory(pwszDir))
    {
        if (!CreateDirectory(pwszDir, NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
            {
                _JumpErrorStr(hr, error, "CreateDirectory", pwszDir);
            }
        } // else dir created successfully
    } // else dir already exists

    if (!myIsDirEmpty(pwszDir))
    {
	if (!fForceOverWrite)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
	    _JumpErrorStr(hr, error, "myIsDirEmpty", pwszDir);
	}
	hr = myForceDirEmpty(pwszDir);
	_JumpIfErrorStr(hr, error, "myForceDirEmpty", pwszDir);

	if (!myIsDirEmpty(pwszDir))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
	    _JumpErrorStr(hr, error, "myIsDirEmpty", pwszDir);
	}
    } // else is empty

    hr = S_OK;

error:
    return(hr);
}


// if Flags & CDBBACKUP_VERIFYONLY, create and verify the target directory is empty

HRESULT
myBackupDB(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fServerOnline;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    WCHAR *pwszPathDBDir = NULL;
    WCHAR *pwszDATFile = NULL;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    DBBACKUPPROGRESS dbp;
    LONG grbitJet;
    LONG BackupFlags;
    BOOL fImpersonating = FALSE;
    
    if (NULL == pwszConfig)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "NULL pwszConfig");
    }
    
    if (NULL == pdbp)
    {
        pdbp = &dbp;
    }
    ZeroMemory(pdbp, sizeof(*pdbp));
    
    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;
    
    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");
    
    if (NULL == pwszBackupDir)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    if (~CDBBACKUP_BACKUPVALID & Flags)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Flags");
    }
    
    if (!myIsDirectory(pwszBackupDir))
    {
        if (!CreateDirectory(pwszBackupDir, NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
            {
                _JumpError(hr, error, "CreateDirectory");
            }
        }
    }
    
    hr = myBuildPathAndExt(
        pwszBackupDir,
        wszDBBACKUPSUBDIR,
        NULL,
        &pwszPathDBDir);
    _JumpIfError(hr, error, "myBuildPathAndExt");
    
    hr = myCreateBackupDir(
        pwszPathDBDir,
        (CDBBACKUP_OVERWRITE & Flags)? TRUE : FALSE);
    _JumpIfError(hr, error, "myCreateBackupDir");
    
    //if (NULL != pwszConfig)
    if (0 == (Flags & CDBBACKUP_VERIFYONLY))
    {
        hr = CertSrvIsServerOnline(pwszConfig, &fServerOnline);
        _JumpIfError(hr, error, "CertSrvIsServerOnline");
        
        //printf("Cert Server Online -> %d\n", fServerOnline);
        
        if (!fServerOnline)
        {
            hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
            _JumpError(hr, error, "CertSrvIsServerOnline");
        }
        
        BackupFlags = CSBACKUP_TYPE_FULL;
        grbitJet = 0;
        if (CDBBACKUP_INCREMENTAL & Flags)
        {
            grbitJet |= JET_bitBackupIncremental;
            BackupFlags = CSBACKUP_TYPE_LOGS_ONLY;
        }
        if (CDBBACKUP_KEEPOLDLOGS & Flags)
        {
            // JetBeginExternalBackup can't handle setting this bit
            // grbitJet |= JET_bitKeepOldLogs;
        }
        
        hr = CertSrvBackupPrepare(pwszConfig, grbitJet, BackupFlags, &hcsbc);
        _JumpIfError(hr, error, "CertSrvBackupPrepare");
        
        fBegin = TRUE;
        
        if (0 == (CDBBACKUP_INCREMENTAL & Flags))
        {
            hr = CertSrvRestoreGetDatabaseLocations(hcsbc, &pwszzFileList, &cbList);
            _JumpIfError(hr, error, "CertSrvRestoreGetDatabaseLocations");
            
            hr = myBuildPathAndExt(
                pwszPathDBDir,
                wszDBBACKUPCERTBACKDAT,
                NULL,
                &pwszDATFile);
            _JumpIfError(hr, error, "myBuildPathAndExt");
            
            hr = EncodeToFileW(
                pwszDATFile,
                (BYTE const *) pwszzFileList,
                cbList,
                CRYPT_STRING_BINARY);
            _JumpIfError(hr, error, "EncodeToFileW");
            
            hr = BackupDBFileList(
                hcsbc,
                TRUE,
                pwszPathDBDir,
                &pdbp->dwDBPercentComplete);
            _JumpIfError(hr, error, "BackupDBFileList(DB)");
        }
        else
        {
            pdbp->dwDBPercentComplete = 100;
        }
        //printf("DB Done: dwDBPercentComplete = %u\n", pdbp->dwDBPercentComplete);
        
        hr = BackupDBFileList(
            hcsbc,
            FALSE,
            pwszPathDBDir,
            &pdbp->dwLogPercentComplete);
        _JumpIfError(hr, error, "BackupDBFileList(Log)");
        //printf("Log Done: dwLogPercentComplete = %u\n", pdbp->dwLogPercentComplete);
        
        if (0 == (CDBBACKUP_KEEPOLDLOGS & Flags))
        {
            hr = CertSrvBackupTruncateLogs(hcsbc);
            _JumpIfError(hr, error, "CertSrvBackupTruncateLogs");
        }
        pdbp->dwTruncateLogPercentComplete = 100;
        //printf("Truncate Done: dwTruncateLogPercentComplete = %u\n", pdbp->dwTruncateLogPercentComplete);
    }
    
error:
    if (NULL != pwszzFileList)
    {
        CertSrvBackupFree(pwszzFileList);
    }
    if (fBegin)
    {
        hr2 = CertSrvBackupEnd(hcsbc);
        _PrintIfError(hr2, "CertSrvBackupEnd");
        if (S_OK == hr)
        {
            hr = hr2;
        }
    }
    if (NULL != pwszDATFile)
    {
        LocalFree(pwszDATFile);
    }
    if (NULL != pwszPathDBDir)
    {
        LocalFree(pwszPathDBDir);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


// Verify the backup file names only, and return the log file numeric range.

HRESULT
myVerifyBackupDirectory(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszPathDBDir,
    OUT DWORD *plogMin,
    OUT DWORD *plogMax,
    OUT DWORD *pc64kDBBlocks,	// 64k blocks in DB files to be restored
    OUT DWORD *pc64kLogBlocks)	// 64k blocks in Log files to be restored
{
    HRESULT hr;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA wfd;
    WCHAR wszpath[2 * MAX_PATH];
    WCHAR wszfile[MAX_PATH];
    BOOL fSawEDBFile = FALSE;
    BOOL fSawDatFile = FALSE;
    DWORD cLogFiles = 0;
    WCHAR *pwszCA;
    WCHAR *pwszRevertCA = NULL;
    WCHAR *pwszSanitizedCA = NULL;
    WCHAR *pwszExt;
    WCHAR *pwsz;
    DWORD log;

    *plogMin = MAXDWORD;
    *plogMax = 0;
    *pc64kDBBlocks = 0;
    *pc64kLogBlocks = 0;
    wszpath[0] = L'\0'; 

    pwszCA = wcschr(pwszConfig, L'\\');
    if (NULL != pwszCA)
    {
	pwszCA++;	// point to CA Name

	hr = myRevertSanitizeName(pwszCA, &pwszRevertCA);
	_JumpIfError(hr, error, "myRevertSanitizeName");

	hr = mySanitizeName(pwszRevertCA, &pwszSanitizedCA);
	_JumpIfError(hr, error, "mySanitizeName");
    }

    wcscpy(wszpath, pwszPathDBDir);
    wcscat(wszpath, L"\\*.*");

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "missing backup files");
    }

    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
    do {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}
	//printf("File: %ws\n", wfd.cFileName);

	wcscpy(wszfile, wfd.cFileName);

	pwszExt = wcsrchr(wszfile, L'.');
	if (NULL == pwszExt)
	{
	    _JumpError(hr, error, "file missing extension");
	}
	*pwszExt++ = L'\0';

	if (0 == lstrcmpi(&wszLOGFILENAMEEXT[1], pwszExt))
	{
	    if (0 != _wcsnicmp(wszfile, wszDBBASENAMEPARM, 3))
	    {
		_JumpErrorStr(hr, error, "bad log prefix", wfd.cFileName);
	    }
	    for (pwsz = &wszfile[3]; L'\0' != *pwsz; pwsz++)
	    {
		if (!iswxdigit(*pwsz))
		{
		    _JumpErrorStr(hr, error, "bad name digit", wfd.cFileName);
		}
	    }
	    log = wcstoul(&wszfile[3], NULL, 16);
	    if (log > *plogMax)
	    {
		//printf("Log %x: max = %x -> %x\n", log, *plogMax, log);
		*plogMax = log;
	    }
	    if (log < *plogMin)
	    {
		//printf("Log %x: min = %x -> %x\n", log, *plogMin, log);
		*plogMin = log;
	    }
	    *pc64kLogBlocks += _64kBlocks(wfd.nFileSizeHigh, wfd.nFileSizeLow);
	    cLogFiles++;
	}
	else
	if (0 == lstrcmpi(&wszDBFILENAMEEXT[1], pwszExt))
	{
	    if (fSawEDBFile)
	    {
		_JumpError(hr, error, "multiple *.edb files");
	    }
	    if (NULL != pwszSanitizedCA &&
		0 != lstrcmpi(wszfile, pwszSanitizedCA))
	    {
		_PrintErrorStr(hr, "expected base name", pwszSanitizedCA);
		_JumpErrorStr(hr, error, "base name mismatch", wfd.cFileName);
	    }
	    *pc64kDBBlocks += _64kBlocks(wfd.nFileSizeHigh, wfd.nFileSizeLow);
	    fSawEDBFile = TRUE;
	}
	else
	if (0 == lstrcmpi(&wszDATFILENAMEEXT[1], pwszExt))
	{
	    if (fSawDatFile)
	    {
		_JumpError(hr, error, "multiple *.dat files");
	    }
	    if (lstrcmpi(wfd.cFileName, wszDBBACKUPCERTBACKDAT))
	    {
		_JumpErrorStr(hr, error, "unexpected file", wfd.cFileName);
	    }
	    fSawDatFile = TRUE;
	}
	else
	{
	    _JumpErrorStr(hr, error, "unexpected extension", wfd.cFileName);
	}
    } while (FindNextFile(hf, &wfd));

    //printf("clog=%u: %u - %u  edb=%u\n", cLogFiles, *plogMin, *plogMax, fSawEDBFile);

    if (0 == cLogFiles)
    {
	_JumpError(hr, error, "missing log file(s)");
    }
    if (0 == (CDBBACKUP_INCREMENTAL & Flags))
    {
	if (!fSawEDBFile || !fSawDatFile)
	{
	    _JumpError(hr, error, "missing full backup file(s)");
	}
    }
    else
    {
	if (fSawEDBFile || fSawDatFile)
	{
	    _JumpError(hr, error, "unexpected incremental backup file(s)");
	}
    }

    if (*plogMax - *plogMin + 1 != cLogFiles)
    {
	_JumpError(hr, error, "missing log file(s)");
    }
    hr = S_OK;

error:
    if (NULL != pwszRevertCA)
    {
	LocalFree(pwszRevertCA);
    }
    if (NULL != pwszSanitizedCA)
    {
	LocalFree(pwszSanitizedCA);
    }
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    return(hr);
}


HRESULT
myGetRegUNCDBDir(
    IN HKEY hkey,
    IN WCHAR const *pwszReg,
    OPTIONAL IN WCHAR const *pwszServer,
    IN WCHAR const **ppwszUNCDir)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;
    WCHAR *pwszDir = NULL;
    WCHAR *pwszUNCDir;

    *ppwszUNCDir = NULL;
    hr = RegQueryValueEx(hkey, pwszReg, NULL, &dwType, NULL, &cb);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpErrorStr(hr, error, "RegQueryValueEx", pwszReg);
    }

    pwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == pwszDir)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = RegQueryValueEx(hkey, pwszReg, NULL, &dwType, (BYTE *) pwszDir, &cb);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpErrorStr(hr, error, "RegQueryValueEx", pwszReg);
    }

    hr = myConvertLocalPathToUNC(pwszServer, pwszDir, &pwszUNCDir);
    _JumpIfError(hr, error, "myConvertLocalPathToUNC");

    *ppwszUNCDir = pwszUNCDir;

error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    return(hr);
}


HRESULT
myCopyUNCPath(
    IN WCHAR const *pwszIn,
    OPTIONAL IN WCHAR const *pwszDnsName,
    OUT WCHAR const **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszOut;
    WCHAR const *pwsz;
    
    *ppwszOut = NULL;

    if (L'\\' != pwszIn[0] || L'\\' != pwszIn[1])
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad parm");
    }
    if (NULL == pwszDnsName)
    {
	hr = myConvertUNCPathToLocal(pwszIn, &pwszOut);
	_JumpIfError(hr, error, "myConvertUNCPathToLocal");
    }
    else
    {
	pwsz = wcschr(&pwszIn[2], L'\\');
	if (NULL == pwsz)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad parm");
	}
	pwszOut = (WCHAR *) LocalAlloc(
		LMEM_FIXED,
		(2 + wcslen(pwszDnsName) + wcslen(pwsz) + 1) * sizeof(WCHAR));
	if (NULL == pwszOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszOut, L"\\\\");
	wcscat(pwszOut, pwszDnsName);
	wcscat(pwszOut, pwsz);
    }
    *ppwszOut = pwszOut;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetDBPaths(
    IN WCHAR const *pwszConfig,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszzFileList,
    OUT WCHAR const **ppwszDBDir,
    OUT WCHAR const **ppwszLogDir,
    OUT WCHAR const **ppwszSystemDir)
{
    HRESULT hr;
    HKEY hkey = NULL;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszRegPath = NULL;
    WCHAR *pwszDBDir = NULL;
    WCHAR const *pwsz;
    WCHAR const *pwszT;
    BOOL fLocal;

    *ppwszDBDir = NULL;
    *ppwszLogDir = NULL;
    *ppwszSystemDir = NULL;

    hr = myIsConfigLocal(pwszConfig, NULL, &fLocal);
    _JumpIfError(hr, error, "myIsConfigLocal");

    if (fLocal)
    {
	pwszConfig = NULL;
    }
    else
    {
	hr = myGetMachineDnsName(&pwszDnsName);
	_JumpIfError(hr, error, "myGetMachineDnsName");
    }

    hr = myRegOpenRelativeKey(
			fLocal? NULL : pwszConfig,
			L"",
			0,
			&pwszRegPath,
			NULL,		// ppwszName
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    // Find old database path:

    pwszT = NULL;
    if (NULL != pwszzFileList)
    {
	for (pwsz = pwszzFileList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (CSBFT_CERTSERVER_DATABASE == *pwsz)
	    {
		pwsz++;
		pwszT = wcsrchr(pwsz, L'\\');
		break;
	    }
	}
    }

    if (NULL != pwszT)
    {
	DWORD cwc = SAFE_SUBTRACT_POINTERS(pwszT, pwsz);

	pwszDBDir = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszDBDir)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszDBDir, pwsz, cwc * sizeof(WCHAR));
	pwszDBDir[cwc] = L'\0';

	hr = myCopyUNCPath(pwszDBDir, pwszDnsName, ppwszDBDir);
	_JumpIfError(hr, error, "myCopyUNCPath");
    }
    else
    {
	hr = myGetRegUNCDBDir(hkey, wszREGDBDIRECTORY, pwszDnsName, ppwszDBDir);
	_JumpIfError(hr, error, "myGetRegUNCDBDir");
    }

    if (NULL != pwszLogPath)
    {
	hr = myCopyUNCPath(pwszLogPath, pwszDnsName, ppwszLogDir);
	_JumpIfError(hr, error, "myCopyUNCPath");
    }
    else
    {
	hr = myGetRegUNCDBDir(
			hkey,
			wszREGDBLOGDIRECTORY,
			pwszDnsName,
			ppwszLogDir);
	_JumpIfError(hr, error, "myGetRegUNCDBDir");
    }

    hr = myGetRegUNCDBDir(
			hkey,
			wszREGDBSYSDIRECTORY,
			pwszDnsName,
			ppwszSystemDir);
    _JumpIfError(hr, error, "myGetRegUNCDBDir");

error:
    if (S_OK != hr)
    {
	if (NULL != *ppwszDBDir)
	{
	    LocalFree(const_cast<WCHAR *>(*ppwszDBDir));
	    *ppwszDBDir = NULL;
	}
	if (NULL != *ppwszLogDir)
	{
	    LocalFree(const_cast<WCHAR *>(*ppwszLogDir));
	    *ppwszLogDir = NULL;
	}
	if (NULL != *ppwszSystemDir)
	{
	    LocalFree(const_cast<WCHAR *>(*ppwszSystemDir));
	    *ppwszSystemDir = NULL;
	}
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszDBDir)
    {
	LocalFree(pwszDBDir);
    }
    if (NULL != pwszRegPath)
    {
	LocalFree(pwszRegPath);
    }
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    return(hr);
}


HRESULT
RestoreCopyFile(
    IN BOOL fForceOverWrite,
    IN WCHAR const *pwszSourceDir,
    IN WCHAR const *pwszTargetDir,
    IN WCHAR const *pwszFile,
    IN DWORD nFileSizeHigh,
    IN DWORD nFileSizeLow,
    IN DWORD c64kBlocksTotal,		// total file size
    IN OUT DWORD *pc64kBlocksCurrent,	// current file size sum
    IN OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    WCHAR *pwszSource = NULL;
    WCHAR *pwszTarget = NULL;
    HANDLE hTarget = INVALID_HANDLE_VALUE;
    HANDLE hSource = INVALID_HANDLE_VALUE;
    DWORD dwPercentCompleteCurrent;
    LARGE_INTEGER licb;
    LARGE_INTEGER licbRead;
    DWORD cbRead;
    DWORD cbWritten;
    DWORD cbLargeAlloc;
    BYTE *pbLargeAlloc = NULL;
    DWORD c64kBlocksFile;
    DWORD dwPercentComplete;

    licb.HighPart = nFileSizeHigh;
    licb.LowPart = nFileSizeLow;

    hr = myBuildPathAndExt(pwszSourceDir, pwszFile, NULL, &pwszSource);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hr = myBuildPathAndExt(pwszTargetDir, pwszFile, NULL, &pwszTarget);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hr = myLargeAlloc(&cbLargeAlloc, &pbLargeAlloc);
    _JumpIfError(hr, error, "myLargeAlloc");

    hSource = CreateFile(
			pwszSource,
			GENERIC_READ,
			0,
			NULL,
			OPEN_EXISTING,
			0,
			NULL);
    if (hSource == INVALID_HANDLE_VALUE)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszSource);
    }
    hTarget = CreateFile(
			pwszTarget,
			GENERIC_WRITE,
			0,
			NULL,
			fForceOverWrite? CREATE_ALWAYS : CREATE_NEW,
			0,
			NULL);
    if (hTarget == INVALID_HANDLE_VALUE)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszTarget);
    }

    licbRead.QuadPart = 0;
    c64kBlocksFile = 0;
    while (licbRead.QuadPart < licb.QuadPart)
    {
	if (!ReadFile(hSource, pbLargeAlloc, cbLargeAlloc, &cbRead, NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "ReadFile");
	}
	//printf("ReadFile(%x)\n", cbRead);

	if (!WriteFile(hTarget, pbLargeAlloc, cbRead, &cbWritten, NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "WriteFile", pwszTarget);
	}
	if (cbWritten != cbRead)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
	    _JumpErrorStr(hr, error, "WriteFile", pwszTarget);
	}
	licbRead.QuadPart += cbRead;

	c64kBlocksFile = _64kBlocks(licbRead.HighPart, licbRead.LowPart);
	dwPercentComplete =
	    (100 * (c64kBlocksFile + *pc64kBlocksCurrent)) / c64kBlocksTotal;

	CSASSERT(*pdwPercentComplete <= dwPercentComplete);
	*pdwPercentComplete = dwPercentComplete;
	//printf("RestoreCopyFile0: PercentComplete = %u\n", *pdwPercentComplete);
    }
    *pc64kBlocksCurrent += c64kBlocksFile;
    dwPercentComplete = (100 * *pc64kBlocksCurrent) / c64kBlocksTotal;
    CSASSERT(*pdwPercentComplete <= dwPercentComplete);
    *pdwPercentComplete = dwPercentComplete;
    //printf("RestoreCopyFile1: PercentComplete = %u\n", *pdwPercentComplete);
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hTarget)
    {
	CloseHandle(hTarget);
    }
    if (INVALID_HANDLE_VALUE != hSource)
    {
	CloseHandle(hSource);
    }
    if (NULL != pwszSource)
    {
	LocalFree(pwszSource);
    }
    if (NULL != pwszTarget)
    {
	LocalFree(pwszTarget);
    }
    if (NULL != pbLargeAlloc)
    {
	VirtualFree(pbLargeAlloc, 0, MEM_RELEASE);
    }
    return(hr);
}


HRESULT
RestoreCopyFilePattern(
    IN BOOL fForceOverWrite,
    IN WCHAR const *pwszSourceDir,
    IN WCHAR const *pwszTargetDir,
    IN WCHAR const *pwszFilePattern,
    IN DWORD c64kBlocksTotal,		// total file size
    IN OUT DWORD *pc64kBlocksCurrent,	// current file size sum
    IN OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    WCHAR *pwszPattern = NULL;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA wfd;
    
    hr = myBuildPathAndExt(pwszSourceDir, pwszFilePattern, NULL, &pwszPattern);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hf = FindFirstFile(pwszPattern, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpErrorStr(hr, error, "missing source files", pwszPattern);
    }

    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
    do {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}
	//printf("File: %ws\n", wfd.cFileName);
	hr = RestoreCopyFile(
			fForceOverWrite,
			pwszSourceDir,		// source dir
			pwszTargetDir,		// target dir
			wfd.cFileName,
			wfd.nFileSizeHigh,
			wfd.nFileSizeLow,
			c64kBlocksTotal,	// total file size
			pc64kBlocksCurrent,	// current file size sum
			pdwPercentComplete);
	_JumpIfError(hr, error, "RestoreCopyFile");

    } while (FindNextFile(hf, &wfd));
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    if (NULL != pwszPattern)
    {
	LocalFree(pwszPattern);
    }
    return(hr);
}


HRESULT
myRestoreDBFiles(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszzFileList,	// NULL if incremental restore
    IN DWORD c64kDBBlocks,
    IN DWORD c64kLogBlocks,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp)
{
    HRESULT hr;
    DWORD i;
#define IDIR_DB		0
#define IDIR_LOG	1
#define IDIR_SYSTEM	2
    WCHAR const *apwszDirs[3] = { NULL, NULL, NULL };
    DWORD c64kBlocksCurrent;
    BOOL fForceOverWrite = 0 != (CDBBACKUP_OVERWRITE & Flags);
    WCHAR *pwszFileInUse = NULL;

    // Get DB, Log & System paths from registry

    hr = myGetDBPaths(
		    pwszConfig,
		    pwszLogPath,
		    pwszzFileList,
		    &apwszDirs[IDIR_DB],
		    &apwszDirs[IDIR_LOG],
		    &apwszDirs[IDIR_SYSTEM]);
    _JumpIfError(hr, error, "myGetDBPaths");

    DBGPRINT((DBG_SS_CERTLIBI, "DBDir:  %ws\n", apwszDirs[IDIR_DB]));
    DBGPRINT((DBG_SS_CERTLIBI, "LogDir: %ws\n", apwszDirs[IDIR_LOG]));
    DBGPRINT((DBG_SS_CERTLIBI, "SysDir: %ws\n", apwszDirs[IDIR_SYSTEM]));

    CSASSERT((NULL == pwszzFileList) ^ (0 == (CDBBACKUP_INCREMENTAL & Flags)));
    for (i = 0; i < ARRAYSIZE(apwszDirs); i++)
    {
	BOOL fFilesExist;

	if (!myIsDirectory(apwszDirs[i]))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
	    _JumpErrorStr(hr, error, "not a directory", apwszDirs[i]);
	}
	hr = myDoDBFilesExistInDir(apwszDirs[i], &fFilesExist, &pwszFileInUse);
	_JumpIfError(hr, error, "myDoDBFilesExistInDir");

	if (NULL != pwszFileInUse)
	{
	    _PrintErrorStr(
		    HRESULT_FROM_WIN32(ERROR_BUSY),
		    "myDoDBFilesExistInDir",
		    pwszFileInUse);
	}
	if (!fFilesExist)
	{
	    if (CDBBACKUP_INCREMENTAL & Flags)
	    {
		// Incremental restore -- some DB files should already exist

		hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
		_JumpErrorStr(hr, error, "myDoDBFilesExistInDir", apwszDirs[i]);
	    }
	}
	else if (0 == (CDBBACKUP_INCREMENTAL & Flags))
	{
	    // Full restore -- no DB files should exist yet

	    if (!fForceOverWrite)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
		_JumpErrorStr(
			hr,
			error,
			"myDoDBFilesExistInDir",
			NULL != pwszFileInUse? pwszFileInUse : apwszDirs[i]);
	    }
	    hr = myDeleteDBFilesInDir(apwszDirs[i]);
	    if (S_OK != hr)
	    {
		_PrintErrorStr(hr, "myDeleteDBFilesInDir", apwszDirs[i]);
	    }
	}
    }

    // copy files to appropriate target directories

    if (0 == (CDBBACKUP_INCREMENTAL & Flags))
    {
	c64kBlocksCurrent = 0;
	hr = RestoreCopyFilePattern(
			fForceOverWrite,
			pwszBackupDir,		// source dir
			apwszDirs[IDIR_DB],	// target dir
			L"*" wszDBFILENAMEEXT,	// match pattern
			c64kDBBlocks,
			&c64kBlocksCurrent,	// current total file size
			&pdbp->dwDBPercentComplete);
	_JumpIfError(hr, error, "RestoreCopyFile");

	CSASSERT(c64kDBBlocks == c64kBlocksCurrent);
    }
    CSASSERT(100 >= pdbp->dwDBPercentComplete);
    pdbp->dwDBPercentComplete = 100;

    c64kBlocksCurrent = 0;
    hr = RestoreCopyFilePattern(
		    fForceOverWrite,
		    pwszBackupDir,		// source dir
		    apwszDirs[IDIR_LOG],	// target dir
		    L"*" wszLOGFILENAMEEXT,	// match pattern
		    c64kLogBlocks,
		    &c64kBlocksCurrent,		// current total file size
		    &pdbp->dwLogPercentComplete);
    _JumpIfError(hr, error, "RestoreCopyFile");

    CSASSERT(c64kLogBlocks == c64kBlocksCurrent);

    CSASSERT(100 >= pdbp->dwLogPercentComplete);
    pdbp->dwLogPercentComplete = 100;

    CSASSERT(100 >= pdbp->dwTruncateLogPercentComplete);
    pdbp->dwTruncateLogPercentComplete = 100;

    hr = S_OK;

error:
    if (NULL != pwszFileInUse)
    {
	LocalFree(pwszFileInUse);
    }
    for (i = 0; i < ARRAYSIZE(apwszDirs); i++)
    {
	if (NULL != apwszDirs[i])
	{
	    LocalFree(const_cast<WCHAR *>(apwszDirs[i]));
	}
    }
    return(hr);
}


HRESULT
myDeleteRestoreInProgressKey(
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    WCHAR *pwszRegPath = NULL;

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszRegPath,
			NULL,		// ppwszName
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    hr = RegDeleteKey(hkey, wszREGKEYRESTOREINPROGRESS);
    _JumpIfError(hr, error, "RegDeleteKey");

error:
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    if (NULL != pwszRegPath)
    {
	LocalFree(pwszRegPath);
    }
    return(hr);
}


// If CDBBACKUP_VERIFYONLY, only verify the passed directory contains valid
// files.  If pwszBackupDir is NULL, delete the RestoreInProgress registry key.

HRESULT
myRestoreDB(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszBackupDir,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR buf[MAX_PATH];
    WCHAR *pwszPathDBDir = NULL;
    WCHAR *pwszDATFile = NULL;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    CSEDB_RSTMAP RstMap[1];
    DWORD crstmap = 0;
    WCHAR *pwszFile;
    DWORD logMin;
    DWORD logMax;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    BOOL fImpersonating = FALSE;
    DBBACKUPPROGRESS dbp;
    DWORD c64kDBBlocks;		// 64k blocks in DB files to be restored
    DWORD c64kLogBlocks;	// 64k blocks in Log files to be restored

    if (NULL == pdbp)
    {
	pdbp = &dbp;
    }
    ZeroMemory(pdbp, sizeof(*pdbp));

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_RESTORE_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");
    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    if (NULL == pwszConfig ||
	((CDBBACKUP_VERIFYONLY & Flags) && NULL == pwszBackupDir))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL != pwszBackupDir)
    {
	if (!GetFullPathName(pwszBackupDir, ARRAYSIZE(buf), buf, &pwszFile))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetFullPathName");
	}
	hr = myBuildPathAndExt(buf, wszDBBACKUPSUBDIR, NULL, &pwszPathDBDir);
	_JumpIfError(hr, error, "myBuildPathAndExt");

	hr = myVerifyBackupDirectory(
				pwszConfig,
				Flags,
				pwszPathDBDir,
				&logMin,
				&logMax,
				&c64kDBBlocks,
				&c64kLogBlocks);
	_JumpIfError(hr, error, "myVerifyBackupDirectory");

	DBGPRINT((
		DBG_SS_CERTLIBI,
		"c64kBlocks=%u+%u\n",
		c64kDBBlocks,
		c64kLogBlocks));

	if (0 == (CDBBACKUP_INCREMENTAL & Flags))
	{
	    hr = myBuildPathAndExt(
			    pwszPathDBDir,
			    wszDBBACKUPCERTBACKDAT,
			    NULL,
			    &pwszDATFile);
	    _JumpIfError(hr, error, "myBuildPathAndExt");

	    hr = DecodeFileW(
			pwszDATFile,
			(BYTE **) &pwszzFileList,
			&cbList,
			CRYPT_STRING_BINARY);
	    _JumpIfError(hr, error, "DecodeFileW");

	    if (2 * sizeof(WCHAR) >= cbList ||
		L'\0' != pwszzFileList[cbList/sizeof(WCHAR) - 1] ||
		L'\0' != pwszzFileList[cbList/sizeof(WCHAR) - 2])
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "pwszzFileList malformed");
	    }
	    RstMap[0].pwszDatabaseName = pwszzFileList;
	    RstMap[0].pwszNewDatabaseName = pwszzFileList;
	    crstmap = 1;
	}
	if (0 == (CDBBACKUP_VERIFYONLY & Flags))
	{
	    hr = myRestoreDBFiles(
			    pwszConfig,
			    Flags,
			    pwszPathDBDir,
			    pwszLogPath,
			    pwszzFileList,
			    c64kDBBlocks,
			    c64kLogBlocks,
			    pdbp);
	    _JumpIfError(hr, error, "myRestoreDBFiles");

	    hr = CertSrvRestorePrepare(pwszConfig, CSRESTORE_TYPE_FULL, &hcsbc);
	    _JumpIfError(hr, error, "CertSrvRestorePrepare");

	    fBegin = TRUE;

	    hr = CertSrvRestoreRegister(
			    hcsbc,
			    pwszCheckPointFilePath,
			    pwszLogPath,
			    0 == crstmap? NULL : RstMap,
			    crstmap,
			    pwszBackupLogPath,
			    logMin,
			    logMax);

	    // When running only as backup operator, we don't have rights
	    // in the registry and CertSrvRestoreRegister fails with access
	    // denied. We try to mark for restore through a file.

	    if (E_ACCESSDENIED == hr)
	    {
		hr = CertSrvRestoreRegisterThroughFile(
				hcsbc,
				pwszCheckPointFilePath,
				pwszLogPath,
				0 == crstmap? NULL : RstMap,
				crstmap,
				pwszBackupLogPath,
				logMin,
				logMax);
		_JumpIfError(hr, error, "CertSrvRestoreRegisterThroughFile");
	    }
	    else
	    {
		_JumpIfError(hr, error, "CertSrvRestoreRegister");

		hr = CertSrvRestoreRegisterComplete(hcsbc, S_OK);
		_JumpIfError(hr, error, "CertSrvRestoreRegisterComplete");
	    }
	}
    }
    else if (0 == (CDBBACKUP_VERIFYONLY & Flags))
    {
	hr = myDeleteRestoreInProgressKey(pwszConfig);
	_JumpIfError(hr, error, "myDeleteRestoreInProgressKey");
    }
    hr = S_OK;

error:
    if (fBegin)
    {
	hr2 = CertSrvRestoreEnd(hcsbc);
	_PrintIfError(hr2, "CertSrvBackupEnd");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    if (NULL != pwszzFileList)
    {
	LocalFree(pwszzFileList);
    }
    if (NULL != pwszDATFile)
    {
	LocalFree(pwszDATFile);
    }
    if (NULL != pwszPathDBDir)
    {
	LocalFree(pwszPathDBDir);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        myEnablePrivilege(SE_RESTORE_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


HRESULT
myPFXExportCertStore(
    IN HCERTSTORE hStore,
    OUT CRYPT_DATA_BLOB *ppfx,
    IN WCHAR const *pwszPassword,
    IN DWORD dwFlags)
{
    HRESULT hr;

    ppfx->pbData = NULL;
    if (!PFXExportCertStore(hStore, ppfx, pwszPassword, dwFlags))
    {
        hr = myHLastError();
        _JumpError(hr, error, "PFXExportCertStore");
    }
    ppfx->pbData = (BYTE *) LocalAlloc(LMEM_FIXED, ppfx->cbData);
    if (NULL == ppfx->pbData)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "no memory for PFX blob");
    }

    if (!PFXExportCertStore(hStore, ppfx, pwszPassword, dwFlags))
    {
        hr = myHLastError();
        _JumpError(hr, error, "PFXExportCertStore");
    }
    hr = S_OK;

error:
    return(hr);
}


////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////

HRESULT
myAddChainToMemoryStore(
    IN HCERTSTORE hMemoryStore,
    IN CERT_CONTEXT const *pCertContext)
{
    HRESULT hr;
    DWORD i;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_SIMPLE_CHAIN *pSimpleChain;

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pCertContext,
			    NULL,
			    NULL,
			    &CertChainPara,
			    0,
			    NULL,
			    &pCertChainContext))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChainContext->cChain)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        _JumpError(hr, error, "pCertChainContext->cChain");
    }

    pSimpleChain = pCertChainContext->rgpChain[0];
    for (i = 0; i < pSimpleChain->cElement; i++)
    {
	if (!CertAddCertificateContextToStore(
			    hMemoryStore,
			    pSimpleChain->rgpElement[i]->pCertContext,
			    CERT_STORE_ADD_REPLACE_EXISTING,
			    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCertificateContextToStore");
	}
    }
    hr = S_OK;

error:
    if (pCertChainContext != NULL)
    {
	CertFreeCertificateChain(pCertChainContext);
    }
    return(hr);
}


HRESULT
SaveCACertChainToMemoryStore(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN HCERTSTORE hMyStore,
    IN HCERTSTORE hTempMemoryStore)
{
    HRESULT hr;
    CERT_CONTEXT const *pccCA = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD NameId;

    hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedName,
			    CSRH_CASIGCERT,
			    iCert,
			    &NameId,
			    &pccCA);
    _JumpIfError(hr, error, "myFindCACertByHashIndex");

    hr = myRepairCertKeyProviderInfo(pccCA, TRUE, &pkpi);
    if (S_OK != hr)
    {
        if (CRYPT_E_NOT_FOUND != hr)
        {
            _JumpError(hr, error, "myRepairCertKeyProviderInfo");
        }
    }
    else if (NULL != pkpi)
    {
	BOOL fMatchingKey;

	hr = myVerifyPublicKey(
			pccCA,
			FALSE,
			NULL,		// pKeyProvInfo
			NULL,		// pPublicKeyInfo
			&fMatchingKey);
        if (S_OK != hr)
        {
            if (!IsHrSkipPrivateKey(hr))
            {
                _JumpError(hr, error, "myVerifyPublicKey");
            }
            _PrintError2(hr, "myVerifyPublicKey", hr);
        }
	else if (!fMatchingKey)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Key doesn't match cert");
	}
    }

    // Begin Chain Building

    hr = myAddChainToMemoryStore(hTempMemoryStore, pccCA);
    _JumpIfError(hr, error, "myAddChainToMemoryStore");

    // End Chain Building

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pccCA)
    {
	CertFreeCertificateContext(pccCA);
    }
    return(hr);
}


HRESULT
myCertServerExportPFX(
    IN WCHAR const *pwszCA,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN BOOL fForceOverWrite,
    IN BOOL fMustExportPrivateKeys,
    OPTIONAL OUT WCHAR **ppwszPFXFile)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    HCERTSTORE hTempMemoryStore = NULL;
    CRYPT_DATA_BLOB pfx;
    WCHAR *pwszPFXFile = NULL;
    BOOL fImpersonating = FALSE;
    WCHAR *pwszSanitizedCA = NULL;
    WCHAR *pwszRevertCA = NULL;
    DWORD cCACert;
    DWORD cCACertSaved;
    DWORD i;

    pfx.pbData = NULL;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    if (NULL != ppwszPFXFile)
    {
	*ppwszPFXFile = NULL;
    }

    while (TRUE)
    {
	hr = mySanitizeName(pwszCA, &pwszSanitizedCA);
	_JumpIfError(hr, error, "mySanitizeName");

	// get CA cert count
	hr = myGetCARegHashCount(pwszSanitizedCA, CSRH_CASIGCERT, &cCACert);
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
	    NULL == pwszRevertCA)
	{
	    LocalFree(pwszSanitizedCA);
	    pwszSanitizedCA = NULL;

	    hr = myRevertSanitizeName(pwszCA, &pwszRevertCA);
	    _JumpIfError(hr, error, "myRevertSanitizeName");

	    pwszCA = pwszRevertCA;
	    continue;
	}
	_JumpIfError(hr, error, "myGetCARegHashCount");

	if (NULL != pwszRevertCA)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"myCertServerExportPFX called with Sanitized Name: %ws\n",
		pwszSanitizedCA));
	}
	break;
    }

    if (!myIsDirectory(pwszBackupDir))
    {
        if (!CreateDirectory(pwszBackupDir, NULL))
        {
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
	    {
		_JumpError(hr, error, "CreateDirectory");
	    }
        }
    }

    pwszPFXFile = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszBackupDir) +
				     1 +
				     wcslen(pwszSanitizedCA) +
				     ARRAYSIZE(wszPFXFILENAMEEXT)) *
					 sizeof(WCHAR));
    if (NULL == pwszPFXFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszPFXFile, pwszBackupDir);
    wcscat(pwszPFXFile, L"\\");
    wcscat(pwszPFXFile, pwszSanitizedCA);
    wcscat(pwszPFXFile, wszPFXFILENAMEEXT);

    DBGPRINT((DBG_SS_CERTLIBI, "myCertServerExportPFX(%ws)\n", pwszPFXFile));

    hMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			CERT_STORE_OPEN_EXISTING_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG |
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_READONLY_FLAG,
			wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    hTempMemoryStore = CertOpenStore(
				CERT_STORE_PROV_MEMORY,
				X509_ASN_ENCODING,
				NULL,
				0,
				NULL);
    if (NULL == hTempMemoryStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    cCACertSaved = 0;
    for (i = 0; i < cCACert; i++)
    {
	hr = SaveCACertChainToMemoryStore(
			    pwszSanitizedCA,
			    i,
			    hMyStore,
			    hTempMemoryStore);
	_PrintIfError(hr, "SaveCACertChainToMemoryStore");
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "SaveCACertChainToMemoryStore");

	    cCACertSaved++;
	}
    }
    if (0 == cCACertSaved)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "SaveCACertChainToMemoryStore");
    }

    // done, have built entire chain for all CA Certs

    // GemPlus returns NTE_BAD_TYPE instead of NTE_BAD_KEY, blowing up
    // REPORT_NOT_ABLE* filtering.  if they ever get this right, we can pass
    // "[...] : EXPORT_PRIVATE_KEYS"

    hr = myPFXExportCertStore(
		hTempMemoryStore,
		&pfx,
		pwszPassword,
		fMustExportPrivateKeys? (EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) : 0);
    _JumpIfError(hr, error, "myPFXExportCertStore");

    hr = EncodeToFileW(
		pwszPFXFile,
		pfx.pbData,
		pfx.cbData,
		CRYPT_STRING_BINARY | (fForceOverWrite? DECF_FORCEOVERWRITE : 0));
    _JumpIfError(hr, error, "EncodeToFileW");

    if (NULL != ppwszPFXFile)
    {
	*ppwszPFXFile = pwszPFXFile;
	pwszPFXFile = NULL;
    }

error:
    if (NULL != pwszSanitizedCA)
    {
	LocalFree(pwszSanitizedCA);
    }
    if (NULL != pwszRevertCA)
    {
	LocalFree(pwszRevertCA);
    }
    if (NULL != pwszPFXFile)
    {
	LocalFree(pwszPFXFile);
    }
    if (NULL != hMyStore)
    {
	CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hTempMemoryStore)
    {
	CertCloseStore(hTempMemoryStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
	LocalFree(pfx.pbData);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


HRESULT
FindKeyUsage(
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension,
    OUT DWORD *pdwUsage)
{
    HRESULT hr;
    DWORD i;
    CRYPT_BIT_BLOB *pblob = NULL;

    *pdwUsage = 0;
    for (i = 0; i < cExtension; i++)
    {
	CERT_EXTENSION const *pce;

	pce = &rgExtension[i];
	if (0 == strcmp(pce->pszObjId, szOID_KEY_USAGE))
	{
	    DWORD cb;

	    // Decode CRYPT_BIT_BLOB:

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    pce->Value.pbData,
			    pce->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pblob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    if (1 > pblob->cbData || 8 < pblob->cUnusedBits)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Key Usage Extension too small");
	    }
	    *pdwUsage = *pblob->pbData;

	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    _JumpError(hr, error, "no Key Usage Extension");

error:
    if (NULL != pblob)
    {
	LocalFree(pblob);
    }
    return(hr);
}


HRESULT
mySetKeySpec(
    IN CERT_CONTEXT const *pCert,
    OUT DWORD *pdwKeySpec)
{
    HRESULT hr;
    DWORD dwKeyUsage;

    *pdwKeySpec = AT_SIGNATURE;
    hr = FindKeyUsage(
		pCert->pCertInfo->cExtension,
		pCert->pCertInfo->rgExtension,
		&dwKeyUsage);
    _JumpIfError(hr, error, "FindKeyUsage");

    if (CERT_KEY_ENCIPHERMENT_KEY_USAGE & dwKeyUsage)
    {
	*pdwKeySpec = AT_KEYEXCHANGE;
    }
    hr = S_OK;

error:

    // Ignore errors because the Key Usage extension may not exist:
    hr = S_OK;

    return(hr);
}


HRESULT
myRepairKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    IN BOOL fForceMachineKey,
    IN OUT CRYPT_KEY_PROV_INFO *pkpi)
{
    HRESULT hr;
    BOOL fModified = FALSE;

    if (0 == pkpi->dwProvType)
    {
	pkpi->dwProvType = PROV_RSA_FULL;
	fModified = TRUE;
    }
    if (0 == pkpi->dwKeySpec)
    {
	hr = mySetKeySpec(pCert, &pkpi->dwKeySpec);
	_JumpIfError(hr, error, "mySetKeySpec");

	fModified = TRUE;
    }
    if (fForceMachineKey && 0 == (CRYPT_MACHINE_KEYSET & pkpi->dwFlags))
    {
	pkpi->dwFlags |= CRYPT_MACHINE_KEYSET;
	fModified = TRUE;
    }
    if (fModified)
    {
	if (!CertSetCertificateContextProperty(
					    pCert,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    pkpi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myRepairCertKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    IN BOOL fForceMachineKey,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;

    if (NULL != ppkpi)
    {
	*ppkpi = NULL;
    }

    hr = myCertGetKeyProviderInfo(pCert, &pkpi);
    _JumpIfError2(hr, error, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);

    CSASSERT(NULL != pkpi);

    hr = myRepairKeyProviderInfo(pCert, fForceMachineKey, pkpi);
    _JumpIfError(hr, error, "myRepairKeyProviderInfo");

    if (NULL != ppkpi)
    {
	*ppkpi = pkpi;
	pkpi = NULL;
    }

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    return(hr);
}


HRESULT
myGetCertSubjectCommonName(
    IN CERT_CONTEXT const *pCert,
    OUT WCHAR **ppwszCommonName)
{
    HRESULT hr;
    CERT_NAME_INFO *pCertNameInfo = NULL;
    DWORD cbCertNameInfo;
    WCHAR const *pwszName;

    if (!myDecodeName(
		    X509_ASN_ENCODING,
                    X509_UNICODE_NAME,
                    pCert->pCertInfo->Subject.pbData,
                    pCert->pCertInfo->Subject.cbData,
                    CERTLIB_USE_LOCALALLOC,
                    &pCertNameInfo,
                    &cbCertNameInfo))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    hr = myGetCertNameProperty(pCertNameInfo, szOID_COMMON_NAME, &pwszName);
    _JumpIfError(hr, error, "myGetCertNameProperty");

    *ppwszCommonName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszName) + 1) * sizeof(WCHAR));
    if (NULL == *ppwszCommonName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszCommonName, pwszName);
    hr = S_OK;

error:
    if (NULL != pCertNameInfo)
    {
	LocalFree(pCertNameInfo);
    }
    return(hr);
}


HRESULT
myGetChainArrayFromStore(
    IN HCERTSTORE hStore,
    IN BOOL fCAChain,
    IN BOOL fUserStore,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    IN OUT DWORD *pcRestoreChain,
    OPTIONAL OUT RESTORECHAIN *paRestoreChain)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    WCHAR *pwszCommonName = NULL;
    CERT_CHAIN_PARA ChainParams;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD iRestoreChain = 0;

    if (NULL != ppwszCommonName)
    {
	*ppwszCommonName = NULL;
    }
    if (NULL != paRestoreChain)
    {
	ZeroMemory(paRestoreChain, *pcRestoreChain * sizeof(paRestoreChain[0]));
    }

    // Look for certificates with keys.  There should be at least one.

    while (TRUE)
    {
	BOOL fMatchingKey;
	WCHAR *pwszCommonNameT;
	CERT_CHAIN_CONTEXT const *pChain;
	DWORD NameId;

	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}

	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}
	hr = myRepairCertKeyProviderInfo(pCert, !fUserStore, &pkpi);
	if (S_OK != hr)
	{
	    if (CRYPT_E_NOT_FOUND == hr)
	    {
		continue;
	    }
	    _JumpError(hr, error, "myRepairCertKeyProviderInfo");
	}
	if (NULL == pkpi || NULL == pkpi->pwszContainerName)
	{
	    continue;
	}

	hr = myVerifyPublicKey(
			pCert,
			FALSE,
			pkpi,		// pKeyProvInfo
			NULL,		// pPublicKeyInfo
			&fMatchingKey);
	_JumpIfError(hr, error, "myVerifyPublicKey");

	if (!fMatchingKey)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Key doesn't match cert");
	}

	hr = myGetCertSubjectCommonName(pCert, &pwszCommonNameT);
	_JumpIfError(hr, error, "myGetCertSubjectCommonName");

	if (NULL == pwszCommonName)
	{
	    pwszCommonName = pwszCommonNameT;
	}
	else
	{
	    if (0 != lstrcmp(pwszCommonName, pwszCommonNameT))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "multiple CommonNames");
	    }
	    LocalFree(pwszCommonNameT);
	}
	if (fCAChain)
	{
	    hr = myGetNameId(pCert, &NameId);
	    _PrintIfError(hr, "myGetNameId");
	}
	else
	{
	    NameId = 0;
	}

	if (NULL != paRestoreChain && iRestoreChain >= *pcRestoreChain)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "Chain array full");
	}

	ZeroMemory(&ChainParams, sizeof(ChainParams));
	ChainParams.cbSize = sizeof(ChainParams);
	ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

	// Get the chain and verify the cert:

	if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,		// hChainEngine
			    pCert,		// pCertContext
			    NULL,		// pTime
			    hStore,		// hAdditionalStore
			    &ChainParams,	// pChainPara
			    0,			// dwFlags
			    NULL,		// pvReserved
			    &pChain))		// ppChainContext
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "CertGetCertificateChain");
	}
	if (NULL != paRestoreChain)
	{
	    paRestoreChain[iRestoreChain].pChain = pChain;
	    paRestoreChain[iRestoreChain].NameId = NameId;
	}
	else
	{
	    CertFreeCertificateChain(pChain);
	}
	iRestoreChain++;
    }
    if (NULL != ppwszCommonName)
    {
	*ppwszCommonName = pwszCommonName;
	pwszCommonName = NULL;
    }
    *pcRestoreChain = iRestoreChain;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != paRestoreChain)
    {
	for (iRestoreChain = 0; iRestoreChain < *pcRestoreChain; iRestoreChain++)
	{
	    if (NULL != paRestoreChain[iRestoreChain].pChain)
	    {
		CertFreeCertificateChain(paRestoreChain[iRestoreChain].pChain);
		paRestoreChain[iRestoreChain].pChain = NULL;
	    }
	}
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
myCopyKeys(
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN WCHAR const *pwszOldContainer,
    IN WCHAR const *pwszNewContainer,
    IN BOOL fOldUserKey,
    IN BOOL fNewUserKey,
    IN BOOL fForceOverWrite)
{
    HRESULT hr;
    HCRYPTPROV hProvOld = NULL;
    HCRYPTKEY hKeyOld = NULL;
    HCRYPTPROV hProvNew = NULL;
    HCRYPTKEY hKeyNew = NULL;
    CRYPT_BIT_BLOB PrivateKey;
    BOOL fKeyContainerNotFound = FALSE;

    PrivateKey.pbData = NULL;

    if (!myCertSrvCryptAcquireContext(
			&hProvOld,
			pwszOldContainer,
			pkpi->pwszProvName,
			pkpi->dwProvType,
			pkpi->dwFlags,
			!fOldUserKey))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }
    if (!CryptGetUserKey(hProvOld, pkpi->dwKeySpec, &hKeyOld))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetUserKey");
    }
    hr = myCryptExportPrivateKey(
		    hKeyOld,
		    &PrivateKey.pbData,
		    &PrivateKey.cbData);
    _JumpIfError(hr, error, "myCryptExportPrivateKey");

    if (myCertSrvCryptAcquireContext(
			    &hProvNew,
			    pwszNewContainer,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags,
			    !fNewUserKey))
    {
	if (!fForceOverWrite)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
	    _JumpErrorStr(hr, error, "Key Container Exists", pwszNewContainer);
	}

	// Delete the target key container

	CryptReleaseContext(hProvNew, 0);
        if (myCertSrvCryptAcquireContext(
			    &hProvNew,
			    pwszNewContainer,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags | CRYPT_DELETEKEYSET,
			    !fNewUserKey))
        {
            fKeyContainerNotFound = TRUE;
        }
	hProvNew = NULL;
    }
    else
    {
        fKeyContainerNotFound = TRUE;
    }

    if (!myCertSrvCryptAcquireContext(
			    &hProvNew,
			    pwszNewContainer,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags | 
			    fKeyContainerNotFound? CRYPT_NEWKEYSET : 0,
			    !fNewUserKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    if (!CryptImportKey(
		    hProvNew,
		    PrivateKey.pbData,
		    PrivateKey.cbData,
		    NULL,		// HCRYPTKEY hPubKey
		    CRYPT_EXPORTABLE,
		    &hKeyNew))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }

error:
    if (NULL != PrivateKey.pbData)
    {
	LocalFree(PrivateKey.pbData);
    }
    if (NULL != hKeyNew)
    {
	CryptDestroyKey(hKeyNew);
    }
    if (NULL != hProvNew)
    {
	CryptReleaseContext(hProvNew, 0);
    }
    if (NULL != hKeyOld)
    {
	CryptDestroyKey(hKeyOld);
    }
    if (NULL != hProvOld)
    {
	CryptReleaseContext(hProvOld, 0);
    }
    return(hr);
}


HRESULT
myImportChainAndKeys(
    IN WCHAR const *pwszSanitizedCA,
    IN DWORD iCert,
    IN DWORD iKey,
    IN BOOL fForceOverWrite,
    IN CERT_CHAIN_CONTEXT const *pChain,
    OPTIONAL OUT CERT_CONTEXT const **ppccNewestCA)
{
    HRESULT hr;
    BOOL fDeleted = FALSE;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    CERT_CHAIN_ELEMENT **ppChainElement;
    WCHAR *pwszKeyContainerName = NULL;

    hr = myAllocIndexedName(pwszSanitizedCA, iKey, &pwszKeyContainerName);
    _JumpIfError(hr, error, "myAllocIndexedName");

    ppChainElement = pChain->rgpChain[0]->rgpElement;

    hr = myCertGetKeyProviderInfo(ppChainElement[0]->pCertContext, &pkpi);
    _JumpIfError(hr, error, "myCertGetKeyProviderInfo");

    if (iCert == iKey)
    {
	hr = myCopyKeys(
		    pkpi,
		    pkpi->pwszContainerName,	// pwszOldContainer
		    pwszKeyContainerName,	// pwszNewContainer
		    FALSE,			// fOldUserKey
		    FALSE,			// fNewUserKey
		    fForceOverWrite);
	_JumpIfError(hr, error, "myCopyKeys");
    }

    pkpi->pwszContainerName = pwszKeyContainerName;

    hr = mySaveChainAndKeys(
			pChain->rgpChain[0],
			wszMY_CERTSTORE,
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_BACKUP_RESTORE_FLAG,
			pkpi,
			ppccNewestCA);
    _JumpIfError(hr, error, "mySaveChainAndKeys");

    hr = S_OK;

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pwszKeyContainerName)
    {
        LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


HRESULT
FindPFXInBackupDir(
    IN WCHAR const *pwszBackupDir,
    OUT WCHAR **ppwszPFXFile)
{
    HRESULT hr;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR wszpath[MAX_PATH];
    WCHAR wszfile[MAX_PATH];
    DWORD cFile = 0;

    *ppwszPFXFile = NULL;

    wcscpy(wszpath, pwszBackupDir);
    wcscat(wszpath, L"\\*");
    wcscat(wszpath, wszPFXFILENAMEEXT);

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE != hf)
    {
	do {
	    if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	    {
		continue;
	    }
	    cFile++;
	    wcscpy(wszfile, wfd.cFileName);
	    //printf("File: %ws\n", wszfile);
	    break;

	} while (FindNextFile(hf, &wfd));
	FindClose(hf);
    }
    if (0 == cFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no *.p12 files");
    }
    if (1 < cFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
	_JumpError(hr, error, "Too many *.p12 files");
    }

    *ppwszPFXFile = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszBackupDir) +
				     1 +
				     wcslen(wszfile) +
				     1) * sizeof(WCHAR));
    if (NULL == *ppwszPFXFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszPFXFile, pwszBackupDir);
    wcscat(*ppwszPFXFile, L"\\");
    wcscat(*ppwszPFXFile, wszfile);
    hr = S_OK;

error:
    return(hr);
}


// Return TRUE if pcc is newer than pcc2

BOOL
IsCACertNewer(
    IN CERT_CONTEXT const *pcc,
    IN DWORD NameId,
    IN CERT_CONTEXT const *pcc2,
    IN DWORD NameId2)
{
    BOOL fNewer = FALSE;
    CERT_INFO const *pci = pcc->pCertInfo;
    CERT_INFO const *pci2 = pcc2->pCertInfo;

    if (MAXDWORD != NameId && MAXDWORD != NameId2)
    {
	if (CANAMEIDTOICERT(NameId) > CANAMEIDTOICERT(NameId2))
	{
	    fNewer = TRUE;
	}
    }
    else
    if (CompareFileTime(&pci->NotAfter, &pci2->NotAfter) > 0)
    {
	fNewer = TRUE;
    }

#if 0
    HRESULT hr;
    WCHAR *pwszDate = NULL;
    WCHAR *pwszDate2 = NULL;

    hr = myGMTFileTimeToWszLocalTime(&pci->NotAfter, &pwszDate);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

    hr = myGMTFileTimeToWszLocalTime(&pci2->NotAfter, &pwszDate2);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

    printf(
	"%u.%u %ws is %wsnewer than %u.%u %ws\n",
	CANAMEIDTOICERT(NameId),
	CANAMEIDTOIKEY(NameId),
	pwszDate,
	fNewer? L"" : L"NOT ",
	CANAMEIDTOICERT(NameId2),
	CANAMEIDTOIKEY(NameId2),
	pwszDate2);

    if (NULL != pwszDate) LocalFree(pwszDate);
    if (NULL != pwszDate2) LocalFree(pwszDate2);
#endif

    return(fNewer);
}


#if 0
VOID
DumpChainArray(
    IN char const *psz,
    IN DWORD cCACert,
    IN OUT RESTORECHAIN *paRestoreChain)
{
    HRESULT hr;
    DWORD i;
    
    printf("\n%hs:\n", psz);
    for (i = 0; i < cCACert; i++)
    {
	WCHAR *pwszDate;
	
	hr = myGMTFileTimeToWszLocalTime(
	    &paRestoreChain[i].pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->NotBefore,
	    &pwszDate);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

	printf(
	    " %u: %u.%u %ws",
	    i,
	    CANAMEIDTOICERT(paRestoreChain[i].NameId),
	    CANAMEIDTOIKEY(paRestoreChain[i].NameId),
	    pwszDate);


	if (NULL != pwszDate) LocalFree(pwszDate);

	hr = myGMTFileTimeToWszLocalTime(
	    &paRestoreChain[i].pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->NotAfter,
	    &pwszDate);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

	printf(" -- %ws\n", pwszDate);

	if (NULL != pwszDate) LocalFree(pwszDate);
    }
    printf("\n");
}
#endif


HRESULT
SortCACerts(
    IN DWORD cCACert,
    IN OUT RESTORECHAIN *paRestoreChain)
{
    HRESULT hr;
    DWORD i;
    DWORD j;

#if 0
    DumpChainArray("Start", cCACert, paRestoreChain);
#endif

    for (i = 0; i < cCACert; i++)
    {
	for (j = i + 1; j < cCACert; j++)
	{
	    CERT_CHAIN_CONTEXT const *pChain;
	    DWORD NameId;
	    DWORD NameId2;
	    CERT_CONTEXT const *pcc;
	    CERT_CONTEXT const *pcc2;

	    pChain = paRestoreChain[i].pChain;
	    NameId = paRestoreChain[i].NameId;
	    NameId2 = paRestoreChain[j].NameId;

	    pcc = pChain->rgpChain[0]->rgpElement[0]->pCertContext;
	    pcc2 = paRestoreChain[j].pChain->rgpChain[0]->rgpElement[0]->pCertContext;

#if 0
	    printf(
		"%u(%u.%u) %u(%u.%u): ",
		i,
		CANAMEIDTOIKEY(NameId),
		CANAMEIDTOICERT(NameId),
		j,
		CANAMEIDTOIKEY(NameId2),
		CANAMEIDTOICERT(NameId2));
#endif

	    if (IsCACertNewer(pcc, NameId, pcc2, NameId2))
	    {
		paRestoreChain[i] = paRestoreChain[j];
		paRestoreChain[j].pChain = pChain;
		paRestoreChain[j].NameId = NameId;
	    }
	}
    }
#if 0
    DumpChainArray("End", cCACert, paRestoreChain);
#endif

    hr = S_OK;

//error:
    return(hr);
}


HRESULT
myDeleteGuidKeys(
    IN HCERTSTORE hStorePFX,
    IN BOOL fMachineKeySet)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;

    // Look for certificates with keys, and delete all key containers with
    // names that look like GUIDs.

    while (TRUE)
    {
	HCRYPTPROV hProv;

	pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
	if (NULL == pCert)
	{
	    break;
	}

	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}
	hr = myRepairCertKeyProviderInfo(pCert, FALSE, &pkpi);
	if (S_OK == hr &&
	    NULL != pkpi->pwszContainerName &&
	    wcLBRACE == *pkpi->pwszContainerName)
	{
	    if (myCertSrvCryptAcquireContext(
			    &hProv,
			    pkpi->pwszContainerName,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags | CRYPT_DELETEKEYSET,
			    fMachineKeySet))
	    {
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "myDeleteGuidKeys(%ws, %ws)\n",
		    fMachineKeySet? L"Machine" : L"User",
		    pkpi->pwszContainerName));
	    }
	}
    }
    hr = S_OK;

//error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
myCertServerImportPFX(
    IN WCHAR const *pwszBackupDirOrPFXFile,
    IN WCHAR const *pwszPassword,
    IN BOOL fForceOverWrite,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    OPTIONAL OUT WCHAR **ppwszPFXFile,
    OPTIONAL OUT CERT_CONTEXT const **ppccNewestCA)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    HCERTSTORE hStorePFX = NULL;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszSanitizedName = NULL;
    RESTORECHAIN *paRestoreChain = NULL;
    WCHAR *pwszPFXFile = NULL;
    DWORD FileAttr;
    BOOL fImpersonating = FALSE;
    DWORD cCACert;
    DWORD iCert;

    pfx.pbData = NULL;

    if (NULL != ppwszCommonName)
    {
        *ppwszCommonName = NULL;
    }
    if (NULL != ppwszPFXFile)
    {
        *ppwszPFXFile = NULL;
    }
    if (NULL != ppccNewestCA)
    {
        *ppccNewestCA = NULL;
    }

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_RESTORE_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    FileAttr = GetFileAttributes(pwszBackupDirOrPFXFile);
    if (MAXDWORD == FileAttr)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetFileAttributes");
    }

    if (FILE_ATTRIBUTE_DIRECTORY & FileAttr)
    {
        hr = FindPFXInBackupDir(pwszBackupDirOrPFXFile, &pwszPFXFile);
        _JumpIfError(hr, error, "FindPFXInBackupDir");
    }
    else
    {
	hr = myDupString(pwszBackupDirOrPFXFile, &pwszPFXFile);
	_JumpIfError(hr, error, "myDupString");
    }

    hr = DecodeFileW(pwszPFXFile, &pfx.pbData, &pfx.cbData, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    CSASSERT(NULL != pfx.pbData);

    if (!PFXIsPFXBlob(&pfx))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "PFXIsPFXBlob");
    }

    hStorePFX = myPFXImportCertStore(&pfx, pwszPassword, CRYPT_EXPORTABLE);
    if (NULL == hStorePFX)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myPFXImportCertStore");
    }

    cCACert = 0;
    hr = myGetChainArrayFromStore(
			    hStorePFX,
			    TRUE,		// fCAChain
			    FALSE,		// fUserStore
			    &pwszCommonName,
			    &cCACert,
			    NULL);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    if (0 == cCACert)
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_SELF_SIGNED);
        _JumpError(hr, error, "myGetChainArrayFromStore <no chain>");
    }

    paRestoreChain = (RESTORECHAIN *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cCACert * sizeof(paRestoreChain[0]));
    if (NULL == paRestoreChain)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = myGetChainArrayFromStore(
			    hStorePFX,
			    TRUE,		// fCAChain
			    FALSE,		// fUserStore
			    NULL,
			    &cCACert,
			    paRestoreChain);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    hr = SortCACerts(cCACert, paRestoreChain);
    _JumpIfError(hr, error, "SortCACerts");

    hr = mySanitizeName(pwszCommonName, &pwszSanitizedName);
    _JumpIfError(hr, error, "mySanitizeName");

    for (iCert = 0; iCert < cCACert; iCert++)
    {
	CERT_CHAIN_CONTEXT const *pChain = paRestoreChain[iCert].pChain;
	DWORD iKey;
	CERT_PUBLIC_KEY_INFO *pPublicKeyInfo;

	if (1 > pChain->cChain)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "No Chain Context");
	}

	// Compute iKey by comparing this public key to the public keys
	// of all certs in the array already processed.

	pPublicKeyInfo = &pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->SubjectPublicKeyInfo;

	for (iKey = 0; iKey < iCert; iKey++)
	{
	    if (CertComparePublicKeyInfo(
				    X509_ASN_ENCODING,
				    pPublicKeyInfo,
				    &paRestoreChain[iKey].pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->SubjectPublicKeyInfo))
	    {
		// by design, CertComparePublicKeyInfo doesn't set last error!

		break;
	    }
	}
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "Import: %u.%u -- %u.%u\n",
	    iCert,
	    iKey,
	    CANAMEIDTOICERT(paRestoreChain[iCert].NameId),
	    CANAMEIDTOIKEY(paRestoreChain[iCert].NameId)));

	// Retrieve the cert context for the newest CA cert chain in the PFX
	// we are importing.  We must return a cert context with the new
	// key prov info, not the PFX cert context with a GUID key container.

	hr = myImportChainAndKeys(
			    pwszSanitizedName,
			    iCert,
			    iKey,
			    fForceOverWrite,
			    pChain,
			    iCert + 1 == cCACert? ppccNewestCA : NULL);
	_JumpIfError(hr, error, "myImportChainAndKeys");
    }

    if (NULL != ppwszCommonName)
    {
        *ppwszCommonName = pwszCommonName;
        pwszCommonName = NULL;
    }
    if (NULL != ppwszPFXFile)
    {
        *ppwszPFXFile = pwszPFXFile;
        pwszPFXFile = NULL;
    }
    hr = S_OK;

error:
    if (NULL != paRestoreChain)
    {
        for (iCert = 0; iCert < cCACert; iCert++)
	{
	    if (NULL != paRestoreChain[iCert].pChain)
	    {
		CertFreeCertificateChain(paRestoreChain[iCert].pChain);
	    }
	}
	LocalFree(paRestoreChain);
    }
    if (NULL != pwszPFXFile)
    {
        LocalFree(pwszPFXFile);
    }
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    if (NULL != pwszSanitizedName)
    {
        LocalFree(pwszSanitizedName);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, TRUE);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
        LocalFree(pfx.pbData);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_RESTORE_NAME, FALSE);
        myEnablePrivilege(SE_BACKUP_NAME,  FALSE);
        RevertToSelf();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\certlibp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlibp.h
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#ifndef __CERTLIBP_H__
#define __CERTLIBP_H__


char PrintableChar(char ch);


#endif // __CERTLIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\certlib.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlib.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include <time.h>
#include <locale.h>
extern "C" {
#include <luidate.h>
}
#include <wininet.h>

#include "certlibp.h"
#include "csdisp.h"
#include "csprop.h"
#include <winnlsp.h>
#include <winldap.h>
#include <ntsecapi.h>
#include "csldap.h"


#define  wszSANITIZEESCAPECHAR  L"!"
#define  wszURLESCAPECHAR       L"%"
#define  wcSANITIZEESCAPECHAR   L'!'

char
PrintableChar(char ch)
{
    if (ch < ' ' || ch > '~')
    {
        ch = '.';
    }
    return(ch);
}


#if DBG_CERTSRV
VOID
mydbgDumpHex(
    IN DWORD dwSubSysId,
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb)
{
    if (DbgIsSSActive(dwSubSysId))
    {
	DumpHex(Flags, pb, cb);
    }
}
#endif


VOID
DumpHex(
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb)
{
    char const *pszsep;
    ULONG r;
    ULONG i;
    ULONG cbremain;
    BOOL fZero = FALSE;
    DWORD cchIndent;
    DWORD cchAsciiSep;
    char szAddress[8 + 1];
    char szHexDump[1 + 1 + 3 * 16 + 1];
    char szAsciiDump[16 + 1];
    char *psz;

    cchIndent = DH_INDENTMASK & Flags;
    if ((DH_MULTIADDRESS & Flags) && 16 >= cb)
    {
	Flags |= DH_NOADDRESS;
    }
    for (r = 0; r < cb; r += 16)
    {
	szAddress[0] = '\0';
        if (0 == (DH_NOADDRESS & Flags))
	{
	    sprintf(szAddress, 64 * 1024 < cb? "%06x": "%04x", r);
	    CSASSERT(strlen(szAddress) < ARRAYSIZE(szAddress));
	}

	cbremain = cb - r;
        if (r != 0 && pb[r] == 0 && cbremain >= 16)
        {
            ULONG j;

            for (j = r + 1; j < cb; j++)
            {
                if (pb[j] != 0)
                {
                    break;
                }
            }
            if (j == cb)
            {
                fZero = TRUE;
                break;
            }
        }

	psz = szHexDump;
        for (i = 0; i < min(cbremain, 16); i++)
        {
            pszsep = " ";
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = "  ";
                if (i == 0)             // 0
                {
		    if (0 == (DH_NOTABPREFIX & Flags))
		    {
			pszsep = "\t";
		    }
		    else if (DH_NOADDRESS & Flags)
		    {
			pszsep = "";
		    }
                }
            }
	    CSASSERT(strlen(pszsep) <= 2);
            psz += sprintf(psz, "%hs%02x", pszsep, pb[r + i]);
        }
	*psz = '\0';
	CSASSERT(strlen(szHexDump) < ARRAYSIZE(szHexDump));

	cchAsciiSep = 0;
	szAsciiDump[0] = '\0';
	if (0 == (DH_NOASCIIHEX & Flags) && 0 != i)
        {
            cchAsciiSep = 3 + (16 - i)*3 + ((i <= 8)? 1 : 0);
            for (i = 0; i < min(cbremain, 16); i++)
            {
		szAsciiDump[i] = PrintableChar(pb[r + i]);
            }
	    szAsciiDump[i] = '\0';
	    CSASSERT(strlen(szAsciiDump) < ARRAYSIZE(szAsciiDump));
        }
	CONSOLEPRINT7((
		MAXDWORD,
		"%*hs%hs%hs%*hs%hs\n",
		cchIndent,
		"",
		szAddress,
		szHexDump,
		cchAsciiSep,
		"",
		szAsciiDump));
    }
    if (fZero)
    {
        CONSOLEPRINT1((MAXDWORD, "\tRemaining %lx bytes are zero\n", cbremain));
    }
}


HRESULT
myDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (*pDate == 0.0)
    {
        GetSystemTime(&st);
    }
    else
    {
	if (!VariantTimeToSystemTime(*pDate, &st))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "VariantTimeToSystemTime");
	}
    }

    if (!SystemTimeToFileTime(&st, pft))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

error:
    return(hr);
}

HRESULT
myMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    HRESULT hr;
    FILETIME ft;

    hr = myDateToFileTime(pDate, &ft);
    _JumpIfError(hr, error, "myDateToFileTime");

    myMakeExprDateTime(&ft, lDelta, enumPeriod);

    hr = myFileTimeToDate(&ft, pDate);
    _JumpIfError(hr, error, "myFileTimeToDate");

error:
    return(hr);
}


typedef struct _UNITSTABLE
{
    WCHAR const     *pwszString;
    enum ENUM_PERIOD enumPeriod;
} UNITSTABLE;

UNITSTABLE g_aut[] =
{
    { wszPERIODSECONDS, ENUM_PERIOD_SECONDS },
    { wszPERIODMINUTES, ENUM_PERIOD_MINUTES },
    { wszPERIODHOURS,   ENUM_PERIOD_HOURS },
    { wszPERIODDAYS,    ENUM_PERIOD_DAYS },
    { wszPERIODWEEKS,   ENUM_PERIOD_WEEKS },
    { wszPERIODMONTHS,  ENUM_PERIOD_MONTHS },
    { wszPERIODYEARS,   ENUM_PERIOD_YEARS },
};
#define CUNITSTABLEMAX	(sizeof(g_aut)/sizeof(g_aut[0]))


HRESULT
myTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount)
{
    HRESULT hr;
    UNITSTABLE const *put;

    for (put = g_aut; put < &g_aut[CUNITSTABLEMAX]; put++)
    {
	if (0 == lstrcmpi(pwszPeriod, put->pwszString))
	{
	    *penumPeriod = put->enumPeriod;
	    if (0 > lCount)
	    {
		lCount = MAXLONG;
	    }
	    *plCount = lCount;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    CSASSERT(hr == S_OK);
    return(hr);
}


HRESULT
myTranslateUnlocalizedPeriodString(
    IN enum ENUM_PERIOD enumPeriod,
    OUT WCHAR const **ppwszPeriodString)
{
    HRESULT hr;
    UNITSTABLE const *put;

    *ppwszPeriodString = NULL;
    for (put = g_aut; put < &g_aut[CUNITSTABLEMAX]; put++)
    {
	if (enumPeriod == put->enumPeriod)
	{
	    *ppwszPeriodString = put->pwszString;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    CSASSERT(hr == S_OK);
    return(hr);
}


HRESULT
myFileTimePeriodToWszTimePeriod(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT WCHAR **ppwszTimePeriod)
{
    HRESULT hr;
    DWORD cPeriodUnits;
    PERIODUNITS *rgPeriodUnits = NULL;
    WCHAR const *pwszUnitSep;
    DWORD i;
    WCHAR awc[MAX_PATH];
    WCHAR *pwsz;

    *ppwszTimePeriod = NULL; 
    hr = caTranslateFileTimePeriodToPeriodUnits(
					pftGMT,
					fExact,
					&cPeriodUnits,
					&rgPeriodUnits);
    _JumpIfError(hr, error, "caTranslateFileTimePeriodToPeriodUnits");

    CSASSERT(0 < cPeriodUnits);
    pwszUnitSep = L"";
    pwsz = awc;
    for (i = 0; i < cPeriodUnits; i++)
    {
	WCHAR const *pwszPeriodString;

	hr = myTranslateUnlocalizedPeriodString(
				rgPeriodUnits[i].enumPeriod,
				&pwszPeriodString);
	_JumpIfError(hr, error, "myTranslateUnlocalizedPeriodString");

	pwsz += wsprintf(
		    pwsz,
		    L"%ws%u %ws",
		    pwszUnitSep,
		    rgPeriodUnits[i].lCount,
		    pwszPeriodString);
	pwszUnitSep = L", ";
    }
    hr = myDupString(awc, ppwszTimePeriod);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != rgPeriodUnits)
    {
	LocalFree(rgPeriodUnits);
    }
    return(hr);
}


HRESULT
myFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (!FileTimeToSystemTime(pft, &st))
    {
        hr = myHLastError();
        _JumpError(hr, error, "FileTimeToSystemTime");
    }
    if (!SystemTimeToVariantTime(&st, pDate))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "SystemTimeToVariantTime");
    }

error:
    return(hr);
}


HRESULT
mySystemTimeToGMTSystemTime(
    IN OUT SYSTEMTIME *pSys)
{
    // Conversion path: SystemTimeLocal -> ftLocal -> ftGMT -> SystemTimeGMT

    FILETIME ftLocal, ftGMT;
    HRESULT hr = S_OK;

    if (!SystemTimeToFileTime(pSys, &ftLocal))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

    if (!LocalFileTimeToFileTime(&ftLocal, &ftGMT))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LocalFileTimeToFileTime");
    }

    if (!FileTimeToSystemTime(&ftGMT, pSys))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FileTimeToSystemTime");
    }

error:
    return hr;
}


HRESULT
myGMTFileTimeToWszLocalTime(
    IN FILETIME const *pftGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime)
{
    HRESULT hr;
    FILETIME ftLocal;

    *ppwszLocalTime = NULL;

    if (!FileTimeToLocalFileTime(pftGMT, &ftLocal))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FileTimeToLocalFileTime");
    }
    hr = myFileTimeToWszTime(&ftLocal, fSeconds, ppwszLocalTime);
    _JumpIfError(hr, error, "myFileTimeToWszTime");

error:
    return(hr);
}


HRESULT
myFileTimeToWszTime(
    IN FILETIME const *pft,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszTime)
{
    HRESULT hr;
    SYSTEMTIME st;
    WCHAR awcDate[128];
    WCHAR awcTime[128];
    WCHAR *pwsz;

    *ppwszTime = NULL;

    if (!FileTimeToSystemTime(pft, &st))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FileTimeToSystemTime");
    }

    if (0 == GetDateFormat(
		    LOCALE_USER_DEFAULT,
		    DATE_SHORTDATE,
		    &st,
		    NULL,
		    awcDate,
		    sizeof(awcDate)/sizeof(awcDate[0])))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetDateFormat");
    }

    if (0 == GetTimeFormat(
		    LOCALE_USER_DEFAULT,
		    TIME_NOSECONDS,
		    &st,
		    NULL,
		    awcTime,
		    sizeof(awcTime)/sizeof(awcTime[0])))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetTimeFormat");
    }

    if (fSeconds)
    {
	wsprintf(
	    &awcTime[wcslen(awcTime)],
	    L" %02u.%03us",
	    st.wSecond,
	    st.wMilliseconds);
    }

    pwsz = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    (wcslen(awcDate) + 1 + wcslen(awcTime) + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwsz, awcDate);
    wcscat(pwsz, L" ");
    wcscat(pwsz, awcTime);

    *ppwszTime = pwsz;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGMTDateToWszLocalTime(
    IN DATE const *pDateGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime)
{
    HRESULT hr;
    FILETIME ftGMT;
    FILETIME ftLocal;
    SYSTEMTIME stLocal;
    WCHAR awcDate[128];
    WCHAR awcTime[128];
    WCHAR *pwsz;

    *ppwszLocalTime = NULL;

    hr = myDateToFileTime(pDateGMT, &ftGMT);
    _JumpIfError(hr, error, "myDateToFileTime");

    hr = myGMTFileTimeToWszLocalTime(&ftGMT, fSeconds, ppwszLocalTime);
    _JumpIfError(hr, error, "FileTimeToLocalFileTime");

    hr = S_OK;

error:
    return(hr);
}


HRESULT
myWszLocalTimeToGMTDate(
    IN WCHAR const *pwszLocalTime,
    OUT DATE *pDateGMT)
{
    HRESULT hr;
    FILETIME ftGMT;

    hr = myWszLocalTimeToGMTFileTime(pwszLocalTime, &ftGMT);
    _JumpIfError(hr, error, "myWszLocalTimeToGMTFileTime");

    hr = myFileTimeToDate(&ftGMT, pDateGMT);
    _JumpIfError(hr, error, "myFileTimeToDate");

error:
    return(hr);
}


HRESULT
myWszLocalTimeToGMTFileTime(
    IN WCHAR const *pwszLocalTime,
    OUT FILETIME *pftGMT)
{
    HRESULT hr;
    time_t time;
    USHORT parselen;
    struct tm *ptm;
    SYSTEMTIME stLocal;
    FILETIME ftLocal;
    char *pszLocalTime = NULL;

    if (!ConvertWszToSz(&pszLocalTime, pwszLocalTime, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }

    hr = LUI_ParseDateTime(pszLocalTime, (time_t *) &time, &parselen, 0);
    if (S_OK != hr)
    {
	_PrintError(hr, "LUI_ParseDateTime");
        hr = E_INVALIDARG;
	_JumpError(hr, error, "LUI_ParseDateTime");
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myWszLocalTimeToGMTDate = %ws: %x -- %ws\n",
	pwszLocalTime,
	time,
	_wctime(&time)));

    ptm = gmtime(&time);
    if (ptm == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "gmTime");
    }

    stLocal.wYear = ptm->tm_year + 1900;
    stLocal.wMonth = ptm->tm_mon + 1;
    stLocal.wDayOfWeek = (WORD)ptm->tm_wday;
    stLocal.wDay = (WORD)ptm->tm_mday;
    stLocal.wHour = (WORD)ptm->tm_hour;
    stLocal.wMinute = (WORD)ptm->tm_min;
    stLocal.wSecond = (WORD)ptm->tm_sec;
    stLocal.wMilliseconds = 0;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%u/%u/%u %u:%02u:%02u.%03u DayOfWeek=%u\n",
	stLocal.wMonth,
	stLocal.wDay,
	stLocal.wYear,
	stLocal.wHour,
	stLocal.wMinute,
	stLocal.wSecond,
	stLocal.wMilliseconds,
	stLocal.wDayOfWeek));

    if (!SystemTimeToFileTime(&stLocal, &ftLocal))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

    if (!LocalFileTimeToFileTime(&ftLocal, pftGMT))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LocalFileTimeToFileTime");
    }

error:
    if (NULL != pszLocalTime)
    {
	LocalFree(pszLocalTime);
    }
    return(hr);
}

// counts # of string in a multisz string
DWORD CountMultiSz(LPCWSTR pcwszString)
{
    DWORD dwCount = 0;
    DWORD dwLen;

    if(!pcwszString)
        return 0;
    while(*pcwszString)
    {
        dwCount++;
        pcwszString += wcslen(pcwszString)+1;
    }
    return dwCount;
}

//
// myRegValueToVariant and myVariantToRegValue map registry values 
// to/from variant:
//
// REG_SZ       <->     VT_BSTR
// REG_BINARY   <->     VT_ARRAY|VT_UI1
// REG_DWORD    <->     VT_I4 (VT_I2)
// REG_MULTI_SZ <->     VT_ARRAY|VT_BSTR
//

HRESULT myRegValueToVariant(
    IN DWORD dwType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pVar)
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sab;
    LPWSTR pwszCrtString = (LPWSTR)pbValue;
    BSTR bstr = NULL;
    SAFEARRAY* psa;

    VariantInit(pVar);

    switch(dwType)
    {
    case REG_SZ:
        if(sizeof(WCHAR)<=cbValue)
            cbValue -= sizeof(WCHAR);
	    V_BSTR(pVar) = NULL;
	    if (!ConvertWszToBstr(
			    &(V_BSTR(pVar)),
			    (WCHAR const *) pbValue,
			    cbValue))
	    {
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
	    }
        V_VT(pVar) = VT_BSTR;
        break;

    case REG_BINARY:
        sab.cElements = cbValue;
        sab.lLbound = 0;
        psa = SafeArrayCreate(
                            VT_UI1,
                            1,
                            &sab);
        if(!psa)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "SafeArrayCreate");
        }
        for(DWORD c=0; c<sab.cElements; c++)
        {
            hr = SafeArrayPutElement(psa, (LONG*)&c, (LPVOID)&pbValue[c]);
            _JumpIfError(hr, error, "SafeArrayPutElement");
        }
                
        V_VT(pVar) = VT_ARRAY|VT_UI1;
        V_ARRAY(pVar) = psa;
        break;

    case REG_DWORD:
	    V_VT(pVar) = VT_I4;
	    V_I4(pVar) = *(LONG const *) pbValue;
        break;

    case REG_MULTI_SZ:
        sab.cElements = CountMultiSz((LPCWSTR)pbValue);
        sab.lLbound = 0;
        psa = SafeArrayCreate(
                            VT_BSTR,
                            1,
                            &sab);
        if(!psa)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "SafeArrayCreate");
        }
        for(DWORD cStr=0; cStr<sab.cElements; cStr++)
        {
            if(!ConvertWszToBstr(
                    &bstr,
                    pwszCrtString,
                    -1))
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "ConvertWszToBstr");
            }

            hr = SafeArrayPutElement(psa, (LONG*)&cStr, bstr);
            _JumpIfError(hr, error, "SafeArrayPutElement");

            pwszCrtString += wcslen(pwszCrtString)+1;

            SysFreeString(bstr);
            bstr = NULL;
        }
        
        V_VT(pVar) = VT_ARRAY|VT_BSTR;
        V_ARRAY(pVar) = psa;
        break;

    default:
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid type");
    }

error:
    if(bstr)
        SysFreeString(bstr);
    return hr;
}


HRESULT
myVariantToRegValue(
    IN VARIANT const *pvarPropertyValue,
    OUT DWORD *pdwType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop)
{
    HRESULT hr = S_OK;
    DWORD cbprop = 0;
    BYTE *pbprop = NULL;
    LONG lVal = 0L;
    LONG lLbound, lUbound;
    void * pData = NULL;
    LPSAFEARRAY psa = NULL; // no free
    BSTR bstr = NULL; // no free

    *ppbprop = NULL;
    *pcbprop = 0;

	switch (pvarPropertyValue->vt)
	{
        case VT_BYREF|VT_BSTR:
        case VT_BSTR:
            bstr = (pvarPropertyValue->vt & VT_BYREF)?
                *V_BSTRREF(pvarPropertyValue):
                V_BSTR(pvarPropertyValue);

            *pdwType = REG_SZ;

            if (NULL == bstr)
		    {
            
                cbprop = 0;
		    }
		    else
		    {
		        pbprop = (BYTE *) bstr;
			    cbprop = (wcslen(bstr) + 1) * sizeof(WCHAR);
		    }
		    break;

        case VT_BYREF|VT_ARRAY|VT_UI1:
        case VT_ARRAY|VT_UI1:
            psa = (pvarPropertyValue->vt & VT_BYREF)?
                *V_ARRAYREF(pvarPropertyValue):
                V_ARRAY(pvarPropertyValue);
            *pdwType = REG_BINARY;
            if(1!=SafeArrayGetDim(psa))
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "only 1 dim array of bytes allowed");
            }
                
            hr = SafeArrayGetLBound(
                psa,
                1,
                &lLbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayGetUBound(
                psa,
                1,
                &lUbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayAccessData(psa, &pData);
            _JumpIfError(hr, error, "SafeArrayGetLBound");
            
            cbprop = lUbound-lLbound+1;
            pbprop = (LPBYTE)pData;
            break;

        case VT_BYREF|VT_I2:
        case VT_I2:
            *pdwType = REG_DWORD;
            pbprop = (BYTE *)((pvarPropertyValue->vt & VT_BYREF)?
                V_I2REF(pvarPropertyValue):
                &V_I2(pvarPropertyValue));
            cbprop = sizeof(V_I2(pvarPropertyValue));
            break;

        case VT_BYREF|VT_I4:
        case VT_I4:
            *pdwType = REG_DWORD;
            pbprop = (BYTE *) ((pvarPropertyValue->vt & VT_BYREF)?
                V_I4REF(pvarPropertyValue):
                &V_I4(pvarPropertyValue));
		    cbprop = sizeof(pvarPropertyValue->lVal);
    		break;

        case VT_BYREF|VT_ARRAY|VT_BSTR:
        case VT_ARRAY|VT_BSTR:
            psa = (pvarPropertyValue->vt & VT_BYREF)?
                *V_ARRAYREF(pvarPropertyValue):
                V_ARRAY(pvarPropertyValue);

            *pdwType = REG_MULTI_SZ;
            if(1!=SafeArrayGetDim(psa))
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "only 1 dim array of bstr allowed");
            }
            
            hr = SafeArrayGetLBound(
                psa,
                1,
                &lLbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayGetUBound(
                psa,
                1,
                &lUbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayAccessData(psa, &pData);
            _JumpIfError(hr, error, "SafeArrayGetLBound");
            
            for(LONG c=0;c<=lUbound-lLbound;c++)
            {
                cbprop += wcslen(((BSTR*)pData)[c])+1;
            }
            cbprop += 1;
            cbprop *= sizeof(WCHAR);

            pbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
            if (NULL == pbprop)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }

            *ppbprop = pbprop;

            for(LONG c=0;c<=lUbound-lLbound;c++)
            {
                wcscpy((LPWSTR)pbprop, ((BSTR*)pData)[c]);
                pbprop += (wcslen((LPWSTR)pbprop)+1)*sizeof(WCHAR);
            }
            
            *(LPWSTR)pbprop = L'\0';

            pbprop = NULL; //avoid copying twice to ppbprop
            break;

	    default:
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "invalid variant type");
	}

    if (NULL != pbprop)
	{
        *ppbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
        if (NULL == *ppbprop)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        CopyMemory(*ppbprop, pbprop, cbprop);
	}

    *pcbprop = cbprop;

error:
    if(S_OK!=hr && pbprop)
    {
        LocalFree(pbprop);
    }

    if(pData)
    {
        CSASSERT(psa);
        SafeArrayUnaccessData(psa);
    }
    return(hr);
}


HRESULT
myUnmarshalVariant(
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    CSASSERT(NULL != pvarValue);
    VariantInit(pvarValue);

    // pb = NULL, cb = 0 always returns VT_EMPTY

    if (NULL == pbValue)
    {
	CSASSERT(0 == cbValue);
        CSASSERT(VT_EMPTY == pvarValue->vt);
        goto error;
    }

    switch (PROPTYPE_MASK & PropType)
    {
	case PROPTYPE_STRING:
	    if (0 == (PROPMARSHAL_LOCALSTRING & PropType) &&
		sizeof(WCHAR) <= cbValue)
	    {
		cbValue -= sizeof(WCHAR);
	    }
	    if (wcslen((WCHAR const *) pbValue) * sizeof(WCHAR) != cbValue)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad string len");
	    }
	    // FALLTHROUGH:

	case PROPTYPE_BINARY:
//	    CSASSERT(0 != cbValue);
	    pvarValue->bstrVal = NULL;
	    if (!ConvertWszToBstr(
			    &pvarValue->bstrVal,
			    (WCHAR const *) pbValue,
			    cbValue))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "ConvertWszToBstr");
	    }
	    pvarValue->vt = VT_BSTR;
	    break;

	case PROPTYPE_LONG:
	    CSASSERT(sizeof(LONG) == cbValue);
	    pvarValue->vt = VT_I4;
	    pvarValue->lVal = *(LONG const *) pbValue;
	    break;

	case PROPTYPE_DATE:
	    CSASSERT(sizeof(FILETIME) == cbValue);
	    hr = myFileTimeToDate(
				(FILETIME const *) pbValue,
				&pvarValue->date);
	    _JumpIfError(hr, error, "myFileTimeToDate");

	    pvarValue->vt = VT_DATE;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropType parameter");
    }

error:
    return(hr);
}


HRESULT
myUnmarshalFormattedVariant(
    IN DWORD Flags,
    IN DWORD PropId,
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue)
{
    HRESULT hr;
    BSTR strCert;
    
    hr = myUnmarshalVariant(
		    PropType,
		    cbValue,
		    pbValue,
		    pvarValue);
    _JumpIfError(hr, error, "myUnmarshalVariant");

    if (PROPTYPE_BINARY == (PROPTYPE_MASK & PropType))
    {
	CSASSERT(VT_BSTR == pvarValue->vt);

	CSASSERT(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
	CSASSERT(CV_OUT_BASE64 == CRYPT_STRING_BASE64);
	CSASSERT(CV_OUT_BINARY == CRYPT_STRING_BINARY);
	CSASSERT(CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER);
	CSASSERT(CV_OUT_HEX == CRYPT_STRING_HEX);
	CSASSERT(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII);
	CSASSERT(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR);
	CSASSERT(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR);

	switch (Flags)
	{
	    case CV_OUT_BASE64HEADER:
		if (CR_PROP_BASECRL == PropId || CR_PROP_DELTACRL == PropId)
		{
		    Flags = CV_OUT_BASE64X509CRLHEADER;
		}
		else
		if (MAXDWORD == PropId)
		{
		    Flags = CV_OUT_BASE64REQUESTHEADER;
		}
		break;

	    case CV_OUT_BASE64:
	    case CV_OUT_BINARY:
	    case CV_OUT_BASE64REQUESTHEADER:
	    case CV_OUT_BASE64X509CRLHEADER:
	    case CV_OUT_HEX:
	    case CV_OUT_HEXASCII:
	    case CV_OUT_HEXADDR:
	    case CV_OUT_HEXASCIIADDR:
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Flags");
	}

	if (CV_OUT_BINARY != Flags)
	{
	    strCert = NULL;
	    hr = EncodeCertString(pbValue, cbValue, Flags, &strCert);
	    _JumpIfError(hr, error, "EncodeCertString");

	    SysFreeString(pvarValue->bstrVal);
	    pvarValue->bstrVal = strCert;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myMarshalVariant(
    IN VARIANT const *pvarPropertyValue,
    IN DWORD PropType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop)
{
    HRESULT hr = S_OK;
    DWORD cbprop = 0;
    BYTE *pbprop = NULL;
    BSTR str = NULL;
    FILETIME ft;
    LONG lval;

    *ppbprop = NULL;

    // VT_EMPTY always produces same result: *ppbprop = NULL, *pcbprop = 0
    if (VT_EMPTY != pvarPropertyValue->vt)
    {
	switch (PROPTYPE_MASK & PropType)
	{
	    case PROPTYPE_BINARY:
	    case PROPTYPE_STRING:
		switch (pvarPropertyValue->vt)
		{
		    case VT_BYREF | VT_BSTR:
			if (NULL != pvarPropertyValue->pbstrVal)
			{
			    str = *pvarPropertyValue->pbstrVal;
			}
			break;

		    case VT_BSTR:
			str = pvarPropertyValue->bstrVal;
			break;
		}
		if (NULL == str)
		{
		    if (PROPTYPE_STRING == (PROPTYPE_MASK & PropType) &&
			(PROPMARSHAL_NULLBSTROK & PropType) &&
			VT_NULL == pvarPropertyValue->vt)
		    {
			cbprop = 0;
		    }
		    else
		    {
			hr = E_INVALIDARG;
			_JumpError(
				pvarPropertyValue->vt,
				error,
				"variant BSTR type/value");
		    }
		}
		else
		{
		    pbprop = (BYTE *) str;
		    if (PROPTYPE_BINARY == (PROPTYPE_MASK & PropType))
		    {
			cbprop = SysStringByteLen(str) + sizeof(WCHAR);
		    }
		    else
		    {
			cbprop = (wcslen(str) + 1) * sizeof(WCHAR);
		    }
		}
		break;

	    case PROPTYPE_LONG:
		// VB likes to send small constant integers as VT_I2

		if (VT_I2 == pvarPropertyValue->vt)
		{
		    lval = pvarPropertyValue->iVal;
		}
		else if (VT_I4 == pvarPropertyValue->vt)
		{
		    lval = pvarPropertyValue->lVal;
		}
		else if (VT_EMPTY == pvarPropertyValue->vt)
		{
		    pbprop = NULL;
		    cbprop = 0;
		    break;
		}
		else
		{
		    hr = E_INVALIDARG;
		    _JumpError(pvarPropertyValue->vt, error, "variant LONG type");
		}
		pbprop = (BYTE *) &lval;
		cbprop = sizeof(lval);
		break;

	    case PROPTYPE_DATE:
		if (VT_DATE == pvarPropertyValue->vt)
		{
		    hr = myDateToFileTime(&pvarPropertyValue->date, &ft);
		    _JumpIfError(hr, error, "myDateToFileTime");
		}
		else if (VT_EMPTY == pvarPropertyValue->vt)
		{
		    pbprop = NULL;
		    cbprop = 0;
		    break;
		}
		else
		{
		    hr = E_INVALIDARG;
		    _JumpError(pvarPropertyValue->vt, error, "variant DATE type");
		}

		pbprop = (BYTE *) &ft;
		cbprop = sizeof(ft);
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(pvarPropertyValue->vt, error, "variant type/value");
	}
	if (NULL != pbprop)
	{
	    *ppbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
	    if (NULL == *ppbprop)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(*ppbprop, pbprop, cbprop);
	    if (NULL != str &&
		sizeof(WCHAR) <= cbprop &&
		((PROPMARSHAL_LOCALSTRING & PropType) ||
		 PROPTYPE_BINARY == (PROPTYPE_MASK & PropType)))
	    {
		cbprop -= sizeof(WCHAR);
	    }
	}
    }
    *pcbprop = cbprop;

error:
    return(hr);
}


// IsCharRegKeyChar -- Determines if a character is valid for use in a file
// name AND in a registry key name.
#define wszInvalidFileAndKeyChars  L"<>\"/\\:|?*"
#define wszUnsafeURLChars          L"#\"&<>[]^`{}|"
#define wszUnsafeDSChars           L"()='\"`,;+"

BOOL
myIsCharSanitized(
    IN WCHAR wc)
{
    BOOL fCharOk = TRUE;
    if (L' ' > wc ||
        L'~' < wc ||
        NULL != wcschr(
		    wszInvalidFileAndKeyChars
			wszUnsafeURLChars
			wszSANITIZEESCAPECHAR
			wszURLESCAPECHAR
			wszUnsafeDSChars,
		    wc))
    {
	fCharOk = FALSE;
    }
    return(fCharOk);
}


HRESULT
mySanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszPassedName;
    WCHAR *pwszDst;
    WCHAR *pwszOut = NULL;
    WCHAR wcChar;
    DWORD dwSize;

    *ppwszNameOut = NULL;
    pwszPassedName = pwszName;

    dwSize = 0;

    if (NULL == pwszName)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "pwszName NULL");
    }

    while (L'\0' != (wcChar = *pwszPassedName++))
    {
	if (myIsCharSanitized(wcChar))
	{
	    dwSize++;
	}
        else
        {
            dwSize += 5; // format !XXXX
        }
    }
    if (0 == dwSize)
    {
        goto error; // done
    }

    pwszOut = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, (dwSize + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszDst = pwszOut;
    while (L'\0' != (wcChar = *pwszName++))
    {
	if (myIsCharSanitized(wcChar))
	{
            *pwszDst = wcChar;
	    pwszDst++;
	}
        else
        {
            wsprintf(pwszDst, L"%ws", wszSANITIZEESCAPECHAR);
            pwszDst++;
            wsprintf(pwszDst, L"%04x", wcChar);
	    pwszDst += 4;
        }
    }
    *pwszDst = wcChar; // L'\0' terminator

    *ppwszNameOut = pwszOut;
    pwszOut = NULL;

    hr = S_OK;
error:
    if (NULL != pwszOut)
    {
        LocalFree(pwszOut);
    }
    return(hr);
}


BOOL
ScanHexEscapeDigits(
    IN WCHAR const *pwszHex,
    OUT WCHAR *pwcRevert)
{
    BOOL ret = FALSE;
    DWORD i;
    WCHAR wc;
    WCHAR wszValue[5];

    for (i = 0; i < 4; i++)
    {
	wc = pwszHex[i];
	wszValue[i] = wc;
	if (!isascii(wc) || !isxdigit((char) wc))
	{
	    goto error;
	}
    }
    wszValue[4] = L'\0';
    swscanf(wszValue, L"%04x", &i);
    *pwcRevert = (WCHAR) i;
    ret = TRUE;

error:
    return(ret);
}


// This function will truncate the output if pwszName contains "!0000".
// The output string is L'\0' terminated, so the length is not returned.

HRESULT
myRevertSanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    DWORD i;
    DWORD cwc;
    WCHAR wc;
    WCHAR wcRevert;
    WCHAR *pwszRevert;

    *ppwszNameOut = NULL;

    if (NULL == pwszName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL sanitized name");
    }
    cwc = wcslen(pwszName);
    *ppwszNameOut = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == *ppwszNameOut)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Out of memory");
    }

    pwszRevert = *ppwszNameOut;
    while (L'\0' != *pwszName)
    {
	wc = *pwszName++;

        if (wcSANITIZEESCAPECHAR == wc &&
            ScanHexEscapeDigits(pwszName, &wcRevert))
        {
	    wc = wcRevert;
	    pwszName += 4;
        }
        *pwszRevert++ = wc;
    }
    *pwszRevert = L'\0';
    CSASSERT(wcslen(*ppwszNameOut) <= cwc);
    hr = S_OK;

error:
    return hr;
}


#define cwcCNMAX 	64		// 64 chars max for CN
#define cwcCHOPHASHMAX	(1 + 5)		// "-%05hu" decimal USHORT hash digits
#define cwcCHOPBASE 	(cwcCNMAX - (cwcCHOPHASHMAX + cwcSUFFIXMAX))

HRESULT
mySanitizedNameToDSName(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcCopy;
    WCHAR wszDSName[cwcCHOPBASE + cwcCHOPHASHMAX + 1];

    *ppwszNameOut = NULL;

    cwc = wcslen(pwszSanitizedName);
    cwcCopy = cwc;
    if (cwcCHOPBASE < cwcCopy)
    {
	cwcCopy = cwcCHOPBASE;
    }
    CopyMemory(wszDSName, pwszSanitizedName, cwcCopy * sizeof(WCHAR));
    wszDSName[cwcCopy] = L'\0';

    if (cwcCHOPBASE < cwc)
    {
        // Hash the rest of the name into a USHORT
        USHORT usHash = 0;
	DWORD i;
	WCHAR *pwsz;

	// Truncate an incomplete sanitized Unicode character
	
	pwsz = wcsrchr(wszDSName, L'!');
	if (NULL != pwsz && wcslen(pwsz) < 5)
	{
	    cwcCopy -= wcslen(pwsz);
	    *pwsz = L'\0';
	}

        for (i = cwcCopy; i < cwc; i++)
        {
            USHORT usLowBit = (0x8000 & usHash)? 1 : 0;

	    usHash = ((usHash << 1) | usLowBit) + pwszSanitizedName[i];
        }
	wsprintf(&wszDSName[cwcCopy], L"-%05hu", usHash);
	CSASSERT(wcslen(wszDSName) < ARRAYSIZE(wszDSName));
    }

    hr = myDupString(wszDSName, ppwszNameOut);
    _JumpIfError(hr, error, "myDupString");

    DBGPRINT((DBG_SS_CERTLIBI, "mySanitizedNameToDSName(%ws)\n", *ppwszNameOut));

error:
    return(hr);
}


// Decode OCTET string, and convert UTF8 string to Unicode.
// Can return S_OK and NULL pointer.

HRESULT
myDecodeCMCRegInfo(
    IN BYTE const *pbOctet,
    IN DWORD cbOctet,
    OUT WCHAR **ppwszRA)
{
    HRESULT hr;
    CRYPT_DATA_BLOB *pBlob = NULL;
    DWORD cb;

    *ppwszRA = NULL;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    pbOctet,
		    cbOctet,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pBlob,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (0 != pBlob->cbData && NULL != pBlob->pbData)
    {
	if (!myConvertUTF8ToWsz(
			ppwszRA,
			(CHAR const *) pBlob->pbData,
			pBlob->cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myConvertUTF8ToWsz");
	}
    }
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}


DWORD
myGetCertNameProperty(
    IN CERT_NAME_INFO const *pNameInfo,
    IN char const *pszObjId,
    OUT WCHAR const **ppwszName)
{
    HRESULT hr;
    CERT_RDN_ATTR const *prdnaT;
    CERT_RDN const *prdn;
    CERT_RDN const *prdnEnd;

    prdnaT = NULL;
    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    if (0 == strcmp(prdna->pszObjId, pszObjId))
	    {
		prdnaT = prdna;
	    }
	}
    }
    if (NULL == prdnaT)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	goto error;
    }

    *ppwszName = (WCHAR const *) prdnaT->Value.pbData;
    hr = S_OK;

error:
    return(hr);

}


VOID
myGenerateGuidSerialNumber(
    OUT GUID *pguidSerialNumber)
{
    HRESULT hr;
    BYTE *pb;

    ZeroMemory(pguidSerialNumber, sizeof(*pguidSerialNumber));
    hr = UuidCreate(pguidSerialNumber);
    if (S_OK != hr)
    {
	BYTE *pbEnd;
	
	CSASSERT(RPC_S_UUID_LOCAL_ONLY == hr);

	// No net card?  Fake up a GUID:

	pb = (BYTE *) pguidSerialNumber;
	pbEnd = (BYTE *) pb + sizeof(*pguidSerialNumber);

	GetSystemTimeAsFileTime((FILETIME *) pb);
	pb += sizeof(FILETIME);

	while (pb < pbEnd)
	{
	    *(DWORD *) pb = GetTickCount();
	    pb += sizeof(DWORD);
	}
	CSASSERT(pb == pbEnd);
    }
    pb = &((BYTE *) pguidSerialNumber)[sizeof(*pguidSerialNumber) - 1];

    // make sure the last byte is never zero
    if (0 == *pb)
    {
	*pb = 'z';
    }

    // Some clients can't handle negative serial numbers:
    *pb &= 0x7f;
}


BOOL
myAreBlobsSame(
    IN BYTE const *pbData1,
    IN DWORD cbData1,
    IN BYTE const *pbData2,
    IN DWORD cbData2)
{
    BOOL ret = FALSE;

    if (cbData1 != cbData2)
    {
        goto error;
    }
    if (NULL != pbData1 && NULL != pbData2)
    {
	if (0 != memcmp(pbData1, pbData2, cbData1))
	{
	    goto error;
	}
    }

    // else at least one is NULL -- they'd better both be NULL, & the count 0.

    else if (pbData1 != pbData2 || 0 != cbData1)
    {
	goto error;
    }
    ret = TRUE;

error:
    return(ret);
}


BOOL
myAreSerialNumberBlobsSame(
    IN CRYPT_INTEGER_BLOB const *pBlob1,
    IN CRYPT_INTEGER_BLOB const *pBlob2)
{
    DWORD cbData1 = pBlob1->cbData;
    DWORD cbData2 = pBlob2->cbData;

    if (NULL != pBlob1->pbData)
    {
	while (0 != cbData1 && 0 == pBlob1->pbData[cbData1 - 1])
	{
	    cbData1--;
	}
    }
    if (NULL != pBlob2->pbData)
    {
	while (0 != cbData2 && 0 == pBlob2->pbData[cbData2 - 1])
	{
	    cbData2--;
	}
    }
    return(myAreBlobsSame(pBlob1->pbData, cbData1, pBlob2->pbData, cbData2));
}


WCHAR const g_wszCert[] = L"cert";

HRESULT
myIsDirWriteable(
    IN WCHAR const *pwszPath,
    IN BOOL fFilePath)
{
    HRESULT hr;
    WCHAR *pwszBase;
    WCHAR *pwsz;
    WCHAR wszDir[MAX_PATH];
    WCHAR wszTempFile[MAX_PATH];

    if (fFilePath &&
	iswalpha(pwszPath[0]) &&
	L':' == pwszPath[1] &&
	L'\0' == pwszPath[2])
    {
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpErrorStr(hr, error, "not a file path", pwszPath);
    }
    if (!GetFullPathName(
		pwszPath,
		ARRAYSIZE(wszDir),
		wszDir,
		&pwsz))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "GetFullPathName", pwszPath);
    }
    if (fFilePath)
    {
	if (NULL == pwsz)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	    _JumpErrorStr(hr, error, "not a file path", pwszPath);
	}
	pwszBase = wszDir;
	if (iswalpha(wszDir[0]) &&
	    L':' == wszDir[1] &&
	    L'\\' == wszDir[2])
	{
	    pwszBase += 3;
	}
	else if (L'\\' == wszDir[0] && L'\\' == wszDir[1])
	{
	    pwszBase += 2;
	}

	if (pwsz > pwszBase && L'\\' == pwsz[-1])
	{
	    pwsz--;
	}
	*pwsz = L'\0';
    }

    if (!GetTempFileName(wszDir, g_wszCert, 0, wszTempFile))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "GetTempFileName", wszDir);

    }
    if (!DeleteFile(wszTempFile))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "DeleteFile", wszTempFile);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetComputerObjectName(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszComputerObjectName)
{
    HRESULT hr;
    WCHAR *pwszComputerObjectName = NULL;
    DWORD cwc;

    *ppwszComputerObjectName = NULL;

    cwc = 0;
    if (!GetComputerObjectName(NameFormat, NULL, &cwc))
    {
	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError(hr, error, "GetComputerObjectName");
	}
    }

    pwszComputerObjectName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszComputerObjectName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!GetComputerObjectName(NameFormat, pwszComputerObjectName, &cwc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetComputerObjectName");
    }

    *ppwszComputerObjectName = pwszComputerObjectName;
    pwszComputerObjectName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszComputerObjectName)
    {
	LocalFree(pwszComputerObjectName);
    }
    return(hr);
}


HRESULT
myGetComputerNames(
    OUT WCHAR **ppwszDnsName,
    OUT WCHAR **ppwszOldName)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszOldName = NULL;

    *ppwszOldName = NULL;
    *ppwszDnsName = NULL;

    cwc = MAX_COMPUTERNAME_LENGTH + 1;
    pwszOldName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszOldName)
    {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }
    if (!GetComputerName(pwszOldName, &cwc))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetComputerName");
    }

    hr = myGetMachineDnsName(ppwszDnsName);
    _JumpIfError(hr, error, "myGetMachineDnsName");

    *ppwszOldName = pwszOldName;
    pwszOldName = NULL;

error:
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}


typedef LANGID (WINAPI FNSETTHREADUILANGUAGE)(
    IN WORD wReserved);

LANGID
mySetThreadUILanguage(
    IN WORD wReserved)
{
    HMODULE hModule;
    LANGID lang = 0;
    DWORD err;
    static FNSETTHREADUILANGUAGE *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	hModule = GetModuleHandle(TEXT("kernel32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSETTHREADUILANGUAGE *) GetProcAddress(
						   hModule,
						   "SetThreadUILanguage");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    lang = (*s_pfn)(wReserved);

error:
    return(lang);
}


HRESULT
myFormConfigString(
    IN WCHAR const  *pwszServer,
    IN WCHAR const  *pwszCAName,
    OUT WCHAR      **ppwszConfig)
{
    HRESULT  hr;
    WCHAR   *pwszConfig = NULL;

    *ppwszConfig = NULL;

    pwszConfig = (WCHAR *) LocalAlloc(LPTR,
                (wcslen(pwszServer) + wcslen(pwszCAName) + 2) * sizeof(WCHAR));
    if (NULL == pwszConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszConfig, pwszServer);
    wcscat(pwszConfig, L"\\");
    wcscat(pwszConfig, pwszCAName);

    *ppwszConfig = pwszConfig;

    hr = S_OK;
error:
    return hr;
}


HRESULT
myCLSIDToWsz(
    IN CLSID const *pclsid,
    OUT WCHAR **ppwsz)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    WCHAR *pwsz1;
    WCHAR *pwsz2;

    *ppwsz = NULL;
    hr = StringFromCLSID(*pclsid, &pwsz);
    _JumpIfError(hr, error, "StringFromCLSID");

    for (pwsz1 = pwsz; L'\0' != *pwsz1; pwsz1++)
    {
	if (L'A' <= *pwsz1 && L'F' >= *pwsz1)
	{
	    *pwsz1 += L'a' - L'A';
	}
    }

    pwsz1 = pwsz;
    pwsz2 = &pwsz[wcslen(pwsz) - 1];
    if (wcLBRACE == *pwsz1 && wcRBRACE == *pwsz2)
    {
	pwsz1++;
	*pwsz2 = L'\0';
    }
    hr = myDupString(pwsz1, ppwsz);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwsz)
    {
	CoTaskMemFree(pwsz);
    }
    return(hr);
}


HRESULT
myLoadRCString(
    IN HINSTANCE   hInstance,
    IN int         iRCId,
    OUT WCHAR    **ppwsz)
{
#define CS_RCALLOCATEBLOCK 256
    HRESULT   hr;
    WCHAR    *pwszTemp = NULL;
    int       sizeTemp;
    int       size;
    int       cBlocks = 1;

    *ppwsz = NULL;

    while (NULL == pwszTemp)
    {
        sizeTemp = cBlocks * CS_RCALLOCATEBLOCK;

        pwszTemp = (WCHAR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                        sizeTemp * sizeof(WCHAR));
	if (NULL == pwszTemp)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

        size = LoadString(
                   hInstance,
                   iRCId,
                   pwszTemp,
                   sizeTemp);
        if (0 == size)
        {
            hr = myHLastError();
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"myLoadRCString(hInstance=%x, iRCId=%u) --> %x\n",
		hInstance,
		iRCId,
		hr));
            if (S_OK != hr &&
                HRESULT_FROM_WIN32(ERROR_RESOURCE_NAME_NOT_FOUND) != hr)
            {
                _JumpError(hr, error, "LoadString");
            }
        }

        if (size < sizeTemp - 1)
        {
            // ok, size is big enough
            break;
        }
        ++cBlocks;
        LocalFree(pwszTemp);
        pwszTemp = NULL;
    }

    *ppwsz = (WCHAR*) LocalAlloc(LPTR, (size+1) * sizeof(WCHAR));
    if (NULL == *ppwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (0 == size)
    {
        // two possible cases, 1) real empty string or
        // 2) id not found in resource. either case make it empty string
        **ppwsz = L'\0';
    }
    else
    {
        // copy it
        wcscpy(*ppwsz, pwszTemp);
    }

    hr = S_OK;
error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return hr;
}


HRESULT
_IsConfigLocal(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwsz;
    DWORD cwc;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL != pwsz)
    {
	cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
    }
    else
    {
	cwc = wcslen(pwszConfig);
    }
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszMachine, pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';

    if (0 == lstrcmpi(pwszMachine, pwszDnsName) ||
	0 == lstrcmpi(pwszMachine, pwszOldName))
    {
	*pfLocal = TRUE;
    }
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = pwszMachine;
	pwszMachine = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    return(hr);
}


HRESULT
myIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszOldName = NULL;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    hr = myGetComputerNames(&pwszDnsName, &pwszOldName);
    _JumpIfError(hr, error, "myGetComputerNames");

    hr = _IsConfigLocal(
		    pwszConfig,
		    pwszDnsName,
		    pwszOldName,
		    ppwszMachine,
		    pfLocal);
    _JumpIfError(hr, error, "_IsConfigLocal");

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}


HRESULT
myIsConfigLocal2(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    
    hr = _IsConfigLocal(
		    pwszConfig,
		    pwszDnsName,
		    pwszOldName,
		    NULL,
		    pfLocal);
    _JumpIfError(hr, error, "_IsConfigLocal");

error:
    return(hr);
}


HRESULT
myGetConfig(
    IN DWORD dwUIFlag,
    OUT WCHAR **ppwszConfig)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strConfig = NULL;
    WCHAR *pwszConfig = NULL;
    WCHAR *pwszActiveCA = NULL;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszDnsName = NULL;

    CSASSERT(NULL != ppwszConfig);
    *ppwszConfig = NULL;

    hr = ConfigGetConfig(DISPSETUP_COM, dwUIFlag, &strConfig);
    if (S_OK != hr)
    {
	if (CC_LOCALCONFIG != dwUIFlag)
	{
	    _JumpError(hr, error, "ConfigGetConfig");
	}
	hr2 = hr;

	hr = myGetCertRegStrValue(
			    NULL,
			    NULL,
			    NULL,
			    wszREGACTIVE,
			    &pwszActiveCA);
	_PrintIfError(hr, "myGetCertRegStrValue");

	if (S_OK == hr)
	{
	    hr = myGetCertRegStrValue(
				pwszActiveCA,
				NULL,
				NULL,
				wszREGCOMMONNAME,
				&pwszCommonName);
	    _PrintIfError(hr, "myGetCertRegStrValue");
	}
	if (S_OK != hr)
	{
	    hr = hr2;
	    _JumpError(hr, error, "ConfigGetConfig");
	}
	hr = myGetMachineDnsName(&pwszDnsName);
	_JumpIfError(hr, error, "myGetMachineDnsName");

	hr = myFormConfigString(pwszDnsName, pwszCommonName, &pwszConfig);
	_JumpIfError(hr, error, "myFormConfigString");

	if (!ConvertWszToBstr(&strConfig, pwszConfig, MAXDWORD))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }
    *ppwszConfig = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				SysStringByteLen(strConfig) + sizeof(WCHAR));
    if (NULL == *ppwszConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszConfig, strConfig);
    CSASSERT(
	wcslen(*ppwszConfig) * sizeof(WCHAR) ==
	SysStringByteLen(strConfig));
    hr = S_OK;

error:
    if (NULL != pwszActiveCA)
    {
	LocalFree(pwszActiveCA);
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    if (NULL != pwszConfig)
    {
	LocalFree(pwszConfig);
    }
    if (NULL != strConfig)
    {
        SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
myBuildPathAndExt(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile,
    OPTIONAL IN WCHAR const *pwszExt,
    OUT WCHAR **ppwszPath)
{
    HRESULT hr;
    WCHAR *pwsz;
    DWORD cwc;

    *ppwszPath = NULL;
    cwc = wcslen(pwszDir) + 1 + wcslen(pwszFile) + 1;
    if (NULL != pwszExt)
    {
	cwc += wcslen(pwszExt);
    }

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwsz, pwszDir);
    if (L'\\' != pwsz[wcslen(pwsz) - 1])
    {
	wcscat(pwsz, L"\\");
    }
    wcscat(pwsz, pwszFile);
    if (NULL != pwszExt)
    {
	wcscat(pwsz, pwszExt);
    }
    *ppwszPath = pwsz;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myDeleteFilePattern(
    IN WCHAR const *pwszDir,
    OPTIONAL IN WCHAR const *pwszPattern,	// defaults to L"*.*"
    IN BOOL fRecurse)
{
    HRESULT hr;
    HRESULT hr2;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR *pwszFindPath = NULL;
    WCHAR *pwszDeleteFile;
    WCHAR *pwszDeletePath = NULL;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myDeleteFilePattern(%ws, %ws, %ws)\n",
	pwszDir,
	pwszPattern,
	fRecurse? L"Recurse" : L"NO Recurse"));

    if (NULL == pwszPattern)
    {
	pwszPattern = L"*.*";
    }

    hr = myBuildPathAndExt(pwszDir, pwszPattern, NULL, &pwszFindPath);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    pwszDeletePath = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszDir) +  1 + MAX_PATH) * sizeof(WCHAR));
    if (NULL == pwszDeletePath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszDeletePath, pwszFindPath);
    pwszDeleteFile = wcsrchr(pwszDeletePath, L'\\');
    CSASSERT(NULL != pwszDeleteFile);
    pwszDeleteFile++;

    hf = FindFirstFile(pwszFindPath, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
	    HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
	{
	    hr = S_OK;
	    goto error;
	}
	_JumpErrorStr(hr, error, "FindFirstFile", pwszFindPath);
    }
    do
    {
	wcscpy(pwszDeleteFile, wfd.cFileName);
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    if (fRecurse &&
		0 != lstrcmp(L".", wfd.cFileName) &&
		0 != lstrcmp(L"..", wfd.cFileName))
	    {
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "myDeleteFilePattern(DIR): %ws\n",
		    pwszDeletePath));
		hr2 = myRemoveFilesAndDirectory(pwszDeletePath, TRUE);
		if (S_OK != hr2)
		{
		    if (S_OK == hr)
		    {
			hr = hr2;		// only return first error
		    }
		    _PrintErrorStr(hr2, "myRemoveFilesAndDirectory", pwszDeletePath);
		}
	    }
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"myDeleteFilePattern: %ws\n",
		pwszDeletePath));
	    if (!DeleteFile(pwszDeletePath))
	    {
		hr2 = myHLastError();
		if (S_OK == hr)
		{
		    hr = hr2;		// only return first error
		}
		_PrintErrorStr(hr2, "DeleteFile", pwszDeletePath);
	    }
	}
    } while (FindNextFile(hf, &wfd));
    FindClose(hf);

error:
    if (NULL != pwszFindPath)
    {
	LocalFree(pwszFindPath);
    }
    if (NULL != pwszDeletePath)
    {
	LocalFree(pwszDeletePath);
    }
    return(hr);
}


HRESULT
myRemoveFilesAndDirectory(
    IN WCHAR const *pwszPath,
    IN BOOL fRecurse)
{
    HRESULT hr;
    HRESULT hr2;

    hr = myDeleteFilePattern(pwszPath, NULL, fRecurse);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "myDeleteFilePattern", pwszPath);
    }
    if (!RemoveDirectory(pwszPath))
    {
	hr2 = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr2 &&
	    HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr2)
	{
	    if (S_OK == hr)
	    {
		hr = hr2;		// only return first error
	    }
	    _JumpErrorStr(hr2, error, "RemoveDirectory", pwszPath);
	}
    }

error:
    return(hr);
}


BOOL
myIsFullPath(
    IN WCHAR const *pwszPath,
    OUT DWORD      *pdwFlag)
{
    BOOL fFullPath = FALSE;

    *pdwFlag = 0;
    if (NULL != pwszPath)
    {
	if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1])
	{
	    fFullPath = TRUE;
	    *pdwFlag = UNC_PATH;
	}
	else
	if (iswalpha(pwszPath[0]) &&
	    L':' == pwszPath[1] &&
	    L'\\' == pwszPath[2])
	{
	    fFullPath = TRUE;
	    *pdwFlag = LOCAL_PATH;
	}
    }
    return(fFullPath);
}



// Convert local full path to UNC, as in c:\foo... --> \\server\c$\foo...
// If pwszServer is NULL or empty, preserve the local full path

HRESULT
myConvertLocalPathToUNC(
    OPTIONAL IN WCHAR const *pwszServer,
    IN WCHAR const *pwszFile,
    OUT WCHAR **ppwszFileUNC)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR const *pwsz;
    WCHAR *pwszDst;
    WCHAR *pwszFileUNC = NULL;

    if (!iswalpha(pwszFile[0]) || L':' != pwszFile[1] || L'\\' != pwszFile[2])
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "non-local path");
    }
    if (NULL != pwszServer && L'\0' == *pwszServer)
    {
	pwszServer = NULL;
    }
    cwc = wcslen(pwszFile) + 1;
    if (NULL != pwszServer)
    {
	cwc += 2 + wcslen(pwszServer) + 1;
    }

    pwszFileUNC = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszFileUNC)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc pwszFiles");
    }

    pwsz = pwszFile;
    pwszDst = pwszFileUNC;
    if (NULL != pwszServer)
    {
	wcscpy(pwszDst, L"\\\\");	// --> "\\"
	wcscat(pwszDst, pwszServer);	// --> "\\server"
	pwszDst += wcslen(pwszDst);
	*pwszDst++ = L'\\';		// --> "\\server\"
	*pwszDst++ = *pwsz++;		// --> "\\server\c"
	*pwszDst++ = L'$';		// --> "\\server\c$"
	pwsz++;				// skip colon
    }
    wcscpy(pwszDst, pwsz);		// --> "\\server\c$\foo..."

    *ppwszFileUNC = pwszFileUNC;
    hr = S_OK;

error:
    return(hr);
}


WCHAR const *
LocalStart(
    IN WCHAR const *pwsz,
    OUT BOOL *pfUNC)
{
    WCHAR const *pwc;

    *pfUNC = FALSE;
    pwc = pwsz;
    if (L'\\' != *pwc)
    {
	pwc++;
    }
    if (L'\\' == pwc[0] || L'\\' == pwc[1])
    {
	pwc = wcschr(&pwc[2], L'\\');
	if (NULL != pwc &&
	    iswalpha(pwc[1]) &&
	    L'$' == pwc[2] &&
	    L'\\' == pwc[3])
	{
	    pwsz = &pwc[1];
	    *pfUNC = TRUE;
	}
    }
    return(pwsz);
}


ULONG
myLocalPathwcslen(
    IN WCHAR const *pwsz)
{
    BOOL fUNC;

    return(wcslen(LocalStart(pwsz, &fUNC)));
}


VOID
myLocalPathwcscpy(
    OUT WCHAR *pwszOut,
    IN WCHAR const *pwszIn)
{
    BOOL fUNC;

    wcscpy(pwszOut, LocalStart(pwszIn, &fUNC));
    if (fUNC)
    {
	CSASSERT(L'$' == pwszOut[1]);
	pwszOut[1] = L':';
    }
}


HRESULT
myConvertUNCPathToLocal(
    IN WCHAR const *pwszUNCPath,
    OUT WCHAR **ppwszLocalPath)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszLocalPath;
    
    CSASSERT(NULL != pwszUNCPath);
    CSASSERT(NULL != ppwszLocalPath);
    *ppwszLocalPath = NULL;

    if (L'\\' != pwszUNCPath[0] || L'\\' != pwszUNCPath[1])
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad parm");
    }
    cwc = myLocalPathwcslen(pwszUNCPath) + 1;
    pwszLocalPath = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszLocalPath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    myLocalPathwcscpy(pwszLocalPath, pwszUNCPath);
    *ppwszLocalPath = pwszLocalPath;
    hr = S_OK;

error:
    return(hr);
}

//+-------------------------------------------------------------------------
//  Description: create any number of directories in one call
//--------------------------------------------------------------------------
HRESULT
myCreateNestedDirectories(
    WCHAR const *pwszDirectory)
{
    HRESULT hr;

    WCHAR   rgszDir[MAX_PATH];          // static buffer
    WCHAR   *pszNext = const_cast<WCHAR*>(pwszDirectory);   // point to end of current directory
    
    // skip "X:\"
    if ((pszNext[1] == L':') && 
        (pszNext[2] == L'\\'))
        pszNext += 3;

    while (pszNext)   // incr past
    {
        DWORD ch;

        // find the next occurence of '\'
        pszNext = wcschr(pszNext, L'\\');
        if (pszNext == NULL)
        {
            // last directory: copy everything
            wcscpy(rgszDir, pwszDirectory);
        }
        else
        {
            // else copy up to Next ptr 
            ch = SAFE_SUBTRACT_POINTERS(pszNext, pwszDirectory);
            if (0 != ch)
            {
                CopyMemory(rgszDir, pwszDirectory, ch*sizeof(WCHAR));
        
                // zero-term
                rgszDir[ch] = L'\0';
            
                // incr past '\\'
                pszNext++;  
            }
            else
            {
                //if ch = 0, means the first char is \, skip CreateDirectory
                pszNext++; //must shift to next char to get out of loop
                continue;
            }
        }
        
        // UNDONE: PeteSk - add in directory security
        if (!CreateDirectory(rgszDir, NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
            {
                // something must be wrong with the path
                _JumpError(hr, error, "CreateDirectory");
            }
        }
    }

    hr = S_OK;
    
error:
    return hr;
}


HRESULT
myUncanonicalizeURLParm(
    IN WCHAR const *pwszParmIn,
    OUT WCHAR **ppwszParmOut)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszCanon = NULL;
    WCHAR *pwszUncanon = NULL;
    static const WCHAR s_wszLdap[] = L"ldap:///";

    *ppwszParmOut = NULL;

    cwc = WSZARRAYSIZE(s_wszLdap) + wcslen(pwszParmIn);
    pwszCanon = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszCanon)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszCanon, s_wszLdap);
    wcscat(&pwszCanon[WSZARRAYSIZE(s_wszLdap)], pwszParmIn);

    hr = myInternetUncanonicalizeURL(pwszCanon, &pwszUncanon);
    _JumpIfError(hr, error, "myInternetUncanonicalizeURL");

    hr = myDupString(&pwszUncanon[WSZARRAYSIZE(s_wszLdap)], ppwszParmOut);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwszCanon)
    {
	LocalFree(pwszCanon);
    }
    if (NULL != pwszUncanon)
    {
	LocalFree(pwszUncanon);
    }
    return(hr);
}


// myFormatCertsrvStringArray FormatMessage arguments:
//
// %1 -- Machine full DNS name: pwszServerName_p1_2;
//
// %2 -- Machine short name: first DNS component of pwszServerName_p1_2
//
// %3 -- Sanitized CA name: pwszSanitizedName_p3_7 
//
// %4 -- Cert Filename Suffix: L"" if 0 == iCert_p4; else L"(%u)"
//
// %5 -- DS DN path to Domain root: pwszDomainDN_p5
//
// %6 -- DS DN path to Configuration container: pwszConfigDN_p6
//
// %7 -- Sanitized CA name, truncated and hash suffix added if too long:
//	 pwszSanitizedName_p3_7
//
// %8 -- CRL Filename/Key Name Suffix: L"" if 0 == iCRL_p8; else L"(%u)"
//
// %9 -- CRL Filename Suffix: L"" if !fDeltaCRL_p9; else L"+"
//
// %10 -- DS CRL attribute: L"" if !fDSAttrib_p10_11; depends on fDeltaCRL_p9
//
// %11 -- DS CA Cert attribute: L"" if !fDSAttrib_p10_11
//
// %12 -- DS user cert attribute
//
// %13 -- DS KRA cert attribute
//
// %14 -- DS cross cert pair attribute

HRESULT 
myFormatCertsrvStringArray(
    IN BOOL    fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7, 
    IN DWORD   iCert_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6, 
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut)
{
    HRESULT hr = S_OK;
    LPCWSTR apwszInsertionArray[100];  // 100 'cause this is the max number of insertion numbers allowed by FormatMessage
    LPWSTR    pwszCurrent = NULL;
    BSTR      strShortMachineName = NULL;
    DWORD     i;
    WCHAR *pwszSanitizedDSName = NULL;
    WCHAR wszCertSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR wszCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR wszDeltaCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR const *pwszT;


    ZeroMemory(apwszStringsOut, cStrings * sizeof(apwszStringsOut[0]));
    ZeroMemory(apwszInsertionArray, sizeof(apwszInsertionArray));

    // Format the template into a real name
    // Initialize the insertion string array.

    //+================================================
    // Machine DNS name (%1)    

    CSASSERT(L'1' == wszFCSAPARM_SERVERDNSNAME[1]);
    apwszInsertionArray[1 - 1] = pwszServerName_p1_2;

    //+================================================
    // Short Machine Name (%2)

    CSASSERT(L'2' == wszFCSAPARM_SERVERSHORTNAME[1]);
    strShortMachineName = SysAllocString(pwszServerName_p1_2);
    if (strShortMachineName == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }

    pwszCurrent = wcschr(strShortMachineName, L'.');
    if (NULL != pwszCurrent)
    {
        *pwszCurrent = 0;
    }
    apwszInsertionArray[2 - 1] = strShortMachineName;

    //+================================================
    // sanitized name (%3)

    CSASSERT(L'3' == wszFCSAPARM_SANITIZEDCANAME[1]);
    apwszInsertionArray[3 - 1] = pwszSanitizedName_p3_7;  

    //+================================================
    // Cert filename suffix (%4)

    CSASSERT(L'4' == wszFCSAPARM_CERTFILENAMESUFFIX[1]);
    wszCertSuffix[0] = L'\0';
    if (0 != iCert_p4)
    {
        wsprintf(wszCertSuffix, L"(%u)", iCert_p4);
    }
    apwszInsertionArray[4 - 1] = wszCertSuffix;  

    //+================================================
    // Domain DN (%5)

    CSASSERT(L'5' == wszFCSAPARM_DOMAINDN[1]);
    apwszInsertionArray[5 - 1] = pwszDomainDN_p5;

    //+================================================
    // Config DN (%6)

    CSASSERT(L'6' == wszFCSAPARM_CONFIGDN[1]);
    apwszInsertionArray[6 - 1] = pwszConfigDN_p6;

    // Don't pass pwszSanitizedName_p3_7 to SysAllocStringLen with the extended
    // length to avoid faulting past end of pwszSanitizedName_p3_7.

    //+================================================
    // Sanitized Short Name (%7)

    CSASSERT(L'7' == wszFCSAPARM_SANITIZEDCANAMEHASH[1]);
    hr = mySanitizedNameToDSName(pwszSanitizedName_p3_7, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    apwszInsertionArray[7 - 1] = pwszSanitizedDSName;

    //+================================================
    // CRL filename suffix (%8)

    CSASSERT(L'8' == wszFCSAPARM_CRLFILENAMESUFFIX[1]);
    wszCRLSuffix[0] = L'\0';
    if (0 != iCRL_p8)
    {
        wsprintf(wszCRLSuffix, L"(%u)", iCRL_p8);
    }
    apwszInsertionArray[8 - 1] = wszCRLSuffix;  

    //+================================================
    // Delta CRL filename suffix (%9)

    CSASSERT(L'9' == wszFCSAPARM_CRLDELTAFILENAMESUFFIX[1]);
    wszDeltaCRLSuffix[0] = L'\0';
    if (fDeltaCRL_p9)
    {
        wcscpy(wszDeltaCRLSuffix, L"+");
    }
    apwszInsertionArray[9 - 1] = wszDeltaCRLSuffix;  

    //+================================================
    // CRL attribute (%10)

    CSASSERT(L'1' == wszFCSAPARM_DSCRLATTRIBUTE[1]);
    CSASSERT(L'0' == wszFCSAPARM_DSCRLATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = fDeltaCRL_p9?
		    wszDSSEARCHDELTACRLATTRIBUTE :
		    wszDSSEARCHBASECRLATTRIBUTE;
    }
    apwszInsertionArray[10 - 1] = pwszT;  

    //+================================================
    // CA cert attribute (%11)

    CSASSERT(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[1]);
    CSASSERT(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCACERTATTRIBUTE;
    }
    apwszInsertionArray[11 - 1] = pwszT;  

    //+================================================
    // User cert attribute (%12)

    CSASSERT(L'1' == wszFCSAPARM_DSUSERCERTATTRIBUTE[1]);
    CSASSERT(L'2' == wszFCSAPARM_DSUSERCERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHUSERCERTATTRIBUTE;
    }
    apwszInsertionArray[12 - 1] = pwszT;  

    //+================================================
    // KRA cert attribute (%13)

    CSASSERT(L'1' == wszFCSAPARM_DSKRACERTATTRIBUTE[1]);
    CSASSERT(L'3' == wszFCSAPARM_DSKRACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHKRACERTATTRIBUTE;
    }
    apwszInsertionArray[13 - 1] = pwszT;  

    //+================================================
    // Cross cert pair attribute (%14)

    CSASSERT(L'1' == wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE[1]);
    CSASSERT(L'4' == wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCROSSCERTPAIRATTRIBUTE;
    }
    apwszInsertionArray[14 - 1] = pwszT;  

    //+================================================
    // Now format the strings...

    for (i = 0; i < cStrings; i++)
    {
        if (0 == FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			    FORMAT_MESSAGE_FROM_STRING |
			    FORMAT_MESSAGE_ARGUMENT_ARRAY,
			(VOID *) apwszStringsIn[i],
			0,              // dwMessageID
			0,              // dwLanguageID
			(LPWSTR) &apwszStringsOut[i], 
			wcslen(apwszStringsIn[i]),
			(va_list *) apwszInsertionArray))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "FormatMessage");
        }
	if (fURL)
	{
	    WCHAR *pwsz;
	    
	    hr = myInternetCanonicalizeUrl(apwszStringsOut[i], &pwsz);
	    _JumpIfError(hr, error, "myInternetCanonicalizeUrl");

	    LocalFree(apwszStringsOut[i]);
	    apwszStringsOut[i] = pwsz;
	}
    }

error:
    if (S_OK != hr)
    {
	for (i = 0; i < cStrings; i++)
	{
	    if (NULL != apwszStringsOut[i])
	    {
		LocalFree(apwszStringsOut[i]);
		apwszStringsOut[i] = NULL;
	    }
	}
    }
    if (NULL != strShortMachineName)
    {
        SysFreeString(strShortMachineName);
    }
    if (NULL != pwszSanitizedDSName)
    {
        LocalFree(pwszSanitizedDSName);
    }
    return (hr);
}


HRESULT
myAllocIndexedName(
    IN WCHAR const *pwszName,
    IN DWORD Index,
    OUT WCHAR **ppwszIndexedName)
{
    HRESULT hr;
    WCHAR wszIndex[1 + 10 + 1 + 1];	// L"(%u)"
    WCHAR *pwszIndexedName;

    *ppwszIndexedName = NULL;
    wszIndex[0] = L'\0';
    if (0 != Index)
    {
	wsprintf(wszIndex, L"(%u)", Index);
    }
    pwszIndexedName = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (wcslen(pwszName) + wcslen(wszIndex) + 1) * sizeof(WCHAR));
    if (NULL == pwszIndexedName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszIndexedName, pwszName);
    wcscat(pwszIndexedName, wszIndex);
    *ppwszIndexedName = pwszIndexedName;
    hr = S_OK;

error:
    return(hr);
}


int 
myWtoI(
    IN WCHAR const *string,
    OUT BOOL *pfValid)
{
    HRESULT hr;
    WCHAR wszBuf[16];
    WCHAR *pwszT = wszBuf;
    int cTmp = ARRAYSIZE(wszBuf);
    int i = 0;
    WCHAR const *pwsz;
    BOOL fSawDigit = FALSE;
 
    CSASSERT(NULL != pfValid);
    *pfValid = FALSE;

    cTmp = FoldString(MAP_FOLDDIGITS, string, -1, pwszT, cTmp);
    if (cTmp == 0)
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            hr = S_OK;
            cTmp = FoldString(MAP_FOLDDIGITS, string, -1, NULL, 0);

            pwszT = (WCHAR *) LocalAlloc(LMEM_FIXED, cTmp * sizeof(WCHAR));
	    if (NULL == pwszT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

            cTmp = FoldString(MAP_FOLDDIGITS, string, -1, pwszT, cTmp);
            if (cTmp == 0)
	    {
                hr = myHLastError();
	    }
        }
        _JumpIfError(hr, error, "FoldString");
    }    
    pwsz = pwszT;
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    if (L'0' == *pwsz && (L'x' == pwsz[1] || L'X' == pwsz[1]))
    {
	pwsz += 2;
	while (iswxdigit(*pwsz))
	{
	    i <<= 4;
	    if (iswdigit(*pwsz))
	    {
		i |= *pwsz - L'0';
	    }
	    else if (L'A' <= *pwsz && L'F' >= *pwsz)
	    {
		i |= *pwsz - L'A' + 10;
	    }
	    else
	    {
		i |= *pwsz - L'a' + 10;
	    }
	    fSawDigit = TRUE;
	    pwsz++;
	}
    }
    else
    {
	while (iswdigit(*pwsz))
	{
	    fSawDigit = TRUE;
	    pwsz++;
	}
	i = _wtoi(pwszT);
    }
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    if (L'\0' == *pwsz)
    {
	*pfValid = fSawDigit;
    }

error:
    if (NULL != pwszT && pwszT != wszBuf)
    {
       LocalFree(pwszT);
    }
    return(i);
}


HRESULT
myGetEnvString(
    OUT WCHAR **ppwszOut,
    IN  WCHAR const *pwszVariable)
{
    HRESULT hr;
    WCHAR awcBuf[MAX_PATH];
    DWORD len;

    len = GetEnvironmentVariable(pwszVariable, awcBuf, ARRAYSIZE(awcBuf));
    if (0 == len)
    {
        hr = myHLastError();
        _JumpErrorStr2(
		hr,
		error,
		"GetEnvironmentVariable",
		pwszVariable,
		HRESULT_FROM_WIN32(ERROR_ENVVAR_NOT_FOUND));
    }
    if (MAX_PATH <= len)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        _JumpError(hr, error, "GetEnvironmentVariable");
    }
    *ppwszOut = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(awcBuf) + 1) * sizeof(WCHAR));
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszOut, awcBuf);
    hr = S_OK;

error:
    return(hr);
}


BOOL
IsValidAttributeChar(
    IN WCHAR wc)
{
    BOOL fOk = TRUE;

    switch (wc)
    {
        case L'-':
	    fOk = FALSE;
	    break;

	default:
	    if (iswspace(wc))
	    {
		fOk = FALSE;
	    }
	    break;
    }
    return(fOk);
}


// myParseNextAttribute -- destructively parse a name, value attribute pair.
// Allow CR and/or LF delimiters -- MAC web pages seem to convert LFs into CRs.

HRESULT
myParseNextAttribute(
    IN OUT WCHAR **ppwszBuf,
    IN BOOL fURL,		// Use = and & instead of : and \r\n
    OUT WCHAR const **ppwszName,
    OUT WCHAR const **ppwszValue)
{
    HRESULT hr;
    WCHAR *pwszBuf = *ppwszBuf;
    WCHAR *pwcToken;
    WCHAR *pwc;
    WCHAR *pwcDst;
    WCHAR wcSep = fURL? L'=' : L':';
    WCHAR *wszTerm = fURL? L"&" : L"\r\n";

    while (TRUE)
    {
	// Find the beginning of the next token

	while (iswspace(*pwszBuf))
	{
	    pwszBuf++;
	}
	pwcToken = pwszBuf;
	pwszBuf = wcschr(pwszBuf, wcSep);
	if (NULL == pwszBuf)
	{
	    hr = S_FALSE;
	    goto error;
	}

	// If there's a wszTerm char before the next wcSep char, start over.

	pwc = &pwcToken[wcscspn(pwcToken, wszTerm)];
	if (pwc < pwszBuf)
	{
	    pwszBuf = pwc + 1;
	    continue;
	}
	for (pwc = pwcDst = pwcToken; pwc < pwszBuf; pwc++)
	{
	    if (IsValidAttributeChar(*pwc))
	    {
		*pwcDst++ = *pwc;
	    }
	}
	pwszBuf++;		// skip past the wcSep before it gets stomped
	*pwcDst = L'\0';	// may stomp the wcSep separator
	*ppwszName = pwcToken;

	// Find beginning of Value string

	while (NULL == wcschr(wszTerm, *pwszBuf) && iswspace(*pwszBuf))
	{
	    pwszBuf++;
	}
	pwcToken = pwszBuf;

	// find end of Value string

	pwc = &pwcToken[wcscspn(pwcToken, wszTerm)];
	pwszBuf = pwc;
	if (L'\0' != *pwszBuf)
	{
	    // for case when last Value *is* terminated by a wszTerm char:

	    *pwszBuf++ = L'\0';
	}

	// trim trailing whitespace from Value string

	while (--pwc >= pwcToken && iswspace(*pwc))
	{
	    *pwc = L'\0';
	}
	if (L'\0' == **ppwszName || L'\0' == *pwcToken)
	{
	    continue;
	}
	*ppwszValue = pwcToken;
	break;
    }
    hr = S_OK;

error:
    *ppwszBuf = pwszBuf;
    return(hr);
}


HRESULT
myBuildOSVersionAttribute(
    OUT BYTE **ppbVersion,
    OUT DWORD *pcbVersion)
{
    HRESULT hr;
    DWORD i;
    OSVERSIONINFO osvInfo;
    CERT_NAME_VALUE cnvOSVer;
#define cwcVERSIONMAX	128
    WCHAR wszVersion[12 * 4 + cwcVERSIONMAX];

    *ppbVersion = NULL;
    ZeroMemory(&osvInfo, sizeof(osvInfo));

    // get the OSVersion

    osvInfo.dwOSVersionInfoSize = sizeof(osvInfo);
    if (!GetVersionEx(&osvInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetVersionEx");
    }
        
    for (i = 0; ; i++)
    {
	swprintf(
	    wszVersion,
	    0 == i? L"%d.%d.%d.%d.%.*ws" : L"%d.%d.%d.%d", 
	    osvInfo.dwMajorVersion,
	    osvInfo.dwMinorVersion,
	    osvInfo.dwBuildNumber,
	    osvInfo.dwPlatformId,
	    cwcVERSIONMAX,
	    osvInfo.szCSDVersion);
	CSASSERT(ARRAYSIZE(wszVersion) > wcslen(wszVersion));

	cnvOSVer.dwValueType = CERT_RDN_IA5_STRING;
	cnvOSVer.Value.pbData = (BYTE *) wszVersion;
	cnvOSVer.Value.cbData = 0;

	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    &cnvOSVer,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbVersion,
		    pcbVersion))
	{
	    hr = myHLastError();
	    _PrintError(hr, "myEncodeObject");
	    if (0 == i)
	    {
		continue;
	    }
	    goto error;
	}
	break;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myBuildCertTypeExtension(
    IN WCHAR const *pwszCertType,
    OUT CERT_EXTENSION *pExt)
{
    HRESULT hr;
    CERT_TEMPLATE_EXT Template;
    CERT_NAME_VALUE NameValue;
    LPCSTR pszStructType;
    char *pszObjId = NULL;
    VOID *pv;
    char *pszObjIdExt;

    if (!ConvertWszToSz(&pszObjId, pwszCertType, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    hr = myVerifyObjIdA(pszObjId);
    if (S_OK == hr)
    {
	ZeroMemory(&Template, sizeof(Template));

	Template.pszObjId = pszObjId;
	//Template.dwMajorVersion = 0;
	//Template.fMinorVersion = FALSE;      // TRUE for a minor version
	//Template.dwMinorVersion = 0;

	pszStructType = X509_CERTIFICATE_TEMPLATE;
	pv = &Template;
	pszObjIdExt = szOID_CERTIFICATE_TEMPLATE;
    }
    else
    {
	NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
	NameValue.Value.pbData = (BYTE *) pwszCertType;
	NameValue.Value.cbData = 0;

	pszStructType = X509_UNICODE_ANY_STRING;
	pv = &NameValue;
	pszObjIdExt = szOID_ENROLL_CERTTYPE_EXTENSION;
    }
    if (!myEncodeObject(
		X509_ASN_ENCODING,
		pszStructType,
		pv,
		0,
		CERTLIB_USE_LOCALALLOC,
		&pExt->Value.pbData,
		&pExt->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    pExt->pszObjId = pszObjIdExt;
    pExt->fCritical = FALSE;
    hr = S_OK;

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(hr);
}


BOOL
IsWhistler(VOID)
{
    HRESULT hr;
    OSVERSIONINFO ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fWhistler = FALSE;

    if (!s_fDone)
    {
	s_fDone = TRUE;

	// get and confirm platform info

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx(&ovi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetVersionEx");
	}
	if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
	{
	    hr = ERROR_CANCELLED;
	    _JumpError(hr, error, "Not a supported OS");
	}
	if (5 < ovi.dwMajorVersion ||
	    (5 <= ovi.dwMajorVersion && 0 < ovi.dwMinorVersion))
	{
	    s_fWhistler = TRUE;
	}
    }

error:
    return(s_fWhistler);
}


static BOOL
GetFlags(
    OUT DWORD *pdw)
{
    HRESULT hr = S_FALSE;
    
    *pdw = 0;

#if defined(_ALLOW_GET_FLAGS_)
    hr = myGetCertRegDWValue(NULL, NULL, NULL, L"SFlags", pdw);
    if (S_OK == hr)
    {
        DBGPRINT((
	    DBG_SS_CERTLIB,
	    "CertSrv\\Configuration\\SFlags override: %u\n",
	    *pdw));
    }
#endif
    return(S_OK == hr);
}
    

BOOL
FIsAdvancedServer(VOID)
{
    HRESULT hr;
    OSVERSIONINFOEX ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fIsAdvSvr = FALSE;

    if (!s_fDone)
    {
	s_fDone = TRUE;

	// get and confirm platform info

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx((OSVERSIONINFO *) &ovi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetVersionEx");
	}
	if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
	{
	    hr = ERROR_CANCELLED;
	    _JumpError(hr, error, "Not a supported OS");
	}
 
        // if server or DC, if DTC or ADS bits are set, return TRUE

        s_fIsAdvSvr =
	    (ovi.wProductType == VER_NT_SERVER ||
	     ovi.wProductType == VER_NT_DOMAIN_CONTROLLER) && 
	    (ovi.wSuiteMask & VER_SUITE_DATACENTER ||
	     ovi.wSuiteMask & VER_SUITE_ENTERPRISE);

	{
	    DWORD dw;

	    if (GetFlags(&dw))
	    {
		s_fIsAdvSvr = dw;
	    }
	}
    }

error:
    return(s_fIsAdvSvr);
}


BOOL
FIsServer(VOID)
{
    HRESULT hr;
    OSVERSIONINFOEX ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fIsSvr = FALSE;

    if (!s_fDone)
    {
	s_fDone = TRUE;

	// get and confirm platform info

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx((OSVERSIONINFO *) &ovi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetVersionEx");
	}
	if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
	{
	    hr = ERROR_CANCELLED;
	    _JumpError(hr, error, "Not a supported OS");
	}
 
        // if server or DC, if DTC or ADS bits are set, return TRUE
        s_fIsSvr =
	    (ovi.wProductType == VER_NT_SERVER ||
	     ovi.wProductType == VER_NT_DOMAIN_CONTROLLER) &&
	    0 == ((VER_SUITE_PERSONAL | VER_SUITE_BLADE) & ovi.wSuiteMask);

        if (!s_fIsSvr && VER_NT_WORKSTATION == ovi.wProductType)
	{
	    DWORD dw;

	    if (GetFlags(&dw))
	    {
		s_fIsSvr = TRUE;
	    }
	}
    }

error:
    return(s_fIsSvr);
}


HRESULT
myAddLogSourceToRegistry(
    IN LPWSTR   pwszMsgDLL,
    IN LPWSTR   pwszApp)
{
    HRESULT     hr=S_OK;
    DWORD       dwData=0;
    WCHAR       const *pwszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    WCHAR       NameBuf[MAX_PATH];

    HKEY        hkey = NULL;

    CSASSERT((wcslen(pwszRegPath) + wcslen(pwszApp) + 1) < MAX_PATH);

    wcscpy(NameBuf, pwszRegPath);
    wcscat(NameBuf, pwszApp);

    // Create a new key for our application
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, NameBuf, &hkey);
    if (S_OK != hr)
    {
        hr = RegCreateKey(HKEY_LOCAL_MACHINE, NameBuf, &hkey);
        _JumpIfError(hr, error, "RegCreateKey");
    }

    // Add the Event-ID message-file name to the subkey

    hr = RegSetValueEx(
                    hkey,
                    L"EventMessageFile",
                    0,
                    REG_EXPAND_SZ,
                    (const BYTE *) pwszMsgDLL,
                    (wcslen(pwszMsgDLL) + 1) * sizeof(WCHAR));
    _JumpIfError(hr, error, "RegSetValueEx");

    // Set the supported types flags and add it to the subkey

    dwData = EVENTLOG_ERROR_TYPE |
                EVENTLOG_WARNING_TYPE |
                EVENTLOG_INFORMATION_TYPE;

    hr = RegSetValueEx(
                    hkey,
                    L"TypesSupported",
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwData,
                    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(myHError(hr));
}


HRESULT
myDupStringA(
    IN CHAR const *pszIn,
    IN CHAR **ppszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (strlen(pszIn) + 1) * sizeof(CHAR);
    *ppszOut = (CHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppszOut, pszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
IsCurrentUserBuiltinAdmin(
    OUT bool *pfIsMember)
{
    HANDLE                      hAccessToken = NULL, hDupToken = NULL;
    PSID                        psidAdministrators = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    HRESULT hr = S_OK;
    BOOL fIsMember = FALSE;

    CSASSERT(pfIsMember);

    if (!AllocateAndInitializeSid(
                            &siaNtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdministrators))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AllocateAndInitializeSid");
    }

    {
    HANDLE hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }

    // Get the access token for current thread
    if (!OpenThreadToken(
            hThread, 
            TOKEN_QUERY | TOKEN_DUPLICATE, 
            FALSE,
            &hAccessToken))
    {
        hr = myHLastError();

        if(hr==HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            HANDLE hProcess = GetCurrentProcess();
            if (NULL == hProcess)
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetCurrentProcess");
            }

            if (!OpenProcessToken(hProcess,
                    TOKEN_DUPLICATE,
                    &hAccessToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "OpenProcessToken");
            }
        }
        else
        {
            _JumpError(hr, error, "OpenThreadToken");
        }
    }
    }

    // CheckTokenMembership must operate on impersonation token, so make one
    if (!DuplicateToken(hAccessToken, SecurityIdentification, &hDupToken))
    {
        hr = myHLastError();
        _JumpError(hr, error, "DuplicateToken");
    }

    if (!CheckTokenMembership(
        hDupToken,
        psidAdministrators,
        &fIsMember))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CheckTokenMembership");
    }

    *pfIsMember = fIsMember?true:false;

    hr = S_OK;

error:
    if (hAccessToken)
        CloseHandle(hAccessToken);

    if (hDupToken)
        CloseHandle(hDupToken);

    // Free the SID we allocated
    if (psidAdministrators)
        FreeSid(psidAdministrators);

    return(hr);
}

HRESULT
SetRegistryLocalPathString(
    IN HKEY hkey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszUNCPath)
{
    HRESULT hr;
    WCHAR *pwszLocalPath = NULL;

    hr = myConvertUNCPathToLocal(pwszUNCPath, &pwszLocalPath);
    _JumpIfError(hr, error, "myConvertUNCPathToLocal");

    hr = RegSetValueEx(
                    hkey,
                    pwszRegValueName,
                    0,
                    REG_SZ,
                    (BYTE *) pwszLocalPath,
                    (wcslen(pwszLocalPath) + 1) * sizeof(WCHAR));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != pwszLocalPath)
    {
        LocalFree(pwszLocalPath);
    }
    return(hr);
}


HRESULT
LocalMachineIsDomainMember(
    OUT bool *pfIsDomainMember)
{
    HRESULT hr = S_OK;
    NTSTATUS status;
    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO pPDI = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;

    CSASSERT(pfIsDomainMember);

    *pfIsDomainMember = FALSE;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    status = LsaOpenPolicy( 
        NULL,
        &ObjectAttributes,
        GENERIC_READ | POLICY_VIEW_LOCAL_INFORMATION,
        &PolicyHandle);

    if(ERROR_SUCCESS != status)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
        _JumpError(hr, error, "LsaOpenPolicy");
    }

    status = LsaQueryInformationPolicy( PolicyHandle,
        PolicyPrimaryDomainInformation,
        (PVOID*)&pPDI);
    if(status)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
        _JumpError(hr, error, "LsaQueryInformationPolicy");
    }

    if( pPDI->Sid )
    {
        // domain member if has domain SID
        *pfIsDomainMember = TRUE;
                
    }

error:
    if(pPDI)
    {
        LsaFreeMemory((LPVOID)pPDI);
    }

    if(PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }

    return hr;
}


HRESULT
ComputeMAC(
    LPCWSTR pcwsFileName,
    LPWSTR *ppwszMAC)
{
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileMapping = NULL;
    BYTE *pbFile = NULL;

    DWORD cbImage, cbImageHigh=0;
    __int64 icbImage, icbHashed;
    DWORD i;
       
    WCHAR rgwszMAC[64];	// 20 bytes @ 1 char/byte
    DWORD cbString = 64*sizeof(WCHAR);

    DWORD dwFileMappingSize; 
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE rgbHashVal[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHashVal = CBMAX_CRYPT_HASH_LEN;

    // find allocation granularity we can use
    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);
    dwFileMappingSize = systemInfo.dwAllocationGranularity;

    // get the file size
    hFile = CreateFile(
		    pcwsFileName,
		    GENERIC_READ,
		    FILE_SHARE_READ,
		    NULL,
		    OPEN_EXISTING,
		    FILE_ATTRIBUTE_NORMAL,
		    0);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "CreateFile");
    }

    if (0xffffffff == (cbImage = GetFileSize(hFile, &cbImageHigh)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "GetFileSize");
    }
    icbImage = ((__int64)cbImageHigh << 32) | cbImage;

    // create mapping, indicating we will map the entire file sooner or later
    hFileMapping = CreateFileMapping(hFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hFileMapping == NULL)
    {
        hr = myHLastError();
	_JumpError(hr, error, "CreateFileMapping");
    }

    // get a cryptographic provider

    if (!CryptAcquireContext(
		&hProv,
		NULL,	// container
		MS_DEF_PROV,	// provider name
		PROV_RSA_FULL, // provider type
		CRYPT_VERIFYCONTEXT)) // dwflags
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    // get a hash
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptCreateHash");
    }

    // begin looping over data
    for (icbHashed = 0; icbHashed < icbImage; icbHashed += dwFileMappingSize)
    {
	DWORD cbBytesLeft = (DWORD)min((__int64)dwFileMappingSize, icbImage-icbHashed);

	// map the next blob into memory
	pbFile = (BYTE *) MapViewOfFile(
				hFileMapping,
				FILE_MAP_READ,
				(DWORD) (icbHashed>>32),	//hi32
				(DWORD) (icbHashed),		//lo32
				cbBytesLeft);	// max num bytes to map
	if (NULL == pbFile)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "MapViewOfFile");
	}

	// hash file
	if (!CryptHashData(hHash, pbFile, cbBytesLeft, 0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashData");
	}

	// unmap this portion
	if (!UnmapViewOfFile(pbFile))
	{
	    pbFile = NULL;
	    hr = myHLastError();
	    _JumpError(hr, error, "UnmapViewOfFile");
	}
	pbFile = NULL;
    }
    // end looping over data

    // retry the hash

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHashVal, &cbHashVal, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetHashParam");
    }

    hr = MultiByteIntegerToWszBuf(
           TRUE, // byte multiple
           cbHashVal,
           rgbHashVal,
           &cbString,
           rgwszMAC);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    *ppwszMAC = (LPWSTR)LocalAlloc(LMEM_FIXED, cbString);
    _JumpIfAllocFailed(*ppwszMAC, error);

    wcscpy(*ppwszMAC, rgwszMAC);

error:
    if (NULL != pbFile)
    {
	UnmapViewOfFile(pbFile);
    }
    if (NULL != hFileMapping)
    {
	CloseHandle(hFileMapping);
    }
    if (INVALID_HANDLE_VALUE != hFile)
    {
	CloseHandle(hFile);
    }
    if (NULL != hHash)
    {
	if (!CryptDestroyHash(hHash))
	{
	    if (hr == S_OK)
	    {
		hr = myHLastError();
	    }
	}
    }
    if (NULL != hProv)
    {
	if (!CryptReleaseContext(hProv, 0))
	{
	    if (hr == S_OK)
	    {
		hr = myHLastError();
	    }
	}
    }
    return(hr);
}


HRESULT
CertNameToHashString(
    CERT_NAME_BLOB const *pCertName,
    WCHAR **ppwszHash)
{
    HRESULT hr = S_OK;
    WCHAR wszHash[64]; // 20 bytes @ 1 char/byte
    DWORD cbString = 64*sizeof(WCHAR);
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE rgbHashVal[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHashVal = CBMAX_CRYPT_HASH_LEN;

    if(0==pCertName->cbData)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "empty cert name");
    }

    CSASSERT(ppwszHash);

    // get a cryptographic provider

    if (!CryptAcquireContext(
            &hProv,
            NULL,	// container
            MS_DEF_PROV,	// provider name
            PROV_RSA_FULL, // provider type
            CRYPT_VERIFYCONTEXT)) // dwflags
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptAcquireContext");
    }

    // get a hash
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptCreateHash");
    }

	// hash file
	if (!CryptHashData(hHash, pCertName->pbData, pCertName->cbData, 0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashData");
	}

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHashVal, &cbHashVal, 0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGetHashParam");
    }

    hr = MultiByteIntegerToWszBuf(
            TRUE, // byte multiple
            cbHashVal,
            rgbHashVal,
            &cbString,
            wszHash);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    // Generated string looks like this: 
    //
    //     04 e7 23 92 98 9f d8 45 80 c9 ef 87 81 29 41 5d bc 4f 63 20
    // 
    // We need to trim the spaces. We'll do it inplace.
    {
        WCHAR *pchSrc, *pchDest;

        for(pchSrc=pchDest=wszHash; L'\0'!=*pchSrc; pchSrc++)
        {
            if(L' ' != *pchSrc)
                *pchDest++ = *pchSrc;
        }

        *pchDest = L'\0';
    }

    *ppwszHash = (LPWSTR)LocalAlloc(LMEM_FIXED, cbString);
    _JumpIfAllocFailed(*ppwszHash, error);

    wcscpy(*ppwszHash, wszHash);

error:

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\casd.cpp ===
//+--------------------------------------------------------------------------
// File:        casd.cpp
// Contents:    CCertificateAuthoritySD implementation
//---------------------------------------------------------------------------
#include <pch.cpp>
#include <sid.h>
#include <certsd.h>
#include <certacl.h>
#include <prvlg.h>
#include <sid.h>
//
// MessageId: CERTSRV_E_NO_CAADMIN_DEFINED
//
// MessageText:
//
//  At least one security principal must have the permission to manage this CA.  
//
#define CERTSRV_E_NO_CAADMIN_DEFINED _HRESULT_TYPEDEF_(0x8009400DL)

LPCWSTR const *CCertificateAuthoritySD::m_pcwszResources; // no free

using namespace CertSrv;

HRESULT CCertificateAuthoritySD::Set(
    const PSECURITY_DESCRIPTOR pSD,
    bool fSetDSSecurity)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSDCrt; // no free
    PSECURITY_DESCRIPTOR pSDNew = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    CPrivilegeManager PrivilegeMgr;

    CSASSERT(NULL != pSD);

    hr = LockGet(&pSDCrt);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myMergeSD(pSDCrt, pSD, DACL_SECURITY_INFORMATION, &pSDNew);
    _JumpIfError(hr, error, "myMergeSD");

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");
    
    hr = CProtectedSecurityDescriptor::Set(pSDNew);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

    hr = MapAndSetDaclOnObjects(fSetDSSecurity);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAndSetDaclOnObjects");

error:
    LOCAL_FREE(pSDNew);
    return hr;
}

HRESULT CCertificateAuthoritySD::MapAndSetDaclOnObjects(bool fSetDSSecurity)
{
    HRESULT hr = S_OK;
    PACL pCADacl; // no free
    PACL pDSAcl = NULL;
    PACL pServiceAcl = NULL;
    PSECURITY_DESCRIPTOR pCASD; // no free
    BOOL fDaclPresent;
    ACL_SIZE_INFORMATION CAAclInfo, DefaultDSAclInfo, DefaultServiceAclInfo;
    DWORD dwIndex, dwIndex2, dwIndex3;
    PVOID pAce;
    DWORD dwDSAclSize=0, dwServiceAclSize=0;
    DWORD dwTempSize;

    hr = LockGet(&pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myGetSecurityDescriptorDacl(
            pCASD,
            &pCADacl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    if(!GetAclInformation(pCADacl,
                          &CAAclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    // calculate the DACL size
    for(dwIndex = 0; dwIndex < CAAclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(pCADacl, dwIndex, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(fSetDSSecurity)
        {
            hr = MapAclGetSize(pAce, ObjType_DS, dwTempSize);
            _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclGetSize");
        }

        dwDSAclSize += dwTempSize;

        hr = MapAclGetSize(pAce, ObjType_Service, dwTempSize);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclGetSize");

        dwServiceAclSize += dwTempSize;
    }

    if(fSetDSSecurity)
    {
        hr = SetDefaultAcl(ObjType_DS);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::SetDefaultAcl");

        if(!GetAclInformation(m_pDefaultDSAcl,
                              &DefaultDSAclInfo,
                              sizeof(ACL_SIZE_INFORMATION),
                              AclSizeInformation))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAclInformation");
        }

        CSASSERT(0==DefaultDSAclInfo.AclBytesFree);

        dwDSAclSize += DefaultDSAclInfo.AclBytesInUse;

        pDSAcl = (PACL)LocalAlloc(LMEM_FIXED, dwDSAclSize);
        if(!pDSAcl)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if(!InitializeAcl(pDSAcl, dwDSAclSize, ACL_REVISION_DS ))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeAcl");
        }
    }

    hr = SetDefaultAcl(ObjType_Service);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::SetDefaultAcl");

    if(!GetAclInformation(m_pDefaultServiceAcl,
                          &DefaultServiceAclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    CSASSERT(0==DefaultServiceAclInfo.AclBytesFree);

    dwServiceAclSize += DefaultServiceAclInfo.AclBytesInUse;
    
    pServiceAcl = (PACL)LocalAlloc(LMEM_FIXED, dwServiceAclSize);
    if(!pServiceAcl)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!InitializeAcl(pServiceAcl, dwServiceAclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // copy deny aces from default service acl
    for(dwIndex = 0; dwIndex < DefaultServiceAclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(m_pDefaultServiceAcl, dwIndex, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_ACE_TYPE)
            continue;

        if(!AddAce(
                pServiceAcl, 
                ACL_REVISION, 
                MAXDWORD,
                pAce,
                ((ACE_HEADER*)pAce)->AceSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "AddAce");
        }
    }

    if(fSetDSSecurity)
    {
        // copy deny aces from default ds acl
        for(dwIndex3 = 0; dwIndex3 < DefaultDSAclInfo.AceCount; dwIndex3++) 
        {
            if(!GetAce(m_pDefaultDSAcl, dwIndex3, &pAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_ACE_TYPE &&
               ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_OBJECT_ACE_TYPE)
                continue;

            if(!AddAce(
                    pDSAcl, 
                    ACL_REVISION_DS, 
                    MAXDWORD,
                    pAce,
                    ((ACE_HEADER*)pAce)->AceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "AddAce");
            }
        }
    }

    // add mapped deny aces to the DACL
    for(dwIndex2 = 0;  dwIndex2 < CAAclInfo.AceCount; dwIndex2++) 
    {
        if(!GetAce(pCADacl, dwIndex2, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_ACE_TYPE)
            continue;

        if(fSetDSSecurity)
        {
            hr = MapAclAddAce(pDSAcl, ObjType_DS, pAce);
            _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
        }

        hr = MapAclAddAce(pServiceAcl, ObjType_Service, pAce);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
    }

    // continue with the allow aces from default service acl
    for(dwIndex=0; dwIndex < DefaultServiceAclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(m_pDefaultServiceAcl, dwIndex, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)
            continue;

        if(!AddAce(
                pServiceAcl, 
                ACL_REVISION, 
                MAXDWORD,
                pAce,
                ((ACE_HEADER*)pAce)->AceSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "AddAce");
        }
    }

    // continue with the allow aces from default ds acl
    if(fSetDSSecurity)
    {
        for(dwIndex3=0; dwIndex3 < DefaultDSAclInfo.AceCount; dwIndex3++) 
        {
            if(!GetAce(m_pDefaultDSAcl, dwIndex3, &pAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_ACE_TYPE &&
                ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_OBJECT_ACE_TYPE)
                continue;

            if(!AddAce(
                    pDSAcl, 
                    ACL_REVISION_DS, 
                    MAXDWORD,
                    pAce,
                    ((ACE_HEADER*)pAce)->AceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "AddAce");
            }
        }
    }

    // continue with the allow mapped aces to the DACL
    for(dwIndex2=0;dwIndex2 < CAAclInfo.AceCount; dwIndex2++) 
    {
        if(!GetAce(pCADacl, dwIndex2, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)
        {
            continue;
        }

        if(fSetDSSecurity)
        {
            hr = MapAclAddAce(pDSAcl, ObjType_DS, pAce);
            _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
        }

        hr = MapAclAddAce(pServiceAcl, ObjType_Service, pAce);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
    }

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");

    hr = MapAclSetOnService(pServiceAcl);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclSetOnService");
    
    // set DACL on objects
    if(fSetDSSecurity)
    {
        hr = MapAclSetOnDS(pDSAcl);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclSetOnDS");
    }

error:
    LOCAL_FREE(pDSAcl);
    LOCAL_FREE(pServiceAcl);
    return hr;
}

HRESULT CCertificateAuthoritySD::MapAclGetSize(
    PVOID pAce, 
    ObjType type, 
    DWORD& dwSize)
{
    ACCESS_ALLOWED_ACE *pAllowAce = (ACCESS_ALLOWED_ACE*)pAce;

    // CA acl should contain only ACCESS_ALLOWED_ACE_TYPE
    // and ACCESS_DENIED_ACE_TYPE
    if(ACCESS_ALLOWED_ACE_TYPE != pAllowAce->Header.AceType &&
       ACCESS_DENIED_ACE_TYPE  != pAllowAce->Header.AceType)
    {
        return E_INVALIDARG;
    }

    dwSize = 0;

    switch(type)
    {
    case ObjType_DS:
        // enroll access maps to enroll object ace on DS
        if(pAllowAce->Mask & CA_ACCESS_ENROLL)
        {
            dwSize = sizeof(ACCESS_ALLOWED_OBJECT_ACE) - sizeof(DWORD)+
                GetLengthSid((PSID)&(pAllowAce->SidStart));
        }
        break;
    case ObjType_Service:
        // ca admin maps to full control on service
        if(pAllowAce->Mask & CA_ACCESS_ADMIN)
        {
            dwSize = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)+
                GetLengthSid((PSID)&(pAllowAce->SidStart));
        }
        break;
    default:
        CSASSERT("Invalid object type" && 0);
    }

    return S_OK;
}

HRESULT CCertificateAuthoritySD::MapAclAddAce(
    PACL pAcl, 
    ObjType type, 
    PVOID pAce)
{
    ACCESS_ALLOWED_ACE *pCrtAce = (ACCESS_ALLOWED_ACE *)pAce;
    bool fAllowAce = (pCrtAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE);

    CSASSERT(pCrtAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE ||
             pCrtAce->Header.AceType == ACCESS_DENIED_ACE_TYPE);

    switch(type)
    {
    case ObjType_DS:
        // enroll access maps to enroll object ace on DS
        if(pCrtAce->Mask & CA_ACCESS_ENROLL)
        {
            if(fAllowAce)
            {
                if(!AddAccessAllowedObjectAce(
                        pAcl,
                        ACL_REVISION_DS,
                        NO_INHERITANCE,
                        ACTRL_DS_CONTROL_ACCESS,
                        const_cast<GUID*>(&GUID_ENROLL),
                        NULL,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
            else
            {
                if(!AddAccessDeniedObjectAce(
                        pAcl,
                        ACL_REVISION_DS,
                        NO_INHERITANCE,
                        ACTRL_DS_CONTROL_ACCESS,
                        const_cast<GUID*>(&GUID_ENROLL),
                        NULL,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
        }
        break;
    case ObjType_Service:
        // ca admin maps to full control on service
        if(pCrtAce->Mask & CA_ACCESS_ADMIN)
        {
            if(fAllowAce)
            {
                if(!AddAccessAllowedAce(
                        pAcl,
                        ACL_REVISION,
                        SERVICE_ALL_ACCESS,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
            else
            {
                if(!AddAccessDeniedAce(
                        pAcl,
                        ACL_REVISION,
                        SERVICE_ALL_ACCESS,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
        }
        break;
    default:
        CSASSERT("Invalid object type" && 0);
    }

    return S_OK;
}

HRESULT CCertificateAuthoritySD::SetDefaultAcl(ObjType type)
{
    HRESULT hr = S_OK;
    
    switch(type)
    {
    case ObjType_DS:
        if(!m_pDefaultDSAcl)
        {
            hr = SetComputerSID();
            _JumpIfError(hr, error, "SetComputerSID");

            CSASSERT(!m_pDefaultDSSD);
            hr = myGetSDFromTemplate(
                    WSZ_DEFAULT_DSENROLLMENT_SECURITY,
                    m_pwszComputerSID,
                    &m_pDefaultDSSD);
            _JumpIfError(hr, error, "myGetSDFromTemplate");
            
            hr = myGetSecurityDescriptorDacl(
                    m_pDefaultDSSD,
                    &m_pDefaultDSAcl);
            _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");
        }
        break;

    case ObjType_Service:
        if(!m_pDefaultServiceAcl)
        {
            CSASSERT(!m_pDefaultServiceSD);
            hr = myGetSDFromTemplate(
                    WSZ_DEFAULT_SERVICE_SECURITY,
                    NULL,
                    &m_pDefaultServiceSD);
            _JumpIfError(hr, error, "myGetSDFromTemplate");
            
            hr = myGetSecurityDescriptorDacl(
                    m_pDefaultServiceSD,
                    &m_pDefaultServiceAcl);
            _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

        }
        break;
    }
    
error:
    return hr;
}

HRESULT CCertificateAuthoritySD::SetComputerSID()
{
    HRESULT hr = S_OK;
    LPWSTR pwszDomainName = NULL;
    DWORD cDomainName = 0;
    LPWSTR pwszComputerName = NULL;
    DWORD cbSid;
    SID_NAME_USE SidUse;
    PBYTE pComputerSID = NULL;

    CSASSERT(!m_pwszComputerSID);

    hr = myGetComputerObjectName(NameSamCompatible, &pwszComputerName);
    _JumpIfError(hr, error, "myGetComputerObjectName");

    LookupAccountName(
                NULL,
                pwszComputerName,
                NULL,
                &cbSid,
                NULL,
                &cDomainName,
                &SidUse);
    if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
    {
        hr = myHLastError();
        _JumpError(hr, error, "LookupAccountName");
    }
    
    pwszDomainName = (LPWSTR)LocalAlloc(
                                LMEM_FIXED, 
                                cDomainName*sizeof(WCHAR));
    if(!pwszDomainName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    pComputerSID = (LPBYTE)LocalAlloc(
                                LMEM_FIXED, 
                                cbSid);
    if(!pComputerSID)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!LookupAccountName(
                NULL,
                pwszComputerName,
                pComputerSID,
                &cbSid,
                pwszDomainName,
                &cDomainName,
                &SidUse))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LookupAccountName");
    }

    if(!myConvertSidToStringSid(
            pComputerSID,
            &m_pwszComputerSID))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myConvertSidToStringSid");
    }

error:
    LOCAL_FREE(pwszDomainName);
    LOCAL_FREE(pComputerSID);
    return hr;
}


typedef LPCWSTR (WINAPI FNCAGETDN)(
    IN HCAINFO hCAInfo);

LPCWSTR
myCAGetDN(
    IN HCAINFO hCAInfo)
{
    HMODULE hModule;
    static FNCAGETDN *s_pfn = NULL;
    LPCWSTR pwszCADN = NULL;

    if (NULL == s_pfn)
    {
	hModule = GetModuleHandle(TEXT("certcli.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	s_pfn = (FNCAGETDN *) GetProcAddress(hModule, "CAGetDN");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    pwszCADN = (*s_pfn)(hCAInfo);

error:
    return(pwszCADN);
}


HRESULT CCertificateAuthoritySD::MapAclSetOnDS(const PACL pAcl)
{
    HRESULT hr = S_OK;
    LPWSTR pwszSanitizedDSName = NULL;
    HCAINFO hCAInfo;
    LPCWSTR pwszCADN;

	hr = mySanitizedNameToDSName(m_pcwszSanitizedName, &pwszSanitizedDSName);
	_JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
		  pwszSanitizedDSName,
		  NULL,
		  CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		  &hCAInfo);
	_JumpIfErrorStr(hr, error, "CAFindByName", pwszSanitizedDSName);

    pwszCADN = myCAGetDN(hCAInfo);
    if (NULL == pwszCADN)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCAGetDN");
    }

    hr = SetNamedSecurityInfo(
            const_cast<LPWSTR>(pwszCADN),
            SE_DS_OBJECT_ALL,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            pAcl,
            NULL);
    if(ERROR_SUCCESS != hr)
    {

        if(ERROR_ACCESS_DENIED == hr)
        {
            // If we can't set the acl on ds enrollment object, notify
            // the caller with a special error code so it can take action.
            // See bug# 193388
            hr = ERROR_CAN_NOT_COMPLETE;
        }

        hr = myHError(hr);
        _JumpError(hr, error, "SetNamedSecurityInfo");
    }

error:
    LOCAL_FREE(pwszSanitizedDSName);
    if(hCAInfo)
        CACloseCA(hCAInfo);
    return hr;
}

HRESULT CCertificateAuthoritySD::MapAclSetOnService(const PACL pAcl)
{
    HRESULT hr = S_OK;

    hr = SetNamedSecurityInfo(
            wszSERVICE_NAME,
            SE_SERVICE,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            pAcl,
            NULL);
    if(ERROR_SUCCESS != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "SetNamedSecurityInfo");
    }

error:

    return hr;
}

HRESULT CCertificateAuthoritySD::ResetSACL()
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSaclSD = NULL;
    PSECURITY_DESCRIPTOR pSDCrt; // no free
    PSECURITY_DESCRIPTOR pSDNew = NULL;

    hr = myGetSDFromTemplate(
            CERTSRV_SACL_ON,
            NULL,
            &pSaclSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = LockGet(&pSDCrt);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myMergeSD(pSDCrt, pSaclSD, SACL_SECURITY_INFORMATION, &pSDNew);
    _JumpIfError(hr, error, "myMergeSD");

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");
    
    hr = CProtectedSecurityDescriptor::Set(pSDNew);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    LOCAL_FREE(pSaclSD);
    LOCAL_FREE(pSDNew);
    return hr;
}

// Upgrade from CA security descriptor from win2k. 
//
// Allow aces are mapped as follows:
//      manage   -> CA admin + officer
//      enroll   -> enroll
//      read     -> read
//      revoke   -> officer
//      approve  -> officer
//      else     -> read
//
// Deny aces are ignored.

HRESULT CCertificateAuthoritySD::UpgradeWin2k(
    bool fUseEnterpriseAcl)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSDOld; // no free
    PACL pAclOld; // no free
    PSECURITY_DESCRIPTOR pSDNewDaclOnly = NULL;
    PSECURITY_DESCRIPTOR pSDNewSaclOnly = NULL;
    PSECURITY_DESCRIPTOR pSDNew = NULL;
    PACL pAclNew = NULL;
    ACL_SIZE_INFORMATION OldAclSizeInfo;
    DWORD dwSizeAclNew = sizeof(ACL);
    DWORD cAce;
    PVOID pAce;
    ACCESS_MASK dwAccessMask;
    PSID pSid; // no free

    hr = LockGet(&pSDOld);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myGetSecurityDescriptorDacl(
            pSDOld,
            &pAclOld);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    if(!GetAclInformation(pAclOld,
                          &OldAclSizeInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    for(cAce=0;cAce<OldAclSizeInfo.AceCount;cAce++)
    {
        if(!GetAce(pAclOld, cAce, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        dwSizeAclNew += GetUpgradeAceSizeAndType(pAce, NULL, NULL);
    }

    // if no valid ACE found, fall back to a default SD
    if(sizeof(ACL)==dwSizeAclNew)
    {
        hr= myGetSDFromTemplate(
                fUseEnterpriseAcl?
                WSZ_DEFAULT_CA_ENT_SECURITY:
                WSZ_DEFAULT_CA_STD_SECURITY,
                NULL,
                &pSDNew);
        _JumpIfError(hr, error, "myGetSDFromTemplate");
    }
    else
    {
        pAclNew = (PACL)LocalAlloc(LMEM_FIXED, dwSizeAclNew);
        if(!pAclNew)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");

        }

        FillMemory(pAclNew, dwSizeAclNew, L' ');
        if(!InitializeAcl(pAclNew, dwSizeAclNew, ACL_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeAcl");
        }

        for(cAce=0;cAce<OldAclSizeInfo.AceCount;cAce++)
        {
            if(!GetAce(pAclOld, cAce, &pAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(GetUpgradeAceSizeAndType(
                    pAce, 
                    &dwAccessMask,
                    &pSid))
            {
                BYTE acetype = ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType;
                switch(acetype)
                {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    if(!AddAccessAllowedAce(
                            pAclNew,
                            ACL_REVISION,
                            dwAccessMask,
                            pSid))
                    {
                        hr = myHLastError();
                        _JumpError(hr, error, "AddAccessAllowed");
                    }
                    break;
                case ACCESS_DENIED_ACE_TYPE:
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    if(!AddAccessDeniedAce(
                            pAclNew,
                            ACL_REVISION,
                            dwAccessMask,
                            pSid))
                    {
                        hr = myHLastError();
                        _JumpError(hr, error, "AddAccessAllowed");
                    }
                    break;
                }
            }
        }

        // Build a new SD based on this DACL

        pSDNewDaclOnly = (PSECURITY_DESCRIPTOR)LocalAlloc(
                            LMEM_FIXED,
                            SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (!pSDNewDaclOnly)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if (!InitializeSecurityDescriptor(
                pSDNewDaclOnly, 
                SECURITY_DESCRIPTOR_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeSecurityDescriptor");
        }

        if(!SetSecurityDescriptorDacl(pSDNewDaclOnly,
                                      TRUE,
                                      pAclNew,
                                      FALSE))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetSecurityDescriptorDacl");
        }

        hr= myGetSDFromTemplate(
                WSZ_DEFAULT_CA_STD_SECURITY,
                NULL,
                &pSDNewSaclOnly);
        _JumpIfError(hr, error, "myGetSDFromTemplate");

        // merge SACL & DACL in new SD
        hr = myMergeSD(
                pSDNewSaclOnly, 
                pSDNewDaclOnly, 
                DACL_SECURITY_INFORMATION, 
                &pSDNew);
        _JumpIfError(hr, error, "myMergeSD");

        CSASSERT(IsValidSecurityDescriptor(pSDNew));
    }

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");

    hr = CProtectedSecurityDescriptor::Set(pSDNew);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    LOCAL_FREE(pSDNew);
    LOCAL_FREE(pSDNewSaclOnly);
    LOCAL_FREE(pSDNewDaclOnly);
    LOCAL_FREE(pAclNew);
    return hr;
}


DWORD CCertificateAuthoritySD::GetUpgradeAceSizeAndType(
    PVOID pAce, DWORD *pdwType, PSID *ppSid)
{
    DWORD dwSize = 0;
    PSID pSid = NULL;
    DWORD dwType = 0;

    switch(((PACCESS_ALLOWED_ACE)pAce)->Header.AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
        pSid = (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart);
        dwSize = sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+GetLengthSid(pSid);

        switch(((PACCESS_ALLOWED_ACE)pAce)->Mask)
        {
        case ACTRL_CERTSRV_MANAGE:
            dwType = CA_ACCESS_ADMIN | CA_ACCESS_OFFICER;
            break;
        default: // including ACTRL_CERTSRV_READ
            dwType = CA_ACCESS_READ;
        }
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:

        PACCESS_ALLOWED_OBJECT_ACE pObjAce = (PACCESS_ALLOWED_OBJECT_ACE)pAce;

        pSid = (PSID)(((BYTE*)(&pObjAce->ObjectType))+
                ((pObjAce->Flags&ACE_OBJECT_TYPE_PRESENT)? 
                sizeof(pObjAce->ObjectType):0)+
                ((pObjAce->Flags&ACE_INHERITED_OBJECT_TYPE_PRESENT)? 
                sizeof(pObjAce->InheritedObjectType):0));

        dwSize = sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+GetLengthSid(pSid);

        REFGUID rGUID = (((PACCESS_ALLOWED_OBJECT_ACE)pAce)->ObjectType);
        if(IsEqualGUID(rGUID, GUID_ENROLL))
        {
            dwType = CA_ACCESS_ENROLL;
        } else
        if(IsEqualGUID(rGUID, GUID_APPRV_REQ) ||
           IsEqualGUID(rGUID, GUID_REVOKE))
        {
            dwType = CA_ACCESS_OFFICER;
        } else
        {
            dwType = CA_ACCESS_READ;
        }
        break;

    // denied aces are not upgraded so ignore them
    }

    if(ppSid)
        *ppSid = pSid;
    if(pdwType)
        *pdwType = dwType;

    return dwSize;
}

// Returns:
// - E_INVALIDARG: invalid ACEs found,
// - S_FALSE: no admin ACE found (to avoid admins locking themselves out)
HRESULT CCertificateAuthoritySD::Validate(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr;
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwIndex;
    PACCESS_ALLOWED_ACE pAce; // no free
    PACL pDacl; // no free
    bool fAdminAceFound = false;
    DWORD dwKnownRights =   CA_ACCESS_ADMIN     |
                            CA_ACCESS_OFFICER   |
                            CA_ACCESS_READ      |
                            CA_ACCESS_ENROLL;

    if(!IsValidSecurityDescriptor(pSD))
    {
        hr = myHLastError();
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    // get acl
    hr = myGetSecurityDescriptorDacl(
             pSD,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        // only access allowed/denied aces and know rights are allowed
        if((ACCESS_ALLOWED_ACE_TYPE!=pAce->Header.AceType &&
            ACCESS_DENIED_ACE_TYPE !=pAce->Header.AceType) ||
           (~dwKnownRights & pAce->Mask))
        {
            return E_INVALIDARG;
        }

        if((CA_ACCESS_ADMIN & pAce->Mask) &&
           (ACCESS_ALLOWED_ACE_TYPE==pAce->Header.AceType))
        {
            fAdminAceFound = true;
        }
    }

    // no caadmin allow ace found
    hr = fAdminAceFound?S_OK:CERTSRV_E_NO_CAADMIN_DEFINED;

error:
    return hr;
}

HRESULT CCertificateAuthoritySD::ConvertToString(
    IN PSECURITY_DESCRIPTOR pSD,
    OUT LPWSTR& rpwszSD)
{
    HRESULT hr = S_OK;
    LPCWSTR pcwszHeader = L"\n"; // start with a new line
    DWORD dwBufSize = sizeof(WCHAR)*(wcslen(pcwszHeader)+1);
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwIndex;
    PACCESS_ALLOWED_ACE pAce; // no free
    PACL pDacl; // no free
    LPWSTR pwszAce; // no free
    
    rpwszSD = NULL;

    hr = Validate(pSD);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::Validate");

    // get acl
    hr = myGetSecurityDescriptorDacl(
             pSD,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }
    
    
    // calculate text size

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            NULL);
        _JumpIfError(hr, error, "ConvertAceToString");

        dwBufSize += dwAceSize;
    }

    rpwszSD = (LPWSTR)LocalAlloc(LMEM_FIXED, dwBufSize);
    _JumpIfAllocFailed(rpwszSD, error);

    // build the output string
    wcscpy(rpwszSD, pcwszHeader);
    
    pwszAce = rpwszSD + wcslen(pcwszHeader);

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            pwszAce);
        _JumpIfError(hr, error, "ConvertAceToString");

        pwszAce += dwAceSize/sizeof(WCHAR);
    }

error:
    return hr;
}

// Returned string has the following format:
//
// [Allow|Deny]\t[Name|SID]\n
// \tRole1\n
// \tRole2\n
// ...
//
// Example:
//
// Allow    Administrators
//      CA Administrator
//      Certificate Manager
//
// If SID cannot be converted to friendly name it is displayed
// as a string SID
//
HRESULT CCertificateAuthoritySD::ConvertAceToString(
    IN PACCESS_ALLOWED_ACE pAce,
    OUT OPTIONAL PDWORD pdwSize,
    IN OUT OPTIONAL LPWSTR pwszSD)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 1; // trailing '\0'
    CSid sid((PSID)(&pAce->SidStart));
    
    LPCWSTR pcwszAllow      = m_pcwszResources[0];
    LPCWSTR pcwszDeny       = m_pcwszResources[1];

    LPCWSTR pcwszPermissionType = 
        (ACCESS_ALLOWED_ACE_TYPE==pAce->Header.AceType)?
        pcwszAllow:pcwszDeny;
    LPCWSTR pcwszSid; // no free

    DWORD dwRoles[] = 
    {
        CA_ACCESS_ADMIN,
        CA_ACCESS_OFFICER,
        CA_ACCESS_READ,
        CA_ACCESS_ENROLL,
    };

    // dwRoles and resources should match the roles
    const LPCWSTR *pcwszRoles = &m_pcwszResources[2];

    DWORD cRoles;

    // asked for size and/or ace string
    CSASSERT(pdwSize || pwszSD);

    pcwszSid = sid.GetName();
    if(!pcwszSid)
    {
        return E_OUTOFMEMORY;
    }
    
    dwSize = wcslen(pcwszSid);

    dwSize += wcslen(pcwszPermissionType);
    
    dwSize += 2; // '\t' between sid an permission and a '\n' after

    if(pwszSD)
    {
        wcscat(pwszSD, pcwszPermissionType);
        wcscat(pwszSD, L"\t");
        wcscat(pwszSD, pcwszSid);
        wcscat(pwszSD, L"\n");
    }


    for(cRoles=0;cRoles<ARRAYSIZE(dwRoles);cRoles++)
    {
        if(pAce->Mask & dwRoles[cRoles])
        {
            dwSize += wcslen(pcwszRoles[cRoles]) + 2; // "\tRole\n"
            if(pwszSD)
            {
                wcscat(pwszSD, L"\t");
                wcscat(pwszSD, pcwszRoles[cRoles]);
                wcscat(pwszSD, L"\n");
            }
        }
    }

    dwSize *= sizeof(WCHAR);

    if(pdwSize)
    {
        *pdwSize = dwSize;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\certsd.cpp ===
//+--------------------------------------------------------------------------
// File:        certsd.cpp
// Contents:    CA's security descriptor class implementation
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include "certsd.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_CERTLIB_CERTSD_CPP__

using namespace CertSrv;

HRESULT
CProtectedSecurityDescriptor::Init(LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;
    CSASSERT(!m_fInitialized);
    
    __try
    {
	InitializeCriticalSection(&m_csWrite);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    m_hevtNoReaders = CreateEvent(
        NULL,
        TRUE,
        TRUE,
        NULL);
    if(NULL==m_hevtNoReaders)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }

    m_pcwszSanitizedName = pwszSanitizedName;    

error:
    return hr;
}

HRESULT
CProtectedSecurityDescriptor::SetSD(const PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL SDCtrl;
    DWORD dwRev;

    CSASSERT(NULL==m_pSD);

    if(pSD)
    {
        if(!IsValidSecurityDescriptor(pSD))
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "IsValidSecurityDescriptor");
        }

        if(!GetSecurityDescriptorControl(pSD, &SDCtrl, &dwRev))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetSecurityDescriptorControl");
        }

        // always keep the SD in self relative form
        if(!(SDCtrl&SE_SELF_RELATIVE))
        {
            if(!MakeSelfRelativeSD(pSD, NULL, &dwSize))
            {
                m_pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
                if(NULL == m_pSD)
                {
                    hr = E_OUTOFMEMORY;
                    _JumpError(hr, error, "LocalAlloc");
                }

                if(!MakeSelfRelativeSD(pSD, m_pSD, &dwSize))
                {
                    hr = myHLastError();
                    _JumpError(hr, error, "LocalAlloc");
                }
            }
        }
        else
        {
            dwSize = GetSecurityDescriptorLength(pSD);

            m_pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
            if(NULL == m_pSD)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
            CopyMemory(m_pSD, pSD, dwSize);
        }
    }

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Initialize(LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;

    CSASSERT(!m_fInitialized);

    hr = Init(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");

    m_fInitialized = true;

    hr = Load();
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
        hr = S_OK;
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Load");

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Initialize(
    PSECURITY_DESCRIPTOR pSD, 
    LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;
    DWORD dwSDLen;

    CSASSERT(!m_fInitialized);
    
    hr = Init(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");
    
    hr = SetSD(pSD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::SetSD");

    m_fInitialized = true;

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::InitializeFromTemplate(
    LPCWSTR pcwszTemplate, 
    LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;
    DWORD dwSDLen;

    CSASSERT(!m_fInitialized);
    
    hr = Init(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");

    hr = myGetSDFromTemplate(
            pcwszTemplate,
            NULL,
            &m_pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");
    
    m_fInitialized = true;

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Load()
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD = NULL;

    CSASSERT(m_fInitialized);

    hr = myGetCertRegBinaryValue(m_pcwszSanitizedName,
                                 NULL,
                                 NULL,
                                 GetPersistRegistryVal(),
                                 (BYTE**)&pSD);
    if(S_OK!=hr)
    {
        return hr;
    }

    if(!IsValidSecurityDescriptor(pSD))
    {
       LocalFree(pSD);
       return E_UNEXPECTED;
    }

    if(m_pSD)
    {
        LocalFree(m_pSD);
    }

    m_pSD = pSD;

    return S_OK;
}

HRESULT 
CProtectedSecurityDescriptor::Save()
{
    HRESULT hr = S_OK;
    DWORD cbLength = GetSecurityDescriptorLength(m_pSD);

    CSASSERT(m_fInitialized);

	hr = mySetCertRegValue(
			NULL,
			m_pcwszSanitizedName,
			NULL,
			NULL,
			GetPersistRegistryVal(),
			REG_BINARY,
			(BYTE const *) m_pSD,
			cbLength,
			FALSE);
	_JumpIfError(hr, error, "mySetCertRegValue");
    
error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Delete()
{
    HRESULT hr = S_OK;

    CSASSERT(m_fInitialized);

	hr = myDeleteCertRegValue(
			m_pcwszSanitizedName,
			NULL,
			NULL,
			GetPersistRegistryVal());
	_JumpIfError(hr, error, "myDeleteCertRegValue");
    
error:
    return hr;
}

HRESULT
CProtectedSecurityDescriptor::Set(const PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    CSASSERT(m_fInitialized);
    if(!IsValidSecurityDescriptor(pSD))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    __try
    {
        EnterCriticalSection(&m_csWrite);
        WaitForSingleObject(&m_hevtNoReaders, INFINITE);
        if(m_pSD)
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        hr = SetSD(pSD);
        LeaveCriticalSection(&m_csWrite);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
error:
    return hr;
}

HRESULT
CProtectedSecurityDescriptor::LockGet(PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr = S_OK;
    CSASSERT(m_fInitialized);
    __try
    {
        EnterCriticalSection(&m_csWrite);
        InterlockedIncrement(&m_cReaders);
        if(!ResetEvent(m_hevtNoReaders))
        {
            hr = myHLastError();
        }
        LeaveCriticalSection(&m_csWrite);
        *ppSD = m_pSD;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Unlock()
{
    HRESULT hr = S_OK;
    CSASSERT(m_fInitialized);
    if(!InterlockedDecrement(&m_cReaders))
    {
        if(!SetEvent(m_hevtNoReaders))
        {
            hr = myHLastError();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\certpick.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cryptpick.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "cainfop.h"
#include "csdisp.h"
#include "csldap.h"
#include "tfc.h"
#include "clibres.h"

#define CUCS_SOURCEMASK (CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_DSSTORE)

#define CUCS_TYPEMASK (CUCS_MYSTORE | \
			CUCS_CASTORE | \
			CUCS_KRASTORE | \
			CUCS_ROOTSTORE)

#define CUCS_VALIDMASK (CUCS_SOURCEMASK | \
			CUCS_TYPEMASK | \
			CUCS_ARCHIVED | \
			CUCS_USAGEREQUIRED | \
			CUCS_SILENT | \
			CUCS_PRIVATEKEYREQUIRED)


// My, CA, KRA and Root stores -- in HKLM, HKCU and the DS
#define CDISPLAYSTOREMAX	(4 * 3)

typedef struct _STOREMAP {
    DWORD dwFlags;
    WCHAR const *pwszStoreName;
    WCHAR const *pwszDSTemplate;
} STOREMAP;

STOREMAP s_aStoreMap[] = {
    { CUCS_MYSTORE,   wszMY_CERTSTORE,   NULL },
    { CUCS_CASTORE,   wszCA_CERTSTORE,   wszDSAIAQUERYTEMPLATE },
    { CUCS_KRASTORE,  wszKRA_CERTSTORE,  wszDSKRAQUERYTEMPLATE },
    { CUCS_ROOTSTORE, wszROOT_CERTSTORE, NULL },
    { 0x0,            NULL,              NULL },
};

HRESULT
FormatDSStoreName(
    IN OUT BSTR *pstrDomainDN,
    IN OUT BSTR *pstrConfigDN,
    IN WCHAR const *pwszTemplate,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    LDAP *pld = NULL;

    if (NULL == *pstrConfigDN)		// first call
    {
        hr = myRobustLdapBind(&pld, FALSE);
	_JumpIfError(hr, error, "myRobustLdapBind");

	// Renewal domain and config containers (%5, %6)

	hr = myGetAuthoritativeDomainDn(pld, pstrDomainDN, pstrConfigDN);
	_JumpIfError(hr, error, "myGetAuthoritativeDomainDn");
    }
    hr = myFormatCertsrvStringArray(
		    FALSE,			// fURL
		    L"",			// pwszServerName_p1_2
		    L"",            // pwszSanitizedName_p3_7
		    0,				// iCert_p4
		    *pstrDomainDN,		// pwszDomainDN_p5
		    *pstrConfigDN,		// pwszConfigDN_p6
		    0,				// iCRL_p8
		    FALSE,			// fDeltaCRL_p9
		    FALSE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pwszTemplate,	// apwszStringsIn
		    ppwszOut);			// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}


HRESULT
myOpenCertStores(
    IN DWORD dwFlags,		// CUCS_*
    OUT DWORD *pcStore,
    OUT HCERTSTORE **prghStore)
{
    HRESULT hr;
    HRESULT hr2;
    HCERTSTORE *rghStore = NULL;
    DWORD cStore = 0;
    STOREMAP *psm;
    DWORD OpenFlags;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    WCHAR *pwszDSStore = NULL;

    *pcStore = 0;
    *prghStore = NULL;
    rghStore = (HCERTSTORE *) LocalAlloc(
				    LMEM_FIXED,
				    CDISPLAYSTOREMAX * sizeof(HCERTSTORE));
    if (NULL == rghStore)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc(rghStore)");
    }
    OpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_SET_LOCALIZED_NAME_FLAG;
    if (CUCS_ARCHIVED & dwFlags)
    {
	OpenFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
    }

    hr2 = S_OK;
    if ((CUCS_SOURCEMASK | CUCS_TYPEMASK) & dwFlags)
    {
	if (~CUCS_VALIDMASK & dwFlags)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwFlags");
	}
	if (0 == (CUCS_SOURCEMASK & dwFlags))
	{
	    dwFlags |= CUCS_SOURCEMASK;	// source default: all cert store sources
	}
	if (0 == (CUCS_TYPEMASK & dwFlags))
	{
	    dwFlags |= CUCS_MYSTORE;	// type default: use my store
	}

	for (psm = s_aStoreMap; NULL != psm->pwszStoreName; psm++)
	{
	    if (dwFlags & psm->dwFlags)
	    {
		HCERTSTORE hStore;

		if (CUCS_MACHINESTORE & dwFlags)
		{
		    hStore = CertOpenStore(
				    CERT_STORE_PROV_SYSTEM_W,
				    X509_ASN_ENCODING,
				    NULL,
				    CERT_SYSTEM_STORE_LOCAL_MACHINE | OpenFlags,
				    psm->pwszStoreName);
		    if (NULL == hStore)
		    {
			hr = myHLastError();
			_PrintErrorStr(hr, "CertOpenStore LocalMachine", psm->pwszStoreName);
			if (S_OK == hr2)
			{
			    hr2 = hr;
			}
		    }
		    else
		    {
			DBGPRINT((
			    DBG_SS_CERTLIBI,
			    "CertOpenStore LocalMachine(%ws, HKLM)[%u]\n",
			    psm->pwszStoreName,
			    cStore));
			rghStore[cStore++] = hStore;
		    }
		}
		if (CUCS_USERSTORE & dwFlags)
		{
		    hStore = CertOpenStore(
				    CERT_STORE_PROV_SYSTEM_W,
				    X509_ASN_ENCODING,
				    NULL,
				    CERT_SYSTEM_STORE_CURRENT_USER | OpenFlags,
				    psm->pwszStoreName);
		    if (NULL == hStore)
		    {
			hr = myHLastError();
			_PrintErrorStr(hr, "CertOpenStore User", psm->pwszStoreName);
			if (S_OK == hr2)
			{
			    hr2 = hr;
			}
		    }
		    else
		    {
			DBGPRINT((
			    DBG_SS_CERTLIBI,
			    "CertOpenStore User(%ws, HKCU)[%u]\n",
			    psm->pwszStoreName,
			    cStore));
			rghStore[cStore++] = hStore;
		    }
		}
		if ((CUCS_DSSTORE & dwFlags) && NULL != psm->pwszDSTemplate)
		{
		    CString strStoreFriendlyName;
		    int idResource;

		    switch(psm->dwFlags)
		    {
			case CUCS_CASTORE:
			    idResource = IDS_STORENAME_DS_AIA;
			    break;

			case CUCS_KRASTORE:
			    idResource = IDS_STORENAME_DS_KRA;
			    break;

			default:
			    CSASSERT(("Invalid cert store name"));
		    }
		    strStoreFriendlyName.LoadString(idResource);

		    if (NULL != pwszDSStore)
		    {
			LocalFree(pwszDSStore);
			pwszDSStore = NULL;
		    }

		    hr = FormatDSStoreName(
				    &strDomainDN,
				    &strConfigDN,
				    psm->pwszDSTemplate,
				    &pwszDSStore);
                    if (S_OK != hr)
                    {
                        _PrintError(hr, "FormatDSStoreName");
                    }
                    else
                    {
                        hStore = CertOpenStore(
				    CERT_STORE_PROV_LDAP_W,
				    X509_ASN_ENCODING,
				    NULL,
				    OpenFlags,
				    pwszDSStore);
                        if (NULL == hStore)
                        {
                            hr = myHLastError();
                            _PrintErrorStr(hr, "CertOpenStore LDAP", pwszDSStore);
                            if (S_OK == hr2)
                            {
                                hr2 = hr;
                            }
                        }
                        else
                        {
                            CRYPT_DATA_BLOB cdb;

                            cdb.pbData = (BYTE*)strStoreFriendlyName.GetBuffer();
                            cdb.cbData = sizeof(WCHAR)*
                                (wcslen(strStoreFriendlyName.GetBuffer())+1);
                            if (!CertSetStoreProperty(
					hStore,
					CERT_STORE_LOCALIZED_NAME_PROP_ID,
					0,
					(const void *) &cdb))
                            {
                                hr = myHLastError();
                                _PrintErrorStr(hr, "CertSetStoreProp LDAP", pwszDSStore);
                                hr = S_OK;
                            }

                            DBGPRINT((
                                DBG_SS_CERTLIBI,
                                "CertOpenStore LDAP(%ws)[%u]\n",
                                pwszDSStore,
                                cStore));
                            rghStore[cStore++] = hStore;
                        }

		    }
		}
	    }
	}
    }
    hr = hr2;

    if (0 == cStore)
    {
        if (hr == S_OK)
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no Cert Store");
    }
    CSASSERT(CDISPLAYSTOREMAX >= cStore);
    *pcStore = cStore;
    *prghStore = rghStore;
    rghStore = NULL;

    // successfully opened some stores
    hr = S_OK;

error:
    if (NULL != strDomainDN)
    {
	SysFreeString(strDomainDN);
    }
    if (NULL != strConfigDN)
    {
	SysFreeString(strConfigDN);
    }
    if (NULL != pwszDSStore)
    {
        LocalFree(pwszDSStore);
    }
    if (NULL != rghStore)
    {
	myCloseCertStores(cStore, rghStore);
    }
    return(hr);
}


VOID
myCloseCertStores(
    IN DWORD cStore,
    IN HCERTSTORE *rghStore)
{
    DWORD i;

    if (NULL != rghStore)
    {
	for (i = cStore; i < cStore; i++)
	{
	    if (NULL != rghStore[i])
	    {
		CertCloseStore(rghStore[i], CERT_CLOSE_STORE_CHECK_FLAG);
	    }
        }
	LocalFree(rghStore);
    }
}


// Search for and load the cryptographic provider and private key. 

HRESULT
myLoadPrivateKey(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD dwFlags,		// CUCS_*
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv)
{
    HRESULT hr;
    HCERTSTORE *rghStore = NULL;
    DWORD cStore;

    hr = myOpenCertStores(dwFlags, &cStore, &rghStore);
    _JumpIfError(hr, error, "myOpenCertStores");

    hr = myLoadPrivateKeyFromCertStores(
				pPubKeyInfo,
				cStore,
				rghStore,
				phProv,
				pdwKeySpec,
				pfCallerFreeProv);
    _JumpIfError(hr, error, "myLoadPrivateKeyFromCertStores");

error:
    if (NULL != rghStore)
    {
	myCloseCertStores(cStore, rghStore);
    }
    return(hr);
}


HRESULT
myLoadPrivateKeyFromCertStores(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD cStore,
    IN HCERTSTORE *rghStore,
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv)
{
    HRESULT hr;
    DWORD i;
    CERT_CONTEXT const *pcc = NULL;

    // for each cert store
    //   for each cert in store with matching public key (lookup by public key)
    //     call CryptAcquireCertificatePrivateKey
    //       if succeeds, exit w/S_OK

    hr = S_OK;
    for (i = 0; i < cStore; i++)
    {
	HCERTSTORE hStore = rghStore[i];

	while (TRUE)
	{
	    pcc = CertFindCertificateInStore(
				    hStore,
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    0,
				    CERT_FIND_PUBLIC_KEY,
				    pPubKeyInfo,
				    pcc);
	    if (NULL == pcc)
	    {
		break;
	    }
	    if (!CryptAcquireCertificatePrivateKey(
				    pcc,
				    CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
				    NULL,	// pvReserved
				    phProv,
				    pdwKeySpec,
				    pfCallerFreeProv))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptAcquireCertificatePrivateKey");
		continue;
	    }
	    hr = S_OK;
	    goto error;
	}
    }
    if (S_OK == hr)
    {
	hr = CRYPT_E_NOT_FOUND;
    }
    _JumpError(hr, error, "CertFindCertificateInStore");

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
	pcc = NULL;
    }
    return(hr);
}


HRESULT
myMakeSerialBstr(
    IN WCHAR const *pwszSerialNumber,
    OUT BSTR *pstrSerialNumber)
{
    HRESULT hr = E_OUTOFMEMORY;
    WCHAR *pwszDup = NULL;
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;

    pwszDup = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszSerialNumber) + 2) * sizeof(*pwszDup));
    if (NULL == pwszDup)
    {
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszSrc = pwszSerialNumber;
    *pwszDup = L'0';		// allow possible leading zero
    pwszDst = &pwszDup[1];

    while (L'\0' != *pwszSrc)
    {
	WCHAR wc = *pwszSrc++;

	if (iswspace(wc))
	{
	    continue;
	}
	if (L'A' <= wc && L'F' >= wc)
	{
	    wc += L'a' - L'A';
	}
	if ((L'a' > wc || L'f' < wc) &&
	    (L'0' > wc || L'9' < wc))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr2(hr, error, "myMakeSerialBstr", pwszSerialNumber, hr);
	}
	*pwszDst++ = wc;
    }
    *pwszDst = L'\0';
    pwszSrc = pwszDup;		// point at possible extra leading zero
    if (1 & (pwszDst - pwszSrc))
    {
	pwszSrc++;		// keep the length even
    }
    while (L'0' == pwszSrc[0] && L'0' == pwszSrc[1] && L'\0' != pwszSrc[2])
    {
	pwszSrc += 2;		// skip pairs of leading zeros
    }

    if (!myConvertWszToBstr(pstrSerialNumber, pwszSrc, MAXDWORD))
    {
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
myNameBlobMatch(
    IN CERT_NAME_BLOB const *pSubject,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fFoundCN = FALSE;
    BOOL fMatchCN = FALSE;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    DWORD i;

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pSubject->pbData,
		pSubject->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    for (i = 0; i < pNameInfo->cRDN; i++)
    {
	CERT_RDN const *prdn;
	DWORD j;

	prdn = &pNameInfo->rgRDN[i];

	for (j = 0; j < prdn->cRDNAttr; j++)
	{
	    CERT_RDN_ATTR const *prdna;

	    prdna = &prdn->rgRDNAttr[j];

	    if (0 == strcmp(szOID_COMMON_NAME, prdna->pszObjId) &&
		NULL != prdna->Value.pbData)
	    {
		fFoundCN = TRUE;
		
		if (0 == lstrcmpi(
			    pwszCertName,
			    (WCHAR const *) prdna->Value.pbData))
		{
		    fMatchCN = TRUE;
		    break;
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    *pfMatch = fMatchCN || (fAllowMissingCN && !fFoundCN);
    return(hr);
}


HRESULT
mySerialNumberMatch(
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BSTR strSerialNumber = NULL;
    BOOL fMatch = FALSE;

    hr = MultiByteIntegerToBstr(
			FALSE,
			pSerialNumber->cbData,
			pSerialNumber->pbData,
			&strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    if (0 == lstrcmpi(pwszSerialNumber, strSerialNumber))
    {
	fMatch = TRUE;
    }
    CSASSERT(S_OK == hr);

error:
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCertHashMatch(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    //wprintf(L"IN: ");
    //DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 1, pb, cb);

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pCert,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    //wprintf(L"CH: ");
    //DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 1, abHash, cbHash);
    if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
    {
	fMatch = TRUE;
	hr = S_OK;
	goto error;
    }

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pCert,
				CERT_KEY_IDENTIFIER_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_PrintError(hr, "CertGetCertificateContextProperty(KeyId)");
    }
    else
    {
	//wprintf(L"KH: ");
	//DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 1, abHash, cbHash);
	if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
	{
	    fMatch = TRUE;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCertMatch(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    
    if (NULL != pbHash)
    {
	hr = myCertHashMatch(pCert, cbHash, pbHash, &fMatch);
	_JumpIfError(hr, error, "myCertHashMatch");
    }
    if (!fMatch && NULL != pwszSerialNumber)
    {
	hr = mySerialNumberMatch(
			&pCert->pCertInfo->SerialNumber,
			pwszSerialNumber,
			&fMatch);
	_JumpIfError(hr, error, "mySerialNumberMatch");
    }
    if (!fMatch)
    {
	hr = myNameBlobMatch(
			&pCert->pCertInfo->Subject,
			pwszCertName,
			fAllowMissingCN,
			&fMatch);
	_JumpIfError(hr, error, "myNameBlobMatch");
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCertMatchEKUOrApplicationPolicies(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cpszObjId,
    IN CHAR const * const *apszObjId,
    IN BOOL fUsageRequired,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    CERT_ENHKEY_USAGE *pKeyUsage = NULL;
    DWORD cbKeyUsage = 0;
    BOOL fMatch = FALSE;
    DWORD i;
    DWORD j;
    
    while (TRUE)
    {
	// get enhanced key usage OIDs

	if (!CertGetEnhancedKeyUsage(
			pCert,
			CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
			pKeyUsage,
			&cbKeyUsage))
	{
	    // accept match if EKU extension not found

	    hr = myHLastError();
	    if (!fUsageRequired && CRYPT_E_NOT_FOUND == hr)
	    {
		fMatch = TRUE;
	    }
	    _PrintError2(hr, "CertGetEnhancedKeyUsage", CRYPT_E_NOT_FOUND);
	    hr = S_OK;
	    goto error;
	}
	if (NULL != pKeyUsage)
	{
	    break;	// EKU extension fetched; break out of while loop
	}
	pKeyUsage = (CERT_ENHKEY_USAGE *) LocalAlloc(LMEM_FIXED, cbKeyUsage);
	if (NULL == pKeyUsage)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "out of memory");
	}
    }

    if (NULL != pKeyUsage)
    {
	if (0 == pKeyUsage->cUsageIdentifier)
	{
	    hr = myHLastError();	// set by CertGetEnhancedKeyUsage
	    if (S_OK != hr)
	    {
		fMatch = TRUE;
	    }
	}
	else
	{
	    for (i = 0; i < pKeyUsage->cUsageIdentifier; i++)
	    {
		if (fMatch)
		{
		    break;
		}
		for (j = 0; j < cpszObjId; j++)
		{
		    if (0 == strcmp(
				pKeyUsage->rgpszUsageIdentifier[i],
				apszObjId[j]))
		    {
			fMatch = TRUE;	// found matching EKU OID
			break;
		    }
		}
	    }
	}
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    return(hr);
}


HRESULT
myCRLHashMatch(
    IN CRL_CONTEXT const *pCRL,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    cbHash = sizeof(abHash);
    if (!CertGetCRLContextProperty(
				pCRL,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCRLContextProperty");
    }
    if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
    {
	fMatch = TRUE;
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCRLMatch(
    IN CRL_CONTEXT const *pCRL,
    IN WCHAR const *pwszCRLName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    
    if (NULL != pbHash)
    {
	hr = myCRLHashMatch(pCRL, cbHash, pbHash, &fMatch);
	_JumpIfError(hr, error, "myCRLHashMatch");
    }
    if (!fMatch)
    {
	hr = myNameBlobMatch(
			&pCRL->pCrlInfo->Issuer,
			pwszCRLName,
			fAllowMissingCN,
			&fMatch);
	_JumpIfError(hr, error, "myNameBlobMatch");
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCTLHashMatch(
    IN CTL_CONTEXT const *pCTL,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    cbHash = sizeof(abHash);
    if (!CertGetCTLContextProperty(
				pCTL,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCTLContextProperty");
    }
    if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
    {
	fMatch = TRUE;
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCTLMatch(
    IN CTL_CONTEXT const *pCTL,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    
    if (NULL != pbHash)
    {
	hr = myCTLHashMatch(pCTL, cbHash, pbHash, &fMatch);
	_JumpIfError(hr, error, "myCTLHashMatch");
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


typedef struct _CERTFILTERCALLBACKDATA
{
    DWORD		dwFlags;	// CUCS_*
    DWORD		cpszObjId;
    CHAR const * const *apszObjId;
    WCHAR const	       *pwszCommonName;
    BYTE	       *pbHash;
    DWORD		cbHash;
    BSTR		strSerialNumber;
    HRESULT		hr;
    HCERTSTORE		hMemStore;
} CERTFILTERCALLBACKDATA;


BOOL WINAPI
CertificateFilterProc(
    PCCERT_CONTEXT pCertContext,
    BOOL          *pfInitialSelectedCert,
    void          *pvCallbackData)
{
    HRESULT hr;
    BOOL fMatch;
    CERTFILTERCALLBACKDATA *pCallbackData =
                           (CERTFILTERCALLBACKDATA *) pvCallbackData;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    DWORD i;
    WCHAR *pwszSubject = NULL;

    CSASSERT(NULL != pCertContext);

    *pfInitialSelectedCert = FALSE;
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&pCertContext->pCertInfo->Subject,
		CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_QUOTING_FLAG,
		&pwszSubject);
    _PrintIfError(hr, "myCertNameToStr");
    if (NULL != pCallbackData->apszObjId)
    {
	hr = myCertMatchEKUOrApplicationPolicies(
				pCertContext,
				pCallbackData->cpszObjId,
				pCallbackData->apszObjId,
				CUCS_USAGEREQUIRED & pCallbackData->dwFlags,
				&fMatch);
	_JumpIfError(hr, error, "myCertMatchEKUOrApplicationPolicies");

	if (!fMatch)
	{
	    _PrintErrorStr(CRYPT_E_NOT_FOUND, "no matching EKU", pwszSubject);
	    hr = S_OK;
	    goto error;
	}
    }

    // The CommonName filter serves three purposes: 1: a common name, 2: the
    // sha-1 hash of the cert, 3: the sha-1 hash of the public key (or the
    // Subject Key Id extension), 4: the serial number of the cert.  If any one
    // of these match, the cert is accepted.

    if (NULL != pCallbackData->pwszCommonName)
    {
	hr = myCertMatch(
		    pCertContext,
		    pCallbackData->pwszCommonName,
		    FALSE,		// fAllowMissingCN
		    pCallbackData->pbHash,
		    pCallbackData->cbHash,
		    pCallbackData->strSerialNumber,
		    &fMatch);
	_JumpIfError(hr, error, "myCertMatch");

	if (!fMatch)
	{
	    _PrintErrorStr2(
		    CRYPT_E_NOT_FOUND,
		    "no matching CN/Hash/Serial",
		    pwszSubject,
		    CRYPT_E_NOT_FOUND);
	    hr = S_OK;
	    goto error;
	}
    }

    if (CUCS_PRIVATEKEYREQUIRED & pCallbackData->dwFlags)
    {
	DWORD cb;
	
	if (!CertGetCertificateContextProperty(
					pCertContext,
					CERT_KEY_PROV_INFO_PROP_ID,
					NULL,
					&cb))
	{
	    _PrintErrorStr(CRYPT_E_NOT_FOUND, "no KeyProvInfo", pwszSubject);
	    fMatch = FALSE;
	    hr = S_OK;
	    goto error;
	}
    }

    fMatch = TRUE;
    
    // Attempt to add to the temporary store; if it fails then it already
    // exists so we don't want it displayed.

    if (!CertAddCertificateLinkToStore(
			    pCallbackData->hMemStore,
			    pCertContext,
			    CERT_STORE_ADD_NEW,
			    NULL))
    {
	fMatch = FALSE;
	hr = myHLastError();
	_PrintErrorStr(hr, "CertAddCertificateLinkToStore Dup", pwszSubject);
	hr = S_OK;
	goto error;
    }
    hr = S_OK;

error:
    if (S_OK == pCallbackData->hr || (fMatch && S_FALSE == pCallbackData->hr))
    {
        pCallbackData->hr = hr;		// keep the first HRESULT
    }
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pNameInfo)
    {
        LocalFree(pNameInfo);
    }
    return(fMatch);
}


HRESULT
myGetKRACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fUseDS,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    CHAR const *pszObjId = szOID_KP_KEY_RECOVERY_AGENT;

    hr = myGetCertificateFromPicker(
			    hInstance,
			    hwndParent,
			    idTitle,
			    idSubTitle,
			    CUCS_MYSTORE | CUCS_KRASTORE | CUCS_CASTORE |
				CUCS_MACHINESTORE | CUCS_USERSTORE |
				CUCS_USAGEREQUIRED |
				(fUseDS? CUCS_DSSTORE : 0) |
				(fSilent? CUCS_SILENT : 0),
			    pwszCommonName,
			    0,		// cStore
			    NULL,	// rghStore
			    1,		// cpszObjId
			    &pszObjId,
			    ppCert);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

error:
    return(hr);
}


HRESULT
myGetERACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    CHAR const * const apszObjId[2] = {
	szOID_ENROLLMENT_AGENT,
	szOID_KP_QUALIFIED_SUBORDINATION,
    };

    hr = myGetCertificateFromPicker(
			    hInstance,
			    hwndParent,
			    idTitle,
			    idSubTitle,
			    CUCS_MYSTORE |
				CUCS_PRIVATEKEYREQUIRED |
				//CUCS_USAGEREQUIRED |
				(fSilent? CUCS_SILENT : 0),
			    pwszCommonName,
			    0,				// cStore
			    NULL,			// rghStore
			    ARRAYSIZE(apszObjId),	// cpszObjId
			    apszObjId,
			    ppCert);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

error:
    return(hr);
}


HRESULT
mySelectCertificateFromStore(
    IN OUT CRYPTUI_SELECTCERTIFICATE_STRUCT *pCertSelect,
    IN HCERTSTORE hStore,
    IN OUT CERT_CONTEXT const **ppCertRet)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertRet = *ppCertRet;
    CERT_CONTEXT const *pCert = NULL;
    BOOL fInitialSelectedCert = FALSE;

    while (TRUE)
    {
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	if ((*pCertSelect->pFilterCallback)(
				pCert,
				&fInitialSelectedCert,
				pCertSelect->pvCallbackData))
	{
	    if (NULL != pCertRet)
	    {
		hr = CRYPT_E_EXISTS;
		_JumpError(hr, error, "more than one cert matches");
	    }
	    pCertRet = CertDuplicateCertificateContext(pCert);
	    if (NULL == pCertRet)
	    {
		hr = CRYPT_E_NOT_FOUND;
		_JumpError(hr, error, "CertDuplicateCertificateContext");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    *ppCertRet = pCertRet;
    return(hr);
}


CERT_CONTEXT const *
mySelectCertificate(
    IN OUT CRYPTUI_SELECTCERTIFICATE_STRUCT *pCertSelect)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    DWORD i;

    if (NULL == pCertSelect->rghDisplayStores ||
	0 == pCertSelect->cDisplayStores)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "no Cert Stores");
    }
    for (i = 0; i < pCertSelect->cDisplayStores; i++)
    {
	hr = mySelectCertificateFromStore(
				    pCertSelect,
				    pCertSelect->rghDisplayStores[i],
				    &pCert);
	_JumpIfError(hr, error, "mySelectCertificateFromStore");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (NULL != pCert)
	{
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;
	}
	SetLastError(hr);
    }
    return(pCert);
}


HRESULT
myGetCertificateFromPicker(
    OPTIONAL IN HINSTANCE           hInstance,
    OPTIONAL IN HWND                hwndParent,
    OPTIONAL IN int                 idTitle,
    OPTIONAL IN int                 idSubTitle,
    IN DWORD                        dwFlags,	// CUCS_*
    OPTIONAL IN WCHAR const        *pwszCommonName,
    OPTIONAL IN DWORD               cStore,
    OPTIONAL IN HCERTSTORE         *rghStore,
    IN DWORD		            cpszObjId,
    OPTIONAL IN CHAR const * const *apszObjId,
    OUT CERT_CONTEXT const        **ppCert)
{
    HRESULT hr;
    HCERTSTORE *rghStoreOpened = NULL;
    DWORD cStoreOpened;
    CERTFILTERCALLBACKDATA callbackData;
    CRYPTUI_SELECTCERTIFICATE_STRUCT CertSelect;

    ZeroMemory(&callbackData, sizeof(callbackData));
    ZeroMemory(&CertSelect, sizeof(CertSelect));

    // custom titles

    if (NULL != hInstance)
    {
        // try to load title from resource
        hr = myLoadRCString(
		    hInstance,
		    idTitle,
		    const_cast<WCHAR **>(&CertSelect.szTitle));
        if (S_OK != hr)
        {
            CSASSERT(NULL == CertSelect.szTitle);
            _PrintError(hr, "myLoadRCString(Title)");
        }
        hr = myLoadRCString(
		    hInstance,
		    idSubTitle,
		    const_cast<WCHAR **>(&CertSelect.szDisplayString));
        if (S_OK != hr)
        {
            CSASSERT(NULL == CertSelect.szDisplayString);
            _PrintError(hr, "myLoadRCString(Title)");
        }
    }

    if (NULL == rghStore)
    {
	cStore = 0;
    }
    cStoreOpened = 0;
    if ((CUCS_SOURCEMASK | CUCS_TYPEMASK) & dwFlags)
    {
        CWaitCursor cwait;

	hr = myOpenCertStores(dwFlags, &cStoreOpened, &rghStoreOpened);
	_PrintIfError(hr, "myOpenCertStores");
    }
    CertSelect.cDisplayStores = cStore + cStoreOpened;
    if (0 == CertSelect.cDisplayStores)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no Cert Store");
    }
    CertSelect.rghDisplayStores = (HCERTSTORE *) LocalAlloc(
				    LMEM_FIXED,
				    CertSelect.cDisplayStores * sizeof(HCERTSTORE));
    if (NULL == CertSelect.rghDisplayStores)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc(CertSelect.rghDisplayStores)");
    }

    if (0 != cStore)
    {
	CopyMemory(
		&CertSelect.rghDisplayStores[0],
		rghStore,
		cStore * sizeof(rghStore[0]));
    }
    if (0 != cStoreOpened)
    {
	CopyMemory(
		&CertSelect.rghDisplayStores[cStore],
		rghStoreOpened,
		cStoreOpened * sizeof(rghStore[0]));
    }

    // temporary store where the callback will store links to found certs
    // so it can check for duplicates

    callbackData.hMemStore = CertOpenStore(
			CERT_STORE_PROV_MEMORY,
			X509_ASN_ENCODING,
			NULL,
			CERT_STORE_CREATE_NEW_FLAG,
			NULL);
    if (NULL == callbackData.hMemStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "can't create memory store");
    }

    CertSelect.dwSize = sizeof(CertSelect);
    CertSelect.hwndParent = hwndParent;
    //CertSelect.dwFlags = 0;			// single selection
    //CertSelect.dwDontUseColumn = 0;		// display all column
    CertSelect.pFilterCallback = CertificateFilterProc; // assign callback
    //CertSelect.pDisplayCallback = NULL;	// use default cert view dlg
    callbackData.dwFlags = dwFlags;
    callbackData.cpszObjId = cpszObjId;
    callbackData.apszObjId = apszObjId;
    callbackData.pwszCommonName = pwszCommonName;
    if (NULL != pwszCommonName)
    {
	hr = WszToMultiByteInteger(
			    TRUE,
			    pwszCommonName,
			    &callbackData.cbHash,
			    &callbackData.pbHash);
	_PrintIfError2(hr, "WszToMultiByteInteger", hr);

	hr = myMakeSerialBstr(pwszCommonName, &callbackData.strSerialNumber);
	_PrintIfError2(hr, "myMakeSerialBstr", hr);
    }
    callbackData.hr = S_FALSE;
    CertSelect.pvCallbackData = &callbackData;	// pass filter info as data
    //CertSelect.cStores = 0;		// no additional stores for chain verify
    //CertSelect.rghStores = NULL;	// no additional stores for chain verify
    //CertSelect.cPropSheetPages = 0;		// no custom cert view pages
    //CertSelect.rgPropSheetPages = NULL;	// no custom cert view pages
    //CertSelect.hSelectedCertStore = NULL;	// single selection

    if (CUCS_SILENT & dwFlags)
    {
	*ppCert = mySelectCertificate(&CertSelect);
	if (NULL == *ppCert)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "mySelectCertificate");
	}
    }
    else
    {
	*ppCert = CryptUIDlgSelectCertificate(&CertSelect);
    }

    // check for error in selection dialog

    hr = callbackData.hr;
    if (S_FALSE == hr)
    {
	hr = CRYPT_E_NOT_FOUND;
    }
    _JumpIfError(hr, error, "CryptUIDlgSelectCertificate");

error:
    if (NULL != rghStoreOpened)
    {
	myCloseCertStores(cStoreOpened, rghStoreOpened);
    }
    if (NULL != callbackData.hMemStore)
    {
        CertCloseStore(callbackData.hMemStore, 0);
    }
    if (NULL != callbackData.strSerialNumber)
    {
	SysFreeString(callbackData.strSerialNumber);
    }
    if (NULL != callbackData.pbHash)
    {
	LocalFree(callbackData.pbHash);
    }
    if (NULL != CertSelect.szTitle)
    {
        LocalFree(const_cast<WCHAR *>(CertSelect.szTitle));
    }
    if (NULL != CertSelect.szDisplayString)
    {
        LocalFree(const_cast<WCHAR *>(CertSelect.szDisplayString));
    }
    if (NULL != CertSelect.rghDisplayStores)
    {
	LocalFree(CertSelect.rghDisplayStores);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\cipolicy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cipolicy.cpp
//
// Contents:    Cert Server Policy dispatch support
//
// History:     20-Jan-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// ICertServerPolicy dispatch support

//TCHAR const g_wszRegKeyCIPolicyClsid[] = wszCLASS_CERTSERVERPOLICY TEXT("\\Clsid");

//+------------------------------------
// SetContext method:

static OLECHAR *policy_apszSetContext[] = {
    TEXT("SetContext"),
    TEXT("Context"),
};

//+------------------------------------
// GetRequestProperty method:

static OLECHAR *policy_apszGetRequestProp[] = {
    TEXT("GetRequestProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// GetRequestAttribute method:

static OLECHAR *policy_apszGetRequestAttr[] = {
    TEXT("GetRequestAttribute"),
    TEXT("strAttributeName"),
};

//+------------------------------------
// GetCertificateProperty method:

static OLECHAR *policy_apszGetCertificateProp[] = {
    TEXT("GetCertificateProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// SetCertificateProperty method:

static OLECHAR *policy_apszSetCertificateProp[] = {
    TEXT("SetCertificateProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
    TEXT("pvarPropertyValue"),
};

//+------------------------------------
// GetCertificateExtension method:

static OLECHAR *policy_apszGetCertificateExt[] = {
    TEXT("GetCertificateExtension"),
    TEXT("strExtensionName"),
    TEXT("Type"),
};

//+------------------------------------
// GetCertificateExtensionFlags method:

static OLECHAR *policy_apszGetCertificateExtFlags[] = {
    TEXT("GetCertificateExtensionFlags"),
};

//+------------------------------------
// SetCertificateExtension method:

static OLECHAR *policy_apszSetCertificateExt[] = {
    TEXT("SetCertificateExtension"),
    TEXT("strExtensionName"),
    TEXT("Type"),
    TEXT("ExtFlags"),
    TEXT("pvarValue"),
};

//+------------------------------------
// EnumerateExtensionsSetup method:

static OLECHAR *policy_apszEnumerateExtensionsSetup[] = {
    TEXT("EnumerateExtensionsSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateExtensions method:

static OLECHAR *policy_apszEnumerateExtensions[] = {
    TEXT("EnumerateExtensions"),
};

//+------------------------------------
// EnumerateExtensionsClose method:

static OLECHAR *policy_apszEnumerateExtensionsClose[] = {
    TEXT("EnumerateExtensionsClose"),
};

//+------------------------------------
// EnumerateAttributesSetup method:

static OLECHAR *policy_apszEnumerateAttributesSetup[] = {
    TEXT("EnumerateAttributesSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateAttributes method:

static OLECHAR *policy_apszEnumerateAttributes[] = {
    TEXT("EnumerateAttributes"),
};

//+------------------------------------
// EnumerateAttributesClose method:

static OLECHAR *policy_apszEnumerateAttributesClose[] = {
    TEXT("EnumerateAttributesClose"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtCIPolicy[] =
{
#define POLICY_SETCONTEXT		0
    DECLARE_DISPATCH_ENTRY(policy_apszSetContext)

#define POLICY_GETREQUESTPROPERTY	1
    DECLARE_DISPATCH_ENTRY(policy_apszGetRequestProp)

#define POLICY_GETREQUESTATTRIBUTE	1
    DECLARE_DISPATCH_ENTRY(policy_apszGetRequestAttr)

#define POLICY_GETCERTIFICATEPROPERTY	2
    DECLARE_DISPATCH_ENTRY(policy_apszGetCertificateProp)

#define POLICY_SETCERTIFICATEPROPERTY	3
    DECLARE_DISPATCH_ENTRY(policy_apszSetCertificateProp)

#define POLICY_GETCERTIFICATEEXTENSION	4
    DECLARE_DISPATCH_ENTRY(policy_apszGetCertificateExt)

#define POLICY_GETCERTIFICATEEXTENSIONFLAGS	5
    DECLARE_DISPATCH_ENTRY(policy_apszGetCertificateExtFlags)

#define POLICY_SETCERTIFICATEEXTENSION	6
    DECLARE_DISPATCH_ENTRY(policy_apszSetCertificateExt)

#define POLICY_ENUMERATEEXTENSIONSSETUP	7
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateExtensionsSetup)

#define POLICY_ENUMERATEEXTENSIONS	8
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateExtensions)

#define POLICY_ENUMERATEEXTENSIONSCLOSE	9
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateExtensionsClose)

#define POLICY_ENUMERATEATTRIBUTESSETUP	10
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateAttributesSetup)

#define POLICY_ENUMERATEATTRIBUTES	11
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateAttributes)

#define POLICY_ENUMERATEATTRIBUTESCLOSE	12
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateAttributesClose)
};
#define CPOLICYDISPATCH	(ARRAYSIZE(g_adtCIPolicy))




HRESULT
CIPolicy_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiCIPolicy)
{
    HRESULT hr;

    hr = DispatchSetup(
		Flags,
                CLSCTX_INPROC_SERVER,
                wszCLASS_CERTSERVERPOLICY, // g_wszRegKeyCIPolicyClsid,
		&CLSID_CCertServerPolicy,
		&IID_ICertServerPolicy,
		CPOLICYDISPATCH,
                g_adtCIPolicy,
                pdiCIPolicy);
    _JumpIfError(hr, error, "DispatchSetup");

    pdiCIPolicy->pDispatchTable = g_adtCIPolicy;

error:
    return(hr);
}


VOID
CIPolicy_Release(
    IN OUT DISPATCHINTERFACE *pdiCIPolicy)
{
    DispatchRelease(pdiCIPolicy);
}


HRESULT
CIPolicy_SetContext(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Context)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Context;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_SETCONTEXT,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetContext)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->SetContext(Context);
	_JumpIfError(hr, error, "ICertServerPolicy::SetContext");
    }

error:
    return(hr);
}


HRESULT
cipolicyGetProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN DWORD IPolicyTable,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    HRESULT hr;
    BSTR bstrPropName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);
    CSASSERT(
	    POLICY_GETCERTIFICATEPROPERTY == IPolicyTable ||
	    POLICY_GETREQUESTPROPERTY == IPolicyTable);

    VariantInit(&varResult);
    *pbstrPropValue = NULL;

    if (!ConvertWszToBstr(&bstrPropName, pwszPropName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (PropertyType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrPropName;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropertyType;

	hr = DispatchInvoke(
			pdiCIPolicy,
			IPolicyTable,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrPropValue);
	_JumpIfError(
		hr,
		error,
		POLICY_GETCERTIFICATEPROPERTY == IPolicyTable?
		    "Invoke(Policy::GetCertificateProperty)" :
		    POLICY_GETREQUESTPROPERTY == IPolicyTable?
			"Invoke(Policy::GetRequestProperty)" :
			"Invoke(Policy::GetRequestAttribute)");
    }
    else
    {
	if (POLICY_GETCERTIFICATEPROPERTY == IPolicyTable)
	{
	    hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetCertificateProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else if (POLICY_GETREQUESTPROPERTY == IPolicyTable)
	{
	    hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetRequestProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else
	{
	    CSASSERT(POLICY_GETREQUESTATTRIBUTE == IPolicyTable);
	    CSASSERT(PROPTYPE_STRING == PropertyType);
	    hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetRequestAttribute(
							    bstrPropName,
							    &varResult.bstrVal);
	    if (S_OK == hr)
	    {
		varResult.vt = VT_BSTR;
	    }
	}
	_JumpIfError(
		hr,
		error,
		POLICY_GETCERTIFICATEPROPERTY == IPolicyTable?
		    "ICertServerPolicy::GetCertificateProperty" :
		    POLICY_GETREQUESTPROPERTY == IPolicyTable?
			"ICertServerPolicy::GetRequestProperty" :
			"ICertServerPolicy::GetRequestAttribute");
	
	hr = DispatchGetReturnValue(&varResult, RetType, pbstrPropValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrPropName)
    {
	SysFreeString(bstrPropName);
    }
    return(hr);
}


HRESULT
CIPolicy_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(cipolicyGetProperty(
			pdiCIPolicy,
			POLICY_GETREQUESTPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIPolicy_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue)
{
    return(cipolicyGetProperty(
			pdiCIPolicy,
			POLICY_GETREQUESTATTRIBUTE,
			pwszPropName,
			PROPTYPE_STRING,
			pbstrPropValue));
}


HRESULT
CIPolicy_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(cipolicyGetProperty(
			pdiCIPolicy,
			POLICY_GETCERTIFICATEPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIPolicy_SetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    IN WCHAR const *pwszPropValue)
{
    HRESULT hr;
    VARIANT avar[3];
    BSTR bstrPropName = NULL;
    BSTR bstrPropValue = NULL;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (!ConvertWszToBstr(&bstrPropName, pwszPropName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (PropertyType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    if (!ConvertWszToBstr(&bstrPropValue, pwszPropValue, -1))
	    {
		hr = E_OUTOFMEMORY;
		goto error;
	    }
	    avar[2].vt = VT_BSTR;
	    avar[2].bstrVal = bstrPropValue;
	    break;

	case PROPTYPE_DATE:
	    avar[2].vt = VT_DATE;
	    avar[2].date = *(DATE *) pwszPropValue;
	    break;

	case PROPTYPE_LONG:
	    avar[2].vt = VT_I4;
	    avar[2].lVal = *(LONG *) pwszPropValue;
	    break;
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrPropName;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropertyType;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_SETCERTIFICATEPROPERTY,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetCertificateProperty)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->SetCertificateProperty(
								bstrPropName,
								PropertyType,
								&avar[2]);
	_JumpIfError(hr, error, "ICertServerPolicy::SetCertificateProperty");
    }

error:
    if (NULL != bstrPropName)
    {
	SysFreeString(bstrPropName);
    }
    if (NULL != bstrPropValue)
    {
	SysFreeString(bstrPropValue);
    }
    return(hr);
}


HRESULT
CIPolicy_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue)
{
    HRESULT hr;
    BSTR bstrExtensionName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    VariantInit(&varResult);
    *pbstrValue = NULL;

    if (!ConvertWszToBstr(&bstrExtensionName, pwszExtensionName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrExtensionName;

	avar[1].vt = VT_I4;
	avar[1].lVal = Type;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_GETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrValue);
	_JumpIfError(hr, error, "Invoke(Policy::GetCertificateExtension)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetCertificateExtension(
								bstrExtensionName,
								Type,
								&varResult);
	_JumpIfError(hr, error, "ICertServerPolicy::GetCertificateExtension");

	hr = DispatchGetReturnValue(&varResult, RetType, pbstrValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrExtensionName)
    {
	SysFreeString(bstrExtensionName);
    }
    return(hr);
}


HRESULT
CIPolicy_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT LONG *pExtFlags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_GETCERTIFICATEEXTENSIONFLAGS,
			0,
			NULL,
			VT_I4,
			pExtFlags);
	_JumpIfError(hr, error, "Invoke(Policy::GetCertificateExtensionFlags)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetCertificateExtensionFlags(
								pExtFlags);
	_JumpIfError(hr, error, "ICertServerPolicy::GetCertificateExtensionFlags");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG ExtFlags,
    IN void const *pvValue)
{
    HRESULT hr;
    VARIANT avar[4];
    BSTR bstrExtensionName = NULL;


    if (!ConvertWszToBstr(&bstrExtensionName, pwszExtensionName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    avar[3].vt = VT_BSTR;
	    avar[3].bstrVal = (BSTR)pvValue;
	    break;

	case PROPTYPE_DATE:
	    avar[3].vt = VT_DATE;
	    avar[3].date = *(DATE *) pvValue;
	    break;

	case PROPTYPE_LONG:
	    avar[3].vt = VT_I4;
	    avar[3].lVal = *(LONG *) pvValue;
	    break;
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrExtensionName;

	avar[1].vt = VT_I4;
	avar[1].lVal = Type;

	avar[2].vt = VT_I4;
	avar[2].lVal = ExtFlags;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_SETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetCertificateExtension)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->SetCertificateExtension(
							    bstrExtensionName,
							    Type,
							    ExtFlags,
							    &avar[2]);
	_JumpIfError(hr, error, "ICertServerPolicy::SetCertificateExtension");
    }

error:
    if (NULL != bstrExtensionName)
    {
	SysFreeString(bstrExtensionName);
    }

    return(hr);
}


HRESULT
CIPolicy_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEEXTENSIONSSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsSetup)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateExtensionsSetup(
								    Flags);
	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateExtensionsSetup");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEEXTENSIONS,
			0,
			NULL,
			VT_BSTR,
			pstrExtensionName);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensions)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateExtensions(
							    pstrExtensionName);
	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateExtensions");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIPolicy)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEEXTENSIONSCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsClose)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateExtensionsClose();

	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateExtensionsClose");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEATTRIBUTESSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesSetup)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateAttributesSetup(
								    Flags);

	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateAttributesSetup");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEATTRIBUTES,
			0,
			NULL,
			0,
			pstrAttributeName);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributes)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateAttributes(
							    pstrAttributeName);

	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateAttributes");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIPolicy)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEATTRIBUTESCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesClose)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateAttributesClose();
	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateAttributesClose");
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\cnfgstg.cpp ===
//+--------------------------------------------------------------------------
// File:        config.cpp
// Contents:    CConfigStorage implements read/write to CA configuration data 
//              currently stored under HKLM\System\CCS\Services\Certsvc\
//              Configuration
//---------------------------------------------------------------------------
#include <pch.cpp>
#include <config.h>
#pragma hdrstop

using namespace CertSrv;

HRESULT CConfigStorage::InitMachine(LPCWSTR pcwszMachine)
{
    m_pwszMachine = new WCHAR[wcslen(pcwszMachine)+3];
    if(!m_pwszMachine)
    {
        return E_OUTOFMEMORY;
    }

    m_pwszMachine[0] = L'\0';

    if(pcwszMachine[0]!=L'\\' &&
       pcwszMachine[1]!=L'\\')
    {
        wcscpy(m_pwszMachine, L"\\\\");
    }
    wcscat(m_pwszMachine, pcwszMachine);
    return S_OK;
}

CConfigStorage::~CConfigStorage()
{
    if(m_hRemoteHKLM)
        RegCloseKey(m_hRemoteHKLM);
    if(m_hRootConfigKey)
        RegCloseKey(m_hRootConfigKey);
    if(m_hCAKey)
        RegCloseKey(m_hCAKey);
    if(m_pwszMachine)
        delete[] m_pwszMachine;
}


// Retrieve a CA configuration value. If no authority name is specified, the
// node path must be NULL and value is queried from the Configuration root.
// If an authority name is passed in, the value is retrieved from the authority
// node; if a node path is passed in, it is used relative to the authority node
// to read the value.

// For example, to read Configuration\DBDirectory, call:
// 
//      GetEntry(NULL, NULL, L"DBDirectory", &var)
//
// To read Configuration\MyCA\CAServerName, call:
//
//      GetEntry(L"MyCA", NULL, L"CAServerName", &var)
//
// To read Configuration\MyCA\CSP\HashAlgorithm, call:
//
//      GetEntry(L"MyCA", L"CSP", L"HashAlgorithm"
//
//
// If pcwszValue is null, getentry returns a VT_ARRAY|VT_BSTR with a list
// of subkey names.

HRESULT CConfigStorage::GetEntry(
    LPCWSTR pcwszAuthorityName,
    LPCWSTR pcwszRelativeNodePath,
    LPCWSTR pcwszValue,
    VARIANT *pVariant)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    BOOL fRet;
    LPBYTE pData = NULL, pTmp;
    DWORD cData = 0;
    HKEY hKeyTmp = NULL;
    DWORD dwType;
    DWORD nIndex;
    DWORD cName;
    DWORD cKeys;

    if(EmptyString(pcwszAuthorityName))
    {
        if(!EmptyString(pcwszRelativeNodePath))
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "CConfigStorage::GetEntry");
        }

        hr = InitRootKey();
        _JumpIfError(hr, error, "CConfigStorage::InitRootKey");

        hKey = m_hRootConfigKey;
    }
    else
    {
        hr = InitCAKey(pcwszAuthorityName);
        _JumpIfError(hr, error, "CConfigStorage::InitCAKey");

        hKey = m_hCAKey;
    }
    
    CSASSERT(hKey);

    if(!EmptyString(pcwszRelativeNodePath))
    {
        hr = RegOpenKeyEx(
               hKey,
               pcwszRelativeNodePath,
               0,
               KEY_ALL_ACCESS,
               &hKeyTmp);
        _JumpIfError(hr, error, "RegOpenKeyEx");
        hKey = hKeyTmp;
    }

    if(EmptyString(pcwszValue))
    {
        dwType = REG_MULTI_SZ;
        cData = 2;

        hr = RegQueryInfoKey(
                hKey,
                NULL,NULL,NULL,
                &cKeys,
                &cName,
                NULL,NULL,NULL,NULL,NULL,NULL);
        _JumpIfError(hr, error, "RegQueryInfoKey");

        cData = (cName+1)*cKeys*sizeof(WCHAR);
        pData = (LPBYTE)LocalAlloc(LMEM_FIXED, cData);
        if(!pData)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        pTmp = pData;

        for(nIndex=0;nIndex<cKeys; nIndex++)
        {
            cName = cData;
            hr = RegEnumKeyEx(
                    hKey,
                    nIndex,
                    (LPWSTR)pTmp,
                    &cName,
                    0, NULL, NULL, NULL);
            _JumpIfError(hr, error, "RegEnumKeyEx");
            pTmp = pTmp+(wcslen((LPWSTR)pTmp)+1)*sizeof(WCHAR);
        }

        *(LPWSTR)pTmp= L'\0';

        hr = myRegValueToVariant(
                dwType,
                cData,
                pData,
                pVariant);
        _JumpIfError(hr, error, "myRegValueToVariant");
    }
    else
    {
        hr = RegQueryValueEx(
                hKey,
                pcwszValue,
                NULL,
                &dwType,
                NULL,
                &cData);
        _JumpIfError2(hr, error, "RegQueryValueEx", ERROR_FILE_NOT_FOUND);

        pData = (LPBYTE)LocalAlloc(LMEM_FIXED, cData);
        if(!pData)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        hr = RegQueryValueEx(
                hKey,
                pcwszValue,
                NULL,
                &dwType,
                pData,
                &cData);
        _JumpIfError(hr, error, "RegQueryValueEx");

        hr = myRegValueToVariant(
                dwType,
                cData,
                pData,
                pVariant);
        _JumpIfError(hr, error, "myRegValueToVariant");
    }

error:
    if(hKeyTmp)
        RegCloseKey(hKeyTmp);
    if(pData)
        LocalFree(pData);
    return myHError(hr);
}


// If variant type is VT_EMPTY, SetEntry deletes the value. Otherwise it
// set the value, see myRegValueToVariant for supported types
HRESULT CConfigStorage::SetEntry(
    LPCWSTR pcwszAuthorityName,
    LPCWSTR pcwszRelativeNodePath,
    LPCWSTR pcwszValue,
    VARIANT *pVariant)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    BOOL fRet;
    LPBYTE pData = NULL;
    DWORD cData;
    HKEY hKeyTmp = NULL;
    DWORD dwType;

    if(EmptyString(pcwszAuthorityName))
    {
        if(!EmptyString(pcwszRelativeNodePath))
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "CConfigStorage::GetEntry");
        }

        hr = InitRootKey();
        _JumpIfError(hr, error, "CConfigStorage::InitRootKey");

        hKey = m_hRootConfigKey;
    }
    else
    {
        hr = InitCAKey(pcwszAuthorityName);
        _JumpIfError(hr, error, "CConfigStorage::InitCAKey");

        hKey = m_hCAKey;
    }
    
    CSASSERT(hKey);

    if(!EmptyString(pcwszRelativeNodePath))
    {
        hr = RegOpenKeyEx(
               hKey,
               pcwszRelativeNodePath,
               0,
               KEY_ALL_ACCESS,
               &hKeyTmp);
        _JumpIfErrorStr(hr, error, "RegOpenKeyEx", pcwszRelativeNodePath);
        hKey = hKeyTmp;
    }

    if(VT_EMPTY == V_VT(pVariant))
    {
        // delete value
        hr = RegDeleteValue(
            hKey,
            pcwszValue);
        _JumpIfErrorStr(hr, error, "RegDeleteValue", pcwszValue);
    }
    else
    {
        // set value
        hr = myVariantToRegValue(
                pVariant,
                &dwType,
                &cData,
                &pData);
        _JumpIfError(hr, error, "myVariantToRegValue");

        hr = RegSetValueEx(
                hKey,
                pcwszValue,
                NULL,
                dwType,
                pData,
                cData);
        _JumpIfErrorStr(hr, error, "RegSetValueEx", pcwszValue);
    }

error:
    if(hKeyTmp)
        RegCloseKey(hKeyTmp);
    if(pData)
        LocalFree(pData);

    return myHError(hr);
}

HRESULT CConfigStorage::InitRootKey()
{
    HRESULT hr = S_OK;

    if(!m_hRootConfigKey)
    {
        if(m_pwszMachine)
        {
            hr = RegConnectRegistry(
                    m_pwszMachine,
                    HKEY_LOCAL_MACHINE,
                    &m_hRemoteHKLM);
            _JumpIfError(hr, error, "RegConnectRegistry");


        }

        hr = RegOpenKeyEx(
                m_hRemoteHKLM?m_hRemoteHKLM:HKEY_LOCAL_MACHINE,
                wszREGKEYCONFIGPATH,
                0,
                KEY_ALL_ACCESS,
                &m_hRootConfigKey);
        _JumpIfError(hr, error, "RegOpenKeyEx");
    }

error:
    return hr;
}

HRESULT CConfigStorage::InitCAKey(LPCWSTR pcwszAuthority)
{
    HRESULT hr = S_OK;

    if(!m_hCAKey)
    {
        hr = InitRootKey();
        _JumpIfError(hr, error, "CConfigStorage::InitRootKey");

        hr = RegOpenKeyEx(
                m_hRootConfigKey,
                pcwszAuthority,
                0,
                KEY_ALL_ACCESS,
                &m_hCAKey);
        _JumpIfError(hr, error, "RegOpenKeyEx");
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\ciexit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ciexit.cpp
//
// Contents:    Cert Server Exit dispatch support
//
// History:     20-Jan-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// ICertServerExit dispatch support

// TCHAR const g_wszRegKeyCIExitClsid[] = wszCLASS_CERTSERVEREXIT TEXT("\\Clsid");

//+------------------------------------
// SetContext method:

static OLECHAR *exit_apszSetContext[] = {
    TEXT("SetContext"),
    TEXT("Context"),
};

//+------------------------------------
// GetRequestProperty method:

static OLECHAR *exit_apszGetRequestProp[] = {
    TEXT("GetRequestProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// GetRequestAttribute method:

static OLECHAR *exit_apszGetRequestAttr[] = {
    TEXT("GetRequestAttribute"),
    TEXT("strAttributeName"),
};

//+------------------------------------
// GetCertificateProperty method:

static OLECHAR *exit_apszGetCertificateProp[] = {
    TEXT("GetCertificateProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// GetCertificateExtension method:

static OLECHAR *exit_apszGetCertificateExt[] = {
    TEXT("GetCertificateExtension"),
    TEXT("strExtensionName"),
    TEXT("Type"),
};

//+------------------------------------
// GetCertificateExtensionFlags method:

static OLECHAR *exit_apszGetCertificateExtFlags[] = {
    TEXT("GetCertificateExtensionFlags"),
};

//+------------------------------------
// EnumerateExtensionsSetup method:

static OLECHAR *exit_apszEnumerateExtensionsSetup[] = {
    TEXT("EnumerateExtensionsSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateExtensions method:

static OLECHAR *exit_apszEnumerateExtensions[] = {
    TEXT("EnumerateExtensions"),
};

//+------------------------------------
// EnumerateExtensionsClose method:

static OLECHAR *exit_apszEnumerateExtensionsClose[] = {
    TEXT("EnumerateExtensionsClose"),
};

//+------------------------------------
// EnumerateAttributesSetup method:

static OLECHAR *exit_apszEnumerateAttributesSetup[] = {
    TEXT("EnumerateAttributesSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateAttributes method:

static OLECHAR *exit_apszEnumerateAttributes[] = {
    TEXT("EnumerateAttributes"),
};

//+------------------------------------
// EnumerateAttributesClose method:

static OLECHAR *exit_apszEnumerateAttributesClose[] = {
    TEXT("EnumerateAttributesClose"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtCIExit[] =
{
#define EXIT_SETCONTEXT			0
    DECLARE_DISPATCH_ENTRY(exit_apszSetContext)

#define EXIT_GETREQUESTPROPERTY		1
    DECLARE_DISPATCH_ENTRY(exit_apszGetRequestProp)

#define EXIT_GETREQUESTATTRIBUTE	2
    DECLARE_DISPATCH_ENTRY(exit_apszGetRequestAttr)

#define EXIT_GETCERTIFICATEPROPERTY	3
    DECLARE_DISPATCH_ENTRY(exit_apszGetCertificateProp)

#define EXIT_GETCERTIFICATEEXTENSION	4
    DECLARE_DISPATCH_ENTRY(exit_apszGetCertificateExt)

#define EXIT_GETCERTIFICATEEXTENSIONFLAGS	5
    DECLARE_DISPATCH_ENTRY(exit_apszGetCertificateExtFlags)

#define EXIT_ENUMERATEEXTENSIONSSETUP	6
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateExtensionsSetup)

#define EXIT_ENUMERATEEXTENSIONS	7
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateExtensions)

#define EXIT_ENUMERATEEXTENSIONSCLOSE	8
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateExtensionsClose)

#define EXIT_ENUMERATEATTRIBUTESSETUP	9
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateAttributesSetup)

#define EXIT_ENUMERATEATTRIBUTES	10
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateAttributes)

#define EXIT_ENUMERATEATTRIBUTESCLOSE	11
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateAttributesClose)
};
#define CEXITDISPATCH	(ARRAYSIZE(g_adtCIExit))


HRESULT
CIExit_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiCIExit)
{
    HRESULT hr;

    hr = DispatchSetup(
		Flags,
                CLSCTX_INPROC_SERVER,
                wszCLASS_CERTSERVEREXIT, //g_wszRegKeyCIExitClsid,
		&CLSID_CCertServerExit,
		&IID_ICertServerExit,
		CEXITDISPATCH,
                g_adtCIExit,
                pdiCIExit);
    _JumpIfError(hr, error, "DispatchSetup");

    pdiCIExit->pDispatchTable = g_adtCIExit;

error:
    return(hr);
}


VOID
CIExit_Release(
    IN OUT DISPATCHINTERFACE *pdiCIExit)
{
    DispatchRelease(pdiCIExit);
}


HRESULT
CIExit_SetContext(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Context)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Context;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_SETCONTEXT,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetContext)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->SetContext(Context);
	_JumpIfError(hr, error, "ICertServerExit::SetContext");
    }

error:
    return(hr);
}


HRESULT
ciexitGetProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN DWORD IExitTable,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    HRESULT hr;
    BSTR bstrPropName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);
    CSASSERT(
	    EXIT_GETCERTIFICATEPROPERTY == IExitTable ||
	    EXIT_GETREQUESTATTRIBUTE == IExitTable ||
	    EXIT_GETREQUESTPROPERTY == IExitTable);

    VariantInit(&varResult);
    *pbstrPropValue = NULL;

    if (!ConvertWszToBstr(&bstrPropName, pwszPropName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (PropertyType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrPropName;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropertyType;

	hr = DispatchInvoke(
			pdiCIExit,
			IExitTable,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrPropValue);
	_JumpIfError(
		hr,
		error,
		EXIT_GETCERTIFICATEPROPERTY == IExitTable?
		    "Invoke(Exit::GetCertificateProperty)" :
		    EXIT_GETREQUESTPROPERTY == IExitTable?
			"Invoke(Exit::GetRequestProperty)" :
			"Invoke(Exit::GetRequestAttribute)");
    }
    else
    {
	if (EXIT_GETCERTIFICATEPROPERTY == IExitTable)
	{
	    hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetCertificateProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else if (EXIT_GETREQUESTPROPERTY == IExitTable)
	{
	    hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetRequestProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else
	{
	    CSASSERT(EXIT_GETREQUESTATTRIBUTE == IExitTable);
	    CSASSERT(PROPTYPE_STRING == PropertyType);
	    hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetRequestAttribute(
							    bstrPropName,
							    &varResult.bstrVal);
	    if (S_OK == hr)
	    {
		varResult.vt = VT_BSTR;
	    }
	}
	_JumpIfError(
		hr,
		error,
		EXIT_GETCERTIFICATEPROPERTY == IExitTable?
		    "ICertServerExit::GetCertificateProperty" :
		    EXIT_GETREQUESTPROPERTY == IExitTable?
			"ICertServerExit::GetRequestProperty" :
			"ICertServerExit::GetRequestAttribute");

	hr = DispatchGetReturnValue(&varResult, RetType, pbstrPropValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrPropName)
    {
	SysFreeString(bstrPropName);
    }
    return(hr);
}


HRESULT
CIExit_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(ciexitGetProperty(
			pdiCIExit,
			EXIT_GETREQUESTPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIExit_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue)
{
    return(ciexitGetProperty(
			pdiCIExit,
			EXIT_GETREQUESTATTRIBUTE,
			pwszPropName,
			PROPTYPE_STRING,
			pbstrPropValue));
}


HRESULT
CIExit_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(ciexitGetProperty(
			pdiCIExit,
			EXIT_GETCERTIFICATEPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIExit_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue)
{
    HRESULT hr;
    BSTR bstrExtensionName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    VariantInit(&varResult);
    *pbstrValue = NULL;

    if (!ConvertWszToBstr(&bstrExtensionName, pwszExtensionName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrExtensionName;

	avar[1].vt = VT_I4;
	avar[1].lVal = Type;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_GETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrValue);
	_JumpIfError(hr, error, "Invoke(Exit::GetCertificateExtension)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetCertificateExtension(
								bstrExtensionName,
								Type,
								&varResult);
	_JumpIfError(hr, error, "ICertServerExit::GetCertificateExtension");

	hr = DispatchGetReturnValue(&varResult, RetType, pbstrValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrExtensionName)
    {
	SysFreeString(bstrExtensionName);
    }
    return(hr);
}


HRESULT
CIExit_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT LONG *pExtFlags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_GETCERTIFICATEEXTENSIONFLAGS,
			0,
			NULL,
			VT_I4,
			pExtFlags);
	_JumpIfError(hr, error, "Invoke(Exit::GetCertificateExtensionFlags)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetCertificateExtensionFlags(
								pExtFlags);
	_JumpIfError(hr, error, "ICertServerExit::GetCertificateExtensionFlags");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEEXTENSIONSSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsSetup)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateExtensionsSetup(
							    Flags);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateExtensionsSetup");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEEXTENSIONS,
			0,
			NULL,
			VT_BSTR,
			pstrExtensionName);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensions)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateExtensions(
							    pstrExtensionName);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateExtensions");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIExit)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEEXTENSIONSCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsClose)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateExtensionsClose();
	_JumpIfError(hr, error, "ICertServerExit::EnumerateExtensionsClose");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEATTRIBUTESSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesSetup)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateAttributesSetup(
							    Flags);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateAttributesSetup");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEATTRIBUTES,
			0,
			NULL,
			VT_BSTR,
			pstrAttributeName);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributes)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateAttributes(
							    pstrAttributeName);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateAttributes");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIExit)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEATTRIBUTESCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesClose)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateAttributesClose();
	_JumpIfError(hr, error, "ICertServerExit::EnumerateAttributesClose");
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\check7f.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        check7f.cpp
//
// Contents:    Cert Server test for ASN-encoded 7f length
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include <assert.h>

#include "csdisp.h"

typedef struct _ASNTABLE {
    WORD State;
    WORD Flags;
    WCHAR const *pwszElement;
} ASNTABLE;


#define BOOLEAN_TAG             0x01
#define INTEGER_TAG             0x02
#define BIT_STRING_TAG          0x03
#define OCTET_STRING_TAG        0x04
#define NULL_TAG                0x05
#define OBJECT_ID_TAG           0x06
#define SET_OF_TAG              0x11
#define PRINTABLE_STRING_TAG    0x13
#define TELETEX_STRING_TAG      0x14
#define CHAR_STRING_TAG         0x16
#define UTCTIME_TAG             0x17
#define SEQUENCE_TAG            0x30
#define RDN_TAG           	0x31
#define PRIMITIVE_TAG           0x80
#define ATTRIBUTE_TAG           0xa0

#define BEG_REPEAT1		0x00000100	// begin repeat section
#define BEG_REPEAT2		0x00000200	// begin nested repeat section
#define END_REPEAT1		0x00000400	// 'or' in back step count
#define END_REPEAT2		0x00000800	// 'or' in back step count
#define OPTIONAL_FIELD		0x00001000	// begin optional field
#define ANY_TAG			0x00002000	// match any tag

const ASNTABLE asnCert[] = {
 { CHECK7F_OTHER, SEQUENCE_TAG,			L"Certificate" },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L".ToBeSigned" },

 { CHECK7F_OTHER, ATTRIBUTE_TAG | OPTIONAL_FIELD, L"..Version" },
 { CHECK7F_OTHER, INTEGER_TAG ,			L"...Version.Integer" },

 { CHECK7F_OTHER, INTEGER_TAG,			L"..SerialNumber" },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L"..SignatureAlgorithm" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L"...SignatureAlgorithm.ObjectId" },
 { CHECK7F_OTHER, ANY_TAG | OPTIONAL_FIELD,	L"...SignatureAlgorithm.Parameters" },

 { CHECK7F_ISSUER, SEQUENCE_TAG,		L"..Issuer Name" },

 { CHECK7F_ISSUER_RDN,
     BEG_REPEAT1 | RDN_TAG | OPTIONAL_FIELD,	L"...Issuer.RDN" },

 { CHECK7F_ISSUER_RDN_ATTRIBUTE,
		BEG_REPEAT2 | SEQUENCE_TAG,	L"....Issuer.RDN.Attribute" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L".....Issuer.RDN.Attribute.ObjectId" },
 { CHECK7F_ISSUER_RDN_STRING, ANY_TAG,		L".....Issuer.RDN.Attribute.Value" },
 { 0, END_REPEAT2 | 3,				L"...." },
 { 0, END_REPEAT1 | 5,				L"..." },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L"..Dates" },
 { CHECK7F_OTHER, UTCTIME_TAG,			L"...Dates.NotBefore" },
 { CHECK7F_OTHER, UTCTIME_TAG,			L"...Dates.NotAfter" },

 { CHECK7F_SUBJECT, SEQUENCE_TAG,		L"..Subject Name" },
 { CHECK7F_SUBJECT_RDN,
     BEG_REPEAT1 | RDN_TAG | OPTIONAL_FIELD,	L"...Subject.RDN" },
 { CHECK7F_SUBJECT_RDN_ATTRIBUTE,
		BEG_REPEAT2 | SEQUENCE_TAG,	L"....Subject.RDN.Attribute" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L".....Subject.RDN.Attribute.ObjectId" },
 { CHECK7F_SUBJECT_RDN_STRING, ANY_TAG,		L".....Subject.RDN.Attribute.Value" },
 { 0, END_REPEAT2 | 3,				L"...." },
 { 0, END_REPEAT1 | 5,				L"..." },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L"..PublicKey" },
 { CHECK7F_OTHER, SEQUENCE_TAG,			L"...PublicKey.Algorithm" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L"....PublicKey.Algorithm.ObjectId" },
 { CHECK7F_OTHER, ANY_TAG | OPTIONAL_FIELD,	L"....PublicKey.Algorithm.Parameters" },
 { CHECK7F_OTHER, BIT_STRING_TAG,		L"...PublicKey.Key" },

 { CHECK7F_OTHER,
	PRIMITIVE_TAG | 1 | OPTIONAL_FIELD,	L"..IssuerUniqueId" },
 { CHECK7F_OTHER,
	PRIMITIVE_TAG | 2 | OPTIONAL_FIELD,	L"..SubjectUniqueId" },

 { CHECK7F_EXTENSIONS,
	ATTRIBUTE_TAG | 3 | OPTIONAL_FIELD,	L"..Extensions" },
 { CHECK7F_EXTENSION_ARRAY, SEQUENCE_TAG,	L"...Extensions.Array" },
 { CHECK7F_EXTENSION,
		 BEG_REPEAT1 | SEQUENCE_TAG,	L"....Extensions.Array.Extension" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L".....Extensions.Array.Extension.ObjectId" },
 { CHECK7F_OTHER, BOOLEAN_TAG | OPTIONAL_FIELD,	L".....Extensions.Array.Extension.Critical" },
 { CHECK7F_EXTENSION_VALUE, OCTET_STRING_TAG,	L".....Extensions.Array.Extension.Value" },
 //{ CHECK7F_EXTENSION_VALUE_RAW, ANY_TAG,	L"......Extensions.Array.Extension.Value.Bits" },
 { 0, END_REPEAT1 | 4,				L"...." },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L".SignatureAlogorithm" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L"..SignatureAlgorithm.ObjectId" },
 { CHECK7F_OTHER, ANY_TAG | OPTIONAL_FIELD,	L"..SignatureAlgorithm.Parameters" },

 { CHECK7F_OTHER, BIT_STRING_TAG,		L".Signature" },

 { 0, 0,					NULL }
};

#define cbOLDCERTENROLLCHOKESLENGTH	0x7f


// DecodeLength decodes an ASN1 encoded length field.  The pbEncoded parameter
// is the encoded length.  pdwLen is used to return the length.  The function
// returns a -1 if it fails and otherwise returns the number of total bytes in
// the encoded length.

long
DecodeLength(
    BOOL fVerbose,
    DWORD *pdwLen,
    DWORD iLevel,
    BYTE const *pbBase,
    BYTE const *pbEncoded,
    DWORD cbEncoded,
    WCHAR const *pwsz)
{
    long    index = 0;
    BYTE    count;

    assert(NULL != pdwLen);
    assert(NULL != pbEncoded);

    if (1 > cbEncoded)
    {
        DBGPRINT((DBG_SS_CERTLIB, "cbEncoded overflow %d\n", cbEncoded));
        return(-1);
    }

    // determine the length of the length field

    count = pbEncoded[0];
    if (0x80 < count)
    {
        // If there is more than one byte in the length field, then the lower
	// seven bits tells us the number of bytes.

        count &= 0x7f;

        // This function only allows the length field to be 2 bytes.  If the
	// field is longer, then the function fails.

        if (2 < count)
        {
            DBGPRINT((DBG_SS_CERTLIB, "Length field reported to be over 2 bytes\n"));
            return(-1);
        }

        if (count > cbEncoded)
	{
	    DBGPRINT((DBG_SS_CERTLIB, "cbEncoded overflow %d\n", cbEncoded));
	    return(-1);
	}

        *pdwLen = 0;

        // go through the bytes of the length field

        for (index = 1; index <= count; index++)
        {
            *pdwLen = (*pdwLen << 8) + pbEncoded[index];
        }
    }
    else	// the length field is just one byte long
    {
        *pdwLen = pbEncoded[0];
        index = 1;
    }

    // return how many bytes there were in the length field.

#if DBG_CERTSRV
    if (fVerbose)
    {
	CONSOLEPRINT7((
		    DBG_SS_CERTLIB,
		    "asn %u:@%x: %02x, len %x, cbEncoded %x, end @%x, %ws\n",
		    iLevel,
		    &pbEncoded[-1] - pbBase,
		    pbEncoded[-1],
		    *pdwLen,
		    cbEncoded + 1,
		    &pbEncoded[-1] - pbBase + cbEncoded + 1,
		    pwsz));
    }
#endif // DBG_CERTSRV
    return(index);
}


WCHAR const *
GetLevel(
    OPTIONAL IN WCHAR const *pwszField,
    OUT DWORD *piLevel)
{
    DWORD iLevel = 0;

    iLevel = 0;
    if (NULL != pwszField)
    {
	while ('.' == *pwszField)
	{
	    iLevel++;
	    pwszField++;
	}
    }
    *piLevel = iLevel;
    return(pwszField);
}


BOOL
RestoreLevel(
    IN DWORD *acbLevel,
    IN DWORD iLevelNext,
    IN DWORD *piLevel,
    IN BOOL fVerbose)
{
    BOOL fOk = FALSE;
    DWORD iLevel;
    DWORD i = *piLevel;

#if DBG_CERTSRV
    if (1 < fVerbose)
    {
	CONSOLEPRINT2((
		    DBG_SS_CERTLIBI,
		    "RestoreLevel(%x, %x)\n",
		    iLevelNext,
		    *piLevel));
    }
#endif

    iLevel = *piLevel;

    while (0 < iLevel && 0 == acbLevel[iLevel] && iLevelNext < iLevel)
    {
	iLevel--;
	if (1 < fVerbose)
	{
	    CONSOLEPRINT2((
		    DBG_SS_CERTLIBI, 
		    "Restoring length(%u) ==> %x\n",
		    iLevel,
		    acbLevel[iLevel]));
	}
    }
    if (iLevelNext < iLevel)
    {
	CONSOLEPRINT2((
		    MAXDWORD, 
		    "BAD RESTORED LENGTH[%u]: 0 < %x\n",
		    iLevel,
		    acbLevel[iLevel]));
	goto error;
    }
    *piLevel = iLevel;
    fOk = TRUE;

error:
    if (1 < fVerbose)
    {
	CONSOLEPRINT4((
		    DBG_SS_CERTLIBI, 
		    "RestoreLevel(%x, %x --> %x) --> %x\n",
		    iLevelNext,
		    i,
		    *piLevel,
		    fOk));
    }
    return(fOk);
}


VOID
ReturnString(
    IN WCHAR const *pwszReturn,
    OPTIONAL IN OUT DWORD *pcwcBuf,
    OPTIONAL OUT WCHAR *pwcBuf)
{
    DWORD cwcNeeded = wcslen(pwszReturn) + 1;
    DWORD cwcBuf;

    if (NULL != pcwcBuf)
    {
	cwcBuf = *pcwcBuf;
	if (NULL != pwcBuf && 0 < cwcBuf)
	{
	    CopyMemory(pwcBuf, pwszReturn, sizeof(WCHAR) * min(cwcBuf, cwcNeeded));
	    pwcBuf[cwcBuf - 1] = L'\0';
	}
	*pcwcBuf = cwcNeeded;
    }
}


#define MATCHTAG(b, flags)  ((ANY_TAG & (flags)) || (b) == (BYTE) (flags))


HRESULT
myCheck7f(
    IN const BYTE *pbCert,
    IN DWORD cbCert,
    IN BOOL fVerbose,
    OUT DWORD *pState,
    OPTIONAL OUT DWORD *pIndex1,
    OPTIONAL OUT DWORD *pIndex2,
    OPTIONAL IN OUT DWORD *pcwcField,
    OPTIONAL OUT WCHAR *pwszField,
    OPTIONAL IN OUT DWORD *pcwcObjectId,
    OPTIONAL OUT WCHAR *pwszObjectId,
    OPTIONAL OUT WCHAR const **ppwszObjectIdDescription)
{
    ASNTABLE const *pasn;
    HRESULT hr = S_OK;
    BOOL fSaveCert = TRUE;
    BYTE const *pb = pbCert;
    long index;
    DWORD length;
    DWORD acbLevel[20];
    DWORD iLevel;
    DWORD iLevelNext;
    WCHAR const *pwszfieldname;
    DWORD cbdiff;
    DWORD aiElement[20];
    DWORD aiElement7f[2];
    DWORD iElementLevel;
    DWORD State;
    BOOL fSetField = FALSE;
    BOOL fSetObjectId = FALSE;
    CERT_INFO *pCertInfo = NULL;
    DWORD cbCertInfo;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    WCHAR *pwszObjId = NULL;

    State = CHECK7F_NONE;
    if (NULL != ppwszObjectIdDescription)
    {
	*ppwszObjectIdDescription = NULL;
    }

#if DBG_CERTSRV
    if (!fVerbose && DbgIsSSActive(DBG_SS_CERTLIBI))
    {
	fVerbose = TRUE;
    }
#endif // DBG_CERTSRV
    if (fVerbose)
    {
	CONSOLEPRINT1((MAXDWORD, "myCheck7f: %x bytes\n", cbCert));
    }
    pasn = asnCert;
    iLevel = 0;
    ZeroMemory(aiElement7f, sizeof(aiElement7f));
    acbLevel[iLevel] = cbCert;
    iElementLevel = 0;
    while (0 != iLevel || (0 != acbLevel[iLevel] && NULL != pasn->pwszElement))
    {
	DWORD i;

	if (1 < fVerbose)
	{
	    if (2 < fVerbose)
	    {
		CONSOLEPRINT3((
			    DBG_SS_CERTLIBI, 
			    "ASN:0: *pb=%x %u: %ws\n",
			    *pb,
			    pasn - asnCert,
			    pasn->pwszElement));
	    }
	    CONSOLEPRINT0((MAXDWORD, "LENGTHS:0:"));
	    for (i = 0; i <= iLevel; i++)
	    {
		CONSOLEPRINT1((MAXDWORD, " %3x", acbLevel[i]));
	    }
	    CONSOLEPRINT0((MAXDWORD, "\n"));
	}
	while (OPTIONAL_FIELD & pasn->Flags)
	{
	    DWORD f;

	    if (0 < acbLevel[iLevel] && MATCHTAG(*pb, pasn->Flags))
	    {
#if DBG_CERTSRV
		if (fVerbose)
		{
		    CONSOLEPRINT2((
			    DBG_SS_CERTLIB,
			    "Optional field MATCH cb=%x %ws\n",
			    acbLevel[iLevel],
			    pasn->pwszElement));
		}
#endif // DBG_CERTSRV
		break;
	    }

#if DBG_CERTSRV
	    if (fVerbose)
	    {
		CONSOLEPRINT2((
			DBG_SS_CERTLIB,
			"Optional field NO match cb=%x %ws\n",
			acbLevel[iLevel],
			pasn->pwszElement));
	    }
#endif // DBG_CERTSRV

	    f = 0;
	    switch ((BEG_REPEAT1 | BEG_REPEAT2) & pasn->Flags)
	    {
		case BEG_REPEAT1:
		    f = END_REPEAT1;
		    break;

		case BEG_REPEAT2:
		    f = END_REPEAT2;
		    break;
	    }
	    if (f)
	    {
		while (!(f & pasn->Flags))
		{
#if DBG_CERTSRV
		    if (fVerbose)
		    {
			CONSOLEPRINT2((
				DBG_SS_CERTLIB,
				"Skipping[%x] %ws\n",
				f,
				pasn->pwszElement));
		    }
#endif // DBG_CERTSRV
		    pasn++;
		}
	    }
	    else
	    {
		DWORD iLevelCurrent;
		
		GetLevel(pasn->pwszElement, &iLevelCurrent);
		while (TRUE)
		{
		    GetLevel(pasn[1].pwszElement, &iLevelNext);
		    if (iLevelNext <= iLevelCurrent)
		    {
			break;
		    }
#if DBG_CERTSRV
		    if (fVerbose)
		    {
			CONSOLEPRINT1((
				DBG_SS_CERTLIB,
				"Skipping nested optional field %ws\n",
				pasn->pwszElement));
		    }
#endif // DBG_CERTSRV
		    pasn++;
		}
	    }
#if DBG_CERTSRV
	    if (fVerbose)
	    {
		CONSOLEPRINT1((
			DBG_SS_CERTLIB,
			"Skipping optional field %ws\n",
			pasn->pwszElement));
	    }
#endif // DBG_CERTSRV
	    pasn++;

	    if (0 == acbLevel[iLevel])
	    {
		GetLevel(pasn->pwszElement, &iLevelNext);
		if (iLevelNext < iLevel)
		{
		    iLevel = iLevelNext;
		}
	    }
	}
	while ((END_REPEAT1 | END_REPEAT2) & pasn->Flags)
	{
	    // Make sure only one END_REPEAT bit is on.
	    assert(
		(END_REPEAT1 | END_REPEAT2) !=
		((END_REPEAT1 | END_REPEAT2) & pasn->Flags));

	    pwszfieldname = GetLevel(pasn->pwszElement, &iLevelNext);
	    if (!RestoreLevel(acbLevel, iLevelNext, &iLevel, fVerbose))
	    {
		goto error;
	    }
	    i = (BYTE) pasn->Flags;
	    assert((DWORD) (pasn - asnCert) > i);
	    if (0 != acbLevel[iLevel])
	    {
		if (!MATCHTAG(*pb, (pasn - i)->Flags))
		{
		    CONSOLEPRINT5((
			MAXDWORD, 
			"Check7f: Unexpected tag at %x: at level %u: (%x/%x) %ws\n",
			cbCert - acbLevel[0],
			iLevel,
			*pb,
			pasn->Flags,
			pasn->pwszElement));
		    goto error;
		}

		// Some data remain at this level, and the type tag matches
		// the expected repeat tag, loop back to the start of the
		// section to be repeated.

		pasn -= i;

		// Make sure only one BEG_REPEAT bit is on.
		assert(
		    (BEG_REPEAT1 | BEG_REPEAT2) !=
		    ((BEG_REPEAT1 | BEG_REPEAT2) & pasn->Flags));

		// Make sure the BEG_REPEAT bit in the begin record matches
		// the END_REPEAT bit in the end record.
		assert(
		    ((BEG_REPEAT1 & pasn->Flags) &&
		     (END_REPEAT1 & pasn[i].Flags)) ||
		    ((BEG_REPEAT2 & pasn->Flags) &&
		     (END_REPEAT2 & pasn[i].Flags)));
	    }
	    else
	    {
		pasn++;
		iElementLevel--;
	    }
	}
	if (2 < fVerbose)
	{
	    CONSOLEPRINT3((
			DBG_SS_CERTLIBI, 
			"ASN:1: *pb=%x %u: %ws\n",
			*pb,
			pasn - asnCert,
			pasn->pwszElement));
	}
	if ((BEG_REPEAT1 | BEG_REPEAT2) & pasn->Flags)
	{
	    if ((BEG_REPEAT1 & pasn->Flags) && 0 == iElementLevel ||
		(BEG_REPEAT2 & pasn->Flags) && 1 == iElementLevel)
	    {
		iElementLevel++;
		aiElement[iElementLevel] = 0;
	    }
	    aiElement[iElementLevel]++;
	}

	pwszfieldname = GetLevel(pasn->pwszElement, &iLevelNext);
	if (!RestoreLevel(acbLevel, iLevelNext, &iLevel, fVerbose))
	{
	    goto error;
	}

	if (1 < fVerbose)
	{
	    CONSOLEPRINT0((MAXDWORD, "LENGTHS:1:"));
	    for (i = 0; i <= iLevel; i++)
	    {
		CONSOLEPRINT1((MAXDWORD, " %3x", acbLevel[i]));
	    }
	    CONSOLEPRINT0((MAXDWORD, "\n"));
	}
	if (0 == iLevel && 0 == acbLevel[0])
	{
	    break;		// all done!
	}
	if (!MATCHTAG(*pb, pasn->Flags))
	{
	    CONSOLEPRINT5((
		MAXDWORD, 
		"Check7f: Unexpected tag at %x: at level %u: (%x/%x) %ws\n",
		cbCert - acbLevel[0],
		iLevel,
		*pb,
		pasn->Flags,
		pasn->pwszElement));
	    goto error;
	}

	GetLevel(pasn[1].pwszElement, &iLevelNext);
	index = DecodeLength(
			fVerbose,
			&length,
			iLevel,
			pbCert,
			&pb[1],
			acbLevel[iLevel] - 1,
			pasn->pwszElement);

	if (fVerbose)
	{
	    DWORD ccol;
	    char achdbg[128];
	    char *pchdbg;
	    //char achbuf[10];

	    pchdbg = achdbg;
	    pchdbg += sprintf(pchdbg, "%04x:", pb - pbCert);

	    for (i = 0; i <= iLevel; i++)
	    {
		pchdbg += sprintf(pchdbg, " %3x", acbLevel[i]);
	    }
	    pchdbg += sprintf(pchdbg, " (%x)", length);
        
	    ccol = SAFE_SUBTRACT_POINTERS(pchdbg, achdbg);
	    if (ccol > 34)
	    {
		ccol = 34;
	    }
	    pchdbg += sprintf(pchdbg, " %*hs -- ", 34 - ccol, "");

	    assert(2 >= iElementLevel);
	    if (1 == iElementLevel)
	    {
		pchdbg += sprintf(pchdbg, "[%u]:", aiElement[1] - 1);
	    }
	    else if (2 == iElementLevel)
	    {
		pchdbg += sprintf(
				pchdbg, 
				"[%u,%u]:",
				aiElement[1] - 1,
				aiElement[2] - 1);
	    }
	    CONSOLEPRINT2((DBG_SS_CERTLIBI, "%hs%ws\n", achdbg, pwszfieldname));
	}
	if (length == cbOLDCERTENROLLCHOKESLENGTH)
	{
	    CONSOLEPRINT2((
			MAXDWORD, 
			"Check7f: Length of %ws is %u bytes\n",
			pwszfieldname,
			length));
	    if (CHECK7F_NONE == State)
	    {
		ReturnString(pwszfieldname, pcwcField, pwszField);
		if (1 <= iElementLevel)
		{
		    aiElement7f[0] = aiElement[1];
		}
		if (2 <= iElementLevel)
		{
		    aiElement7f[1] = aiElement[2];
		}
		State = pasn->State;
		fSetField = TRUE;
	    }
	}

	if (1 < fVerbose)
	{
	    CONSOLEPRINT6((
			DBG_SS_CERTLIBI, 
			"index=%x len=%x level=%x->%x acb[%x]=%x\n",
			index,
			length,
			iLevel,
			iLevelNext,
			iLevel,
			acbLevel[iLevel]));
	}
	if (0 > index || index + length > acbLevel[iLevel])
	{
	    CONSOLEPRINT2((
			MAXDWORD,
			"Check7f: BAD LENGTH: i=%x l=%x\n",
			index,
			length));
	    goto error;
	}

	cbdiff = index + 1;
	if (iLevelNext > iLevel)
	{
	    assert(iLevel + 1 == iLevelNext);
	}
	else
	{
	    cbdiff += length;
	}
	for (i = 0; i <= iLevel; i++)
	{
	    if (acbLevel[i] < cbdiff)
	    {
		CONSOLEPRINT3((
			    MAXDWORD, 
			    "Check7f: BAD NESTED LENGTH[%u]: %x < %x\n",
			    i,
			    acbLevel[i],
			    cbdiff));
		goto error;
	    }
	    acbLevel[i] -= cbdiff;
	}

	if (iLevelNext > iLevel)
	{
	    iLevel++;
	    if (1 < fVerbose)
	    {
		CONSOLEPRINT2((
			    DBG_SS_CERTLIBI,
			    "Saving length(%u) <== %x\n",
			    iLevel,
			    length));
	    }
	    acbLevel[iLevel] = length;
	}
	pb += cbdiff;
	pasn++;
    }
    *pIndex1 = 0;
    if (0 != iLevel || 0 != acbLevel[iLevel] || NULL != pasn->pwszElement)
    {
	CONSOLEPRINT3((
		    MAXDWORD, 
		    "Check7f: Mismatch: %x bytes left at: %x: %ws\n",
		    acbLevel[iLevel],
		    cbCert - acbLevel[0],
		    pasn->pwszElement));
    }
    else if (!fSetField)
    {
	fSaveCert = FALSE;
    }
    if (fSetField && NULL != pcwcObjectId)
    {
	char const *pszObjId;
	CERT_NAME_BLOB const *pNameBlob;

	// Decode certificate

	cbCertInfo = 0;
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT_TO_BE_SIGNED,
			pbCert,
			cbCert,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pCertInfo,
			&cbCertInfo))
	{
	    hr = GetLastError();
	    goto error;
	}
	pszObjId = NULL;
	pNameBlob = NULL;
	switch (State)
	{
	    case CHECK7F_ISSUER_RDN:
	    case CHECK7F_ISSUER_RDN_ATTRIBUTE:
	    case CHECK7F_ISSUER_RDN_STRING:
		pNameBlob = &pCertInfo->Issuer;
		break;

	    case CHECK7F_SUBJECT_RDN:
	    case CHECK7F_SUBJECT_RDN_ATTRIBUTE:
	    case CHECK7F_SUBJECT_RDN_STRING:
		pNameBlob = &pCertInfo->Subject;
		break;

	    case CHECK7F_EXTENSION:
	    case CHECK7F_EXTENSION_VALUE:
	    case CHECK7F_EXTENSION_VALUE_RAW:
		if (0 != aiElement7f[0] &&
		    aiElement7f[0] <= pCertInfo->cExtension)
		{
		    pszObjId =
			pCertInfo->rgExtension[aiElement7f[0] - 1].pszObjId;
		}
		break;

	    default:
		break;
	}
	if (NULL != pNameBlob)
	{
	    if (!myDecodeName(
			X509_ASN_ENCODING,
			X509_UNICODE_NAME,
			pNameBlob->pbData,
			pNameBlob->cbData,
			CERTLIB_USE_LOCALALLOC,
			&pNameInfo,
			&cbNameInfo))
	    {
		hr = GetLastError();
		goto error;
	    }
	    if (0 != aiElement7f[0] && aiElement7f[0] <= pNameInfo->cRDN)
	    {
		CERT_RDN *pRDN;

		pRDN = &pNameInfo->rgRDN[aiElement7f[0] - 1];

		if (0 != aiElement7f[1] && aiElement7f[1] <= pRDN->cRDNAttr)
		{
		    pszObjId = pRDN->rgRDNAttr[aiElement7f[1] - 1].pszObjId;
		}
	    }
	}
	if (NULL != pszObjId)
	{
	    if (!ConvertSzToWsz(&pwszObjId, pszObjId, -1))
	    {
		hr = E_OUTOFMEMORY;
		goto error;
	    }
	    ReturnString(pwszObjId, pcwcObjectId, pwszObjectId);
	    fSetObjectId = TRUE;
	    if (NULL != ppwszObjectIdDescription)
	    {
		WCHAR const *pwszDesc;

		pwszDesc = myGetOIDNameA(pszObjId);
		if (NULL != pwszDesc && L'\0' != *pwszDesc)
		{
		    *ppwszObjectIdDescription = pwszDesc;
		}
	    }
	}
    }

error:
    if (fSaveCert)
    {
	EncodeToFileW(
		fSetField? L"c:\\7flen.crt" : L"c:\\7fasn.crt",
		pbCert,
		cbCert,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
    }
    if (NULL != pCertInfo)
    {
	LocalFree(pCertInfo);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }

    *pState = State;
    if (NULL != pIndex1)
    {
	*pIndex1 = aiElement7f[0];
    }
    if (NULL != pIndex2)
    {
	*pIndex2 = aiElement7f[1];
    }
    if (!fSetField && NULL != pcwcField)
    {
	if (NULL != pwszField && 0 < *pcwcField)
	{
	    pwszField[0] = L'\0';
	}
	*pcwcField = 0;
    }
    if (!fSetObjectId && NULL != pcwcObjectId)
    {
	if (NULL != pwszObjectId && 0 < *pcwcObjectId)
	{
	    pwszObjectId[0] = L'\0';
	}
	*pcwcObjectId = 0;
    }
    if (fVerbose)
    {
	CONSOLEPRINT1((MAXDWORD, "myCheck7f: --> %x\n", hr));
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\config.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       config.cpp
//
//  Contents:   ICertConfig IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_CONFIG_CPP__


//+------------------------------------------------------------------------
// ICertConfig dispatch support

// TCHAR szRegKeyConfigClsid[] = wszCLASS_CERTCONFIG TEXT("\\Clsid");

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
    TEXT("Index"),
};

//+------------------------------------
// Next method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetField method:

static OLECHAR *_apszGetField[] = {
    TEXT("GetField"),
    TEXT("strFieldName"),
};

//+------------------------------------
// GetConfig method:

static OLECHAR *_apszGetConfig[] = {
    TEXT("GetConfig"),
    TEXT("Flags"),
};

//+------------------------------------
// SetSharedFolder method:

static OLECHAR *_apszSetSharedFolder[] = {
    TEXT("SetSharedFolder"),
    TEXT("strSharedFolder"),
};

//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtConfig[] =
{
#define CONFIG_RESET		0
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define CONFIG_NEXT		1
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define CONFIG_GETFIELD		2
    DECLARE_DISPATCH_ENTRY(_apszGetField)

#define CONFIG_GETCONFIG	3
    DECLARE_DISPATCH_ENTRY(_apszGetConfig)

#define CONFIG2_SETSHAREDFOLDER	4
    DECLARE_DISPATCH_ENTRY(_apszSetSharedFolder)
};
#define CCONFIGDISPATCH	(ARRAYSIZE(s_adtConfig))
#define CCONFIGDISPATCH_V1	CONFIG2_SETSHAREDFOLDER
#define CCONFIGDISPATCH_V2	CCONFIGDISPATCH


DWORD s_acConfigDispatch[] = {
    CCONFIGDISPATCH_V2,
    CCONFIGDISPATCH_V1,
};

IID const *s_apConfigiid[] = {
    &IID_ICertConfig2,
    &IID_ICertConfig,
};


HRESULT
Config_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiConfig)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTCONFIG,
		&CLSID_CCertConfig,
		ARRAYSIZE(s_acConfigDispatch),		// cver
		s_apConfigiid,
		s_acConfigDispatch,
		s_adtConfig,
		pdiConfig);
    _JumpIfError(hr, error, "DispatchSetup2(ICertConfig)");

error:
    return(hr);
}


VOID
Config_Release(
    IN OUT DISPATCHINTERFACE *pdiConfig)
{
    DispatchRelease(pdiConfig);
}


HRESULT
ConfigVerifyVersion(
    IN DISPATCHINTERFACE *pdiConfig,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    switch (pdiConfig->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiConfig->pDispatch ||
		CCONFIGDISPATCH_V1 == pdiConfig->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiConfig->pDispatch ||
		CCONFIGDISPATCH_V2 == pdiConfig->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiConfig->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Config_Reset(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Index,
    OUT LONG *pCount)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Index;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_RESET,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pCount);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->Reset(Index, pCount);

	_JumpIfError(hr, error, "ICertConfig::Reset");
    }

error:
    return(hr);
}


HRESULT
Config_Next(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (NULL != pdiConfig->pDispatch)
    {
	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError(hr, error, "Invoke(Next)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->Next(pIndex);
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "ICertConfig::Next");
	}
    }

error:
    return(hr);
}


HRESULT
Config_GetField(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszField,
    OUT BSTR *pstr)
{
    HRESULT hr;
    BSTR strField = NULL;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (!ConvertWszToBstr(&strField, pwszField, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    //wprintf(L"str=%ws, len=%u\n", strField, ((ULONG *) strField)[-1]);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strField;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_GETFIELD,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstr);
	_JumpIfError(hr, error, "Invoke(GetField)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->GetField(strField, pstr);
	_JumpIfErrorNotSpecific(
			    hr,
			    error,
			    "ICertConfig::GetField",
			    CERTSRV_E_PROPERTY_EMPTY);
    }
    hr = S_OK;

error:
    if (NULL != strField)
    {
	SysFreeString(strField);
    }
    return(hr);
}


HRESULT
Config_GetConfig(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Flags,
    OUT BSTR *pstrConfig)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_GETCONFIG,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrConfig);
	_JumpIfError(hr, error, "Invoke(GetConfig)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->GetConfig(Flags, pstrConfig);
	_JumpIfError(hr, error, "ICertConfig::GetConfig");
    }

error:
    return(hr);
}


HRESULT
Config2_SetSharedFolder(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszSharedFolder)
{
    HRESULT hr;
    BSTR strSharedFolder = NULL;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    hr = ConfigVerifyVersion(pdiConfig, 2);
    _JumpIfError(hr, error, "ConfigVerifyVersion");

    if (!ConvertWszToBstr(&strSharedFolder, pwszSharedFolder, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    //wprintf(L"str=%ws, len=%u\n", strSharedFolder, ((ULONG *) strSharedFolder)[-1]);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strSharedFolder;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG2_SETSHAREDFOLDER,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetSharedFolder)");
    }
    else
    {
	hr = ((ICertConfig2 *) pdiConfig->pUnknown)->SetSharedFolder(strSharedFolder);
	_JumpIfError(hr, error, "ICertConfig::GetConfig");
    }

error:
    if (NULL != strSharedFolder)
    {
	SysFreeString(strSharedFolder);
    }
    return(hr);
}


WCHAR const * const s_apwszFieldNames[] = {
    wszCONFIG_COMMONNAME,
    wszCONFIG_ORGUNIT,
    wszCONFIG_ORGANIZATION,
    wszCONFIG_LOCALITY,
    wszCONFIG_STATE,
    wszCONFIG_COUNTRY,
    wszCONFIG_CONFIG,
    wszCONFIG_EXCHANGECERTIFICATE,
    wszCONFIG_SIGNATURECERTIFICATE,
    wszCONFIG_DESCRIPTION,
    wszCONFIG_SERVER,
    wszCONFIG_AUTHORITY,
    wszCONFIG_SANITIZEDNAME,
    wszCONFIG_SHORTNAME,
    wszCONFIG_SANITIZEDSHORTNAME,
    wszCONFIG_FLAGS,
};
#define CSTRING (sizeof(s_apwszFieldNames)/sizeof(s_apwszFieldNames[0]))

WCHAR const *s_apwszDisplayNames[CSTRING] = {
    wszCONFIG_COMMONNAME L":",
    wszCONFIG_ORGUNIT L":",
    wszCONFIG_ORGANIZATION L":",
    wszCONFIG_LOCALITY L":",
    wszCONFIG_STATE L":",
    wszCONFIG_COUNTRY L":",
    wszCONFIG_CONFIG L":",
    wszCONFIG_EXCHANGECERTIFICATE L":",
    wszCONFIG_SIGNATURECERTIFICATE L":",
    wszCONFIG_DESCRIPTION L":",
    wszCONFIG_SERVER L":",
    wszCONFIG_AUTHORITY L":",
    wszCONFIG_SANITIZEDNAME L":",
    wszCONFIG_SHORTNAME L":",
    wszCONFIG_SANITIZEDSHORTNAME L":",
    wszCONFIG_FLAGS L":",
};


HRESULT
ConfigDumpSetDisplayNames(
    IN WCHAR const * const *apwszFieldNames,
    IN WCHAR const * const *apwszDisplayNames,
    IN DWORD cNames)
{
    DWORD i;
    DWORD j;
    HRESULT hr;

    for (i = 0; i < cNames; i++)
    {
	for (j = 0; j < CSTRING; j++)
	{
	    if (0 == lstrcmpi(s_apwszFieldNames[j], apwszFieldNames[i]) ||
		(0 == lstrcmpi(s_apwszFieldNames[j], wszCONFIG_DESCRIPTION) &&
		 0 == lstrcmpi(apwszFieldNames[i], wszCONFIG_COMMENT)))
	    {
		s_apwszDisplayNames[j] = apwszDisplayNames[i];
		break;
	    }
	}
	if (CSTRING <= j)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "column name", apwszFieldNames[i]);
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ConfigDumpEntry(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszEntry,		// localized L"Entry"
    IN LONG Index,  // less than 0 skip index, entry, & suffix print
    OPTIONAL IN WCHAR const *pwszSuffix)
{
    HRESULT hr;
    DWORD i;
    BSTR strings[CSTRING];

    for (i = 0; i < CSTRING; i++)
    {
	strings[i] = NULL;
    }
    for (i = 0; i < CSTRING; i++)
    {
	hr = Config_GetField(pdiConfig, s_apwszFieldNames[i], &strings[i]);
	_JumpIfError(hr, error, "Config_GetField");
    }
    if (-1 < Index)
    {
        myConsolePrintf(
	    L"%ws%ws %u:%ws%ws\n",
	    0 == Index? L"" : L"\n",
	    pwszEntry,
	    Index,
	    NULL != pwszSuffix? L" " : L"",
	    NULL != pwszSuffix? pwszSuffix : L"");
    }
    for (i = 0; i < CSTRING; i++)
    {
	myConsolePrintf(L"  ");
	myConsolePrintString(24, s_apwszDisplayNames[i]);
	myConsolePrintf(L"\t`");
	if (0 != wcscmp(s_apwszFieldNames[i], L"ExchangeCertificate"))
	{
	    if (NULL != strings[i])
	    {
		myConsolePrintf(L"%ws", strings[i]);
	    }
	}
	myConsolePrintf(L"'\n");
    }

error:
    for (i = 0; i < CSTRING; i++)
    {
	if (NULL != strings[i])
	{
	    SysFreeString(strings[i]);
	}
    }
    return(hr);
}


HRESULT
ConfigDump(
    IN DWORD Flags,				// See DispatchSetup() Flags
    IN WCHAR const *pwszEntry,			// localized L"Entry"
    OPTIONAL IN WCHAR const *pwszLocalSuffix,	// localized L"(Local)"
    OPTIONAL IN WCHAR const *pwszMach1,
    OPTIONAL IN WCHAR const *pwszMach2)
{
    HRESULT hr;
    LONG i;
    LONG count;
    LONG Index;
    BSTR strServer = NULL;
    WCHAR const *pwszSuffix;
    DISPATCHINTERFACE diConfig;

    hr = Config_Init(Flags, &diConfig);
    _JumpIfError(hr, error, "Config_Init");

    hr = Config_Reset(&diConfig, 0, &count);
    _JumpIfError(hr, error, "Config_Reset");

    Index = 0;
    for (i = 0; i < count; i++)
    {
	hr = Config_Next(&diConfig, &Index);
	if (S_OK != hr && S_FALSE != hr)
	{
	    _JumpError(hr, error, "Config_Next");
	}
	hr = S_OK;
	if (-1 == Index)
	{
	    break;
	}

	pwszSuffix = NULL;
	if (NULL != pwszLocalSuffix)
	{
	    hr = Config_GetField(&diConfig, wszCONFIG_SERVER, &strServer);
	    _JumpIfError(hr, error, "Config_GetField");

	    if ((NULL != pwszMach1 && 0 == lstrcmpi(strServer, pwszMach1)) ||
		(NULL != pwszMach2 && 0 == lstrcmpi(strServer, pwszMach2)))
	    {
		pwszSuffix = pwszLocalSuffix;
	    }
	}
	hr = ConfigDumpEntry(&diConfig, pwszEntry, Index, pwszSuffix);
	_JumpIfError(hr, error, "ConfigDumpEntry");
    }

error:
    if (NULL != strServer)
    {
	SysFreeString(strServer);
    }
    Config_Release(&diConfig);
    return(hr);
}


HRESULT
ConfigGetConfig(
    IN DWORD Flags,
    IN DWORD dwUIFlag,
    OUT BSTR *pstrConfig)
{
    HRESULT hr;
    LONG count;
    DISPATCHINTERFACE diConfig;

    hr = Config_Init(Flags, &diConfig);
    _JumpIfError(hr, error, "Config_Init");

    hr = Config_GetConfig(&diConfig, dwUIFlag, pstrConfig);
    _JumpIfError(hr, error, "Config_GetConfig");

error:
    Config_Release(&diConfig);
    return(hr);
}


DWORD
myGetDisplayLength(
    IN WCHAR const *pwsz)
{
    HRESULT hr;
    LONG ccol;

    CSASSERT(NULL != pwsz);

    ccol = WideCharToMultiByte(
		    GetACP(),	// CodePage
		    0,		// dwFlags
		    pwsz,	// lpWideCharStr
		    -1,		// cchWideChar, -1 => L'\0' terminated
		    NULL,	// lpMultiByteStr
		    0,		// cbMultiByte
		    NULL,	// lpDefaultChar
		    NULL);	// lpUsedDefaultChar
    if (0 >= ccol)
    {
	if (0 > ccol || L'\0' != *pwsz)
	{
	    hr = myHLastError();
	    _PrintError(hr, "WideCharToMultiByte");
	}
	ccol = wcslen(pwsz);
    }
    else
    {
	ccol--;			// don't include trailing L'\0'
    }
//error:
    return(ccol);
}


LONG
myConsolePrintString(
    IN DWORD ccolMin,
    IN WCHAR const *pwszString)
{
    DWORD ccolDisplay;
    DWORD ccolRet;

    ccolRet = myGetDisplayLength(pwszString);
    ccolDisplay = ccolRet;
    if (ccolMin < ccolDisplay)
    {
	ccolDisplay = ccolMin;
    }
    myConsolePrintf(L"%ws%*ws", pwszString, ccolMin - ccolDisplay, L"");
    return(ccolRet);
}


static BOOL s_fConsolePrintfDisable = FALSE;

BOOL
myConsolePrintfDisable(
    IN BOOL fDisable)
{
    BOOL fDisableOld = s_fConsolePrintfDisable;

    s_fConsolePrintfDisable = fDisable;
    return(fDisableOld);
}


// Fall back to stdio if s_fConsolePrintfDisable is set OR
// if _vsnwprintf doesn't exist in ntdll.dll and msvcrt.dll OR
// if we run out of memory allocating a working buffer.
//
// Otherwise:
// if redirected, use WriteFile
// if not redirected, use WriteConsole

#define cwcBUFMIN	512
#define cwcBUFMAX	(64 * 1024)

int __cdecl
myConsolePrintf(
    OPTIONAL IN WCHAR const *pwszFmt,
    ...)
{
    HRESULT hr;
    va_list pva;
    int cwc;
    DWORD cwcOut;
    HANDLE hStdOut;
    WCHAR wszBuf[cwcBUFMIN];
    WCHAR *pwszBuf = wszBuf;
    DWORD cwcBuf = ARRAYSIZE(wszBuf);
    CHAR szAnsi[2 * cwcBUFMIN];
    CHAR *pszAnsi = NULL;
    DWORD cchAnsi;

    typedef int (__cdecl FN_VSNWPRINTF)(
        OUT wchar_t *,
        IN size_t,
        IN const wchar_t *,
        IN va_list);

    HMODULE hModule;
    static FN_VSNWPRINTF *s_pfn = NULL;

    if (NULL == pwszFmt)
    {
        pwszFmt = L"(null)";
    }
    if (L'\0' == *pwszFmt)
    {
	cwcOut = 0;
	goto error;
    }
    if (NULL == s_pfn)
    {
        hModule = GetModuleHandle(TEXT("ntdll.dll"));
        if (NULL != hModule)
        {
            s_pfn = (FN_VSNWPRINTF *) GetProcAddress(hModule, "_vsnwprintf");
        }
	if (NULL == s_pfn)
	{
	    hModule = GetModuleHandle(TEXT("msvcrt.dll"));
            s_pfn = (FN_VSNWPRINTF *) GetProcAddress(hModule, "_vsnwprintf");
	}
    }
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (NULL == s_pfn || s_fConsolePrintfDisable)
    {
	hStdOut = INVALID_HANDLE_VALUE;		// use stdio fallback
    }

    if (INVALID_HANDLE_VALUE != hStdOut)
    {
	while (TRUE)
	{
	    va_start(pva, pwszFmt);
	    cwc = (*s_pfn)(pwszBuf, cwcBuf, pwszFmt, pva);
	    va_end(pva);

	    if (-1 != cwc)
	    {
		break;
	    }
	    if (cwcBUFMAX <= cwcBuf)
	    {
		_PrintError(
		    HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
		    "_vsnwprintf");
		hStdOut = INVALID_HANDLE_VALUE;
		break;
	    }
	    if (pwszBuf != wszBuf)
	    {
		LocalFree(pwszBuf);
	    }
	    cwcBuf *= 2;
	    if (cwcBUFMAX < cwcBuf)
	    {
		cwcBuf = cwcBUFMAX;
	    }
	    pwszBuf = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcBuf * sizeof(WCHAR));
	    if (NULL == pwszBuf)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
		hStdOut = INVALID_HANDLE_VALUE;
		break;
	    }
	}
    }

    if (INVALID_HANDLE_VALUE != hStdOut)
    {
	BOOL fRedirected = FALSE;

	// time for output -- where are we going, to a file or the console?
	
	switch (~FILE_TYPE_REMOTE & GetFileType(hStdOut))
	{
	    //case FILE_TYPE_UNKNOWN:
	    //case FILE_TYPE_PIPE:
	    //case FILE_TYPE_DISK:
	    default:
		// if redirected to a pipe or a file, don't use WriteConsole;
		// it drops redirected output on the floor
		fRedirected = TRUE;
		break;
		
	    case FILE_TYPE_CHAR:
		break;
	}

	if (!fRedirected)
	{
	    if (!WriteConsole(hStdOut, pwszBuf, cwc, &cwcOut, NULL))
	    {
		hr = myHLastError();
		_PrintError(hr, "WriteConsole");
		hStdOut = INVALID_HANDLE_VALUE;
	    }
	}
	else  // WriteConsole is out of the question
	{
	    DWORD cch;

	    // Expand all \n chars to \r\n so the WriteFile ends up clean.
	    // Alloc new buffer big enough to hold two bytes per WCHAR for
	    // worst case MultiByte translation + inserted \r chars.

	    cchAnsi = 2 * (cwc + 1);
	    if (ARRAYSIZE(szAnsi) >= cchAnsi)
	    {
		pszAnsi = szAnsi;
	    }
	    else
	    {
		pszAnsi = (LPSTR) LocalAlloc(LMEM_FIXED, cchAnsi);
		if (NULL == pszAnsi)
		{
		    _PrintError(E_OUTOFMEMORY, "LocalAlloc");
		    hStdOut = INVALID_HANDLE_VALUE;
		}
	    }
	    if (INVALID_HANDLE_VALUE != hStdOut)
	    {
		cch = WideCharToMultiByte(
				    GetConsoleOutputCP(),
				    0,
				    pwszBuf,
				    cwc,
				    pszAnsi,
				    cchAnsi,
				    NULL,
				    NULL);
		if (0 == cch)
		{
		    hr = myHLastError();
		    _PrintError(hr, "WideCharToMultiByte");
		    hStdOut = INVALID_HANDLE_VALUE;
		}
	    }
	    if (INVALID_HANDLE_VALUE != hStdOut)
	    {
		CHAR *pchWork = pszAnsi;
		DWORD cchOut;
		
		// expand all \n chars to \r\n

		cwcOut = cwc;
		for (unsigned int j = 0; j < cch; j++, pchWork++)
		{
		    if (*pchWork == '\n')
		    {
			// create a 1-char space before \n

			MoveMemory(&pchWork[1], pchWork, cch - j);

			// Fill with \r and skip past \r (this statement) and
			// \n (automatic via loop incr).

			*pchWork++ = '\r';
			j++;
			cch++;		// write one more char for each \n
		    }
		}
		CSASSERT(pchWork <= &pszAnsi[2 * cwc]);
		
		if (!WriteFile(hStdOut, pszAnsi, cch, &cchOut, NULL))
		{
		    hr = myHLastError();
		    _PrintError(hr, "WriteFile");
		    if (E_HANDLE == hr)
		    {
			hStdOut = INVALID_HANDLE_VALUE;
			s_fConsolePrintfDisable = TRUE;
		    }
		    else
		    {
			// This is the only case we drop output on the floor.
			// Most likely cause is disk full, so stdio won't help.
		    }
		}
	    }
	} // else WriteConsole
    }

    if (INVALID_HANDLE_VALUE == hStdOut)
    {
	BOOL fRetried = FALSE;
	
	while (TRUE)
	{
	    ALIGNIOB(stdout);
	    va_start(pva, pwszFmt);
	    __try
	    {
		cwcOut = vfwprintf(stdout, pwszFmt, pva);
		hr = S_OK;
	    }
	    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	    {
		cwcOut = MAXDWORD;
		DBGPRINT((
		    DBG_SS_ERROR,
		    "Exception %x: myConsolePrintf(%ws)",
		    hr,
		    pwszFmt));
	    }
	    va_end(pva);
	    if (S_OK == hr || fRetried || !IOBUNALIGNED(stdout))
	    {
		break;
	    }
	    fRetried = TRUE;
	}
    }

error:
    if (NULL != pwszBuf && wszBuf != pwszBuf)
    {
	LocalFree(pwszBuf);
    }
    if (NULL != pszAnsi && szAnsi != pszAnsi)
    {
	LocalFree(pszAnsi);
    }
    return((int) cwcOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\crfile.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crfile.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


HRESULT
myFixupRCFilterString(WCHAR *szFilter)
{
    if (NULL == szFilter)
        return S_OK;

    // translate to end of string
    for(LPWSTR szTmpPtr=szFilter; szTmpPtr=wcschr(szTmpPtr, L'|'); )
    {
        // replace every "|" with NULL termination
        szTmpPtr[0] = L'\0';
        szTmpPtr++;
    }

    return S_OK;
}

HRESULT
myGetFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    IN BOOL                  fOpen,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    HRESULT       hr;
    WCHAR        *pwszTitle = NULL;
    WCHAR        *pwszExpandedTitle = NULL;
    WCHAR        *pwszFilter = NULL;
    WCHAR        *pwszDefExt = NULL;
    WCHAR         wszFileName[MAX_PATH] = L"\0";
    WCHAR         wszEmptyFilter[] = L"\0";
    WCHAR         wszPath[MAX_PATH];
    WCHAR        *pwszFilePortion;
    DWORD         dwFileAttr;
    BOOL          fGetFile;
    OPENFILENAME  ofn;

    CSASSERT(NULL != ppwszFile);

    // init
    *ppwszFile = NULL;
    ZeroMemory(&ofn, sizeof(OPENFILENAME));

    if (0 != iRCTitle)
    {
        // load title
        hr = myLoadRCString(hInstance, iRCTitle, &pwszTitle);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszTitle);
            _PrintError(hr, "myLoadECString(iRCTitle)");
        }
        else if (NULL != pwszTitleInsert)
        {
            // replace %1
            if (FormatMessage(
                         FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         pwszTitle,
                         0,
                         0,
                         reinterpret_cast<WCHAR *>(&pwszExpandedTitle),
                         0,
                         reinterpret_cast<va_list *>
                             (const_cast<WCHAR **>(&pwszTitleInsert))) )
            {
                CSASSERT(NULL != pwszExpandedTitle);
                // free title with %1
                LocalFree(pwszTitle);
                pwszTitle = pwszExpandedTitle;
                pwszExpandedTitle = NULL;
            }
        }
    }

    if (0 != iRCFilter)
    {
        // load filter
        hr = myLoadRCString(hInstance, iRCFilter, &pwszFilter);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszFilter);
            _PrintError(hr, "myLoadECString(iRCFilter)");
        }
        if (NULL == pwszFilter)
        {
            //point to empty one
            pwszFilter = wszEmptyFilter;
        }
        else
        {
            hr = myFixupRCFilterString(pwszFilter);
            _JumpIfError(hr, error , "myFixupRCFilterString");
        }
    }

    if (0 != iRCDefExt)
    {
        // load default extension
        hr = myLoadRCString(hInstance, iRCDefExt, &pwszDefExt);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszDefExt);
            _PrintError(hr, "myLoadECString(iRCDefExt)");
        }
    }

    ofn.lStructSize = CCSIZEOF_STRUCT(OPENFILENAME, lpTemplateName);
    ofn.hwndOwner = hwndOwner;
    ofn.hInstance = hInstance;
    ofn.lpstrTitle = pwszTitle;
    ofn.lpstrFilter = pwszFilter;
    ofn.lpstrDefExt = pwszDefExt;
    ofn.Flags = Flags;
    ofn.lpstrFile = wszFileName;  // for out
    ofn.nMaxFile = ARRAYSIZE(wszFileName);

    if (NULL != pwszDefaultFile)
    {
        // analysis of default directory and file
        dwFileAttr = GetFileAttributes(pwszDefaultFile);
        if (0xFFFFFFFF == dwFileAttr &&
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != (hr = myHLastError()) )
        {
            // error, ignore, pop up file dialog without defaults
            _PrintError(hr, "GetFileAttributes");
        }
        else
        {
            if (0xFFFFFFFF != dwFileAttr &&
                FILE_ATTRIBUTE_DIRECTORY & dwFileAttr)
            {
                // only pass a dircetory path
                ofn.lpstrInitialDir = pwszDefaultFile;
            }
            else
            {
                // full path
                pwszFilePortion = NULL; // init
                if (0 == GetFullPathName(
                             pwszDefaultFile,
                             ARRAYSIZE(wszPath),
                             wszPath,
                             &pwszFilePortion) )
                {
                    // error, ignore
                    hr = myHLastError();
                    _PrintError(hr, "GetFullPathName");
                }
                else
                {
                    if (NULL != pwszFilePortion)
                    {
                        wcscpy(wszFileName, pwszFilePortion);
                    }
                    *pwszFilePortion = L'\0'; // make init dir
                    ofn.lpstrInitialDir = wszPath;
                }
            }
                
        }
    }

    if (fOpen)
    {
        fGetFile = GetOpenFileName(&ofn);
    }
    else
    {
        fGetFile = GetSaveFileName(&ofn);
    }

    if (!fGetFile)
    {
        hr = CommDlgExtendedError();
        if (S_OK == hr)
        {
            // cancel would make Get?FileName return FALSE but no error
            goto done;
        }
        _JumpError(hr, error, "GetOpenFileName");
    }

    // ok get file name

    hr = myDupString(wszFileName, ppwszFile);
    _JumpIfError(hr, error, "myDupString");

done:
    hr = S_OK;
error:
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszExpandedTitle)
    {
        LocalFree(pwszExpandedTitle);
    }
    if (NULL != pwszFilter && pwszFilter != wszEmptyFilter)
    {
        LocalFree(pwszFilter);
    }
    if (NULL != pwszDefExt)
    {
        LocalFree(pwszDefExt);
    }
    return hr;
}

HRESULT
myGetOpenFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    TRUE,    // open file
                    iRCTitle,
                    NULL,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}

HRESULT
myGetSaveFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    FALSE,    // save file
                    iRCTitle,
                    NULL,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}

HRESULT
myGetOpenFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    TRUE,    // open file
                    iRCTitle,
                    pwszTitleInsert,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}

HRESULT
myGetSaveFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    FALSE,    // save file
                    iRCTitle,
                    pwszTitleInsert,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\crypt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crypt.cpp
//
// Contents:    Cert Server wrapper routines
//
// History:     17-Oct-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>

#include "csdisp.h"
#include "cscsp.h"
#include "csprop.h"
#include "csber.h"


HRESULT
myGenerateKeys(
    IN WCHAR const *pwszContainer,
    OPTIONAL IN WCHAR const *pwszProvName,
    IN BOOL fMachineKeySet,
    IN DWORD dwKeySpec,
    IN DWORD dwProvType,
    IN DWORD dwKeySize,
    OUT HCRYPTPROV *phProv)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;
    DWORD dwFlags = 0;

    *phProv = NULL;

    if (fMachineKeySet)
    {
	dwFlags |= CRYPT_MACHINE_KEYSET;
    }

    // see if the container already exists

    if (CryptAcquireContext(
			phProv,
			pwszContainer,
			pwszProvName,
			dwProvType,
			dwFlags))
    {
	if (NULL != *phProv)
	{
	    CryptReleaseContext(*phProv, 0);
	    *phProv = NULL;
	}

        // container exists -- remove old keys and generate new ones.

        if (!CryptAcquireContext(
			    phProv,
			    pwszContainer,
			    pwszProvName,
			    dwProvType,
			    CRYPT_DELETEKEYSET | dwFlags))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptAcquireContextEx");
        }
    }

    // create new container

    if (!CryptAcquireContext(
                        phProv,
                        pwszContainer,
			pwszProvName,
                        dwProvType,
                        CRYPT_NEWKEYSET | dwFlags)) // force new container
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContextEx");
    }

    // create keys

    if (!CryptGenKey(*phProv, dwKeySpec, dwKeySize << 16, &hKey))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenKey");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return(hr);
}


HRESULT
myCryptExportPrivateKey(
    IN HCRYPTKEY hKey,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey)
{
    HRESULT hr;
    BYTE *pbKey = NULL;

    *ppbKey = NULL;

    // export the key set to a CAPI blob

    if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, pcbKey))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "CryptExportKey", NTE_BAD_KEY_STATE);
    }

    pbKey = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbKey);
    if (NULL == pbKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, pbKey, pcbKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptExportKey");
    }

    *ppbKey = pbKey;
    pbKey = NULL;
    hr = S_OK;

error:
    if (NULL != pbKey)
    {
	LocalFree(pbKey);
    }
    return(hr);
}


HRESULT
myVerifyPublicKey(
    IN OPTIONAL CERT_CONTEXT const *pCert,
    IN BOOL fV1Cert,
    IN OPTIONAL CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OPTIONAL OUT BOOL *pfMatchingKey)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    DWORD cb;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfoExported = NULL;

    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = FALSE;
    }
    if (NULL == pCert ||
	!CryptAcquireCertificatePrivateKey(
				    pCert,
				    0,		// dwFlags
				    NULL,	// pvReserved
				    &hProv,
				    &dwKeySpec,
				    NULL))	// pfCallerFreeProv
    {
        if (NULL != pKeyProvInfo)
        {
            // ok, try passed kpi

            if (!myCertSrvCryptAcquireContext(
		&hProv,
		pKeyProvInfo->pwszContainerName,
		pKeyProvInfo->pwszProvName,
		pKeyProvInfo->dwProvType,
		~CRYPT_MACHINE_KEYSET & pKeyProvInfo->dwFlags,
		(CRYPT_MACHINE_KEYSET & pKeyProvInfo->dwFlags)? TRUE : FALSE))
	    {
                hr = myHLastError();
                _JumpErrorStr(
			hr,
			error,
			"myCertSrvCryptAcquireContextEx",
			pKeyProvInfo->pwszContainerName);
            }
            dwKeySpec = pKeyProvInfo->dwKeySpec;
        }
        else if (NULL != pCert)
	{
            hr = myHLastError();
            _JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
	}
	else
        {
	    hr = E_POINTER;
	    _JumpError(hr, error, "No cert & no KeyProvInfo");
        }
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				dwKeySpec,
				CERTLIB_USE_LOCALALLOC,
				&pPublicKeyInfoExported,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    if (NULL == pPublicKeyInfo)
    {
	if (NULL == pCert)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "No cert & no SubjectPublicKeyInfo");
	}
	pPublicKeyInfo = &pCert->pCertInfo->SubjectPublicKeyInfo;
    }
    if (!myCertComparePublicKeyInfo(
		    X509_ASN_ENCODING,
		    fV1Cert,
		    pPublicKeyInfoExported,
		    pPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "myCertComparePublicKeyInfo");
    }
    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != pPublicKeyInfoExported)
    {
	LocalFree(pPublicKeyInfoExported);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


DWORD
GetLengthIndex(
    IN BYTE bBERTag,
    IN DWORD iStart,
    IN BYTE const *pb,
    IN DWORD cb)
{
    DWORD Index = MAXDWORD;

    pb += iStart;
    if (iStart + 4 < cb && bBERTag == pb[0])
    {
	// make sure there's room to increment the length in place.

	if (0x7f > pb[1])
	{
	    Index = iStart + 1;
	}
	else if (0x81 == pb[1] && 0xff > pb[2])
	{
	    Index = iStart + 2;
	}
    }
    return(Index);
}


// by design, (my)CertComparePublicKeyInfo doesn't set last error!

BOOL
myCertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN BOOL fV1Cert,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKey1,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKey2)
{
    BOOL fMatch = FALSE;
    BYTE *pbKeyNew = NULL;
    CERT_PUBLIC_KEY_INFO PublicKey;
    
    if (CertComparePublicKeyInfo(
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKey1),
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKey2)))
    {
	fMatch = TRUE;
	goto error;
    }

    // If this is a V1 X509 cert with the sign bit set in the first public key
    // byte -- without a leading zero pad byte, and there's a wasted byte at
    // the end of the public key, insert the zero byte and bump up the lengths.

    PublicKey = *pPublicKey2;
    if (fV1Cert && BER_SEQUENCE == PublicKey.PublicKey.pbData[0])
    {
	DWORD iLenSequence;
	DWORD iLenModulus;
	BYTE *pbKey = PublicKey.PublicKey.pbData;
	DWORD cbKey = PublicKey.PublicKey.cbData;

	iLenSequence = GetLengthIndex(BER_SEQUENCE, 0, pbKey, cbKey);
	if (MAXDWORD == iLenSequence)
	{
	    goto error;
	}
	iLenModulus = GetLengthIndex(
				BER_INTEGER,
				iLenSequence + 1,
				pbKey,
				cbKey);
	if (MAXDWORD == iLenSequence)
	{
	    goto error;
	}
	if (0x80 & pbKey[iLenModulus + 1] &&
	    (DWORD) (iLenSequence + 1 + pbKey[iLenSequence]) < cbKey)
	{
	    pbKeyNew = (BYTE *) LocalAlloc(LMEM_FIXED, cbKey);
	    if (NULL == pbKeyNew)
	    {
		_JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
	    }
	    CopyMemory(pbKeyNew, pbKey, iLenModulus + 1);
	    pbKeyNew[iLenSequence]++;
	    pbKeyNew[iLenModulus]++;
	    pbKeyNew[iLenModulus + 1] = 0;
	    CopyMemory(
		    &pbKeyNew[iLenModulus + 2],
		    &pbKey[iLenModulus + 1],
		    cbKey - (iLenModulus + 2));

	    PublicKey.PublicKey.pbData = pbKeyNew;
	    if (CertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKey1),
			    &PublicKey))
	    {
		fMatch = TRUE;
	    }
	}
    }

error:
    if (NULL != pbKeyNew)
    {
	LocalFree(pbKeyNew);
    }
    return(fMatch);
}


BOOL
myCryptSignMessage(
    IN CRYPT_SIGN_MESSAGE_PARA const *pcsmp,
    IN BYTE const *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSignedBlob,
    OUT DWORD *pcbSignedBlob)
{
    BOOL b;

    *ppbSignedBlob = NULL;
    *pcbSignedBlob = 0;
    while (TRUE)
    {
	b = CryptSignMessage(
			const_cast<CRYPT_SIGN_MESSAGE_PARA *>(pcsmp),
			TRUE,			// fDetachedSignature
			1,			// cToBeSigned
			&pbToBeSigned,		// rgpbToBeSigned
			&cbToBeSigned,		// rgcbToBeSigned
			*ppbSignedBlob,
			pcbSignedBlob);
	if (b && 0 == *pcbSignedBlob)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppbSignedBlob)
	    {
		myFree(*ppbSignedBlob, allocType);
		*ppbSignedBlob = NULL;
	    }
	    break;
	}
	if (NULL != *ppbSignedBlob)
	{
	    break;
	}
	*ppbSignedBlob = (BYTE *) myAlloc(*pcbSignedBlob, allocType);
	if (NULL == *ppbSignedBlob)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}


BOOL
myEncodeCert(
    IN DWORD dwEncodingType,
    IN CERT_SIGNED_CONTENT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_CERT,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeName(
    IN DWORD dwEncodingType,
    IN CERT_NAME_INFO const *pInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_UNICODE_NAME,
		    pInfo,
		    dwFlags,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeKeyAttributes(
    IN DWORD dwEncodingType,
    IN CERT_KEY_ATTRIBUTES_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_KEY_ATTRIBUTES,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeKeyUsage(
    IN DWORD dwEncodingType,
    IN CRYPT_BIT_BLOB const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_KEY_USAGE,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN CERT_AUTHORITY_KEY_ID2_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_AUTHORITY_KEY_ID2,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeToBeSigned(
    DWORD dwEncodingType,
    CERT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_CERT_TO_BE_SIGNED,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}

BOOL
myDecodeName(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_NAME_INFO **ppNameInfo,
    OUT DWORD *pcbNameInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppNameInfo,
		    pcbNameInfo));
}


BOOL
myDecodeKeyAuthority(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID_INFO const **ppInfo,
    OUT DWORD *pcbInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    X509_AUTHORITY_KEY_ID,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


BOOL
myDecodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID2_INFO const **ppInfo,
    OUT DWORD *pcbInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    X509_AUTHORITY_KEY_ID2,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


BOOL
myDecodeExtensions(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_EXTENSIONS **ppInfo,
    OUT DWORD *pcbInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    X509_NAME,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


BOOL
myDecodeKeyGenRequest(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_KEYGEN_REQUEST_INFO **ppKeyGenRequest,
    OUT DWORD *pcbKeyGenRequest)
{
    return(myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_KEYGEN_REQUEST_TO_BE_SIGNED,
		    pbRequest,
		    cbRequest,
		    allocType,
		    (VOID **) ppKeyGenRequest,
		    pcbKeyGenRequest));
}


HRESULT
myDecodeCSPProviderAttribute(
    IN BYTE const *pbCSPEncoded,
    IN DWORD cbCSPEncoded,
    OUT CRYPT_CSP_PROVIDER **ppccp)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pCSPProviderSeq = NULL;
    CERT_NAME_VALUE *pCSPProviderName = NULL;
    DWORD cb;
    CRYPT_CSP_PROVIDER *pccp;
    DWORD dwKeySpec;
    CERT_NAME_VALUE *pName = NULL;
    CRYPT_BIT_BLOB *pBlob = NULL;
    BYTE *pb;

    *ppccp = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    pbCSPEncoded,
		    cbCSPEncoded,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pCSPProviderSeq,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (3 > pCSPProviderSeq->cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Sequence count < 3");
    }

    dwKeySpec = 0;
    if (NULL != pCSPProviderSeq->rgValue[0].pbData &&
	0 != pCSPProviderSeq->rgValue[0].cbData)
    {
	cb = sizeof(dwKeySpec);
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pCSPProviderSeq->rgValue[0].pbData,
			pCSPProviderSeq->rgValue[0].cbData,
			0,
			&dwKeySpec,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptDecodeObject");
	}
    }
    if (NULL != pCSPProviderSeq->rgValue[1].pbData &&
	0 != pCSPProviderSeq->rgValue[1].cbData)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pCSPProviderSeq->rgValue[1].pbData,
			pCSPProviderSeq->rgValue[1].cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pName,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
    }
    if (NULL != pCSPProviderSeq->rgValue[2].pbData &&
	0 != pCSPProviderSeq->rgValue[2].cbData)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_BITS,
			pCSPProviderSeq->rgValue[2].pbData,
			pCSPProviderSeq->rgValue[2].cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pBlob,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
    }
    cb = sizeof(*pccp);
    if (NULL != pName && NULL != pName->Value.pbData)
    {
	cb += POINTERROUND((wcslen((WCHAR const *) pName->Value.pbData) + 1) *
							    sizeof(WCHAR));
    }
    if (NULL != pBlob && NULL != pBlob->pbData)
    {
	cb += POINTERROUND(pBlob->cbData);
    }
    pccp = (CRYPT_CSP_PROVIDER *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);
    if (NULL == pccp)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppccp = pccp;
    pb = (BYTE *) (pccp + 1);
    pccp->dwKeySpec = dwKeySpec;
    if (NULL != pName->Value.pbData)
    {
	pccp->pwszProviderName = (WCHAR *) pb;
	wcscpy(pccp->pwszProviderName, (WCHAR const *) pName->Value.pbData);
	pb += POINTERROUND((wcslen((WCHAR const *) pName->Value.pbData) + 1) *
							    sizeof(WCHAR));
    }
    if (NULL != pBlob && NULL != pBlob->pbData)
    {
	pccp->Signature.pbData = pb;
	pccp->Signature.cbData = pBlob->cbData;
	pccp->Signature.cUnusedBits = pBlob->cUnusedBits;
	CopyMemory(pccp->Signature.pbData, pBlob->pbData, pBlob->cbData);
    }
    hr = S_OK;

error:
    if (NULL != pCSPProviderSeq)
    {
	LocalFree(pCSPProviderSeq);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}


BOOL
myCertGetCertificateContextProperty(
    IN CERT_CONTEXT const *pCertContext,
    IN DWORD dwPropId,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData)
{
    BOOL b;

    *ppvData = NULL;
    *pcbData = 0;
    while (TRUE)
    {
	b = CertGetCertificateContextProperty(
					 pCertContext,
					 dwPropId,
					 *ppvData,
					 pcbData);
	if (b && 0 == *pcbData)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppvData)
	    {
		myFree(*ppvData, allocType);
		*ppvData = NULL;
	    }
	    break;
	}
	if (NULL != *ppvData)
	{
	    break;
	}
	*ppvData = (VOID *) myAlloc(*pcbData, allocType);
	if (NULL == *ppvData)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}


HRESULT
myCertGetKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    OUT CRYPT_KEY_PROV_INFO **ppkpi)
{
    HRESULT hr;
    DWORD cb;

    *ppkpi = NULL;

    if (!CertGetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					NULL,
					&cb))
    {
	hr = myHLastError();
	_JumpError2(
		hr,
		error,
		"CertGetCertificateContextProperty",
		CRYPT_E_NOT_FOUND);
    }

    *ppkpi = (CRYPT_KEY_PROV_INFO *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppkpi)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CertGetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					*ppkpi,
					&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCryptExportKey(
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hKeyExp,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey)
{
    HRESULT hr;
    
    if (!CryptExportKey(hKey, hKeyExp, dwBlobType, dwFlags, NULL, pcbKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptExportKey");
    }

    *ppbKey = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbKey);
    if (NULL == *ppbKey)
    { 
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportKey(hKey, hKeyExp, dwBlobType, dwFlags, *ppbKey, pcbKey))
    {
	hr = myHLastError();
	LocalFree(*ppbKey);
	*ppbKey = NULL;
	_JumpError(hr, error, "CryptExportKey");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCryptEncrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted)
{
    HRESULT hr;
    BYTE *pbEncrypted = NULL;
    DWORD cbEncrypted;
    DWORD cbAlloc;
    BOOL fRetried = FALSE;

    cbAlloc = cbIn + 64;	// may be enough to prevent overflow
    while (TRUE)
    {
	cbEncrypted = cbIn;
	pbEncrypted = (BYTE *) LocalAlloc(LMEM_FIXED, cbAlloc);
	if (NULL == pbEncrypted)
	{
	   hr = E_OUTOFMEMORY;
	   _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pbEncrypted, pbIn, cbIn);

	if (!CryptEncrypt(
		    hKey,
		    NULL,		// hHash
		    TRUE,		// Final
		    0,			// dwFlags
		    pbEncrypted,	// pbData
		    &cbEncrypted,	// pdwDataLen
		    cbAlloc))		// dwBufLen
	{
	    hr = myHLastError();
	    if (!fRetried && HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
	    {
		LocalFree(pbEncrypted);
		pbEncrypted = NULL;
		DBGPRINT((
		    DBG_SS_CERTLIB,
		    "CryptEncrypt(MORE DATA): %u -> %u\n",
		    cbAlloc,
		    cbEncrypted));
		cbAlloc = cbEncrypted;
		fRetried = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "CryptEncrypt");
	}
	break;
    }
    *ppbEncrypted = pbEncrypted;
    *pcbEncrypted = cbEncrypted;
    pbEncrypted = NULL;
    hr = S_OK;

error:
    if (NULL != pbEncrypted)
    {
	LocalFree(pbEncrypted);
    }
    return(hr);
}


HRESULT
myCryptDecrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;

    // init
    *ppbDecrypted = NULL;
    *pcbDecrypted = 0;

    cbDecrypted = cbIn;
    pbDecrypted = (BYTE *) LocalAlloc(LMEM_FIXED, cbIn);
    if (NULL == pbDecrypted)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pbDecrypted, pbIn, cbIn);

    if (!CryptDecrypt(
		hKey,
		NULL,			// hHash
		TRUE,			// Final
		0,			// dwFlags
		pbDecrypted,		// pbData
		&cbDecrypted))		// pdwDataLen
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecrypt");
    }
    *ppbDecrypted = pbDecrypted;
    *pcbDecrypted = cbDecrypted;
    pbDecrypted = NULL;
    hr = S_OK;

error:
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    return(hr);
}


HRESULT
myCryptEncryptMessage(
    IN ALG_ID algId,
    IN DWORD cCertRecipient,
    IN CERT_CONTEXT const **rgCertRecipient,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OPTIONAL HCRYPTPROV hCryptProv,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted)
{
    HRESULT hr;
    CRYPT_ENCRYPT_MESSAGE_PARA cemp;
    CRYPT_OID_INFO const *pOidInfo;
    CERT_CONTEXT const *pcc = NULL;

    // Convert to an Object Id

    pOidInfo = CryptFindOIDInfo(
			CRYPT_OID_INFO_ALGID_KEY,
			&algId,
			CRYPT_ENCRYPT_ALG_OID_GROUP_ID);
    if (NULL == pOidInfo)
    {
        // function is not doc'd to set GetLastError()

        hr = CRYPT_E_NOT_FOUND;
	DBGPRINT((DBG_SS_ERROR, "algId = %x\n", algId));
        _JumpError(hr, error, "CryptFindOIDInfo");
    }

    // Encrypt the data with the public key

    ZeroMemory(&cemp, sizeof(cemp));
    cemp.cbSize = sizeof(cemp);
    cemp.dwMsgEncodingType = PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING;
    cemp.ContentEncryptionAlgorithm.pszObjId = const_cast<char *>(pOidInfo->pszOID);
    cemp.hCryptProv = hCryptProv;

    *pcbEncrypted = 0;
    while (TRUE)
    {
	if (!CryptEncryptMessage(
			    &cemp,
			    cCertRecipient,	// cRecipientCert
			    rgCertRecipient,	// rgpRecipientCert IN
			    pbIn,		// pbToBeEncrypted
			    cbIn,		// cbToBeEncrypted
			    *ppbEncrypted,	// pbEncryptedBlob
			    pcbEncrypted))	// pcbEncryptedBlob
	{
	    hr = myHLastError();
	    if (NULL != *ppbEncrypted)
	    {
		LocalFree(*ppbEncrypted);
		*ppbEncrypted = NULL;
	    }
	    _JumpError(hr, error, "CryptEncryptMessage");
	}
	if (NULL != *ppbEncrypted)
	{
	    break;
	}
	*ppbEncrypted = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncrypted);
	if (NULL == *ppbEncrypted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myCryptDecryptMessage(
    IN HCERTSTORE hStore,
    IN BYTE const *pbEncrypted,
    IN DWORD cbEncrypted,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    CRYPT_DECRYPT_MESSAGE_PARA cdmp;

    ZeroMemory(&cdmp, sizeof(cdmp));
    cdmp.cbSize = sizeof(cdmp);
    cdmp.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    cdmp.cCertStore = 1;
    cdmp.rghCertStore = &hStore;

    *ppbDecrypted = NULL;
    *pcbDecrypted = 0;
    while (TRUE)
    {
	if (!CryptDecryptMessage(
			    &cdmp,
			    pbEncrypted,
			    cbEncrypted,
			    *ppbDecrypted,
			    pcbDecrypted,
			    NULL))	// ppXchgCert
	{
	    hr = myHLastError();
	    if (NULL != *ppbDecrypted)
	    {
		myFree(*ppbDecrypted, allocType);
		*ppbDecrypted = NULL;
	    }
	    _JumpError(hr, error, "CryptDecryptMessage");
	}
	if (NULL != *ppbDecrypted)
	{
	    break;
	}
	*ppbDecrypted = (BYTE *) myAlloc(*pcbDecrypted, allocType);
	if (NULL == *ppbDecrypted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetInnerPKCS10(
    IN HCRYPTMSG hMsg,
    IN char const *pszInnerContentObjId,
    OUT CERT_REQUEST_INFO **ppRequest)
{
    HRESULT hr;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    CMC_DATA_INFO *pcmcData = NULL;
    DWORD cbcmcData;
    CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;
    DWORD cbRequest;

    *ppRequest = NULL;
#define szOID_CT_PKI_DATA_OLDRFC "1.3.6.1.5.5.7.5.2" // BUGBUG: temporary!!!

    if (0 != strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA) &&
	0 != strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA_OLDRFC))
    {
	hr = CRYPT_E_INVALID_MSG_TYPE;
	_JumpError(hr, error, "Not a CMC request");
    }

    // Get the request content, then search for the PKCS10's public key.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
                    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbContent,
		    &cbContent);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    pbContent,
		    cbContent,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcData,
		    &cbcmcData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (1 != pcmcData->cTaggedRequest ||
	CMC_TAGGED_CERT_REQUEST_CHOICE !=
	    pcmcData->rgTaggedRequest[0].dwTaggedRequestChoice)
    {
	hr = CRYPT_E_INVALID_MSG_TYPE;
	_JumpError(hr, error, "Must be 1 PKCS10");
    }
    pTaggedCertRequest = pcmcData->rgTaggedRequest[0].pTaggedCertRequest;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pTaggedCertRequest->SignedCertRequest.pbData,
		    pTaggedCertRequest->SignedCertRequest.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppRequest,
		    &cbRequest))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pbContent)
    {
	LocalFree(pbContent);
    }
    if (NULL != pcmcData)
    {
	LocalFree(pcmcData);
    }
    return(hr);
}


HRESULT
myPKCSEncodeString(
    IN WCHAR const *pwsz,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE cnv;

    // encode the string as an IA5 string

    cnv.dwValueType = CERT_RDN_IA5_STRING;
    cnv.Value.pbData = (BYTE *) pwsz;
    cnv.Value.cbData = 0;	// Use L'\0' termination for the length

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_NAME_VALUE,
		    &cnv,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
error:
    return(hr);
}


HRESULT
myPKCSDecodeString(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE *pcnv = NULL;
    DWORD cbOut;

    *ppwszOut = NULL;

    // decode the string from an IA5 string

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_NAME_VALUE,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcnv,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (CERT_RDN_IA5_STRING != pcnv->dwValueType)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Not an IA5 string");
    }
    cbOut = (wcslen((WCHAR const *) pcnv->Value.pbData) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cbOut);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pcnv->Value.pbData, cbOut);

error:
    if (NULL != pcnv)
    {
	LocalFree(pcnv);
    }
    return(hr);
}


HRESULT
myPKCSEncodeLong(
    IN LONG Value,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;

    // encode the long value

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &Value,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
error:
    return(hr);
}


HRESULT
myPKCSDecodeLong(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT LONG **ppValue)
{
    HRESULT hr = S_OK;
    DWORD cbOut;

    // encode the long value

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppValue,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    CSASSERT(sizeof(**ppValue) == cbOut);
error:
    return(hr);
}


HRESULT
myPKCSEncodeDate(
    IN FILETIME const *pft,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;

    // encode the time value

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CHOICE_OF_TIME,
		    pft,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
error:
    return(hr);
}


HRESULT
myPKCSDecodeDate(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT FILETIME **ppftOut)
{
    HRESULT hr = S_OK;
    DWORD cbOut;

    // encode the time value

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CHOICE_OF_TIME,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppftOut,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    CSASSERT(sizeof(**ppftOut) == cbOut);
error:
    return(hr);
}


HRESULT
myEncodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = E_INVALIDARG;

    // everyone assumes pbIn != NULL

    if (NULL == pbIn || 0 == cbIn)
    {
	_JumpError(hr, error, "NULL param");
    }

    switch (PROPTYPE_MASK & Flags)
    {
	case PROPTYPE_STRING:
	    if (0 == (PROPMARSHAL_LOCALSTRING & Flags) &&
		sizeof(WCHAR) <= cbIn)
	    {
		cbIn -= sizeof(WCHAR);
	    }
	    if (wcslen((WCHAR const *) pbIn) * sizeof(WCHAR) != cbIn)
	    {
		_JumpError(hr, error, "bad string len");
	    }
	    hr = myPKCSEncodeString((WCHAR const *) pbIn, ppbOut, pcbOut);
	    _JumpIfError(hr, error, "myPKCSEncodeString");

	    break;

	case PROPTYPE_LONG:
	    CSASSERT(sizeof(DWORD) == cbIn);
	    hr = myPKCSEncodeLong(*(DWORD const *) pbIn, ppbOut, pcbOut);
	    _JumpIfError(hr, error, "myPKCSEncodeLong");

	    break;

	case PROPTYPE_DATE:
	    CSASSERT(sizeof(FILETIME) == cbIn);
	    hr = myPKCSEncodeDate((FILETIME const *) pbIn, ppbOut, pcbOut);
	    _JumpIfError(hr, error, "myPKCSEncodeDate");

	    break;

	default:
	    _JumpError(hr, error, "variant type/value");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myDecodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;

    switch (PROPTYPE_MASK & Flags)
    {
	case PROPTYPE_STRING:
	    hr = myPKCSDecodeString(pbIn, cbIn, (WCHAR **) ppbOut);
	    _JumpIfError(hr, error, "myPKCSDecodeString");

	    *pcbOut = wcslen((WCHAR const *) *ppbOut) * sizeof(WCHAR);
	    break;

	case PROPTYPE_LONG:
	    hr = myPKCSDecodeLong(pbIn, cbIn, (LONG **) ppbOut);
	    _JumpIfError(hr, error, "myPKCSDecodeLong");

	    *pcbOut = sizeof(LONG);
	    break;

	case PROPTYPE_DATE:
	    hr = myPKCSDecodeDate(pbIn, cbIn, (FILETIME **) ppbOut);
	    _JumpIfError(hr, error, "myPKCSDecodeDate");

	    *pcbOut = sizeof(FILETIME);
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Flags: Invalid type");
    }

error:
    return(hr);
}


// szOID_ENROLLMENT_NAME_VALUE_PAIR

BOOL
myDecodeNameValuePair(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CRYPT_ENROLLMENT_NAME_VALUE_PAIR **ppInfo,
    OUT DWORD *pcbInfo)
{

    return(myDecodeObject(
		    X509_ASN_ENCODING,
		    szOID_ENROLLMENT_NAME_VALUE_PAIR,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


//+-------------------------------------------------------------------------
// myVerifyObjIdA - verify the passed pszObjId is valid as per X.208
//
// Encode and Decode the Object Id and make sure it survives the round trip.
// The first number must be 0, 1 or 2.
// Enforce all characters are digits and dots.
// Enforce that no dot starts or ends the Object Id, and disallow double dots.
// Enforce there is at least one dot separator.
// If the first number is 0 or 1, the second number must be between 0 & 39.
// If the first number is 2, the second number can be any value.
//--------------------------------------------------------------------------

HRESULT
myVerifyObjIdA(
    IN CHAR const *pszObjId)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_ATTRIBUTE ainfo;
    CRYPT_ATTRIBUTE *painfo = NULL;
    DWORD cbainfo;
    char const *psz;
    int i;
    BOOL fNoisy = FALSE;

    hr = E_INVALIDARG;
    for (psz = pszObjId; '\0' != *psz; psz++)
    {
	// must be a digit or a dot separator
	
	if (!isdigit(*psz))
	{
	    if ('.' != *psz)
	    {
		_JumpError2(hr, error, "bad ObjId: bad char", hr);
	    }

	    // can't have dot at start, double dots or dot at end

	    if (psz == pszObjId || '.' == psz[1] || '\0' == psz[1])
	    {
		_JumpError2(hr, error, "bad ObjId: dot location", hr);
	    }
	}
    }
    psz = strchr(pszObjId, '.');
    if (NULL == psz)
    {
	_JumpError2(hr, error, "bad ObjId: must have at least one dot", hr);
    }
    i = atoi(pszObjId);
    switch (i)
    {
	case 0:
	case 1:
	    i = atoi(++psz);
	    if (0 > i || 39 < i)
	    {
		_JumpError(hr, error, "bad ObjId: 0. or 1. must be followed by 0..39");
	    }
	    break;

	case 2:
	    break;

	default:
	    fNoisy = TRUE;
	    _JumpError(hr, error, "bad ObjId: must start with 0, 1 or 2");
    }

    fNoisy = TRUE;
    ainfo.pszObjId = const_cast<char *>(pszObjId);
    ainfo.cValue = 0;
    ainfo.rgValue = NULL;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    &ainfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    pbEncoded,
		    cbEncoded,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &painfo,
		    &cbainfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (0 != strcmp(pszObjId, painfo->pszObjId))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad ObjId: decode mismatch");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	DBGPRINT((
	    fNoisy? DBG_SS_CERTLIB : DBG_SS_CERTLIBI,
	    "myVerifyObjIdA(%hs): %x\n",
	    pszObjId,
	    hr));
    }
    if (NULL != pbEncoded)
    {
    	LocalFree(pbEncoded);
    }
    if (NULL != painfo)
    {
    	LocalFree(painfo);
    }
    return(hr);
}


HRESULT
myVerifyObjId(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
    CHAR *pszObjId = NULL;

    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    hr = myVerifyObjIdA(pszObjId);
    _JumpIfErrorStr2(hr, error, "myVerifyObjIdA", pwszObjId, E_INVALIDARG);

error:
    if (NULL != pszObjId)
    {
    	LocalFree(pszObjId);
    }
    return(hr);
}


// The returned pszObjId is a constant that must not be freed.  CryptFindOIDInfo
// has a static internal database that is valid until crypt32.dll is unloaded.

#define GON_GROUP	0x00000001
#define GON_GENERIC	0x00000002

typedef struct _OIDNAME
{
    char const *pszObjId;
    WCHAR const *pwszDisplayName;
} OIDNAME;

#if DBG
#define wszCERTLIB	L"(certlib)"
#else
#define wszCERTLIB	L""
#endif

OIDNAME s_aOIDName[] = {
    { szOID_CT_PKI_DATA,		L"CMC Data" wszCERTLIB, },
    { szOID_CT_PKI_RESPONSE,		L"CMC Response" wszCERTLIB, },
    { szOID_CMC,			L"Unsigned CMC Request" wszCERTLIB, },
    { szOID_CMC_TRANSACTION_ID,		L"Transaction Id" wszCERTLIB, },
    { szOID_CMC_SENDER_NONCE,		L"Sender Nonce" wszCERTLIB, },
    { szOID_CMC_RECIPIENT_NONCE,	L"Recipient Nonce" wszCERTLIB, },
    { szOID_CMC_REG_INFO,		L"Reg Info" wszCERTLIB, },
    { szOID_CMC_GET_CERT,		L"Get Certificate" wszCERTLIB, },
    { szOID_CMC_GET_CRL,		L"Get CRL" wszCERTLIB, },
    { szOID_CMC_REVOKE_REQUEST,		L"Revoke Request" wszCERTLIB, },
    { szOID_CMC_QUERY_PENDING,		L"Query Pending" wszCERTLIB, },
    { szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE, L"Confirm Certificate Acceptance" wszCERTLIB, },
    { szOID_CMC_STATUS_INFO,		L"Unsigned CMC Response" wszCERTLIB, },
    { szOID_CMC_ADD_EXTENSIONS,		L"CMC Extensions" wszCERTLIB, },
    { szOID_CMC_ADD_ATTRIBUTES,		L"CMC Attributes" wszCERTLIB, },
    { szOID_VERISIGN_ONSITE_JURISDICTION_HASH, L"Jurisdiction Hash" wszCERTLIB, },
    { szOID_PKCS_7_DATA,		L"PKCS 7 Data" wszCERTLIB, },
    { szOID_ARCHIVED_KEY_ATTR,		L"Archived Key" wszCERTLIB, },
    { szOID_CTL,			L"Certifcate Trust List" wszCERTLIB, },
    { szOID_ARCHIVED_KEY_CERT_HASH,	L"Archived Key Certificate Hash" wszCERTLIB, },
    { szOID_ROOT_LIST_SIGNER,		L"Root List Signer" wszCERTLIB, },
    { szOID_PRIVATEKEY_USAGE_PERIOD,	L"Private Key Usage Period" wszCERTLIB, },
    { szOID_REQUEST_CLIENT_INFO,	L"Client Information" wszCERTLIB, },
};

WCHAR const *
myGetOIDNameA(
    IN char const *pszObjId)
{
    CRYPT_OID_INFO const *pInfo = NULL;
    WCHAR const *pwszName = L"";
    DWORD Flags = GON_GROUP | GON_GENERIC;

    if ('+' == *pszObjId)
    {
	Flags = GON_GROUP;	// Group lookup only
	pszObjId++;
    }
    else
    if ('-' == *pszObjId)
    {
	Flags = GON_GENERIC;	// Generic lookup only
	pszObjId++;
    }

    // First try looking up the ObjectId as an Extension or Attribute, because
    // we get a better Display Name, especially for Subject RDNs: CN, L, etc.
    // If that fails, look it up withoput restricting the group.

    if (GON_GROUP & Flags)
    {
	pInfo = CryptFindOIDInfo(
			    CRYPT_OID_INFO_OID_KEY,
			    (VOID *) pszObjId,
			    CRYPT_EXT_OR_ATTR_OID_GROUP_ID);
    }
    if ((GON_GENERIC & Flags) &&
	(NULL == pInfo ||
	 NULL == pInfo->pwszName ||
	 L'\0' == pInfo->pwszName[0]))
    {
	pInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, (VOID *) pszObjId, 0);
    }
    if (NULL != pInfo && NULL != pInfo->pwszName && L'\0' != pInfo->pwszName[0])
    {
	pwszName = pInfo->pwszName;
    }
    else
    {
	OIDNAME const *pOIDName;

	for (pOIDName = s_aOIDName;
	     pOIDName < &s_aOIDName[ARRAYSIZE(s_aOIDName)];
	     pOIDName++)
	{
	    if (0 == strcmp(pOIDName->pszObjId, pszObjId))
	    {
		pwszName = pOIDName->pwszDisplayName;
		break;
	    }
	}
    }
    return(pwszName);
}


WCHAR const *
myGetOIDName(
    IN WCHAR const *pwszObjId)
{
    char *pszObjId = NULL;
    WCHAR const *pwszName = L"";

    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	_JumpError(E_OUTOFMEMORY, error, "ConvertWszToSz");
    }
    pwszName = myGetOIDNameA(pszObjId);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(pwszName);
}


typedef struct _DUMPFLAGS
{
    DWORD Mask;
    DWORD Value;
    WCHAR const *pwszDescription;
} DUMPFLAGS;


#define _DFBIT(def)		{ (def), (def), L#def }
#define _DFBIT2(mask, def)	{ (mask), (def), L#def }


DUMPFLAGS g_adfErrorStatus[] =
{
    _DFBIT(CERT_TRUST_IS_NOT_TIME_VALID),
    _DFBIT(CERT_TRUST_IS_NOT_TIME_NESTED),
    _DFBIT(CERT_TRUST_IS_REVOKED),
    _DFBIT(CERT_TRUST_IS_NOT_SIGNATURE_VALID),
    _DFBIT(CERT_TRUST_IS_NOT_VALID_FOR_USAGE),
    _DFBIT(CERT_TRUST_IS_UNTRUSTED_ROOT),
    _DFBIT(CERT_TRUST_REVOCATION_STATUS_UNKNOWN),
    _DFBIT(CERT_TRUST_IS_CYCLIC),

    _DFBIT(CERT_TRUST_INVALID_EXTENSION),
    _DFBIT(CERT_TRUST_INVALID_POLICY_CONSTRAINTS),
    _DFBIT(CERT_TRUST_INVALID_BASIC_CONSTRAINTS),
    _DFBIT(CERT_TRUST_INVALID_NAME_CONSTRAINTS),
    _DFBIT(CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT),
    _DFBIT(CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT),
    _DFBIT(CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT),
    _DFBIT(CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT),

    _DFBIT(CERT_TRUST_IS_OFFLINE_REVOCATION),
    _DFBIT(CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY),

    _DFBIT(CERT_TRUST_IS_PARTIAL_CHAIN),
    _DFBIT(CERT_TRUST_CTL_IS_NOT_TIME_VALID),
    _DFBIT(CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID),
    _DFBIT(CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE),

    { 0, 0, NULL }
};

DUMPFLAGS g_adfInfoStatus[] =
{
    _DFBIT(CERT_TRUST_HAS_EXACT_MATCH_ISSUER),
    _DFBIT(CERT_TRUST_HAS_KEY_MATCH_ISSUER),
    _DFBIT(CERT_TRUST_HAS_NAME_MATCH_ISSUER),
    _DFBIT(CERT_TRUST_IS_SELF_SIGNED),

    _DFBIT(CERT_TRUST_HAS_PREFERRED_ISSUER),
    _DFBIT(CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY),
    _DFBIT(CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS),

    _DFBIT(CERT_TRUST_IS_COMPLEX_CHAIN),
    { 0, 0, NULL }
};


VOID
DumpFlags(
    IN DWORD Flags,
    IN WCHAR const *pwsz,
    IN DUMPFLAGS const *pdf)
{
    for ( ; NULL != pdf->pwszDescription; pdf++)
    {
	if ((Flags & pdf->Mask) == pdf->Value)
	{
	    CONSOLEPRINT2((
		    MAXDWORD,
		    "%ws = %ws\n",
		    pwsz,
		    pdf->pwszDescription));
	}
    }
}


VOID
DumpUsage(
    IN WCHAR const *pwsz,
    OPTIONAL IN CERT_ENHKEY_USAGE const *pUsage)
{
    DWORD i;

    if (NULL != pUsage)
    {
	for (i = 0; i < pUsage->cUsageIdentifier; i++)
	{
	    CONSOLEPRINT4((
		    MAXDWORD,
		    "%ws[%u] = %hs %ws\n",
		    pwsz,
		    i,
		    pUsage->rgpszUsageIdentifier[i],
		    myGetOIDNameA(pUsage->rgpszUsageIdentifier[i])));
	}
    }
}


HRESULT
WriteBlob(
    IN FILE *pf, 
    IN BYTE const *pb,
    IN DWORD cb,
    IN DWORD Flags)
{
    HRESULT hr;
    char *pszBase64 = NULL;

    hr = myCryptBinaryToStringA(
		    pb,
		    cb,
		    Flags | CRYPT_STRING_NOCR,
		    &pszBase64);
    _JumpIfError(hr, error, "myCryptBinaryToStringA");

    fputs(pszBase64, pf);
    fflush(pf);
    if (ferror(pf))
    {
	hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
	_JumpError(hr, error, "fputs");
    }
    hr = S_OK;

error:
    if (NULL != pszBase64)
    {
	LocalFree(pszBase64);
    }
    return(hr);
}


VOID
WriteChain(
    IN CERT_SIMPLE_CHAIN const *pChain,
    IN DWORD SaveIndex,
    IN DWORD ChainIndex)
{
    HRESULT hr;
    char szPath[MAX_PATH];
    DWORD i;
    FILE *pf = NULL;

    if (0 == GetEnvironmentVariableA("temp", szPath, ARRAYSIZE(szPath)))
    {
	strcpy(szPath, "\\");
    }
    i = strlen(szPath);
    if (0 == i || '\\' != szPath[i - 1])
    {
	szPath[i++] = '\\';
    }
    sprintf(&szPath[i], "Chain%d_%d.txt", SaveIndex, ChainIndex);
    pf = fopen(szPath, "w");
    if (NULL == pf)
    {
	hr = errno;
	_JumpError(hr, error, "fopen");
    }
    for (i = 0; i < pChain->cElement; i++)
    {
	CERT_CHAIN_ELEMENT const *pElement = pChain->rgpElement[i];
	CERT_REVOCATION_INFO *pRevocationInfo;

	if (0 < i)
	{
	    fputs("\n", pf);
	}
	fprintf(pf, "Certificate %d:\n", i);

	hr = WriteBlob(
		    pf, 
		    pElement->pCertContext->pbCertEncoded,
		    pElement->pCertContext->cbCertEncoded,
		    CRYPT_STRING_BASE64HEADER);
	_JumpIfError(hr, error, "WriteBlob");

	pRevocationInfo = pElement->pRevocationInfo;

	if (NULL != pRevocationInfo &&
	    CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		pRevocationInfo->cbSize &&
	    NULL != pRevocationInfo->pCrlInfo)
	{
	    CERT_REVOCATION_CRL_INFO *pCrlInfo;

	    pCrlInfo = pRevocationInfo->pCrlInfo;
	    if (NULL != pCrlInfo)
	    {
		if (NULL != pCrlInfo->pBaseCrlContext)
		{
		    fprintf(pf, "\nCRL %d:\n", i);
		    hr = WriteBlob(
				pf, 
				pCrlInfo->pBaseCrlContext->pbCrlEncoded,
				pCrlInfo->pBaseCrlContext->cbCrlEncoded,
				CRYPT_STRING_BASE64X509CRLHEADER);
		    _JumpIfError(hr, error, "WriteBlob");
		}
		if (NULL != pCrlInfo->pDeltaCrlContext)
		{
		    fprintf(pf, "\nDelta CRL %d:\n", i);
		    hr = WriteBlob(
				pf, 
				pCrlInfo->pDeltaCrlContext->pbCrlEncoded,
				pCrlInfo->pDeltaCrlContext->cbCrlEncoded,
				CRYPT_STRING_BASE64X509CRLHEADER);
		    _JumpIfError(hr, error, "WriteBlob");
		}
	    }
	}
    }

error:
    if (NULL != pf)
    {
	fclose(pf);
    }
}


VOID
DumpChain(
    IN HRESULT hrVerify,
    IN DWORD dwFlags,
    IN CERT_CONTEXT const *pCert,
    OPTIONAL IN WCHAR const *pwszMissingIssuer,
    IN CERT_CHAIN_CONTEXT const *pChainContext)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    static BOOL s_fEnvChecked = FALSE;
    static BOOL s_fDumpEnabled = FALSE;
    static DWORD s_SaveCount = 0;
    static DWORD s_SaveIndex;
    BOOL fDump;
    BOOL fSave;

    if (!s_fEnvChecked)
    {
	WCHAR wszBuf[20];

	if (0 != GetEnvironmentVariable(
				L"CertSrv_Chain",
				wszBuf,
				ARRAYSIZE(wszBuf)))
	{
	    s_fDumpEnabled = TRUE;
	    s_SaveCount = _wtoi(wszBuf);
	    s_SaveIndex = s_SaveCount;
	}
	s_fEnvChecked = TRUE;
    }
    fSave = 0 != s_SaveCount || (CA_VERIFY_FLAGS_SAVE_CHAIN & dwFlags);
    fDump = s_fDumpEnabled ||
		S_OK != hrVerify ||
		(CA_VERIFY_FLAGS_DUMP_CHAIN & dwFlags);
#if DBG_CERTSRV
    if (DbgIsSSActive(DBG_SS_CERTLIBI))
    {
	fDump = TRUE;
    }
#endif
    if (!fSave && !fDump)
    {
	return;
    }
    if (0 != s_SaveCount)
    {
	if (++s_SaveIndex >= s_SaveCount)
	{
	    s_SaveIndex = 0;
	}
    }
    if (fDump)
    {
	DBGPRINT((MAXDWORD, "-------- Chain Start --------\n"));
	DumpFlags(
		pChainContext->TrustStatus.dwInfoStatus,
		L"ChainContext.dwInfoStatus",
		g_adfInfoStatus);
	DumpFlags(
		pChainContext->TrustStatus.dwErrorStatus,
		L"ChainContext.dwErrorStatus",
		g_adfErrorStatus);
    }
    for (i = 0; i < pChainContext->cChain; i++)
    {
	if (fSave)
	{
	    WriteChain(pChainContext->rgpChain[i], s_SaveIndex, i);
	}
	if (fDump)
	{
	    DumpFlags(
		    pChainContext->rgpChain[i]->TrustStatus.dwInfoStatus,
		    L"SimpleChain.dwInfoStatus",
		    g_adfInfoStatus);
	    DumpFlags(
		    pChainContext->rgpChain[i]->TrustStatus.dwErrorStatus,
		    L"SimpleChain.dwErrorStatus",
		    g_adfErrorStatus);
	}
	for (j = 0; j < pChainContext->rgpChain[i]->cElement; j++)
	{
	    CERT_CHAIN_ELEMENT const *pElement;

	    pElement = pChainContext->rgpChain[i]->rgpElement[j];

	    if (fDump ||
		S_OK != hrVerify ||
		0 != pElement->TrustStatus.dwErrorStatus)
	    {
		WCHAR *pwsz;
		CERT_REVOCATION_INFO *pRevocationInfo;

		CONSOLEPRINT4((
		    MAXDWORD,
		    "CertContext[%u][%u]: dwInfoStatus=%x dwErrorStatus=%x\n",
		    i,
		    j,
		    pElement->TrustStatus.dwInfoStatus,
		    pElement->TrustStatus.dwErrorStatus));

		pwsz = NULL;
		hr = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pElement->pCertContext->pCertInfo->Issuer,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwsz);
		_PrintIfError(hr, "myCertNameToStr");
		if (NULL != pwsz)
		{
		    CONSOLEPRINT1((MAXDWORD, "  Issuer: %ws\n", pwsz));
		    LocalFree(pwsz);
		}

		pwsz = NULL;
		hr = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pElement->pCertContext->pCertInfo->Subject,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwsz);
		_PrintIfError(hr, "myCertNameToStr");
		if (NULL != pwsz)
		{
		    CONSOLEPRINT1((MAXDWORD, "  Subject: %ws\n", pwsz));
		    LocalFree(pwsz);
		}
		DumpFlags(
			pElement->TrustStatus.dwInfoStatus,
			L"  CertContext.dwInfoStatus",
			g_adfInfoStatus);
		DumpFlags(
			pElement->TrustStatus.dwErrorStatus,
			L"  CertContext.dwErrorStatus",
			g_adfErrorStatus);

		pRevocationInfo = pElement->pRevocationInfo;

		if (NULL != pRevocationInfo &&
		    CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
			pRevocationInfo->cbSize &&
		    NULL != pRevocationInfo->pCrlInfo)
		{
		    CERT_REVOCATION_CRL_INFO *pCrlInfo;

		    pCrlInfo = pRevocationInfo->pCrlInfo;
		    if (NULL != pCrlInfo)
		    {
			if (NULL != pCrlInfo->pBaseCrlContext)
			{
			    CONSOLEPRINT1((MAXDWORD, "  CRL %d:\n", i));
			}
			if (NULL != pCrlInfo->pDeltaCrlContext)
			{
			    CONSOLEPRINT1((MAXDWORD, "  Delta CRL %d:\n", i));
			}
		    }
		}

		if (FIELD_OFFSET(CERT_CHAIN_ELEMENT, pIssuanceUsage) <
		    pElement->cbSize)
		{
		    DumpUsage(L"  Issuance", pElement->pIssuanceUsage);
		}
		if (FIELD_OFFSET(CERT_CHAIN_ELEMENT, pApplicationUsage) <
		    pElement->cbSize)
		{
		    DumpUsage(L"  Application", pElement->pApplicationUsage);
		}
		if (FIELD_OFFSET(CERT_CHAIN_ELEMENT, pwszExtendedErrorInfo) <
		    pElement->cbSize &&
		    NULL != pElement->pwszExtendedErrorInfo)
		{
		    CONSOLEPRINT1((
			    MAXDWORD,
			    "  %ws",
			    pElement->pwszExtendedErrorInfo));
		}
	    }
	}
    }
    if (fDump)
    {
	if (S_OK != hrVerify)
	{
	    WCHAR *pwszCertSubject;
	    WCHAR const *pwszErr = myGetErrorMessageText(hrVerify, TRUE);

	    if (NULL != pwszMissingIssuer)
	    {
		CONSOLEPRINT1((
			MAXDWORD,
			"Missing Issuer: %ws\n",
			pwszMissingIssuer));
	    }
	    hr = myCertNameToStr(
			X509_ASN_ENCODING,
			&pCert->pCertInfo->Subject,
			CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			&pwszCertSubject);
	    _PrintIfError(hr, "myCertNameToStr");
	    if (S_OK == hr)
	    {
		CONSOLEPRINT1((MAXDWORD, "Subject: %ws\n", pwszCertSubject));
		LocalFree(pwszCertSubject);
	    }
	    if (NULL != pwszErr)
	    {
		CONSOLEPRINT1((MAXDWORD, "%ws\n", pwszErr));
		LocalFree(const_cast<WCHAR *>(pwszErr));
	    }
	}
	DBGPRINT((MAXDWORD, "-------- Chain End --------\n"));
    }
}


HRESULT
SavePolicies(
    OPTIONAL IN CERT_ENHKEY_USAGE const *pUsage,
    OUT WCHAR **ppwszzPolicies)
{
    HRESULT hr;
    DWORD i;
    DWORD cwc;
    char const *psz;
    WCHAR *pwsz;

    if (NULL != pUsage &&
	0 != pUsage->cUsageIdentifier &&
	NULL != pUsage->rgpszUsageIdentifier)
    {
	cwc = 1;
	for (i = 0; i < pUsage->cUsageIdentifier; i++)
	{
	    cwc += strlen(pUsage->rgpszUsageIdentifier[i]) + 1;
	}
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*ppwszzPolicies = pwsz;
	for (i = 0; i < pUsage->cUsageIdentifier; i++)
	{
	    psz = pUsage->rgpszUsageIdentifier[i];
	    while (*pwsz++ = *psz++)
	    	;
	}
	*pwsz++ = L'\0';
	CSASSERT(pwsz == &(*ppwszzPolicies)[cwc]);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myVerifyCertContextEx(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN FILETIME const *pft,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer,
    OPTIONAL OUT WCHAR **ppwszzIssuancePolicies,
    OPTIONAL OUT WCHAR **ppwszzApplicationPolicies)
{
    HRESULT hr;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_POLICY_PARA ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    LPCSTR pszChainPolicyFlags;
    WCHAR *pwszMissingIssuer = NULL;
    CERT_CHAIN_ELEMENT const *pElement;

    if (NULL != ppwszMissingIssuer)
    {
	*ppwszMissingIssuer = NULL;
    }
    if (NULL != ppwszzIssuancePolicies)
    {
	*ppwszzIssuancePolicies = NULL;
    }
    if (NULL != ppwszzApplicationPolicies)
    {
	*ppwszzApplicationPolicies = NULL;
    }
    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    //ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
    //ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;
    ChainParams.RequestedUsage.Usage.cUsageIdentifier = cUsageOids;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = (char **) apszUsageOids;

    DBGPRINT((DBG_SS_CERTLIBI, "Calling CertGetCertificateChain...\n"));

    // Get the chain and verify the cert:

    if (!CertGetCertificateChain(
			    hChainEngine,	// hChainEngine
			    pCert,		// pCertContext
			    const_cast<FILETIME *>(pft), // pTime
			    hAdditionalStore,	// hAdditionalStore
			    &ChainParams,	// pChainPara
			    (dwFlags & CA_VERIFY_FLAGS_NO_REVOCATION)?
				0 : CERT_CHAIN_REVOCATION_CHECK_CHAIN,
			    NULL,		// pvReserved
			    &pChainContext))	// ppChainContext
    {
        hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }
    DBGPRINT((DBG_SS_CERTLIBI, "CertGetCertificateChain done\n"));

    ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;
    //ChainPolicy.pvExtraPolicyPara = NULL;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    //PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    //PolicyStatus.pvExtraPolicyStatus = NULL;

    // use NTAuth policy if (usage oids being added) & (caller asks us to check(EntCA))
    pszChainPolicyFlags =
	(NULL != apszUsageOids && (CA_VERIFY_FLAGS_NT_AUTH & dwFlags))?
	    CERT_CHAIN_POLICY_NT_AUTH : CERT_CHAIN_POLICY_BASE;
    if (!CertVerifyCertificateChainPolicy(
                                    pszChainPolicyFlags,
				    pChainContext,
				    &ChainPolicy,
				    &PolicyStatus))
    {
        hr = myHLastError();
	_JumpError(hr, error, "CertVerifyCertificateChainPolicy");
    }

    hr = myHError(PolicyStatus.dwError);
    if ((CA_VERIFY_FLAGS_IGNORE_OFFLINE | CA_VERIFY_FLAGS_NO_REVOCATION) & dwFlags)
    {
        if (CRYPT_E_NO_REVOCATION_CHECK == hr ||
	    CRYPT_E_REVOCATION_OFFLINE == hr)
        {
            hr = S_OK;
        }
    }
    if (CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT & dwFlags)
    {
        if (CERT_E_UNTRUSTEDROOT == hr)
        {
            hr = S_OK;
        }
    }
    if (S_OK != hr &&
	0 < pChainContext->cChain &&
	0 < pChainContext->rgpChain[0]->cElement)
    {
	pElement = pChainContext->rgpChain[0]->rgpElement[
		    pChainContext->rgpChain[0]->cElement - 1];

	if (0 == (CERT_TRUST_IS_SELF_SIGNED & pElement->TrustStatus.dwInfoStatus))
	{
	    HRESULT hr2;

	    hr2 = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pElement->pCertContext->pCertInfo->Issuer,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwszMissingIssuer);
	    _PrintIfError(hr2, "myCertNameToStr");
	}
    }
    DumpChain(hr, dwFlags, pCert, pwszMissingIssuer, pChainContext);

    if (NULL != ppwszMissingIssuer)
    {
	*ppwszMissingIssuer = pwszMissingIssuer;
	pwszMissingIssuer = NULL;
    }
    _JumpIfError(hr, error, "PolicyStatus.dwError");

    pElement = pChainContext->rgpChain[0]->rgpElement[0];

    if (NULL != ppwszzIssuancePolicies &&
	FIELD_OFFSET(CERT_CHAIN_ELEMENT, pIssuanceUsage) < pElement->cbSize)
    {
	hr = SavePolicies(
		    pElement->pIssuanceUsage,
		    ppwszzIssuancePolicies);
	_JumpIfError(hr, error, "SavePolicies");
    }
    if (NULL != ppwszzApplicationPolicies &&
	FIELD_OFFSET(CERT_CHAIN_ELEMENT, pApplicationUsage) < pElement->cbSize)
    {
	hr = SavePolicies(
		    pElement->pApplicationUsage,
		    ppwszzApplicationPolicies);
	_JumpIfError(hr, error, "SavePolicies");
    }

error:
    if (S_OK != hr)
    {
	if (NULL != ppwszzIssuancePolicies && NULL != *ppwszzIssuancePolicies)
	{
	    LocalFree(*ppwszzIssuancePolicies);
	    *ppwszzIssuancePolicies = NULL;
	}
    }
    if (NULL != pwszMissingIssuer)
    {
        LocalFree(pwszMissingIssuer);
    }
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


HRESULT
myVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer)
{
    HRESULT hr;

    hr = myVerifyCertContextEx(
			pCert,
			dwFlags,
			cUsageOids,
			apszUsageOids,
			hChainEngine,
			NULL,		// pft
			hAdditionalStore,
			ppwszMissingIssuer,
			NULL,		// ppwszzIssuancePolicies
			NULL);		// ppwszzApplicationPolicies
    _JumpIfError2(hr, error, "myVerifyCertContextEx", hr);

error:
    return(hr);
}


HRESULT
myIsFirstSigner(
    IN CERT_NAME_BLOB const *pNameBlob,
    OUT BOOL *pfFirst)
{
    HRESULT hr;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    DWORD i;

    *pfFirst = FALSE;

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    for (i = 0; i < pNameInfo->cRDN; i++)
    {
	CERT_RDN const *prdn;
	DWORD j;

	prdn = &pNameInfo->rgRDN[i];

	for (j = 0; j < prdn->cRDNAttr; j++)
	{
	    if (0 == strcmp(
			prdn->rgRDNAttr[j].pszObjId,
			szOID_RDN_DUMMY_SIGNER))
	    {
		*pfFirst = TRUE;
		i = pNameInfo->cRDN;	// terminate outer loop
		break;
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HCERTSTORE
myPFXImportCertStore(
    IN CRYPT_DATA_BLOB *ppfx,
    OPTIONAL IN WCHAR const *pwszPassword,
    IN DWORD dwFlags)
{
    HCERTSTORE hStore;
    HRESULT hr;

    if (NULL == pwszPassword)
    {
	pwszPassword = L"";	// Try empty password first, then NULL
    }

    while (TRUE)
    {
	hStore = PFXImportCertStore(ppfx, pwszPassword, dwFlags);
	if (NULL == hStore)
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD) != hr ||
		NULL == pwszPassword ||
		L'\0' != *pwszPassword)
	    {
		_JumpError2(
			hr,
			error,
			"PFXImportCertStore",
			HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	    }
	    pwszPassword = NULL;	// empty password failed; try NULL
	    continue;
	}
	break;
    }


error:
    return(hStore);
}


// No longer support versions before IE3.02 - Auth2 update, advisory only

HRESULT
CertCheck7f(
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    DWORD State;
    DWORD Index1;
    DWORD Index2;
    DWORD cwcField;
    WCHAR wszField[128];
    DWORD cwcObjectId;
    WCHAR wszObjectId[128];
    WCHAR const *pwszObjectIdDescription = NULL;

    cwcField = sizeof(wszField)/sizeof(wszField[0]);
    cwcObjectId = sizeof(wszObjectId)/sizeof(wszObjectId[0]);
    hr = myCheck7f(
		pcc->pbCertEncoded,
		pcc->cbCertEncoded,
		FALSE,
		&State,
		&Index1,
		&Index2,
		&cwcField,
		wszField,
		&cwcObjectId,
		wszObjectId,
		&pwszObjectIdDescription);	// Static: do not free!
    _JumpIfError(hr, error, "myCheck7f");

    if (CHECK7F_NONE != State)
    {
	hr = CERTSRV_E_ENCODING_LENGTH;

#if DBG_CERTSRV
	WCHAR wszBuf[2048];

	wcscpy(wszBuf, wszField);
	if (0 != Index1)
	{
	    wsprintf(
		&wszBuf[wcslen(wszBuf)],
		0 != Index2? L"[%u,%u]" : L"[%u]",
		Index1 - 1,
		Index2 - 1);
	}

	if (0 != cwcObjectId)
	{
	    wcscat(wszBuf, L" ObjectId=");
	    wcscat(wszBuf, wszObjectId);
	}
	if (NULL != pwszObjectIdDescription)
	{
	    wcscat(wszBuf, L" (");
	    wcscat(wszBuf, pwszObjectIdDescription);
	    wcscat(wszBuf, L")");
	}
	DBGPRINT((DBG_SS_CERTLIB, "CertCheck7f: %ws, hr=%x\n", wszBuf, hr));
#endif // DBG_CERTSRV
    }
error:
    return(hr);
}


HRESULT
myAddCertToStore(
    IN HCERTSTORE                          hStore,
    IN CERT_CONTEXT const                 *pCertContext,
    OPTIONAL IN CRYPT_KEY_PROV_INFO const *pkpi,
    OPTIONAL OUT CERT_CONTEXT const      **ppCert)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;

    if (NULL != ppCert)
    {
	*ppCert = NULL;
    }

    // for root cert, if it shows related private key, it will
    // pfx import failure for other applications

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
		    hStore,
		    X509_ASN_ENCODING,
		    pCertContext->pbCertEncoded,
		    pCertContext->cbCertEncoded,
		    NULL != pkpi?
			CERT_STORE_ADD_REPLACE_EXISTING :
			CERT_STORE_ADD_USE_EXISTING,
		    &pcc))			// ppCertContext
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    if (NULL != pkpi)
    {
	if (!CertSetCertificateContextProperty(
					    pcc,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    pkpi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
    }
    if (NULL != ppCert)
    {
	*ppCert = pcc;
	pcc = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
mySaveChainAndKeys(
    IN CERT_SIMPLE_CHAIN const *pSimpleChain,
    IN WCHAR const *pwszStore,
    IN DWORD dwStoreFlags,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    OPTIONAL IN CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    HCERTSTORE hRootStore = NULL;
    HCERTSTORE hCAStore = NULL;
    HCERTSTORE hMyStore = NULL;
    DWORD i;

    if (NULL != ppCert)
    {
	*ppCert = NULL;
    }
    hRootStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			dwStoreFlags,
			wszROOT_CERTSTORE);
    if (NULL == hRootStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", wszROOT_CERTSTORE);
    }

    hCAStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			dwStoreFlags,
			wszCA_CERTSTORE);
    if (NULL == hCAStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", wszCA_CERTSTORE);
    }

    hMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			dwStoreFlags,
			pwszStore);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", pwszStore);
    }

    for (i = 0; i < pSimpleChain->cElement; i++)
    {
	CERT_CONTEXT const *pcc = pSimpleChain->rgpElement[i]->pCertContext;
	HCERTSTORE hStore;

//	CertCheck7f(pcc);

        // if leaf CA cert, add to MY store

        if (0 == i)
        {
            PCCERT_CONTEXT pFoundCC = CertFindCertificateInStore(
                hMyStore,              
                X509_ASN_ENCODING,
                0,
                CERT_FIND_EXISTING,                  
                pcc,
                NULL);

            if(!pFoundCC)
            {
        	    hr = myAddCertToStore(hMyStore, pcc, pkpi, ppCert);
        	    _JumpIfError(hr, error, "myAddCertToStore");
            }
            else
            {
                if(ppCert)
                {
                    *ppCert = pFoundCC;
                }
                else
                {
                    CertFreeCertificateContext(pFoundCC);
                }
            }
        }

        // if root cert, add to ROOT store (without key); else add to CA store

	hStore = hCAStore;

	if (CERT_TRUST_IS_SELF_SIGNED &
		pSimpleChain->rgpElement[i]->TrustStatus.dwInfoStatus)
	{
	    hStore = hRootStore;
    }

	hr = myAddCertToStore(hStore, pcc, NULL, NULL);
	_JumpIfError(hr, error, "myAddCertToStore");
    }
    hr = S_OK;

error:
    if (NULL != hRootStore)
    {
        CertCloseStore(hRootStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hCAStore)
    {
        CertCloseStore(hCAStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
myGetNameId(
    IN CERT_CONTEXT const *pCACert,
    OUT DWORD *pdwNameId)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    CERT_EXTENSION const *pExt;
    DWORD NameId;
    DWORD cb;

    *pdwNameId = MAXDWORD;
    pExt = CertFindExtension(
			szOID_CERTSRV_CA_VERSION,
			pCACert->pCertInfo->cExtension,
			pCACert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	// This API doesn't set LastError
	_JumpError(hr, error, "CertFindExtension(CA Version)");
    }
    cb = sizeof(NameId);
    NameId = 0;
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pExt->Value.pbData,
			pExt->Value.cbData,
			0,
			&NameId,
			&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    *pdwNameId = NameId;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCertGetNameString(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwType,
    OUT WCHAR **ppwszSimpleName)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    DWORD cwc;
    
    *ppwszSimpleName = NULL;
    cwc = 0;
    while (TRUE)
    {
	cwc = CertGetNameString(
			pcc,
			CERT_NAME_SIMPLE_DISPLAY_TYPE,
			0,			// dwFlags
			NULL,			// pvTypePara
			pwsz,
			cwc);
	if (1 >= cwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND);
	    _JumpError(hr, error, "CertGetNameString");
	}
	if (NULL != pwsz)
	{
	    break;
	}
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppwszSimpleName = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    return(hr);
}


HRESULT
myCertStrToName(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppszError)
{
    HRESULT hr;
    
    *ppbEncoded = NULL;
    *pcbEncoded = 0;

    while (TRUE)
    {
	if (!CertStrToName(
		    dwCertEncodingType,
		    pszX500,
		    dwStrType,
		    pvReserved,
		    *ppbEncoded,
		    pcbEncoded,
		    ppszError))
	{
	    hr = myHLastError();
	    if (NULL != *ppbEncoded)
	    {
		LocalFree(*ppbEncoded);
		*ppbEncoded = NULL;
	    }
	    _JumpError(hr, error, "CertStrToName");
	}
	if (NULL != *ppbEncoded)
	{
	    break;
	}
	*ppbEncoded = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncoded);
	if (NULL == *ppbEncoded)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCertNameToStr(
    IN DWORD dwCertEncodingType,
    IN CERT_NAME_BLOB const *pName,
    IN DWORD dwStrType,
    OUT WCHAR **ppwszName)
{
    HRESULT hr;
    DWORD cwc = 0;
    WCHAR *pwszName = NULL;

    while (TRUE)
    {
	cwc = CertNameToStr(
			dwCertEncodingType,
			const_cast<CERT_NAME_BLOB *>(pName),
			dwStrType,
			pwszName,
			cwc);
	if (1 > cwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "CertNameToStr");
	}
	if (NULL != pwszName)
	{
	    break;
	}
	pwszName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppwszName = pwszName;
    pwszName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    return(hr);
}


HRESULT
myVerifyKRACertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags)
{
    HRESULT hr;
    WCHAR *pwszzAppPolicies = NULL;
    WCHAR *pwszCrt;

    hr = myVerifyCertContextEx(
			pCert,
			dwFlags,
			0,                      // cUsageOids
			NULL,                   // apszUsageOids
			HCCE_LOCAL_MACHINE,     // hChainEngine
			NULL,			// pft
			NULL,                   // hAdditionalStore
			NULL,                   // ppwszMissingIssuer
			NULL,			// ppwszzIssuancePolicies
			&pwszzAppPolicies);
    _JumpIfError(hr, error, "myVerifyCertContextEx");

    hr = CERT_E_WRONG_USAGE;

    for(pwszCrt = pwszzAppPolicies; 
        pwszCrt && L'\0' != *pwszCrt;
        pwszCrt = pwszCrt + wcslen(pwszzAppPolicies) + 1)
    {
        if(0==wcscmp(TEXT(szOID_KP_KEY_RECOVERY_AGENT), pwszCrt))
        {
            hr = S_OK;
            break;
        }
    }
    _JumpIfError(hr, error, "myVerifyKRACertContext");

error:
    if(pwszzAppPolicies)
    {
        LocalFree(pwszzAppPolicies);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\cslistvw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cslistvw.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <commctrl.h>
#include <assert.h>

#include "cslistvw.h"

BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;

    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        WinHelp((HWND)pHelpInfo->hItemHandle, szHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    }
    return TRUE;
}

BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;
    assert(IsWindow(hWnd));
    WinHelp(hWnd, szHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\dcom.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dcom.cpp
//
//  Contents:   IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certsrvd.h"

#define __dwFILE__      __dwFILE_CERTLIB_DCOM_CPP__


HRESULT
mySplitConfigString(
    IN WCHAR const *pwszConfig,
    OUT WCHAR **ppwszServer,
    OUT WCHAR **ppwszAuthority)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD cwcServer;
    WCHAR *pwszAuthority = NULL;
    
    *ppwszServer = NULL;
    *ppwszAuthority = NULL;
    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwcServer = wcslen(pwszConfig);
    }
    else
    {
        cwcServer = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
	pwsz++;

	pwszAuthority = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(wcslen(pwsz) + 1) * sizeof(WCHAR));
	if (NULL == pwszAuthority)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszAuthority, pwsz);
    }
    *ppwszServer = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwcServer + 1) * sizeof(WCHAR));
    if (NULL == *ppwszServer)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszServer, pwszConfig, cwcServer * sizeof(WCHAR));
    (*ppwszServer)[cwcServer] = L'\0';

    *ppwszAuthority = pwszAuthority;
    pwszAuthority = NULL;
    hr = S_OK;

error:
    if (NULL != pwszAuthority)
    {
	LocalFree(pwszAuthority);
    }
    return(hr);
}


HRESULT
_OpenDComConnection(
    IN WCHAR const *pwszConfig,
    IN CLSID const *pclsid,
    IN IID const *piid,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OUT BOOL *pfNewConnection,
    IN OUT IUnknown **ppUnknown)
{
    HRESULT hr;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwsz;
    DWORD cwc;
    COSERVERINFO ComponentInfo;
    MULTI_QI mq;
    WCHAR *pwcDot = NULL;

    if (NULL == pwszConfig ||
	NULL == pclsid ||
	NULL == piid ||
	NULL == pfNewConnection ||
	NULL == ppUnknown)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    CSASSERT(NULL != pwszConfig);
    *pfNewConnection = FALSE;

    // Allow UNC-style config strings: \\server\CaName

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwc = wcslen(pwszConfig);
        if (NULL != ppwszAuthority)
        {
	    *ppwszAuthority = &pwszConfig[cwc];
        }
    }
    else
    {
        cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
        if (NULL != ppwszAuthority)
        {
	    *ppwszAuthority = &pwsz[1];
        }
    }
    pwszServerName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszServerName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszServerName, pwszConfig, cwc * sizeof(WCHAR));
    pwszServerName[cwc] = L'\0';

    // NOTE: CoSetProxyBlanket returns RPC_S_UNKNOWN_AUTHN_SERVICE when
    // the Dns name ends with a '.'.  Until that's fixed, truncate the dot.

    if (0 < cwc && L'.' == pwszServerName[cwc - 1])
    {
        pwszServerName[cwc - 1] = L'\0';
        cwc--;
    }

    if (NULL == *ppUnknown ||
	NULL == ppwszServerName ||
	NULL == *ppwszServerName ||
	0 != lstrcmpi(pwszServerName, *ppwszServerName))
    {
        ZeroMemory(&ComponentInfo, sizeof(COSERVERINFO));
        ComponentInfo.pwszName = pwszServerName;
        //ComponentInfo.pAuthInfo = NULL;

        mq.pIID = piid;
        mq.pItf = NULL;
        mq.hr = S_OK;

        myCloseDComConnection(ppUnknown, ppwszServerName);

        while (TRUE)
	{
	    hr = CoCreateInstanceEx(
			    *pclsid,
			    NULL,
			    CLSCTX_SERVER, //CLSCTX_LOCAL_SERVER,
			    &ComponentInfo,
			    1,
			    &mq);
	    _PrintIfErrorStr2(
			hr,
			"CoCreateInstanceEx",
			pwszServerName,
			E_NOINTERFACE);

	    if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr &&
		0 < cwc &&
		L'.' == pwszServerName[cwc - 1])
	    {
		pwcDot = &pwszServerName[cwc - 1];
		*pwcDot = L'\0';
		continue;
	    }
	    break;
	}
	if (NULL != pwcDot)
	{
	    *pwcDot = L'.';
	}
	_JumpIfErrorStr2(hr, error, "CoCreateInstanceEx", pwszServerName, hr);

	*ppUnknown = mq.pItf;
	if (NULL != ppwszServerName)
	{
	    CSASSERT(NULL == *ppwszServerName);
	    *ppwszServerName = pwszServerName;
	    pwszServerName = NULL;
	}

	*pfNewConnection = TRUE;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	myCloseDComConnection(ppUnknown, ppwszServerName);
    }
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    return(hr);
}


HRESULT
_OpenDComConnection2(
    IN WCHAR const *pwszConfig,
    IN CLSID const *pclsid,
    IN IID const *piid, // v1 interface
    IN IID const *piid2,// v2 interface
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OPTIONAL OUT BOOL *pfNewConnection,
    IN OUT DWORD *pdwServerVersion,
    IN OUT IUnknown **ppUnknown)
{
    HRESULT hr = E_INVALIDARG;
    BOOL fNewConnection;

    if (NULL != pfNewConnection)
    {
	*pfNewConnection = FALSE;
    }
    CSASSERT(
	0 == *pdwServerVersion ||
	1 == *pdwServerVersion ||
	2 == *pdwServerVersion);

    hr = _OpenDComConnection(
		    pwszConfig,
		    pclsid,
		    piid,
		    ppwszAuthority,
		    ppwszServerName,
		    &fNewConnection,
		    ppUnknown);
    _JumpIfError(hr, error, "_OpenDComConnection");

    if (fNewConnection)
    {
	IUnknown *pUnknown;

	if (NULL != pfNewConnection)
	{
	    *pfNewConnection = TRUE;
	}
	hr = (*ppUnknown)->QueryInterface(*piid2, (VOID **) &pUnknown);
	if (S_OK != hr)
	{
	    *pdwServerVersion = 1;	// v2 not supported
	}
	else
	{
	    *pdwServerVersion = 2;	// v2 supported
	    (*ppUnknown)->Release();
	    *ppUnknown = pUnknown;
	}

	hr = CoSetProxyBlanket(
		    *ppUnknown,
		    RPC_C_AUTHN_DEFAULT,    // use NT default security
		    RPC_C_AUTHZ_DEFAULT,    // use NT default authentication
		    COLE_DEFAULT_PRINCIPAL,
		    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, // call
		    RPC_C_IMP_LEVEL_IMPERSONATE,
		    NULL,
		    EOAC_STATIC_CLOAKING);
	_JumpIfError(hr, error, "CoSetProxyBlanket");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myOpenAdminDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertAdminD2 **ppICertAdminD)
{
    HRESULT hr;

    hr = _OpenDComConnection2(
			pwszConfig,
			&CLSID_CCertAdminD,
			&IID_ICertAdminD,
			&IID_ICertAdminD2,
			ppwszAuthority,
			ppwszServerName,
			NULL,			// pfNewConnection
			pdwServerVersion,
			(IUnknown **) ppICertAdminD);
    _JumpIfError(hr, error, "_OpenDComConnection2");

error:
    return(hr);
}


HRESULT
myOpenRequestDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OPTIONAL OUT BOOL *pfNewConnection,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertRequestD2 **ppICertRequestD)
{
    HRESULT hr;

    hr = _OpenDComConnection2(
			pwszConfig,
			&CLSID_CCertRequestD,
			&IID_ICertRequestD,
			&IID_ICertRequestD2,
			ppwszAuthority,
			ppwszServerName,
			pfNewConnection,
			pdwServerVersion,
			(IUnknown **) ppICertRequestD);
    _JumpIfError(hr, error, "_OpenDComConnection2");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// myCloseDComConnection -- release DCOM connection
//
//+--------------------------------------------------------------------------

VOID
myCloseDComConnection(
    OPTIONAL IN OUT IUnknown **ppUnknown,
    OPTIONAL IN OUT WCHAR **ppwszServerName)
{
    if (NULL != ppUnknown && NULL != *ppUnknown)
    {
        (*ppUnknown)->Release();
        *ppUnknown = NULL;
    }
    if (NULL != ppwszServerName && NULL != *ppwszServerName)
    {
	LocalFree(*ppwszServerName);
	*ppwszServerName = NULL;
    }
}


HRESULT
myPingCertSrv(
    IN WCHAR const *pwszConfigOrCAName,
    OPTIONAL IN WCHAR const *pwszMachineName,
    OPTIONAL OUT WCHAR **ppwszzCANames,
    OPTIONAL OUT WCHAR **ppwszSharedFolder,
    OPTIONAL OUT CAINFO **ppCAInfo,
    OPTIONAL OUT DWORD *pdwServerVersion,
    OPTIONAL OUT WCHAR **ppwszCADnsName)
{
    HRESULT hr;
    WCHAR wszConfig[MAX_PATH];
    WCHAR const *pwszConfig;
    ICertRequestD2 *pICertRequestD = NULL;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCANames;
    CERTTRANSBLOB ctbSharedFolder;
    CERTTRANSBLOB ctbCAInfo;
    CERTTRANSBLOB ctbCADnsName;
    CAINFO CAInfo;
    CAINFO const *pCAInfo;
    DWORD dwServerVersion = 0;

    ctbCANames.pb = NULL;
    ctbSharedFolder.pb = NULL;
    ctbCAInfo.pb = NULL;
    ctbCADnsName.pb = NULL;

    if (NULL != ppwszzCANames)
    {
        *ppwszzCANames = NULL;
    }
    if (NULL != ppwszSharedFolder)
    {
        *ppwszSharedFolder = NULL;
    }
    if (NULL != ppCAInfo)
    {
        *ppCAInfo = NULL;
    }
    if (NULL != ppwszCADnsName)
    {
        *ppwszCADnsName = NULL;
    }

    if (NULL == pwszConfigOrCAName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Invalid parameters");
    }
    pwszConfig = pwszConfigOrCAName;
    if (NULL != pwszMachineName)
    {
        wcscpy(wszConfig, pwszMachineName);
        wcscat(wszConfig, L"\\");
        wcscat(wszConfig, pwszConfigOrCAName);
        pwszConfig = wszConfig;
    }

    hr = myOpenRequestDComConnection(
                        pwszConfig,
                        &pwszAuthority,
                        NULL,
                        NULL,
                        &dwServerVersion,
                        &pICertRequestD);
    _JumpIfError(hr, error, "myOpenRequestDComConnection");

    CSASSERT(0 != dwServerVersion);

    if (2 <= dwServerVersion)
    {
        __try
        {
            hr = pICertRequestD->Ping2(pwszAuthority);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "Ping2");
    }
    else
    {
        __try
        {
            hr = pICertRequestD->Ping(pwszAuthority);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "Ping");
    }

    if (NULL != ppwszzCANames)
    {
        __try
        {
            hr = pICertRequestD->GetCACert(
                                        GETCERT_CANAME,
                                        pwszAuthority,
                                        &ctbCANames);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "GetCACert(CANames)");

        // must register this memory
        myRegisterMemAlloc(ctbCANames.pb, ctbCANames.cb, CSM_COTASKALLOC);

        // Only one CA Name expected for now...

        CSASSERT(
            (wcslen((WCHAR *) ctbCANames.pb) + 1) * sizeof(WCHAR) ==
            ctbCANames.cb);

        *ppwszzCANames = (WCHAR *) LocalAlloc(
                                        LMEM_FIXED,
                                        ctbCANames.cb + sizeof(WCHAR));
        if (NULL == *ppwszzCANames)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppwszzCANames, ctbCANames.pb, ctbCANames.cb);
        (*ppwszzCANames)[ctbCANames.cb/sizeof(WCHAR)] = L'\0';
    }

    if (NULL != ppwszSharedFolder)
    {
        __try
        {
            hr = pICertRequestD->GetCACert(
                GETCERT_SHAREDFOLDER,
                pwszAuthority,
                &ctbSharedFolder);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "GetCACert(SharedFolder)");
        
        // must register this memory
        myRegisterMemAlloc(ctbSharedFolder.pb, ctbSharedFolder.cb, CSM_COTASKALLOC);
        
        *ppwszSharedFolder = (WCHAR *)LocalAlloc(LMEM_FIXED,
            ctbSharedFolder.cb + sizeof(WCHAR));
        if (NULL == *ppwszSharedFolder)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppwszSharedFolder, ctbSharedFolder.pb, ctbSharedFolder.cb);
        (*ppwszSharedFolder)[ctbSharedFolder.cb/sizeof(WCHAR)] = L'\0';
        
        CSASSERT(wcslen(*ppwszSharedFolder)*sizeof(WCHAR) == ctbSharedFolder.cb);
    }

    if (NULL != ppCAInfo)
    {
        __try
        {
            hr = pICertRequestD->GetCACert(
                                    GETCERT_CAINFO,
                                    pwszAuthority,
                                    &ctbCAInfo);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        if (E_INVALIDARG == hr)         // if old server
        {
            __try
            {
                hr = pICertRequestD->GetCACert(
                                        GETCERT_CATYPE,
                                        pwszAuthority,
                                        &ctbCAInfo);
            }
            __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
            {
            }
            _JumpIfError(hr, error, "GetCACert(CAType)");

            myRegisterMemAlloc(ctbCAInfo.pb, ctbCAInfo.cb, CSM_COTASKALLOC);

            ZeroMemory(&CAInfo, sizeof(CAInfo));
            CAInfo.cbSize = CCSIZEOF_STRUCT(CAINFO, cCASignatureCerts);
            CAInfo.CAType = *(ENUM_CATYPES *) ctbCAInfo.pb;
            CAInfo.cCASignatureCerts = 1;
            pCAInfo = &CAInfo;
        }
        else
        {
            _JumpIfError(hr, error, "GetCACert(CAInfo)");

            // must register this memory

            myRegisterMemAlloc(ctbCAInfo.pb, ctbCAInfo.cb, CSM_COTASKALLOC);

            pCAInfo = (CAINFO *) ctbCAInfo.pb;
        }
        *ppCAInfo = (CAINFO *) LocalAlloc(LMEM_FIXED, pCAInfo->cbSize);
        if (NULL == *ppCAInfo)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppCAInfo, pCAInfo, pCAInfo->cbSize);
    }
    if (NULL != pdwServerVersion)
    {
        *pdwServerVersion = dwServerVersion;
    }
    if (NULL != ppwszCADnsName && 2 <= dwServerVersion)
    {
        __try
        {
            hr = pICertRequestD->GetCAProperty(
                pwszAuthority,
                CR_PROP_DNSNAME,
                0,
                PROPTYPE_STRING,
                &ctbCADnsName);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "GetCACert(SharedFolder)");

        // must register this memory
        myRegisterMemAlloc(ctbCADnsName.pb, ctbCADnsName.cb, CSM_COTASKALLOC);
        
        *ppwszCADnsName = (WCHAR *)LocalAlloc(LMEM_FIXED, ctbCADnsName.cb + sizeof(WCHAR));
        if (NULL == *ppwszCADnsName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppwszCADnsName, ctbCADnsName.pb, ctbCADnsName.cb);
        (*ppwszCADnsName)[ctbCADnsName.cb/sizeof(WCHAR)] = L'\0';
        
        CSASSERT((wcslen(*ppwszCADnsName)+1)*sizeof(WCHAR) == ctbCADnsName.cb);
    }

    hr = S_OK;

error:
    myCloseDComConnection((IUnknown **) &pICertRequestD, NULL);
    if (NULL != ctbCANames.pb)
    {
        CoTaskMemFree(ctbCANames.pb);
    }
    if (NULL != ctbSharedFolder.pb)
    {
        CoTaskMemFree(ctbSharedFolder.pb);
    }
    if (NULL != ctbCAInfo.pb)
    {
        CoTaskMemFree(ctbCAInfo.pb);
    }
    if (NULL != ctbCADnsName.pb)
    {
        CoTaskMemFree(ctbCADnsName.pb);
    }

    return(hr);
}


HRESULT
myEnablePrivilege(
    IN LPCTSTR szPrivilege,
    IN BOOL fEnable)
{

    HRESULT hr = S_OK;
    TOKEN_PRIVILEGES NewState;
    CAutoHANDLE hThread;
    CAutoHANDLE hToken;

    NewState.PrivilegeCount = 1;


    hThread = GetCurrentThread();
    if (!hThread)
    {
        hr = myHLastError();
	    _JumpIfError(hr, error, "GetCurrentThread");
    }

    // Get the access token for current thread
    if (!OpenThreadToken(
            hThread, 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
            FALSE,
            &hToken))
    {
        hr = myHLastError();

        if(hr==HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            HANDLE hProcess = GetCurrentProcess();
            if (!hProcess)
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetCurrentProcess");
            }

            if (!OpenProcessToken(hProcess,
                    TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                    &hToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "OpenProcessToken");
            }

            hr = S_OK;
        }
        else
        {
            _JumpError(hr, error, "OpenThreadToken");
        }
    }

    if (!LookupPrivilegeValue(NULL, szPrivilege, &NewState.Privileges[0].Luid))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "LookupPrivelageValue");
    }

    NewState.Privileges[0].Attributes = (fEnable?SE_PRIVILEGE_ENABLED:0);

    if(!AdjustTokenPrivileges(hToken,
                              FALSE,
                              &NewState,
                              sizeof(NewState),
                              NULL,
                              NULL))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "AdjustTokenPrivileges");
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\cspelog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       log.cpp
//
//  Contents:   implements policy and exit module logging routines.
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"


BOOL
LogModuleStatus(
    IN HMODULE hModule,
    IN DWORD dwLogID,				// Resource ID of log string
    IN BOOL fPolicy, 
    IN WCHAR const *pwszSource, 
    IN WCHAR const * const *ppwszInsert)	// array of insert strings
{
    HRESULT hr = S_OK;
    BOOL fResult = FALSE;
    WCHAR *pwszResult = NULL;
    ICreateErrorInfo *pCreateErrorInfo = NULL;
    IErrorInfo *pErrorInfo = NULL;

    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_ARGUMENT_ARRAY |
			FORMAT_MESSAGE_FROM_HMODULE,
		    hModule,
		    dwLogID,
		    0,
		    (WCHAR *) &pwszResult,
		    0,
		    (va_list *) ppwszInsert))
    {
        goto error;
    }
    DBGPRINT((DBG_SS_CERTPOL, "LogPolicyStatus: %ws\n", pwszResult));

    hr = CreateErrorInfo(&pCreateErrorInfo);
    _JumpIfError(hr, error, "CreateErrorInfo");

    hr = pCreateErrorInfo->SetGUID(fPolicy? IID_ICertPolicy : IID_ICertExit);
    _PrintIfError(hr, "SetGUID");

    hr = pCreateErrorInfo->SetDescription(pwszResult);
    _PrintIfError(hr, "SetDescription");

    // Set ProgId:

    hr = pCreateErrorInfo->SetSource(const_cast<WCHAR *>(pwszSource));
    _PrintIfError(hr, "SetSource");

    hr = pCreateErrorInfo->QueryInterface(
				    IID_IErrorInfo,
				    (VOID **) &pErrorInfo);
    _JumpIfError(hr, error, "QueryInterface");

    SetErrorInfo(0, pErrorInfo);
    fResult = TRUE;

error:
    if (NULL != pwszResult)
    {
        LocalFree(pwszResult);
    }
    if (NULL != pErrorInfo)
    {
        pErrorInfo->Release();
    }
    if (NULL != pCreateErrorInfo)
    {
        pCreateErrorInfo->Release();
    }
    return(fResult);
}


HRESULT
LogPolicyEvent(
    IN HMODULE hModule,
    IN DWORD dwLogID,				// Resource ID of log string
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropEvent,
    IN WCHAR const * const *ppwszInsert)	// array of insert strings
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BSTR strName = NULL;
    VARIANT varValue;

    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_ARGUMENT_ARRAY |
			FORMAT_MESSAGE_FROM_HMODULE,
		    hModule,
		    dwLogID,
		    0,
		    (WCHAR *) &pwszValue,
		    0,
		    (va_list *) ppwszInsert))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FormatMessage");
    }
    DBGPRINT((DBG_SS_CERTPOL, "LogPolicyEvent: %ws\n", pwszValue));

    varValue.vt = VT_EMPTY;

    if (!myConvertWszToBstr(&strName, pwszPropEvent, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }

    varValue.bstrVal = NULL;
    if (!myConvertWszToBstr(&varValue.bstrVal, pwszValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    varValue.vt = VT_BSTR;
    
    hr = pServer->SetCertificateProperty(strName, PROPTYPE_STRING, &varValue);
    _JumpIfError(hr, error, "SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pwszValue)
    {
        LocalFree(pwszValue);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\csw97sht.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97sht.cpp
//
//--------------------------------------------------------------------------

// csw97sht.cpp: implementation of the CWizard97PropertySheet class.
//
//////////////////////////////////////////////////////////////////////

#include <pch.cpp>

#pragma hdrstop

#include "prsht.h"
#include "csw97sht.h"
#include "csw97ppg.h"
//#include "resource.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWizard97PropertySheet::CWizard97PropertySheet(
    HINSTANCE hInstance,
    UINT nIDCaption,
    UINT nIDWaterMark,
    UINT nIDBanner,
    BOOL fWizard)
{
    ZeroMemory(&m_pPagePtr, sizeof(CWizard97PropertyPage*) * NUM_PAGES);
    ZeroMemory(&m_pPageArr, sizeof(HPROPSHEETPAGE) * NUM_PAGES);

    // NOTICE: do this because of header mismatch
    ZeroMemory(&m_psh, sizeof(PROPSHEETHEADER));
    m_psh.dwFlags = fWizard ? (PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER) : PSH_DEFAULT;
    m_psh.pszbmWatermark = MAKEINTRESOURCE(nIDWaterMark);
    m_psh.pszbmHeader = MAKEINTRESOURCE(nIDBanner);
    m_psh.hplWatermark = NULL;         
	

    m_psh.dwSize              = sizeof(m_psh);
    m_psh.hInstance           = hInstance; //AfxGetApp()->m_hInstance;
    m_psh.hwndParent          = NULL;

    VERIFY(m_title.LoadString(nIDCaption));
    m_psh.pszCaption          = (LPCTSTR) m_title;
    m_psh.phpage              = NULL;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = 0;

    m_nPageCount = 0;
}

CWizard97PropertySheet::~CWizard97PropertySheet()
{
}


BOOL
CWizard97PropertySheet::DoWizard(
    HWND hParent)
{
    m_psh.hwndParent = hParent;
//   if (m_nPageCount > 0 && m_pPagePtr[m_nPageCount - 1])
//		m_pPagePtr[m_nPageCount - 1]->m_bLast = TRUE;

    m_psh.phpage              = m_pPageArr;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = m_nPageCount;

    return (BOOL)PropertySheet(&m_psh);
}

void
CWizard97PropertySheet::AddPage(
    CWizard97PropertyPage *pPage)
{
    ASSERT(pPage);
    if (pPage)
    {
	ASSERT(m_nPageCount < NUM_PAGES);
	m_pPagePtr[m_nPageCount] = pPage;
	m_pPageArr[m_nPageCount] = ::CreatePropertySheetPage(&(pPage->m_psp97));
	ASSERT(m_pPageArr[m_nPageCount]);
	m_nPageCount++;
	pPage->m_pWiz = this;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\dispatch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       csdisp.cpp
//
//  Contents:   IDispatch helper functions
//
//  History:    09-Dec-96   vich    created
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"

#ifndef DBG_DISPATCH
#  define DBG_DISPATCH	0
#endif

TCHAR szRegKeyClsidValue[] = TEXT("");


HRESULT
DispatchGetReturnValue(
    VARIANT *pvar,
    IN LONG Type,
    OUT VOID *pretval)
{
    HRESULT hr = S_OK;

    if (VT_EMPTY == pvar->vt)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "VT_EMPTY", hr);
    }
    if (Type != pvar->vt)
    {
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "pvar->vt=%x, expected %x\n",
	    pvar->vt,
	    Type));
	hr = TYPE_E_WRONGTYPEKIND;
	_JumpError(hr, error, "pvar->vt != Type");
    }
    switch (Type)
    {
	case VT_I4:
	    *(LONG *) pretval = pvar->lVal;
	    break;

	case VT_DATE:
	    *(DATE *) pretval = pvar->date;
	    break;

	case VT_BSTR:
	    *(BSTR *) pretval = pvar->bstrVal;
            
	    pvar->vt = VT_EMPTY;
	    break;

	case VT_DISPATCH:
	    *(IDispatch **) pretval = pvar->pdispVal;
	    pvar->vt = VT_EMPTY;
	    break;

	default:
	    hr = E_INVALIDARG;
	    goto error;
    }

error:
    return(hr);
}


HRESULT
DispatchSetErrorInfoSub(
    IN HRESULT hrError,
    OPTIONAL IN WCHAR const *pwszIDispatchMethod,
    OPTIONAL IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszSource,
    OPTIONAL IN IID const *piid,
    OPTIONAL IN WCHAR const *pwszHelpFile,
    IN DWORD dwHelpFileContext)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    ICreateErrorInfo *pCreateErrorInfo = NULL;
    IErrorInfo *pErrorInfo = NULL;

#ifdef DBG_CERTSRV_DEBUG_PRINT
    if (NULL != pwszIDispatchMethod || DbgIsSSActive(DBG_SS_CERTLIBI))
#else
    if (NULL != pwszIDispatchMethod)
#endif
    {
	pwszError = myGetErrorMessageText(hrError, TRUE);
		
	if (NULL != pwszIDispatchMethod)
	{
	    CONSOLEPRINT1((
		    MAXDWORD,
		    "IDispatch->Invoke(%ws) Exception:\n",
		    pwszIDispatchMethod));
	}
	else
	{
	    CONSOLEPRINT0((MAXDWORD, "COM Error:\n"));
	}

	CONSOLEPRINT5((
		MAXDWORD,
		"    Source=%ws\n    Description=%ws\n    HelpFile=%ws[%x]\n    %ws\n",
		pwszSource,
		pwszDescription,
		pwszHelpFile,
		dwHelpFileContext,
		pwszError));
    }

    hr = CreateErrorInfo(&pCreateErrorInfo);
    _JumpIfError(hr, error, "CreateErrorInfo");

    if (NULL != piid)
    {
	hr = pCreateErrorInfo->SetGUID(*piid);
	_PrintIfError(hr, "SetGUID");
    }
    if (NULL != pwszSource)
    {
	hr = pCreateErrorInfo->SetSource(const_cast<WCHAR *>(pwszSource));
	_PrintIfError(hr, "SetSource");
    }
    if (NULL != pwszDescription)
    {
	hr = pCreateErrorInfo->SetDescription(
					const_cast<WCHAR *>(pwszDescription));
	_PrintIfError(hr, "SetDescription");
    }
    if (NULL != pwszHelpFile)
    {
	hr = pCreateErrorInfo->SetHelpFile(const_cast<WCHAR *>(pwszHelpFile));
	_PrintIfError(hr, "SetHelpFile");

	hr = pCreateErrorInfo->SetHelpContext(dwHelpFileContext);
	_PrintIfError(hr, "SetHelpContext");
    }

    hr = pCreateErrorInfo->QueryInterface(
				    IID_IErrorInfo,
				    (VOID **) &pErrorInfo);
    _JumpIfError(hr, error, "QueryInterface");

    SetErrorInfo(0, pErrorInfo);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    if (NULL != pErrorInfo)
    {
	pErrorInfo->Release();
    }
    if (NULL != pCreateErrorInfo)
    {
	pCreateErrorInfo->Release();
    }
    return(hr);
}


HRESULT
DispatchInvoke(
    IN DISPATCHINTERFACE *pDispatchInterface,
    IN LONG MethodIndex,
    IN DWORD cvar,
    IN VARIANT avar[],
    IN LONG Type,
    OUT VOID *pretval)
{
    HRESULT hr;
    DISPATCHTABLE const *pdt;
    EXCEPINFO excepinfo;
    VARIANT varResult;
    DISPPARAMS parms;
    unsigned iArgErr;
    DISPID *adispid;

    VariantInit(&varResult);
    CSASSERT(NULL != pDispatchInterface->pDispatchTable);
    CSASSERT((DWORD) MethodIndex < pDispatchInterface->m_cDispatchTable);
    pdt = &pDispatchInterface->pDispatchTable[MethodIndex];

    adispid = &pDispatchInterface->m_adispid[pdt->idispid];
    CSASSERT(NULL != pDispatchInterface->m_adispid);
    CSASSERT(pdt->idispid + pdt->cdispid <= pDispatchInterface->m_cdispid);

    parms.rgvarg = avar;
    parms.rgdispidNamedArgs = &adispid[1];
    parms.cArgs = pdt->cdispid - 1;
    parms.cNamedArgs = parms.cArgs;

    if (parms.cArgs != cvar)
    {
	CSASSERT(parms.cArgs == cvar);
	hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	_JumpError(hr, error, "cvar");
    }

    CSASSERT(NULL != pDispatchInterface->pDispatch);

    hr = pDispatchInterface->pDispatch->Invoke(
		    adispid[0],
		    IID_NULL,
		    LOCALE_SYSTEM_DEFAULT,
		    DISPATCH_METHOD,
		    &parms,
		    &varResult,
		    &excepinfo,
		    &iArgErr);

    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "Invoke", pdt->apszNames[0]);

	if (DISP_E_EXCEPTION == hr)
	{
	    HRESULT hr2;
	    IID const *piid;

	    if (FAILED(excepinfo.scode))
	    {
		hr = excepinfo.scode;
	    }
	    hr2 = DispatchSetErrorInfoSub(
				hr,
				pdt->apszNames[0],
				excepinfo.bstrDescription,
				excepinfo.bstrSource,
				pDispatchInterface->GetIID(),
				excepinfo.bstrHelpFile,
				excepinfo.dwHelpContext);
	    _PrintIfError(hr2, "DispatchSetErrorInfoSub");
	}
	goto error;
    }

    if (CLSCTX_INPROC_SERVER != pDispatchInterface->m_ClassContext)
    {
	myRegisterMemAlloc(&varResult, 0, CSM_VARIANT);
    }
    if (NULL != pretval)
    {
	hr = DispatchGetReturnValue(&varResult, Type, pretval);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "DispatchGetReturnValue",
		    pdt->apszNames[0],
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    VariantClear(&varResult);
    return(hr);
}


HRESULT
DispatchGetIds(
    IN IDispatch *pDispatch,
    IN DWORD cDispatchTable,
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr = S_OK;
    DISPATCHTABLE *pdt;
    DISPATCHTABLE *pdtEnd;
    DISPID *adispid = NULL;
    DWORD idispid;

    pdtEnd = &pDispatchTable[cDispatchTable];
    pDispatchInterface->m_cdispid = 0;
    for (pdt = pDispatchTable; pdt < pdtEnd; pdt++)
    {
	if (0 == pdt->idispid)
	{
	    pdt->idispid = pDispatchInterface->m_cdispid;
	}
	CSASSERT(pdt->idispid == pDispatchInterface->m_cdispid);
	pDispatchInterface->m_cdispid += pdt->cdispid;
    }

    adispid = (DISPID *) LocalAlloc(
			LMEM_FIXED,
			pDispatchInterface->m_cdispid * sizeof(adispid[0]));
    if (NULL == adispid)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    idispid = 0;
    for (pdt = pDispatchTable; pdt < pdtEnd; pdt++)
    {
	CSASSERT(idispid + pdt->cdispid <= pDispatchInterface->m_cdispid);
	hr = pDispatch->GetIDsOfNames(
				IID_NULL,
				pdt->apszNames,
				pdt->cdispid,
				LOCALE_SYSTEM_DEFAULT,
				&adispid[idispid]);
#if DBG_CERTSRV
	if (S_OK != hr || DBG_DISPATCH)
	{
	    DWORD i;

	    DBGPRINT((
		MAXDWORD,
		"GetIDsOfNames(%ws) --> %x, dispid=%x" szLPAREN,
		pdt->apszNames[0],
		hr,
		adispid[idispid]));
	    for (i = 1; i < pdt->cdispid; i++)
	    {
		DBGPRINT((
		    MAXDWORD,
		    "%ws%x",
		    i == 1? L"" : L", ",
		    adispid[idispid + i]));
	    }
	    DBGPRINT((MAXDWORD, szRPAREN "\n"));
	}
#endif
	_JumpIfError(hr, error, "GetIDsOfNames");

	idispid += pdt->cdispid;
    }
    pDispatchInterface->m_cDispatchTable = cDispatchTable;
    pDispatchInterface->pDispatchTable = pDispatchTable;
    pDispatchInterface->m_adispid = adispid;
    adispid = NULL;

error:
    if (NULL != adispid)
    {
	LocalFree(adispid);
    }
    return(hr);
}




HRESULT
DispatchSetup(
    IN DWORD Flags,
    IN DWORD ClassContext,
    OPTIONAL IN TCHAR const *pszProgID,	        // for IDispatch
    OPTIONAL IN CLSID const *pclsid,		// for COM
    OPTIONAL IN IID const *piid,		// for COM
    IN DWORD cDispatchTable,			// for IDispatch
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr;
    CLSID clsid;
    
    pDispatchInterface->SetIID(piid);
    while (TRUE)
    {
	pDispatchInterface->pDispatch = NULL;
	pDispatchInterface->pUnknown = NULL;
	pDispatchInterface->m_adispid = NULL;

	CSASSERT(NULL != pszProgID || DISPSETUP_COM == Flags);
	CSASSERT(NULL != pclsid || DISPSETUP_IDISPATCH == Flags);
	CSASSERT(NULL != piid || DISPSETUP_IDISPATCH == Flags);

	if (DISPSETUP_IDISPATCH == Flags)
	{
            // use win32 version, not our own hack
            hr = CLSIDFromProgID(pszProgID, &clsid);

	    _JumpIfError2(
			hr,
			error,
			"ClassNameToCLSID",
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	    pclsid = &clsid;
	    piid = &IID_IDispatch;
	}

	hr = CoCreateInstance(
			*pclsid,
			NULL,		// pUnkOuter
			ClassContext,
			*piid,
			DISPSETUP_IDISPATCH == Flags? 
			    (VOID **) &pDispatchInterface->pDispatch :
			    (VOID **) &pDispatchInterface->pUnknown);
#if DBG_DISPATCH
	printf("CoCreateInstance(%x) --> %x\n", Flags, hr);
#endif
	if (S_OK != hr)
	{
	    if (DISPSETUP_COMFIRST != Flags)
	    {
		_JumpError2(hr, error, "CoCreateInstance", E_NOINTERFACE);
	    }
	    Flags = DISPSETUP_IDISPATCH;
	    continue;
	}
	pDispatchInterface->m_ClassContext = ClassContext;
	break;
    }
    if (DISPSETUP_IDISPATCH == Flags)
    {
	hr = DispatchGetIds(
			pDispatchInterface->pDispatch,
			cDispatchTable,
			pDispatchTable,
			pDispatchInterface);
	if (S_OK != hr)
	{
	    DispatchRelease(pDispatchInterface);
	    _JumpError(hr, error, "DispatchGetIds");
	}
    }

error:
    return(hr);
}



HRESULT
DispatchSetup2(
    IN DWORD Flags,
    IN DWORD ClassContext,
    IN WCHAR const *pwszClass,		// wszRegKeyAdminClsid
    IN CLSID const *pclsid,
    IN DWORD cver,
    IN IID const * const *ppiid,	// cver elements
    IN DWORD const *pcDispatch,		// cver elements
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr = E_INVALIDARG;

    CSASSERT(0 < cver);
    for ( ; 0 < cver; cver--, ppiid++, pcDispatch++)
    {
	hr = DispatchSetup(
		    Flags,
		    ClassContext,
		    pwszClass,
		    pclsid,
		    *ppiid,
		    *pcDispatch,
		    pDispatchTable,
		    pDispatchInterface);
	if (S_OK == hr)
	{
	    pDispatchInterface->m_dwVersion = cver;
	    pDispatchInterface->pDispatchTable = pDispatchTable;
	    break;
	}
	if (1 == cver || (E_NOINTERFACE != hr && DISP_E_UNKNOWNNAME != hr))
	{
	    _JumpErrorStr(hr, error, "DispatchSetup", pwszClass);
	}
	_PrintErrorStr2(hr, "DispatchSetup", pwszClass, hr);
    }

error:
    return(hr);
}


VOID
DispatchRelease(
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    if (NULL != pDispatchInterface->pDispatch)
    {
	pDispatchInterface->pDispatch->Release();
	pDispatchInterface->pDispatch = NULL;
    }
    if (NULL != pDispatchInterface->pUnknown)
    {
	pDispatchInterface->pUnknown->Release();
	pDispatchInterface->pUnknown = NULL;
    }
    if (NULL != pDispatchInterface->m_adispid)
    {
	LocalFree(pDispatchInterface->m_adispid);
	pDispatchInterface->m_adispid = NULL;
    }
}


BOOL
myConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb)
{
    HRESULT hr;
    BSTR bstr;

    do
    {
	bstr = NULL;
	if (NULL != pwc)
	{
	    if (-1 == cb)
	    {
		cb = wcslen(pwc) * sizeof(WCHAR);
	    }
	    bstr = SysAllocStringByteLen((char const *) pwc, cb);
	    if (NULL == bstr)
	    {
		hr = E_OUTOFMEMORY;
		break;
	    }
	}
	if (NULL != *pbstr)
	{
	    SysFreeString(*pbstr);
	}
	*pbstr = bstr;
	hr = S_OK;
    } while (FALSE);
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


BOOL
myConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch)
{
    HRESULT hr;
    BSTR bstr = NULL;
    LONG cwc = 0;

    if (-1 == cch)
    {
	cch = strlen(pch);
    }
    CSASSERT(0 != cch);
    while (TRUE)
    {
	cwc = MultiByteToWideChar(GetACP(), 0, pch, cch, bstr, cwc);
	if (0 >= cwc)
	{
	    hr = myHLastError();
	    _PrintError(hr, "MultiByteToWideChar");
	    if (NULL != bstr)
	    {
		SysFreeString(bstr);
	    }
	    break;
	}
	if (NULL != bstr)
	{
	    bstr[cwc] = L'\0';
	    if (NULL != *pbstr)
	    {
		SysFreeString(*pbstr);
	    }
	    *pbstr = bstr;
	    hr = S_OK;
	    break;
	}
	bstr = SysAllocStringLen(NULL, cwc);
	if (NULL == bstr)
	{
	    hr = E_OUTOFMEMORY;
	    break;
	}
    }
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


HRESULT
DecodeCertString(
    IN BSTR const bstrIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    DWORD dwSize;

    *ppbOut = NULL;

    CSASSERT(CR_IN_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CR_IN_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CR_IN_BINARY == CRYPT_STRING_BINARY);

    switch (Flags)
    {
	case CRYPT_STRING_BASE64HEADER:
	case CRYPT_STRING_BASE64:
	case CRYPT_STRING_BASE64REQUESTHEADER:
	case CRYPT_STRING_HEX:
	case CRYPT_STRING_HEXASCII:
	case CRYPT_STRING_BASE64_ANY:
	case CRYPT_STRING_HEX_ANY:
	case CRYPT_STRING_BASE64X509CRLHEADER:
	case CRYPT_STRING_HEXADDR:
	case CRYPT_STRING_HEXASCIIADDR:
	    CSASSERT(sizeof(WCHAR) * wcslen(bstrIn) == SysStringByteLen(bstrIn));
	    // FALLTHROUGH

	case CRYPT_STRING_ANY:
            dwSize = (SysStringByteLen(bstrIn) + sizeof(WCHAR) - 1) / sizeof(WCHAR);
            break;

	case CRYPT_STRING_BINARY:
            dwSize = SysStringByteLen(bstrIn);
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Flags");
    }
    hr = myCryptStringToBinary(
			bstrIn,
			dwSize,
			Flags,
			ppbOut,
			pcbOut,
			NULL,
			NULL);
    _JumpIfError(hr, error, "myCryptStringToBinary");

    if (CRYPT_STRING_ANY == Flags &&
	(SysStringByteLen(bstrIn) & (sizeof(WCHAR) - 1)))
    {
	(*pcbOut)--;
	CSASSERT(SysStringByteLen(bstrIn) == *pcbOut);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
EncodeCertString(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT BSTR *pbstrOut)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR *pwcCert = NULL;
    DWORD cbCert;
    BSTR strCert = NULL;

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CR_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CR_OUT_BINARY == CRYPT_STRING_BINARY);
    //CSASSERT(CR_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER);
    //CSASSERT(CR_OUT_HEX == CRYPT_STRING_HEX);

    CSASSERT(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CV_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CV_OUT_BINARY == CRYPT_STRING_BINARY);
    CSASSERT(CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER);
    CSASSERT(CV_OUT_HEX == CRYPT_STRING_HEX);
    CSASSERT(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII);
    CSASSERT(CV_OUT_BASE64X509CRLHEADER == CRYPT_STRING_BASE64X509CRLHEADER);
    CSASSERT(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR);
    CSASSERT(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR);

    if (NULL == pbIn || (~CR_OUT_ENCODEMASK & Flags))
    {
	goto error;
    }

    switch (CR_OUT_ENCODEMASK & Flags)
    {
	case CRYPT_STRING_BASE64HEADER:
	case CRYPT_STRING_BASE64:
	case CRYPT_STRING_BASE64REQUESTHEADER:
	case CRYPT_STRING_HEX:
	case CRYPT_STRING_HEXASCII:
	case CRYPT_STRING_BASE64X509CRLHEADER:
	case CRYPT_STRING_HEXADDR:
	case CRYPT_STRING_HEXASCIIADDR:
	    hr = myCryptBinaryToString(
                        pbIn,
                        cbIn,
                        CR_OUT_ENCODEMASK & Flags,
                        &pwcCert);
	    _JumpIfError(hr, error, "myCryptBinaryToString");

	    cbCert = sizeof(WCHAR) * wcslen(pwcCert);
	    break;

	case CRYPT_STRING_BINARY:
	    pwcCert = (WCHAR *) pbIn;
	    cbCert = cbIn;
	    hr = S_OK;
	    break;

	default:
	    goto error;
    }
    if (!ConvertWszToBstr(pbstrOut, pwcCert, cbCert))
    {
	hr = E_OUTOFMEMORY;
    }

    hr = S_OK;
error:
    if (NULL != pwcCert && pwcCert != (WCHAR *) pbIn)
    {
	LocalFree(pwcCert);
    }
    return(hr);
}


HRESULT
DispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    WCHAR *pwszText = NULL;

    if (NULL == pwszDescription)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL pointer");
    }
    CSASSERT(FAILED(hrError));
    pwszError = myGetErrorMessageText(hrError, TRUE);
    if (NULL == pwszError)
    {
	_PrintError(E_OUTOFMEMORY, "myGetErrorMessageText");
    }
    else
    {
	pwszText = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    (wcslen(pwszDescription) + 1 + wcslen(pwszError) + 1) *
	     sizeof(WCHAR));
	if (NULL == pwszText)
	{
	    _PrintError(E_OUTOFMEMORY, "LocalAlloc");
	}
	else
	{
	    wcscpy(pwszText, pwszDescription);
	    wcscat(pwszText, L" ");
	    wcscat(pwszText, pwszError);
	}
    }
    hr = DispatchSetErrorInfoSub(
			hrError,
			NULL,		// pwszIDispatchMethod
			NULL != pwszText?
			    pwszText : const_cast<WCHAR *>(pwszDescription),
			pwszProgId,
			piid,
			NULL,		// pwszHelpFile
			0);		// dwHelpFileContext
    _PrintIfError(hr, "DispatchSetErrorInfoSub");

error:
    if (NULL != pwszText)
    {
	LocalFree(pwszText);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hrError);	// return input error!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\csw97ppg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97ppg.cpp
//
//--------------------------------------------------------------------------

// csw97ppg.cpp : implementation file

#include <pch.cpp>

#pragma hdrstop

#include "prsht.h"
#include "csw97ppg.h"
//#include "resource.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage property page
//IMPLEMENT_DYNCREATE(CWizard97PropertyPage, CPropertyPage)

CWizard97PropertyPage::CWizard97PropertyPage() :
    PropertyPage(),
    m_pWiz(NULL)
{
    ASSERT(0); // default constructor - should never be called
}


CWizard97PropertyPage::CWizard97PropertyPage(
    HINSTANCE hInstance,
    UINT nIDTemplate,
    UINT rgnIDFont[CSW97PG_COUNT]) :
    PropertyPage(nIDTemplate),
    m_pWiz(NULL)
{
    //{{AFX_DATA_INIT(CWizard97PropertyPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hInstance = hInstance;
    CopyMemory(m_rgnIDFont, rgnIDFont, sizeof(m_rgnIDFont));
}


CWizard97PropertyPage::~CWizard97PropertyPage()
{
}


/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage message handlers

void
CWizard97PropertyPage::InitWizard97(
    bool bHideHeader)
{
    ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE));
    CopyMemory(&m_psp97, &m_psp, m_psp.dwSize);
    m_psp97.dwSize = sizeof(PROPSHEETPAGE);

    if (bHideHeader)
    {
	// for first and last page of the wizard
	m_psp97.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
	// for intermediate pages
	m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
	m_psp97.pszHeaderTitle = (LPCTSTR) m_szHeaderTitle;
	m_psp97.pszHeaderSubTitle = (LPCTSTR) m_szHeaderSubTitle;
    }
}


BOOL
CWizard97PropertyPage::SetupFonts()
{
    BOOL bReturn = FALSE;
    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
    LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
    // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;

    WCHAR	largeFontSizeString[24];
    INT		largeFontSize;
    WCHAR	smallFontSizeString[24];
    INT		smallFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if (!::LoadString(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDLARGEFONTNAME],
		BigBoldLogFont.lfFaceName,
		LF_FACESIZE)) 
    {
	ASSERT(0);
        lstrcpy(BigBoldLogFont.lfFaceName, L"MS Shell Dlg");
    }

    if (::LoadStringW(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDLARGEFONTSIZE],
		largeFontSizeString,
		ARRAYSIZE(largeFontSizeString))) 
    {
        largeFontSize = wcstoul(largeFontSizeString, NULL, 10);
    } 
    else 
    {
	ASSERT(0);
        largeFontSize = 12;
    }

    if (!::LoadString(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDSMALLFONTNAME],
		BoldLogFont.lfFaceName,
		LF_FACESIZE)) 
    {
		ASSERT(0);
        lstrcpy(BoldLogFont.lfFaceName, L"MS Shell Dlg");
    }

    if (::LoadStringW(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDSMALLFONTSIZE],
		smallFontSizeString,
		ARRAYSIZE(smallFontSizeString))) 
    {
        smallFontSize = wcstoul(smallFontSizeString, NULL, 10);
    } 
    else 
    {
	ASSERT(0);
        smallFontSize = 8;
    }

    HDC hdc = GetDC(m_hWnd);

    if (hdc)
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * largeFontSize / 72);
        BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * smallFontSize / 72);


        BOOL bBigBold = m_bigBoldFont.CreateFontIndirect(&BigBoldLogFont);
	BOOL bBold = m_boldFont.CreateFontIndirect(&BoldLogFont);

        ReleaseDC(m_hWnd, hdc);

        if (bBigBold && bBold)
	{
	    bReturn = TRUE;
	}
    }
    return bReturn;
}


HFONT
CWizard97PropertyPage::GetBoldFont()
{
    return m_boldFont;
}


HFONT
CWizard97PropertyPage::GetBigBoldFont()
{
    return m_bigBoldFont;
}



BOOL CWizard97PropertyPage::OnInitDialog() 
{
    PropertyPage::OnInitDialog();
	
    SetupFonts();
	
    return TRUE;  // return TRUE unless you set the focus to a control
		  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\cscsp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cscsp.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>
#include "initcert.h"
#include "cscsp.h"
#include "csdisp.h"

TCHAR const g_wszRegKeyCSP[] = wszREGKEYCSP;
TCHAR const g_wszRegKeyEncryptionCSP[] = wszREGKEYENCRYPTIONCSP;
TCHAR const g_wszRegProviderType[] = wszREGPROVIDERTYPE;
TCHAR const g_wszRegProvider[] = wszREGPROVIDER;
TCHAR const g_wszRegHashAlgorithm[] = wszHASHALGORITHM;
TCHAR const g_wszRegEncryptionAlgorithm[] = wszENCRYPTIONALGORITHM;
TCHAR const g_wszRegMachineKeyset[] = wszMACHINEKEYSET;
TCHAR const g_wszRegKeySize[] = wszREGKEYSIZE;


BOOL
myCertSrvCryptAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvider,
    IN DWORD        dwProvType,
    IN DWORD        dwFlags,
    IN BOOL         fMachineKeyset)
{
    HRESULT hr;

    if (fMachineKeyset)
    {
        dwFlags |= CRYPT_MACHINE_KEYSET;
    }
    if (!CryptAcquireContext(
			phProv,
			pwszContainer,
			pwszProvider,
			dwProvType,
			dwFlags))
    {
	hr = myHLastError();
	_JumpErrorStr2(
	    hr,
	    error,
	    (CRYPT_MACHINE_KEYSET & dwFlags)?
		"CryptAcquireContext(Machine)" : "CryptAcquireContext(User)",
	    pwszContainer,
	    (CRYPT_DELETEKEYSET & dwFlags)? hr : S_OK);
    }
    hr = S_OK;
          
error:
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


HRESULT
myGetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *pdwProvType,
    OUT WCHAR **ppwszProvName,
    OUT ALG_ID *pidAlg,
    OUT BOOL *pfMachineKeyset,
    OPTIONAL OUT DWORD *pdwKeySize)
{
    HRESULT hr;
    HKEY    hCertSrvCSPKey = NULL;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    WCHAR  *pwszPath = NULL;
    WCHAR  *pwszProvName = NULL;
    WCHAR const *pwszRegKeyCSP;
    DWORD cwc;
    
    if (NULL != ppwszProvName)
    {
	*ppwszProvName = NULL;
    }
    if (NULL != pdwKeySize)
    {
	*pdwKeySize = 0;
    }
    if (NULL == pwszSanitizedCAName ||
	NULL == pdwProvType ||
	NULL == ppwszProvName ||
	NULL == pidAlg ||
	NULL == pfMachineKeyset)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    pwszRegKeyCSP = fEncryptionCSP? g_wszRegKeyEncryptionCSP : g_wszRegKeyCSP;
    cwc = WSZARRAYSIZE(wszREGKEYCONFIGPATH_BS) +
	    wcslen(pwszSanitizedCAName) +
	    1 +
	    wcslen(pwszRegKeyCSP);
    pwszPath = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszPath)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszPath, wszREGKEYCONFIGPATH_BS);
    wcscat(pwszPath, pwszSanitizedCAName);
    wcscat(pwszPath, L"\\");
    wcscat(pwszPath, pwszRegKeyCSP);
    CSASSERT(cwc == wcslen(pwszPath));

    hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		pwszPath,
		0,
		KEY_ALL_ACCESS,
		&hCertSrvCSPKey);
    _JumpIfErrorStr2(hr, error, "RegOpenKeyEx", pwszPath, ERROR_FILE_NOT_FOUND);

    dwValueSize = 0;
    hr = RegQueryValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProvider,
		    0,
		    &dwValueType,
		    NULL,
		    &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_SZ != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    pwszProvName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    dwValueSize + sizeof(WCHAR));
    if (NULL == pwszProvName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    hr = RegQueryValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProvider,
		    0,
		    &dwValueType,
		    (BYTE *) pwszProvName,
		    &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    pwszProvName[dwValueSize / sizeof(WCHAR)] = L'\0';


    dwValueSize = sizeof(*pdwProvType);
    hr = RegQueryValueEx(hCertSrvCSPKey,
                          g_wszRegProviderType,
                          0,
                          &dwValueType,
                          (BYTE *) pdwProvType,
                          &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_DWORD != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    dwValueSize = sizeof(*pidAlg);
    hr = RegQueryValueEx(
		    hCertSrvCSPKey,
		    fEncryptionCSP? 
			g_wszRegEncryptionAlgorithm :
			g_wszRegHashAlgorithm,
		    0,
		    &dwValueType,
		    (BYTE *) pidAlg,
		    &dwValueSize);
    if (S_OK != hr && fEncryptionCSP)
    {
	_PrintErrorStr2(
		    hr,
		    "RegQueryValueEx",
		    g_wszRegEncryptionAlgorithm,
		    ERROR_FILE_NOT_FOUND);
	dwValueSize = sizeof(*pidAlg);
	hr = RegQueryValueEx(
			hCertSrvCSPKey,
			g_wszRegHashAlgorithm,
			0,
			&dwValueType,
			(BYTE *) pidAlg,
			&dwValueSize);
    }
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_DWORD != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    dwValueSize = sizeof(*pfMachineKeyset);
    hr = RegQueryValueEx(hCertSrvCSPKey,
                          g_wszRegMachineKeyset,
                          0,
                          &dwValueType,
                          (BYTE *) pfMachineKeyset,
                          &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_DWORD != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    if (NULL != pdwKeySize)
    {
	dwValueSize = sizeof(*pdwKeySize);
	hr = RegQueryValueEx(hCertSrvCSPKey,
			      g_wszRegKeySize,
			      0,
			      &dwValueType,
			      (BYTE *) pdwKeySize,
			      &dwValueSize);
	_JumpIfError(hr, error, "RegQueryValueEx");

	if (REG_DWORD != dwValueType)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Invalid reg type");
	}
    }

    *ppwszProvName = pwszProvName;
    pwszProvName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    if (NULL != hCertSrvCSPKey)
    {
        RegCloseKey(hCertSrvCSPKey);
    }
    return(myHError(hr));
}


//+------------------------------------------------------------------------
//
//  Function:   myGetSigningOID( . . . . )
//
//  Synopsis:   Determine algorithm identifer for cert creation
//  Arguments:  csp_provider_type, hash_algorithm_id.
//  Returns:    object identifier
//
//-------------------------------------------------------------------------

HRESULT
myGetSigningOID(
    OPTIONAL IN HCRYPTPROV hProv,	// hProv OR pwszProvName & dwProvType
    OPTIONAL IN WCHAR const *pwszProvName,
    OPTIONAL IN DWORD dwProvType,
    IN ALG_ID idHashAlg,
    OUT CHAR **ppszAlgId)
{
    HRESULT  hr;

    PCCRYPT_OID_INFO pcOIDInfo; //don't free it
    ALG_ID      aidAlgKey[] = {idHashAlg, 0};
    HCRYPTPROV  hProvT = NULL;
    int         i;
    DWORD       dwFlags;
    DWORD       cbData;
    PROV_ENUMALGS enumalgs;
    BOOL        fFoundSignID = FALSE;

    *ppszAlgId = NULL;
    if (NULL == hProv)
    {
	CSASSERT(NULL != pwszProvName);

	if (!myCertSrvCryptAcquireContext(
				&hProvT,
				NULL,
				pwszProvName,
				dwProvType,
				CRYPT_VERIFYCONTEXT,
				FALSE))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
	}
	hProv = hProvT;
    }

    // find public key id

    dwFlags = CRYPT_FIRST;
    for (i = 0; ; i++)
    {
        cbData = sizeof(enumalgs);
        if (!CryptGetProvParam(
			    hProv,
			    PP_ENUMALGS,
			    (BYTE *) &enumalgs,
			    &cbData,
			    dwFlags))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                // out of for loop
                break;
            }
	    _JumpError(hr, error, "CryptGetProvParam");
        }
        if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(enumalgs.aiAlgid))
        {
            fFoundSignID = TRUE;
            aidAlgKey[1] = enumalgs.aiAlgid;
            break;
        }
	dwFlags = 0;
    }

    if (fFoundSignID)
    {
        pcOIDInfo = CryptFindOIDInfo(
                        CRYPT_OID_INFO_SIGN_KEY,
                        aidAlgKey,
                        CRYPT_SIGN_ALG_OID_GROUP_ID); // only signing
        if (NULL == pcOIDInfo)
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "unsupported signing algorithm");
        }
	hr = myDupStringA(pcOIDInfo->pszOID, ppszAlgId);
	_JumpIfError(hr, error, "myDupStringA");
    }
    hr = S_OK;

error:
    if (NULL != hProvT)
    {
        CryptReleaseContext(hProvT, 0);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myValidateKeyForSigning(
    IN HCRYPTPROV hProv,
    OPTIONAL IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId)
{
    HRESULT hr;
    BYTE abRandom[64];
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;

    // create a supported hash
    if (!CryptCreateHash(hProv, algId, 0, 0, &hHash))
    {
        hr = myHLastError();
	DBGPRINT((DBG_SS_ERROR, "algId = %x\n", algId));
        _JumpError(hr, error, "CryptCreateHash");
    }
    // create some random data
    if (!CryptGenRandom(hProv, ARRAYSIZE(abRandom), abRandom))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }
    if (!CryptHashData(hHash, abRandom, ARRAYSIZE(abRandom), 0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptHashData");
    }
    // sign the hash, get size first
    if (!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignHash");
    }
    pbSignature = (BYTE *) LocalAlloc(LMEM_FIXED, cbSignature);
    if (NULL == pbSignature)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    if (!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignHash");
    }

    if (NULL != pPublicKeyInfo)
    {
	// import public key into provider

	if (!CryptImportPublicKeyInfo(
			hProv,
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			&hKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptImportPublicKeyInfo");
	}
    }
    else
    {
        // get public key from container

        if (!CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptGetUserKey");
        }
    }

    if (!CryptVerifySignature(hHash, pbSignature, cbSignature, hKey, NULL, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptVerifySignature");
    }
    hr = S_OK;

error:
    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != pbSignature)
    {
        LocalFree(pbSignature);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myValidateKeyForEncrypting(
    IN HCRYPTPROV hProv,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId)
{
    HRESULT hr;
    HCRYPTKEY hKeyPub = NULL;
    HCRYPTKEY hKeySym = NULL;
    HCRYPTKEY hKeyPri = NULL;
    BYTE *pbKeySym = NULL;
    DWORD cbKeySym;
    BYTE abRandom[64];
    BYTE *pbEncrypted = NULL;
    BYTE *pbDecrypted = NULL;
    DWORD cbEncrypted;
    DWORD cbDecrypted;

    // import public key into provider

    if (!CryptImportPublicKeyInfo(
			hProv,
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			&hKeyPub))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportPublicKeyInfo");
    }

    // Generate a default sized symmetric session key

    if (!CryptGenKey(hProv, algId, CRYPT_EXPORTABLE, &hKeySym))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenKey");
    }

    // create some random data

    if (!CryptGenRandom(hProv, ARRAYSIZE(abRandom), abRandom))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }
#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "Plain text size = %d\n", ARRAYSIZE(abRandom)));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	abRandom,
	ARRAYSIZE(abRandom)));
#endif
    hr = myCryptEncrypt(
		    hKeySym,
		    abRandom,
		    ARRAYSIZE(abRandom),
		    &pbEncrypted,
		    &cbEncrypted);
    _JumpIfError(hr, error, "myCryptEncrypt");

#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "Encrypted size = %d\n", cbEncrypted));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pbEncrypted,
	cbEncrypted));
#endif

    hr = myCryptExportKey(hKeySym, hKeyPub, SIMPLEBLOB, 0, &pbKeySym, &cbKeySym);
    _JumpIfError(hr, error, "myCryptExportKey");

    CryptDestroyKey(hKeySym);
    hKeySym = NULL;

#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "SIMPLEBLOB:\n"));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pbKeySym,
	cbKeySym));
#endif

    // get private key from container and import session key blob

    if (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKeyPri))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetUserKey");
    }
    if (!CryptImportKey(
		    hProv,
		    pbKeySym,
		    cbKeySym,
		    hKeyPri,
		    CRYPT_EXPORTABLE,
		    &hKeySym))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }
    hr = myCryptDecrypt(
		    hKeySym,
		    pbEncrypted,
		    cbEncrypted,
		    &pbDecrypted,
		    &cbDecrypted);
    _JumpIfError(hr, error, "myCryptDecrypt");

#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "Decrypted size = %d\n", cbDecrypted));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pbDecrypted,
	cbDecrypted));
#endif

    if (ARRAYSIZE(abRandom) != cbDecrypted ||
	0 != memcmp(abRandom, pbDecrypted, ARRAYSIZE(abRandom)))
    {
	hr = NTE_BAD_KEY;
	_JumpIfError(hr, error, "Decrypted data mismatch");
    }
    hr = S_OK;

error:
    if (NULL != hKeyPub)
    {
        CryptDestroyKey(hKeyPub);
    }
    if (NULL != hKeySym)
    {
        CryptDestroyKey(hKeySym);
    }
    if (NULL != hKeyPri)
    {
        CryptDestroyKey(hKeyPri);
    }
    if (NULL != pbEncrypted)
    {
	LocalFree(pbEncrypted);
    }
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    if (NULL != pbKeySym)
    {
	LocalFree(pbKeySym);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myValidateHashForSigning(
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvName,
    IN DWORD dwProvType,
    IN BOOL fMachineKeyset,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;

    // get private key handler
    if (!myCertSrvCryptAcquireContext(
			       &hProv,
			       pwszContainer,
			       pwszProvName,
			       dwProvType,
			       0,
			       fMachineKeyset))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    hr = myValidateKeyForSigning(hProv, pPublicKeyInfo, algId);
    _JumpIfError(hr, error, "myValidateKeyForSigning");

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
GenerateTemporaryContainerName(
    OUT WCHAR **ppwszKeyContainerName)
{
    HRESULT hr;
    GUID guid;
    WCHAR awcbuf[MAX_PATH];
    DWORD cb;
    DWORD cwc;

    myGenerateGuidSerialNumber(&guid);

    wcscpy(awcbuf, L"KeyVerification--");
    cwc = wcslen(awcbuf);
    cb = sizeof(awcbuf) - cwc * sizeof(WCHAR);
    hr = MultiByteIntegerToWszBuf(
			FALSE,
			sizeof(guid),
			(BYTE const *) &guid,
			&cb,
			&awcbuf[cwc]);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    hr = myDupString(awcbuf, ppwszKeyContainerName);
    _JumpIfError(hr, error, "myDupString");

error:
    return(hr);
}


VOID
DeleteRSAKeyContainer(
    IN WCHAR const *pwszKeyContainerName,
    IN BOOL fMachineKeyset)
{
    HCRYPTPROV hProv;
    DWORD dwFlags = CRYPT_DELETEKEYSET;

    if (fMachineKeyset)
    {
        dwFlags = CRYPT_MACHINE_KEYSET;
    }
    CryptAcquireContext(
		    &hProv,
		    pwszKeyContainerName,
		    NULL,		// pwszProvName
		    PROV_RSA_FULL,
		    dwFlags);
}


HRESULT
myValidateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN BOOL fV1Cert,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO *pkpi)
{
    HRESULT hr;
    WCHAR *pwszKeyContainerName = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    CRYPT_KEY_PROV_INFO kpi;
    BOOL fMatchingKey;
    WCHAR wszPassword[MAX_PATH];

    hr = GenerateTemporaryContainerName(&pwszKeyContainerName);
    _JumpIfError(hr, error, "GenerateTemporaryContainerName");

    DeleteRSAKeyContainer(pwszKeyContainerName, FALSE);

    DBGPRINT((DBG_SS_CERTLIBI, "Key Container: %ws\n", pwszKeyContainerName));

    if (!CryptAcquireContext(
			&hProv,
			pwszKeyContainerName,
			NULL,
			PROV_RSA_FULL,
			CRYPT_NEWKEYSET))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (!CryptImportKey(
		    hProv,
		    pbKey,
		    cbKey,
		    NULL,		// hPubKey
		    CRYPT_EXPORTABLE,
		    &hKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }
    CryptDestroyKey(hKey);
    hKey = NULL;

    ZeroMemory(&kpi, sizeof(kpi));
    kpi.pwszContainerName = pwszKeyContainerName;
    kpi.dwProvType = PROV_RSA_FULL;
    kpi.dwKeySpec = AT_KEYEXCHANGE;
    if (!CryptGetUserKey(hProv, kpi.dwKeySpec, &hKey))
    {
	hr = myHLastError();
	_PrintIfError2(hr, "CryptGetUserKey", hr);

	kpi.dwKeySpec = AT_SIGNATURE;
	if (!CryptGetUserKey(hProv, kpi.dwKeySpec, &hKey))
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "CryptGetUserKey");
	}
    }
    CryptDestroyKey(hKey);
    hKey = NULL;

    CryptReleaseContext(hProv, 0);
    hProv = NULL;

    if (!CryptAcquireContext(
			&hProv,
			pwszKeyContainerName,
			NULL,
			PROV_RSA_FULL,
			0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    if (AT_SIGNATURE == kpi.dwKeySpec)
    {
	hr = myValidateKeyForSigning(hProv, pPublicKeyInfo, CALG_SHA1);
	_PrintIfError(hr, "myValidateKeyForSigning");
    }
    else
    {
	hr = myValidateKeyForEncrypting(hProv, pPublicKeyInfo, CALG_RC4);
	_PrintIfError(hr, "myValidateKeyForEncrypting");
    }
    if (S_OK != hr)
    {
	_JumpError(hr, error, "Key Validation");
    }

    hr = myVerifyPublicKey(
		    NULL,		// pCert
		    fV1Cert,
		    &kpi,		// pKeyProvInfo
		    pPublicKeyInfo,	// pPublicKeyInfo
		    &fMatchingKey);
    if (S_OK != hr)
    {
	_JumpError(hr, error, "myVerifyPublicKey");
    }
    if (!fMatchingKey)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Key doesn't match cert");
    }
    if (NULL != pkpi)
    {
	*pkpi = kpi;
	pwszKeyContainerName = NULL;
    }

error:
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszKeyContainerName)
    {
	DeleteRSAKeyContainer(pwszKeyContainerName, FALSE);
	LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


/*
 *      myEnumProviders
 *
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT ppwszProvName  - Name of the enumerated provider
 */

HRESULT
myEnumProviders(
    IN DWORD dwIndex,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    OUT DWORD *pdwProvType,
    OUT WCHAR **ppwszProvName)
{
    HRESULT hr;
    char *pszProvName = NULL;
    DWORD cbProvName;

    *ppwszProvName = NULL;
    
    while (TRUE)
    {
	if (!CryptEnumProvidersA(
			dwIndex,
			pdwReserved,
			dwFlags,
			pdwProvType,
			pszProvName,
			&cbProvName))
	{
	    hr = myHLastError();
	    _JumpError2(hr, error, "CryptEnumProvidersA", hr);
	}
	if (NULL != pszProvName)
	{
	    break;
	}

        // allocate ansi string buffer

        pszProvName = (char *) LocalAlloc(LMEM_FIXED, cbProvName);
        if (NULL == pszProvName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }

    if (!myConvertSzToWsz(ppwszProvName, pszProvName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }
    hr = S_OK;

error:
    if (NULL != pszProvName)
    {
        LocalFree(pszProvName);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\exitdisp.cpp ===
#include <pch.cpp>
#pragma hdrstop
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__      __dwFILE_CERTLIB_EXITDISP_CPP__


//+------------------------------------------------------------------------
// ICertExit dispatch support

//+------------------------------------
// Initialize method:

OLECHAR *exit_apszInitialize[] = {
    TEXT("Initialize"),
    TEXT("strConfig"),
};

//+------------------------------------
// Notify method:

OLECHAR *exit_apszNotify[] = {
    TEXT("Notify"),
    TEXT("ExitEvent"),
    TEXT("Context"),
};

//+------------------------------------
// GetDescription method:

OLECHAR *exit_apszGetDescription[] = {
    TEXT("GetDescription"),
};

//+------------------------------------
// GetManageModule method:

OLECHAR *exit_apszGetManageModule[] = {
    TEXT("GetManageModule"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtExit[] =
{
    DECLARE_DISPATCH_ENTRY(exit_apszInitialize)
    DECLARE_DISPATCH_ENTRY(exit_apszNotify)
    DECLARE_DISPATCH_ENTRY(exit_apszGetDescription)
    DECLARE_DISPATCH_ENTRY(exit_apszGetManageModule)
};
DWORD CEXITDISPATCH		(ARRAYSIZE(g_adtExit));


DWORD s_acExitDispatch[] = {
    CEXITDISPATCH_V2,
    CEXITDISPATCH_V1,
};

IID const *s_apExitiid[] = {
    &IID_ICertExit2,
    &IID_ICertExit,
};


HRESULT
Exit_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdi)
{
    HRESULT hr;

    hr = DispatchSetup2(
                Flags,
                CLSCTX_INPROC_SERVER,
                pcwszProgID, // g_wszRegKeyCIPolicyClsid,
                pclsid,
                ARRAYSIZE(s_acExitDispatch),
                s_apExitiid,
                s_acExitDispatch,
                g_adtExit,
                pdi);
    _JumpIfError(hr, error, "DispatchSetup");

    pdi->pDispatchTable = g_adtPolicy;

error:
    return(hr);
}


VOID
Exit_Release(
    IN OUT DISPATCHINTERFACE *pdiManage)
{
    DispatchRelease(pdiManage);
}


HRESULT
ExitVerifyVersion(
    IN DISPATCHINTERFACE *pdiExit,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiExit && NULL != pdiExit->pDispatchTable);

    switch (pdiExit->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiExit->pDispatch ||
		CEXITDISPATCH_V1 == pdiExit->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiExit->pDispatch ||
		CEXITDISPATCH_V2 == pdiExit->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiExit->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Exit_Initialize(
    IN DISPATCHINTERFACE *pdiExit,
    IN BSTR strDescription,
    IN WCHAR const *pwszConfig,
    OUT LONG *pEventMask)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    __try
    {
	if (NULL != pdiExit->pDispatch)
	{
	    VARIANT avar[1];

	    CSASSERT(NULL != pdiExit->pDispatchTable);
	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;

	    hr = DispatchInvoke(
			    pdiExit,
			    EXIT_INITIALIZE,
			    ARRAYSIZE(avar),
			    avar,
			    VT_I4,
			    pEventMask);
	    _JumpIfError(hr, error, "Invoke(Initialize)");
	}
	else
	{
	    hr = ((ICertExit *) pdiExit->pUnknown)->Initialize(
							    strConfig,
							    pEventMask);
	    _JumpIfError(hr, error, "ICertExit::Initialize");
	}
    }
    _finally
    {
	if (NULL != strConfig)
	{
	    SysFreeString(strConfig);
	}
    }

error:
    return(hr);
}


HRESULT
Exit_Notify(
    IN DISPATCHINTERFACE *pdiExit,
    IN BSTR strDescription,
    IN LONG ExitEvent,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL != pdiExit->pDispatch)
    {
	VARIANT avar[2];

	CSASSERT(NULL != pdiExit->pDispatchTable);
	avar[0].vt = VT_I4;
	avar[0].lVal = ExitEvent;
	avar[1].vt = VT_I4;
	avar[1].lVal = Context;

	hr = DispatchInvoke(
			pdiExit,
			EXIT_NOTIFY,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Notify)");
    }
    else
    {
	hr = ((ICertExit *) pdiExit->pUnknown)->Notify(ExitEvent, Context);
	_JumpIfError(hr, error, "ICertExit::Notify");
    }

error:
    return(hr);
}


HRESULT
Exit_GetDescription(
    IN DISPATCHINTERFACE *pdiExit,
    OUT BSTR *pstrDescription)
{
    HRESULT hr;

    if (NULL != pdiExit->pDispatch)
    {
	CSASSERT(NULL != pdiExit->pDispatchTable);

	hr = DispatchInvoke(
			pdiExit,
			EXIT_GETDESCRIPTION,
			0,
			NULL,
			VT_BSTR,
			pstrDescription);
	_JumpIfError(hr, error, "Invoke(GetDescription)");
    }
    else
    {
	hr = ((ICertExit *) pdiExit->pUnknown)->GetDescription(pstrDescription);
	_JumpIfError(hr, error, "ICertExit::GetDescription");
    }

error:
    return(hr);
}


HRESULT
Exit2_GetManageModule(
    IN DISPATCHINTERFACE *pdiExit,
    OUT DISPATCHINTERFACE *pdiManageModule)
{
    HRESULT hr;
    ICertManageModule *pManageModule = NULL;

    hr = ExitVerifyVersion(pdiExit, 2);
    _JumpIfError(hr, error, "ExitVerifyVersion");

    if (NULL != pdiExit->pDispatch)
    {
	CSASSERT(NULL != pdiExit->pDispatchTable);

	hr = DispatchInvoke(
			pdiExit,
			EXIT2_GETMANAGEMODULE,
			0,
			NULL,
			VT_DISPATCH,
			&pManageModule);
	_JumpIfError(hr, error, "Invoke(GetManageModule)");
    }
    else
    {
	hr = ((ICertExit2 *) pdiExit->pUnknown)->GetManageModule(
							&pManageModule);
	_JumpIfError(hr, error, "ICertExit::GetManageModule");
    }

    hr = ManageModule_Init2(
		NULL != pdiExit->pDispatch,
		pManageModule,
		pdiManageModule);
    _JumpIfError(hr, error, "ManageModule_Init2");

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\keygen.h ===
/***************************************************/
/* Copyright (C) Microsoft Corporation, 1996 - 1999*/
/***************************************************/
/* Abstract syntax: keygen */
/* Created: Mon Jan 27 13:51:10 1997 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -listingfile keygen.lst -noshortennames -1990 -noconstraints
 */

#ifndef OSS_keygen
#define OSS_keygen

#include "asn1hdr.h"
#include "asn1code.h"

#define          RSAPublicKey_PDU 1
#define          SubjectPublicKeyInfo_PDU 2
#define          SignedContent_PDU 3
#define          SignedPublicKeyAndChallenge_PDU 4

typedef struct ObjectID {
    unsigned short  count;
    unsigned long   value[16];
} ObjectID;

typedef struct HUGEINTEGER {
    unsigned int    length;
    unsigned char   *value;
} HUGEINTEGER;

typedef struct BITSTRING {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} BITSTRING;

typedef struct IA5STRING {
    unsigned int    length;
    char            *value;
} IA5STRING;

typedef struct AlgorithmIdentifier {
    unsigned char   bit_mask;
#       define      parameters_present 0x80
    ObjectID        algorithm;
    OpenType        parameters;  /* optional */
} AlgorithmIdentifier;

typedef struct RSAPublicKey {
    HUGEINTEGER     modulus;
    int             publicExponent;
} RSAPublicKey;

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    BITSTRING       subjectPublicKey;
} SubjectPublicKeyInfo;

typedef struct SignedContent {
    OpenType        toBeSigned;
    AlgorithmIdentifier algorithm;
    BITSTRING       signature;
} SignedContent;

typedef struct PublicKeyAndChallenge {
    SubjectPublicKeyInfo spki;
    IA5STRING       challenge;
} PublicKeyAndChallenge;

typedef struct _bit1 {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} _bit1;

typedef struct SignedPublicKeyAndChallenge {
    PublicKeyAndChallenge publicKeyAndChallenge;
    AlgorithmIdentifier signatureAlgorithm;
    _bit1           signature;
} SignedPublicKeyAndChallenge;


extern void *keygen;    /* encoder-decoder control table */
#endif /* OSS_keygen */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\inf.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        inf.cpp
//
// Contents:    Cert Server INF file processing routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certca.h>

#include "csdisp.h"
#include "initcert.h"
#include "clibres.h"

#define __dwFILE__	__dwFILE_CERTLIB_INF_CPP__

#define wszBSCAPOLICYFILE	L"\\" wszCAPOLICYFILE
#define wszINFKEY_CONTINUE	L"_continue_"

#define cwcVALUEMAX		1024

static WCHAR *s_pwszSection = NULL;
static WCHAR *s_pwszKey = NULL;
static WCHAR *s_pwszValue = NULL;


VOID
infClearString(
    IN OUT WCHAR **ppwsz)
{
    if (NULL != ppwsz && NULL != *ppwsz)
    {
	LocalFree(*ppwsz);
	*ppwsz = NULL;
    }
}


BOOL
infCopyString(
    OPTIONAL IN WCHAR const *pwszIn,
    OPTIONAL OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    
    if (NULL != pwszIn && L'\0' != *pwszIn)
    {
	if (NULL == *ppwszOut)
	{
	    if (NULL != *ppwszOut)
	    {
		LocalFree(*ppwszOut);
		*ppwszOut = NULL;
	    }
	    hr = myDupString(pwszIn, ppwszOut);
	    _JumpIfError(hr, error, "myDupString");
	}
    }
    hr = S_OK;

error:
    return(S_OK == hr);
}


#define INFSTRINGSELECT(pwsz)	(NULL != (pwsz)? (pwsz) : L"")

#if DBG_CERTSRV
# define INFSETERROR(hr, pwszSection, pwszKey, pwszValue) \
    { \
	_PrintError3(hr, "infSetError", ERROR_LINE_NOT_FOUND, S_FALSE); \
	infSetError(hr, pwszSection, pwszKey, pwszValue, __LINE__); \
    }
#else
# define INFSETERROR infSetError
#endif


VOID
infSetError(
    IN HRESULT hr,
    OPTIONAL IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszKey,
    OPTIONAL IN WCHAR const *pwszValue
    DBGPARM(IN DWORD dwLine))
{
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"inf.cpp(%u): infSetError Begin: [%ws] %ws = %ws\n",
	dwLine,
	INFSTRINGSELECT(pwszSection),
	INFSTRINGSELECT(pwszKey),
	INFSTRINGSELECT(pwszValue)));
    infCopyString(pwszSection, &s_pwszSection);
    infCopyString(pwszKey, &s_pwszKey);
    infCopyString(pwszValue, &s_pwszValue);
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"inf.cpp(%u): infSetError End:   [%ws] %ws = %ws\n",
	dwLine,
	INFSTRINGSELECT(s_pwszSection),
	INFSTRINGSELECT(s_pwszKey),
	INFSTRINGSELECT(s_pwszValue)));
}


WCHAR *
myInfGetError()
{
    DWORD cwc = 1;
    WCHAR *pwsz = NULL;
    
    if (NULL != s_pwszSection)
    {
	cwc += wcslen(s_pwszSection) + 2;
    }
    if (NULL != s_pwszKey)
    {
	cwc += wcslen(s_pwszKey) + 1;
    }
    if (NULL != s_pwszValue)
    {
	cwc += wcslen(s_pwszValue) + 3;
    }
    if (1 == cwc)
    {
	goto error;
    }
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	goto error;
    }
    *pwsz = L'\0';
    if (NULL != s_pwszSection)
    {
	wcscat(pwsz, wszLBRACKET);
	wcscat(pwsz, s_pwszSection);
	wcscat(pwsz, wszRBRACKET);
    }
    if (NULL != s_pwszKey)
    {
	if (L'\0' != *pwsz)
	{
	    wcscat(pwsz, L" ");
	}
	wcscat(pwsz, s_pwszKey);
    }
    if (NULL != s_pwszValue)
    {
	wcscat(pwsz, L" = ");
	wcscat(pwsz, s_pwszValue);
    }
error:
    return(pwsz);
}


VOID
myInfClearError()
{
    infClearString(&s_pwszSection);
    infClearString(&s_pwszKey);
    infClearString(&s_pwszValue);
}


HRESULT
infSetupFindFirstLine(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszKey,
    OUT INFCONTEXT *pInfContext)
{
    HRESULT hr;
    
    if (!SetupFindFirstLine(hInf, pwszSection, pwszKey, pInfContext))
    {
        hr = myHLastError();
	if ((HRESULT) ERROR_LINE_NOT_FOUND == hr &&
	    SetupFindFirstLine(hInf, pwszSection, wszINFKEY_EMPTY, pInfContext))
	{
	    hr = S_FALSE;	// Section exists, but Key doesn't
	}
        _JumpErrorStr3(
		hr,
		error,
		"SetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
infBuildPolicyElement(
    IN OUT INFCONTEXT *pInfContext,
    OPTIONAL OUT CERT_POLICY_QUALIFIER_INFO *pcpqi)
{
    HRESULT hr;
    DWORD i;
    WCHAR wszKey[MAX_PATH];
    BOOL fURL = FALSE;
    BOOL fNotice = FALSE;
    DWORD cwc;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszURL = NULL;
    BYTE *pbData = NULL;
    DWORD cbData;

    wszKey[0] = L'\0';
    if (!SetupGetStringField(
			pInfContext,
			0,
			wszKey,
			ARRAYSIZE(wszKey),
			NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SetupGetStringField");
    }
    DBGPRINT((DBG_SS_CERTLIBI, "Element = %ws\n", wszKey));

    if (0 == lstrcmpi(wszINFKEY_URL, wszKey))
    {
	fURL = TRUE;
    }
    else
    if (0 == lstrcmpi(wszINFKEY_NOTICE, wszKey))
    {
	fNotice = TRUE;
    }
    else
    {
	if (0 != lstrcmpi(wszINFKEY_OID, wszKey))
	{
	    _PrintErrorStr(E_INVALIDARG, "Skipping unknown key", wszKey);
	}
	hr = S_FALSE;		// Skip this key
    }
    if (fURL || fNotice)
    {
	if (!SetupGetStringField(pInfContext, 1, NULL, 0, &cwc))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}
	pwszValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	if (!SetupGetStringField(pInfContext, 1, pwszValue, cwc, NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}
	DBGPRINT((DBG_SS_CERTLIBI, "SetupGetStringField = %ws\n", pwszValue));

	if (fURL)
	{
	    CERT_NAME_VALUE NameValue;

	    hr = myInternetCanonicalizeUrl(pwszValue, &pwszURL);
	    _JumpIfError(hr, error, "myInternetCanonicalizeUrl");

	    NameValue.dwValueType = CERT_RDN_IA5_STRING;
	    NameValue.Value.pbData = (BYTE *) pwszURL;
	    NameValue.Value.cbData = 0;

	    if (NULL != pcpqi)
	    {
		CSILOG(S_OK, IDS_ILOG_CAPOLICY_ELEMENT, pwszURL, NULL, NULL);
	    }

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_NAME_VALUE,
			    &NameValue,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pbData,
			    &cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	}
	else
	{
	    CERT_POLICY_QUALIFIER_USER_NOTICE UserNotice;

	    ZeroMemory(&UserNotice, sizeof(UserNotice));
	    UserNotice.pszDisplayText = pwszValue;

	    if (NULL != pcpqi)
	    {
		CSILOG(S_OK, IDS_ILOG_CAPOLICY_ELEMENT, pwszValue, NULL, NULL);
	    }

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_PKIX_POLICY_QUALIFIER_USERNOTICE,
			    &UserNotice,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pbData,
			    &cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	}
	if (NULL != pcpqi)
	{
	    pcpqi->pszPolicyQualifierId = fURL?
		szOID_PKIX_POLICY_QUALIFIER_CPS :
		szOID_PKIX_POLICY_QUALIFIER_USERNOTICE;
	    pcpqi->Qualifier.pbData = pbData;
	    pcpqi->Qualifier.cbData = cbData;
	    pbData = NULL;
	}
	hr = S_OK;
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, NULL, wszKey, pwszValue);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


HRESULT
infBuildPolicy(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN OUT CERT_POLICY_INFO *pcpi)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    DWORD i;
    WCHAR wszValue[cwcVALUEMAX];

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    wszValue[0] = L'\0';
    hr = infSetupFindFirstLine(hInf, pwszSection, wszINFKEY_OID, &InfContext);
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, wszINFKEY_OID, NULL);
        _JumpErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);
    }
    if (!SetupGetStringField(
			&InfContext,
			1,
			wszValue,
			ARRAYSIZE(wszValue),
			NULL))
    {
	hr = myHLastError();
	INFSETERROR(hr, NULL, wszINFKEY_OID, NULL);
	_JumpError(hr, error, "SetupGetStringField");
    }

    if (!ConvertWszToSz(&pcpi->pszPolicyIdentifier, wszValue, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "ConvertWszToSz");
    }
    DBGPRINT((DBG_SS_CERTLIBI, "OID = %hs\n", pcpi->pszPolicyIdentifier));

    hr = infSetupFindFirstLine(hInf, pwszSection, NULL, &InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    for (i = 0; ; )
    {
	hr = infBuildPolicyElement(&InfContext, NULL);
	if (S_FALSE != hr)
	{
	    _JumpIfErrorStr(hr, error, "infBuildPolicyElement", pwszSection);

	    i++;
	}

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
	    break;
	}
    }

    pcpi->cPolicyQualifier = i;
    pcpi->rgPolicyQualifier = (CERT_POLICY_QUALIFIER_INFO *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				pcpi->cPolicyQualifier *
				    sizeof(pcpi->rgPolicyQualifier[0]));
    if (NULL == pcpi->rgPolicyQualifier)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = infSetupFindFirstLine(hInf, pwszSection, NULL, &InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    for (i = 0; ; )
    {
	// handle one URL or text message

	hr = infBuildPolicyElement(&InfContext, &pcpi->rgPolicyQualifier[i]);
	if (S_FALSE != hr)
	{
	    _JumpIfErrorStr(hr, error, "infBuildPolicyElement", pwszSection);

	    i++;
	}
	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
	    break;
	}
    }
    CSASSERT(i == pcpi->cPolicyQualifier);
    hr = S_OK;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, NULL, L"???");
    }
    CSILOG(
	hr,
	IDS_ILOG_CAPOLICY_BUILD,
	pwszSection,
	S_OK == hr || L'\0' == wszValue[0]? NULL : wszValue,
	NULL);
    return(hr);
}


VOID
infFreePolicy(
    IN OUT CERT_POLICY_INFO *pcpi)
{
    DWORD i;
    CERT_POLICY_QUALIFIER_INFO *pcpqi;

    if (NULL != pcpi->pszPolicyIdentifier)
    {
	LocalFree(pcpi->pszPolicyIdentifier);
    }
    if (NULL != pcpi->rgPolicyQualifier)
    {
	for (i = 0; i < pcpi->cPolicyQualifier; i++)
	{
	    pcpqi = &pcpi->rgPolicyQualifier[i];
	    if (NULL != pcpqi->Qualifier.pbData)
	    {
		LocalFree(pcpqi->Qualifier.pbData);
	    }
	}
	LocalFree(pcpi->rgPolicyQualifier);
    }
}


HRESULT
myInfOpenFile(
    OPTIONAL IN WCHAR const *pwszfnPolicy,
    OUT HINF *phInf,
    OUT DWORD *pErrorLine)
{
    HRESULT hr;
    HINF hInf;
    WCHAR wszPath[MAX_PATH];
    UINT ErrorLine;
    DWORD Flags;

    *phInf = INVALID_HANDLE_VALUE;
    *pErrorLine = 0;
    myInfClearError();

    if (NULL == pwszfnPolicy)
    {
	if (0 == GetEnvironmentVariable(
			L"SystemRoot",
			wszPath,
			ARRAYSIZE(wszPath) - ARRAYSIZE(wszBSCAPOLICYFILE)))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "GetEnvironmentVariable");
	}
	wcscat(wszPath, wszBSCAPOLICYFILE);
	pwszfnPolicy = wszPath;
    }
    else
    {
	if (NULL == wcschr(pwszfnPolicy, L'\\'))
	{
	    if (ARRAYSIZE(wszPath) <= 2 + wcslen(pwszfnPolicy))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
		_JumpErrorStr(hr, error, "filename too long", pwszfnPolicy);
	    }
	    wcscpy(wszPath, L".\\");
	    wcscat(wszPath, pwszfnPolicy);
	    pwszfnPolicy = wszPath;
	}
    }

    Flags = INF_STYLE_WIN4;
    while (TRUE)
    {
	ErrorLine = 0;
	*phInf = SetupOpenInfFile(
			    pwszfnPolicy,
			    NULL,
			    Flags,
			    &ErrorLine);
	*pErrorLine = ErrorLine;
	if (INVALID_HANDLE_VALUE != *phInf)
	{
	    break;
	}
	hr = myHLastError();
	if ((HRESULT) ERROR_WRONG_INF_STYLE == hr && INF_STYLE_WIN4 == Flags)
	{
	    Flags = INF_STYLE_OLDNT;
	    continue;
	}
	CSILOG(
	    hr,
	    IDS_ILOG_CAPOLICY_OPEN_FAILED,
	    pwszfnPolicy,
	    NULL,
	    0 == *pErrorLine? NULL : pErrorLine);
        _JumpErrorStr(hr, error, "SetupOpenInfFile", pwszfnPolicy);
    }
    CSILOG(S_OK, IDS_ILOG_CAPOLICY_OPEN, pwszfnPolicy, NULL, NULL);
    hr = S_OK;

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfOpenFile(%ws) hr=%x --> h=%x\n",
	pwszfnPolicy,
	hr,
	*phInf));
    return(hr);
}


VOID
myInfCloseFile(
    IN HINF hInf)
{
    if (NULL != hInf && INVALID_HANDLE_VALUE != hInf)
    {
	WCHAR *pwszInfError = myInfGetError();

	SetupCloseInfFile(hInf);
	CSILOG(S_OK, IDS_ILOG_CAPOLICY_CLOSE, pwszInfError, NULL, NULL);
	if (NULL != pwszInfError)
	{
	    LocalFree(pwszInfError);
	}
    }
    DBGPRINT((DBG_SS_CERTLIBI, "myInfCloseFile(%x)\n", hInf));
}


HRESULT
myInfParseBooleanValue(
    IN WCHAR const *pwszValue,
    OUT BOOL *pfValue)
{
    HRESULT hr;
    DWORD i;
    static WCHAR const * const s_apwszTrue[] = { L"True", L"Yes", L"On", L"1" };
    static WCHAR const * const s_apwszFalse[] = { L"False", L"No", L"Off", L"0" };

    *pfValue = FALSE;
    for (i = 0; i < ARRAYSIZE(s_apwszTrue); i++)
    {
	if (0 == lstrcmpi(pwszValue, s_apwszTrue[i]))
	{
	    *pfValue = TRUE;
	    break;
	}
    }
    if (i == ARRAYSIZE(s_apwszTrue))
    {
	for (i = 0; i < ARRAYSIZE(s_apwszFalse); i++)
	{
	    if (0 == lstrcmpi(pwszValue, s_apwszFalse[i]))
	    {
		break;
	    }
	}
	if (i == ARRAYSIZE(s_apwszFalse))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "bad boolean value string", pwszValue);
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, NULL, pwszValue);
    }
    return(hr);
}


HRESULT
myInfGetBooleanValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fIgnoreMissingKey,
    OUT BOOL *pfValue)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    DWORD i;
    WCHAR wszValue[cwcVALUEMAX];

    *pfValue = FALSE;
    myInfClearError();

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    hr = infSetupFindFirstLine(hInf, pwszSection, pwszKey, &InfContext);
    _PrintIfErrorStr3(
		hr,
		"infSetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);
    _JumpIfErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszKey,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);

    if (!SetupGetStringField(
			&InfContext,
			1,
			wszValue,
			ARRAYSIZE(wszValue),
			NULL))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "SetupGetStringField", pwszKey);
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetBooleanValue --> '%ws'\n",
	wszValue));

    hr = myInfParseBooleanValue(wszValue, pfValue);
    _JumpIfError(hr, error, "myInfParseBooleanValue");

error:
    if (S_OK != hr &&
	((HRESULT) ERROR_LINE_NOT_FOUND != hr || !fIgnoreMissingKey))
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetBooleanValue(%ws, %ws) hr=%x --> f=%d\n",
	pwszSection,
	pwszKey,
	hr,
	*pfValue));
    return(hr);
}


HRESULT
infGetCriticalFlag(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN BOOL fDefault,
    OUT BOOL *pfCritical)
{
    HRESULT hr;

    hr = myInfGetBooleanValue(
			hInf,
			pwszSection,
			wszINFKEY_CRITICAL,
			TRUE,
			pfCritical);
    if (S_OK != hr)
    {
	*pfCritical = fDefault;
	if ((HRESULT) ERROR_LINE_NOT_FOUND != hr && S_FALSE != hr)
	{
	    _JumpErrorStr(hr, error, "myInfGetBooleanValue", pwszSection);
	}
	hr = S_OK;
    }

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infGetCriticalFlag(%ws) hr=%x --> f=%d\n",
	pwszSection,
	hr,
	*pfCritical));
    return(hr);
}


//+------------------------------------------------------------------------
// infGetPolicyStatementExtensionSub -- build policy extension from INF file
//
// [pwszSection]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
//
// [LegalPolicy]
// OID = 1.3.6.1.4.1.311.21.43
// Notice = "Legal policy statement text."
//
// [LimitedUsePolicy]
// OID = 1.3.6.1.4.1.311.21.47
// URL = "http://http.site.com/some where/default.asp"
// URL = "ftp://ftp.site.com/some where else/default.asp"
// Notice = "Limited use policy statement text."
// URL = "ldap://ldap.site.com/some where else again/default.asp"
//
// [ExtraPolicy]
// OID = 1.3.6.1.4.1.311.21.53
// URL = http://extra.site.com/Extra Policy/default.asp
//
// Return S_OK if extension has been constructed from the INF file
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//-------------------------------------------------------------------------

HRESULT
infGetPolicyStatementExtensionSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN char const *pszObjId,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_POLICIES_INFO PoliciesInfo;
    INFCONTEXT InfContext;
    DWORD i;
    WCHAR wszValue[cwcVALUEMAX];

    wszValue[0] = L'\0';
    ZeroMemory(&PoliciesInfo, sizeof(PoliciesInfo));
    ZeroMemory(pext, sizeof(*pext));

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			wszINFKEY_POLICIES,
			&InfContext);
    if (S_OK != hr)
    {
	CSILOG(
	    hr,
	    IDS_ILOG_CAPOLICY_NOKEY,
	    pwszSection,
	    wszINFKEY_POLICIES,
	    NULL);
	_JumpErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);
    }

    // First, count the policies.

    PoliciesInfo.cPolicyInfo = SetupGetFieldCount(&InfContext);
    if (0 == PoliciesInfo.cPolicyInfo)
    {
        hr = S_FALSE;
	_JumpError(hr, error, "SetupGetFieldCount");
    }

    // Next, allocate memory.

    PoliciesInfo.rgPolicyInfo = (CERT_POLICY_INFO *) LocalAlloc(
	    LMEM_FIXED | LMEM_ZEROINIT,
	    PoliciesInfo.cPolicyInfo * sizeof(PoliciesInfo.rgPolicyInfo[0]));
    if (NULL == PoliciesInfo.rgPolicyInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // Finally!  Fill in the policies data.

    for (i = 0; i < PoliciesInfo.cPolicyInfo; i++)
    {
	if (!SetupGetStringField(
			    &InfContext,
			    i + 1,
			    wszValue,
			    ARRAYSIZE(wszValue),
			    NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr2(hr, error, "SetupGetStringField", wszINFKEY_POLICIES, hr);
	}
	DBGPRINT((DBG_SS_CERTLIBI, "%ws[%u] = %ws\n", wszINFKEY_POLICIES, i, wszValue));

	hr = infBuildPolicy(hInf, wszValue, &PoliciesInfo.rgPolicyInfo[i]);
	_JumpIfErrorStr(hr, error, "infBuildPolicy", wszValue);
    }

    hr = infGetCriticalFlag(hInf, pwszSection, FALSE, &pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    &PoliciesInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, wszINFKEY_POLICIES, wszValue);
    }
    pext->pszObjId = const_cast<char *>(pszObjId);	// on error, too!

    if (NULL != PoliciesInfo.rgPolicyInfo)
    {
	for (i = 0; i < PoliciesInfo.cPolicyInfo; i++)
	{
	    infFreePolicy(&PoliciesInfo.rgPolicyInfo[i]);
	}
	LocalFree(PoliciesInfo.rgPolicyInfo);
    }
    CSILOG(
	hr,
	IDS_ILOG_CAPOLICY_EXTENSION,
	S_OK == hr || L'\0' == wszValue[0]? NULL : wszValue,
	NULL,
	NULL);
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetPolicyStatementExtension -- build policy extension from INF file
//
// [PolicyStatementExtension]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
// ...
//
// OR
//
// [CAPolicy]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
// ...
//
// Return S_OK if extension has been constructed from the INF file
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetPolicyStatementExtension;

HRESULT
myInfGetPolicyStatementExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = infGetPolicyStatementExtensionSub(
				hInf,
				wszINFSECTION_POLICYSTATEMENT,
				szOID_CERT_POLICIES,
				pext);
    if (S_OK != hr)
    {
	HRESULT hr2;
	
	hr2 = infGetPolicyStatementExtensionSub(
				    hInf,
				    wszINFSECTION_CAPOLICY,
				    szOID_CERT_POLICIES,
				    pext);
	if (S_FALSE == hr2 && (HRESULT) ERROR_LINE_NOT_FOUND == hr)
	{
	    hr = hr2;
	}
    }
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyStatementExtensionSub",
		wszINFSECTION_POLICYSTATEMENT,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetPolicyStatementExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetApplicationPolicyStatementExtension -- build application policy
// extension from INF file
//
// [ApplicationPolicyStatementExtension]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
// ...
//
// Return S_OK if extension has been constructed from the INF file
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetApplicationPolicyStatementExtension;

HRESULT
myInfGetApplicationPolicyStatementExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = infGetPolicyStatementExtensionSub(
				hInf,
				wszINFSECTION_APPLICATIONPOLICYSTATEMENT,
				szOID_APPLICATION_CERT_POLICIES,
				pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyStatementExtensionSub",
		wszINFSECTION_APPLICATIONPOLICYSTATEMENT,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetApplicationPolicyStatementExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


HRESULT
infGetCurrentKeyValue(
    IN OUT INFCONTEXT *pInfContext,
    IN DWORD Index,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    WCHAR wszValue[1024];

    *ppwszValue = NULL;
    wszValue[0] = L'\0';
    if (!SetupGetStringField(
			pInfContext,
			Index,
			wszValue,
			ARRAYSIZE(wszValue),
			NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SetupGetStringField");
    }
    hr = myDupString(wszValue, ppwszValue);
    _JumpIfError(hr, error, "myDupString");

error:
    return(hr);
}



HRESULT
myinfGetCRLPublicationParams(
   IN HINF hInf,
   IN LPCWSTR szInfSection_CRLPeriod,
   IN LPCWSTR szInfSection_CRLCount,
   OUT LPWSTR* ppwszCRLPeriod, 
   OUT DWORD* pdwCRLCount)
{
   HRESULT hr;

   // Retrieve units count and string.  If either fails, both are discarded.

   *ppwszCRLPeriod = NULL;
   hr = myInfGetNumericKeyValue(
			hInf,
			FALSE,
			wszINFSECTION_CERTSERVER,
			szInfSection_CRLCount,
			pdwCRLCount);
   _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetNumericKeyValue",
		szInfSection_CRLCount,
		ERROR_LINE_NOT_FOUND);

   hr = myInfGetKeyValue(
		    hInf,
		    FALSE,
		    wszINFSECTION_CERTSERVER,
		    szInfSection_CRLPeriod,
		    ppwszCRLPeriod);
   _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetKeyValue",
		szInfSection_CRLPeriod,
		ERROR_LINE_NOT_FOUND);

error:

    return hr;
}


//+------------------------------------------------------------------------
// myInfGetKeyValue -- fetch a string value from INF file
//
// [pwszSection]
// pwszKey = string
//
// Returns: allocated string key value
//-------------------------------------------------------------------------

HRESULT
myInfGetKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszT = NULL;

    *ppwszValue = NULL;
    myInfClearError();

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    hr = infSetupFindFirstLine(hInf, pwszSection, pwszKey, &InfContext);
    if (S_OK != hr)
    {
	if (fLog)
	{
	    CSILOG(hr, IDS_ILOG_CAPOLICY_NOKEY, pwszSection, pwszKey, NULL);
	}
	_JumpErrorStr2(
		    hr,
		    error,
		    "infSetupFindFirstLine",
		    pwszKey,
		    ERROR_LINE_NOT_FOUND);
    }

    hr = infGetCurrentKeyValue(&InfContext, 1, &pwszValue);
    _JumpIfError(hr, error, "infGetCurrentKeyValue");

    while (TRUE)
    {
	DWORD cwc;
	WCHAR *pwsz;
	
	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    break;
	}
	hr = infGetCurrentKeyValue(&InfContext, 0, &pwszT);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	if (0 != lstrcmpi(wszINFKEY_CONTINUE, pwszT))
	{
	    break;
	}
	LocalFree(pwszT);
	pwszT = NULL;

	hr = infGetCurrentKeyValue(&InfContext, 1, &pwszT);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	cwc = wcslen(pwszValue) + wcslen(pwszT);
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwsz, pwszValue);
	wcscat(pwsz, pwszT);

	LocalFree(pwszValue);
	pwszValue = pwsz;

	LocalFree(pwszT);
	pwszT = NULL;
    }
    *ppwszValue = pwszValue;
    pwszValue = NULL;
    hr = S_OK;

    //wprintf(L"%ws = %ws\n", pwszKey, *ppwszValue);

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (S_OK != hr && fLog)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetNumericKeyValue -- fetch a numeric value from INF file
//
// [pwszSection]
// pwszKey = 2048
//
// Returns: DWORD key value
//-------------------------------------------------------------------------

HRESULT
myInfGetNumericKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT DWORD *pdwValue)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    INT Value;

    myInfClearError();
    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    if (!SetupFindFirstLine(hInf, pwszSection, pwszKey, &InfContext))
    {
	hr = myHLastError();
	if (fLog)
	{
	    CSILOG(hr, IDS_ILOG_CAPOLICY_NOKEY, pwszSection, pwszKey, NULL);
	}
	_PrintErrorStr2(
		hr,
		"SetupFindFirstLine",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
	_JumpErrorStr2(
		hr,
		error,
		"SetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND);
    }

    if (!SetupGetIntField(&InfContext, 1, &Value))
    {
	hr = myHLastError();
	if (fLog)
	{
	    CSILOG(hr, IDS_ILOG_BAD_NUMERICFIELD, pwszSection, pwszKey, NULL);
	}
	_JumpErrorStr(hr, error, "SetupGetIntField", pwszKey);
    }
    *pdwValue = Value;
    DBGPRINT((DBG_SS_CERTLIBI, "%ws = %u\n", pwszKey, *pdwValue));
    hr = S_OK;

error:
    if (S_OK != hr && fLog)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetKeyLength -- fetch the renewal key length from CAPolicy.inf
//
// [certsrv_server]
// RenewalKeyLength = 2048
//
// Returns: DWORD key kength
//-------------------------------------------------------------------------

HRESULT
myInfGetKeyLength(
    IN HINF hInf,
    OUT DWORD *pdwKeyLength)
{
    HRESULT hr;

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			wszINFSECTION_CERTSERVER,
			wszINFKEY_RENEWALKEYLENGTH,
			pdwKeyLength);
    _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetNumericKeyValue",
		wszINFKEY_RENEWALKEYLENGTH,
		ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetKeyLength hr=%x --> len=%x\n",
	hr,
	*pdwKeyLength));
    return(hr);
}


//+------------------------------------------------------------------------
// infGetValidityPeriodSub -- fetch validity period & units from CAPolicy.inf
//
// [certsrv_server]
// xxxxValidityPeriod = 8		(count)
// xxxxValidityPeriodUnits = Years	(string)
//
// Returns: validity period count and enum
//-------------------------------------------------------------------------

HRESULT
infGetValidityPeriodSub(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszInfKeyNameCount,
    IN WCHAR const *pwszInfKeyNameString,
    OPTIONAL IN WCHAR const *pwszValidityPeriodCount,
    OPTIONAL IN WCHAR const *pwszValidityPeriodString,
    OUT DWORD *pdwValidityPeriodCount,
    OUT ENUM_PERIOD *penumValidityPeriod)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszStringValue = NULL;
    BOOL fValidCount = TRUE;
    UINT idsLog = IDS_ILOG_BAD_VALIDITY_STRING;

    *pdwValidityPeriodCount = 0;
    *penumValidityPeriod = ENUM_PERIOD_INVALID;

    if (NULL == pwszValidityPeriodCount && NULL == pwszValidityPeriodString)
    {
        if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
        {
            hr = E_HANDLE;
            _JumpError2(hr, error, "hInf", hr);
        }

	hr = myInfGetNumericKeyValue(
			    hInf,
			    fLog,
			    wszINFSECTION_CERTSERVER,
			    pwszInfKeyNameCount,
			    pdwValidityPeriodCount);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "myInfGetNumericKeyValue",
		    pwszInfKeyNameCount,
		    ERROR_LINE_NOT_FOUND);

	hr = myInfGetKeyValue(
			hInf,
			fLog,
			wszINFSECTION_CERTSERVER,
			pwszInfKeyNameString,
			&pwszStringValue);
	if (S_OK != hr && fLog)
	{
	    INFSETERROR(hr, wszINFSECTION_CERTSERVER, pwszInfKeyNameString, NULL);
	}
	_JumpIfErrorStr(hr, error, "myInfGetKeyValue", pwszInfKeyNameString);

	pwszValidityPeriodString = pwszStringValue;
    }
    else
    {
	if (NULL != pwszValidityPeriodCount)
	{
	    *pdwValidityPeriodCount = myWtoI(
					pwszValidityPeriodCount,
					&fValidCount);
	}
	idsLog = IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND;
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%ws = %u -- %ws = %ws\n",
	pwszInfKeyNameCount,
	*pdwValidityPeriodCount,
	pwszInfKeyNameString,
	pwszValidityPeriodString));

    if (NULL != pwszValidityPeriodString)
    {
        if (0 == lstrcmpi(wszPERIODYEARS, pwszValidityPeriodString))
        {
	    *penumValidityPeriod = ENUM_PERIOD_YEARS;
        }
        else if (0 == lstrcmpi(wszPERIODMONTHS, pwszValidityPeriodString))
        {
	    *penumValidityPeriod = ENUM_PERIOD_MONTHS;
        }
        else if (0 == lstrcmpi(wszPERIODWEEKS, pwszValidityPeriodString))
        {
	    *penumValidityPeriod = ENUM_PERIOD_WEEKS;
        }
        else if (0 == lstrcmpi(wszPERIODDAYS, pwszValidityPeriodString))
        {
	    *penumValidityPeriod = ENUM_PERIOD_DAYS;
        }
	else if (fLog)
	{
	    INFSETERROR(
		    hr,
		    wszINFSECTION_CERTSERVER,
		    pwszInfKeyNameString,
		    pwszValidityPeriodString);
	}
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%ws = %u (%ws)\n",
	pwszInfKeyNameString,
	*penumValidityPeriod,
	pwszValidityPeriodString));

    if (!fValidCount ||
	(ENUM_PERIOD_YEARS == *penumValidityPeriod &&
	 fValidCount && 9999 < *pdwValidityPeriodCount))
    {
	hr = E_INVALIDARG;
	if (fLog)
	{
	    WCHAR awcCount[20];
	    
	    if (NULL == pwszValidityPeriodCount)
	    {
		wsprintf(awcCount, L"%d", *pdwValidityPeriodCount);
	    }
	    INFSETERROR(
		    hr,
		    wszINFSECTION_CERTSERVER,
		    pwszInfKeyNameCount,
		    NULL != pwszValidityPeriodCount? 
			pwszValidityPeriodCount : awcCount);
	    CSILOG(
		hr,
		idsLog,
		wszINFSECTION_CERTSERVER,
		NULL == pwszValidityPeriodCount? pwszInfKeyNameCount : NULL,
		pdwValidityPeriodCount);
	}
	_JumpIfErrorStr(
		hr,
		error,
		"bad ValidityPeriod count value",
		pwszValidityPeriodCount);
    }
    hr = S_OK;

error:
    if (NULL != pwszStringValue)
    {
	LocalFree(pwszStringValue);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// infGetValidityPeriod -- fetch renewal period & units from CAPolicy.inf
//
// [certsrv_server]
// xxxxValidityPeriod = 8
// xxxxValidityPeriodUnits = Years
//
// Returns: validity period count and enum
//-------------------------------------------------------------------------

HRESULT
myInfGetValidityPeriod(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszValidityPeriodCount,
    OPTIONAL IN WCHAR const *pwszValidityPeriodString,
    OUT DWORD *pdwValidityPeriodCount,
    OUT ENUM_PERIOD *penumValidityPeriod,
    OPTIONAL OUT BOOL *pfSwap)
{
    HRESULT hr;

    if ((NULL == hInf || INVALID_HANDLE_VALUE == hInf) &&
        NULL == pwszValidityPeriodCount &&
        NULL == pwszValidityPeriodString)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();

    if (NULL != pfSwap)
    {
        *pfSwap = FALSE;
    }

    // Try correct order:
    // [certsrv_server]
    // xxxxValidityPeriod = 8		(count)
    // xxxxValidityPeriodUnits = Years	(string)
    
    hr = infGetValidityPeriodSub(
		hInf,
		TRUE,
		wszINFKEY_RENEWALVALIDITYPERIODCOUNT,
		wszINFKEY_RENEWALVALIDITYPERIODSTRING,
                pwszValidityPeriodCount,
                pwszValidityPeriodString,
		pdwValidityPeriodCount,
		penumValidityPeriod);
    _PrintIfError2(hr, "infGetValidityPeriodSub", ERROR_LINE_NOT_FOUND);

    if (S_OK != hr)
    {
	// Try backwards:
	// [certsrv_server]
	// xxxxValidityPeriodUnits = 8	(count)
	// xxxxValidityPeriod = Years	(string)
    
	hr = infGetValidityPeriodSub(
		    hInf,
		    FALSE,
		    wszINFKEY_RENEWALVALIDITYPERIODSTRING,
		    wszINFKEY_RENEWALVALIDITYPERIODCOUNT,
		    pwszValidityPeriodString,
		    pwszValidityPeriodCount,
		    pdwValidityPeriodCount,
		    penumValidityPeriod);
	_JumpIfError2(
		hr,
		error,
		"infGetValidityPeriodSub",
		ERROR_LINE_NOT_FOUND);

        if (NULL != pfSwap)
        {
            *pfSwap = TRUE;
        }
    }

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetValidityPeriod hr=%x --> c=%d, enum=%d\n",
	hr,
	*pdwValidityPeriodCount,
	*penumValidityPeriod));
    return(hr);
}



HRESULT
infFindNextKey(
    IN WCHAR const *pwszKey,
    IN OUT INFCONTEXT *pInfContext)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR wszKey[MAX_PATH];

    while (TRUE)
    {
	if (!SetupFindNextLine(pInfContext, pInfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszKey, hr);
	    if ((HRESULT) ERROR_LINE_NOT_FOUND == hr)
	    {
		hr = S_FALSE;
	    }
	    _JumpError2(hr, error, "SetupFindNextLine", hr);
	}
	if (!SetupGetStringField(
			pInfContext,
			0,
			wszKey,
			ARRAYSIZE(wszKey),
			NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}
	if (0 == lstrcmpi(pwszKey, wszKey))
	{
	    break;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetKeyList -- fetch a list of key values from CAPolicy.inf
//
// [pwszSection]
// pwszKey = Value1
// pwszKey = Value2
//
// Returns: double null terminated list of values
//-------------------------------------------------------------------------

HRESULT
myInfGetKeyList(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    DWORD iVal;
    DWORD cwc;
    WCHAR *pwsz;
    WCHAR **apwszVal = NULL;
    DWORD cVal;
    WCHAR *pwszBuf = NULL;
    DWORD cwcBuf = 0;

    *ppwszz = NULL;
    *pfCritical = FALSE;
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(hInf, pwszSection, pwszKey, &InfContext);
    if (S_OK != hr)
    {
	CSILOG(hr, IDS_ILOG_CAPOLICY_NOKEY, pwszSection, pwszKey, NULL);
	_JumpErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);
    }

    cVal = 0;
    while (TRUE)
    {
	if (!SetupGetStringField(&InfContext, 1, NULL, 0, &cwc))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "SetupGetStringField", pwszKey);
	}
	cVal++;
	if (cwcBuf < cwc)
	{
	    cwcBuf = cwc;
	}
	hr = infFindNextKey(pwszKey, &InfContext);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfErrorStr(hr, error, "infFindNextKey", pwszKey);
    }

    pwszBuf = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcBuf * sizeof(WCHAR));
    if (NULL == pwszBuf)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    apwszVal = (WCHAR **) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cVal * sizeof(apwszVal[0]));
    if (NULL == apwszVal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = infSetupFindFirstLine(hInf, pwszSection, pwszKey, &InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    cwc = 1;
    iVal = 0;
    while (TRUE)
    {
	if (!SetupGetStringField(&InfContext, 1, pwszBuf, cwcBuf, NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "SetupGetStringField", pwszKey);
	}

	hr = myDupString(pwszBuf, &apwszVal[iVal]);
	_JumpIfError(hr, error, "myDupString");

	DBGPRINT((DBG_SS_CERTLIBI, "%ws = %ws\n", pwszKey, apwszVal[iVal]));

	cwc += wcslen(apwszVal[iVal]) + 1;
	iVal++;

	hr = infFindNextKey(pwszKey, &InfContext);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfErrorStr(hr, error, "infFindNextKey", pwszKey);
    }
    CSASSERT(iVal == cVal);

    *ppwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == *ppwszz)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    pwsz = *ppwszz;
    for (iVal = 0; iVal < cVal; iVal++)
    {
	wcscpy(pwsz, apwszVal[iVal]);
	pwsz += wcslen(pwsz) + 1;
    }
    *pwsz = L'\0';
    CSASSERT(cwc == 1 + SAFE_SUBTRACT_POINTERS(pwsz, *ppwszz));

    if (NULL != pfCritical)
    {
	hr = infGetCriticalFlag(hInf, pwszSection, FALSE, pfCritical);
	_JumpIfError(hr, error, "infGetCriticalFlag");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    if (NULL != apwszVal)
    {
	for (iVal = 0; iVal < cVal; iVal++)
	{
	    if (NULL != apwszVal[iVal])
	    {
		LocalFree(apwszVal[iVal]);
	    }
	}
	LocalFree(apwszVal);
    }
    if (NULL != pwszBuf)
    {
	LocalFree(pwszBuf);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetCRLDistributionPoints -- fetch CDP URLs from CAPolicy.inf
//
// [CRLDistributionPoint]
// URL = http://CRLhttp.site.com/Public/MyCA.crl
// URL = ftp://CRLftp.site.com/Public/MyCA.crl
//
// Returns: double null terminated list of CDP URLs
//-------------------------------------------------------------------------

HRESULT
myInfGetCRLDistributionPoints(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_CDP,
		wszINFKEY_URL,
		pfCritical,
		ppwszz);
    _JumpIfErrorStr4(
		hr,
		error,
		"myInfGetKeyList",
		wszINFSECTION_CDP,
		ERROR_LINE_NOT_FOUND,
		S_FALSE,
		E_HANDLE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetCRLDistributionPoints hr=%x --> f=%d\n",
	hr,
	*pfCritical));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetAuthorityInformationAccess -- fetch AIA URLs from CAPolicy.inf
//
// [AuthorityInformationAccess]
// URL = http://CRThttp.site.com/Public/MyCA.crt
// URL = ftp://CRTftp.site.com/Public/MyCA.crt
//
// Returns: double null terminated list of AIA URLs
//-------------------------------------------------------------------------

HRESULT
myInfGetAuthorityInformationAccess(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_AIA,
		wszINFKEY_URL,
		pfCritical,
		ppwszz);
    _JumpIfErrorStr4(
		hr,
		error,
		"myInfGetKeyList",
		wszINFSECTION_AIA,
		ERROR_LINE_NOT_FOUND,
		S_FALSE,
		E_HANDLE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetAuthorityInformationAccess hr=%x --> f=%d\n",
	hr,
	*pfCritical));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetEnhancedKeyUsage -- fetch EKU OIDS from CAPolicy.inf
//
// [EnhancedKeyUsage]
// OID = 1.2.3.4.5
// OID = 1.2.3.4.6
//
// Returns: double null terminated list of EKU OIDs
//-------------------------------------------------------------------------

HRESULT
myInfGetEnhancedKeyUsage(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_EKU,
		wszINFKEY_OID,
		pfCritical,
		ppwszz);
    _JumpIfErrorStr4(
		hr,
		error,
		"myInfGetKeyList",
		wszINFSECTION_EKU,
		ERROR_LINE_NOT_FOUND,
		S_FALSE,
		E_HANDLE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetEnhancedKeyUsage hr=%x --> f=%d\n",
	hr,
	*pfCritical));
    return(hr);
}


//+--------------------------------------------------------------------------
// infGetBasicConstraints2CAExtension -- fetch basic constraints extension
// from INF file, setting the SubjectType flag to CA
//
// If the INF handle is bad, or if the INF section does not exist, construct
// a default extension only if fDefault is set, otherwise fail.
//
// [BasicConstraintsExtension]
// ; Subject Type is not supported -- always set to CA
// ; maximum subordinate CA path length
// PathLength = 3
//
// Return S_OK if extension has been constructed from INF file.
//
// Returns: encoded basic constraints extension
//+--------------------------------------------------------------------------

HRESULT
infGetBasicConstraints2CAExtension(
    IN BOOL fDefault,
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_BASIC_CONSTRAINTS2_INFO bc2i;
    INFCONTEXT InfContext;

    ZeroMemory(pext, sizeof(*pext));
    ZeroMemory(&bc2i, sizeof(bc2i));
    myInfClearError();

    pext->fCritical = TRUE;	// default value for both INF and default cases
    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	if (!fDefault)
	{
	    hr = E_HANDLE;
	    _JumpError2(hr, error, "hInf", hr);
	}
    }
    else
    {
	hr = infSetupFindFirstLine(
			    hInf,
			    wszINFSECTION_BASICCONSTRAINTS,
			    NULL,
			    &InfContext);
	if (S_OK != hr)
	{
	    if (!fDefault)
	    {
		_JumpErrorStr3(
			    hr,
			    error,
			    "infSetupFindFirstLine",
			    wszINFSECTION_BASICCONSTRAINTS,
			    S_FALSE,
			    ERROR_LINE_NOT_FOUND);
	    }
	}
	else
	{
	    hr = infGetCriticalFlag(
				hInf,
				wszINFSECTION_BASICCONSTRAINTS,
				pext->fCritical,	// fDefault
				&pext->fCritical);
	    _JumpIfError(hr, error, "infGetCriticalFlag");

	    bc2i.fPathLenConstraint = TRUE;
	    hr = myInfGetNumericKeyValue(
				hInf,
				TRUE,			// fLog
				wszINFSECTION_BASICCONSTRAINTS,
				wszINFKEY_PATHLENGTH,
				&bc2i.dwPathLenConstraint);
	    if (S_OK != hr)
	    {
		_PrintErrorStr2(
			    hr,
			    "myInfGetNumericKeyValue",
			    wszINFKEY_PATHLENGTH,
			    ERROR_LINE_NOT_FOUND);
		if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
		{
		    goto error;
		}
		bc2i.dwPathLenConstraint = 0;
		bc2i.fPathLenConstraint = FALSE;
	    }
	}
    }
    bc2i.fCA = TRUE;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_BASIC_CONSTRAINTS2,
		    &bc2i,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, wszINFSECTION_BASICCONSTRAINTS, NULL, NULL);
    }
    pext->pszObjId = szOID_BASIC_CONSTRAINTS2;	// on error, too!
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetBasicConstraints2CAExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}

//+--------------------------------------------------------------------------
// myInfGetBasicConstraints2CAExtension -- fetch basic constraints extension
// from INF file, setting the SubjectType flag to CA
//
// [BasicConstraintsExtension]
// ; Subject Type is not supported -- always set to CA
// ; maximum subordinate CA path length
// PathLength = 3
//
// Return S_OK if extension has been constructed from INF file.
//
// Returns: encoded basic constraints extension
//+--------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtension;

HRESULT
myInfGetBasicConstraints2CAExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetBasicConstraints2CAExtension(FALSE, hInf, pext);
    _JumpIfError3(
		hr,
		error,
		"infGetBasicConstraints2CAExtension",
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

error:
    return(hr);
}


FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtensionOrDefault;

HRESULT
myInfGetBasicConstraints2CAExtensionOrDefault(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetBasicConstraints2CAExtension(TRUE, hInf, pext);
    _JumpIfError(hr, error, "infGetBasicConstraints2CAExtension");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// myInfGetEnhancedKeyUsageExtension -- fetch EKU extension from INF file
//
// [EnhancedKeyUsageExtension]
// OID = 1.2.3.4.5
// OID = 1.2.3.4.6
//
// Return S_OK if extension has been constructed from INF file.
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//
// Returns: encoded enhanced key usage extension
//+--------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetEnhancedKeyUsageExtension;

HRESULT
myInfGetEnhancedKeyUsageExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    DWORD i;
    DWORD cEKU = 0;
    WCHAR *pwszzEKU = NULL;
    WCHAR *pwszCurrentEKU;
    CERT_ENHKEY_USAGE ceku;

    ceku.rgpszUsageIdentifier = NULL;
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = myInfGetEnhancedKeyUsage(hInf, &pext->fCritical, &pwszzEKU);
    _JumpIfError3(
		hr,
		error,
		"myInfGetEnhancedKeyUsage",
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

    pwszCurrentEKU = pwszzEKU;
    if (NULL != pwszCurrentEKU)
    {
	while (L'\0' != *pwszCurrentEKU)
	{
	    cEKU++;
	    pwszCurrentEKU += wcslen(pwszCurrentEKU) + 1;
	}
    }
    if (0 == cEKU)
    {
        hr = S_FALSE;
        goto error;
    }

    ceku.cUsageIdentifier = cEKU;
    ceku.rgpszUsageIdentifier = (char **) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			sizeof(ceku.rgpszUsageIdentifier[0]) * cEKU);
    if (NULL == ceku.rgpszUsageIdentifier)
    {
        hr = E_OUTOFMEMORY;
	_JumpIfError(hr, error, "LocalAlloc");
    }

    cEKU = 0;
    pwszCurrentEKU = pwszzEKU;
    while (L'\0' != *pwszCurrentEKU)
    {
	if (!ConvertWszToSz(&ceku.rgpszUsageIdentifier[cEKU], pwszCurrentEKU, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToSz");
	}
	cEKU++;
	pwszCurrentEKU += wcslen(pwszCurrentEKU) + 1;
    }
    CSASSERT(ceku.cUsageIdentifier == cEKU);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceku,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && E_HANDLE != hr)
    {
	INFSETERROR(hr, wszINFSECTION_EKU, NULL, NULL);
    }
    pext->pszObjId = szOID_ENHANCED_KEY_USAGE;	// on error, too!
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetEnhancedKeyUsageExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    if (NULL != ceku.rgpszUsageIdentifier)
    {
	for (i = 0; i < ceku.cUsageIdentifier; i++)
	{
	    if (NULL != ceku.rgpszUsageIdentifier[i])
	    {
		LocalFree(ceku.rgpszUsageIdentifier[i]);
	    }
	}
	LocalFree(ceku.rgpszUsageIdentifier);
    }
    if (NULL != pwszzEKU)
    {
	LocalFree(pwszzEKU);
    }
    return(hr);
}


HRESULT
infAddAttribute(
    IN CRYPT_ATTR_BLOB const *pAttribute,
    IN OUT DWORD *pcAttribute,
    IN OUT CRYPT_ATTR_BLOB **ppaAttribute)
{
    HRESULT hr;
    CRYPT_ATTR_BLOB *pAttribT;
    
    if (NULL == *ppaAttribute)
    {
	CSASSERT(0 == *pcAttribute);
	pAttribT = (CRYPT_ATTR_BLOB *) LocalAlloc(
					    LMEM_FIXED,
					    sizeof(**ppaAttribute));
    }
    else
    {
	CSASSERT(0 != *pcAttribute);
	pAttribT = (CRYPT_ATTR_BLOB *) LocalReAlloc(
				*ppaAttribute,
				(*pcAttribute + 1) * sizeof(**ppaAttribute),
				LMEM_MOVEABLE);
    }
    if (NULL == pAttribT)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
		hr,
		error,
		NULL == *ppaAttribute? "LocalAlloc" : "LocalReAlloc");
    }
    *ppaAttribute = pAttribT;
    pAttribT[(*pcAttribute)++] = *pAttribute;
    hr = S_OK;

error:
    return(hr);
}


VOID
myInfFreeRequestAttributes(
    IN DWORD cAttribute,
    IN OUT CRYPT_ATTR_BLOB *paAttribute)
{
    if (NULL != paAttribute)
    {
	DWORD i;
	
	for (i = 0; i < cAttribute; i++)
	{
	    if (NULL != paAttribute[i].pbData)
	    {
		LocalFree(paAttribute[i].pbData);
	    }
	}
	LocalFree(paAttribute);
    }
}


//+------------------------------------------------------------------------
// myInfGetRequestAttributes -- fetch request attributes from INF file
//
// [RequestAttributes]
// AttributeName1 = AttributeValue1
// AttributeName2 = AttributeValue2
// ...
// AttributeNameN = AttributeValueN
//
// Returns: array of encoded attribute blobs
//-------------------------------------------------------------------------

HRESULT
myInfGetRequestAttributes(
    IN  HINF hInf,
    OUT DWORD *pcAttribute,
    OUT CRYPT_ATTR_BLOB **ppaAttribute,
    OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR wszName[MAX_PATH];
    WCHAR wszValue[cwcVALUEMAX];
    DWORD i;
    DWORD cAttribute = 0;
    CRYPT_ATTR_BLOB Attribute;
    WCHAR *pwszTemplateName = NULL;

    *ppwszTemplateName = NULL;
    *pcAttribute = 0;
    *ppaAttribute = NULL;
    Attribute.pbData = NULL;
    wszName[0] = L'\0';
    wszValue[0] = L'\0';
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(
			hInf,
			wszINFSECTION_REQUESTATTRIBUTES,
			NULL,		// Key
			&InfContext);
    _JumpIfErrorStr(
		hr,
		error,
		"infSetupFindFirstLine",
		wszINFSECTION_REQUESTATTRIBUTES);

    while (TRUE)
    {
	CRYPT_ENROLLMENT_NAME_VALUE_PAIR NamePair;

	wszName[0] = L'\0';
	wszValue[0] = L'\0';
	if (!SetupGetStringField(
			    &InfContext,
			    0,
			    wszName,
			    ARRAYSIZE(wszName),
			    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}

	if (!SetupGetStringField(
			    &InfContext,
			    1,
			    wszValue,
			    ARRAYSIZE(wszValue),
			    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}

	//wprintf(L"%ws = %ws\n", wszName, wszValue);

	NamePair.pwszName = wszName;
	NamePair.pwszValue = wszValue;

	if (0 == lstrcmpi(wszPROPCERTTEMPLATE, wszName))
	{
	    if (NULL != pwszTemplateName)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Duplicate cert template");
	    }
	    hr = myDupString(wszValue, &pwszTemplateName);
	    _JumpIfError(hr, error, "myDupString");
	}

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			// X509__ENROLLMENT_NAME_VALUE_PAIR
			szOID_ENROLLMENT_NAME_VALUE_PAIR,
			&NamePair,
			0,
			CERTLIB_USE_LOCALALLOC,
			&Attribute.pbData,
			&Attribute.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}

	hr = infAddAttribute(&Attribute, &cAttribute, ppaAttribute);
	_JumpIfError(hr, error, "infAddAttribute");

	Attribute.pbData = NULL;

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupFindNextLine(end)", hr);
	    break;
	}
    }
    *pcAttribute = cAttribute;
    cAttribute = 0;
    *ppwszTemplateName = pwszTemplateName;
    pwszTemplateName = NULL;

    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, wszINFSECTION_REQUESTATTRIBUTES, wszName, wszValue);
    }
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != Attribute.pbData)
    {
	LocalFree(Attribute.pbData);
    }
    if (0 != cAttribute)
    {
	myInfFreeRequestAttributes(cAttribute, *ppaAttribute);
	*ppaAttribute = NULL;
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetRequestAttributes hr=%x --> c=%d\n",
	hr,
	*pcAttribute));
    return(hr);
}


typedef struct _SUBTREEINFO
{
    BOOL	 fEmptyDefault;
    DWORD	 dwInfMinMaxIndexBase;
    DWORD	 dwAltNameChoice;
    WCHAR const *pwszKey;
} SUBTREEINFO;

SUBTREEINFO g_aSubTreeInfo[] = {
    { TRUE,  2, CERT_ALT_NAME_OTHER_NAME,	wszINFKEY_UPN },
    { TRUE,  2, CERT_ALT_NAME_RFC822_NAME,	wszINFKEY_EMAIL },
    { TRUE,  2, CERT_ALT_NAME_DNS_NAME,		wszINFKEY_DNS },
    { TRUE,  2, CERT_ALT_NAME_DIRECTORY_NAME,	wszINFKEY_DIRECTORYNAME },
    { TRUE,  2, CERT_ALT_NAME_URL,		wszINFKEY_URL },
    { TRUE,  3, CERT_ALT_NAME_IP_ADDRESS,	wszINFKEY_IPADDRESS },
    { FALSE, 2, CERT_ALT_NAME_REGISTERED_ID,	wszINFKEY_REGISTEREDID },
};
#define CSUBTREEINFO	ARRAYSIZE(g_aSubTreeInfo)

#define STII_UPNOTHERNAME   0  // CERT_ALT_NAME_OTHER_NAME	pOtherName
#define STII_RFC822NAME	    1  // CERT_ALT_NAME_RFC822_NAME	pwszRfc822Name
#define STII_DNSNAME	    2  // CERT_ALT_NAME_DNS_NAME	pwszDNSName
#define STII_DIRECTORYNAME  3  // CERT_ALT_NAME_DIRECTORY_NAME	DirectoryName
#define STII_URL	    4  // CERT_ALT_NAME_URL		pwszURL
#define STII_IPADDRESS	    5  // CERT_ALT_NAME_IP_ADDRESS	IPAddress
#define STII_REGISTEREDID   6  // CERT_ALT_NAME_REGISTERED_ID	pszRegisteredID


VOID
infFreeGeneralSubTreeElement(
    IN OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    CERT_ALT_NAME_ENTRY *pName = &pSubTree->Base;
    VOID **ppv = NULL;
    
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infFreeGeneralSubTreeElement: p=%x, choice=%x\n",
	pSubTree,
	pName->dwAltNameChoice));
    switch (pName->dwAltNameChoice)
    {
	case CERT_ALT_NAME_OTHER_NAME:
	    ppv = (VOID **) &pName->pOtherName;
	    if (NULL != pName->pOtherName &&
		NULL != pName->pOtherName->Value.pbData)
	    {
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infFreeGeneralSubTreeElement: p=%x, Free(other.pbData=%x\n)",
		    pSubTree,
		    pName->pOtherName->Value.pbData));
		LocalFree(pName->pOtherName->Value.pbData);
	    }
	    break;

	case CERT_ALT_NAME_RFC822_NAME:
	    ppv = (VOID **) &pName->pwszRfc822Name;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    ppv = (VOID **) &pName->pwszDNSName;
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	    ppv = (VOID **) &pName->DirectoryName.pbData;
	    break;

	case CERT_ALT_NAME_URL:
	    ppv = (VOID **) &pName->pwszURL;
	    break;

	case CERT_ALT_NAME_IP_ADDRESS:
	    ppv = (VOID **) &pName->IPAddress.pbData;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    ppv = (VOID **) &pName->pszRegisteredID;
	    break;
    }
    if (NULL != ppv && NULL != *ppv)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infFreeGeneralSubTreeElement: p=%x, Free(pv=%x)\n",
	    pSubTree,
	    *ppv));
	LocalFree(*ppv);
    }
}


VOID
infFreeGeneralSubTree(
    IN DWORD cSubTree,
    IN OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    if (NULL != pSubTree)
    {
	DWORD i;
	
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infFreeGeneralSubTree: p=%x, c=%x\n",
	    pSubTree,
	    cSubTree));
	for (i = 0; i < cSubTree; i++)
	{
	    infFreeGeneralSubTreeElement(&pSubTree[i]);
	}
	LocalFree(pSubTree);
    }
}


// Destructively parse an old-style 4 byte IP Address.

#define CB_IPV4ADDRESS	4

HRESULT
infParseIPV4Address(
    IN WCHAR *pwszValue,
    OUT BYTE *pb,
    IN OUT DWORD *pcb)
{
    HRESULT hr;
    DWORD cb;

    DBGPRINT((DBG_SS_CERTLIBI, "infParseIPV4Address(%ws)\n", pwszValue));
    if (CB_IPV4ADDRESS > *pcb)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "buffer too small");
    }
    for (cb = 0; cb < CB_IPV4ADDRESS; cb++)
    {
	WCHAR *pwszNext;
	BOOL fValid;
	DWORD dw;
	
	pwszNext = &pwszValue[wcscspn(pwszValue, L".")];
	if (L'.' == *pwszNext)
	{
	    *pwszNext++ = L'\0';
	}
	dw = myWtoI(pwszValue, &fValid);
	if (!fValid || 255 < dw)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "bad IP Address digit string", pwszValue);
	}
	pb[cb] = (BYTE) dw;
	pwszValue = pwszNext;
    }
    if (L'\0' != *pwszValue)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "extra data");
    }
    *pcb = cb;
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infParseIPV4Address: %u.%u.%u.%u\n",
	pb[0],
	pb[1],
	pb[2],
	pb[3]));
    hr = S_OK;

error:
    return(hr);
}


// Destructively parse a new-style 16 byte IP Address.

#define CB_IPV6ADDRESS	16
#define MAKE16(b0, b1)	(((b0) << 8) | (b1))


HRESULT
infParseIPV6AddressSub(
    IN WCHAR *pwszValue,
    OUT BYTE *pb,
    IN OUT DWORD *pcb)
{
    HRESULT hr;
    DWORD cbMax = *pcb;
    DWORD cb;
    WCHAR *pwsz;

    DBGPRINT((DBG_SS_CERTLIBI, "infParseIPV6AddressSub(%ws)\n", pwszValue));
    ZeroMemory(pb, cbMax);

    for (cb = 0; cb < cbMax; cb += 2)
    {
	WCHAR *pwszNext;
	BOOL fValid;
	DWORD dw;
	WCHAR awc[7];
	
	pwszNext = &pwszValue[wcscspn(pwszValue, L":")];
	if (L':' == *pwszNext)
	{
	    *pwszNext++ = L'\0';
	}
	if (L'\0' == *pwszValue)
	{
	    break;
	}
	if (4 < wcslen(pwszValue))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "too many IP Address digits", pwszValue);
	}
	wcscpy(awc, L"0x");
	wcscat(awc, pwszValue);
	CSASSERT(wcslen(awc) < ARRAYSIZE(awc));

	dw = myWtoI(awc, &fValid);
	if (!fValid || 64 * 1024 <= dw)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "bad IP Address digit string", pwszValue);
	}
	pb[cb] = (BYTE) (dw >> 8);
	pb[cb + 1] = (BYTE) dw;
	pwszValue = pwszNext;
    }
    if (L'\0' != *pwszValue)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "extra data", pwszValue);
    }
    *pcb = cb;
    hr = S_OK;

error:
    return(hr);
}


// Destructively parse a new-style 16 byte IP Address.

HRESULT
infParseIPV6Address(
    IN WCHAR *pwszValue,
    OUT BYTE *pb,
    IN OUT DWORD *pcb)
{
    HRESULT hr;
    DWORD cbMax;
    WCHAR *pwsz;
    WCHAR *pwszLeft;
    WCHAR *pwszRight;
    BYTE abRight[CB_IPV6ADDRESS];
    DWORD cbLeft;
    DWORD cbRight;
    DWORD i;
    BOOL fV4Compat;

    DBGPRINT((DBG_SS_CERTLIBI, "infParseIPV6Address(%ws)\n", pwszValue));
    if (CB_IPV6ADDRESS > *pcb)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "buffer too small");
    }
    ZeroMemory(pb, CB_IPV6ADDRESS);
    cbMax = CB_IPV6ADDRESS;

    // If there's a period after the last colon, an IP V4 Address is attached.
    // Parse it as an IP V4 Address, and reduce the expected size of the IP V6
    // Address to be parsed from eight to six 16-bit address chunks.

    pwsz = wcsrchr(pwszValue, L':');
    if (NULL != pwsz)
    {
	if (NULL != wcschr(pwsz, L'.'))
	{
	    DWORD cb = CB_IPV4ADDRESS;

	    hr = infParseIPV4Address(
			    &pwsz[1],
			    &pb[CB_IPV6ADDRESS - CB_IPV4ADDRESS],
			    &cb);
	    _JumpIfError(hr, error, "infParseIPV4Address");

	    CSASSERT(CB_IPV4ADDRESS == cb);

	    pwsz[1] = L'\0';	// get rid of the trailing IP V4 Address

	    // drop the trailing colon -- if it's not part of a double colon.

	    if (pwsz > pwszValue && L':' != *--pwsz)
	    {
		pwsz[1] = L'\0';
	    }
	    cbMax -= CB_IPV4ADDRESS;
	}
    }
    cbLeft = 0;
    cbRight = 0;
    pwszLeft = pwszValue;
    pwszRight = wcsstr(pwszValue, L"::");
    if (NULL != pwszRight)
    {
	*pwszRight = L'\0';
	pwszRight += 2;
	if (L'\0' != *pwszRight)
	{
	    cbRight = cbMax;
	    hr = infParseIPV6AddressSub(pwszRight, abRight, &cbRight);
	    _JumpIfError(hr, error, "infParseIPV6AddressSub");
	}
    }

    if (L'\0' != *pwszLeft)
    {
	cbLeft = cbMax;
	hr = infParseIPV6AddressSub(pwszLeft, pb, &cbLeft);
	_JumpIfError(hr, error, "infParseIPV6AddressSub");
    }
    if (NULL == pwszRight && cbLeft != cbMax)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "too few IP Address chunks");
    }
    if (cbLeft + cbRight + (NULL != pwszRight? 1 : 0) > cbMax)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "too many IP Address chunks");
    }
    if (0 != cbRight)
    {
	CopyMemory(&pb[cbMax - cbRight], abRight, cbRight);
    }
    *pcb = CB_IPV6ADDRESS;

    fV4Compat = TRUE;
    for (i = 0; i < CB_IPV6ADDRESS - CB_IPV4ADDRESS - 2; i++)
    {
	if (0 != pb[i])
	{
	    fV4Compat = FALSE;
	    break;
	}
    }
    if (fV4Compat)
    {
	CSASSERT(i == CB_IPV6ADDRESS - CB_IPV4ADDRESS - 2);
	fV4Compat = (0 == pb[i] && 0 == pb[i + 1]) ||
		    (0xff == pb[i] && 0xff == pb[i + 1]);
    }
    if (fV4Compat)
    {
	CSASSERT(i == CB_IPV6ADDRESS - CB_IPV4ADDRESS - 2);
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "infParseIPV6Address: ::%hs%u.%u.%u.%u\n",
	    0 == pb[i]? "" : "ffff:",
	    pb[12],
	    pb[13],
	    pb[14],
	    pb[15]));
    }
    else
    {
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "infParseIPV6Address: %x:%x:%x:%x:%x:%x:%x:%x\n",
	    MAKE16(pb[0], pb[1]),
	    MAKE16(pb[2], pb[3]),
	    MAKE16(pb[4], pb[5]),
	    MAKE16(pb[6], pb[7]),
	    MAKE16(pb[8], pb[9]),
	    MAKE16(pb[10], pb[11]),
	    MAKE16(pb[12], pb[13]),
	    MAKE16(pb[14], pb[15])));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
infParseIPAddress(
    IN WCHAR const *pwszValue,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    DWORD cb = *pcbData;
    WCHAR *pwszDup = NULL;
    WCHAR *pwsz;

    // if pwszValue is an empty string, return zero length.

    *pcbData = 0;
    if (L'\0' != *pwszValue)
    {
	hr = myDupString(pwszValue, &pwszDup);
	_JumpIfError(hr, error, "myDupString");

	if (NULL == wcschr(pwszDup, L':'))
	{
	    hr = infParseIPV4Address(pwszDup, pbData, &cb);
	    _JumpIfError(hr, error, "infParseIPV4Address");
	}
	else
	{
	    hr = infParseIPV6Address(pwszDup, pbData, &cb);
	    _JumpIfError(hr, error, "infParseIPV6Address");
	}
	*pcbData = cb;
	DBGDUMPHEX((
		DBG_SS_CERTLIBI,
		DH_NOADDRESS | DH_NOTABPREFIX | 8,
		pbData,
		*pcbData));
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, NULL, pwszValue);
    }
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}



HRESULT
infParseIPAddressAndMask(
    IN WCHAR const *pwszIPAddress,
    IN WCHAR const *pwszIPAddressMask,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    BYTE ab[2 * CB_IPV6ADDRESS];
    DWORD cb;
    DWORD cbAddress;
    DWORD cbMask;
    WCHAR *pwsz;

    *ppbData = NULL;
    *pcbData = 0;

    // if pwszValue is an empty string, encode zero length blob.

    cb = 0;
    if (L'\0' != *pwszIPAddress && L'\0' != *pwszIPAddressMask)
    {
	cbAddress = sizeof(ab) / 2;

	hr = infParseIPAddress(pwszIPAddress, ab, &cbAddress);
	_JumpIfError(hr, error, "infParseIPAddress");

	if (L'\0' != *pwszIPAddressMask)
	{
	    cbMask = sizeof(ab) / 2;
	    hr = infParseIPAddress(pwszIPAddressMask, &ab[cbAddress], &cbMask);
	    _JumpIfError(hr, error, "infParseIPMask");
	}
	if (cbAddress != cbMask)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "address and mask lengths differ");
	}
	cb = cbAddress + cbMask;
    }
    else if (L'\0' != *pwszIPAddress || L'\0' != *pwszIPAddressMask)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "address or mask missing");
    }

    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pcbData = cb;
    CopyMemory(*ppbData, ab, cb);
    DBGDUMPHEX((
	    DBG_SS_CERTLIBI,
	    DH_NOADDRESS | DH_NOTABPREFIX | 8,
	    *ppbData,
	    *pcbData));
    hr = S_OK;

error:
    return(hr);
}


// [NameConstraintsPermitted]/[NameConstraintsExcluded]
// ; the numeric second and third arguments are optional
// ; when present, the second argument is the minimum depth
// ; when present, the third argument is the maximum depth
// ; The IETF recommends against specifying dwMinimum & dwMaximum
// DNS = foo@domain.com
// DNS = domain1.domain.com, 3, 6

HRESULT
infBuildSubTreeElement(
    IN OUT INFCONTEXT *pInfContext,
    OPTIONAL IN WCHAR const *pwszEmptyEntry,	// NULL means read INF file
    IN DWORD iSubTreeInfo,
    OPTIONAL OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    HRESULT hr;
    SUBTREEINFO const *pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];
    CERT_GENERAL_SUBTREE SubTree;
    WCHAR *pwszValueRead = NULL;
    WCHAR *pwszValueRead2 = NULL;
    WCHAR const *pwszValue = NULL;
    WCHAR const *pwszValue2;

    ZeroMemory(&SubTree, sizeof(SubTree));
    if (NULL != pSubTree)
    {
	ZeroMemory(pSubTree, sizeof(*pSubTree));
    }

    // If pwszEmptyEntry is NULL, read the value from the INF file.
    // Otherwise, encode the specified (empty string) value.

    if (NULL == pwszEmptyEntry)
    {
	INT Value;

	hr = infGetCurrentKeyValue(pInfContext, 1, &pwszValueRead);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	pwszValue = pwszValueRead;

	if (!SetupGetIntField(
			pInfContext,
			pSubTreeInfo->dwInfMinMaxIndexBase,
			&Value))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupGetIntField:2", hr);

	    Value = 0;
	}
	SubTree.dwMinimum = Value;
	SubTree.fMaximum = TRUE;

	if (!SetupGetIntField(
			pInfContext,
			pSubTreeInfo->dwInfMinMaxIndexBase + 1,
			&Value))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupGetIntField:3", hr);

	    Value = 0;
	    SubTree.fMaximum = FALSE;
	}
	SubTree.dwMaximum = Value;
    }
    else
    {
	pwszValue = pwszEmptyEntry;
    }

    SubTree.Base.dwAltNameChoice = pSubTreeInfo->dwAltNameChoice;
    if (NULL != pSubTree)
    {
	WCHAR **ppwsz = NULL;
	
	CSASSERT(CSUBTREEINFO > iSubTreeInfo);
	switch (iSubTreeInfo)
	{
	    case STII_UPNOTHERNAME:
	    {
		CERT_NAME_VALUE nameUpn;

		SubTree.Base.pOtherName = (CERT_OTHER_NAME *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT, 
					    sizeof(*SubTree.Base.pOtherName));
		if (NULL == SubTree.Base.pOtherName)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		SubTree.Base.pOtherName->pszObjId = szOID_NT_PRINCIPAL_NAME;

		nameUpn.dwValueType = CERT_RDN_UTF8_STRING;
		nameUpn.Value.pbData = (BYTE *) pwszValue;
		nameUpn.Value.cbData = 0;

		if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    &nameUpn,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &SubTree.Base.pOtherName->Value.pbData,
			    &SubTree.Base.pOtherName->Value.cbData))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myEncodeObject");
		}
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infFreeGeneralSubTreeElement: p=%x, otherUPN=%x,%x\n",
		    pSubTree,
		    SubTree.Base.pOtherName,
		    SubTree.Base.pOtherName->Value.pbData));
		break;
	    }

	    case STII_RFC822NAME:
		ppwsz = &SubTree.Base.pwszRfc822Name;
		break;

	    case STII_DNSNAME:
		ppwsz = &SubTree.Base.pwszDNSName;
		break;

	    case STII_DIRECTORYNAME:
		hr = myCertStrToName(
			X509_ASN_ENCODING,
			pwszValue,		// pszX500
			CERT_NAME_STR_REVERSE_FLAG,
			NULL,			// pvReserved
			&SubTree.Base.DirectoryName.pbData,
			&SubTree.Base.DirectoryName.cbData,
			NULL);			// ppszError
		_JumpIfError(hr, error, "myCertStrToName");

		break;

	    case STII_URL:
		ppwsz = &SubTree.Base.pwszURL;
		break;

	    case STII_IPADDRESS:

		// convert INF string value to binary IP Address

		if (NULL == pwszEmptyEntry)
		{
		    hr = infGetCurrentKeyValue(pInfContext, 2, &pwszValueRead2);
		    _JumpIfError(hr, error, "infGetCurrentKeyValue");

		    pwszValue2 = pwszValueRead2;
		}
		else
		{
		    pwszValue2 = pwszEmptyEntry;
		}

		hr = infParseIPAddressAndMask(
				pwszValue,
				pwszValue2,
				&SubTree.Base.IPAddress.pbData,
				&SubTree.Base.IPAddress.cbData);
		_JumpIfError(hr, error, "infParseIPAddressAndMask");

		break;

	    case STII_REGISTEREDID:
		if (!myConvertWszToSz(
			    &SubTree.Base.pszRegisteredID,
			    pwszValue,
			    -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToSz");
		}
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infFreeGeneralSubTreeElement: p=%x, psz=%x\n",
		    pSubTree,
		    SubTree.Base.pszRegisteredID));
		break;

	}
	if (NULL != ppwsz)
	{
	    hr = myDupString(pwszValue, ppwsz);
	    _JumpIfError(hr, error, "myDupString");

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"infFreeGeneralSubTreeElement: p=%x, pwsz=%x\n",
		pSubTree,
		*ppwsz));
	}
	*pSubTree = SubTree;
	ZeroMemory(&SubTree, sizeof(SubTree));
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, NULL, pwszValue);
    }
    infFreeGeneralSubTreeElement(&SubTree);
    if (NULL != pwszValueRead)
    {
	LocalFree(pwszValueRead);
    }
    if (NULL != pwszValueRead2)
    {
	LocalFree(pwszValueRead2);
    }
    return(hr);
}


HRESULT
infGetGeneralSubTreeByType(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszEmptyEntry,
    IN DWORD iSubTreeInfo,
    IN OUT DWORD *pcName,
    OPTIONAL OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    HRESULT hr;
    SUBTREEINFO const *pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];
    INFCONTEXT InfContext;
    DWORD iName;
    DWORD cName = MAXDWORD;
    BOOL fIgnore = FALSE;

    if (NULL == pSubTree)
    {
	*pcName = 0;
    }
    else
    {
	cName = *pcName;
    }

    // If pwszEmptyEntry is NULL, read the value from the INF file.
    // Otherwise, encode the specified (empty string) value.

    if (!SetupFindFirstLine(
			hInf,
			pwszSection,
			pSubTreeInfo->pwszKey,
			&InfContext))
    {
        hr = myHLastError();
        _PrintErrorStr2(
		    hr,
		    "SetupFindFirstLine",
		    pwszSection,
		    ERROR_LINE_NOT_FOUND);

	// INF file entry does not exist.  Create an empty name constraints
	// entry only if asked to do so (if pwszEmptyEntry is non-NULL).

	if (NULL == pwszEmptyEntry)
	{
	    fIgnore = (HRESULT) ERROR_LINE_NOT_FOUND == hr;
	    goto error;
	}
    }
    else
    {
	// INF file entry exists; don't create an empty name constraints entry.

	pwszEmptyEntry = NULL;
    }

    for (iName = 0; ; )
    {
	CSASSERT(NULL == pSubTree || iName < cName);
	hr = infBuildSubTreeElement(
			    &InfContext,
			    pwszEmptyEntry,
			    iSubTreeInfo,
			    pSubTree);
	_JumpIfErrorStr(hr, error, "infBuildSubTreeElement", pSubTreeInfo->pwszKey);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infBuildSubTreeElement: &p[%u]=%x, type=%ws\n",
	    iName,
	    pSubTree,
	    pSubTreeInfo->pwszKey));
	iName++;
	if (NULL != pSubTree)
	{
	    pSubTree++;
	}

	if (NULL == pwszEmptyEntry)
	{
	    hr = infFindNextKey(pSubTreeInfo->pwszKey, &InfContext);
	}
	else
	{
	    hr = S_FALSE;
	}
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfErrorStr(hr, error, "infFindNextKey", pSubTreeInfo->pwszKey);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infGetGeneralSubTreeByType: i=%x, c=%x\n",
	iName,
	cName));
    CSASSERT(NULL == pSubTree || iName <= cName);
    *pcName = iName;
    hr = S_OK;

error:
    if (S_OK != hr && !fIgnore)
    {
	INFSETERROR(hr, pwszSection, pSubTreeInfo->pwszKey, NULL);
    }
    return(hr);
}


HRESULT
infGetGeneralSubTree(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,		// key value is sub-section name
    OPTIONAL IN WCHAR const *pwszEmptyEntry,
    OUT DWORD *pcSubTree,
    OUT CERT_GENERAL_SUBTREE **ppSubTree)
{
    HRESULT hr;
    WCHAR *pwszSubTreeSection = NULL;
    DWORD cSubTree = 0;
    CERT_GENERAL_SUBTREE *rgSubTree = NULL;
    CERT_GENERAL_SUBTREE *pSubTree;
    DWORD iSubTreeInfo;
    DWORD count;
    DWORD cRemain;
    SUBTREEINFO const *pSubTreeInfo;

    *pcSubTree = 0;
    *ppSubTree = NULL;

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    hr = myInfGetKeyValue(
		    hInf,
		    TRUE,		// fLog
		    pwszSection,
		    pwszKey,
		    &pwszSubTreeSection);
    _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetKeyValue",
		pwszKey,
		ERROR_LINE_NOT_FOUND);

    for (iSubTreeInfo = 0; iSubTreeInfo < CSUBTREEINFO; iSubTreeInfo++)
    {
	pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];

	hr = infGetGeneralSubTreeByType(
			    hInf,
			    pwszSubTreeSection,
			    pSubTreeInfo->fEmptyDefault? pwszEmptyEntry : NULL,
			    iSubTreeInfo,
			    &count,
			    NULL);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infGetGeneralSubTreeByType(%ws, %ws, NULL) -> hr=%x, c=%x\n",
	    pwszSubTreeSection,
	    pSubTreeInfo->pwszKey,
	    hr,
	    count));
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"infGetGeneralSubTreeByType",
			pSubTreeInfo->pwszKey,
			ERROR_LINE_NOT_FOUND);
	    if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	    {
		_JumpErrorStr(
			    hr,
			    error,
			    "infGetGeneralSubTreeByType",
			    pSubTreeInfo->pwszKey);
	    }
	    count = 0;
	}
	cSubTree += count;
    }
    rgSubTree = (CERT_GENERAL_SUBTREE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cSubTree * sizeof(rgSubTree[0]));
    if (NULL == rgSubTree)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infGetGeneralSubTree: rg=%x, total=%x\n",
	rgSubTree,
	cSubTree));

    pSubTree = rgSubTree;
    cRemain = cSubTree;
    for (iSubTreeInfo = 0; iSubTreeInfo < CSUBTREEINFO; iSubTreeInfo++)
    {
	pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];
	count = cRemain;
	hr = infGetGeneralSubTreeByType(
			    hInf,
			    pwszSubTreeSection,
			    pSubTreeInfo->fEmptyDefault? pwszEmptyEntry : NULL,
			    iSubTreeInfo,
			    &count,
			    pSubTree);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infGetGeneralSubTreeByType(%ws, %ws, &p[%x]=%x) -> hr=%x, c=%x\n",
	    pwszSubTreeSection,
	    pSubTreeInfo->pwszKey,
	    SAFE_SUBTRACT_POINTERS(pSubTree, rgSubTree),
	    pSubTree,
	    hr,
	    count));
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"infGetGeneralSubTreeByType",
			pSubTreeInfo->pwszKey,
			ERROR_LINE_NOT_FOUND);
	    if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	    {
		_JumpErrorStr(
			    hr,
			    error,
			    "infGetGeneralSubTreeByType",
			    pSubTreeInfo->pwszKey);
	    }
	    if (0 < cRemain)
	    {
		ZeroMemory(pSubTree, sizeof(*pSubTree));
	    }
	    count = 0;
	}
	cRemain -= count;
	pSubTree += count;
    }
    CSASSERT(0 == cRemain);
    *pcSubTree = cSubTree;
    *ppSubTree = rgSubTree;
    rgSubTree = NULL;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, pwszSection, pwszKey, pwszSubTreeSection);
    }
    if (NULL != pwszSubTreeSection)
    {
	LocalFree(pwszSubTreeSection);
    }
    if (NULL != rgSubTree)
    {
	infFreeGeneralSubTree(cSubTree, rgSubTree);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetNameConstraintsExtension -- fetch name constraints extension from INF file
//
// [NameConstraintsExtension]
// Include = NameConstraintsPermitted
// Exclude = NameConstraintsExcluded
//
// [NameConstraintsPermitted]
// ; the numeric second and third arguments are optional
// ; when present, the second argument is the minimum depth
// ; when present, the third argument is the maximum depth
// ; The IETF recommends against specifying dwMinimum & dwMaximum
// DNS = foo@domain.com
// DNS = domain1.domain.com, 3, 6
//
// [NameConstraintsExcluded]
// DNS = domain.com
// DNS = domain2.com
//
// Returns: encoded name constraints extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetNameConstraintsExtension;

HRESULT
myInfGetNameConstraintsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    WCHAR const *pwszKey = NULL;
    CERT_NAME_CONSTRAINTS_INFO NameConstraints;

    ZeroMemory(&NameConstraints, sizeof(NameConstraints));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    pwszKey = wszINFKEY_INCLUDE;
    hr = infGetGeneralSubTree(
		    hInf,
		    wszINFSECTION_NAMECONSTRAINTS,
		    pwszKey,
		    L"",
		    &NameConstraints.cPermittedSubtree,
		    &NameConstraints.rgPermittedSubtree);
    _PrintIfErrorStr2(
		hr,
		"infGetGeneralSubTree",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
    if (S_OK != hr && (HRESULT) ERROR_LINE_NOT_FOUND != hr)
    {
	goto error;
    }

    pwszKey = wszINFKEY_EXCLUDE;
    hr = infGetGeneralSubTree(
		    hInf,
		    wszINFSECTION_NAMECONSTRAINTS,
		    pwszKey,
		    NULL,
		    &NameConstraints.cExcludedSubtree,
		    &NameConstraints.rgExcludedSubtree);
    _PrintIfErrorStr2(
		hr,
		"infGetGeneralSubTree",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
    if (S_OK != hr && (HRESULT) ERROR_LINE_NOT_FOUND != hr)
    {
	goto error;
    }
    pwszKey = NULL;

    if (NULL == NameConstraints.rgPermittedSubtree &&
	NULL == NameConstraints.rgExcludedSubtree)
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "no data", hr);
    }
    hr = infGetCriticalFlag(
			hInf,
			wszINFSECTION_NAMECONSTRAINTS,
			FALSE,
			&pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME_CONSTRAINTS,
		    &NameConstraints,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, wszINFSECTION_NAMECONSTRAINTS, pwszKey, NULL);
    }
    pext->pszObjId = szOID_NAME_CONSTRAINTS;	// on error, too!

    if (NULL != NameConstraints.rgPermittedSubtree)
    {
	infFreeGeneralSubTree(
			NameConstraints.cPermittedSubtree,
			NameConstraints.rgPermittedSubtree);
    }
    if (NULL != NameConstraints.rgExcludedSubtree)
    {
	infFreeGeneralSubTree(
			NameConstraints.cExcludedSubtree,
			NameConstraints.rgExcludedSubtree);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetNameConstraintsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


VOID
infFreePolicyMappings(
    IN DWORD cPolicyMapping,
    IN OUT CERT_POLICY_MAPPING *pPolicyMapping)
{
    if (NULL != pPolicyMapping)
    {
	DWORD i;
	
	for (i = 0; i < cPolicyMapping; i++)
	{
	    CERT_POLICY_MAPPING *pMap = &pPolicyMapping[i];
	    
	    if (NULL != pMap->pszIssuerDomainPolicy)
	    {
		LocalFree(pMap->pszIssuerDomainPolicy);
	    }
	    if (NULL != pMap->pszSubjectDomainPolicy)
	    {
		LocalFree(pMap->pszSubjectDomainPolicy);
	    }
	}
	LocalFree(pPolicyMapping);
    }
}


HRESULT
infGetPolicyMappingsSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN OUT DWORD *pcPolicyMapping,
    OPTIONAL OUT CERT_POLICY_MAPPING *pPolicyMapping)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR wszIssuer[cwcVALUEMAX];
    WCHAR wszSubject[cwcVALUEMAX];
    DWORD i;
    DWORD cPolicyMappingIn;
    DWORD cPolicyMapping = 0;

    cPolicyMappingIn = MAXDWORD;
    if (NULL != pPolicyMapping)
    {
	cPolicyMappingIn = *pcPolicyMapping;
    }
    *pcPolicyMapping = 0;
    wszIssuer[0] = L'\0';
    wszSubject[0] = L'\0';

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    cPolicyMapping = 0;
    hr = infSetupFindFirstLine(hInf, pwszSection, NULL, &InfContext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

    while (TRUE)
    {
	wszIssuer[0] = L'\0';
	wszSubject[0] = L'\0';
	if (!SetupGetStringField(
			    &InfContext,
			    0,
			    wszIssuer,
			    ARRAYSIZE(wszIssuer),
			    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}
	if (iswdigit(wszIssuer[0]))
	{
	    if (!SetupGetStringField(
				&InfContext,
				1,
				wszSubject,
				ARRAYSIZE(wszSubject),
				NULL))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "SetupGetStringField");
	    }
	    if (!iswdigit(wszSubject[0]))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpErrorStr(hr, error, "bad OID", wszSubject);
	    }
	    if (NULL != pPolicyMapping)
	    {
		CERT_POLICY_MAPPING *pMap;

		if (cPolicyMappingIn <= cPolicyMapping)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
		    _JumpError(hr, error, "*pcPolicyMapping");
		}

		pMap = &pPolicyMapping[cPolicyMapping];
		if (!ConvertWszToSz(&pMap->pszIssuerDomainPolicy, wszIssuer, -1) ||
		    !ConvertWszToSz(&pMap->pszSubjectDomainPolicy, wszSubject, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToSz");
		}
	    }
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"Map[%u]: %ws = %ws\n",
		cPolicyMapping,
		wszIssuer,
		wszSubject));

	    cPolicyMapping++;
	}
	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupFindNextLine", hr);
	    break;
	}
    }
    *pcPolicyMapping = cPolicyMapping;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, pwszSection, wszIssuer, wszSubject);
    }
    return(hr);
}


HRESULT
infGetPolicyMappings(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OUT DWORD *pcPolicyMapping,
    OUT CERT_POLICY_MAPPING **ppPolicyMapping)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR wszIssuer[cwcVALUEMAX];
    WCHAR wszSubject[cwcVALUEMAX];
    DWORD i;
    DWORD cPolicyMapping = 0;
    CERT_POLICY_MAPPING *pPolicyMapping = NULL;

    *pcPolicyMapping = 0;
    *ppPolicyMapping = NULL;

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    cPolicyMapping = 0;
    hr = infGetPolicyMappingsSub(
			hInf,
			pwszSection,
			&cPolicyMapping,
			NULL);
    _JumpIfError3(
		hr,
		error,
		"infGetPolicyMappingsSub",
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

    *pcPolicyMapping = cPolicyMapping;
    pPolicyMapping = (CERT_POLICY_MAPPING *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cPolicyMapping * sizeof(*pPolicyMapping));
    if (NULL == pPolicyMapping)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = infGetPolicyMappingsSub(
			hInf,
			pwszSection,
			&cPolicyMapping,
			pPolicyMapping);
    _JumpIfError(hr, error, "infGetPolicyMappingsSub");

    CSASSERT(*pcPolicyMapping == cPolicyMapping);
    *ppPolicyMapping = pPolicyMapping;
    pPolicyMapping = NULL;
    hr = S_OK;

error:
    if (NULL != pPolicyMapping)
    {
	infFreePolicyMappings(*pcPolicyMapping, pPolicyMapping);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// infGetPolicyMappingSub -- fetch policy mapping extension from INF file
//
// [pwszSection]
// ; list of user defined policy mappings
// ; The first OID is for the Issuer Domain Policy, the second is for the
// ; Subject Domain Policy.  Each entry maps one Issuer Domain policy OID
// ; to a Subject Domain policy OID
//
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.87
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.89
//
// Returns: encoded policy mapping extension
//-------------------------------------------------------------------------

HRESULT
infGetPolicyMappingExtensionSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN char const *pszObjId,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_POLICY_MAPPINGS_INFO PolicyMappings;

    ZeroMemory(&PolicyMappings, sizeof(PolicyMappings));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infGetPolicyMappings(
		    hInf,
		    pwszSection,
		    &PolicyMappings.cPolicyMapping,
		    &PolicyMappings.rgPolicyMapping);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyMappings",
		pwszSection,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

    hr = infGetCriticalFlag(
			hInf,
			pwszSection,
			FALSE,
			&pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_POLICY_MAPPINGS,
		    &PolicyMappings,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, NULL, NULL);
    }
    pext->pszObjId = const_cast<char *>(pszObjId);	// on error, too!

    if (NULL != PolicyMappings.rgPolicyMapping)
    {
	infFreePolicyMappings(
			PolicyMappings.cPolicyMapping,
			PolicyMappings.rgPolicyMapping);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetPolicyMapping -- fetch policy mapping extension from INF file
//
// [PolicyMappingExtension]
// ; list of user defined policy mappings
// ; The first OID is for the Issuer Domain Policy, the second is for the
// ; Subject Domain Policy.  Each entry maps one Issuer Domain policy OID
// ; to a Subject Domain policy OID
//
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.87
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.89
//
// Returns: encoded policy mapping extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetPolicyMappingExtension;

HRESULT
myInfGetPolicyMappingExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyMappingExtensionSub(
				    hInf,
				    wszINFSECTION_POLICYMAPPINGS,
				    szOID_POLICY_MAPPINGS,
				    pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyMappingExtensionSub",
		wszINFSECTION_POLICYMAPPINGS,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetPolicyMappingExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetApplicationPolicyMapping -- fetch application policy mapping
// extension from INF file
//
// [ApplicationPolicyMappingExtension]
// ; list of user defined policy mappings
// ; The first OID is for the Issuer Domain Policy, the second is for the
// ; Subject Domain Policy.  Each entry maps one Issuer Domain policy OID
// ; to a Subject Domain policy OID
//
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.87
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.89
//
// Returns: encoded policy mapping extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetApplicationPolicyMappingExtension;

HRESULT
myInfGetApplicationPolicyMappingExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyMappingExtensionSub(
				    hInf,
				    wszINFSECTION_APPLICATIONPOLICYMAPPINGS,
				    szOID_APPLICATION_POLICY_MAPPINGS,
				    pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyMappingExtensionSub",
		wszINFSECTION_APPLICATIONPOLICYMAPPINGS,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetApplicationPolicyMappingExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// infGetPolicyConstraintsExtensionSub -- get policy constraints ext from INF
//
// [pwszSection]
// ; consists of two optional DWORDs
// ; They refer to the depth of the CA hierarchy that requires and inhibits
// ; Policy Mapping
// RequireExplicitPolicy = 3
// InhibitPolicyMapping = 5
//
// Returns: encoded policy constraints extension
//-------------------------------------------------------------------------

HRESULT
infGetPolicyConstraintsExtensionSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN char const *pszObjId,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_POLICY_CONSTRAINTS_INFO PolicyConstraints;
    WCHAR const *pwszKey = NULL;

    ZeroMemory(&PolicyConstraints, sizeof(PolicyConstraints));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }

    PolicyConstraints.fRequireExplicitPolicy = TRUE;
    pwszKey = wszINFKEY_REQUIREEXPLICITPOLICY;
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			pwszSection,
			pwszKey,
			&PolicyConstraints.dwRequireExplicitPolicySkipCerts);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		    hr,
		    "myInfGetNumericKeyValue",
		    wszINFKEY_REQUIREEXPLICITPOLICY,
		    ERROR_LINE_NOT_FOUND);
	PolicyConstraints.dwRequireExplicitPolicySkipCerts = 0;
	PolicyConstraints.fRequireExplicitPolicy = FALSE;
    }

    PolicyConstraints.fInhibitPolicyMapping = TRUE;
    pwszKey = wszINFKEY_INHIBITPOLICYMAPPING;
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			pwszSection,
			pwszKey,
			&PolicyConstraints.dwInhibitPolicyMappingSkipCerts);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		    hr,
		    "myInfGetNumericKeyValue",
		    wszINFKEY_INHIBITPOLICYMAPPING,
		    ERROR_LINE_NOT_FOUND);
	PolicyConstraints.dwInhibitPolicyMappingSkipCerts = 0;
	PolicyConstraints.fInhibitPolicyMapping = FALSE;
    }
    pwszKey = NULL;
    if (!PolicyConstraints.fRequireExplicitPolicy &&
	!PolicyConstraints.fInhibitPolicyMapping)
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "no policy constraints", hr);
    }

    hr = infGetCriticalFlag(
			hInf,
			pwszSection,
			FALSE,
			&pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_POLICY_CONSTRAINTS,
		    &PolicyConstraints,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    pext->pszObjId = const_cast<char *>(pszObjId);	// on error, too!

    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetPolicyConstraintsExtension -- get policy constraints ext from INF
//
// [PolicyConstraintsExtension]
// ; consists of two optional DWORDs
// ; They refer to the depth of the CA hierarchy that requires and inhibits
// ; Policy Mapping
// RequireExplicitPolicy = 3
// InhibitPolicyMapping = 5
//
// Returns: encoded policy constraints extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetPolicyConstraintsExtension;

HRESULT
myInfGetPolicyConstraintsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyConstraintsExtensionSub(
			    hInf,
			    wszINFSECTION_POLICYCONSTRAINTS,
			    szOID_POLICY_CONSTRAINTS,
			    pext);
    _JumpIfErrorStr2(
		hr,
		error,
		"infGetPolicyConstraintsExtensionSub",
		wszINFSECTION_POLICYCONSTRAINTS,
		S_FALSE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetPolicyConstraintsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetApplicationPolicyConstraintsExtension -- get application policy
// constraints extension from INF
//
// [ApplicationPolicyConstraintsExtension]
// ; consists of two optional DWORDs
// ; They refer to the depth of the CA hierarchy that requires and inhibits
// ; Policy Mapping
// RequireExplicitPolicy = 3
// InhibitPolicyMapping = 5
//
// Returns: encoded policy constraints extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetApplicationPolicyConstraintsExtension;

HRESULT
myInfGetApplicationPolicyConstraintsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyConstraintsExtensionSub(
			    hInf,
			    wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS,
			    szOID_APPLICATION_POLICY_CONSTRAINTS,
			    pext);
    _JumpIfErrorStr2(
		hr,
		error,
		"infGetPolicyConstraintsExtensionSub",
		wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS,
		S_FALSE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetApplicationPolicyConstraintsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetCrossCertDistributionPointsExtension -- fetch Cross CertDist Point
//	URLs from CAPolicy.inf
//
// [CrossCertificateDistributionPointsExtension]
// SyncDeltaTime = 24
// URL = http://CRLhttp.site.com/Public/MyCA.crt
// URL = ftp://CRLftp.site.com/Public/MyCA.crt
//
// Returns: encoded cross cert dist points extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetCrossCertDistributionPointsExtension;

HRESULT
myInfGetCrossCertDistributionPointsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    CROSS_CERT_DIST_POINTS_INFO ccdpi;
    CERT_ALT_NAME_INFO AltNameInfo;
    CERT_ALT_NAME_ENTRY *rgAltEntry = NULL;
    WCHAR const *pwsz;
    WCHAR *pwszzURL = NULL;
    BYTE *pbData = NULL;
    DWORD cbData;
    DWORD i;
    WCHAR const *pwszKey = NULL;

    ZeroMemory(&ccdpi, sizeof(ccdpi));
    ZeroMemory(&AltNameInfo, sizeof(AltNameInfo));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }

    hr = infSetupFindFirstLine(hInf, wszINFSECTION_CCDP, NULL, &InfContext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		wszINFSECTION_CCDP,
		S_FALSE,
		ERROR_LINE_NOT_FOUND);

    pwszKey = wszINFKEY_CCDPSYNCDELTATIME;
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			wszINFSECTION_CCDP,
			pwszKey,
			&ccdpi.dwSyncDeltaTime);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		    hr,
		    "myInfGetNumericKeyValue",
		    pwszKey,
		    ERROR_LINE_NOT_FOUND);
	ccdpi.dwSyncDeltaTime = 0;
    }
    pwszKey = wszINFKEY_URL;
    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_CCDP,
		pwszKey,
		&pext->fCritical,
		&pwszzURL);
    _JumpIfErrorStr3(
		hr,
		error,
		"myInfGetKeyList",
		pwszKey,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);
    pwszKey = NULL;

    if (NULL != pwszzURL)
    {
	for (pwsz = pwszzURL; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    AltNameInfo.cAltEntry++;
        }
    }

    if (0 != AltNameInfo.cAltEntry)
    {
	ccdpi.cDistPoint = 1;
	ccdpi.rgDistPoint = &AltNameInfo;

	AltNameInfo.rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
		    LMEM_FIXED | LMEM_ZEROINIT,
		    AltNameInfo.cAltEntry * sizeof(AltNameInfo.rgAltEntry[0]));
	if (NULL == AltNameInfo.rgAltEntry)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	i = 0;
	for (pwsz = pwszzURL; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    AltNameInfo.rgAltEntry[i].pwszURL = const_cast<WCHAR *>(pwsz);
	    AltNameInfo.rgAltEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;
	    i++;
	}
	CSASSERT(i == AltNameInfo.cAltEntry);
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CROSS_CERT_DIST_POINTS,
		    &ccdpi,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, wszINFSECTION_CCDP, pwszKey, NULL);
    }
    pext->pszObjId = szOID_CROSS_CERT_DIST_POINTS;	// on error, too!

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetCrossCertDistributionPointsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));

    if (NULL != AltNameInfo.rgAltEntry)
    {
	LocalFree(AltNameInfo.rgAltEntry);
    }
    if (NULL != pwszzURL)
    {
	LocalFree(pwszzURL);
    }
    if (NULL != rgAltEntry)
    {
	LocalFree(rgAltEntry);
    }
    return(hr);
}




HRESULT
infAddKey(
    IN WCHAR const *pwszName,
    IN OUT DWORD *pcValues,
    IN OUT INFVALUES **prgInfValues,
    OUT INFVALUES **ppInfValues)
{
    HRESULT hr;
    INFVALUES *rgInfValues;
    WCHAR *pwszKeyT = NULL;
    
    hr = myDupString(pwszName, &pwszKeyT);
    _JumpIfError(hr, error, "myDupString");

    if (NULL == *prgInfValues)
    {
	CSASSERT(0 == *pcValues);
	rgInfValues = (INFVALUES *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    sizeof(**prgInfValues));
    }
    else
    {
	CSASSERT(0 != *pcValues);
	rgInfValues = (INFVALUES *) LocalReAlloc(
				*prgInfValues,
				(*pcValues + 1) * sizeof(**prgInfValues),
				LMEM_MOVEABLE | LMEM_ZEROINIT);
    }
    if (NULL == rgInfValues)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
		hr,
		error,
		NULL == *prgInfValues? "LocalAlloc" : "LocalReAlloc");
    }
    *prgInfValues = rgInfValues;
    *ppInfValues = &rgInfValues[*pcValues];
    (*pcValues)++;
    (*ppInfValues)->pwszKey = pwszKeyT;
    pwszKeyT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszKeyT)
    {
	LocalFree(pwszKeyT);
    }
    return(hr);
}


HRESULT
infAddValue(
    IN WCHAR const *pwszValue,
    IN OUT INFVALUES *pInfValues)
{
    HRESULT hr;
    WCHAR *pwszValueT = NULL;
    WCHAR **rgpwszValues = NULL;
    
    hr = myDupString(pwszValue, &pwszValueT);
    _JumpIfError(hr, error, "myDupString");

    if (NULL == pInfValues->rgpwszValues)
    {
	CSASSERT(0 == pInfValues->cValues);
	rgpwszValues = (WCHAR **) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(*pInfValues->rgpwszValues));
    }
    else
    {
	CSASSERT(0 != pInfValues->cValues);
	rgpwszValues = (WCHAR **) LocalReAlloc(
		pInfValues->rgpwszValues,
		(pInfValues->cValues + 1) * sizeof(*pInfValues->rgpwszValues),
		LMEM_MOVEABLE);
    }
    if (NULL == rgpwszValues)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
	    hr,
	    error,
	    NULL == pInfValues->rgpwszValues? "LocalAlloc" : "LocalReAlloc");
    }
    pInfValues->rgpwszValues = rgpwszValues;
    pInfValues->rgpwszValues[pInfValues->cValues] = pwszValueT;
    pInfValues->cValues++;
    pwszValueT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszValueT)
    {
	LocalFree(pwszValueT);
    }
    return(hr);
}


VOID
myInfFreeSectionValues(
    IN DWORD cInfValues,
    IN OUT INFVALUES *rgInfValues)
{
    DWORD i;
    DWORD ival;
    INFVALUES *pInfValues;
    
    if (NULL != rgInfValues)
    {
	for (i = 0; i < cInfValues; i++)
	{
	    pInfValues = &rgInfValues[i];

	    if (NULL != pInfValues->pwszKey)
	    {
		LocalFree(pInfValues->pwszKey);
	    }
	    if (NULL != pInfValues->rgpwszValues)
	    {
		for (ival = 0; ival < pInfValues->cValues; ival++)
		{
		    if (NULL != pInfValues->rgpwszValues[ival])
		    {
			LocalFree(pInfValues->rgpwszValues[ival]);
		    }
		}
		LocalFree(pInfValues->rgpwszValues);
	    }
	}
	LocalFree(rgInfValues);
    }
}


//+------------------------------------------------------------------------
// myInfGetSectionValues -- fetch all section values from INF file
//
// [pwszSection]
// KeyName1 = KeyValue1a, KeyValue1b, ...
// KeyName2 = KeyValue2a, KeyValue2b, ...
// ...
// KeyNameN = KeyValueNa, KeyValueNb, ...
//
// Returns: array of key names and values
//-------------------------------------------------------------------------

HRESULT
myInfGetSectionValues(
    IN  HINF hInf,
    IN  WCHAR const *pwszSection,
    OUT DWORD *pcInfValues,
    OUT INFVALUES **prgInfValues)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR wszName[MAX_PATH];
    WCHAR wszValue[cwcVALUEMAX];
    DWORD i;
    DWORD cInfValues = 0;
    INFVALUES *rgInfValues = NULL;
    INFVALUES *pInfValues;

    *pcInfValues = 0;
    *prgInfValues = NULL;
    wszName[0] = L'\0';
    wszValue[0] = L'\0';
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(hInf, pwszSection, NULL, &InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    while (TRUE)
    {
	wszName[0] = L'\0';
	wszValue[0] = L'\0';
	if (!SetupGetStringField(
			    &InfContext,
			    0,
			    wszName,
			    ARRAYSIZE(wszName),
			    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetupGetStringField");
	}

	//wprintf(L"%ws[0]:\n", wszName);

	hr = infAddKey(wszName, &cInfValues, &rgInfValues, &pInfValues);
	_JumpIfError(hr, error, "infAddKey");

	for (i = 1; ; i++)
	{
	    wszValue[0] = L'\0';
	    if (!SetupGetStringField(
				&InfContext,
				i,
				wszValue,
				ARRAYSIZE(wszValue),
				NULL))
	    {
		hr = myHLastError();
		if (1 == i)
		{
		    _JumpError(hr, error, "SetupGetStringField");
		}
		break;
	    }
	    //wprintf(L"%ws[%u] = %ws\n", wszName, i, wszValue);

	    hr = infAddValue(wszValue, pInfValues);
	    _JumpIfError(hr, error, "infAddValue");
	}

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupFindNextLine(end)", hr);
	    break;
	}
    }
    *pcInfValues = cInfValues;
    *prgInfValues = rgInfValues;
    rgInfValues = NULL;
    hr = S_OK;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, wszName, wszValue);
    }
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetSectionValues hr=%x --> c=%d\n",
	hr,
	*pcInfValues));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\manage.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        manage.cpp
//
// Contents:    Cert Server Policy & Exit manage module callouts
//
// History:     10-Sept-98       mattt created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__      __dwFILE_CERTLIB_MANAGE_CPP__


//+-------------------------------------------------------------------------
// IManageModule dispatch support

//+------------------------------------
// GetProperty method:

OLECHAR *managemodule_apszGetProperty[] = {
    TEXT("GetProperty"),
    TEXT("strConfig"),
    TEXT("strStorageLocation"),
    TEXT("strPropertyName"),
    TEXT("Flags"),
};

//+------------------------------------
// SetProperty method:

OLECHAR *managemodule_apszSetProperty[] = {
    TEXT("SetProperty"),
    TEXT("strConfig"),
    TEXT("strStorageLocation"),
    TEXT("strPropertyName"),
    TEXT("Flags"),
    TEXT("pvarProperty"),
};

//+------------------------------------
// Configure method:

OLECHAR *managemodule_apszConfigure[] = {
    TEXT("Configure"),
    TEXT("strConfig"),
    TEXT("strStorageLocation"),
    TEXT("Flags"),
};



//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtManageModule[] =
{
#define MANAGEMODULE_GETPROPERTY            0
    DECLARE_DISPATCH_ENTRY(managemodule_apszGetProperty)

#define MANAGEMODULE_SETPROPERTY            1
    DECLARE_DISPATCH_ENTRY(managemodule_apszSetProperty)

#define MANAGEMODULE_CONFIGURE              2
    DECLARE_DISPATCH_ENTRY(managemodule_apszConfigure)
};
#define CMANAGEMODULEDISPATCH	(ARRAYSIZE(g_adtManageModule))

 
HRESULT
ManageModule_GetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG ColumnType,
    OUT VOID *pProperty)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strStorageLocation = NULL;
    BSTR strPropertyName = NULL;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiManage && NULL != pdiManage->pDispatchTable);

    hr = E_OUTOFMEMORY;
    strConfig = SysAllocString(pwszConfig);
    if (NULL == strConfig)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strStorageLocation = SysAllocString(pwszStorageLocation);
    if (NULL == strStorageLocation)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strPropertyName = SysAllocString(pwszPropertyName);
    if (NULL == strPropertyName)
    {
	_JumpError(hr, error, "SysAllocString");
    }

    switch (ColumnType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    __try
    {
	if (NULL != pdiManage->pDispatch)
	{
	    VARIANT avar[4];

	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
            avar[1].vt = VT_BSTR;
            avar[1].bstrVal = strStorageLocation;
            avar[2].vt = VT_BSTR;
            avar[2].bstrVal = strPropertyName;
            avar[3].vt = VT_I4;
            avar[3].lVal = dwFlags;

	    hr = DispatchInvoke(
			    pdiManage,
			    MANAGEMODULE_GETPROPERTY,
			    ARRAYSIZE(avar),
			    avar,
			    RetType,
                pProperty);
	    _JumpIfError(hr, error, "Invoke(GetName)");
	}
	else
	{
	    hr = ((ICertManageModule *) pdiManage->pUnknown)->GetProperty(
							strConfig,
							strStorageLocation,
							strPropertyName,
							dwFlags,
							&varResult);
	    _JumpIfError(hr, error, "ICertManageModule::GetProperty");

	    hr = DispatchGetReturnValue(&varResult, RetType, pProperty);
	    _JumpIfError2(hr, error, "DispatchGetReturnValue", CERTSRV_E_PROPERTY_EMPTY);
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "GetProperty: Exception");
	fException = TRUE;
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strStorageLocation)
    {
	SysFreeString(strStorageLocation);
    }
    if (NULL != strPropertyName)
    {
	SysFreeString(strPropertyName);
    }
    VariantClear(&varResult);
    return(hr);
}

HRESULT
ManageModule_SetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG ColumnType,
    IN VOID* pProperty)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strStorageLocation = NULL;
    BSTR strPropertyName = NULL;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress;
    VARIANT varResult;

    CSASSERT(NULL != pdiManage && NULL != pdiManage->pDispatchTable);

    hr = E_OUTOFMEMORY;
    strConfig = SysAllocString(pwszConfig);
    if (NULL == strConfig)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strStorageLocation = SysAllocString(pwszStorageLocation);
    if (NULL == strStorageLocation)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strPropertyName = SysAllocString(pwszPropertyName);
    if (NULL == strPropertyName)
    {
	_JumpError(hr, error, "SysAllocString");
    }

    switch (ColumnType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    varResult.vt = VT_BSTR;
	    varResult.bstrVal = (BSTR) pProperty;
	    break;

	case PROPTYPE_DATE:
	    varResult.vt = VT_DATE;
	    CopyMemory(&varResult.date, pProperty, sizeof(DATE));
	    break;

	case PROPTYPE_LONG:
	    varResult.vt = VT_I4;
	    varResult.lVal = *(LONG *) pProperty;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    __try
    {
	if (NULL != pdiManage->pDispatch)
	{
	    VARIANT avar[5];

	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
            avar[1].vt = VT_BSTR;
            avar[1].bstrVal = strStorageLocation;
            avar[2].vt = VT_BSTR;
            avar[2].bstrVal = strPropertyName;
            avar[3].vt = VT_I4;
            avar[3].lVal = dwFlags;
            avar[4] = varResult;

	    hr = DispatchInvoke(
			    pdiManage,
			    MANAGEMODULE_SETPROPERTY,
			    ARRAYSIZE(avar),
			    avar,
			    0,
			    NULL);
	    _JumpIfError(hr, error, "Invoke(GetName)");
	}
	else
	{
	    hr = ((ICertManageModule *) pdiManage->pUnknown)->SetProperty(
							strConfig,
							strStorageLocation,
							strPropertyName,
							dwFlags,
							&varResult);
	    _JumpIfError(hr, error, "ICertManageModule::SetProperty");
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "SetProperty: Exception");
	fException = TRUE;
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strStorageLocation)
    {
	SysFreeString(strStorageLocation);
    }
    if (NULL != strPropertyName)
    {
	SysFreeString(strPropertyName);
    }
    //VariantInit(&varResult);    // this owned no memory 
    return(hr);
}




HRESULT 
ManageModule_Configure( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN DWORD dwFlags)
{
    HRESULT hr;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress;
    BSTR strConfig = NULL;
    BSTR strStorageLocation = NULL;

    CSASSERT(NULL != pdiManage && NULL != pdiManage->pDispatchTable);

    hr = E_OUTOFMEMORY;
    strConfig = SysAllocString(pwszConfig);
    if (NULL == strConfig)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strStorageLocation = SysAllocString(pwszStorageLocation);
    if (NULL == strStorageLocation)
    {
	_JumpError(hr, error, "SysAllocString");
    }

    __try
    {
	if (NULL != pdiManage->pDispatch)
	{
	    VARIANT avar[3];

	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
            avar[1].vt = VT_BSTR;
            avar[1].bstrVal = strStorageLocation;
            avar[2].vt = VT_I4;
            avar[2].lVal = dwFlags;

	    hr = DispatchInvoke(
			    pdiManage,
			    MANAGEMODULE_CONFIGURE,
			    ARRAYSIZE(avar),
			    avar,
			    0,
			    NULL);
	    _JumpIfError(hr, error, "Invoke(Configure)");
	}
	else
	{
	    hr = ((ICertManageModule *) pdiManage->pUnknown)->Configure(
							    strConfig,
							    strStorageLocation,
							    dwFlags);
	    _JumpIfError(hr, error, "ICertManageModule::Configure");
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Configure: Exception");
	fException = TRUE;
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strStorageLocation)
    {
	SysFreeString(strStorageLocation);
    }
    return(hr);
}


HRESULT
ManageModule_Init(
    IN DWORD Flags,
    IN TCHAR const *pszProgID,      // morph for difft instances of this class
    IN CLSID const *pclsid,		
    OUT DISPATCHINTERFACE *pdiManage)
{
    HRESULT hr;

    hr = DispatchSetup(
		Flags,
		CLSCTX_INPROC_SERVER,
		pszProgID, 
		pclsid,
		&IID_ICertManageModule,
		CMANAGEMODULEDISPATCH,
		g_adtManageModule,
		pdiManage);

    _JumpIfError(hr, error, "DispatchSetup");

    pdiManage->pDispatchTable = g_adtManageModule;

error:
    return(hr);
}


HRESULT
ManageModule_Init2(
    IN BOOL fIDispatch,
    IN ICertManageModule *pManage,
    OUT DISPATCHINTERFACE *pdiManage)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;

    pdiManage->pDispatchTable = NULL;
    pdiManage->pDispatch = NULL;
    pdiManage->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pManage->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CMANAGEMODULEDISPATCH,
			g_adtManageModule,
			pdiManage);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiManage->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pManage->AddRef();
	pdiManage->pUnknown = (IUnknown *) pManage;
	hr = S_OK;
    }
    pdiManage->pDispatchTable = g_adtManageModule;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ManageModule_Release(
    IN OUT DISPATCHINTERFACE *pdiManage)
{
    DispatchRelease(pdiManage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\mapi.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlib.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <ntlsa.h>

#define wszCERTMAPIINFO	L"CertServerMapiInfo"


void
InitLsaString(
    OUT LSA_UNICODE_STRING *plus,
    IN WCHAR const *pwsz,
    IN DWORD cb)
{
    if (MAXDWORD == cb)
    {
	cb = lstrlenW(pwsz) * sizeof(WCHAR);
    }

    plus->Buffer = const_cast<WCHAR *>(pwsz);
    plus->Length = (USHORT) cb;
    plus->MaximumLength = plus->Length + sizeof(WCHAR);
}


HRESULT
OpenPolicy(
    IN WCHAR const *pwszServerName,
    DWORD DesiredAccess,
    LSA_HANDLE *phPolicy)
{
    HRESULT hr;
    LSA_OBJECT_ATTRIBUTES oa;
    LSA_UNICODE_STRING ServerString;
    LSA_UNICODE_STRING *plusServer;

    ZeroMemory(&oa, sizeof(oa));

    plusServer = NULL;
    if (NULL != pwszServerName)
    {
        InitLsaString(&ServerString, pwszServerName, MAXDWORD);
        plusServer = &ServerString;
    }
    hr = LsaOpenPolicy(plusServer, &oa, DesiredAccess, phPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "LsaOpenPolicy");
    }
 
error:
    return(hr);
}


HRESULT
SaveString(
    IN WCHAR const *pwszIn,
    IN DWORD cwcIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwsz;

    *ppwszOut = NULL;
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwcIn + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwsz, pwszIn, cwcIn * sizeof(WCHAR));
    pwsz[cwcIn] = L'\0';
    *ppwszOut = pwsz;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// myGetMapiInfo -- Retrieve a Name/Password from a global LSA secret
//+--------------------------------------------------------------------------

HRESULT
myGetMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR **ppwszProfileName,
    OUT WCHAR **ppwszLogonName,
    OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    LSA_HANDLE hPolicy;
    UNICODE_STRING lusSecretKeyName;
    UNICODE_STRING *plusSecretData = NULL;
    DWORD cwc;
    DWORD cwcProfileName;
    DWORD cwcLogonName;
    DWORD cwcPassword;
    WCHAR const *pwsz;
    WCHAR *pwszProfileName = NULL;
    WCHAR *pwszLogonName = NULL;
    WCHAR *pwszPassword = NULL;

    if (NULL == ppwszProfileName ||
	NULL == ppwszLogonName ||
	NULL == ppwszPassword)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "no data");
    }

    InitLsaString(&lusSecretKeyName, wszCERTMAPIINFO, MAXDWORD);

    hr = OpenPolicy(pwszServerName, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "OpenPolicy");
    }

    hr = LsaRetrievePrivateData(hPolicy, &lusSecretKeyName, &plusSecretData);
    LsaClose(hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_PrintError2(hr, "LsaRetrievePrivateData", STATUS_OBJECT_NAME_NOT_FOUND);
	if ((HRESULT) STATUS_OBJECT_NAME_NOT_FOUND == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpError2(hr, error, "LsaRetrievePrivateData", hr);
    }

    if (NULL == plusSecretData || NULL == plusSecretData->Buffer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no data");
    }

    pwsz = (WCHAR const *) plusSecretData->Buffer;
    cwc = plusSecretData->Length / sizeof(WCHAR);

    for (cwcProfileName = 0; cwcProfileName < cwc; cwcProfileName++)
    {
	if (L'\0' == pwsz[cwcProfileName])
	{
	    break;
	}
    }
    if (cwcProfileName == cwc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad data");
    }

    for (cwcLogonName = cwcProfileName + 1; cwcLogonName < cwc; cwcLogonName++)
    {
	if (L'\0' == pwsz[cwcLogonName])
	{
	    break;
	}
    }
    if (cwcLogonName == cwc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad data");
    }
    cwcLogonName -= cwcProfileName + 1;

    cwcPassword = cwc - (cwcProfileName + 1 + cwcLogonName + 1);

    hr = SaveString(pwsz, cwcProfileName, &pwszProfileName);
    _JumpIfError(hr, error, "SaveString");

    hr = SaveString(&pwsz[cwcProfileName + 1], cwcLogonName, &pwszLogonName);
    _JumpIfError(hr, error, "SaveString");

    hr = SaveString(
		&pwsz[cwcProfileName + 1 + cwcLogonName + 1],
		cwcPassword,
		&pwszPassword);
    _JumpIfError(hr, error, "SaveString");

    *ppwszProfileName = pwszProfileName;
    pwszProfileName = NULL;

    *ppwszLogonName = pwszLogonName;
    pwszLogonName = NULL;

    *ppwszPassword = pwszPassword;
    pwszPassword = NULL;

error:
    if (NULL != pwszProfileName)
    {
	ZeroMemory(pwszProfileName, cwcProfileName * sizeof(WCHAR));
	LocalFree(pwszProfileName);
    }
    if (NULL != pwszLogonName)
    {
	ZeroMemory(pwszLogonName, cwcLogonName * sizeof(WCHAR));
	LocalFree(pwszLogonName);
    }
    if (NULL != pwszPassword)
    {
	ZeroMemory(pwszPassword, cwcPassword * sizeof(WCHAR));
	LocalFree(pwszPassword);
    }
    if (NULL != plusSecretData)
    {
	if (NULL != plusSecretData->Buffer)
	{
	    ZeroMemory(plusSecretData->Buffer, plusSecretData->Length);
	}
	LsaFreeMemory(plusSecretData);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// mySaveMapiInfo -- Persist the specified Name/Password to a global LSA secret
//+--------------------------------------------------------------------------

HRESULT
mySaveMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR const *pwszProfileName,
    OUT WCHAR const *pwszLogonName,
    OUT WCHAR const *pwszPassword)
{
    HRESULT hr;
    LSA_HANDLE hPolicy;
    UNICODE_STRING lusSecretKeyName;
    UNICODE_STRING lusSecretData;
    WCHAR wszSecret[MAX_PATH];
    DWORD cwc;
    WCHAR *pwsz;

    if (NULL == pwszProfileName ||
	NULL == pwszLogonName ||
	NULL == pwszPassword)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cwc = lstrlen(pwszProfileName) + 1 +
	    lstrlen(pwszLogonName) + 1 +
	    lstrlen(pwszPassword);

    if (ARRAYSIZE(wszSecret) <= cwc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "overflow");
    }
    pwsz = wszSecret;
    wcscpy(pwsz, pwszProfileName);

    pwsz += lstrlen(pwsz) + 1;
    wcscpy(pwsz, pwszLogonName);

    pwsz += lstrlen(pwsz) + 1;
    wcscpy(pwsz, pwszPassword);

    InitLsaString(&lusSecretData, wszSecret, cwc * sizeof(WCHAR));
    InitLsaString(&lusSecretKeyName, wszCERTMAPIINFO, MAXDWORD);

    hr = OpenPolicy(pwszServerName, POLICY_CREATE_SECRET, &hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "OpenPolicy");
    }

    hr = LsaStorePrivateData(hPolicy, &lusSecretKeyName, &lusSecretData);
    LsaClose(hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "LsaStorePrivateData");
    }
    hr = S_OK;

error:
    ZeroMemory(wszSecret, sizeof(wszSecret));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\keygen.c ===
/***************************************************/
/* Copyright (C) Microsoft Corporation, 1996 - 1999*/
/***************************************************/
/* Abstract syntax: keygen */
/* Created: Mon Jan 27 13:51:10 1997 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -listingfile keygen.lst -noshortennames -1990 -noconstraints
 */

#include   <stddef.h>
#include   "etype.h"
#include   "keygen.h"

static char copyright[] = 
   "Copyright (C) Microsoft Corporation, 1996 - 1999";


void DLL_ENTRY_FDEF _ossinit_keygen(struct ossGlobal *world) {
    ossLinkBer(world);
}

static unsigned short _pduarray[] = {
    7, 8, 10, 13
};

static struct etype _etypearray[] = {
    {16, 0, 0, NULL, 4, 4, 4, 4, 56, 0, 26, 0},
    {-1, 2, 0, NULL, 8, 0, 4, 4, 8, 0, 62, 0},
    {-1, 4, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 6, 22, NULL, 8, 0, 4, 4, 8, 0, 25, 0},
    {-1, 8, 0, NULL, 16, 0, 0, 0, 8, 0, 51, 0},
    {-1, 9, 11, NULL, 88, 2, 1, 0, 8, 0, 12, 0},
    {-1, 17, 0, NULL, 4, 0, 4, 0, 8, 0, 0, 0},
    {-1, 19, 21, NULL, 12, 2, 0, 0, 8, 2, 12, 0},
    {-1, 29, 31, NULL, 96, 2, 0, 0, 8, 4, 12, 0},
    {-1, 39, 0, NULL, 16, 0, 0, 0, 8, 0, 51, 0},
    {-1, 40, 42, NULL, 112, 3, 0, 0, 8, 6, 12, 0},
    {-1, 52, 54, NULL, 104, 2, 0, 0, 8, 9, 12, 0},
    {-1, 62, 0, NULL, 8, 0, 4, 4, 40, 0, 3, 0},
    {-1, 64, 66, NULL, 200, 3, 0, 0, 8, 11, 12, 0}
};

static struct efield _efieldarray[] = {
    {4, 0, -1, 0, 0},
    {72, 4, 0, 0, 1},
    {0, 1, -1, 0, 0},
    {8, 6, -1, 0, 0},
    {0, 5, -1, 0, 0},
    {88, 2, -1, 0, 0},
    {0, 9, -1, 0, 0},
    {16, 5, -1, 0, 0},
    {104, 2, -1, 0, 0},
    {0, 8, -1, 0, 0},
    {96, 3, -1, 0, 0},
    {0, 11, -1, 0, 0},
    {104, 5, -1, 0, 0},
    {192, 12, -1, 0, 0}
};

static Etag _tagarray[] = {
    1, 0x0006, 1, 0x0002, 1, 0x0003, 1, 0x0016, 0, 1,
    0x0010, 13, 16, 1, 0x0006, 1, 0, 1, 0x0002, 1,
    0x0010, 23, 26, 1, 0x0002, 1, 1, 0x0002, 2, 1,
    0x0010, 33, 36, 1, 0x0010, 1, 1, 0x0003, 2, 0,
    1, 0x0010, 45, 46, 49, 0, 1, 0x0010, 2, 1,
    0x0003, 3, 1, 0x0010, 56, 59, 1, 0x0010, 1, 1,
    0x0016, 2, 1, 0x0003, 1, 0x0010, 69, 72, 75, 1,
    0x0010, 1, 1, 0x0010, 2, 1, 0x0003, 3
};

static struct eheader _head = {_ossinit_keygen, -1, 15, 772, 4, 14,
    _pduarray, _etypearray, _efieldarray, NULL, _tagarray,
    NULL, NULL, NULL, 0};

#ifdef _OSSGETHEADER
void *DLL_ENTRY_FDEF ossGetHeader()
{
    return &_head;
}
#endif /* _OSSGETHEADER */

void *keygen = &_head;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\keygen2.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crypt.cpp
//
// Contents:    Cert Server wrapper routines
//
// History:     17-Oct-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>

#define CRYPT32_SP3_ONLY

#ifdef CRYPT32_SP3_ONLY

#ifdef __cplusplus
extern "C" {
#endif
#include "keygen.h"
#ifdef __cplusplus
}
#endif

#include "crypttls.h"
#include "ossconv.h"
#include "ossutil.h"

// All the *pInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  (((Len) + 7) & ~7)

HCRYPTOSSGLOBAL hOssGlobal;


//+-------------------------------------------------------------------------
//  Function:  GetPog
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized OssGlobal data structure
//--------------------------------------------------------------------------

__inline OssGlobal *
GetPog(VOID)
{
    return(I_CryptGetOssGlobal(hOssGlobal));
}


HRESULT
HError(VOID)
{
    HRESULT hr;

    hr = GetLastError();
    if (hr <= 0xffff)
    {
        hr = HRESULT_FROM_WIN32(hr);
    }

    if (!FAILED(hr))
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return(hr);
}


VOID
OssX509GetIA5ConvertedToUnicode(
    IN IA5STRING *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT LPWSTR *ppwsz,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssUtilGetIA5StringConvertedToUnicode(
				    pOss->length,
				    pOss->value,
				    dwFlags,
				    ppwsz,
				    ppbExtra,
				    plRemainExtra);
}


VOID
OssX509GetObjectId(
    IN ObjectID *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CHAR **pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    DWORD cb;
    DWORD cbExtra;
    char ach[MAX_PATH];
    LONG lRemainExtra;

    cb = sizeof(ach);
    if (!OssConvFromObjectIdentifier(pOss->count, pOss->value, ach, &cb))
    {
	goto error;
    }
    CSASSERT(strlen(ach) + 1 == cb);
    cbExtra = INFO_LEN_ALIGN(cb);

    lRemainExtra = *plRemainExtra;
    lRemainExtra -= cbExtra;
    if (0 <= lRemainExtra)
    {
	*pInfo = (char *) *ppbExtra;
	CopyMemory(*pInfo, ach, cb);
	*ppbExtra += cbExtra;
    }
    *plRemainExtra = lRemainExtra;

error:
    ;
}


__inline VOID
OssX509GetAlgorithmParameters(
    IN OpenType *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CRYPT_OBJID_BLOB *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssUtilGetOctetString(
		    pOss->length,
		    (BYTE *) pOss->encoded,
		    dwFlags,
		    pInfo,
		    ppbExtra,
		    plRemainExtra);
}


VOID
OssX509GetAlgorithm(
    IN AlgorithmIdentifier *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CRYPT_ALGORITHM_IDENTIFIER *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    if (0 <= *plRemainExtra)
    {
	ZeroMemory((VOID *) pInfo, sizeof(*pInfo));
    }
    OssX509GetObjectId(
		    &pOss->algorithm,
		    dwFlags,
		    &pInfo->pszObjId,
		    ppbExtra,
		    plRemainExtra);

    if (pOss->bit_mask & parameters_present)
    {
	OssX509GetAlgorithmParameters(
			    &pOss->parameters,
			    dwFlags,
			    &pInfo->Parameters,
			    ppbExtra,
			    plRemainExtra);
    }
}


__inline VOID
OssX509GetPublicKeyBlob(
    IN BITSTRING const *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CRYPT_BIT_BLOB *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssUtilGetBitString(
		    pOss->length,
		    pOss->value,
		    dwFlags,
		    pInfo,
		    ppbExtra,
		    plRemainExtra);
}


VOID
OssX509GetPublicKeyInfo(
    IN SubjectPublicKeyInfo *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssX509GetAlgorithm(
		    &pOss->algorithm,
		    dwFlags,
		    &pInfo->Algorithm,
		    ppbExtra,
		    plRemainExtra);

    OssX509GetPublicKeyBlob(
		    &pOss->subjectPublicKey,
		    dwFlags,
		    &pInfo->PublicKey,
		    ppbExtra,
		    plRemainExtra);
}
//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------

__inline BOOL
OssInfoDecodeAndAlloc(
    IN int pdunum,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT VOID **ppOssInfo)
{
    return(OssUtilDecodeAndAllocInfo(
				GetPog(),
				pdunum,
				pbEncoded,
				cbEncoded,
				ppOssInfo));
}


//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------

VOID
OssInfoFree(
    IN int pdunum,
    IN VOID *pOssInfo)
{
    if (NULL != pOssInfo)
    {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        OssUtilFreeInfo(GetPog(), pdunum, pOssInfo);
        SetLastError(dwErr);
    }
}


//+-------------------------------------------------------------------------
//  KeyGen Info Decode (OSS X509)
//--------------------------------------------------------------------------

BOOL
DecodeKeyGen(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT VOID *pInfo,
    IN OUT DWORD *pcbInfo)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    SignedPublicKeyAndChallenge *pOssInfo = NULL;
    CERT_KEYGEN_REQUEST_INFO *pcgi;
    BYTE *pbExtra;
    LONG lRemainExtra;
    LONG lAlignExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }
    if (0 == hOssGlobal)
    {
	hOssGlobal = I_CryptInstallOssGlobal(keygen, 0, NULL);
	if (0 == hOssGlobal)
	{
	    goto error;
	}
    }
    if (!OssInfoDecodeAndAlloc(
			    SignedPublicKeyAndChallenge_PDU,
			    pbEncoded,
			    cbEncoded,
			    (VOID **) &pOssInfo))
    {
	hr = HError();
	printf("OssInfoDecodeAndAlloc returned %u (%x)\n", hr, hr);
        goto error;
    }

    lRemainExtra = (LONG) *pcbInfo - INFO_LEN_ALIGN(sizeof(*pcgi));
    pbExtra = NULL;

    // for lRemainExtra < 0, LENGTH_ONLY calculation

    if (0 <= lRemainExtra)
    {
	pcgi = (CERT_KEYGEN_REQUEST_INFO *) pInfo;

        // Default all optional fields to zero
        ZeroMemory((VOID *) pcgi, sizeof(*pcgi));
	pcgi->dwVersion = 1;

        pbExtra = (BYTE *) pcgi + INFO_LEN_ALIGN(sizeof(*pcgi));
    }

    OssX509GetPublicKeyInfo(
			&pOssInfo->publicKeyAndChallenge.spki,
			dwFlags,
			&pcgi->SubjectPublicKeyInfo,
			&pbExtra,
			&lRemainExtra);

    OssX509GetIA5ConvertedToUnicode(
			&pOssInfo->publicKeyAndChallenge.challenge,
			dwFlags,
			&pcgi->pwszChallengeString,
			&pbExtra,
			&lRemainExtra);

    if (0 <= lRemainExtra)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (NULL != pInfo)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
	    goto error;
	}
    }
    fResult = TRUE;

error:
    OssInfoFree(SignedPublicKeyAndChallenge_PDU, pOssInfo);
    if (!fResult)
    {
	*pcbInfo = 0;
    }
    return(fResult);
}
#endif


BOOL
myDecodeKeyGenRequest(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OUT CERT_KEYGEN_REQUEST_INFO **ppKeyGenRequest,
    OUT DWORD *pcbKeyGenRequest)
{
    BOOL fOk = FALSE;

#ifdef CRYPT32_SP3_ONLY
    *ppKeyGenRequest = NULL;
    *pcbKeyGenRequest = 0;

    if (!DecodeKeyGen(
		pbRequest,
		cbRequest,
		0,				// dwFlags
		NULL,
		pcbKeyGenRequest))
    {
	goto error;
    }
    *ppKeyGenRequest = (CERT_KEYGEN_REQUEST_INFO *) LocalAlloc(LMEM_FIXED, *pcbKeyGenRequest);
    if (NULL == *ppKeyGenRequest)
    {
	_PrintError(E_OUTOFMEMORY, "LocalAlloc(KeyGenRequest)");
	SetLastError(E_OUTOFMEMORY);
	goto error;
    }

    if (!DecodeKeyGen(
		pbRequest,
		cbRequest,
		0,				// dwFlags
		*ppKeyGenRequest,
		pcbKeyGenRequest))
    {
	goto error;
    }
#else
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_KEYGEN_REQUEST_TO_BE_SIGNED,
		    pbRequest,
		    cbRequest,
		    (VOID **) ppKeyGenRequest,
		    pcbKeyGenRequest))
    {
	err = myHLastError();
	_JumpError(err, error, "myDecodeObject");
    }
#endif
    fOk = TRUE;

error:
    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\ldap.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ldap.cpp
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#undef LdapMapErrorToWin32
#include <winldap.h>
#define LdapMapErrorToWin32	Use_myHLdapError_Instead_Of_LdapMapErrorToWin32

#include <ntldap.h>

#include "csldap.h"
#include "certacl.h"
#include "certtype.h"
#include "cainfop.h"
#include "csber.h"

static CHAR s_sdBerValue[] = {
    BER_SEQUENCE,
    3 * sizeof(BYTE),		// three byte sequence
    BER_INTEGER,
    1 * sizeof(BYTE),		// of one-byte integer
    DACL_SECURITY_INFORMATION
	//OWNER_SECURITY_INFORMATION |
	//GROUP_SECURITY_INFORMATION
};

static LDAPControl s_se_info_control =
{
    LDAP_SERVER_SD_FLAGS_OID_W,
    { ARRAYSIZE(s_sdBerValue), s_sdBerValue },
    TRUE
};
LDAPControl *g_rgLdapControls[2] = { &s_se_info_control, NULL };


// Revocation templates

WCHAR const g_wszHTTPRevocationURLTemplate[] = // Fetch CRL via http:
    L"http://"
	wszFCSAPARM_SERVERDNSNAME
	L"/CertEnroll/"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CRLFILENAMESUFFIX
	wszFCSAPARM_CRLDELTAFILENAMESUFFIX
	L".crl";

WCHAR const g_wszFILERevocationURLTemplate[] = // Fetch CRL via file:
    L"file://\\\\"
	wszFCSAPARM_SERVERDNSNAME
	L"\\CertEnroll\\"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CRLFILENAMESUFFIX
	wszFCSAPARM_CRLDELTAFILENAMESUFFIX
	L".crl";

WCHAR const g_wszASPRevocationURLTemplate[] = // ASP revocation check via https:
    L"https://"
	wszFCSAPARM_SERVERDNSNAME
	L"/CertEnroll/nsrev_"
	wszFCSAPARM_SANITIZEDCANAME
	L".asp";

#define wszCDPDNTEMPLATE			\
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	wszFCSAPARM_CRLFILENAMESUFFIX		\
	L","					\
	L"CN="					\
	wszFCSAPARM_SERVERSHORTNAME		\
	L","					\
	L"CN=CDP,"				\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszzLDAPRevocationURLTemplate[] = // Fetch CRL via ldap:
    L"ldap:///"
	wszCDPDNTEMPLATE
	wszFCSAPARM_DSCRLATTRIBUTE
	L"\0";

// Publish CRL via ldap:
WCHAR const g_wszCDPDNTemplate[] = wszCDPDNTEMPLATE;


// AIA templates

WCHAR const g_wszHTTPIssuerCertURLTemplate[] = // Fetch CA Cert via http:
    L"http://"
	wszFCSAPARM_SERVERDNSNAME
	L"/CertEnroll/"
	wszFCSAPARM_SERVERDNSNAME
	L"_"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CERTFILENAMESUFFIX
	L".crt"
	L"\0";

WCHAR const g_wszFILEIssuerCertURLTemplate[] = // Fetch CA Cert via http:
    L"file://\\\\"
	wszFCSAPARM_SERVERDNSNAME
	L"\\CertEnroll\\"
	wszFCSAPARM_SERVERDNSNAME
	L"_"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CERTFILENAMESUFFIX
	L".crt"
	L"\0";

#define wszAIADNTEMPLATE \
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	L","					\
	L"CN=AIA,"				\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszzLDAPIssuerCertURLTemplate[] = // Fetch CA Cert via ldap:
    L"ldap:///"
	wszAIADNTEMPLATE
	wszFCSAPARM_DSCACERTATTRIBUTE
	L"\0";

// Publish CA Cert via ldap:
WCHAR const g_wszAIADNTemplate[] = wszAIADNTEMPLATE;


#define wszNTAUTHDNTEMPLATE \
    L"CN=NTAuthCertificates,"			\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszLDAPNTAuthURLTemplate[] = // Fetch NTAuth Certs via ldap:
    L"ldap:///"
	wszNTAUTHDNTEMPLATE
	wszFCSAPARM_DSCACERTATTRIBUTE;


#define wszROOTTRUSTDNTEMPLATE \
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	L","					\
	L"CN=Certification Authorities,"	\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszLDAPRootTrustURLTemplate[] = // Fetch Root Certs via ldap:
    L"ldap:///"
	wszROOTTRUSTDNTEMPLATE
	wszFCSAPARM_DSCACERTATTRIBUTE;


#define wszKRADNTEMPLATE \
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	L","					\
	L"CN=KRA,"				\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszzLDAPKRACertURLTemplate[] = // Fetch KRA Cert via ldap:
    L"ldap:///"
	wszKRADNTEMPLATE
	wszFCSAPARM_DSKRACERTATTRIBUTE
	L"\0";

// Publish KRA Certs via ldap:
WCHAR const g_wszKRADNTemplate[] = wszKRADNTEMPLATE;


//+--------------------------------------------------------------------------
//
// Routine Description:
//    This routine simply queries the operational attributes for the
//    domaindn and configdn.
//    
//    The strings returned by this routine must be freed by the caller
//    using SysFreeString
//
// Parameters:
//    pld -- a valid handle to an ldap session
//    pstrDomainDN -- a pointer to a string to be allocated in this routine
//    pstrConfigDN -- a pointer to a string to be allocated in this routine
//
// Return Values:
//    HRESULT for operation error.
//    
//---------------------------------------------------------------------------

HRESULT 
myGetAuthoritativeDomainDn(
    IN LDAP *pld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN)
{
    HRESULT hr;
    LDAPMessage *pSearchResult = NULL;
    LDAPMessage *pEntry;
    WCHAR *pwszAttrName;
    BerElement *pber;
    WCHAR **rgpwszValues;
    WCHAR *apwszAttrArray[3];
    WCHAR *pwszDefaultNamingContext = L"defaultNamingContext";
    WCHAR *pwszConfigurationNamingContext = L"configurationNamingContext";
    WCHAR *pwszObjectClassFilter = L"objectClass=*";
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;

    // Set the OUT parameters to NULL

    if (NULL != pstrConfigDN)
    {
        *pstrConfigDN = NULL;
    }
    if (NULL != pstrDomainDN)
    {
        *pstrDomainDN = NULL;
    }

    // Query for the ldap server oerational attributes to obtain the default
    // naming context.

    apwszAttrArray[0] = pwszDefaultNamingContext;
    apwszAttrArray[1] = pwszConfigurationNamingContext;
    apwszAttrArray[2] = NULL;  // this is the sentinel

    hr = ldap_search_s(
		    pld,
		    NULL,
		    LDAP_SCOPE_BASE,
		    pwszObjectClassFilter,
		    apwszAttrArray,
		    FALSE,
		    &pSearchResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_sW");

    pEntry = ldap_first_entry(pld, pSearchResult);
    if (NULL == pEntry)
    {
	hr = myHLdapLastError(pld, NULL);
	_JumpError(hr, error, "ldap_first_entry");
    }

    pwszAttrName = ldap_first_attribute(pld, pEntry, &pber);
    while (NULL != pwszAttrName)
    {
	BSTR *pstr = NULL;
	
	if (NULL != pstrDomainDN &&
	    0 == lstrcmpi(pwszAttrName, pwszDefaultNamingContext))
	{
	    pstr = &strDomainDN;
	}
	else
	if (NULL != pstrConfigDN &&
	    0 == lstrcmpi(pwszAttrName, pwszConfigurationNamingContext))
	{
	    pstr = &strConfigDN;
	}
	if (NULL != pstr && NULL == *pstr)
	{
	    rgpwszValues = ldap_get_values(pld, pEntry, pwszAttrName);
	    if (NULL != rgpwszValues)
	    {
		if (NULL != rgpwszValues[0])
		{
		    *pstr = SysAllocString(rgpwszValues[0]);
		    if (NULL == *pstr)
		    { 
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "SysAllocString");
		    }
		}
		ldap_value_free(rgpwszValues);
	    }
	}
	ldap_memfree(pwszAttrName);
	pwszAttrName = ldap_next_attribute(pld, pEntry, pber);
    }

    if ((NULL != pstrDomainDN && NULL == strDomainDN) ||
	(NULL != pstrConfigDN && NULL == strConfigDN))
    {
	// We couldn't get default domain info - bail out

	hr =  HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	_JumpError(hr, error, "missing domain info");
    }
    if (NULL != pstrDomainDN)
    {
	*pstrDomainDN = strDomainDN;
	strDomainDN = NULL;
    }
    if (NULL != pstrConfigDN)
    {
	*pstrConfigDN = strConfigDN;
	strConfigDN = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pSearchResult)
    {
        ldap_msgfree(pSearchResult);
    }
    myLdapClose(NULL, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
myDomainFromDn(
    IN WCHAR const *pwszDN,
    OPTIONAL OUT WCHAR **ppwszDomainDNS)
{
    HRESULT hr;
    DWORD cwcOut;
    WCHAR *pwszOut;
    WCHAR **ppwszExplodedDN = NULL;
    WCHAR **ppwsz;
    WCHAR wszDC[4];
    WCHAR *pwsz;

    *ppwszDomainDNS = NULL;
    ppwszExplodedDN = ldap_explode_dn(const_cast<WCHAR *>(pwszDN), 0);
    if (NULL == ppwszExplodedDN)
    {
	hr = myHLdapLastError(NULL, NULL);
	_JumpError(hr, error, "ldap_explode_dn");
    }

    cwcOut = 0;
    for (ppwsz = ppwszExplodedDN; NULL != *ppwsz; ppwsz++)
    {
	pwsz = *ppwsz;

	wcsncpy(wszDC, pwsz, ARRAYSIZE(wszDC) - 1);
	wszDC[ARRAYSIZE(wszDC) - 1] = L'\0';
	if (0 == lstrcmpi(wszDC, L"DC="))
        {
	    pwsz += ARRAYSIZE(wszDC) - 1;
            if (0 != cwcOut)
            {
                cwcOut++;
            }
            cwcOut += wcslen(pwsz);
        }
    }

    pwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwcOut + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszDomainDNS = pwszOut;

    for (ppwsz = ppwszExplodedDN; NULL != *ppwsz; ppwsz++)
    {
	pwsz = *ppwsz;

	wcsncpy(wszDC, pwsz, ARRAYSIZE(wszDC) - 1);
	wszDC[ARRAYSIZE(wszDC) - 1] = L'\0';
	if (0 == lstrcmpi(wszDC, L"DC="))
        {
	    pwsz += ARRAYSIZE(wszDC) - 1;
            if (pwszOut != *ppwszDomainDNS)
            {
		*pwszOut++ = L'.';
            }
	    wcscpy(pwszOut, pwsz);
            pwszOut += wcslen(pwsz);
        }
    }
    CSASSERT(wcslen(*ppwszDomainDNS) == cwcOut);
    hr = S_OK;

error:
    if (NULL != ppwszExplodedDN)
    {
        ldap_value_free(ppwszExplodedDN);
    }
    return(hr);
}


HRESULT
myLdapOpen(
    OUT LDAP **ppld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN)
{
    HRESULT hr;
    LDAP *pld = NULL;

    *ppld = NULL;
    CSASSERT(NULL == pstrConfigDN || NULL == *pstrConfigDN);
    CSASSERT(NULL == pstrDomainDN || NULL == *pstrDomainDN);

    hr = myRobustLdapBind(&pld, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    // domain and config containers (%5, %6)

    hr = myGetAuthoritativeDomainDn(pld, pstrDomainDN, pstrConfigDN);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "myGetAuthoritativeDomainDn");
    }
    *ppld = pld;
    pld = NULL;

error:
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    return(hr);
}


VOID
myLdapClose(
    OPTIONAL IN LDAP *pld,
    OPTIONAL IN BSTR strDomainDN,
    OPTIONAL IN BSTR strConfigDN)
{
    if (NULL != strDomainDN)
    {
	SysFreeString(strDomainDN);
    }
    if (NULL != strConfigDN)
    {
	SysFreeString(strConfigDN);
    }
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
}


BOOL
myLdapRebindRequired(
    IN ULONG ldaperrParm,
    OPTIONAL IN LDAP *pld)
{
    BOOL fRebindRequired = FALSE;
    
    if (LDAP_SERVER_DOWN == ldaperrParm ||
	LDAP_UNAVAILABLE == ldaperrParm ||
	LDAP_TIMEOUT == ldaperrParm ||
	NULL == pld)
    {
	fRebindRequired = TRUE;
    }
    else
    {
	ULONG ldaperr;
	VOID *pvReachable = NULL;	// clear high bits for 64-bit machines

	ldaperr = ldap_get_option(pld, LDAP_OPT_HOST_REACHABLE, &pvReachable);
	if (LDAP_SUCCESS != ldaperr || LDAP_OPT_ON != pvReachable)
	{
	    fRebindRequired = TRUE;
	}
    }
    return(fRebindRequired);
}


HRESULT
myLdapGetDSHostName(
    IN LDAP *pld,
    OUT WCHAR **ppwszHostName)
{
    HRESULT hr;
    ULONG ldaperr;
    
    ldaperr = ldap_get_option(pld, LDAP_OPT_HOST_NAME, ppwszHostName);
    if (LDAP_SUCCESS != ldaperr)
    {
	*ppwszHostName = NULL;
    }
    hr = myHLdapError(pld, ldaperr, NULL);
    return(hr);
}


HRESULT
myLdapCreateContainer(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN BOOL  fSkipObject,       // Does the DN contain a leaf object name
    IN DWORD cMaxLevel,         // create this many nested containers as needed
    IN PSECURITY_DESCRIPTOR pContainerSD,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR const *pwsz = pwszDN;
    LDAPMod objectClass;
    LDAPMod advancedView;
    LDAPMod securityDescriptor;
    WCHAR *papwszshowInAdvancedViewOnly[2] = { L"TRUE", NULL };
    WCHAR *objectClassVals[3];
    LDAPMod *mods[4];
    struct berval *sdVals[2];
    struct berval sdberval;

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &advancedView;
    mods[2] = &securityDescriptor;
    mods[3] = NULL;

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = TEXT("objectclass");
    objectClass.mod_values = objectClassVals;

    advancedView.mod_op = LDAP_MOD_ADD;
    advancedView.mod_type = TEXT("showInAdvancedViewOnly");
    advancedView.mod_values = papwszshowInAdvancedViewOnly;

    objectClassVals[0] = TEXT("top");
    objectClassVals[1] = TEXT("container");
    objectClassVals[2] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;

    if (IsValidSecurityDescriptor(pContainerSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pContainerSD);
        sdberval.bv_val = (char *)pContainerSD;
    }
    else
    {
        sdberval.bv_len = 0;
        sdberval.bv_val = NULL;
    }
    
    // If the DN passed in was for the full object that goes in the container
    // (and not the container itself), skip past the CN for the leaf object.

    if (fSkipObject)
    {
        // Look for the CN of the container for this object.
        pwsz = wcsstr(&pwsz[3], L"CN=");
        if (NULL == pwsz)
        {
            // If there was no CN, then we are contained in an OU or DC,
            // and we don't need to do the create.

            hr = S_OK;
            goto error;
        }
    }
    if (0 != wcsncmp(pwsz, L"CN=", 3))
    {
        // We're not pointing to a simple container, so don't create this DN.  

        hr = S_OK;
        goto error;
    }

    pwszDN = pwsz;
    if (0 != cMaxLevel)
    {
        pwsz = wcsstr(&pwsz[3], L"CN=");
        if (NULL != pwsz)
        {
            // The remaining DN is a container, so try to create it.

            hr = myLdapCreateContainer(
				    pld,
				    pwsz,
				    FALSE,
				    cMaxLevel - 1,
				    pContainerSD,
				    ppwszError);
            _JumpIfError(hr, error, "myLdapCreateContainer");

	    CSASSERT(NULL == ppwszError || NULL == *ppwszError);
        }
    }

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS Container: '%ws'\n", pwszDN));

    // Create the container

    hr = ldap_add_ext_s(
		    pld,
		    const_cast<WCHAR *>(pwszDN),
		    mods,
		    g_rgLdapControls,
		    NULL);
    _PrintIfErrorStr2(
		hr,
		"ldap_add_ext_s(container)",
		pwszDN,
		LDAP_ALREADY_EXISTS);
    if ((HRESULT) LDAP_SUCCESS != hr && (HRESULT) LDAP_ALREADY_EXISTS != hr)
    {
	hr = myHLdapError(pld, hr, ppwszError);
        _JumpIfErrorStr(hr, error, "ldap_add_ext_s(container)", pwszDN);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
TrimURLDN(
    IN WCHAR const *pwszIn,
    OPTIONAL OUT WCHAR **ppwszSuffix,
    OUT WCHAR **ppwszDN)
{
    HRESULT hr;
    WCHAR *pwsz;
    
    if (NULL != ppwszSuffix)
    {
	*ppwszSuffix = NULL;
    }
    *ppwszDN = NULL;
    pwsz = wcschr(pwszIn, L':');
    if (NULL != pwsz)
    {
	pwszIn = &pwsz[1];
    }
    while (L'/' == *pwszIn)
    {
	pwszIn++;
    }
    hr = myDupString(pwszIn, ppwszDN);
    _JumpIfError(hr, error, "myDupString");

    pwsz = wcschr(*ppwszDN, L'?');
    if (NULL != pwsz)
    {
	*pwsz++ = L'\0';
	if (NULL != ppwszSuffix)
	{
	    *ppwszSuffix = pwsz;
	}
    }
    CSASSERT(S_OK == hr);

error:
    if (S_OK != hr && NULL != *ppwszDN)
    {
	LocalFree(*ppwszDN);
	*ppwszDN = NULL;
    }
    return(hr);
}


HRESULT
CreateCertObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN DWORD dwObjectType,	// LPC_*
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pContainerSD = NULL;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    // get default DS CA security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY, NULL, &pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    // get default DS AIA security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY, NULL, &pContainerSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    if (LPC_CREATECONTAINER & dwObjectType)
    {
	hr = myLdapCreateContainer(
			    pld,
			    pwszDN,
			    TRUE,
			    0,
			    pContainerSD,
			    ppwszError);
	if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
	{
	    _JumpIfError(hr, error, "myLdapCreateContainer");
	}
    }

    if (LPC_CREATEOBJECT & dwObjectType)
    {
	switch (LPC_OBJECTMASK & dwObjectType)
	{
	    case LPC_CAOBJECT:
		hr = myLdapCreateCAObject(
				    pld,
				    pwszDN,
				    NULL,
				    0,
				    pSD,
				    pdwDisposition,
				    ppwszError);
		if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
		{
		    _JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszDN);
		}
		break;

	    case LPC_KRAOBJECT:
	    case LPC_USEROBJECT:
	    case LPC_MACHINEOBJECT:
		hr = myLdapCreateUserObject(
				    pld,
				    pwszDN,
				    NULL,
				    0,
				    pSD,
				    dwObjectType,
				    pdwDisposition,
				    ppwszError);
		if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
		{
		    _JumpIfErrorStr(hr, error, "myLdapCreateUserObject", pwszDN);
		}
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "dwObjectType");
	}
    }
    hr = S_OK;

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    if (NULL != pContainerSD)
    {
        LocalFree(pContainerSD);
    }
    return(hr);
}


HRESULT
AddCertToAttribute(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    DWORD cber;
    DWORD iber;
    DWORD i;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    struct berval **ppberval = NULL;
    struct berval **prgpberVals = NULL;
    FILETIME ft;
    BOOL fDeleteExpiredCert = FALSE;
    BOOL fNewCertMissing = TRUE;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    apwszAttrs[0] = const_cast<WCHAR *>(pwszAttribute);
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		LDAP_SCOPE_BASE,		// scope
		NULL,				// filter
		apwszAttrs,			// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, NULL);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszDN);
    }
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	// No entries were found.

	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_count_entries");
    }

    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_first_entry");
    }

    ppberval = ldap_get_values_len(
			    pld,
			    pres,
			    const_cast<WCHAR *>(pwszAttribute));
    cber = 0;
    if (NULL != ppberval)
    {
	while (NULL != ppberval[cber])
	{
	    cber++;
	}
    }
    prgpberVals = (struct berval **) LocalAlloc(
					LMEM_FIXED,
					(cber + 2) * sizeof(prgpberVals[0]));
    if (NULL == prgpberVals)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Delete any certs that are at least one day old

    GetSystemTimeAsFileTime(&ft);
    myMakeExprDateTime(&ft, -1, ENUM_PERIOD_DAYS);

    iber = 0;
    if (NULL != ppberval)
    {
	for (i = 0; NULL != ppberval[i]; i++)
	{
	    BOOL fCopyBER = TRUE;
	    struct berval *pberval = ppberval[i];

	    if (pberval->bv_len == 1 && pberval->bv_val[0] == 0)
	    {
		fCopyBER = FALSE;	// remove zero byte placeholder value
	    }
	    else
	    if (pccPublish->cbCertEncoded == pberval->bv_len &&
		0 == memcmp(
			pberval->bv_val,
			pccPublish->pbCertEncoded,
			pccPublish->cbCertEncoded))
	    {
		fCopyBER = FALSE;	// remove duplicates to avoid ldap error
		fNewCertMissing = FALSE;
	    }
	    else
	    {
		CERT_CONTEXT const *pcc;

		pcc = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    (BYTE *) pberval->bv_val,
					    pberval->bv_len);
		if (NULL == pcc)
		{
		    hr = myHLastError();
		    _PrintError(hr, "CertCreateCertificateContext");
		}
		else
		{
		    if (0 > CompareFileTime(&pcc->pCertInfo->NotAfter, &ft))
		    {
			fCopyBER = FALSE;
			fDeleteExpiredCert = TRUE;
			DBGPRINT((DBG_SS_CERTLIB, "Deleting expired cert %u\n", i));
		    }
		    CertFreeCertificateContext(pcc);
		}
	    }
	    if (fCopyBER)
	    {
		prgpberVals[iber++] = pberval;
	    }
	}
    }

    // set disposition assuming there's nothing to do:

    *pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;

    if (fNewCertMissing || fDeleteExpiredCert)
    {
	struct berval certberval;
	LDAPMod *mods[2];
	LDAPMod certmod;

	mods[0] = &certmod;
	mods[1] = NULL;

	certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
	certmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	certmod.mod_bvalues = prgpberVals;

	prgpberVals[iber++] = &certberval;
	prgpberVals[iber] = NULL;

	certberval.bv_val = (char *) pccPublish->pbCertEncoded;
	certberval.bv_len = pccPublish->cbCertEncoded;

	hr = ldap_modify_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    }
    hr = S_OK;

error:
    if (NULL != prgpberVals)
    {
	LocalFree(prgpberVals);
    }
    if (NULL != ppberval)
    {
	ldap_value_free_len(ppberval);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
AddCRLToAttribute(
    IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    struct berval **ppberval = NULL;
    LDAPMod crlmod;
    LDAPMod *mods[2];
    struct berval *crlberVals[2];
    struct berval crlberval;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    apwszAttrs[0] = const_cast<WCHAR *>(pwszAttribute);
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		LDAP_SCOPE_BASE,		// scope
		NULL,				// filter
		apwszAttrs,			// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, NULL);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszDN);
    }
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	// No entries were found.

	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_count_entries");
    }

    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_first_entry");
    }

    ppberval = ldap_get_values_len(
			    pld,
			    pres,
			    const_cast<WCHAR *>(pwszAttribute));

    if (NULL != ppberval &&
	NULL != ppberval[0] &&
	pCRLPublish->cbCrlEncoded == ppberval[0]->bv_len &&
	0 == memcmp(
		ppberval[0]->bv_val,
		pCRLPublish->pbCrlEncoded,
		pCRLPublish->cbCrlEncoded))
    {
	// set disposition assuming there's nothing to do:

	*pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;
    }
    else
    {
	mods[0] = &crlmod;
	mods[1] = NULL;

	crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
	crlmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	crlmod.mod_bvalues = crlberVals;

	crlberVals[0] = &crlberval;
	crlberVals[1] = NULL;

	crlberval.bv_val = (char *) pCRLPublish->pbCrlEncoded;
	crlberval.bv_len = pCRLPublish->cbCrlEncoded;

	hr = ldap_modify_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    }
    hr = S_OK;

error:
    if (NULL != ppberval)
    {
	ldap_value_free_len(ppberval);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
myLdapPublishCertToDS(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    IN DWORD dwObjectType,	// LPC_*
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR *pwszDN = NULL;
    WCHAR *pwszSuffix;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    hr = TrimURLDN(pwszURL, &pwszSuffix, &pwszDN);
    _JumpIfError(hr, error, "TrimURLDN");

    if (0 == lstrcmpi(wszDSUSERCERTATTRIBUTE, pwszAttribute) ||
	0 == lstrcmpi(wszDSKRACERTATTRIBUTE, pwszAttribute))
    {
	if (LPC_CAOBJECT == (LPC_OBJECTMASK & dwObjectType))
	{
	    hr = E_INVALIDARG;
	}
    }
    else
    if (0 == lstrcmpi(wszDSCACERTATTRIBUTE, pwszAttribute) ||
	0 == lstrcmpi(wszDSCROSSCERTPAIRATTRIBUTE, pwszAttribute))
    {
	if (LPC_CAOBJECT != (LPC_OBJECTMASK & dwObjectType))
	{
	    hr = E_INVALIDARG;
	}
    }
    else
    {
	hr = E_INVALIDARG;
    }
    _JumpIfErrorStr(hr, error, "Bad Cert Attribute", pwszAttribute);

    *pdwDisposition = LDAP_SUCCESS;
    if ((LPC_CREATECONTAINER | LPC_CREATEOBJECT) & dwObjectType)
    {
	hr = CreateCertObject(
			pld,
			pwszDN,
			dwObjectType,
			pdwDisposition,
			ppwszError);
	_JumpIfError(hr, error, "CreateCertObject");

	CSASSERT(NULL == ppwszError || NULL == *ppwszError);
    }

    hr = AddCertToAttribute(
		    pld,
		    pccPublish,
		    pwszDN,
		    pwszAttribute,
		    pdwDisposition,
		    ppwszError);
    _JumpIfError(hr, error, "AddCertToAttribute");

    CSASSERT(NULL == ppwszError || NULL == *ppwszError);

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}


HRESULT
myLdapPublishCRLToDS(
    IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR *pwszDN = NULL;
    WCHAR *pwszSuffix;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pContainerSD = NULL;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    hr = TrimURLDN(pwszURL, &pwszSuffix, &pwszDN);
    _JumpIfError(hr, error, "TrimURLDN");

    if (0 == lstrcmpi(wszDSBASECRLATTRIBUTE, pwszAttribute))
    {
    }
    else if (0 == lstrcmpi(wszDSDELTACRLATTRIBUTE, pwszAttribute))
    {
    }
    else
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "Bad CRL Attribute", pwszAttribute);
    }

    // get default DS CDP security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CDP_DS_SECURITY, NULL, &pSD);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetSDFromTemplate");
	pSD = NULL;
    }

    // get default DS AIA security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY, NULL, &pContainerSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = myLdapCreateContainer(pld, pwszDN, TRUE, 1, pContainerSD, ppwszError);
    _JumpIfError(hr, error, "myLdapCreateContainer");

    hr = myLdapCreateCDPObject(
			pld,
			pwszDN,
			NULL != pSD? pSD : pContainerSD,
			pdwDisposition,
			ppwszError);
    _JumpIfErrorStr(hr, error, "myLdapCreateCDPObject", pwszDN);

    hr = AddCRLToAttribute(
		    pld,
		    pCRLPublish,
		    pwszDN,
		    pwszAttribute,
		    pdwDisposition,
		    ppwszError);
    _JumpIfError(hr, error, "AddCRLToAttribute");

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    if (NULL != pContainerSD)
    {
        LocalFree(pContainerSD);
    }
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}


HRESULT
CreateOrUpdateDSObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN LDAPMod **prgmodsCreate,
    OPTIONAL IN LDAPMod **prgmodsUpdate,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    ULONG ldaperr;

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    ldaperr = ldap_add_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			prgmodsCreate,
			g_rgLdapControls,
			NULL);
    *pdwDisposition = ldaperr;
    _PrintIfErrorStr2(ldaperr, "ldap_add_ext_s", pwszDN, LDAP_ALREADY_EXISTS);

    if (ldaperr == LDAP_ALREADY_EXISTS)
    {
	if (NULL == prgmodsUpdate)
	{
	    ldaperr = LDAP_SUCCESS;
	}
	else
	{
	    ldaperr = ldap_modify_ext_s(
				pld,
				const_cast<WCHAR *>(pwszDN),
				prgmodsUpdate,
				NULL,
				NULL);
	    *pdwDisposition = ldaperr;
	    _PrintIfErrorStr2(
			ldaperr,
			"ldap_modify_ext_s",
			pwszDN,
			LDAP_ATTRIBUTE_OR_VALUE_EXISTS);
	    if (LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
	    {
		ldaperr = LDAP_SUCCESS;
	    }
	}
    }
    if (ldaperr != LDAP_SUCCESS)
    {
	hr = myHLdapError(pld, ldaperr, ppwszError);
        _JumpError(hr, error, "Add/Update DS");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myLdapCreateCAObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    BYTE ZeroByte = 0;

    LDAPMod objectClass;
    LDAPMod securityDescriptor;
    LDAPMod crlmod;
    LDAPMod arlmod;
    LDAPMod certmod;

    struct berval sdberval;
    struct berval crlberval;
    struct berval arlberval;
    struct berval certberval;

    WCHAR *objectClassVals[3];
    struct berval *sdVals[2];
    struct berval *crlVals[2];
    struct berval *arlVals[2];
    struct berval *certVals[2];

    LDAPMod *mods[6];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &securityDescriptor;
    mods[2] = &crlmod;
    mods[3] = &arlmod;
    mods[4] = &certmod;	// must be last!
    mods[5] = NULL;

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;
    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSCACLASSNAME;
    objectClassVals[2] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;
    sdberval.bv_len = 0;
    sdberval.bv_val = NULL;
    if (IsValidSecurityDescriptor(pSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pSD);
	sdberval.bv_val = (char *) pSD;
    }

    crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    crlmod.mod_type = wszDSBASECRLATTRIBUTE;
    crlmod.mod_bvalues = crlVals;
    crlVals[0] = &crlberval;
    crlVals[1] = NULL;
    crlberval.bv_len = sizeof(ZeroByte);
    crlberval.bv_val = (char *) &ZeroByte;

    arlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    arlmod.mod_type = wszDSAUTHORITYCRLATTRIBUTE;
    arlmod.mod_bvalues = arlVals;
    arlVals[0] = &arlberval;
    arlVals[1] = NULL;
    arlberval.bv_len = sizeof(ZeroByte);
    arlberval.bv_val = (char *) &ZeroByte;

    certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    certmod.mod_type = wszDSCACERTATTRIBUTE;
    certmod.mod_bvalues = certVals;
    certVals[0] = &certberval;
    certVals[1] = NULL;
    certberval.bv_len = sizeof(ZeroByte);
    certberval.bv_val = (char *) &ZeroByte;
    if (NULL != pbCert)
    {
	certberval.bv_len = cbCert;
	certberval.bv_val = (char *) pbCert;
    }

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS CA Object: '%ws'\n", pwszDN));

    CSASSERT(&certmod == mods[ARRAYSIZE(mods) - 2]);
    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL != pbCert? &mods[ARRAYSIZE(mods) - 2] : NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(CA object)");

error:
    return(hr);
}


HRESULT
myLdapCreateUserObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    IN DWORD dwObjectType,	// LPC_* (but LPC_CREATE* is ignored)
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    ULONG ldaperr;
    BYTE ZeroByte = 0;

    LDAPMod objectClass;
    LDAPMod securityDescriptor;
    LDAPMod certmod;

    struct berval sdberval;
    struct berval certberval;

    WCHAR *objectClassVals[6];
    struct berval *sdVals[2];
    struct berval *certVals[2];

    LDAPMod *mods[4];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &securityDescriptor;
    mods[2] = &certmod;	// must be last!
    mods[3] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;
    sdberval.bv_len = 0;
    sdberval.bv_val = NULL;
    if (IsValidSecurityDescriptor(pSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pSD);
        sdberval.bv_val = (char *) pSD;
    }

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;

    DBGCODE(WCHAR const *pwszObjectType);
    switch (LPC_OBJECTMASK & dwObjectType)
    {
	case LPC_KRAOBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSKRACLASSNAME;
	    objectClassVals[2] = NULL;
	    DBGCODE(pwszObjectType = L"KRA");
	    break;

	case LPC_USEROBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSPERSONCLASSNAME;
	    objectClassVals[2] = wszDSORGPERSONCLASSNAME;
	    objectClassVals[3] = wszDSUSERCLASSNAME;
	    objectClassVals[4] = NULL;
	    DBGCODE(pwszObjectType = L"User");
	    break;

	case LPC_MACHINEOBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSPERSONCLASSNAME;
	    objectClassVals[2] = wszDSORGPERSONCLASSNAME;
	    objectClassVals[3] = wszDSUSERCLASSNAME;
	    objectClassVals[4] = wszDSMACHINECLASSNAME;
	    objectClassVals[5] = NULL;
	    DBGCODE(pwszObjectType = L"Machine");
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwObjectType");
    }

    certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    certmod.mod_type = wszDSUSERCERTATTRIBUTE;
    certmod.mod_bvalues = certVals;
    certVals[0] = &certberval;
    certVals[1] = NULL;
    certberval.bv_len = sizeof(ZeroByte);
    certberval.bv_val = (char *) &ZeroByte;
    if (NULL != pbCert)
    {
	certberval.bv_len = cbCert;
	certberval.bv_val = (char *) pbCert;
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"Creating DS %ws Object: '%ws'\n",
	pwszObjectType,
	pwszDN));

    CSASSERT(&certmod == mods[ARRAYSIZE(mods) - 2]);
    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL != pbCert? &mods[ARRAYSIZE(mods) - 2] : NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(KRA object)");

error:
    return(hr);
}


HRESULT
myLdapCreateCDPObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    BYTE ZeroByte = 0;

    LDAPMod objectClass;
    LDAPMod securityDescriptor;
    LDAPMod crlmod;
    LDAPMod drlmod;

    struct berval sdberval;
    struct berval crlberval;
    struct berval drlberval;

    WCHAR *objectClassVals[3];
    struct berval *sdVals[2];
    struct berval *crlVals[2];
    struct berval *drlVals[2];

    LDAPMod *mods[5];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &securityDescriptor;
    mods[2] = &crlmod;
    mods[3] = &drlmod;
    mods[4] = NULL;

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;
    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSCDPCLASSNAME;
    objectClassVals[2] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;
    sdberval.bv_len = 0;
    sdberval.bv_val = NULL;
    if (IsValidSecurityDescriptor(pSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pSD);
        sdberval.bv_val = (char *) pSD;
    }

    crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    crlmod.mod_type = wszDSBASECRLATTRIBUTE;
    crlmod.mod_bvalues = crlVals;
    crlVals[0] = &crlberval;
    crlVals[1] = NULL;
    crlberval.bv_val = (char *) &ZeroByte;
    crlberval.bv_len = sizeof(ZeroByte);

    drlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    drlmod.mod_type = wszDSDELTACRLATTRIBUTE;
    drlmod.mod_bvalues = drlVals;
    drlVals[0] = &drlberval;
    drlVals[1] = NULL;
    drlberval.bv_val = (char *) &ZeroByte;
    drlberval.bv_len = sizeof(ZeroByte);

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS CDP Object: '%ws'\n", pwszDN));

    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(CDP object)");

error:
    return(hr);
}


HRESULT
myLdapCreateOIDObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN DWORD dwType,
    IN WCHAR const *pwszObjId,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR awcType[22];

    LDAPMod objectClass;
    LDAPMod typemod;
    LDAPMod oidmod;

    WCHAR *objectClassVals[3];
    WCHAR *typeVals[2];
    WCHAR *oidVals[2];

    LDAPMod *mods[4];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &typemod;
    mods[2] = &oidmod;
    mods[3] = NULL;
    CSASSERT(4 == ARRAYSIZE(mods));

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;
    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSOIDCLASSNAME;
    objectClassVals[2] = NULL;
    CSASSERT(3 == ARRAYSIZE(objectClassVals));

    typemod.mod_op = LDAP_MOD_ADD;
    typemod.mod_type = OID_PROP_TYPE;
    typemod.mod_values = typeVals;
    wsprintf(awcType, L"%u", dwType);
    typeVals[0] = awcType;
    typeVals[1] = NULL;
    CSASSERT(2 == ARRAYSIZE(typeVals));

    oidmod.mod_op = LDAP_MOD_ADD;
    oidmod.mod_type = OID_PROP_OID;
    oidmod.mod_values = oidVals;
    oidVals[0] = const_cast<WCHAR *>(pwszObjId);
    oidVals[1] = NULL;
    CSASSERT(2 == ARRAYSIZE(oidVals));

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS OID Object: '%ws'\n", pwszDN));

    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(OID object)");

error:
    return(hr);
}


HRESULT
myLdapOIDIsMatchingLangId(
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwLanguageId,
    OUT BOOL *pfLangIdExists)
{
    DWORD DisplayLangId = _wtoi(pwszDisplayName);

    *pfLangIdExists = FALSE;
    if (iswdigit(*pwszDisplayName) &&
	NULL != wcschr(pwszDisplayName, L',') &&
	DisplayLangId == dwLanguageId)
    {
	*pfLangIdExists = TRUE;
    }
    return(S_OK);
}


HRESULT
myLdapAddOIDDisplayNameToAttribute(
    IN LDAP *pld,
    OPTIONAL IN WCHAR **ppwszOld,
    IN DWORD dwLanguageId,
    IN WCHAR const *pwszDisplayName,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cname;
    DWORD iname;
    DWORD i;
    WCHAR **ppwszNew = NULL;
    WCHAR *pwszNew = NULL;
    BOOL fDeleteOldName = FALSE;
    BOOL fNewNameMissing = TRUE;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    pwszNew = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (12 + 1 + wcslen(pwszDisplayName) + 1) * sizeof(WCHAR));
    if (NULL == pwszNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wsprintf(pwszNew, L"%u,%ws", dwLanguageId, pwszDisplayName);

    cname = 0;
    if (NULL != ppwszOld)
    {
	while (NULL != ppwszOld[cname])
	{
	    cname++;
	}
    }
    ppwszNew = (WCHAR **) LocalAlloc(
				LMEM_FIXED,
				(cname + 2) * sizeof(ppwszNew[0]));
    if (NULL == ppwszNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Delete any display names with matching dwLanguageId

    iname = 0;
    if (NULL != ppwszOld)
    {
	for (i = 0; NULL != ppwszOld[i]; i++)
	{
	    BOOL fCopy = TRUE;
	    WCHAR *pwsz = ppwszOld[i];

	    // case-sensitive compare:

	    if (0 == lstrcmp(pwszNew, ppwszOld[i]))
	    {
		fCopy = FALSE;	// remove duplicates to avoid ldap error
		fNewNameMissing = FALSE;
	    }
	    else
	    {
		BOOL fLangIdExists;
		
		hr = myLdapOIDIsMatchingLangId(
					pwsz,
					dwLanguageId,
					&fLangIdExists);
		_PrintIfError(hr, "myLdapOIDIsMatchingLangId");
		if (S_OK != hr || fLangIdExists)
		{
		    fCopy = FALSE;
		    fDeleteOldName = TRUE;
		    DBGPRINT((DBG_SS_CERTLIB, "Deleting %ws\n", pwsz));
		}
	    }
	    if (fCopy)
	    {
		ppwszNew[iname++] = pwsz;
	    }
	}
    }
    CSASSERT(iname <= cname);

    // set disposition assuming there's nothing to do:

    *pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;

    if (fNewNameMissing || fDeleteOldName)
    {
	LDAPMod *mods[2];
	LDAPMod namemod;

	mods[0] = &namemod;
	mods[1] = NULL;

	namemod.mod_op = LDAP_MOD_REPLACE;
	namemod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	namemod.mod_values = ppwszNew;

	ppwszNew[iname++] = pwszNew;
	ppwszNew[iname] = NULL;

	hr = ldap_modify_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszNew)
    {
	LocalFree(pwszNew);
    }
    if (NULL != ppwszNew)
    {
	LocalFree(ppwszNew);
    }
    return(hr);
}


HRESULT
myHLdapError3(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    IN ULONG ldaperrParmQuiet2,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr = S_OK;
    
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    if (LDAP_SUCCESS != ldaperrParm)
    {
	BOOL fXlat = TRUE;
	ULONG ldaperr;
	WCHAR *pwszError = NULL;

	if (NULL != pld)
	{
	    ldaperr = ldap_get_option(pld, LDAP_OPT_SERVER_ERROR, &pwszError);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		_PrintError(ldaperr, "ldap_get_option(server error)");
		pwszError = NULL;
	    }

	    ldaperr = ldap_get_option(pld, LDAP_OPT_SERVER_EXT_ERROR, &hr);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		_PrintError2(
			ldaperr,
			"ldap_get_option(server extended error)",
			ldaperr);
	    }
	    else
	    {
		fXlat = FALSE;
	    }
	}
	if (fXlat)
	{
#undef LdapMapErrorToWin32
	    hr = LdapMapErrorToWin32(ldaperrParm);
#define LdapMapErrorToWin32	Use_myHLdapError_Instead_Of_LdapMapErrorToWin32
	}
	hr = myHError(hr);
	_PrintErrorStr3(
		    ldaperrParm,
		    "ldaperr",
		    pwszError,
		    ldaperrParmQuiet,
		    ldaperrParmQuiet2);
	if (NULL != ppwszError && NULL != pwszError)
	{
	    WCHAR awc[32];
	    DWORD cwc;

	    wsprintf(awc, L"ldap: 0x%x: ", ldaperrParm);
	    cwc = wcslen(awc) + wcslen(pwszError);
	    *ppwszError = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	    if (NULL == *ppwszError)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
	    }
	    else
	    {
		wcscpy(*ppwszError, awc);
		wcscat(*ppwszError, pwszError);
	    }
	} 

    if(NULL != pwszError)
        ldap_memfree(pwszError);

    }
    return(hr);
}


HRESULT
myHLdapError2(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    OPTIONAL OUT WCHAR **ppwszError)
{
    return(myHLdapError3(
		    pld,
		    ldaperrParm,
		    ldaperrParmQuiet,
		    LDAP_SUCCESS,
		    ppwszError));
}


HRESULT
myHLdapError(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    OPTIONAL OUT WCHAR **ppwszError)
{
    return(myHLdapError3(
		    pld,
		    ldaperrParm,
		    LDAP_SUCCESS,
		    LDAP_SUCCESS,
		    ppwszError));
}


HRESULT
myHLdapLastError(
    OPTIONAL IN LDAP *pld,
    OPTIONAL OUT WCHAR **ppwszError)
{
    return(myHLdapError3(
		    pld,
		    LdapGetLastError(),
		    LDAP_SUCCESS,
		    LDAP_SUCCESS,
		    ppwszError));
}

HRESULT myLDAPSetStringAttribute(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    IN WCHAR const *pwszValue,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr = S_OK;
	LDAPMod *mods[2];
	LDAPMod certmod;
    const WCHAR *ppwszVals[2];
    CAutoLPWSTR pwszDNOnly;
    WCHAR *pwszSuffix; // no free

    hr = TrimURLDN(pwszDN, &pwszSuffix, &pwszDNOnly);
    _JumpIfErrorStr(hr, error, "TrimURLDN", pwszDN);

	mods[0] = &certmod;
	mods[1] = NULL;

    ppwszVals[0] = pwszValue;
    ppwszVals[1] = NULL;

	certmod.mod_op = LDAP_MOD_REPLACE;
	certmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	certmod.mod_values = const_cast<PWCHAR *>(ppwszVals);

	hr = ldap_modify_ext_s(
			pld,
			pwszDNOnly,
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    hr = S_OK;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\log.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       log.cpp
//
//  Contents:   cert server logging
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "initcert.h"
#include "certmsg.h"
#include "clibres.h"

#define __dwFILE__	__dwFILE_CERTLIB_LOG_CPP__

FILE *g_pfLog = NULL;
BOOL g_fInitLogCritSecEnabled = FALSE;
extern FNLOGMESSAGEBOX *g_pfnLogMessagBox = NULL;

CRITICAL_SECTION g_InitLogCriticalSection;


VOID
fputsStripCRA(
    IN char const *psz,
    IN FILE *pf)
{
    while ('\0' != *psz)
    {
	DWORD i;

	i = strcspn(psz, "\r");
	if (0 != i)
	{
	    fprintf(pf, "%.*hs", i, psz);
	    psz += i;
	}
	if ('\r' == *psz)
	{
	    psz++;
	}
    }
}


VOID
fputsStripCRW(
    IN WCHAR const *pwsz,
    IN FILE *pf)
{
    while (L'\0' != *pwsz)
    {
	DWORD i;

	i = wcscspn(pwsz, L"\r");
	if (0 != i)
	{
	    fprintf(pf, "%.*ws", i, pwsz);
	    pwsz += i;
	}
	if ('\r' == *pwsz)
	{
	    pwsz++;
	}
    }
}


VOID
csiLog(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN HRESULT hrMsg,
    IN UINT idMsg,
    OPTIONAL IN WCHAR const *pwsz1,
    OPTIONAL IN WCHAR const *pwsz2,
    OPTIONAL IN DWORD const *pdw)
{
    HRESULT hr;
    WCHAR const *pwszMsg = NULL; // don't free
    WCHAR const *pwszMessageText = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    BOOL fCritSecEntered = FALSE;
    
    if (0 != idMsg)
    {
	pwszMsg = myLoadResourceString(idMsg);
	if (NULL == pwszMsg)
	{
	    hr = myHLastError();
	    _PrintError(hr, "myLoadResourceString");
	}
    }
    if (NULL == pwszMsg)
    {
	pwszMsg = L"";
    }
    if (g_fInitLogCritSecEnabled)
    {
	EnterCriticalSection(&g_InitLogCriticalSection);
	fCritSecEntered = TRUE;
    }
    if (NULL != g_pfLog)
    {
	fprintf(g_pfLog, "%u.%u.%u: ", dwFile, dwLine, idMsg);
	fputsStripCRW(pwszMsg, g_pfLog);
	if (NULL != pwsz1)
	{
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwsz1, g_pfLog);
	}
	if (NULL != pwsz2)
	{
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwsz2, g_pfLog);
	}
	if (NULL != pdw)
	{
	    fprintf(g_pfLog, ": 0x%x(%d)", *pdw, *pdw);
	}
	if (hrMsg != S_OK)
	{
	    pwszMessageText = myGetErrorMessageText(hrMsg, TRUE);
	    if (NULL == pwszMessageText)
	    {
		pwszMessageText = myHResultToStringRaw(awchr, hrMsg);
	    }
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwszMessageText, g_pfLog);
	}
	fprintf(g_pfLog, "\n");
	fflush(g_pfLog);
    }

//error:
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


VOID
csiLogTime(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg)
{
    HRESULT hr;
    WCHAR *pwszDate = NULL;
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_PrintError(hr, "SystemTimeToFileTime");
    }
    else
    {
	hr = myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszDate);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    }

    csiLog(dwFile, dwLine, S_OK, idMsg, pwszDate, NULL, NULL);

//error:
    if (NULL != pwszDate)
    {
	LocalFree(pwszDate);
    }
}


VOID
csiLogDWord(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg,
    IN DWORD dwVal)
{
    csiLog(dwFile, dwLine, S_OK, idMsg, NULL, NULL, &dwVal);
}


FNLOGSTRING csiLogString;

VOID
csiLogString(
    IN char const *psz)
{
    BOOL fCritSecEntered = FALSE;

    if (NULL != g_pfLog)
    {
	if (g_fInitLogCritSecEnabled)
	{
	    EnterCriticalSection(&g_InitLogCriticalSection);
	    fCritSecEntered = TRUE;
	}
	fputsStripCRA(psz, g_pfLog);
	fflush(g_pfLog);
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
}


FNLOGMESSAGEBOX csiLogMessagBox;

VOID
csiLogMessagBox(
    IN HRESULT hrMsg,
    IN UINT idMsg,
    IN WCHAR const *pwszTitle,
    IN WCHAR const *pwszMessage)
{
    // Use file number 0 and the passed idMsg as the line number.
    
    csiLog(0, idMsg, hrMsg, IDS_ILOG_MESSAGEBOX, pwszTitle, pwszMessage, NULL);
}


VOID
csiLogClose()
{
    BOOL fCritSecEntered = FALSE;
    BOOL fDelete;
    
    if (NULL != g_pfLog)
    {
	CSILOGTIME(IDS_ILOG_END);
    }
    if (g_fInitLogCritSecEnabled)
    {
	EnterCriticalSection(&g_InitLogCriticalSection);
	fCritSecEntered = TRUE;
    }
    if (NULL != g_pfLog)
    {
	fclose(g_pfLog);
	g_pfLog = NULL;
    }
    fDelete = FALSE;
    if (fCritSecEntered)
    {
	if (g_fInitLogCritSecEnabled)
	{
	    g_fInitLogCritSecEnabled = FALSE;
	    fDelete = TRUE;
	}
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
    if (fDelete)
    {
	DeleteCriticalSection(&g_InitLogCriticalSection);
    }
}


char const szHeader[] = "\n========================================================================\n";

VOID
csiLogOpen(
    IN char const *pszFile)
{
    HRESULT hr;
    UINT cch;
    char aszLogFile[MAX_PATH];
    BOOL fAppend = FALSE;
    BOOL fOk = FALSE;
    BOOL fCritSecEntered = FALSE;

    __try
    {
	if (!g_fInitLogCritSecEnabled)
	{
	    InitializeCriticalSection(&g_InitLogCriticalSection);
	    g_fInitLogCritSecEnabled = TRUE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (g_fInitLogCritSecEnabled)
    {
	EnterCriticalSection(&g_InitLogCriticalSection);
	fCritSecEntered = TRUE;
    }
    if ('+' == *pszFile)
    {
	pszFile++;
	fAppend = TRUE;
    }
    cch = GetWindowsDirectoryA(aszLogFile, ARRAYSIZE(aszLogFile));
    if (0 != cch)
    {
	if (L'\\' != aszLogFile[cch - 1])
	{
	    strcat(aszLogFile, "\\");
	}
	strcat(aszLogFile, pszFile);

	while (TRUE)
	{
	    g_pfLog = fopen(aszLogFile, fAppend? "at" : "wt");
	    if (NULL == g_pfLog)
	    {
		_PrintError(E_FAIL, "fopen(Log)");
	    }
	    else
	    {
		if (fAppend)
		{
		    if (0 == fseek(g_pfLog, 0L, SEEK_END) &&
			CBLOGMAXAPPEND <= ftell(g_pfLog))
		    {
			fclose(g_pfLog);
			g_pfLog = NULL;
			fAppend = FALSE;
			continue;
		    }
		    fprintf(g_pfLog, szHeader);
		}
		fOk = TRUE;
	    }
	    break;
	}
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
    if (fOk)
    {
	CSILOGTIME(IDS_ILOG_BEGIN);
	DBGLOGSTRINGINIT(csiLogString);
	CSASSERT(NULL == g_pfnLogMessagBox);
	g_pfnLogMessagBox = csiLogMessagBox;
    }

//error:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certlib"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif

#include <windows.h>
#include <wincrypt.h>
#include <setupapi.h>
#include <certsrv.h>
#include <aclapi.h>
#include "ocmanage.h"
#include "certlib.h"	            // debug allocator
#define SECURITY_WIN32
#include <security.h>
#define CERTLIB_BUILD

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\poldisp.cpp ===
#include <pch.cpp>
#pragma hdrstop
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__      __dwFILE_CERTLIB_POLDISP_CPP__

//+------------------------------------------------------------------------
// ICertPolicy dispatch support


//+------------------------------------
// VerifyRequest method:

OLECHAR *_apszVerifyRequest[] = {
    TEXT("VerifyRequest"),
    TEXT("strConfig"),
    TEXT("Context"),
    TEXT("bNewRequest"),
    TEXT("Flags")
};


//+------------------------------------
// GetDescription method:

OLECHAR *_apszGetDescription[] = {
    TEXT("GetDescription"),
};


//+------------------------------------
// Initialize method:

OLECHAR *_apszInitialize[] = {
    TEXT("Initialize"),
    TEXT("strConfig"),
};


//+------------------------------------
// ShutDown method:

OLECHAR *_apszShutDown[] = {
    TEXT("ShutDown"),
};


//+------------------------------------
// GetManageModule method:

OLECHAR *_apszGetManageModule[] = {
    TEXT("GetManageModule"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtPolicy[] =
{
    DECLARE_DISPATCH_ENTRY(_apszVerifyRequest)
    DECLARE_DISPATCH_ENTRY(_apszGetDescription)
    DECLARE_DISPATCH_ENTRY(_apszInitialize)
    DECLARE_DISPATCH_ENTRY(_apszShutDown)
    DECLARE_DISPATCH_ENTRY(_apszGetManageModule)
};


DWORD CPOLICYDISPATCH = (ARRAYSIZE(g_adtPolicy));

DWORD s_acPolicyDispatch[2] = {
    CPOLICYDISPATCH_V2,
    CPOLICYDISPATCH_V1,
};

IID const *s_apPolicyiid[2] = {
    &IID_ICertPolicy2,
    &IID_ICertPolicy,
};


HRESULT
PolicyVerifyVersion(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiPolicy && NULL != pdiPolicy->pDispatchTable);

    switch (pdiPolicy->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiPolicy->pDispatch ||
		CPOLICYDISPATCH_V1 == pdiPolicy->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiPolicy->pDispatch ||
		CPOLICYDISPATCH_V2 == pdiPolicy->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiPolicy->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Policy_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdi)
{
    HRESULT hr;

    hr = DispatchSetup2(
                Flags,
                CLSCTX_INPROC_SERVER,
                pcwszProgID, // g_wszRegKeyCIPolicyClsid,
                pclsid,
                ARRAYSIZE(s_acPolicyDispatch),
                s_apPolicyiid,
                s_acPolicyDispatch,
                g_adtPolicy,
                pdi);
    _JumpIfError(hr, error, "DispatchSetup");

    pdi->pDispatchTable = g_adtPolicy;

error:
    return(hr);
}


VOID
Policy_Release(
    IN OUT DISPATCHINTERFACE *pdiManage)
{
    DispatchRelease(pdiManage);
}


HRESULT
Policy_Initialize(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    __try
    {
	if (NULL != pdiPolicy->pDispatch)
	{
	    VARIANT avar[1];

	    CSASSERT(NULL != pdiPolicy->pDispatchTable);
	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;

	    hr = DispatchInvoke(
			    pdiPolicy,
			    POLICY_INITIALIZE,
			    ARRAYSIZE(avar),
			    avar,
			    0,
			    NULL);
	    _LeaveIfError(hr, "Invoke(Initialize)");
	}
	else
	{
	    hr = ((ICertPolicy *) pdiPolicy->pUnknown)->Initialize(strConfig);
	    _LeaveIfError(hr, "ICertPolicy::Initialize");
	}
    }
    _finally
    {
	if (NULL != strConfig)
	{
	    SysFreeString(strConfig);
	}
    }

error:
    return(hr);
}


HRESULT
Policy_ShutDown(
    IN DISPATCHINTERFACE *pdiPolicy)
{
    HRESULT hr;

    if (NULL != pdiPolicy->pDispatch)
    {
	CSASSERT(NULL != pdiPolicy->pDispatchTable);

	hr = DispatchInvoke(
			pdiPolicy,
			POLICY_SHUTDOWN,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(ShutDown)");
    }
    else
    {
	hr = ((ICertPolicy *) pdiPolicy->pUnknown)->ShutDown();
	_JumpIfError(hr, error, "ICertPolicy::ShutDown");
    }

error:
    return(hr);
}


HRESULT
Policy_VerifyRequest(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig,
    IN LONG Context,
    IN LONG bNewRequest,
    IN LONG Flags,
    OUT LONG *pResult)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    __try
    {
	if (NULL != pdiPolicy->pDispatch)
	{
	    VARIANT avar[4];

	    CSASSERT(NULL != pdiPolicy->pDispatchTable);
	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
	    avar[1].vt = VT_I4;
	    avar[1].lVal = Context;
	    avar[2].vt = VT_I4;
	    avar[2].lVal = bNewRequest;
	    avar[3].vt = VT_I4;
	    avar[3].lVal = Flags;

	    hr = DispatchInvoke(
			    pdiPolicy,
			    POLICY_VERIFYREQUEST,
			    ARRAYSIZE(avar),
			    avar,
			    VT_I4,
			    pResult);
	    _PrintIfError(hr, "Invoke(VerifyRequest)");

	    // Emulate the way C++ Policy Modules overload *pRequest with
	    // a FAILED HRESULT:

	    if (FAILED(hr))
	    {
		*pResult = hr;
		hr = S_OK;
	    }
	    _LeaveIfError(hr, "Invoke(VerifyRequest)");
	}
	else
	{
	    hr = ((ICertPolicy *) pdiPolicy->pUnknown)->VerifyRequest(
							    strConfig,
							    Context,
							    bNewRequest,
							    Flags,
							    pResult);
	    _LeaveIfError(hr, "ICertPolicy::VerifyRequest");
	}
    }
    _finally
    {
	if (NULL != strConfig)
	{
	    SysFreeString(strConfig);
	}
    }

error:
    return(hr);
}


HRESULT
Policy_GetDescription(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT BSTR *pstrDescription)
{
    HRESULT hr;

    if (NULL != pdiPolicy->pDispatch)
    {
	CSASSERT(NULL != pdiPolicy->pDispatchTable);

	hr = DispatchInvoke(
			pdiPolicy,
			POLICY_GETDESCRIPTION,
			0,
			NULL,
			VT_BSTR,
			pstrDescription);
	_JumpIfError(hr, error, "Invoke(GetDescription)");
    }
    else
    {
	hr = ((ICertPolicy *) pdiPolicy->pUnknown)->GetDescription(
							pstrDescription);
	_JumpIfError(hr, error, "ICertPolicy::GetDescription");
    }

error:
    return(hr);
}


HRESULT
Policy2_GetManageModule(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT DISPATCHINTERFACE *pdiManageModule)
{
    HRESULT hr;
    ICertManageModule *pManageModule = NULL;

    hr = PolicyVerifyVersion(pdiPolicy, 2);
    _JumpIfError(hr, error, "PolicyVerifyVersion");

    if (NULL != pdiPolicy->pDispatch)
    {
	CSASSERT(NULL != pdiPolicy->pDispatchTable);

	hr = DispatchInvoke(
			pdiPolicy,
			POLICY2_GETMANAGEMODULE,
			0,
			NULL,
			VT_DISPATCH,
			&pManageModule);
	_JumpIfError(hr, error, "Invoke(GetManageModule)");
    }
    else
    {
	hr = ((ICertPolicy2 *) pdiPolicy->pUnknown)->GetManageModule(
							&pManageModule);
	_JumpIfError(hr, error, "ICertPolicy::GetManageModule");
    }

    hr = ManageModule_Init2(
		NULL != pdiPolicy->pDispatch,
		pManageModule,
		pdiManageModule);
    _JumpIfError(hr, error, "ManageModule_Init2");

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\prop2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       prop2.cpp
//
//  Contents:   ICertAdmin2 & ICertRequest2 IDispatch helper functions
//
//--------------------------------------------------------------------------

#if defined(CCERTADMIN)

# define CAPropWrapper(IFAdmin, IFRequest, Method) IFAdmin##_##Method
# define ICertProp2		ICertAdmin2
# define szICertProp2		"ICertAdmin2"

#elif defined(CCERTREQUEST)

# define CAPropWrapper(IFAdmin, IFRequest, Method) IFRequest##_##Method
# define ICertProp2		ICertRequest2
# define szICertProp2		"ICertRequest2"

#else
# error -- CCERTADMIN or CCERTREQUEST must be defined
#endif

#define szInvokeICertProp2(szMethod)	"Invoke(" szICertProp2 "::" szMethod ")"


HRESULT
CAPropWrapper(Admin2, Request2, GetCAProperty)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,		// CR_OUT_*
    OUT VOID *pPropertyValue)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiProp && NULL != pdiProp->pDispatchTable);

    switch (PropType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropType");
    }

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiProp->pDispatch)
    {
	VARIANT avar[5];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropId;

	avar[2].vt = VT_I4;
	avar[2].lVal = PropIndex;

	avar[3].vt = VT_I4;
	avar[3].lVal = PropType;

	avar[4].vt = VT_I4;
	avar[4].lVal = Flags;

	hr = DispatchInvoke(
			pdiProp,
			CAPropWrapper(ADMIN2, REQUEST2, GETCAPROPERTY),
			ARRAYSIZE(avar),
			avar,
			RetType,
			pPropertyValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"%hs: Config=%ws PropId=%x Index=%x Type=%x Flags=%x\n",
		szInvokeICertProp2("GetCAProperty"),
		pwszConfig,
		PropId,
		PropIndex,
		PropType,
		Flags));
	}
	_JumpIfError(hr, error, szInvokeICertProp2("GetCAProperty"));
    }
    else
    {
	hr = ((ICertProp2 *) pdiProp->pUnknown)->GetCAProperty(
						    strConfig,
						    PropId,
						    PropIndex,
						    PropType,
						    Flags,
						    &varResult);
	_JumpIfError3(
		    hr,
		    error,
		    szICertProp2 "::GetCAProperty",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		    E_INVALIDARG);

	hr = DispatchGetReturnValue(&varResult, RetType, pPropertyValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    VariantClear(&varResult);
    return(hr);
}


HRESULT
CAPropWrapper(Admin2, Request2, GetCAPropertyFlags)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiProp && NULL != pdiProp->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiProp->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropId;

	hr = DispatchInvoke(
			pdiProp,
			CAPropWrapper(ADMIN2, REQUEST2, GETCAPROPERTYFLAGS),
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pPropFlags);
	_JumpIfError(hr, error, szInvokeICertProp2("GetCAPropertyFlags"));
    }
    else
    {
	hr = ((ICertProp2 *) pdiProp->pUnknown)->GetCAPropertyFlags(
						    strConfig,
						    PropId,
						    pPropFlags);
	_JumpIfError(hr, error, szICertProp2 "::GetCAPropertyFlags");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
CAPropWrapper(Admin2, Request2, GetCAPropertyDisplayName)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiProp && NULL != pdiProp->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiProp->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropId;

	hr = DispatchInvoke(
		    pdiProp,
		    CAPropWrapper(ADMIN2, REQUEST2, GETCAPROPERTYDISPLAYNAME),
		    ARRAYSIZE(avar),
		    avar,
		    VT_BSTR,
		    pstrDisplayName);
	_JumpIfError(hr, error, szInvokeICertProp2("GetCAPropertyDisplayName"));
    }
    else
    {
	hr = ((ICertProp2 *) pdiProp->pUnknown)->GetCAPropertyDisplayName(
						    strConfig,
						    PropId,
						    pstrDisplayName);
	_JumpIfError(hr, error, szICertProp2 "::GetCAPropertyDisplayName");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\progress.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       progress.cpp
//
//--------------------------------------------------------------------------

// progress.cpp : implementation file
//

#include <pch.cpp>

#pragma hdrstop

#include "clibres.h"
#include "progress.h"

// defines

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum MYDIALOGBEHAVIORENUM
{
    enumPERCENTCOMPLETEBEHAVIOR = 0,
    enumPROGRESSBARWITHTIMEOUT,
};

typedef struct _PROGRESSPROC_LPARAM
{
    HINSTANCE           hInstance;
    HWND                hwndParent;
    UINT                iRscJobDescription;
    MYDIALOGBEHAVIORENUM enumWhichBehavior;
    DWORD               dwTickerUpperRange;
    DBBACKUPPROGRESS*   pdbp;
} PROGRESSPROC_LPARAM, *PPROGRESSPROC_LPARAM;


static BOOL s_fDisableProgressDialogs = 0;
static BOOL s_fIKnow = 0;

BOOL FICanShowDialogs()
{
   if (s_fIKnow != TRUE)
   {
      s_fIKnow = TRUE;
      DWORD dwVal;

      if (S_OK == myGetCertRegDWValue(
         NULL,
         NULL,
         NULL,
         L"DisableProgress",
         &dwVal))
      {
         s_fDisableProgressDialogs = (dwVal != 0);
      }
   }
   return ! s_fDisableProgressDialogs;
}



////////////////////////////////////////////////////////////////////////////////
// show a progress dialog

int     g_iTimeoutTicks = 0;
BOOL    g_fUseTimer;

INT_PTR CALLBACK dlgProcProgress(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  )
{
    PPROGRESSPROC_LPARAM pLParam = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            HWND hwndProgressBar;
            
            pLParam = (PPROGRESSPROC_LPARAM)lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (ULONG_PTR)pLParam);

            hwndProgressBar = GetDlgItem(hwndDlg, IDD_PROGRESS_BAR);
			
            {
                RECT rcParent, rcDlg, rcScreenArea;
                GetWindowRect(pLParam->hwndParent, &rcParent);
            	GetWindowRect(hwndDlg, &rcDlg);
                SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcScreenArea, NULL);

                // calc centers
                int xLeft = (rcParent.left + rcParent.right) / 2 - (rcDlg.right - rcDlg.left) / 2;
                int yTop = (rcParent.top + rcParent.bottom) / 2 - (rcDlg.bottom - rcDlg.top) / 2;

                // careful: if the dialog is outside the screen, move it inside
                if (xLeft < rcScreenArea.left)
	                xLeft = rcScreenArea.left;
                else if (xLeft + (rcDlg.right - rcDlg.left) > rcScreenArea.right)
	                xLeft = rcScreenArea.right - (rcDlg.right - rcDlg.left);

                if (yTop < rcScreenArea.top)
	                yTop = rcScreenArea.top;
                else if (yTop + (rcDlg.bottom - rcDlg.top) > rcScreenArea.bottom)
	                yTop = rcScreenArea.bottom - (rcDlg.bottom - rcDlg.top);

                // map screen coordinates to child coordinates
                SetWindowPos(hwndDlg, HWND_TOPMOST, xLeft, yTop, -1, -1,
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            }
    
            {
                DWORD dwStyle;
                dwStyle = GetWindowLong(hwndProgressBar, GWL_STYLE);
                SetWindowLong(hwndProgressBar, GWL_STYLE, (dwStyle | PBS_SMOOTH)); 
            }

            // Set the range and increment of the progress bar. 
            if (pLParam->enumWhichBehavior == enumPROGRESSBARWITHTIMEOUT)
            {
                SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, pLParam->dwTickerUpperRange));
                SendMessage(hwndProgressBar, PBM_SETSTEP, (WPARAM) 1, 0); 
            }
            else
            {
                SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 300));
            }
            SendMessage(hwndProgressBar, PBM_SETPOS, (WPARAM)0, 0);
            
            // set job description if specified
            if (pLParam->iRscJobDescription != 0)
            {
                WCHAR szJobDesc[MAX_PATH];
                if (0 != LoadString(
                             pLParam->hInstance,
                             pLParam->iRscJobDescription,
                             szJobDesc,
                             MAX_PATH))
                    SetDlgItemText(hwndDlg, IDC_JOB_DESCRIPTION, szJobDesc);
            }

            return 1;
        }
    case WM_DESTROY:
        {
            pLParam = (PPROGRESSPROC_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
            if (NULL == pLParam)
                break;

            SetForegroundWindow(pLParam->hwndParent);

            LocalFree(pLParam);
            pLParam = NULL;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, NULL);
        }
    case PBM_STEPIT:
        {
            pLParam = (PPROGRESSPROC_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
            if (NULL == pLParam)
                break;

            HWND hwndProgressBar = GetDlgItem(hwndDlg, IDD_PROGRESS_BAR);

            if (pLParam->enumWhichBehavior == enumPROGRESSBARWITHTIMEOUT)
                SendMessage(hwndProgressBar, PBM_STEPIT, 0, 0);
            else
            {
                DWORD wProgress = pLParam->pdbp->dwDBPercentComplete + 
                                pLParam->pdbp->dwLogPercentComplete + 
                                pLParam->pdbp->dwTruncateLogPercentComplete ;
                
                DWORD wTop = (DWORD)SendMessage(hwndProgressBar,
		                                PBM_GETRANGE,
						FALSE,
						NULL);
                if (wProgress == wTop)
                {
		    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, S_FALSE);     // we're done!
                    return TRUE;
                }
                else
                    SendMessage(hwndProgressBar, PBM_SETPOS, wProgress, 0); // keep incrementing
            }


            break;
        }
    case PBM_SETPOS:
        {
            HWND hwndProgressBar = GetDlgItem(hwndDlg, IDD_PROGRESS_BAR);
            LRESULT wTop = SendMessage(hwndProgressBar, PBM_GETRANGE, FALSE, NULL);
            
            // if we're not yet at the top make it so
            if (wTop != SendMessage(hwndProgressBar, PBM_GETPOS, 0, 0))
            {
                SendMessage(hwndProgressBar, PBM_SETPOS, (WPARAM)wTop, 0);
                Sleep(400);
            }
        }
    default:
        break;
    }
    return 0;
}

#define PROGRESS_TICKS_PER_SEC 3

DWORD WINAPI StartTimerThread(  LPVOID lpParameter )
{
    if (FICanShowDialogs())
    { 
    PPROGRESSPROC_LPARAM  psParam = (PPROGRESSPROC_LPARAM)lpParameter;

    HWND hwndProgressDlg = CreateDialogParam(  
        psParam->hInstance,
        MAKEINTRESOURCE(IDD_PROGRESS_BOX),
        NULL,
        dlgProcProgress, 
        (LPARAM)lpParameter);
    if (NULL == hwndProgressDlg)
       return 0;

    ShowWindow(hwndProgressDlg, SW_SHOW);
    UpdateWindow(hwndProgressDlg);

    // if not timer based, go forever
    // if timer based, go while timersec is +
    while ((!g_fUseTimer) ||
           (g_iTimeoutTicks-- > 0))
    {
        SendMessage(hwndProgressDlg, PBM_STEPIT, 0, 0);
        UpdateWindow(hwndProgressDlg);
        Sleep(1000/PROGRESS_TICKS_PER_SEC);
    }

    // send "fill the indicator" 
    SendMessage(hwndProgressDlg, PBM_SETPOS, 0, 0);
    
    DestroyWindow(hwndProgressDlg);
    }
    return 0;
}

// callable APIs: Start/End ProgressDlg
BOOL FProgressDlgRunning()
{
    return (!g_fUseTimer || (g_iTimeoutTicks > 0));
}

HANDLE
StartProgressDlg(
    HINSTANCE hInstance,
    HWND      hwndParent,
    DWORD     dwTickerSeconds,
    DWORD     dwTimeoutSeconds,
    UINT      iRscJobDescription)
{
    HANDLE hProgressThread = NULL;
    DWORD dwThread;
    PPROGRESSPROC_LPARAM psParam = NULL;
    
    INITCOMMONCONTROLSEX sCommCtrl;
    sCommCtrl.dwSize = sizeof(sCommCtrl);
    sCommCtrl.dwICC = ICC_PROGRESS_CLASS;
    if (!InitCommonControlsEx(&sCommCtrl))
        goto Ret;

    g_fUseTimer = dwTimeoutSeconds != 0;
    g_iTimeoutTicks = (dwTimeoutSeconds * PROGRESS_TICKS_PER_SEC);
    
    // dialog frees this
    psParam = (PPROGRESSPROC_LPARAM)LocalAlloc(LMEM_FIXED, sizeof(PROGRESSPROC_LPARAM));
    if (psParam == NULL)
        goto Ret;

    psParam->hInstance = hInstance;
    psParam->hwndParent = hwndParent;
    psParam->enumWhichBehavior = enumPROGRESSBARWITHTIMEOUT;
    psParam->dwTickerUpperRange = dwTickerSeconds * PROGRESS_TICKS_PER_SEC;
    psParam->iRscJobDescription = iRscJobDescription;
    psParam->pdbp = NULL;


    hProgressThread = 
        CreateThread(
            NULL,
            0,
            StartTimerThread,
            (void*)psParam,
            0,
            &dwThread);
Ret:
    if (NULL == hProgressThread)
        LocalFree(psParam);

    return hProgressThread;
}

void EndProgressDlg(HANDLE hProgressThread)
{
    // end countdown immediately
    g_iTimeoutTicks = 0;
    if (!g_fUseTimer)
    {
        // make the controlling thread suddenly aware of the timer
        g_fUseTimer = TRUE;
    }

    // don't return until we're certain the progress dlg is gone
    while(TRUE)
    {
        DWORD dwExitCode;
        // break on error
        if (!GetExitCodeThread(hProgressThread, &dwExitCode) )
            break;

        // continue until goes away
        if (STILL_ACTIVE != dwExitCode)
            break;

        Sleep(100);
    }

    CloseHandle(hProgressThread);
}

///////////////////////////////////////////////////////
// %age complete progress indicator

DWORD WINAPI StartPercentCompleteThread(  LPVOID lpParameter )
{
    if (FICanShowDialogs())
    {
    PPROGRESSPROC_LPARAM  psParam = (PPROGRESSPROC_LPARAM)lpParameter;

    HWND hwndProgressDlg = CreateDialogParam(  
        psParam->hInstance,
        MAKEINTRESOURCE(IDD_PROGRESS_BOX),
        NULL,
        dlgProcProgress, 
        (LPARAM)lpParameter);

if (NULL == hwndProgressDlg) {GetLastError(); return 0;}

    ShowWindow(hwndProgressDlg, SW_SHOW);
    Sleep(0);

    while (TRUE)
    {
        if (ERROR_SUCCESS != SendMessage(hwndProgressDlg, PBM_STEPIT, 0, 0))
            break;

        UpdateWindow(hwndProgressDlg);
        Sleep(0);
        Sleep(1000/PROGRESS_TICKS_PER_SEC);
    }

    // send "fill the indicator" 
    SendMessage(hwndProgressDlg, PBM_SETPOS, 0, 0);
    
    DestroyWindow(hwndProgressDlg);
    }

    return 0;
}

HANDLE
StartPercentCompleteDlg(
    HINSTANCE  hInstance,
    HWND       hwndParent,
    UINT       iRscJobDescription,
    DBBACKUPPROGRESS *pdbp)
{
    HANDLE hProgressThread = NULL;
    DWORD dwThread;
    PPROGRESSPROC_LPARAM psParam = NULL;

    g_fUseTimer = FALSE;
    g_iTimeoutTicks = 0;    // no timeout

    INITCOMMONCONTROLSEX sCommCtrl;
    sCommCtrl.dwSize = sizeof(sCommCtrl);
    sCommCtrl.dwICC = ICC_PROGRESS_CLASS;
    if (!InitCommonControlsEx(&sCommCtrl))
        goto Ret;

    // dialog frees this
    psParam = (PPROGRESSPROC_LPARAM)LocalAlloc(LMEM_FIXED, sizeof(PROGRESSPROC_LPARAM));
    if (psParam == NULL)
        goto Ret;

    psParam->hInstance = hInstance;
    psParam->hwndParent = hwndParent;
    psParam->enumWhichBehavior = enumPERCENTCOMPLETEBEHAVIOR;
    psParam->dwTickerUpperRange = 300;
    psParam->iRscJobDescription = iRscJobDescription;
    psParam->pdbp = pdbp;
    
    hProgressThread = 
        CreateThread(
            NULL,
            0,
            StartPercentCompleteThread,
            (void*)psParam,
            0,
            &dwThread);
Ret:
    if (NULL == hProgressThread)
        LocalFree(psParam);

    return hProgressThread;
}

void EndPercentCompleteDlg(HANDLE hProgressThread)
{
    // don't return until we're certain the progress dlg is gone
    while(TRUE)
    {
        DWORD dwExitCode;
        // break on error
        if (!GetExitCodeThread(hProgressThread, &dwExitCode) )
            break;

        // continue until goes away
        if (STILL_ACTIVE != dwExitCode)
            break;

        Sleep(100);
    }

    CloseHandle(hProgressThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\prvlg.h ===
//+--------------------------------------------------------------------------
// File:        prvlg.h
// Contents:    privilege manager declaration
//---------------------------------------------------------------------------
#include <ntsecapi.h>
namespace CertSrv
{

// define event

class CPrivilegeManager
{
public:

    CPrivilegeManager() : 
        m_lsah(NULL),
        m_pAddPrivilegeBackup(NULL),
        m_pAddPrivilegeAudit(NULL),
        m_pRemovePrivilegeBackup(NULL),
        m_pRemovePrivilegeAudit(NULL) {};
    
    ~CPrivilegeManager()
    {
        if(m_pAddPrivilegeBackup)
            LocalFree(m_pAddPrivilegeBackup);
        if(m_pAddPrivilegeAudit)
            LocalFree(m_pAddPrivilegeAudit);
        if(m_pRemovePrivilegeBackup)
            LocalFree(m_pRemovePrivilegeBackup);
        if(m_pRemovePrivilegeAudit)
            LocalFree(m_pRemovePrivilegeAudit);
    }

    HRESULT ComputePrivilegeChanges(
                const PSECURITY_DESCRIPTOR pOldSD,
                const PSECURITY_DESCRIPTOR pNewSD);
    HRESULT UpdatePrivileges();

protected:

    HRESULT OpenPolicy();
    HRESULT ClosePolicy();
    HRESULT AddPrivilege(const PSID pSid, DWORD dwRole);
    HRESULT RemovePrivilege(const PSID pSid, DWORD dwRole);
    void GetPrivilegeString(
        DWORD dwRole,
        PLSA_UNICODE_STRING &plsastr,
        ULONG &cstr);
    HRESULT InitBuffer(PACCESS_ALLOWED_ACE **buffer, DWORD cAce);

    LSA_HANDLE m_lsah;
    PACCESS_ALLOWED_ACE *m_pAddPrivilegeBackup;
    PACCESS_ALLOWED_ACE *m_pAddPrivilegeAudit;
    PACCESS_ALLOWED_ACE *m_pRemovePrivilegeBackup;
    PACCESS_ALLOWED_ACE *m_pRemovePrivilegeAudit;

    DWORD m_cOldAce, m_cNewAce;

    static LSA_UNICODE_STRING  m_lsaSecurityPrivilege[];
    static LSA_UNICODE_STRING  m_lsaBackupRestorePrivilege[];

}; // class CPrivilegeManager
} // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\officer.cpp ===
//+--------------------------------------------------------------------------
// File:        officer.cpp
// Contents:    officer rights implementation
//---------------------------------------------------------------------------
#include <pch.cpp>
#include <certsd.h>
#include <certacl.h>
#include <sid.h>

using namespace CertSrv;

HRESULT
COfficerRightsSD::Merge(
        PSECURITY_DESCRIPTOR pOfficerSD,
        PSECURITY_DESCRIPTOR pCASD)
{

    HRESULT hr;
    PACL pCAAcl; // no free
    PACL pOfficerAcl; // no free
    PACL pNewOfficerAcl = NULL;
    ACL_SIZE_INFORMATION CAAclInfo, OfficerAclInfo;
    PBOOL pCAFound = NULL, pOfficerFound = NULL;
    DWORD cCAAce, cOfficerAce;
    PACCESS_ALLOWED_ACE pCAAce;
    PACCESS_ALLOWED_CALLBACK_ACE pOfficerAce;
    PACCESS_ALLOWED_CALLBACK_ACE pNewAce = NULL;
    DWORD dwNewAclSize = sizeof(ACL);
    PSID pSidEveryone = NULL, pSidBuiltinAdministrators = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_WORLD_SID_AUTHORITY;
    DWORD dwSidEveryoneSize, dwAceSize, dwSidSize;
    PSID_LIST pSidList;
    PSECURITY_DESCRIPTOR pNewOfficerSD = NULL;
    ACL EmptyAcl;
    SECURITY_DESCRIPTOR EmptySD;

    CSASSERT(NULL==pOfficerSD || IsValidSecurityDescriptor(pOfficerSD));
    CSASSERT(IsValidSecurityDescriptor(pCASD));

    // allow NULL officer SD, in that case build an empty SD and use it
    if(NULL==pOfficerSD)
    {
        if(!InitializeAcl(&EmptyAcl, sizeof(ACL), ACL_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeAcl");
        }
   
        if (!InitializeSecurityDescriptor(&EmptySD, SECURITY_DESCRIPTOR_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeSecurityDescriptor");
        }

        if(!SetSecurityDescriptorDacl(
            &EmptySD,
            TRUE, // DACL present
            &EmptyAcl,
            FALSE)) // DACL defaulted
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetSecurityDescriptorControl");
        }

        pOfficerSD = &EmptySD;
    }

    hr = myGetSecurityDescriptorDacl(pCASD, &pCAAcl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    hr = myGetSecurityDescriptorDacl(pOfficerSD, &pOfficerAcl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    // allocate a bool array for each DACL

    if(!GetAclInformation(pCAAcl,
                          &CAAclInfo,
                          sizeof(CAAclInfo),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }
    if(!GetAclInformation(pOfficerAcl,
                          &OfficerAclInfo,
                          sizeof(OfficerAclInfo),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    pCAFound = (PBOOL)LocalAlloc(LMEM_FIXED, sizeof(BOOL)*CAAclInfo.AceCount);
    if(!pCAFound)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(pCAFound, sizeof(BOOL)*CAAclInfo.AceCount);

    pOfficerFound = (PBOOL)LocalAlloc(LMEM_FIXED, sizeof(BOOL)*OfficerAclInfo.AceCount);
    if(!pOfficerFound)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(pOfficerFound, sizeof(BOOL)*OfficerAclInfo.AceCount);

    hr = GetEveryoneSID(&pSidEveryone);
    _JumpIfError(hr, error, "GetEveryoneSID");

    dwSidEveryoneSize = GetLengthSid(pSidEveryone);

    // mark in the bool arrays each ace whose SID is found in both DACLs;
    // also mark CA ACEs we are not interested in (denied ACEs and 
    // non-officer ACEs)

    for(cCAAce=0; cCAAce<CAAclInfo.AceCount; cCAAce++)
    {
        if(!GetAce(pCAAcl, cCAAce, (PVOID*)&pCAAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }
        
        // process only officer allow aces
        if(0==(pCAAce->Mask & CA_ACCESS_OFFICER))
        {
            pCAFound[cCAAce] = TRUE;
            continue;
        }

        // compare SIDs in each officer ace with current CA ace and mark 
        // corresponding bool in arrays if equal
        for(cOfficerAce=0; cOfficerAce<OfficerAclInfo.AceCount; cOfficerAce++)
        {
            if(!GetAce(pOfficerAcl, cOfficerAce, (PVOID*)&pOfficerAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }
            if(EqualSid((PSID)&pOfficerAce->SidStart,
                (PSID)&pCAAce->SidStart))
            {
                pCAFound[cCAAce] = TRUE;
                pOfficerFound[cOfficerAce] = TRUE;
            }
        }
        
        // if the officer is found in the CA ACL but not in the officer ACL,
        // we will add a new ACE allowing him to manage certs for Everyone
        if(!pCAFound[cCAAce])
        {
            dwNewAclSize += sizeof(ACCESS_ALLOWED_CALLBACK_ACE)+
                GetLengthSid((PSID)&pCAAce->SidStart)+
                dwSidEveryoneSize;
        }
    }

    // Calculate the size of the new officer ACL; we already added in the header
    // size and the size of the new ACEs to be added. Now we add the ACEs to be
    // copied over from the old ACL
    for(cOfficerAce=0; cOfficerAce<OfficerAclInfo.AceCount; cOfficerAce++)
    {
        if(pOfficerFound[cOfficerAce])
        {
            if(!GetAce(pOfficerAcl, cOfficerAce, (PVOID*)&pOfficerAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }
            dwNewAclSize += pOfficerAce->Header.AceSize;
        }
    }

    // allocate a new DACL

    pNewOfficerAcl = (PACL)LocalAlloc(LMEM_FIXED, dwNewAclSize);
    if(!pNewOfficerAcl)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

#ifdef _DEBUG
    ZeroMemory(pNewOfficerAcl, dwNewAclSize);
#endif 

    if(!InitializeAcl(pNewOfficerAcl, dwNewAclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // build the new DACL

    // traverse officer DACL and add only marked ACEs (whose SID was found
    // in the CA DACL, ie principal is an officer)
    for(cOfficerAce=0; cOfficerAce<OfficerAclInfo.AceCount; cOfficerAce++)
    {
        if(pOfficerFound[cOfficerAce])
        {
            if(!GetAce(pOfficerAcl, cOfficerAce, (PVOID*)&pOfficerAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(!AddAce(
                pNewOfficerAcl,
                ACL_REVISION,
                MAXDWORD,
                pOfficerAce,
                pOfficerAce->Header.AceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }
        }
    }

    CSASSERT(IsValidAcl(pNewOfficerAcl));

    hr = GetBuiltinAdministratorsSID(&pSidBuiltinAdministrators);
    _JumpIfError(hr, error, "GetBuiltinAdministratorsSID");
    
    // traverse the CA DACL and add a new officer to list, allowed to manage
    // Everyone
    for(cCAAce=0; cCAAce<CAAclInfo.AceCount; cCAAce++)
    {
        if(pCAFound[cCAAce])
            continue;

        if(!GetAce(pCAAcl, cCAAce, (PVOID*)&pCAAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        // create a new ACE
        dwSidSize = GetLengthSid((PSID)&pCAAce->SidStart);

        dwAceSize = sizeof(ACCESS_ALLOWED_CALLBACK_ACE)+
            dwSidEveryoneSize+dwSidSize;

        pNewAce = (ACCESS_ALLOWED_CALLBACK_ACE*) LocalAlloc(LMEM_FIXED, dwAceSize);
        if(!pNewAce)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
#ifdef _DEBUG
        ZeroMemory(pNewAce, dwAceSize);
#endif 

        pNewAce->Header.AceType = ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
        pNewAce->Header.AceFlags= 0;
        pNewAce->Header.AceSize = (USHORT)dwAceSize;
        pNewAce->Mask = DELETE;
        CopySid(dwSidSize,
            (PSID)&pNewAce->SidStart,
            (PSID)&pCAAce->SidStart);
        pSidList = (PSID_LIST)(((BYTE*)&pNewAce->SidStart)+dwSidSize);
        pSidList->dwSidCount = 1;
        
        CopySid(dwSidEveryoneSize,
            (PSID)&pSidList->SidListStart,
            pSidEveryone);

        CSASSERT(IsValidSid((PSID)&pNewAce->SidStart));
        
        if(!AddAce(
            pNewOfficerAcl,
            ACL_REVISION,
            MAXDWORD,
            pNewAce,
            dwAceSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "AddAce");
        }

        LocalFree(pNewAce);
        pNewAce = NULL;
    }

    CSASSERT(IsValidAcl(pNewOfficerAcl));

    // setup the new security descriptor
    
    pNewOfficerSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED,
                                      SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pNewOfficerSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
#ifdef _DEBUG
    ZeroMemory(pNewOfficerSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
#endif 

    if (!InitializeSecurityDescriptor(pNewOfficerSD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    if(!SetSecurityDescriptorOwner(
        pNewOfficerSD,
        pSidBuiltinAdministrators,
        FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    if(!SetSecurityDescriptorDacl(
        pNewOfficerSD,
        TRUE, // DACL present
        pNewOfficerAcl,
        FALSE)) // DACL defaulted
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    CSASSERT(IsValidSecurityDescriptor(pNewOfficerSD));

    hr = Set(pNewOfficerSD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    if(pNewAce)
    {
        LocalFree(pNewAce);
    }

    if(pSidEveryone)
    {
        FreeSid(pSidEveryone);
    }

    if(pSidBuiltinAdministrators)
    {
        FreeSid(pSidBuiltinAdministrators);
    }

    if(pNewOfficerAcl)
    {
        LocalFree(pNewOfficerAcl);
    }

    if(pNewOfficerSD)
    {
        LocalFree(pNewOfficerSD);
    }

    return hr;
}

HRESULT 
COfficerRightsSD::Adjust(PSECURITY_DESCRIPTOR pCASD)
{
    return Merge(Get(), pCASD);
}

HRESULT
COfficerRightsSD::InitializeEmpty()
{
    HRESULT hr = S_OK;
    ACL Acl;
    SECURITY_DESCRIPTOR SD;

    hr = Init(NULL);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");

    if(!InitializeAcl(&Acl, sizeof(ACL), ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }
   
    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    if(!SetSecurityDescriptorDacl(
        &SD,
        TRUE, // DACL present
        &Acl,
        FALSE)) // DACL defaulted
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    m_fInitialized = true;

    hr = Set(&SD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    return hr;
}

HRESULT COfficerRightsSD::Save()
{
    HRESULT hr = S_OK;

    if(IsEnabled())
    {
        hr = CProtectedSecurityDescriptor::Save();
        _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");
    }
    else
    {
        hr = CProtectedSecurityDescriptor::Delete();
        _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Delete");
    }

error:
    return hr;
}

HRESULT COfficerRightsSD::Load()
{
    HRESULT hr;
    
    hr = CProtectedSecurityDescriptor::Load();
    if(S_OK==hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        SetEnable(S_OK==hr);
        hr = S_OK;
    }
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");

error:
    return hr;
}

HRESULT COfficerRightsSD::Initialize(LPCWSTR pwszSanitizedName)
{
    HRESULT hr;
    
    hr = CProtectedSecurityDescriptor::Initialize(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");

    SetEnable(NULL!=m_pSD);

error:
    return hr;
}

HRESULT COfficerRightsSD::ConvertToString(
    IN PSECURITY_DESCRIPTOR pSD,
    OUT LPWSTR& rpwszSD)
{
    HRESULT hr = S_OK;
    LPCWSTR pcwszHeader = L"\n"; // start with a new line
    DWORD dwBufSize = sizeof(WCHAR)*(wcslen(pcwszHeader)+1);
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwIndex;
    PACCESS_ALLOWED_CALLBACK_ACE pAce; // no free
    PACL pDacl; // no free
    LPWSTR pwszAce; // no free

    CSASSERT(IsValidSecurityDescriptor(pSD));
    
    rpwszSD = NULL;

    // get acl
    hr = myGetSecurityDescriptorDacl(
             pSD,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }
    
    
    // calculate text size

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            NULL);
        _JumpIfError(hr, error, "ConvertAceToString");

        dwBufSize += dwAceSize;
    }

    rpwszSD = (LPWSTR)LocalAlloc(LMEM_FIXED, dwBufSize);
    _JumpIfAllocFailed(rpwszSD, error);

    // build the output string
    wcscpy(rpwszSD, pcwszHeader);
    
    pwszAce = rpwszSD + wcslen(pcwszHeader);

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            pwszAce);
        _JumpIfError(hr, error, "ConvertAceToString");

        pwszAce += dwAceSize/sizeof(WCHAR);
    }

error:
    return hr;
}

// Returned string has the following format:
//
// [Allow|Deny]\t[OfficerName|SID]\n
// \t[Client1Name|SID]\n
// \t[Client2Name|SID]\n
// ...
//
// Example:
//
// Allow    OfficerGroup1
//      ClientGroup1
//      ClientGroup2
//
// If SID cannot be converted to friendly name it is displayed
// as a string SID
//
HRESULT COfficerRightsSD::ConvertAceToString(
    IN PACCESS_ALLOWED_CALLBACK_ACE pAce,
    OUT OPTIONAL PDWORD pdwSize,
    IN OUT OPTIONAL LPWSTR pwszSD)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 1; // trailing '\0'
    CSid sid((PSID)(&pAce->SidStart));
    PSID_LIST pSidList = (PSID_LIST) (((BYTE*)&pAce->SidStart)+
        GetLengthSid(&pAce->SidStart));
    PSID pSid;
    DWORD cSids;
    
    LPCWSTR pcwszAllow      = m_pcwszResources[0];
    LPCWSTR pcwszDeny       = m_pcwszResources[1];

    LPCWSTR pcwszPermissionType = 
        (ACCESS_ALLOWED_CALLBACK_ACE_TYPE==pAce->Header.AceType)?
        pcwszAllow:pcwszDeny;
    LPCWSTR pcwszSid; // no free

    // asked for size and/or ace string
    CSASSERT(pdwSize || pwszSD);

    if(pAce->Header.AceType != ACCESS_ALLOWED_CALLBACK_ACE_TYPE &&
       pAce->Header.AceType != ACCESS_DENIED_CALLBACK_ACE_TYPE)
    {
        return E_INVALIDARG;
    }

    pcwszSid = sid.GetName();
    if(!pcwszSid)
    {
        return E_OUTOFMEMORY;
    }
    
    dwSize = wcslen(pcwszSid);

    dwSize += wcslen(pcwszPermissionType);
    
    dwSize += 2; // '\t' between sid an permission and a '\n' after

    if(pwszSD)
    {
        wcscat(pwszSD, pcwszPermissionType);
        wcscat(pwszSD, L"\t");
        wcscat(pwszSD, pcwszSid);
        wcscat(pwszSD, L"\n");
    }

    for(pSid=(PSID)&pSidList->SidListStart, cSids=0; cSids<pSidList->dwSidCount;
        cSids++, pSid = (PSID)(((BYTE*)pSid)+GetLengthSid(pSid)))
    {
        CSASSERT(IsValidSid(pSid));

        CSid sidClient(pSid);
        LPCWSTR pcwszSidClient;
        
        pcwszSidClient = sidClient.GetName();
        if(!pcwszSidClient)
        {
            return E_OUTOFMEMORY;
        }

        dwSize += wcslen(pcwszSidClient) + 2; // \tClientNameOrSid\n
        
        if(pwszSD)
        {
            wcscat(pwszSD, L"\t");
            wcscat(pwszSD, pcwszSidClient);
            wcscat(pwszSD, L"\n");
        }
    }

    dwSize *= sizeof(WCHAR);

    if(pdwSize)
    {
        *pdwSize = dwSize;
    }

    return hr;
}

HRESULT 
CertSrv::GetWellKnownSID(
    PSID *ppSid,
    SID_IDENTIFIER_AUTHORITY *pAuth,
    BYTE  SubauthorityCount,
    DWORD SubAuthority1,
    DWORD SubAuthority2,
    DWORD SubAuthority3,
    DWORD SubAuthority4,
    DWORD SubAuthority5,
    DWORD SubAuthority6,
    DWORD SubAuthority7,
    DWORD SubAuthority8)
{
    HRESULT hr = S_OK;

    // build Everyone SID
    if(!AllocateAndInitializeSid(
            pAuth,
            SubauthorityCount,
            SubAuthority1,
            SubAuthority2,
            SubAuthority3,
            SubAuthority4,
            SubAuthority5,
            SubAuthority6,
            SubAuthority7,
            SubAuthority8,
            ppSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AllocateAndInitializeSid");
    }

error:
    return hr;
}

// caller is responsible for LocalFree'ing PSID
HRESULT CertSrv::GetEveryoneSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_WORLD_SID_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        1,
        SECURITY_WORLD_RID);
    return S_OK;
}
// caller is responsible for LocalFree'ing PSID
HRESULT CertSrv::GetLocalSystemSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        1,
        SECURITY_LOCAL_SYSTEM_RID);
}

// caller is responsible for LocalFree'ing PSID
HRESULT CertSrv::GetBuiltinAdministratorsSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\prvlg.cpp ===
//+--------------------------------------------------------------------------
// File:        prvlg.cpp
// Contents:    privilege manager implementation
//---------------------------------------------------------------------------
#include <pch.cpp>
#include "prvlg.h"

using namespace CertSrv;

LSA_UNICODE_STRING CPrivilegeManager::m_lsaSecurityPrivilege[] = 
{
    sizeof(SE_SECURITY_NAME)-2,
    sizeof(SE_SECURITY_NAME),
    SE_SECURITY_NAME
};

LSA_UNICODE_STRING CPrivilegeManager::m_lsaBackupRestorePrivilege[] = 
{
    {
    sizeof(SE_BACKUP_NAME)-2,
    sizeof(SE_BACKUP_NAME),
    SE_BACKUP_NAME
    },
    {
    sizeof(SE_RESTORE_NAME)-2,
    sizeof(SE_RESTORE_NAME),
    SE_RESTORE_NAME
    }
};


HRESULT CPrivilegeManager::OpenPolicy()
{
    HRESULT hr = S_OK;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS NTStatus;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    NTStatus = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                &m_lsah);
    if(STATUS_SUCCESS!=NTStatus)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(NTStatus));
        _JumpError(hr, error, "LsaOpenPolicy");
    }

error:
    return hr;
}

HRESULT CPrivilegeManager::ClosePolicy()
{
    if(m_lsah)
        LsaClose(m_lsah);

    return S_OK;
}

void CPrivilegeManager::GetPrivilegeString(
    DWORD dwRole,
    PLSA_UNICODE_STRING &plsastr,
    ULONG &cstr)
{
    switch(dwRole)
    {
    case CA_ACCESS_AUDITOR:
        plsastr = m_lsaSecurityPrivilege;
        cstr = ARRAYSIZE(m_lsaSecurityPrivilege);
        break;
    case CA_ACCESS_OPERATOR:
        plsastr = m_lsaBackupRestorePrivilege;
        cstr = ARRAYSIZE(m_lsaBackupRestorePrivilege);
        break;
    }

}

HRESULT CPrivilegeManager::AddPrivilege(
    const PSID pSid, 
    DWORD dwRole)
{
    HRESULT hr = S_OK;
    NTSTATUS NTStatus;
    PLSA_UNICODE_STRING plsastr = NULL;
    ULONG cstr = 0;

    GetPrivilegeString(
        dwRole,
        plsastr,
        cstr);

    NTStatus = LsaAddAccountRights(
                m_lsah,
                pSid,
                plsastr,
                cstr);
    if(STATUS_SUCCESS!=NTStatus)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(NTStatus));
        _JumpError(hr, error, "LsaAddAcountRights");
    }
    
error:
    return hr;
}

HRESULT CPrivilegeManager::RemovePrivilege(
    const PSID pSid, 
    DWORD dwRole)
{
    HRESULT hr = S_OK;
    NTSTATUS NTStatus;
    PLSA_UNICODE_STRING plsastr = NULL;
    ULONG cstr = 0;

    GetPrivilegeString(
        dwRole,
        plsastr,
        cstr);

    NTStatus = LsaRemoveAccountRights(
                m_lsah,
                pSid,
                FALSE,
                plsastr,
                cstr);
    if(STATUS_SUCCESS!=NTStatus && STATUS_OBJECT_NAME_NOT_FOUND!=NTStatus)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(NTStatus));
        _JumpError(hr, error, "LsaRemoveAcountRights");
    }
    
error:
    return hr;
}

HRESULT CPrivilegeManager::InitBuffer(
    PACCESS_ALLOWED_ACE **buffer,
    DWORD cAce)
{
    *buffer = (PACCESS_ALLOWED_ACE *)LocalAlloc(LMEM_FIXED, 
        cAce*sizeof(PACCESS_ALLOWED_ACE));
    if(!*buffer)
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(*buffer, cAce*sizeof(PACCESS_ALLOWED_ACE));
    return S_OK;
}

HRESULT CPrivilegeManager::ComputePrivilegeChanges(
            const PSECURITY_DESCRIPTOR pOldSD,
            const PSECURITY_DESCRIPTOR pNewSD)
{
    HRESULT hr = S_OK;
    PACCESS_ALLOWED_ACE pOldAce, pNewAce;
    DWORD cOldAce, cNewAce;
    PACL pOldAcl, pNewAcl; // no free

    hr = myGetSecurityDescriptorDacl(
             pOldSD,
             &pOldAcl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    hr = myGetSecurityDescriptorDacl(
             pNewSD,
             &pNewAcl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    m_cOldAce = pOldAcl->AceCount;
    m_cNewAce = pNewAcl->AceCount;

    hr = InitBuffer(
            &m_pAddPrivilegeAudit,
            m_cNewAce);
    _JumpIfError(hr, error, "InitBuffer");

    hr = InitBuffer(
            &m_pAddPrivilegeBackup,
            m_cNewAce);
    _JumpIfError(hr, error, "InitBuffer");

    hr = InitBuffer(
            &m_pRemovePrivilegeAudit,
            m_cOldAce);
    _JumpIfError(hr, error, "InitBuffer");

    hr = InitBuffer(
            &m_pRemovePrivilegeBackup,
            m_cOldAce);
    _JumpIfError(hr, error, "InitBuffer");

    for(cNewAce=0; cNewAce<m_cNewAce; cNewAce++)
    {
        if(!GetAce(pNewAcl, cNewAce, (PVOID*)&pNewAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(pNewAce->Mask&CA_ACCESS_AUDITOR)
            m_pAddPrivilegeAudit[cNewAce] = pNewAce;
        if(pNewAce->Mask&CA_ACCESS_OPERATOR)
            m_pAddPrivilegeBackup[cNewAce] = pNewAce;
    }

    for(cOldAce=0; cOldAce<m_cOldAce; cOldAce++)
    {

        if(!GetAce(pOldAcl, cOldAce, (PVOID*)&pOldAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(pOldAce->Mask&CA_ACCESS_AUDITOR)
            m_pRemovePrivilegeAudit[cOldAce] = pOldAce;
        if(pOldAce->Mask&CA_ACCESS_OPERATOR)
            m_pRemovePrivilegeBackup[cOldAce] = pOldAce;

        for(cNewAce=0; cNewAce<m_cNewAce; cNewAce++)
        {
            if(!GetAce(pNewAcl, cNewAce, (PVOID*)&pNewAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(EqualSid((PSID)&pOldAce->SidStart,
                        (PSID)&pNewAce->SidStart))
            {
                if((pOldAce->Mask&CA_ACCESS_AUDITOR)&&
                   (pNewAce->Mask&CA_ACCESS_AUDITOR))
                {
                    m_pRemovePrivilegeAudit[cOldAce] = NULL;
                }
                if((pOldAce->Mask&CA_ACCESS_OPERATOR)&&
                   (pNewAce->Mask&CA_ACCESS_OPERATOR))
                {
                    m_pRemovePrivilegeBackup[cOldAce] = NULL;
                }
                if((pOldAce->Mask&CA_ACCESS_AUDITOR)&&
                   (pNewAce->Mask&CA_ACCESS_AUDITOR))
                {
                    m_pAddPrivilegeAudit[cNewAce] = NULL;
                }
                if((pOldAce->Mask&CA_ACCESS_OPERATOR)&&
                   (pNewAce->Mask&CA_ACCESS_OPERATOR))
                {
                    m_pAddPrivilegeBackup[cNewAce] = NULL;
                }
            }
        }
    }

error:
    return hr;
}

HRESULT CPrivilegeManager::UpdatePrivileges()
{
    HRESULT hr = S_OK;
    DWORD cOldAce, cNewAce;

    hr = OpenPolicy();
    _JumpIfError(hr, error, "CPrivilegeManager::OpenPolicy");

    for(cOldAce=0; cOldAce<m_cOldAce; cOldAce++)
    {
        if(m_pRemovePrivilegeBackup[cOldAce])
        {
            hr = RemovePrivilege(
                    (PSID)&(m_pRemovePrivilegeBackup[cOldAce]->SidStart),
                    CA_ACCESS_OPERATOR);
            _JumpIfError(hr, error, "CPrivilegeManager::RemovePrivilege");
        }
        if(m_pRemovePrivilegeAudit[cOldAce])
        {
            hr = RemovePrivilege(
                    (PSID)&(m_pRemovePrivilegeAudit[cOldAce]->SidStart),
                    CA_ACCESS_AUDITOR);
            _JumpIfError(hr, error, "CPrivilegeManager::RemovePrivilege");
        }
    }

    for(cNewAce=0; cNewAce<m_cNewAce; cNewAce++)
    {
        if(m_pAddPrivilegeBackup[cNewAce])
        {
            hr = AddPrivilege(
                    (PSID)&(m_pAddPrivilegeBackup[cNewAce]->SidStart),
                    CA_ACCESS_OPERATOR);
            _JumpIfError(hr, error, "CPrivilegeManager::AddPrivilege");
        }
        if(m_pAddPrivilegeAudit[cNewAce])
        {
            hr = AddPrivilege(
                    (PSID)&(m_pAddPrivilegeAudit[cNewAce]->SidStart),
                    CA_ACCESS_AUDITOR);
            _JumpIfError(hr, error, "CPrivilegeManager::AddPrivilege");
        }
    }
error:
    
    ClosePolicy();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\reg.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        reg.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <sddl.h>
#include <assert.h>

#include "certacl.h"
#include "polreg.h"


HRESULT
myFormCertRegPath(
    IN  WCHAR const *pwszName1,
    IN  WCHAR const *pwszName2,
    IN  WCHAR const *pwszName3,
    IN  BOOL         fConfigLevel,  // from CertSrv if FALSE
    OUT WCHAR      **ppwszPath)
{
    HRESULT  hr;
    WCHAR   *pwszPath = NULL;
    DWORD    len1;
    DWORD    len2;
    DWORD    len3;

    len1 = NULL != pwszName1 ? wcslen(pwszName1) + 1 : 0;
    len2 = 0 != len1 && NULL != pwszName2 ? wcslen(pwszName2) + 1 : 0;
    len3 = 0 != len2 && NULL != pwszName3 ? wcslen(pwszName3) + 1 : 0;

    pwszPath = (WCHAR*)LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    ((fConfigLevel?
				WSZARRAYSIZE(wszREGKEYCONFIGPATH) :
				WSZARRAYSIZE(wszREGKEYCERTSVCPATH)) +
			     len1 +
			     len2 +
			     len3 +
			     1) * sizeof(WCHAR));
    if (NULL == pwszPath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszPath, fConfigLevel? wszREGKEYCONFIGPATH : wszREGKEYCERTSVCPATH);

    if (NULL != pwszName1)
    {
        wcscat(pwszPath, L"\\");
        wcscat(pwszPath, pwszName1);
        if (NULL != pwszName2)
        {
            wcscat(pwszPath, L"\\");
            wcscat(pwszPath, pwszName2);
            if (NULL != pwszName3)
            {
                wcscat(pwszPath, L"\\");
                wcscat(pwszPath, pwszName3);
            }
        }
    }

    *ppwszPath = pwszPath;
    pwszPath = NULL;

    hr = S_OK;
error:
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myDeleteCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN BOOL                  fAbsolutePath)
{
    HRESULT  hr;
    HKEY     hKey = NULL;
    WCHAR    *pwszTemp = NULL;

    if (!fAbsolutePath)
    {
        hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, TRUE, &pwszTemp);
        _JumpIfError(hr, error, "myFormCertRegPath");
    }
    else
    {
        CSASSERT(NULL == pwszName2 && NULL == pwszName3);
    }

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    fAbsolutePath ? pwszName1 : pwszTemp,
		    0,
		    KEY_ALL_ACCESS,
		    &hKey);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    hr = RegDeleteValue(hKey, pwszValueName);
    if ((HRESULT) ERROR_FILE_NOT_FOUND != hr)
    {
	_JumpIfError(hr, error, "RegDeleteValue");
    }
    hr = S_OK;

error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return(myHError(hr));
}


HRESULT
myDeleteCertRegValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName)
{
    return myDeleteCertRegValueEx(pwszName1,
                                  pwszName2,
                                  pwszName3,
                                  pwszValueName,
                                  FALSE);
}

HRESULT
myDeleteCertRegKeyEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel)
{
    HRESULT  hr;
    WCHAR    *pwszTemp = NULL;

    hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, fConfigLevel, &pwszTemp);
    _JumpIfError(hr, error, "myFormCertRegPath");

    hr = RegDeleteKey(
		    HKEY_LOCAL_MACHINE,
		    pwszTemp);
    _JumpIfError(hr, error, "RegDeleteKey");

    hr = S_OK;
error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return(myHError(hr));
}


HRESULT
myDeleteCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3)
{
    return myDeleteCertRegKeyEx(pwszName1, pwszName2, pwszName3, TRUE);
}


HRESULT
myCreateCertRegKeyEx(
    IN BOOL                  fSetAcl,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3)
{
    HRESULT  hr;
    HKEY     hKey = NULL;
    DWORD    dwDisposition;
    WCHAR    *pwszTemp = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;

    hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, TRUE, &pwszTemp);
    _JumpIfError(hr, error, "myFormCertRegPath");

    hr = RegCreateKeyEx(
		    HKEY_LOCAL_MACHINE,
		    pwszTemp,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    if (fSetAcl)
    {
        // construct correct reg acl for the key if upgrade
        hr = myGetSDFromTemplate(WSZ_DEFAULT_UPGRADE_SECURITY,
                                 NULL,
                                 &pSD);
        if (S_OK == hr)
        {
            // set to correct acl
            hr = RegSetKeySecurity(hKey,
                                   DACL_SECURITY_INFORMATION,
                                   pSD);
            _PrintIfError(hr, "RegSetKeySecurity");
        }
        else
        {
            _PrintError(hr, "myGetSDFromTemplate");
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    return(myHError(hr));
}

HRESULT
myCreateCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3)
{
    return myCreateCertRegKeyEx(FALSE,  // not upgrade
                                pwszName1,
                                pwszName2,
                                pwszName3);
}

HRESULT
mySetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath)
{
    HRESULT  hr;
    HKEY     hKey = NULL;
    WCHAR    *pwszTemp = NULL;
    BOOL     fFree = TRUE;
    DWORD    dwDisposition;
    HKEY     hBaseKey = NULL;
    DWORD    cbD = cbData;

    if (!fAbsolutePath)
    {
        hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, fConfigLevel, &pwszTemp);
        _JumpIfError(hr, error, "myFormCertRegPath");
    }

    if (pwszMachine)
    {
        hr = RegConnectRegistry(
            pwszMachine,
            HKEY_LOCAL_MACHINE,
            &hBaseKey);
        _JumpIfError(hr, error, "RegConnectRegistry");
    }
    else
        hBaseKey = HKEY_LOCAL_MACHINE;

    hr = RegCreateKeyEx(
		    hBaseKey,
		    fAbsolutePath ? pwszName1 : pwszTemp,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    if (NULL != pwszValueName)
    {
        if(NULL == pbData || 0 == cbData)
        {
            switch(dwValueType)
            {
            case REG_EXPAND_SZ:
            case REG_SZ:
                pbData = (BYTE*) L"";
                cbD    = sizeof (L"");
                break;
            case REG_MULTI_SZ:
                pbData = (BYTE*) L"\0";
                cbD    = sizeof (L"\0");
                break;
            }
        }
        hr = RegSetValueEx(
	        hKey,
	        pwszValueName,
	        0,
	        dwValueType,
	        pbData,
	        cbD);
        _JumpIfError(hr, error, "RegSetValueEx");
    }

    hr = S_OK;
error:
    if ((NULL != hBaseKey) && (HKEY_LOCAL_MACHINE != hBaseKey))
    {
        RegCloseKey(hBaseKey);
    }
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return(myHError(hr));
}

HRESULT
mySetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath)
{
    return mySetCertRegValueEx(pwszMachine,
                               pwszName1,
                               pwszName2,
                               pwszName3,
                               TRUE, //from Configuration
                               pwszValueName,
                               dwValueType,
                               pbData,
                               cbData,
                               fAbsolutePath);
}

HRESULT
myGetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType)
{
    HRESULT hr;
    HKEY hKey = NULL;
    WCHAR *pwszTemp = NULL;
    DWORD dwDisposition;
    DWORD dwType;
    DWORD dwLen;
    BYTE *pbData = NULL;
    DWORD cbZero = 0;
    HKEY hBaseKey = NULL;

    *ppbData = NULL;
    if (NULL != pcbData)
    {
        *pcbData = 0;
    }
    if (NULL != pValueType)
    {
        *pValueType = REG_NONE;
    }

    hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, fConfigLevel, &pwszTemp);
    _JumpIfError(hr, error, "myFormCertRegPath");

    if (pwszMachine)
    {
        hr = RegConnectRegistry(
            pwszMachine,
            HKEY_LOCAL_MACHINE,
            &hBaseKey);
        _JumpIfError(hr, error, "RegConnectRegistry");
    }
    else
        hBaseKey = HKEY_LOCAL_MACHINE;

    hr = RegOpenKeyEx(
		    hBaseKey,
		    pwszTemp,
		    0,
		    KEY_READ,
		    &hKey);
    _JumpIfError2(hr, error, "RegOpenKeyEx", ERROR_FILE_NOT_FOUND);

    while (TRUE)
    {
	hr = RegQueryValueEx(
		        hKey,
		        pwszValueName,
		        0,
		        &dwType,
		        pbData,
		        &dwLen);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "RegQueryValueEx",
		    pwszValueName,
		    ERROR_FILE_NOT_FOUND);

        if (NULL != pbData)
        {
	    ZeroMemory(&pbData[dwLen], cbZero);
            break;
        }

	// Enforce WCHAR-aligned double null termination for malformed values.
	// Some callers need to treat REG_SZ values as REG_MULTI_SZ.

	if (REG_MULTI_SZ == dwType || REG_SZ == dwType)
	{
	    cbZero = 2 * sizeof(WCHAR);
	    if (dwLen & (sizeof(WCHAR) - 1))
	    {
		cbZero++;
	    }
	}
        pbData = (BYTE *) LocalAlloc(LMEM_FIXED, dwLen + cbZero);
        if (NULL == pbData)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }
    if (NULL != pValueType)
    {
        *pValueType = dwType;
    }
    if (NULL != pcbData)
    {
        *pcbData = dwLen;
    }
    *ppbData = pbData;
    hr = S_OK;

error:
    if ((NULL != hBaseKey) && (hBaseKey != HKEY_LOCAL_MACHINE))
    {
        RegCloseKey(hBaseKey);
    }

    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return(myHError(hr));
}

HRESULT
myGetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType)
{
    return myGetCertRegValueEx(pwszMachine,
                               pwszName1,
                               pwszName2,
                               pwszName3,
                               TRUE, //from Configuration
                               pwszValueName,
                               ppbData,
                               pcbData,
                               pValueType);
}

HRESULT
mySetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue)
{
    DWORD cwc = 0;
    DWORD cwcT;
    WCHAR const *pwc;

    if (NULL != pwszzValue)
    {
	for (pwc = pwszzValue; L'\0' != *pwc; cwc += cwcT, pwc += cwcT)
	{
	    cwcT = wcslen(pwc) + 1;
	}
	cwc++;
    }

    return(mySetCertRegValue(
			 NULL,
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 REG_MULTI_SZ,
			 (BYTE const *) pwszzValue,
			 cwc * sizeof(WCHAR),
			 FALSE));
}


HRESULT
mySetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszValue)
{
    DWORD cwc = 0;

    if (NULL != pwszValue)
    {
        cwc = wcslen(pwszValue) + 1;
    }
    return mySetCertRegValue(
			 NULL,
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 REG_SZ,
			 (BYTE const *) pwszValue,
			 cwc * sizeof(WCHAR),
			 FALSE);
}


HRESULT
mySetAbsRegMultiStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszzValue)
{
    DWORD cwc = 0;
    DWORD cwcT;
    WCHAR const *pwc;

    if (NULL != pwszzValue)
    {
	for (pwc = pwszzValue; L'\0' != *pwc; cwc += cwcT, pwc += cwcT)
	{
	    cwcT = wcslen(pwc) + 1;
	}
	cwc++;
    }
    return(mySetCertRegValue(
			 NULL,
			 pwszName,
			 NULL,
			 NULL,
			 pwszValueName,
			 REG_MULTI_SZ,
			 (BYTE const *) pwszzValue,
			 cwc * sizeof(WCHAR),
			 TRUE));
}


HRESULT
mySetAbsRegStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszValue)
{
    DWORD cwc = 0;

    if (NULL != pwszValue)
    {
        cwc = wcslen(pwszValue) + 1;
    }
    return mySetCertRegValue(
			 NULL,
			 pwszName,
			 NULL,
			 NULL,
			 pwszValueName,
			 REG_SZ,
			 (BYTE const *)pwszValue,
			 cwc*sizeof(WCHAR),
			 TRUE);
}


HRESULT
mySetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValue)
{
    return mySetCertRegValue(
			 NULL,
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 REG_DWORD,
			 (BYTE const *)&dwValue,
			 sizeof(DWORD),
			 FALSE);
}


HRESULT
myGetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    OUT WCHAR               **ppwszzValue)
{
    HRESULT hr;
    DWORD dwType;

    hr = myGetCertRegValue(
		       NULL,
		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       (BYTE **) ppwszzValue,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (REG_MULTI_SZ != dwType && REG_SZ != dwType)
    {
	LocalFree(*ppwszzValue);
	*ppwszzValue = NULL;

	hr = E_INVALIDARG;
	_JumpError(hr, error, "not REG_SZ or REG_MULTI_SZ");
    }
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}

HRESULT
myGetCertRegBinaryValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbValue)
{
    HRESULT hr;
    DWORD dwType;

    hr = myGetCertRegValue(
		       NULL,
 		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       ppbValue,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszName1,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (REG_BINARY != dwType)
    {
        LocalFree(*ppbValue);
        *ppbValue = NULL;

        hr = E_INVALIDARG;
        _JumpError(hr, error, "not REG_BINARY");
    }
    hr = S_OK;

error:
    return hr;
}

HRESULT
myGetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT WCHAR               **ppwszValue)
{
    HRESULT hr;
    DWORD dwType;

    hr = myGetCertRegValue(
		       NULL,
 		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       (BYTE **) ppwszValue,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszName1,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (REG_SZ != dwType)
    {
        LocalFree(*ppwszValue);
        *ppwszValue = NULL;

        hr = E_INVALIDARG;
        _JumpError(hr, error, "not REG_SZ");
    }
    hr = S_OK;

error:
    return hr;
}


HRESULT
myGetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT DWORD               *pdwValue)
{
    HRESULT hr;
    DWORD *pdw = NULL;
    DWORD dwType;

    *pdwValue = 0;
    hr = myGetCertRegValue(
		       NULL,
		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       (BYTE **) &pdw,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    if (REG_DWORD != dwType)
    {
        hr = E_INVALIDARG;
        _JumpErrorStr(hr, error, "not REG_DWORD", pwszValueName);
    }
    *pdwValue = *pdw;
    hr = S_OK;

error:
    if (NULL != pdw)
    {
        LocalFree(pdw);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr)
{
    HRESULT   hr;
    WCHAR    *pwszOrzzValue = NULL;
    WCHAR const *pwszName = NULL != pwszDesValueName?
                            pwszDesValueName : pwszSrcValueName;

    // get value from source
    if (fMultiStr)
    {
        hr = myGetCertRegMultiStrValue(
				 pwszSrcName1,
				 pwszSrcName2,
				 pwszSrcName3,
				 pwszSrcValueName,
				 &pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "myGetCertRegMultiStrValue", pwszSrcValueName);

        // set it to destination
        hr = mySetCertRegMultiStrValue(
				 pwszDesName1,
				 pwszDesName2,
				 pwszDesName3,
				 pwszName,
				 pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszName);
    }
    else
    {
        hr = myGetCertRegStrValue(
			     pwszSrcName1,
			     pwszSrcName2,
			     pwszSrcName3,
			     pwszSrcValueName,
			     &pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", pwszSrcValueName);

        // set it to destination
        hr = mySetCertRegStrValue(
			     pwszDesName1,
			     pwszDesName2,
			     pwszDesName3,
			     pwszName,
			     pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszName);
    }
    hr = S_OK;

error:
    if (NULL != pwszOrzzValue)
    {
        LocalFree(pwszOrzzValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myMoveCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr)
{
    HRESULT hr;

    hr = myCopyCertRegStrValue(
			pwszSrcName1,
			pwszSrcName2,
			pwszSrcName3,
			pwszSrcValueName,
			pwszDesName1,
			pwszDesName2,
			pwszDesName3,
			pwszDesValueName,
			fMultiStr);
    _JumpIfErrorStr(hr, error, "myCopyCertRegStrValue", pwszSrcValueName);

    hr = myDeleteCertRegValue(
			pwszSrcName1,
			pwszSrcName2,
			pwszSrcName3,
			pwszSrcValueName);
    _PrintIfErrorStr(hr, "myDeleteCertRegValue", pwszSrcValueName);
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}

HRESULT
myMoveOrCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr,
    IN BOOL                  fMove)
{
    HRESULT hr;

    if (fMove)
    {
        hr = myMoveCertRegStrValue(
                     pwszSrcName1,
                     pwszSrcName2,
                     pwszSrcName3,
                     pwszSrcValueName,
                     pwszDesName1,
                     pwszDesName2,
                     pwszDesName3,
                     pwszDesValueName,
                     fMultiStr);
    }
    else
    {
        hr = myCopyCertRegStrValue(
                     pwszSrcName1,
                     pwszSrcName2,
                     pwszSrcName3,
                     pwszSrcValueName,
                     pwszDesName1,
                     pwszDesName2,
                     pwszDesName3,
                     pwszDesValueName,
                     fMultiStr);
    }

    return hr;
}

// Description: it does the same thing as mySetCertRegStrValue but it takes
//              upgrade flag, if upgrade and entry exists, do nothing
HRESULT
mySetCertRegStrValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszValue)
{
    HRESULT hr;
    WCHAR *pwszDummy = NULL;

    if (fUpgrade)
    {
        // see if it exists
        hr = myGetCertRegStrValue(
			     pwszName1,
			     pwszName2,
			     pwszName3,
			     pwszValueName,
			     &pwszDummy);
        if (S_OK == hr)
	{
	    if (NULL != pwszDummy && L'\0' != pwszDummy[0])
	    {
		goto error;	// keep existing entry
	    }
	}
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegStrValue", pwszValueName);
        }
    }
    // cases: 1) not upgrade
    //        2) upgrade but no existing entry
    //        3) upgrade, existing but empty reg string
    hr = mySetCertRegStrValue(
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 pwszValue);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszValueName);

error:
    if (NULL != pwszDummy)
    {
        LocalFree(pwszDummy);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// calculate multi string character length including double zero terminators
DWORD
myWCSZZLength(
    IN WCHAR const *pwszz)
{
    DWORD len = 0;
    WCHAR const *pwsz = pwszz;

    if (NULL != pwszz)
    {
        // point to the end of pwszz
        for (; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)  
        {
        }

        len = SAFE_SUBTRACT_POINTERS(pwsz, pwszz) + 1;
    }
    return len;
}

// merge two multi strings into one
// ignore redundant strings
HRESULT
myMergeMultiStrings(
    IN WCHAR const *pwszzStr1,
    IN WCHAR const *pwszzStr2,
    OUT WCHAR **ppwszzStr)
{
    HRESULT  hr;

    DWORD dwStr1 = myWCSZZLength(pwszzStr1);
    DWORD dwStr2 = 0;
    DWORD i = 0;
    DWORD dwCount = 0;

    WCHAR const *pwsz1;
    WCHAR const *pwsz2;
    WCHAR *pwsz;
    BOOL *pfRedundant = NULL;
    WCHAR *pwszzMerge = NULL;

    // init
    *ppwszzStr = NULL;

    //calculate string count
    for (pwsz2 = pwszzStr2; L'\0' != *pwsz2; pwsz2 += wcslen(pwsz2) + 1)
    {
        ++dwCount;
    }
    if (0 == dwCount)
    {
        //no merge needed
        goto only_str1;
    }
    pfRedundant = (BOOL*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                dwCount * sizeof(BOOL));
    if (NULL == pfRedundant)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    //calculate size
    for (pwsz2 = pwszzStr2; L'\0' != *pwsz2; pwsz2 += wcslen(pwsz2) + 1)
    {
        ++i;
        for (pwsz1 = pwszzStr1; L'\0' != *pwsz1; pwsz1 += wcslen(pwsz1) + 1)
        {
            if (0 == lstrcmpi(pwsz2, pwsz1))
            {
                //pwsz2 exists in pwszzStr1, dont take it
                // cache information
                pfRedundant[i - 1] = TRUE;
                break; //for pwsz1
            }
        }
        //if get here, no-existing
        dwStr2 += wcslen(pwsz2) + 1;
    }

only_str1:
    pwszzMerge = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                    (dwStr1 + dwStr2) * sizeof(WCHAR));
    if (NULL == pwszzMerge)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // copy existing
    CopyMemory(pwszzMerge,
               pwszzStr1,
               (dwStr1 - 1) * sizeof(WCHAR));
 
    if (0 < dwCount)
    {
        // merge begins
        i = 0;
        // point to end at 2nd z
        pwsz = pwszzMerge + dwStr1 - 1;
        for (pwsz2 = pwszzStr2; L'\0' != *pwsz2; pwsz2 += wcslen(pwsz2) + 1)
        {
            if (!pfRedundant[i])
            {
                wcscpy(pwsz, pwsz2);
                pwsz += wcslen(pwsz) + 1;
            }
            ++i;
        }
        // zz
        *pwsz = L'\0';
    }

    *ppwszzStr = pwszzMerge;
    pwszzMerge = NULL;

    hr = S_OK;
error:
    if (NULL != pfRedundant)
    {
        LocalFree(pfRedundant);
    }
    if (NULL != pwszzMerge)
    {
        LocalFree(pwszzMerge);
    }
    return hr;
}

// append one multi_sz to another
HRESULT
myAppendMultiStrings(
    IN WCHAR const *pwszzStr1,
    IN WCHAR const *pwszzStr2,
    OUT WCHAR **ppwszzStr)
{
    HRESULT  hr;

    DWORD dwStr1 = myWCSZZLength(pwszzStr1);
    DWORD dwStr2 = myWCSZZLength(pwszzStr2);

    // init
    *ppwszzStr = NULL;

    WCHAR *pwszzMerge = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                    (dwStr1 + dwStr2 - 1) * sizeof(WCHAR));
    if (NULL == pwszzMerge)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // copy existing
    CopyMemory(pwszzMerge,
               pwszzStr1,
               (dwStr1 - 1) * sizeof(WCHAR));
    // append second
    CopyMemory(pwszzMerge + dwStr1 - 1,
               pwszzStr2,
               dwStr2 * sizeof(WCHAR));
    *ppwszzStr = pwszzMerge;

     hr = S_OK;
error:
     return hr;
}

// Description: it does the same thing as mySetCertRegMultiStrValue but it takes
//              upgrade|append flag, if upgrade and entry exists, do nothing
//              if upgrade & append, merge existing entry with in-pwszz
HRESULT
mySetCertRegMultiStrValueEx(
    IN DWORD                 dwFlags, //CSREG_UPGRADE|CSREG_APPEND|CSREG_REPLACE|CSREG_MERGE
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue)
{
    HRESULT hr;
    WCHAR *pwszzExisting = NULL;
    WCHAR const  *pwszzFinal = pwszzValue; //default
    WCHAR *pwszzMerge = NULL;

    if (0x0 == (CSREG_REPLACE & dwFlags) &&
        (CSREG_UPGRADE & dwFlags) )
    {
        // to see if it exist
        hr = myGetCertRegMultiStrValue(
				 pwszName1,
				 pwszName2,
				 pwszName3,
				 pwszValueName,
				 &pwszzExisting);
        if (S_OK == hr)
        {
            if (NULL != pwszzExisting)
            {
                if (0x0 == (CSREG_APPEND & dwFlags) &&
                    0x0 == (CSREG_MERGE  & dwFlags) )
                {
		    goto error;	// keep existing entry
                }
                else if (0x0 != (CSREG_MERGE & dwFlags))
                {
                    hr = myMergeMultiStrings(
                                 pwszzExisting,
                                 pwszzValue,
                                 &pwszzMerge);
                    _JumpIfError(hr, error, "myMergeMultiStrings");
                    pwszzFinal = pwszzMerge;
                }
                else if (0x0 != (CSREG_APPEND & dwFlags))
                {
                    hr = myAppendMultiStrings(
                                 pwszzExisting,
                                 pwszzValue,
                                 &pwszzMerge);
                    _JumpIfError(hr, error, "myAppendMultiStrings");
                    pwszzFinal = pwszzMerge;
                }
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegMultiStrValue", pwszValueName);
        }
    }
    hr = mySetCertRegMultiStrValue(
			     pwszName1,
			     pwszName2,
			     pwszName3,
			     pwszValueName,
			     pwszzFinal);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszValueName);

error:
    if (NULL != pwszzExisting)
    {
        LocalFree(pwszzExisting);
    }
    if (NULL != pwszzMerge)
    {
        LocalFree(pwszzMerge);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Description: it does the same thing as mySetCertRegDWValue but it takes
//              upgrade flag, if upgrade and entry exists, do nothing
HRESULT
mySetCertRegDWValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValue)
{
    HRESULT hr;
    DWORD   dwDummy;

    if (fUpgrade)
    {
        // to see if it exist
        hr = myGetCertRegDWValue(
                     pwszName1,
                     pwszName2,
                     pwszName3,
                     pwszValueName,
                     &dwDummy);
        if (S_OK == hr)
        {
	    goto error;	// keep existing entry
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegDWValue", pwszValueName);
        }
    }
    hr = mySetCertRegDWValue(
                     pwszName1,
                     pwszName2,
                     pwszName3,
                     pwszValueName,
                     dwValue);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", pwszValueName);

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


WCHAR const *
wszRegCertChoice(
    IN DWORD dwRegHashChoice)
{
    WCHAR const *pwsz;
    
    switch (dwRegHashChoice)
    {
	case CSRH_CASIGCERT:
	    pwsz = wszREGCACERTHASH;
	    break;

	case CSRH_CAXCHGCERT:
	    pwsz = wszREGCAXCHGCERTHASH;
	    break;

	case CSRH_CAKRACERT:
	    pwsz = wszREGKRACERTHASH;
	    break;

	default:
	    CSASSERT("dwRegHashChoice");
	    pwsz = L"";
	    break;
    }
    return(pwsz);
}


WCHAR const g_wszNoHash[] = L"-";


HRESULT myShrinkCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index)
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwType;
    DWORD count;
    WCHAR *pwszzOld = NULL;
    WCHAR *pwchr = NULL; // no free

    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszzOld,
		    &i,		// ignore &cb
		    &dwType);
    _JumpIfErrorStr(hr, error, "myGetCertRegValue", wszRegCertChoice(dwRegHashChoice));

    for (count = 0, pwchr = pwszzOld;
         count < Index && L'\0' != *pwchr;
         count++, pwchr += wcslen(pwchr) + 1)
	NULL;

    // valid only if shrinking the list
    if(L'\0' == *pwchr)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "new hash count should be smaller than current count");
    }

    *pwchr = L'\0';

    hr = mySetCertRegValue(
			NULL,
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszRegCertChoice(dwRegHashChoice),
			REG_MULTI_SZ,
			(BYTE const *) pwszzOld,
			(SAFE_SUBTRACT_POINTERS(pwchr, pwszzOld) + 1) * sizeof(WCHAR),
			FALSE);
    _JumpIfError(hr, error, "mySetCertRegValue");

error:
    if(pwszzOld)
        LocalFree(pwszzOld);
    return hr;
}

HRESULT
mySetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    BSTR strHash = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    WCHAR *pwszzOld = NULL;
    WCHAR *pwszzNew = NULL;
    DWORD cOld;
    DWORD i;
    DWORD cNew;
    DWORD cwcNew;
    WCHAR const **apwsz = NULL;
    DWORD dwType;
    WCHAR *pwc;

    if (NULL == pwszSanitizedCAName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "empty ca name");
    }

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
			pCert,
			CERT_HASH_PROP_ID,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    cOld = 0;
    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszzOld,
		    &i,		// ignore &cb
		    &dwType);
    _PrintIfError2(hr, "myGetCertRegValue", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    if (S_OK == hr && REG_MULTI_SZ == dwType)
    {
	for (pwc = pwszzOld; L'\0' != *pwc; pwc += wcslen(pwc) + 1)
	{
	    cOld++;
	}
    }

    cNew = max(Index + 1, cOld);
    apwsz = (WCHAR const **) LocalAlloc(LMEM_FIXED, cNew * sizeof(*apwsz));
    if (NULL == apwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    i = 0;
    if (0 != cOld)
    {
	for (pwc = pwszzOld; L'\0' != *pwc; pwc += wcslen(pwc) + 1)
	{
	    DBGPRINT((DBG_SS_CERTLIBI, "Old CARegHash[%u] = \"%ws\"\n", i, pwc));
	    apwsz[i++] = pwc;
	}
	CSASSERT(i == cOld);
    }
    while (i < Index)
    {
	DBGPRINT((DBG_SS_CERTLIBI, "CARegHash[%u] Unused\n", i));
	apwsz[i++] = g_wszNoHash;
    }
    if (Index < cOld)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "Replacing CARegHash[%u] = \"%ws\"\n",
	    Index,
	    apwsz[Index]));
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"Adding CARegHash[%u] = \"%ws\"\n",
	Index,
	strHash));
    apwsz[Index] = strHash;

    cwcNew = 1;		// wszz double termination
    for (i = 0; i < cNew; i++)
    {
	cwcNew += wcslen(apwsz[i]) + 1;
    }

    pwszzNew = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcNew * sizeof(WCHAR));
    if (NULL == pwszzNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwc = pwszzNew;
    for (i = 0; i < cNew; i++)
    {
	wcscpy(pwc, apwsz[i]);
	DBGPRINT((DBG_SS_CERTLIBI, "New CARegHash[%u] = \"%ws\"\n", i, pwc));
	pwc += wcslen(pwc) + 1;
    }
    *pwc = L'\0';

    CSASSERT(&pwszzNew[cwcNew - 1] == pwc);

    hr = mySetCertRegValue(
			NULL,
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszRegCertChoice(dwRegHashChoice),
			REG_MULTI_SZ,
			(BYTE const *) pwszzNew,
			cwcNew * sizeof(WCHAR),
			FALSE);
    _JumpIfError(hr, error, "mySetCertRegValue");

error:
    if (NULL != apwsz)
    {
	LocalFree(apwsz);
    }
    if (NULL != pwszzOld)
    {
	LocalFree(pwszzOld);
    }
    if (NULL != pwszzNew)
    {
	LocalFree(pwszzNew);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
myGetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OUT BYTE **ppbHash,
    OUT DWORD *pcbHash)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    DWORD cb;
    DWORD dwType;
    WCHAR *pwc;
    DWORD i;

    *ppbHash = NULL;
    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszz,
		    &cb,
		    &dwType);
    _JumpIfError(hr, error, "myGetCertRegValue");

    if (REG_MULTI_SZ != dwType)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "dwType");
    }
    pwc = pwszz;
    for (i = 0; i < Index; i++)
    {
	if (L'\0' == *pwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "Index too large");
	}
	pwc += wcslen(pwc) + 1;
    }
    if (0 == lstrcmp(g_wszNoHash, pwc))
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "Unused hash", S_FALSE);
    }
    hr = WszToMultiByteInteger(TRUE, pwc, pcbHash, ppbHash);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

error:
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


HRESULT
myGetCARegHashCount(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    OUT DWORD *pCount)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    DWORD cb;
    DWORD dwType;
    WCHAR *pwc;
    DWORD Count = 0;

    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszz,
		    &cb,
		    &dwType);
    if (S_OK == hr)
    {
	if (REG_MULTI_SZ == dwType)
	{
	    for (pwc = pwszz; L'\0' != *pwc; pwc += wcslen(pwc) + 1)
	    {
		Count++;
	    }
	}
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpError(hr, error, "myGetCertRegValue");
    }
    hr = S_OK;

error:
    *pCount = Count;
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


HRESULT
myFindCACertByHash(
    IN HCERTSTORE hStore,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT OPTIONAL DWORD *pdwNameId,
    CERT_CONTEXT const **ppCACert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB Hash;

    CSASSERT(
	NULL != hStore &&
	NULL != pbHash &&
	NULL != ppCACert);

    *ppCACert = NULL;
    Hash.pbData = const_cast<BYTE *>(pbHash);
    Hash.cbData = cbHash;

    *ppCACert = CertFindCertificateInStore(
				    hStore,
				    X509_ASN_ENCODING,
				    0,
				    CERT_FIND_HASH,
				    &Hash,
				    NULL);
    if (NULL == *ppCACert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertFindCertificateInStore");
    }

    if (NULL != pdwNameId)
    {
        *pdwNameId = MAXDWORD;
        hr = myGetNameId(*ppCACert, pdwNameId);
        _PrintIfError(hr, "myGetNameId");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myFindCACertByHashIndex(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OPTIONAL OUT DWORD *pdwNameId,
    CERT_CONTEXT const **ppCACert)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE *pbHash = NULL;

    CSASSERT(NULL != hStore && NULL != ppCACert);

    if (NULL != pdwNameId)
    {
        *pdwNameId = MAXDWORD;
    }
    *ppCACert = NULL;

    hr = myGetCARegHash(
		    pwszSanitizedCAName,
		    dwRegHashChoice,
		    Index,
		    &pbHash,
		    &cbHash);
    _JumpIfError2(hr, error, "myGetCARegHash", S_FALSE);

    hr = myFindCACertByHash(hStore, pbHash, cbHash, pdwNameId, ppCACert);
    _JumpIfError(hr, error, "myFindCACertByHash");

error:
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    return(hr);
}


HRESULT
GetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *pdwStatus)
{
    HRESULT hr;

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGSETUPSTATUS,
			pdwStatus);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegDWValue",
		wszREGSETUPSTATUS,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    DBGPRINT((DBG_SS_CERTLIBI, "GetSetupStatus(%ws) --> %x\n", pwszSanitizedCAName, *pdwStatus));

error:
    return(hr);
}


HRESULT
SetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    IN const DWORD  dwFlag,
    IN const BOOL   fSetBit)
{
    HRESULT  hr;
    DWORD    dwCurrentStatus;
    DWORD    dwStatus = dwFlag;

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGSETUPSTATUS,
			&dwCurrentStatus);
    _PrintIfError2(
	    hr,
	    "myGetCertRegDWValue",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    // check to if there is existing status
    if (S_OK == hr || 0xFFFFFFFF == dwStatus)
    {
        // existing status, set according to dwFlag

        if (fSetBit)
        {
            // set corresponding bit
            dwStatus = dwCurrentStatus | dwStatus;
        }
        else
        {
            // unset corresponding
            dwStatus = dwCurrentStatus & ~dwStatus;
        }
    }
    else
    {
        // entry doesn't exist, if fSetBit, keep dwStatus=dwFlag
        if (!fSetBit)
        {
            // otherwise set all 0
            dwStatus = 0x0;
        }
    }
    hr = mySetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGSETUPSTATUS,
			dwStatus);
    _JumpIfError(hr, error, "mySetCertRegDWValue");

    DBGPRINT((DBG_SS_CERTLIBI, "SetSetupStatus(%ws, %x)\n", pwszSanitizedCAName, dwStatus));

error:
    return(hr);
}


HRESULT
myGetActiveManageModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OUT LPOLESTR *ppwszProgIdManageModule,           // CoTaskMem*
    OUT CLSID *pclsidManageModule)
{
    DWORD dw;
    PBYTE pb = NULL;
    DWORD dwType, cb = 0;

    LPWSTR pszTmp;
    DWORD cbClassName;
    LPOLESTR lpszProgID = NULL;
    LPWSTR szClassName = NULL;

    if (NULL != *ppwszProgIdManageModule)
    {
        CoTaskMemFree(*ppwszProgIdManageModule);
        *ppwszProgIdManageModule = NULL;
    }

    dw = myGetActiveModule(
		    pwszMachine,
		    pwszSanitizedCAName,
		    fPolicyModule,
		    Index,
		    &lpszProgID,
		    NULL);
    if (S_OK != dw)
        goto error;

    {
        // terminate class name at first '.'
        LPWSTR pAddTermination = wcschr(lpszProgID, L'.');

        if (NULL != pAddTermination)
	{
            pAddTermination[0] = L'\0';
	}
    }

    cbClassName = (wcslen(lpszProgID) + 1) * sizeof(WCHAR);
    cbClassName += (fPolicyModule) ? sizeof(wszCERTMANAGEPOLICY_POSTFIX) : sizeof(wszCERTMANAGEEXIT_POSTFIX);

    szClassName = (LPWSTR) CoTaskMemAlloc(cbClassName);
    if (NULL == szClassName)
        goto error;

    wcscpy(szClassName, lpszProgID);
    wcscat(szClassName, fPolicyModule? wszCERTMANAGEPOLICY_POSTFIX : wszCERTMANAGEEXIT_POSTFIX);

    // Now we have class module name, cvt to clsid
    dw = CLSIDFromProgID(szClassName, pclsidManageModule);
    if (S_OK != dw)
        goto error;   // clsid not found?

error:
    if (pb)
        LocalFree(pb);

    // intermediate ProgId
    if (lpszProgID)
        CoTaskMemFree(lpszProgID);

    *ppwszProgIdManageModule = szClassName;

    return dw;
}


HRESULT
myGetActiveModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OPTIONAL OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OPTIONAL OUT CLSID *pclsidModule)
{
    HRESULT hr;
    WCHAR *pwszzValue = NULL;
    WCHAR *pwsz;
    DWORD dwType;
    DWORD cb = 0;
    LPWSTR pwszModuleSubkey = NULL;
    DWORD chModule;
    
    chModule = wcslen(pwszSanitizedCAName) + 1 + 1; // (L'\\' + trailing L'\0');
    chModule += fPolicyModule?
	WSZARRAYSIZE(wszREGKEYPOLICYMODULES) :
	WSZARRAYSIZE(wszREGKEYEXITMODULES);

    pwszModuleSubkey = (LPWSTR) LocalAlloc(
				    LMEM_FIXED,
				    chModule * sizeof(WCHAR));
    if (NULL == pwszModuleSubkey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszModuleSubkey, pwszSanitizedCAName);
    wcscat(pwszModuleSubkey, L"\\");
    wcscat(
	pwszModuleSubkey,
	fPolicyModule? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES);

    // grab entry under CA with the active module ProgID
    hr = myGetCertRegValue(
		    pwszMachine,
		    pwszModuleSubkey,
		    NULL,
		    NULL,
		    wszREGACTIVE,
		    (BYTE **) &pwszzValue,
		    &cb,
		    &dwType);
    _JumpIfError(hr, error, "myGetCertRegValue");

    hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);

    // might or might not have an active entry
    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
	_JumpError(hr, error, "Bad active entry type");
    }
    if (0 == cb || NULL == pwszzValue)
    {
	_JumpError(hr, error, "No active entry");
    }
    if (0 != Index && (REG_SZ == dwType || fPolicyModule))
    {
	_JumpError(hr, error, "only one policy module or REG_SZ entry");
    }
    
    pwsz = pwszzValue;

    if (REG_MULTI_SZ == dwType)
    {
        // look for Index'th entry
        for ( ; 0 != Index; pwsz += wcslen(pwsz) + 1, Index--)
        {
	    if (L'\0' == *pwsz)
	    {
		_JumpError(hr, error, "No more active entries");
	    }
        }
    }

    // Verify nth entry exists
    if (L'\0' == *pwsz)
    {
	_JumpError(hr, error, "No active entries");
    }

    if (NULL != pclsidModule)
    {
        hr = CLSIDFromProgID(pwsz, pclsidModule);
        _JumpIfError(hr, error, "CLSIDFromProgID");
    }
    
    if (NULL != ppwszProgIdModule)
    {
        *ppwszProgIdModule = (LPOLESTR) CoTaskMemAlloc(
            (wcslen(pwsz) + 1) * sizeof(WCHAR));
        if (NULL == *ppwszProgIdModule)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "CoTaskMemAlloc");
        }
        wcscpy(*ppwszProgIdModule, pwsz);
    }
    hr = S_OK;      // not reset after ERROR_MOD_NOT_FOUND in all cases

error:
    if (NULL != pwszModuleSubkey)
    {
        LocalFree(pwszModuleSubkey);
    }
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


BOOL
IsPrefix(
    WCHAR const *pwszPrefix,
    WCHAR const *pwszString,
    DWORD cwcPrefix)
{
    return(
	0 == _wcsnicmp(pwszPrefix, pwszString, cwcPrefix) &&
	(L'\\' == pwszString[cwcPrefix] ||
	 L'\0' == pwszString[cwcPrefix]));
}


//+------------------------------------------------------------------------
//  Function:	myRegOpenRelativeKey
//
//  Synopsis:	Compute CA-relative, Policy-relative or Exit-relative registry
//		path, and retrieve the value, type, and parent registry key.
//
// IN params:
//
// pwszConfig is the config string of the CA:
//	if NULL, the local machine's first active CA is used.
//	if a server name (no \CAName is present), the specified machine's
//	first active CA is used.
//
// pwszRegName can specify any of the following the targets:
//	Passed String:			ValueName Relative Key Opened:
//	-------------			------------------------------
//      "ValueName"			Configuration key
//      "CA[\ValueName]"		CAName key
//      "policy[\ValueName]"		CAName\PolicyModules\<ActivePolicy>
//      "policy\ModuleProgId[\ValueName]" CAName\PolicyModules\ModuleProgId
//      "exit[\ValueName]"		CAName\ExitModules\<ActiveExit>
//      "exit\ModuleProgId[\ValueName]"	CAName\ExitModules\ModuleProgId
//      "Template[\ValueName]"		Template
//
//
// RORKF_FULLPATH specifies whether the path returned is relative from HKLM or
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration.
//
// RORKF_CREATESUBKEYS will allow subkeys to be created if necessary and the
// returned hkey opened for WRITE access
//
// On successful execution:
//
// *ppwszPath will contain a LocalAlloc'd registry path relative to
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration.
//
// *ppwszName will contain a LocalAlloc'd registry value name string relative to
// the returned parent key. If NULL, pwszRegName specifies a key, not a value.
//
// *phkey contains the opened reg key, if phkey non-NULL. Caller is responsible
// for freeing this key.
//-------------------------------------------------------------------------

HRESULT
myRegOpenRelativeKey(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszRegName,
    IN DWORD Flags,		// RORKF_*
    OUT WCHAR **ppwszPath,
    OUT OPTIONAL WCHAR **ppwszName,
    OUT OPTIONAL HKEY *phkey)
{
    HRESULT hr;
    WCHAR awc[MAX_PATH];
    WCHAR awc2[MAX_PATH];
    HKEY hkeyRoot = HKEY_LOCAL_MACHINE;
    HKEY hkeyConfig = NULL;
    HKEY hkeyMod = NULL;
    HKEY hkeyRequested = NULL;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwszModules = NULL;
    WCHAR const *pwszName;
    WCHAR const *pwsz;
    DWORD dwType;
    DWORD cb;
    DWORD cwc;
    DWORD i;
    BOOL fTemplateCache;
    DWORD dwDisposition;
    
    // Parameter checking
    
    if (NULL != phkey)
    {
        *phkey = NULL;
    }
    if (NULL != ppwszName)
    {
        *ppwszName = NULL;
    }
    if (NULL == ppwszPath)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "ppwszPath not optional");
    }
    *ppwszPath = NULL;
    
    fTemplateCache = IsPrefix(L"Template", pwszRegName, 8);
    if (fTemplateCache && (RORKF_USERKEY & Flags))
    {
	hkeyRoot = HKEY_CURRENT_USER;
    }

    // take care of remote machine access
    
    if (NULL != pwszConfig)
    {
        BOOL fLocal;
        
        hr = myIsConfigLocal(pwszConfig, &pwszMachine, &fLocal);
        _JumpIfError(hr, error, "myIsConfigLocal");
        
        if (!fLocal)
        {
            hr = RegConnectRegistry(pwszMachine, hkeyRoot, &hkeyRoot);
            _JumpIfError(hr, error, "RegConnectRegistry");
        }
    }
    
    if (!fTemplateCache)
    {
	hr = RegOpenKeyEx(
		    hkeyRoot,
		    wszREGKEYCONFIGPATH,
		    0,
		    (RORKF_CREATESUBKEYS & Flags)? KEY_ALL_ACCESS : KEY_READ,
		    &hkeyConfig);
	_JumpIfError(hr, error, "RegOpenKey(config)");
    }
    
    // value or key\value passed in under pwszRegName?

    pwsz = wcschr(pwszRegName, L'\\');
    if (NULL == pwsz &&
        !IsPrefix(L"CA", pwszRegName, 2) &&
        !IsPrefix(L"Policy", pwszRegName, 6) &&
        !IsPrefix(L"Exit", pwszRegName, 4) &&
        !IsPrefix(L"Restore", pwszRegName, 7) &&
	!fTemplateCache)
    {
        // Operate on registry value under the Configuration registry key
        
        pwszName = pwszRegName;
        
        // this is the final key we'll open
        
        hkeyRequested = hkeyConfig;
        hkeyConfig = NULL;
        awc[0] = L'\0';
    }
    else if (fTemplateCache)
    {
	pwszName = &pwszRegName[8];
	wcscpy(awc, wszCERTTYPECACHE);
    }
    else
    {
        //printf("RegName = '%ws'\n", pwszRegName);
        // load config of the active CA
        
	cb = sizeof(awc);
	hr = RegQueryValueEx(
			hkeyConfig,
			wszREGACTIVE,
			NULL,
			&dwType,
			(BYTE *) awc,
			&cb);
	_JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGACTIVE);
	
	if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpIfErrorStr(hr, error, "RegQueryValueEx TYPE", wszREGACTIVE);
	}
        
        //printf("Active CA = '%ws'\n", awc);
        
        // operate on key\value
        
        // first, subdivide into policymodules\exitmodules subkey
        
        if (IsPrefix(L"CA", pwszRegName, 2))
        {
            // Operate on registry value under the Active CA registry key
            
            pwszName = &pwszRegName[2];
        }
        else if (IsPrefix(L"Policy", pwszRegName, 6))
        {
            // Operate on registry value under a Policy Module registry key
            
            pwszModules = wszREGKEYPOLICYMODULES;
            pwszName = &pwszRegName[6];
        }
        else if (IsPrefix(L"Exit", pwszRegName, 4))
        {
            // Operate on registry value under an Exit Module registry key
            
            pwszModules = wszREGKEYEXITMODULES;
            pwszName = &pwszRegName[4];
        }
        else if (IsPrefix(L"Restore", pwszRegName, 7))
        {
            // Operate on registry value under Restore registry key
            
            pwszName = &pwszRegName[7];
            wcscpy(awc, wszREGKEYRESTOREINPROGRESS);
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "pwszRegName: no subkey description");
        }
        
        // expand module ProgId if necessary: get active ProgId
        
        if (NULL != pwszModules)	// if a policy or exit module
        {
            wcscat(awc, L"\\");
            wcscat(awc, pwszModules);
        }
        
        //printf("CA|restore|policy|exit key = '%ws'\n", awc);
        
        if (NULL != ppwszName)		// if a registry value expected
        {
            // Find active policy/exit module's ProgId
            hr = RegOpenKeyEx(
                hkeyConfig,
                awc,
                0,
                KEY_READ,
                &hkeyMod);
            _JumpIfErrorStr(hr, error, "RegOpenKey", awc);
            
            if (NULL != pwszModules)	// if a policy or exit module
            {
                cb = sizeof(awc2);
                hr = RegQueryValueEx(
                    hkeyMod,
                    wszREGACTIVE,
                    NULL,
                    &dwType,
                    (BYTE *) awc2,
                    &cb);
                _JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGACTIVE);
                
                if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    _JumpIfErrorStr(hr, error, "RegQueryValueEx Active Module", awc);
                }
                
                //printf("Active Module = '%ws'\n", awc2);
                
                wcscat(awc, L"\\");
                wcscat(awc, awc2);
            }
        }
        else	// else a registry key name is expected
        {
            // key\value: ProgId was passed in
            // concatenate key name (including the \\ prefix) onto end of awc
            
            if (NULL != pwsz)
            {
                CSASSERT(L'\\' == *pwsz);
                wcscat(awc, pwsz);
            }
        }
    } // end if (operate on key/value or value)

    if (NULL == hkeyRequested)
    {
        //printf("Creating key = '%ws'\n", awc);
        
        // open this key
        hr = RegCreateKeyEx(
		    NULL != hkeyConfig? hkeyConfig : hkeyRoot,
		    awc,
		    0,
		    NULL,
		    0,
		    (RORKF_CREATESUBKEYS & Flags)? KEY_ALL_ACCESS : KEY_READ,
		    NULL,
		    &hkeyRequested,
		    &dwDisposition);
	_JumpIfErrorStr(hr, error, "RegCreateKeyEx(parent)", awc);
        
    } // end if (operate on key/value or value)
    
    if (L'\\' == *pwszName)
    {
	pwszName++;
    }
    if (NULL != ppwszName && L'\0' != *pwszName)
    {
        // Look for case-ignore matching registry value name, & use the value's
        // correct upper/lower case spelling if an existing registry value:
        
        for (i = 0; ; i++)
        {
            cwc = ARRAYSIZE(awc2);
            hr = RegEnumValue(hkeyRequested, i, awc2, &cwc, NULL, NULL, NULL, NULL);
            if (S_OK != hr)
            {
                hr = S_OK;
                break;
            }
            if (0 == lstrcmpi(awc2, pwszName))
            {
                pwszName = awc2;
                break;
            }
        }
    }
    
    cb = (wcslen(awc) + 1) * sizeof(WCHAR);
    if (!fTemplateCache && (RORKF_FULLPATH & Flags))
    {
        cb += WSZARRAYSIZE(wszREGKEYCONFIGPATH_BS) * sizeof(WCHAR);
    }
    
    *ppwszPath = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszPath)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    (*ppwszPath)[0] = L'\0';
    if (!fTemplateCache && (RORKF_FULLPATH & Flags))
    {
	wcscpy(*ppwszPath, wszREGKEYCONFIGPATH_BS);
    }
    wcscat(*ppwszPath, awc);
    CSASSERT((wcslen(*ppwszPath) + 1) * sizeof(WCHAR) == cb);
    if (L'\0' == awc[0] && L'\\' == (*ppwszPath)[cb / sizeof(WCHAR) - 2])
    {
        (*ppwszPath)[cb / sizeof(WCHAR) - 2] = L'\0';
    }
    
    if (NULL != ppwszName)
    {
        *ppwszName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszName) + 1) * sizeof(WCHAR));
        if (NULL == *ppwszName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(*ppwszName, pwszName);
    }
    if (NULL != phkey)
    {
        *phkey = hkeyRequested;
        hkeyRequested = NULL;
    }
    
    //printf("key path = '%ws'\n", *ppwszPath);
    //if (NULL != ppwszName) printf("value name = '%ws'\n", *ppwszName);
    
error:
    if (HKEY_LOCAL_MACHINE != hkeyRoot && HKEY_CURRENT_USER != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    if (NULL != hkeyConfig)
    {
        RegCloseKey(hkeyConfig);
    }
    if (NULL != hkeyMod)
    {
        RegCloseKey(hkeyMod);
    }
    if (NULL != hkeyRequested)
    {
        RegCloseKey(hkeyRequested);
    }
    if (NULL != pwszMachine)
    {
        LocalFree(pwszMachine);
    }
    if (S_OK != hr)
    {
        if (NULL != ppwszPath && NULL != *ppwszPath)
        {
            LocalFree(*ppwszPath);
            *ppwszPath = NULL;
        }
        if (NULL != ppwszName && NULL != *ppwszName)
        {
            LocalFree(*ppwszName);
            *ppwszName = NULL;
        }
    }
    return(myHError(hr));
}


#define wszTEMPLATE wszFCSAPARM_SERVERDNSNAME L"_" wszFCSAPARM_SANITIZEDCANAME
#define cwcTEMPLATE WSZARRAYSIZE(wszTEMPLATE)

HRESULT
mySetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszFileName)
{
    HRESULT hr;
    WCHAR *pwszMatch = NULL;
    WCHAR *pwszMatchIn;
    WCHAR const *pwszBase;
    WCHAR const *pwszExt;
    DWORD cwcPath;
    DWORD cwcBase;
    DWORD cwcMatch;
    DWORD cwcT;
    WCHAR *pwszT = NULL;
    WCHAR *pwszT2;

    pwszBase = wcsrchr(pwszFileName, L'\\');
    if (NULL == pwszBase)
    {
	hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
	_JumpErrorStr(hr, error, "bad path", pwszFileName);
    }
    pwszBase++;
    cwcPath = SAFE_SUBTRACT_POINTERS(pwszBase, pwszFileName);
    pwszExt = wcsrchr(pwszBase, L'.');
    if (NULL == pwszExt)
    {
	pwszExt = &pwszBase[wcslen(pwszBase)];
    }
    cwcBase = SAFE_SUBTRACT_POINTERS(pwszExt, pwszBase);

    do
    {
	cwcMatch = wcslen(pwszServerName) + 1 + wcslen(pwszSanitizedName);
	if (cwcBase != cwcMatch)
	{
	    break;
	}

	// Allocate space for both strings at once:

	pwszMatch = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    2 * (cwcMatch + 1) * sizeof(WCHAR));
	if (NULL == pwszMatch)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszMatch, pwszServerName);
	wcscat(pwszMatch, L"_");
	wcscat(pwszMatch, pwszSanitizedName);

	pwszMatchIn = &pwszMatch[cwcMatch + 1];
	CopyMemory(pwszMatchIn, pwszBase, cwcMatch * sizeof(WCHAR));
	pwszMatchIn[cwcMatch] = L'\0';

	if (0 == lstrcmpi(pwszMatch, pwszMatchIn))
	{
	    pwszBase = wszTEMPLATE;
	    cwcBase = cwcTEMPLATE;
	}
    } while (FALSE);

    cwcT = cwcPath +
		cwcBase +
		WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX) +
		wcslen(pwszExt);

    pwszT = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (cwcT + 1) * sizeof(WCHAR));
    if (NULL == pwszT)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwszT2 = pwszT;

    CopyMemory(pwszT2, pwszFileName, cwcPath * sizeof(WCHAR));
    pwszT2 += cwcPath;

    CopyMemory(pwszT2, pwszBase, cwcBase * sizeof(WCHAR));
    pwszT2 += cwcBase;

    wcscpy(pwszT2, wszFCSAPARM_CERTFILENAMESUFFIX);
    wcscat(pwszT2, pwszExt);

    hr = mySetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegValueName,
			pwszT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszRegValueName);

error:
    if (NULL != pwszMatch)
    {
	LocalFree(pwszMatch);
    }
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    return(hr);
}


HRESULT
myGetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    OUT WCHAR **ppwszFileName)
{
    HRESULT hr;
    WCHAR *pwszT = NULL;

    *ppwszFileName = NULL;

    hr = myGetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegValueName,
			&pwszT);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegStrValue",
		pwszRegValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = myFormatCertsrvStringArray(
			    FALSE,		// fURL
			    pwszServerName,	// pwszServerName_p1_2
			    pwszSanitizedName,	// pwszSanitizedName_p3_7
			    iCert,		// iCert_p4
			    L"",		// pwszDomainDN_p5
			    L"", 		// pwszConfigDN_p6
			    iCRL,		// iCRL_p8
			    FALSE,		// fDeltaCRL_p9
			    FALSE,		// fDSAttrib_p10_11
			    1,			// cStrings
			    (LPCWSTR *) &pwszT,	// apwszStringsIn
			    ppwszFileName);	// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\tfcprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfcprop.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#include "tfcprop.h"

extern HINSTANCE g_hInstance;

PropertyPage::PropertyPage(UINT uIDD)
{
    m_hWnd = NULL;

    ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));
    m_psp.dwSize = sizeof(PROPSHEETPAGE);
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.hInstance = g_hInstance;
    m_psp.pszTemplate = MAKEINTRESOURCE(uIDD);

    m_psp.pfnDlgProc = dlgProcPropPage;
    m_psp.lParam = (LPARAM)this;
}

PropertyPage::~PropertyPage()
{
}

BOOL PropertyPage::OnCommand(WPARAM, LPARAM)
{
    return TRUE;
}

BOOL PropertyPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    return FALSE;
}

BOOL PropertyPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    return TRUE;
}

BOOL PropertyPage::OnSetActive()
{
    return TRUE;
}

BOOL PropertyPage::OnKillActive()
{
    return TRUE;
}

BOOL PropertyPage::OnInitDialog()
{
    UpdateData(FALSE);  // push to dlg
    return TRUE;
}

void PropertyPage::OnDestroy()
{
    return;
}


BOOL PropertyPage::OnApply()
{
    SetModified(FALSE);
    return TRUE;
}

void PropertyPage::OnCancel()
{
    return;
}

void PropertyPage::OnOK()
{
    return;
}

BOOL PropertyPage::OnWizardFinish()
{
    return TRUE;
}

LRESULT PropertyPage::OnWizardNext()
{
    return 0;
}

LRESULT PropertyPage::OnWizardBack()
{
    return 0;
}

void PropertyPage::OnHelp(LPHELPINFO lpHelp)
{
    return;
}

void PropertyPage::OnContextHelp(HWND hwnd)
{
    return;
}



INT_PTR CALLBACK
dlgProcPropPage(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    HRESULT hr;
    PropertyPage* pPage = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
    {
        // save off PropertyPage*
        ASSERT(lParam);
        pPage = (PropertyPage*) ((PROPSHEETPAGE*)lParam)->lParam;
        ASSERT(pPage);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)pPage);


        // pass notification through
        pPage->m_hWnd = hwndDlg;           // save our hwnd
        return pPage->OnInitDialog();      // call virtual fxn
    }
    case WM_DESTROY:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;
        pPage->OnDestroy();
        break;
    }
    case WM_NOTIFY:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;

        LRESULT lr;

        // catch special commands, drop other notifications
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_SETACTIVE:
            lr = (pPage->OnSetActive() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);       // bool
            break;
    	case PSN_KILLACTIVE:
            lr = (pPage->OnKillActive() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);      // bool
            break;
        case PSN_APPLY:
            pPage->UpdateData(TRUE);  // take from dlg
            lr = (pPage->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);           // bool
            break;
        case PSN_WIZFINISH:
            pPage->UpdateData(TRUE);  // take from dlg
            lr = (pPage->OnWizardFinish() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);    // bool
            break;
        case PSN_WIZBACK:
            pPage->UpdateData(TRUE);  // take from dlg
            lr = pPage->OnWizardBack();
            break;
        case PSN_WIZNEXT:
        {
            pPage->UpdateData(TRUE);  // take from dlg
            lr = pPage->OnWizardNext();
            break;
        }
        default:
            return pPage->OnNotify((int)wParam, (NMHDR*)lParam);
        }

        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, lr);
        return TRUE;
    }
    case WM_COMMAND:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;

        // catch special commands, pass others through
        switch(LOWORD(wParam))
        {
        case IDOK:
            pPage->OnOK();
//            EndDialog(hwndDlg, 0);
            return 0;
        case IDCANCEL:
            pPage->OnCancel();
//            EndDialog(hwndDlg, 1);
            return 0;
        default:
            return pPage->OnCommand(wParam, lParam);
        }
    }
    case WM_HELP:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;
        pPage->OnHelp((LPHELPINFO) lParam);
        break;
    }
    case WM_CONTEXTMENU:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;
        pPage->OnContextHelp((HWND)wParam);
        break;
    }
    default:

        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\view.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       view.cpp
//
//  Contents:   ICertView IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// ICertView dispatch support

//WCHAR wszRegKeyViewClsid[] = wszCLASS_CERTVIEW TEXT("\\Clsid");

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszOpenConnection[] = {
    TEXT("OpenConnection"),
    TEXT("strConfig"),
};

//+------------------------------------
// EnumCertViewColumn method:

static OLECHAR *_apszEnumCertViewColumn[] = {
    TEXT("EnumCertViewColumn"),
    TEXT("fResultColumn"),
};

//+------------------------------------
// GetColumnCount method:

static OLECHAR *_apszGetColumnCount[] = {
    TEXT("GetColumnCount"),
    TEXT("fResultColumn"),
};

//+------------------------------------
// GetColumnIndex method:

static OLECHAR *_apszGetColumnIndex[] = {
    TEXT("GetColumnIndex"),
    TEXT("fResultColumn"),
    TEXT("strColumnName"),
};

//+------------------------------------
// SetResultColumnCount method:

static OLECHAR *_apszSetResultColumnCount[] = {
    TEXT("SetResultColumnCount"),
    TEXT("cResultColumn"),
};

//+------------------------------------
// SetResultColumn method:

static OLECHAR *_apszSetResultColumn[] = {
    TEXT("SetResultColumn"),
    TEXT("ColumnIndex"),
};

//+------------------------------------
// SetRestriction method:

static OLECHAR *_apszSetRestriction[] = {
    TEXT("SetRestriction"),
    TEXT("ColumnIndex"),
    TEXT("SeekOperator"),
    TEXT("SortOrder"),
    TEXT("pvarValue"),
};

//+------------------------------------
// OpenView method:

static OLECHAR *_apszOpenView[] = {
    TEXT("OpenView"),
};

//+------------------------------------
// SetTable method:

static OLECHAR *_apszSetTable[] = {
    TEXT("SetTable"),
    TEXT("Table"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtView[] =
{
#define VIEW_OPENCONNECTION		0
    DECLARE_DISPATCH_ENTRY(_apszOpenConnection)

#define VIEW_ENUMCERTVIEWCOLUMN		1
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewColumn)

#define VIEW_GETCOLUMNCOUNT		2
    DECLARE_DISPATCH_ENTRY(_apszGetColumnCount)

#define VIEW_GETCOLUMNINDEX		3
    DECLARE_DISPATCH_ENTRY(_apszGetColumnIndex)

#define VIEW_SETRESULTCOLUMNCOUNT	4
    DECLARE_DISPATCH_ENTRY(_apszSetResultColumnCount)

#define VIEW_SETRESULTCOLUMN		5
    DECLARE_DISPATCH_ENTRY(_apszSetResultColumn)

#define VIEW_SETRESTRICTION		6
    DECLARE_DISPATCH_ENTRY(_apszSetRestriction)

#define VIEW_OPENVIEW			7
    DECLARE_DISPATCH_ENTRY(_apszOpenView)

#define VIEW2_SETTABLE			8
    DECLARE_DISPATCH_ENTRY(_apszSetTable)
};
#define CVIEWDISPATCH		(ARRAYSIZE(s_adtView))
#define CVIEWDISPATCH_V1	VIEW2_SETTABLE
#define CVIEWDISPATCH_V2	CVIEWDISPATCH


DWORD s_acViewDispatch[] = {
    CVIEWDISPATCH_V2,
    CVIEWDISPATCH_V1,
};

IID const *s_apViewiid[] = {
    &IID_ICertView2,
    &IID_ICertView,
};


HRESULT
View_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiView)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTVIEW,
		&CLSID_CCertView,
		ARRAYSIZE(s_acViewDispatch),		// cver
		s_apViewiid,
		s_acViewDispatch,
		s_adtView,
		pdiView);
    _JumpIfError(hr, error, "DispatchSetup2(ICertView)");

error:
    return(hr);
}


VOID
View_Release(
    IN OUT DISPATCHINTERFACE *pdiView)
{
    DispatchRelease(pdiView);
}


HRESULT
ViewVerifyVersion(
    IN DISPATCHINTERFACE *pdiView,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    switch (pdiView->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiView->pDispatch ||
		CVIEWDISPATCH_V1 == pdiView->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiView->pDispatch ||
		CVIEWDISPATCH_V2 == pdiView->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiView->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
View_OpenConnection(
    IN DISPATCHINTERFACE *pdiView,
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiView,
			VIEW_OPENCONNECTION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(OpenConnection)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->OpenConnection(strConfig);
	_JumpIfError(hr, error, "OpenConnection");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
View_GetColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    OUT LONG *pcColumn)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = fResultColumn;

	hr = DispatchInvoke(
			pdiView,
			VIEW_GETCOLUMNCOUNT,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pcColumn);
	_JumpIfError(hr, error, "Invoke(GetColumnCount)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->GetColumnCount(
							fResultColumn,
							pcColumn);
	_JumpIfError(hr, error, "GetColumnCount");
    }

error:
    return(hr);
}


HRESULT
View_GetColumnIndex(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    IN WCHAR const *pwszColumnName,
    OUT LONG *pColumnIndex)
{
    HRESULT hr;
    BSTR strColumnName = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (!ConvertWszToBstr(&strColumnName, pwszColumnName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = fResultColumn;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strColumnName;

	hr = DispatchInvoke(
			pdiView,
			VIEW_GETCOLUMNINDEX,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pColumnIndex);
	_JumpIfError(hr, error, "Invoke(GetColumnIndex)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->GetColumnIndex(
							fResultColumn,
							strColumnName,
							pColumnIndex);
	_JumpIfError(hr, error, "GetColumnIndex");
    }

error:
    if (NULL != strColumnName)
    {
	SysFreeString(strColumnName);
    }
    return(hr);
}


HRESULT
View_SetResultColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG cResultColumn)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = cResultColumn;

	hr = DispatchInvoke(
			pdiView,
			VIEW_SETRESULTCOLUMNCOUNT,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetResultColumnCount)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->SetResultColumnCount(cResultColumn);
	_JumpIfError(hr, error, "SetResultColumnCount");
    }

error:
    return(hr);
}


HRESULT
View_SetResultColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = ColumnIndex;

	hr = DispatchInvoke(
			pdiView,
			VIEW_SETRESULTCOLUMN,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetResultColumn)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->SetResultColumn(ColumnIndex);
	_JumpIfError(hr, error, "SetResultColumn");
    }

error:
    return(hr);
}


HRESULT
View_SetRestriction(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex,
    IN LONG SeekOperator,
    IN LONG SortOrder,
    IN VARIANT const *pvarValue)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_I4;
	avar[0].lVal = ColumnIndex;

	avar[1].vt = VT_I4;
	avar[1].lVal = SeekOperator;

	avar[2].vt = VT_I4;
	avar[2].lVal = SortOrder;

	avar[3] = *pvarValue;

	hr = DispatchInvoke(
			pdiView,
			VIEW_SETRESTRICTION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetRestriction)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->SetRestriction(
							ColumnIndex,
							SeekOperator,
							SortOrder,
							pvarValue);
	_JumpIfError(hr, error, "SetRestriction");
    }

error:
    return(hr);
}


HRESULT
View_OpenView(
    IN DISPATCHINTERFACE *pdiView,
    OUT DISPATCHINTERFACE *pdiViewRow)
{
    HRESULT hr;
    IEnumCERTVIEWROW *pEnumRow = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	hr = DispatchInvoke(
			pdiView,
			VIEW_OPENVIEW,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumRow);
	_JumpIfError(hr, error, "Invoke(OpenView)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->OpenView(&pEnumRow);
	_JumpIfError(hr, error, "OpenView");
    }
    hr = ViewRow_Init2(NULL != pdiView->pDispatch, pEnumRow, pdiViewRow);
    _JumpIfError(hr, error, "ViewRow_Init2");

error:
    if (NULL != pEnumRow)
    {
	pEnumRow->Release();
    }
    return(hr);
}


HRESULT
View2_SetTable(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG Table)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    hr = ViewVerifyVersion(pdiView, 2);
    _JumpIfError(hr, error, "ViewVerifyVersion");

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Table;

	hr = DispatchInvoke(
			pdiView,
			VIEW2_SETTABLE,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetTable)");
    }
    else
    {
	hr = ((ICertView2 *) pdiView->pUnknown)->SetTable(Table);
	_JumpIfError(hr, error, "SetTable");
    }

error:
    return(hr);
}


HRESULT
View_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    OUT DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pEnumColumn = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = fResultColumn;

	hr = DispatchInvoke(
			pdiView,
			VIEW_ENUMCERTVIEWCOLUMN,
			ARRAYSIZE(avar),
			avar,
			VT_DISPATCH,
			&pEnumColumn);
	_JumpIfError(hr, error, "Invoke(EnumCertViewColumn)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->EnumCertViewColumn(
								 fResultColumn,
								 &pEnumColumn);
	_JumpIfError(hr, error, "EnumCertViewColumn");
    }
    hr = ViewColumn_Init2(
		    NULL != pdiView->pDispatch,
		    pEnumColumn,
		    pdiViewColumn);
    _JumpIfError(hr, error, "ViewColumn_Init2");

error:
    if (NULL != pEnumColumn)
    {
	pEnumColumn->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\request.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       request.cpp
//
//  Contents:   ICertRequest IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"


//+------------------------------------------------------------------------
// ICertRequest dispatch support

//TCHAR szRegKeyRequestClsid[] = wszCLASS_CERTREQUEST TEXT("\\Clsid");

//+------------------------------------
// Submit method:

static OLECHAR *_apszSubmit[] = {
    TEXT("Submit"),
    TEXT("Flags"),
    TEXT("strRequest"),
    TEXT("strAttributes"),
    TEXT("strConfig"),
};

//+------------------------------------
// RetrievePending method:

static OLECHAR *_apszRetrievePending[] = {
    TEXT("RetrievePending"),
    TEXT("RequestId"),
    TEXT("strConfig"),
};

//+------------------------------------
// GetLastStatus method:

static OLECHAR *_apszGetLastStatus[] = {
    TEXT("GetLastStatus"),
};

//+------------------------------------
// GetRequestId method:

static OLECHAR *_apszGetRequestId[] = {
    TEXT("GetRequestId"),
};

//+------------------------------------
// GetDispositionMessage method:

static OLECHAR *_apszGetDispositionMessage[] = {
    TEXT("GetDispositionMessage"),
};

//+------------------------------------
// GetCACertificate method:

static OLECHAR *_apszGetCACertificate[] = {
    TEXT("GetCACertificate"),
    TEXT("fExchangeCertificate"),
    TEXT("strConfig"),
    TEXT("Flags"),
};

//+------------------------------------
// GetCertificate method:

static OLECHAR *_apszGetCertificate[] = {
    TEXT("GetCertificate"),
    TEXT("Flags"),
};

//+------------------------------------
// GetIssuedCertificate method:

static OLECHAR *_apszGetIssuedCertificate[] = {
    TEXT("GetIssuedCertificate"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strSerialNumber"),
};

//+------------------------------------
// GetErrorMessageText method:

static OLECHAR *_apszGetErrorMessageText[] = {
    TEXT("GetErrorMessageText"),
    TEXT("hrMessage"),
    TEXT("Flags"),
};

//+------------------------------------
// GetCAProperty method:

static OLECHAR *_apszGetCAProperty[] = {
    TEXT("GetCAProperty"),
    TEXT("strConfig"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("Flags"),
};

//+------------------------------------
// GetCAPropertyFlags method:

static OLECHAR *_apszGetCAPropertyFlags[] = {
    TEXT("GetCAPropertyFlags"),
    TEXT("strConfig"),
    TEXT("PropId"),
};

//+------------------------------------
// GetCAPropertyDisplayName method:

static OLECHAR *_apszGetCAPropertyDisplayName[] = {
    TEXT("GetCAPropertyDisplayName"),
    TEXT("strConfig"),
    TEXT("PropId"),
};


//+------------------------------------
// GetFullResponseProperty method:

static OLECHAR *_apszGetFullResponseProperty[] = {
    TEXT("GetFullResponseProperty"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("Flags"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtRequest[] =
{
#define REQUEST_SUBMIT				0
    DECLARE_DISPATCH_ENTRY(_apszSubmit)

#define REQUEST_RETRIEVEPENDING			1
    DECLARE_DISPATCH_ENTRY(_apszRetrievePending)

#define REQUEST_GETLASTSTATUS			2
    DECLARE_DISPATCH_ENTRY(_apszGetLastStatus)

#define REQUEST_GETREQUESTID			3
    DECLARE_DISPATCH_ENTRY(_apszGetRequestId)

#define REQUEST_GETDISPOSITIONMESSAGE		4
    DECLARE_DISPATCH_ENTRY(_apszGetDispositionMessage)

#define REQUEST_GETCACERTIFICATE		5
    DECLARE_DISPATCH_ENTRY(_apszGetCACertificate)

#define REQUEST_GETCERTIFICATE			6
    DECLARE_DISPATCH_ENTRY(_apszGetCertificate)

#define REQUEST2_GETISSUEDCERTIFICATE		7
    DECLARE_DISPATCH_ENTRY(_apszGetIssuedCertificate)

#define REQUEST2_GETERRORMESSAGETEXT		8
    DECLARE_DISPATCH_ENTRY(_apszGetErrorMessageText)

#define REQUEST2_GETCAPROPERTY 			9
    DECLARE_DISPATCH_ENTRY(_apszGetCAProperty)

#define REQUEST2_GETCAPROPERTYFLAGS 		10
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyFlags)

#define REQUEST2_GETCAPROPERTYDISPLAYNAME	11
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyDisplayName)

#define REQUEST2_GETFULLRESPONSEPROPERTY	12
    DECLARE_DISPATCH_ENTRY(_apszGetFullResponseProperty)
};
#define CREQUESTDISPATCH	(ARRAYSIZE(s_adtRequest))
#define CREQUESTDISPATCH_V1	REQUEST2_GETISSUEDCERTIFICATE
#define CREQUESTDISPATCH_V2	CREQUESTDISPATCH


DWORD s_acRequestDispatch[] = {
    CREQUESTDISPATCH_V2,
    CREQUESTDISPATCH_V1,
};

IID const *s_apRequestiid[] = {
    &IID_ICertRequest2,
    &IID_ICertRequest,
};


HRESULT
Request_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiRequest)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTREQUEST,
		&CLSID_CCertRequest,
		ARRAYSIZE(s_acRequestDispatch),		// cver
		s_apRequestiid,
		s_acRequestDispatch,
		s_adtRequest,
		pdiRequest);
    _JumpIfError(hr, error, "DispatchSetup2(ICertRequest)");

error:
    return(hr);
}


VOID
Request_Release(
    IN OUT DISPATCHINTERFACE *pdiRequest)
{
    DispatchRelease(pdiRequest);
}


HRESULT
RequestVerifyVersion(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    switch (pdiRequest->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiRequest->pDispatch ||
		CREQUESTDISPATCH_V1 == pdiRequest->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiRequest->pDispatch ||
		CREQUESTDISPATCH_V2 == pdiRequest->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiRequest->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Request_Submit(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG Flags,
    IN WCHAR const *pwszRequest,
    IN DWORD cbRequest,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strRequest = NULL;
    BSTR strAttributes = NULL;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL == pwszRequest || NULL == pwszConfig)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "NULL parm");
    }
    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strRequest, pwszRequest, cbRequest))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strAttributes, pwszAttributes, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strRequest;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strAttributes;

	avar[3].vt = VT_BSTR;
	avar[3].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_SUBMIT,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(Submit)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->Submit(
							Flags,
							strRequest,
							strAttributes,
							strConfig,
							pDisposition);
	_JumpIfError2(
		hr,
		error,
		"ICertRequest::Submit",
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }

error:
    if (NULL != strRequest)
    {
	SysFreeString(strRequest);
    }
    if (NULL != strAttributes)
    {
	SysFreeString(strAttributes);
    }
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Request_RetrievePending(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG RequestId,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = RequestId;

	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_RETRIEVEPENDING,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(RetrievePending)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->RetrievePending(
							RequestId,
							strConfig,
							pDisposition);
	_JumpIfError(hr, error, "ICertRequest::RetrievePending");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Request_GetLastStatus(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pLastStatus)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETLASTSTATUS,
			0,
			NULL,
			VT_I4,
			pLastStatus);
	_JumpIfError(hr, error, "Invoke(GetLastStatus)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetLastStatus(
							pLastStatus);
	_JumpIfError(hr, error, "ICertRequest::GetLastStatus");
    }

error:
    return(hr);
}


HRESULT
Request_GetRequestId(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pRequestId)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETREQUESTID,
			0,
			NULL,
			VT_I4,
			pRequestId);
	_JumpIfError(hr, error, "Invoke(GetRequestId)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetRequestId(pRequestId);
	_JumpIfError(hr, error, "ICertRequest::GetRequestId");
    }

error:
    return(hr);
}


HRESULT
Request_GetDispositionMessage(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT BSTR *pstrMessage)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETDISPOSITIONMESSAGE,
			0,
			NULL,
			VT_BSTR,
			pstrMessage);
	_JumpIfError(hr, error, "Invoke(GetDispositionMessage)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetDispositionMessage(
							pstrMessage);
	_JumpIfError(hr, error, "ICertRequest::GetDispositionMessage");
    }

error:
    return(hr);
}


HRESULT
Request_GetCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD Flags,
    OUT BSTR *pstrCert)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrCert);
	_JumpIfError(hr, error, "Invoke(GetCertificate)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetCertificate(
							Flags,
							pstrCert);
	_JumpIfError(hr, error, "ICertRequest::GetCertificate");
    }

error:
    return(hr);
}


HRESULT
Request_GetCACertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG fExchangeCertificate,
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_I4;
	avar[0].lVal = fExchangeCertificate;

	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strConfig;

	avar[2].vt = VT_I4;
	avar[2].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETCACERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrCert);
	_JumpIfError(hr, error, "Invoke(GetCACertificate)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetCACertificate(
							fExchangeCertificate,
							strConfig,
							Flags,
							pstrCert);
	_JumpIfError2(
		    hr,
		    error,
		    "ICertRequest::GetCACertificate",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Request2_GetIssuedCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    hr = RequestVerifyVersion(pdiRequest, 2);
    _JumpIfError(hr, error, "RequestVerifyVersion");

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pwszSerialNumber &&
	!ConvertWszToBstr(&strSerialNumber, pwszSerialNumber, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strSerialNumber;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST2_GETISSUEDCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(GetIssuedCertificate)");
    }
    else
    {
	hr = ((ICertRequest2 *) pdiRequest->pUnknown)->GetIssuedCertificate(
							strConfig,
							RequestId,
							strSerialNumber,
							pDisposition);
	_JumpIfError(hr, error, "ICertRequest2::GetIssuedCertificate");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
Request2_GetErrorMessageText(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG hrMessage,
    IN LONG Flags,
    OUT BSTR *pstrErrorMessageText)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    hr = RequestVerifyVersion(pdiRequest, 2);
    _JumpIfError(hr, error, "RequestVerifyVersion");

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = hrMessage;

	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST2_GETERRORMESSAGETEXT,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrErrorMessageText);
	_JumpIfError(hr, error, "Invoke(GetErrorMessageText)");
    }
    else
    {
	hr = ((ICertRequest2 *) pdiRequest->pUnknown)->GetErrorMessageText(
							hrMessage,
							Flags,
							pstrErrorMessageText);
	_JumpIfError(hr, error, "ICertRequest2::GetErrorMessageText");
    }

error:
    return(hr);
}


HRESULT
Request2_GetFullResponseProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,		// CR_OUT_*
    OUT VOID *pPropertyValue)
{
    HRESULT hr;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    switch (PropType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropType");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_I4;
	avar[0].lVal = PropId;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropIndex;

	avar[2].vt = VT_I4;
	avar[2].lVal = PropType;

	avar[3].vt = VT_I4;
	avar[3].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST2_GETFULLRESPONSEPROPERTY,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pPropertyValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"GetFullResponseProperty: PropId=%x Index=%x Type=%x Flags=%x\n",
		PropId,
		PropIndex,
		PropType,
		Flags));
	}
	_JumpIfError2(
		    hr,
		    error,
		    "GetFullResponseProperty",
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = ((ICertRequest2 *) pdiRequest->pUnknown)->GetFullResponseProperty(
						    PropId,
						    PropIndex,
						    PropType,
						    Flags,
						    &varResult);
	_JumpIfError2(
		    hr,
		    error,
		    "ICertRequest2::GetFullResponseProperty",
		    CERTSRV_E_PROPERTY_EMPTY);

	hr = DispatchGetReturnValue(&varResult, RetType, pPropertyValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    return(hr);
}


#define CCERTREQUEST
#include "prop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\viewattr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewattr.cpp
//
//  Contents:   IEnumCERTVIEWATTRIBUTE IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// IEnumCERTVIEWATTRIBUTE dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetName method:

static OLECHAR *_apszGetName[] = {
    TEXT("GetName"),
};

//+------------------------------------
// GetValue method:

static OLECHAR *_apszGetValue[] = {
    TEXT("GetValue"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewAttribute[] =
{
#define VIEWATTR_NEXT		0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWATTR_GETNAME	1
    DECLARE_DISPATCH_ENTRY(_apszGetName)

#define VIEWATTR_GETVALUE	2
    DECLARE_DISPATCH_ENTRY(_apszGetValue)

#define VIEWATTR_SKIP		3
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWATTR_RESET		4
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWATTR_CLONE		5
    DECLARE_DISPATCH_ENTRY(_apszClone)
};
#define CVIEWATTRDISPATCH	(ARRAYSIZE(g_adtViewAttribute))


HRESULT
ViewAttribute_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWATTRIBUTE *pEnumAttribute,
    OUT DISPATCHINTERFACE *pdiViewAttribute)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;
    static BOOL s_fInitialized = FALSE;

    pdiViewAttribute->pDispatchTable = NULL;
    pdiViewAttribute->pDispatch = NULL;
    pdiViewAttribute->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumAttribute->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWATTRDISPATCH,
			g_adtViewAttribute,
			pdiViewAttribute);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewAttribute->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumAttribute->AddRef();
	pdiViewAttribute->pUnknown = (IUnknown *) pEnumAttribute;
	hr = S_OK;
    }
    pdiViewAttribute->pDispatchTable = g_adtViewAttribute;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ViewAttribute_Release(
    IN OUT DISPATCHINTERFACE *pdiViewAttribute)
{
    DispatchRelease(pdiViewAttribute);
}


HRESULT
ViewAttribute_Next(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_GetName(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_GETNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->GetName(pstrOut);
	_JumpIfError(hr, error, "GetName");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_GetValue(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_GETVALUE,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetValue)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->GetValue(
								    pstrOut);
	_JumpIfError(hr, error, "GetValue");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_Skip(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_Reset(
    IN DISPATCHINTERFACE *pdiViewAttribute)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_Clone(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT DISPATCHINTERFACE *pdiViewAttributeClone)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *pEnumAttribute = NULL;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumAttribute);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Clone(
							    &pEnumAttribute);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewAttribute_Init2(
		    NULL != pdiViewAttribute->pDispatch,
		    pEnumAttribute,
		    pdiViewAttributeClone);
    _JumpIfError(hr, error, "ViewAttribute_Init2");

error:
    if (NULL != pEnumAttribute)
    {
	pEnumAttribute->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\string.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        string.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define __dwFILE__	__dwFILE_CERTLIB_STRING_CPP__


extern HINSTANCE g_hInstance;

DWORD g_cStringAlloc;
DWORD g_cStringUsed;

typedef struct _RESOURCESTRING
{
    DWORD	 id;
    WCHAR const *pwsz;
} RESOURCESTRING;


#define CRS_CHUNK		100

RESOURCESTRING *g_rgrs = NULL;
DWORD g_crsMax = 0;
DWORD g_crs = 0;


RESOURCESTRING *
AllocStringHeader()
{
    if (g_crs >= g_crsMax)
    {
	DWORD cb = (CRS_CHUNK + g_crsMax) * sizeof(g_rgrs[0]);
	RESOURCESTRING *rgrsT;

	if (NULL == g_rgrs)
	{
	    rgrsT = (RESOURCESTRING *) LocalAlloc(LMEM_FIXED, cb);
	}
	else
	{
	    rgrsT = (RESOURCESTRING *) LocalReAlloc(g_rgrs, cb, LMEM_MOVEABLE);
	}
	if (NULL == rgrsT)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Error allocating resource string header\n"));
	    return(NULL);
	}
	g_rgrs = rgrsT;
	g_crsMax += CRS_CHUNK;
    }
    return(&g_rgrs[g_crs++]);
}


#define cwcRESOURCEMIN	128
#define cwcRESOURCEMAX	8192

WCHAR const *
myLoadResourceString(
    IN DWORD ResourceId)
{
    HRESULT hr;
    DWORD i;
    WCHAR awc[cwcRESOURCEMIN];
    WCHAR *pwsz = NULL;
    DWORD cwc;
    WCHAR const *pwszString = NULL;
    WCHAR *pwszAlloc;

    for (i = 0; i < g_crs; i++)
    {
	if (g_rgrs[i].id == ResourceId)
	{
	    pwszString = g_rgrs[i].pwsz;
	}
    }
    if (NULL == pwszString)
    {
	RESOURCESTRING *prs;

	pwsz = awc;
	cwc = ARRAYSIZE(awc);

	while (TRUE)
	{
	    if (!LoadString(g_hInstance, ResourceId, pwsz, cwc))
	    {
		hr = myHLastError();
		DBGPRINT((
		    DBG_SS_CERTLIB,
		    "LoadString(%d) -> %x\n",
		    ResourceId,
		    hr));
		_JumpError(hr, error, "LoadString");
	    }
#if 0
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"myLoadResourceString(%d) %x/%x\n",
		ResourceId,
		wcslen(pwsz),
		cwc));
#endif

	    // if there's any room left, the resource was not truncated.
	    // if the buffer is already at the maximum size we support, we just
	    // live with the truncation.

	    if (wcslen(pwsz) < cwc - 1 || cwcRESOURCEMAX <= cwc)
	    {
		break;
	    }

	    // LoadString filled the buffer completely, so the string may have
	    // been truncated.  Double the buffer size and try again.

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"myLoadResourceString(%d) %x/%x ==> %x\n",
		ResourceId,
		wcslen(pwsz),
		cwc,
		cwc << 1));
	    if (pwsz != awc)
	    {
		LocalFree(pwsz);
		pwsz = NULL;
	    }
	    cwc <<= 1;
	    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	    if (NULL == pwsz)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = myDupString(pwsz, &pwszAlloc);
	_JumpIfError(hr, error, "myDupString");

	prs = AllocStringHeader();
	if (NULL != prs)
	{
	    prs->id = ResourceId;
	    prs->pwsz = pwszAlloc;
	}
	pwszString = pwszAlloc;
	g_cStringAlloc++;
    }
    g_cStringUsed++;

error:
    if (NULL != pwsz && awc != pwsz)
    {
	LocalFree(pwsz);
    }
    if (NULL == pwszString)
    {
	SetLastError(hr);
    }
    return(pwszString);
}


VOID
myFreeResourceStrings(
    IN char const *pszModule)
{
    DWORD i;

    if (0 != g_cStringAlloc || 0 != g_crs || 0 != g_cStringUsed)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%hs Strings: alloc = %d, saved = %d, used = %d\n",
	    pszModule,
	    g_cStringAlloc,
	    g_crs,
	    g_cStringUsed));
    }

    if (NULL != g_rgrs)
    {
	for (i = 0; i < g_crs; i++)
	{
	    LocalFree(const_cast<WCHAR *>(g_rgrs[i].pwsz));
	    g_rgrs[i].pwsz = NULL;
	    g_rgrs[i].id = 0;
	}
	LocalFree(g_rgrs);
	g_rgrs = NULL;
    }
    g_crsMax = 0;
    g_crs = 0;
    g_cStringAlloc = 0;
    g_cStringUsed = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\tmpllist.cpp ===
//+--------------------------------------------------------------------------
// File:        tmpllist.cpp
// Contents:    certificate template list class
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include "tmpllist.h"

using namespace CertSrv;

HRESULT CTemplateInfo::SetInfo(
    LPCWSTR pcwszTemplateName,
    LPCWSTR pcwszTemplateOID)
{
    HRESULT hr = S_OK;

    if(pcwszTemplateName)
    {
        m_pwszTemplateName = (LPWSTR)LocalAlloc(
            LMEM_FIXED, 
            sizeof(WCHAR)*(wcslen(pcwszTemplateName)+1));
        _JumpIfAllocFailed(m_pwszTemplateName, error);
        wcscpy(m_pwszTemplateName, pcwszTemplateName);
    }

    if(pcwszTemplateOID)
    {
        m_pwszTemplateOID = (LPWSTR)LocalAlloc(
            LMEM_FIXED, 
            sizeof(WCHAR)*(wcslen(pcwszTemplateOID)+1));
        _JumpIfAllocFailed(m_pwszTemplateOID, error);
        wcscpy(m_pwszTemplateOID, pcwszTemplateOID);
    }

error:
    return hr;
}

LPCWSTR CTemplateInfo::GetName()
{
    if(!m_pwszTemplateName && m_hCertType)
    {
        FillInfoFromProperty(
            m_pwszTemplateName, 
            CERTTYPE_PROP_CN);
    }
    return m_pwszTemplateName;
}

LPCWSTR CTemplateInfo::GetOID()
{
    if(!m_pwszTemplateOID && m_hCertType)
    {
        FillInfoFromProperty(
            m_pwszTemplateOID, 
            CERTTYPE_PROP_OID);
    }
    return m_pwszTemplateOID;
}

void CTemplateInfo::FillInfoFromProperty(
    LPWSTR& pwszProp, 
    LPCWSTR pcwszPropName)
{
    LPWSTR *ppwszProp = NULL;
    CAGetCertTypeProperty(
            m_hCertType,
            pcwszPropName,
            &ppwszProp);

    if(ppwszProp && ppwszProp[0])
    {
        pwszProp = (LPWSTR)LocalAlloc(
            LMEM_FIXED,
            sizeof(WCHAR)*(wcslen(ppwszProp[0])+1));
        if(pwszProp)
            wcscpy(pwszProp, ppwszProp[0]);
    }

    if(ppwszProp)
    {
        CAFreeCertTypeProperty(
                    m_hCertType,
                    ppwszProp);
    }
}

bool CTemplateInfo::operator==(CTemplateInfo& rh)
{
    if(GetName() && rh.GetName())
        return 0==wcscmp(GetName(), rh.GetName());
    
    if(GetOID() && rh.GetOID())
        return 0==wcscmp(GetOID(), rh.GetOID());

    return false;
}



HRESULT CTemplateList::AddTemplateInfo(
    LPCWSTR pcwszTemplateName,
    LPCWSTR pcwszTemplateOID)
{
    HRESULT hr = S_OK;

    CTemplateInfo *pTI = NULL;

    pTI = new CTemplateInfo;
    _JumpIfAllocFailed(pTI, error);

    hr = pTI->SetInfo(pcwszTemplateName, pcwszTemplateOID);
    _JumpIfError(hr, error, "SetInfo");

    if(!AddTail(pTI))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "AddTail");
    }

error:
    return hr;
}

HRESULT CTemplateList::AddTemplateInfo(
    HCERTTYPE hCertType)
{
    HRESULT hr = S_OK;

    CTemplateInfo *pTI = NULL;

    pTI = new CTemplateInfo;
    _JumpIfAllocFailed(pTI, error);

    hr = pTI->SetInfo(hCertType);
    _JumpIfError(hr, error, "SetInfo");

    if(!AddTail(pTI))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "AddTail");
    }

error:
    return hr;
}

DWORD CTemplateList::GetMarshalBufferSize() const
{
    DWORD dwSize = sizeof(WCHAR); // at least a trailing zero
    CTemplateListEnum EnumList(*this);

    for(CTemplateInfo *pData=EnumList.Next(); 
        pData; 
        pData=EnumList.Next())
    {
        dwSize += pData->GetMarshalBufferSize();
    }

    return dwSize;
}


// Marshals the template information into a buffer, strings separated
// by new lines:
//
//     "name1\nOID1\nname2\OID2...\nnameN\nOIDN\0"
//
// If the template doesn't have an OID (Win2k domain) there will
// be an empty string in its place

HRESULT CTemplateList::Marshal(BYTE*& rpBuffer, DWORD& rcBuffer) const
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = GetMarshalBufferSize();
    CTemplateListEnum EnumList(*this);
    CTemplateInfo *pData;
    WCHAR *pb;

    rpBuffer = NULL;
    rcBuffer = 0;

    // build the marshaling buffer
    rpBuffer = (BYTE*) MIDL_user_allocate(dwBufferSize);
    _JumpIfAllocFailed(rpBuffer, error);

    pb=(WCHAR*)rpBuffer;
    for(CTemplateInfo *pData=EnumList.Next();
        pData; 
        pData=EnumList.Next())
    {
        if(pData->GetName())
        {
            wcscpy(pb, pData->GetName());
            pb += wcslen(pData->GetName());
        }
        // replace trailing zero with the separator character
        *pb = m_gcchSeparator;
        // jump over to insert the OID
        pb++;

        if(pData->GetOID())
        {
            wcscpy(pb, pData->GetOID());
            pb += wcslen(pData->GetOID());
        }
        // replace trailing zero with the separator character
        *pb = m_gcchSeparator;
        // jump over to insert the OID
        pb++;

    }

    // add string terminator
    *pb = L'\0';

    rcBuffer = dwBufferSize;

error:
    return hr;
}

HRESULT CTemplateList::ValidateMarshalBuffer(const BYTE *pBuffer, DWORD cBuffer) const
{
    const hrError = E_INVALIDARG;

    if(cBuffer&1)
    {
        _PrintError(hrError,
            "ValidateMarshalBuffer: buffer contains unicode string, "
            "buffer size should be even");
        return hrError;
    }

    if(cBuffer==0)
    {
        return S_OK;
    }
    
    if(cBuffer==2)
    {
        if(*(WCHAR*)pBuffer==L'\0')
            return S_OK;
        else
        {
            _PrintErrorStr(hrError, 
                "ValidateMarshalBuffer: buffer size is 2 but string is not empty",
                (WCHAR*)pBuffer);
            return hrError;
        }
    }
    
    if(pBuffer[cBuffer-1] != L'\0')
    {
        _PrintErrorStr(hrError, 
            "ValidateMarshalBuffer: buffer doesn't end with a null string terminator",
            (WCHAR*)pBuffer);
        return hrError;
    }

    // should contain an even number of separators
    DWORD cSeparators = 0;

    for(WCHAR *pCrt = (WCHAR*)pBuffer; 
        pCrt && *pCrt!=L'\0' && ((BYTE*)pCrt) < pBuffer+cBuffer;
        pCrt++, cSeparators++)
    {
        pCrt = wcschr(pCrt, m_gcchSeparator);
        if(!pCrt)
            break;
    }

    if(cSeparators&1)
    {
        _PrintErrorStr(hrError, 
            "ValidateMarshalBuffer: buffer should contain an even number of separators",
            (WCHAR*)pBuffer);
        return hrError;
    }

    if(cBuffer>1 && cSeparators<2)
    {
        _PrintErrorStr(hrError, 
            "ValidateMarshalBuffer: nonempty buffer should contain at least two separators",
            (WCHAR*)pBuffer);
        return hrError;
    }


    return S_OK;
}

HRESULT CTemplateList::Unmarshal(const BYTE *pBuffer, DWORD cBuffer)
{
    HRESULT hr = S_OK;
    WCHAR *pCrt, *pNext, *pwszName, *pwszOID;

    hr = ValidateMarshalBuffer(pBuffer, cBuffer);
    _JumpIfError(hr, error, "CTemplateList::ValidateMarshalBuffer");

    for(pCrt = (WCHAR*)pBuffer; *pCrt!=L'\0';)
    {
        pwszName = pCrt;
        pNext = wcschr(pCrt, m_gcchSeparator);
        if(!pNext)
            break;
        *pNext++ = L'\0';
        pwszOID = pNext;
        pNext = wcschr(pNext, m_gcchSeparator);
        if(!pNext)
            break;
        *pNext++ = L'\0';
        hr = AddTemplateInfo(pwszName, pwszOID);
        _JumpIfError(hr, error, "CTemplateList::AddTemplateInfo");

        pCrt = pNext;
    }

error:
    return hr;
}

HRESULT CTemplateList::RemoveTemplateInfo(HCERTTYPE hCertType)
{
    HRESULT hr = S_OK;
    CTemplateListEnum EnumList(*this);
    CTemplateInfo *pData;
    DWORD dwPosition = 0;
    CTemplateInfo tempInfo;

    hr = tempInfo.SetInfo(hCertType);
    if(S_OK!=hr)
        return hr;

    for(pData = EnumList.Next();
        pData;
        pData = EnumList.Next(), dwPosition++)
    {
        if(*pData == tempInfo)
            break;
    }

    if(!pData)
        return S_FALSE;

    RemoveAt(dwPosition);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\tfc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#include "tfc.h"

#include <stdarg.h>

extern HINSTANCE g_hInstance;

const WCHAR* wszNull = L"";


BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    WCHAR szMessage[_MAX_PATH*2];
    
    // format message into buffer
    wsprintf(szMessage, L"File %hs, Line %d\n",
        lpszFileName, nLine);
    
    OutputDebugString(szMessage);
    int iCode = MessageBox(NULL, szMessage, L"Assertion Failed!",
        MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);
    
    if (iCode == IDIGNORE)
        return FALSE;
    
    if (iCode == IDRETRY)
        return TRUE;
    
    // abort!
    ExitProcess(0);
    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CString
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

CString::CString()
{ 
    Init();
}

CString::CString(const CString& stringSrc)
{
	Init();
	*this = stringSrc;
}

CString::CString(LPCSTR lpsz)
{
    Init();
    *this = lpsz;
}

CString::CString(LPCWSTR lpsz)
{
    Init();
    *this = lpsz;
}

CString::~CString() 
{ 
    if (szData)
    {    
        LocalFree(szData); 
        szData = NULL;
    }
    dwDataLen = 0;
}

// called to initialize cstring
void CString::Init()
{
    szData = NULL;
    dwDataLen = 0;
}

// called to make cstring empty
void CString::Empty() 
{ 
    if (szData)
    {
        // Allow us to use ReAlloc
        szData[0]=L'\0';
        dwDataLen = sizeof(WCHAR);
    }
    else
        dwDataLen = 0;

}

BOOL CString::IsEmpty() const
{ 
    return ((NULL == szData) || (szData[0] == L'\0')); 
}

LPWSTR CString::GetBuffer(DWORD cch) 
{ 
    // get buffer of at least cch CHARS

    cch ++; // incl null term
    cch *= sizeof(WCHAR); // cb

    if (cch > dwDataLen) 
    {
        LPWSTR szTmp;
        if (szData)
            szTmp = (LPWSTR)LocalReAlloc(szData, cch, LMEM_MOVEABLE); 
        else
            szTmp = (LPWSTR)LocalAlloc(LMEM_FIXED, cch);

        if (!szTmp)
        {
            LocalFree(szData);
            dwDataLen = 0;
        }
        else
        {
            dwDataLen = cch;
        }

        szData = szTmp;
    }
    return szData; 
}

BSTR CString::AllocSysString() const
{
    return SysAllocStringLen(szData, (dwDataLen-1)/sizeof(WCHAR));
}


DWORD CString::GetLength() const
{ 
    // return # chars in string (not incl NULL term)
    return ((dwDataLen > 0) ? wcslen(szData) : 0);
}

// warning: insertion strings cannot exceed MAX_PATH chars
void CString::Format(LPCWSTR lpszFormat, ...)
{
    Empty();
    
    DWORD cch = wcslen(lpszFormat) + MAX_PATH;
    GetBuffer(cch);     // chars (don't count NULL term)

    if (szData != NULL)
    {
        DWORD dwformatted;
        va_list argList;
        va_start(argList, lpszFormat);
        dwformatted = vswprintf(szData, lpszFormat, argList);
        va_end(argList);
        
        dwformatted = (dwformatted+1)*sizeof(WCHAR);    // cvt to bytes
        VERIFY (dwformatted <= dwDataLen);
        dwDataLen = dwformatted;
    }
    else
    {
        ASSERT(dwDataLen == 0);
        dwDataLen = 0;
    }
}



BOOL CString::LoadString(UINT iRsc) 
{
    WCHAR awc[4096];
    
    if (! ::LoadString(g_hInstance, iRsc, awc, 4096))
        return FALSE;
    
    *this = (LPCWSTR)awc;
    
    return TRUE;
}

BOOL CString::FromWindow(HWND hWnd)
{
    Empty();
    
    DWORD dwBytes;
    INT iCh = (INT)SendMessage(hWnd, WM_GETTEXTLENGTH, 0, 0);

    GetBuffer(iCh);

    if (NULL == szData)
        return FALSE;

    if (dwDataLen != (DWORD)SendMessage(hWnd, WM_GETTEXT, (WPARAM)(dwDataLen/sizeof(WCHAR)), (LPARAM)szData))
    {
        // truncation!
    }
    return TRUE;
}


BOOL CString::ToWindow(HWND hWnd)
{
    return (BOOL)SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)szData);
}

void CString::SetAt(int nIndex, WCHAR ch) 
{ 
    ASSERT(nIndex <= (int)(dwDataLen / sizeof(WCHAR)) ); 
    if (nIndex <= (int)(dwDataLen / sizeof(WCHAR)) )
        szData[nIndex] = ch;
}

// test
BOOL CString::IsEqual(LPCWSTR sz)
{
    if ((szData == NULL) || (szData[0] == L'\0'))
        return ((sz == NULL) || (sz[0] == L'\0'));

    if (sz == NULL)
        return FALSE;

    return (0 == lstrcmp(sz, szData));
}


// assignmt
const CString& CString::operator=(const CString& stringSrc) 
{ 
    if (stringSrc.IsEmpty())
        Empty();
    else
    {
        GetBuffer( stringSrc.GetLength() );
        if (szData != NULL)
        {
            CopyMemory(szData, stringSrc.szData, sizeof(WCHAR)*(stringSrc.GetLength()+1));
        }
    }
    
    return *this;
}

// W Const
const CString& CString::operator=(LPCWSTR lpsz)
{
    if (lpsz == NULL)
        Empty();
    else
    {
        GetBuffer(wcslen(lpsz));
        if (szData != NULL)
        {
            CopyMemory(szData, lpsz, sizeof(WCHAR)*(wcslen(lpsz)+1));
        }
    }
    return *this;
}
// W 
const CString& CString::operator=(LPWSTR lpsz)
{
    *this = (LPCWSTR)lpsz;
    return *this;
}


// A Const
const CString& CString::operator=(LPCSTR lpsz)
{
    if (lpsz == NULL)
        Empty();
    else
    {
        DWORD cch;
        cch = ::MultiByteToWideChar(CP_ACP, 0, lpsz, -1, NULL, 0);
        GetBuffer(cch-1);
        if (szData != NULL)
        {
            ::MultiByteToWideChar(CP_ACP, 0, lpsz, -1, szData, cch);
        }
    }    
    return *this;
}

// A 
const CString& CString::operator=(LPSTR lpsz)
{
    *this = (LPCSTR)lpsz;
    return *this;
}

// concat
const CString& CString::operator+=(LPCWSTR lpsz)
{
    if (IsEmpty())
    {
        *this = lpsz;
        return *this;
    }

    if (lpsz != NULL)
    {
        GetBuffer(wcslen(lpsz) + GetLength() );
        if (szData != NULL)
        {
            wcscat(szData, lpsz);
        }
    }
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    if (IsEmpty()) 
    {
        *this = string;
        return *this;
    }

    if (!string.IsEmpty())
    {
        GetBuffer( string.GetLength() + GetLength() );    // don't count NULL terms
        if (szData != NULL)
        {
            wcscat(szData, string.szData);
        }
    }
    return *this;
}





//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CBitmap
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

CBitmap::CBitmap()
{
    m_hBmp = NULL; 
}

CBitmap::~CBitmap()
{
    if(m_hBmp) 
        DeleteObject(m_hBmp); 
    m_hBmp = NULL;
}

HBITMAP CBitmap::LoadBitmap(UINT iRsc)
{ 
    m_hBmp = (HBITMAP)LoadImage(g_hInstance, MAKEINTRESOURCE(iRsc), IMAGE_BITMAP, 0, 0, 0); 
    return m_hBmp; 
}


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CComboBox
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

void CComboBox::Init(HWND hWnd)
{
    m_hWnd = hWnd;
}

void CComboBox::ResetContent()         
{ 
    ASSERT(m_hWnd); 
    SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); 
}

int CComboBox::SetItemData(int idx, DWORD dwData) 
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_SETITEMDATA, (WPARAM)idx, (LPARAM)dwData); 
}

DWORD CComboBox::GetItemData(int idx) 
{ 
    ASSERT(m_hWnd); 
    return (DWORD)SendMessage(m_hWnd, CB_GETITEMDATA, (WPARAM)idx, 0);
}

int CComboBox::AddString(LPWSTR sz)    
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM) sz);
}

int CComboBox::AddString(LPCWSTR sz)  
{ 
    return (INT)AddString((LPWSTR)sz); 
}

int CComboBox::GetCurSel()           
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_GETCURSEL, 0, 0);
}

int CComboBox::SetCurSel(int iSel)    
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_SETCURSEL, (WPARAM)iSel, 0); 
}

int CComboBox::SelectString(int nAfter, LPCWSTR szItem)
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_SELECTSTRING, (WPARAM) nAfter, (LPARAM)szItem); 
}


int ListView_NewItem(HWND hList, int iIndex, LPCWSTR szText, LPARAM lParam /* = NULL*/, int iImage /*=-1*/)
{
	LVITEM sItem;
	ZeroMemory(&sItem, sizeof(sItem));
	sItem.iItem = iIndex;
    sItem.iImage = iImage;
	
	if (lParam)
	{
            sItem.mask = LVIF_PARAM;
            if(-1!=iImage)
                sItem.mask |= LVIF_IMAGE;
            sItem.lParam = lParam;
	}

	sItem.iItem = ListView_InsertItem(hList, &sItem);

	ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)szText);

	return sItem.iItem;
}

int ListView_NewColumn(HWND hwndListView, int iCol, int cx, LPCWSTR szHeading /*=NULL*/, int fmt/*=0*/)
{
    LVCOLUMN lvCol;
    lvCol.mask = LVCF_WIDTH;
    lvCol.cx = cx;
    
    if (szHeading)
    {
        lvCol.mask |= LVCF_TEXT;
        lvCol.pszText = (LPWSTR)szHeading;
    }

    if (fmt)
    {
        lvCol.mask |= LVCF_FMT;
        lvCol.fmt = fmt;
    }

    return ListView_InsertColumn(hwndListView, iCol, &lvCol);
}

LPARAM ListView_GetItemData(HWND hListView, int iItem)
{
    LVITEM lvItem;
    lvItem.iItem = iItem;
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    ListView_GetItem(hListView, &lvItem);

    return lvItem.lParam;
}

int ListView_GetCurSel(HWND hwndList)
{
    int iTot = ListView_GetItemCount(hwndList);
    int i=0;

    while(i<iTot)
    {
        if (LVIS_SELECTED == ListView_GetItemState(hwndList, i, LVIS_SELECTED))
            break;

        i++;
    }

    return (i<iTot) ? i : -1;
}

void
ListView_SetItemFiletime(
    IN HWND hwndList,
    IN int  iItem,
    IN int  iColumn,
    IN FILETIME const *pft)
{
    HRESULT hr;
    WCHAR *pwszDateTime = NULL;

    // convert filetime to string
    hr = myGMTFileTimeToWszLocalTime(pft, FALSE, &pwszDateTime);
    if (S_OK != hr)
    {
        _PrintError(hr, "myGMTFileTimeToWszLocalTime");
    }
    else
    {
        ListView_SetItemText(hwndList, iItem, iColumn, pwszDateTime); 
    }

    if (NULL != pwszDateTime)
    {
        LocalFree(pwszDateTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\viewcol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewcol.cpp
//
//  Contents:   IEnumCERTVIEWCOLUMN IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// IEnumCERTVIEWCOLUMN dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetName method:

static OLECHAR *_apszGetName[] = {
    TEXT("GetName"),
};

//+------------------------------------
// GetDisplayName method:

static OLECHAR *_apszGetDisplayName[] = {
    TEXT("GetDisplayName"),
};

//+------------------------------------
// GetType method:

static OLECHAR *_apszGetType[] = {
    TEXT("GetType"),
};

//+------------------------------------
// IsIndexed method:

static OLECHAR *_apszIsIndexed[] = {
    TEXT("IsIndexed"),
};

//+------------------------------------
// GetMaxLength method:

static OLECHAR *_apszGetMaxLength[] = {
    TEXT("GetMaxLength"),
};

//+------------------------------------
// GetValue method:

static OLECHAR *_apszGetValue[] = {
    TEXT("GetValue"),
    TEXT("Flags"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewColumn[] =
{
#define VIEWCOL_NEXT		0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWCOL_GETNAME		1
    DECLARE_DISPATCH_ENTRY(_apszGetName)

#define VIEWCOL_GETDISPLAYNAME	2
    DECLARE_DISPATCH_ENTRY(_apszGetDisplayName)

#define VIEWCOL_GETTYPE		3
    DECLARE_DISPATCH_ENTRY(_apszGetType)

#define VIEWCOL_ISINDEXED	4
    DECLARE_DISPATCH_ENTRY(_apszIsIndexed)

#define VIEWCOL_GETMAXLENGTH	5
    DECLARE_DISPATCH_ENTRY(_apszGetMaxLength)

#define VIEWCOL_GETVALUE	6
    DECLARE_DISPATCH_ENTRY(_apszGetValue)

#define VIEWCOL_SKIP		7
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWCOL_RESET		8
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWCOL_CLONE		9
    DECLARE_DISPATCH_ENTRY(_apszClone)
};
#define CVIEWCOLDISPATCH	(ARRAYSIZE(g_adtViewColumn))


HRESULT
ViewColumn_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWCOLUMN *pEnumColumn,
    OUT DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;
    static BOOL s_fInitialized = FALSE;

    pdiViewColumn->pDispatchTable = NULL;
    pdiViewColumn->pDispatch = NULL;
    pdiViewColumn->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumColumn->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWCOLDISPATCH,
			g_adtViewColumn,
			pdiViewColumn);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewColumn->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumColumn->AddRef();
	pdiViewColumn->pUnknown = (IUnknown *) pEnumColumn;
	hr = S_OK;
    }
    pdiViewColumn->pDispatchTable = g_adtViewColumn;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ViewColumn_Release(
    IN OUT DISPATCHINTERFACE *pdiViewColumn)
{
    DispatchRelease(pdiViewColumn);
}


HRESULT
ViewColumn_Next(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetName(pstrOut);
	_JumpIfError(hr, error, "GetName");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetDisplayName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETDISPLAYNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetDisplayName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetDisplayName(pstrOut);
	_JumpIfError(hr, error, "GetDisplayName");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetType(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pType)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETTYPE,
			0,
			NULL,
			VT_I4,
			pType);
	_JumpIfError(hr, error, "Invoke(GetType)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetType(pType);
	_JumpIfError(hr, error, "GetType");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_IsIndexed(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndexed)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_ISINDEXED,
			0,
			NULL,
			VT_I4,
			pIndexed);
	_JumpIfError(hr, error, "Invoke(IsIndexed)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->IsIndexed(pIndexed);
	_JumpIfError(hr, error, "IsIndexed");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetMaxLength(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pMaxLength)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETMAXLENGTH,
			0,
			NULL,
			VT_I4,
			pMaxLength);
	_JumpIfError(hr, error, "Invoke(GetMaxLength)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetMaxLength(
								pMaxLength);
	_JumpIfError(hr, error, "GetMaxLength");
    }

error:
    return(hr);
}

HRESULT
ViewColumn_GetValue(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG Flags,
    IN LONG ColumnType,
    OUT VOID *pColumnValue)
{
    HRESULT hr;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    switch (ColumnType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiViewColumn->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETVALUE,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pColumnValue);
	_JumpIfError2(hr, error, "Invoke(GetValue)", CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetValue(
								Flags,
								&varResult);
	_JumpIfError(hr, error, "GetValue");

	hr = DispatchGetReturnValue(&varResult, RetType, pColumnValue);
	_JumpIfError2(hr, error, "DispatchGetReturnValue", CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    VariantClear(&varResult);
    return(hr);
}


HRESULT
ViewColumn_Skip(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_Reset(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_Clone(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT DISPATCHINTERFACE *pdiViewColumnClone)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pEnumColumn = NULL;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumColumn);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Clone(
								&pEnumColumn);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewColumn_Init2(
		    NULL != pdiViewColumn->pDispatch,
		    pEnumColumn,
		    pdiViewColumnClone);
    _JumpIfError(hr, error, "ViewColumn_Init2");

error:
    if (NULL != pEnumColumn)
    {
	pEnumColumn->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\about.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include <stdafx.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CSnapinAboutImpl::CSnapinAboutImpl()
{
}


CSnapinAboutImpl::~CSnapinAboutImpl()
{
}


HRESULT CSnapinAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR> 
                ( CoTaskMemAlloc( (s.GetLength()+1)*sizeof(WCHAR) ));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

    myRegisterMemFree(*lpPtr, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


	USES_CONVERSION;
    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_DESCRIPTION, lpDescription);
}


STDMETHODIMP CSnapinAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper(IDS_VERSION, lpVersion);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // in MMC 1.1, this will be used as root node icon!!
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CSnapinAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(cLargeMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COMPUTER_SMALL));
	*hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COMPUTER_SMALL));
	*hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COMPUTER_LARGE));

	*cLargeMask = RGB(255, 0, 255);

	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
		OutputDebugString(L"WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
		}
	#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\viewrow.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewrow.cpp
//
//  Contents:   IEnumCERTVIEWROW IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// IEnumCERTVIEWROW dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// EnumCertViewColumn method:

static OLECHAR *_apszEnumCertViewColumn[] = {
    TEXT("EnumCertViewColumn"),
};

//+------------------------------------
// EnumCertViewAttribute method:

static OLECHAR *_apszEnumCertViewAttribute[] = {
    TEXT("EnumCertViewAttribute"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumCertViewExtension method:

static OLECHAR *_apszEnumCertViewExtension[] = {
    TEXT("EnumCertViewExtension"),
    TEXT("Flags"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};

//+------------------------------------
// GetMaxIndex method:

static OLECHAR *_apszGetMaxIndex[] = {
    TEXT("GetMaxIndex"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewRow[] =
{
#define VIEWROW_NEXT			0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWROW_ENUMCERTVIEWCOLUMN	1
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewColumn)

#define VIEWROW_ENUMCERTVIEWATTRIBUTE	2
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewAttribute)

#define VIEWROW_ENUMCERTVIEWEXTENSION	3
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewExtension)

#define VIEWROW_SKIP			4
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWROW_RESET			5
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWROW_CLONE			6
    DECLARE_DISPATCH_ENTRY(_apszClone)

#define VIEWROW_GETMAXINDEX		7
    DECLARE_DISPATCH_ENTRY(_apszGetMaxIndex)
};
#define CVIEWROWDISPATCH	(ARRAYSIZE(g_adtViewRow))


HRESULT
ViewRow_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWROW *pEnumRow,
    OUT DISPATCHINTERFACE *pdiViewRow)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;

    pdiViewRow->pDispatchTable = NULL;
    pdiViewRow->pDispatch = NULL;
    pdiViewRow->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumRow->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWROWDISPATCH,
			g_adtViewRow,
			pdiViewRow);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewRow->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumRow->AddRef();
	pdiViewRow->pUnknown = (IUnknown *) pEnumRow;
	hr = S_OK;
    }
    pdiViewRow->pDispatchTable = g_adtViewRow;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}



VOID
ViewRow_Release(
    IN OUT DISPATCHINTERFACE *pdiViewRow)
{
    DispatchRelease(pdiViewRow);
}


HRESULT
ViewRow_Next(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewRow_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pEnumColumn = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_ENUMCERTVIEWCOLUMN,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumColumn);
	_JumpIfError(hr, error, "Invoke(EnumCertViewColumn)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->EnumCertViewColumn(
								&pEnumColumn);
	_JumpIfError(hr, error, "EnumCertViewColumn");
    }
    hr = ViewColumn_Init2(
		    NULL != pdiViewRow->pDispatch, 
		    pEnumColumn,
		    pdiViewColumn);
    _JumpIfError(hr, error, "ViewColumn_Init2");

error:
    if (NULL != pEnumColumn)
    {
	pEnumColumn->Release();
    }
    return(hr);
}


HRESULT
ViewRow_EnumCertViewAttribute(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    OUT DISPATCHINTERFACE *pdiViewAttribute)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *pEnumAttribute = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_ENUMCERTVIEWATTRIBUTE,
			ARRAYSIZE(avar),
			avar,
			VT_DISPATCH,
			&pEnumAttribute);
	_JumpIfError(hr, error, "Invoke(EnumCertViewAttribute)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->EnumCertViewAttribute(
							    Flags,
							    &pEnumAttribute);
	_JumpIfError(hr, error, "EnumCertViewAttribute");
    }
    hr = ViewAttribute_Init2(
		    NULL != pdiViewRow->pDispatch, 
		    pEnumAttribute,
		    pdiViewAttribute);
    _JumpIfError(hr, error, "ViewAttribute_Init2");

error:
    if (NULL != pEnumAttribute)
    {
	pEnumAttribute->Release();
    }
    return(hr);
}


HRESULT
ViewRow_EnumCertViewExtension(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    OUT DISPATCHINTERFACE *pdiViewExtension)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *pEnumExtension = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_ENUMCERTVIEWEXTENSION,
			ARRAYSIZE(avar),
			avar,
			VT_DISPATCH,
			&pEnumExtension);
	_JumpIfError(hr, error, "Invoke(EnumCertViewExtension)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->EnumCertViewExtension(
							    Flags,
							    &pEnumExtension);
	_JumpIfError(hr, error, "EnumCertViewExtension");
    }
    hr = ViewExtension_Init2(
		    NULL != pdiViewRow->pDispatch, 
		    pEnumExtension,
		    pdiViewExtension);
    _JumpIfError(hr, error, "ViewExtension_Init2");

error:
    if (NULL != pEnumExtension)
    {
	pEnumExtension->Release();
    }
    return(hr);
}


HRESULT
ViewRow_Skip(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewRow_Reset(
    IN DISPATCHINTERFACE *pdiViewRow)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewRow_Clone(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT DISPATCHINTERFACE *pdiViewRowClone)
{
    HRESULT hr;
    IEnumCERTVIEWROW *pEnumRow = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumRow);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Clone(&pEnumRow);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewRow_Init2(
		    NULL != pdiViewRow->pDispatch,
		    pEnumRow,
		    pdiViewRowClone);
    _JumpIfError(hr, error, "ViewRow_Init2");

error:
    if (NULL != pEnumRow)
    {
	pEnumRow->Release();
    }
    return(hr);
}


HRESULT
ViewRow_GetMaxIndex(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_GETMAXINDEX,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(GetMaxIndex)", E_UNEXPECTED);
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->GetMaxIndex(pIndex);
	_JumpIfError2(hr, error, "GetMaxIndex", E_UNEXPECTED);
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certlib\viewext.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewext.cpp
//
//  Contents:   IEnumCERTVIEWEXTENSION IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"


//+------------------------------------------------------------------------
// IEnumCERTVIEWEXTENSION dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetName method:

static OLECHAR *_apszGetName[] = {
    TEXT("GetName"),
};

//+------------------------------------
// GetFlags method:

static OLECHAR *_apszGetFlags[] = {
    TEXT("GetFlags"),
};

//+------------------------------------
// GetValue method:

static OLECHAR *_apszGetValue[] = {
    TEXT("GetValue"),
    TEXT("Type"),
    TEXT("Flags"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewExtension[] =
{
#define VIEWEXT_NEXT		0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWEXT_GETNAME		1
    DECLARE_DISPATCH_ENTRY(_apszGetName)

#define VIEWEXT_GETFLAGS	2
    DECLARE_DISPATCH_ENTRY(_apszGetFlags)

#define VIEWEXT_GETVALUE	3
    DECLARE_DISPATCH_ENTRY(_apszGetValue)

#define VIEWEXT_SKIP		4
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWEXT_RESET		5
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWEXT_CLONE		6
    DECLARE_DISPATCH_ENTRY(_apszClone)
};
#define CVIEWEXTDISPATCH	(ARRAYSIZE(g_adtViewExtension))


HRESULT
ViewExtension_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWEXTENSION *pEnumExtension,
    OUT DISPATCHINTERFACE *pdiViewExtension)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;
    static BOOL s_fInitialized = FALSE;

    pdiViewExtension->pDispatchTable = NULL;
    pdiViewExtension->pDispatch = NULL;
    pdiViewExtension->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumExtension->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWEXTDISPATCH,
			g_adtViewExtension,
			pdiViewExtension);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewExtension->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumExtension->AddRef();
	pdiViewExtension->pUnknown = (IUnknown *) pEnumExtension;
	hr = S_OK;
    }
    pdiViewExtension->pDispatchTable = g_adtViewExtension;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ViewExtension_Release(
    IN OUT DISPATCHINTERFACE *pdiViewExtension)
{
    DispatchRelease(pdiViewExtension);
}


HRESULT
ViewExtension_Next(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewExtension_GetName(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_GETNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->GetName(pstrOut);
	_JumpIfError(hr, error, "GetName");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_GetFlags(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pFlags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_GETFLAGS,
			0,
			NULL,
			VT_I4,
			pFlags);
	_JumpIfError(hr, error, "Invoke(GetFlags)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->GetFlags(pFlags);
	_JumpIfError(hr, error, "GetFlags");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_GetValue(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG Type,
    IN LONG Flags,
    OUT VOID *pValue)
{
    HRESULT hr;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiViewExtension->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = Type;
	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_GETVALUE,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pValue);
	_JumpIfError(hr, error, "Invoke(GetValue)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->GetValue(
								Type,
								Flags,
								&varResult);
	_JumpIfError2(hr, error, "GetValue", CERTSRV_E_PROPERTY_EMPTY);

	hr = DispatchGetReturnValue(&varResult, RetType, pValue);
	_JumpIfError2(hr, error, "DispatchGetReturnValue", CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    VariantClear(&varResult);
    return(hr);
}


HRESULT
ViewExtension_Skip(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_Reset(
    IN DISPATCHINTERFACE *pdiViewExtension)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_Clone(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT DISPATCHINTERFACE *pdiViewExtensionClone)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *pEnumExtension = NULL;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumExtension);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Clone(
							    &pEnumExtension);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewExtension_Init2(
		    NULL != pdiViewExtension->pDispatch,
		    pEnumExtension,
		    pdiViewExtensionClone);
    _JumpIfError(hr, error, "ViewExtension_Init2");

error:
    if (NULL != pEnumExtension)
    {
	pEnumExtension->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\browsedi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       browsedi.cpp
//
//--------------------------------------------------------------------------

//
// BrowseDir.cpp
//

#include "stdafx.h"
#include <shlobj.h>


int 
InitStartDir( 
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData)
{
    // we just capture Init Message
    if (BFFM_INITIALIZED == uMsg)
    {
        // we expect lpData to be our start path
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
    }

    return 0;
}
 



BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash )
{
    LPITEMIDLIST pItem = NULL;
    TCHAR szPath[MAX_PATH+1];
    BOOL bGotLocation = FALSE;

    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi));
    bi.hwndOwner = hwndParent;

    // initial folder
    if (pszInitialDir != NULL)
    {
        bi.lpfn = InitStartDir;
        bi.lParam = (LPARAM)pszInitialDir;
    }

    bi.pszDisplayName = szPath;   
    bi.lpszTitle = pszDialogTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS;            // return only directories in the filesystem, not other folders


    pItem = SHBrowseForFolder(&bi);
    if (pItem == NULL)
        goto Ret;

    bGotLocation = SHGetPathFromIDList(pItem, szPath);
    if (!bGotLocation)
        goto Ret;
    
    ASSERT((_tcslen(szPath)+1)*sizeof(TCHAR) <= (UINT)cchBuf);
    if ((_tcslen(szPath)+1)*sizeof(TCHAR) > (UINT)cchBuf)
        return FALSE;

    _tcscpy(pszBuf, szPath);
   
Ret:
    LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
    {
       if (pItem)
           pMalloc->Free(pItem);
       if (bi.pidlRoot)
           pMalloc->Free((ITEMIDLIST*)bi.pidlRoot);

       pMalloc->Release();
    }

    return bGotLocation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\certwrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certwrap.cpp
//
//--------------------------------------------------------------------------
#include <stdafx.h>
#include "csdisp.h"
#include "certsrv.h"
#include "genpage.h"
#include "progress.h"
#include "misc.h"
#include "certacl.h"
#include <dsgetdc.h>
#include <winldap.h>
#include "csldap.h"

_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);

//////////////////////////
// CertSvrCA class
CertSvrCA::CertSvrCA(CertSvrMachine* pParent) :
        m_pParentMachine(pParent)
{
    m_hCACertStore = NULL;
    m_fCertStoreOpenAttempted = FALSE;
    m_hrCACertStoreOpen = S_OK;

    m_hRootCertStore = NULL;
    m_fRootStoreOpenAttempted = FALSE;
    m_hrRootCertStoreOpen = S_OK;

    m_hKRACertStore = NULL;
    m_fKRAStoreOpenAttempted = FALSE;
    m_hrKRACertStoreOpen = S_OK;

    m_bstrConfig = NULL;

    m_enumCAType = ENUM_UNKNOWN_CA;
    m_fCATypeKnown = FALSE;

    m_fIsUsingDS = FALSE;
    m_fIsUsingDSKnown = FALSE;

    m_fAdvancedServer = FALSE;
    m_fAdvancedServerKnown = FALSE;

    if(m_pParentMachine)
        m_pParentMachine->AddRef();

    m_dwRoles = 0;
    m_fRolesKnown = FALSE;
}

CertSvrCA::~CertSvrCA()
{
    if (m_hCACertStore)
    {
        CertCloseStore(m_hCACertStore, 0);
        m_hCACertStore = NULL;
    }

    if (m_hRootCertStore)
    {
        CertCloseStore(m_hRootCertStore, 0);
        m_hRootCertStore = NULL;
    }

    if (m_hKRACertStore)
    {
        CertCloseStore(m_hKRACertStore, 0);
        m_hKRACertStore = NULL;
    }

    if (m_bstrConfig)
        SysFreeString(m_bstrConfig);

    if(m_pParentMachine)
        m_pParentMachine->Release();
}

BOOL CertSvrCA::AccessAllowed(DWORD dwAccess)
{
    return (dwAccess & GetMyRoles())?TRUE:FALSE;
}

DWORD CertSvrCA::GetMyRoles()
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pCertAdmin;
    LONG dwRoles;

    if(!m_fRolesKnown)
    {
	    hr = m_pParentMachine->GetAdmin2(&pCertAdmin);
        _JumpIfError(hr, error, "CertSvrMachine::GetAdmin2");

	    hr = pCertAdmin->GetMyRoles(
		    m_bstrConfig,
            &dwRoles);
        _JumpIfError(hr, error, "ICertAdmin2::GetCAProperty");

        m_dwRoles = dwRoles;
        m_fRolesKnown = TRUE;
    }

error:
    return m_dwRoles;
}

HRESULT CertSvrCA::GetCAFlagsFromDS(PDWORD pdwFlags)
{
    HRESULT hr = S_OK;
    LPWSTR pwszSanitizedDSName = NULL;
    HCAINFO hCAInfo = NULL;

    hr = mySanitizedNameToDSName(m_strSanitizedName, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
        pwszSanitizedDSName,
        NULL,
        0,
        &hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", pwszSanitizedDSName);

    hr = CAGetCAFlags(
        hCAInfo,
        pdwFlags);
    _JumpIfError(hr, error, "CAGetCAFlags");

error:
    LOCAL_FREE(pwszSanitizedDSName);
    if(hCAInfo)
        CACloseCA(hCAInfo);

    return hr;
}


// CA machine should have full control over the enrollment object in DS.
// This function checks if the machine has the rights and adds a new
// ace allowing CA machine obj (eg TESTDOMAIN\BOGDANTTEST$) full control
// over its enrollment object
// See bug# 193388.
HRESULT CertSvrCA::FixEnrollmentObject()
{
    HRESULT hr = S_OK;
    IDirectoryObject *pADEnrollObj = NULL;
    LPWSTR pwszAttr = L"nTSecurityDescriptor";
    PADS_ATTR_INFO paai = NULL;
    DWORD dwAttrReturned;
    
    LPWSTR pwszSanitizedDSName = NULL;
    CString strEnrollDN;
    HCAINFO hCAInfo = NULL;
    PSID pSid = NULL;
    bool fAllowed = false;
    PSECURITY_DESCRIPTOR pSDRead = NULL; // no free
    PSECURITY_DESCRIPTOR pSDWrite = NULL;

    hr = mySanitizedNameToDSName(m_strSanitizedName, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
        pwszSanitizedDSName,
        NULL,
        CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
        &hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", pwszSanitizedDSName);

    strEnrollDN = L"LDAP://";
    strEnrollDN += myCAGetDN(hCAInfo);
    if (strEnrollDN.IsEmpty())
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCAGetDN");
    }

    hr = ADsGetObject(strEnrollDN, IID_IDirectoryObject, (void**)&pADEnrollObj);
    _JumpIfErrorStr(hr, error, "ADsGetObject", strEnrollDN);

    hr = pADEnrollObj->GetObjectAttributes(
        &pwszAttr,
        1,
        &paai,
        &dwAttrReturned);
    _JumpIfErrorStr(hr, error, "Get SD", strEnrollDN);

    pSDRead = paai[0].pADsValues[0].SecurityDescriptor.lpValue;

    CSASSERT(IsValidSecurityDescriptor(pSDRead));

    hr = FindComputerObjectSid(
        m_strServer,
        pSid);
    _JumpIfErrorStr(hr, error, "FindCAComputerObjectSid", m_strServer);

    // look in DACL for a ace allowing CA full control
    hr = IsCAAllowedFullControl(
            pSDRead,
            pSid,
            fAllowed);
    _JumpIfError(hr, error, "IsCAAllowedFullControl");

    if(!fAllowed)
    {
        // build new SD allowing CA full control and write it back
        // to DS
        ADSVALUE  snValue;
        ADS_ATTR_INFO  attrInfo[] = 
        {{
            pwszAttr,
            ADS_ATTR_UPDATE,
            ADSTYPE_NT_SECURITY_DESCRIPTOR,
            &snValue,
            1} 
        };

        hr = AllowCAFullControl(
            pSDRead,
            pSid,
            pSDWrite);
        _JumpIfError(hr, error, "AllowCAFullControl");

        CSASSERT(IsValidSecurityDescriptor(pSDWrite));

        snValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        snValue.SecurityDescriptor.dwLength = 
            GetSecurityDescriptorLength(pSDWrite);
        snValue.SecurityDescriptor.lpValue = (LPBYTE)pSDWrite;

        hr = pADEnrollObj->SetObjectAttributes(
            attrInfo,
            1,
            &dwAttrReturned);
        _JumpIfErrorStr(hr, error, "Set SD", strEnrollDN);
    }

error:

    if(paai)
        FreeADsMem(paai);
    if(pADEnrollObj)
        pADEnrollObj->Release();
    if(hCAInfo)
        CACloseCA(hCAInfo);
    LOCAL_FREE(pwszSanitizedDSName);
    LOCAL_FREE(pSid);
    LOCAL_FREE(pSDWrite);
    return hr;
}

HRESULT CertSvrCA::IsCAAllowedFullControl(
    PSECURITY_DESCRIPTOR pSDRead,
    PSID pSid,
    bool& fAllowed)
{
    HRESULT hr = S_OK;
    PACL pDacl; // no free
    ACL_SIZE_INFORMATION AclInfo;
    PACCESS_ALLOWED_ACE pAce; // no free
    DWORD dwIndex;
    
    fAllowed = false;

    hr = myGetSecurityDescriptorDacl(
        pSDRead,
        &pDacl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");


    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    for(dwIndex = 0; dwIndex < AclInfo.AceCount; dwIndex++)
    {
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE &&
           (pAce->Mask & ACTRL_CERTSRV_MANAGE) == ACTRL_CERTSRV_MANAGE &&
           EqualSid((PSID)&pAce->SidStart, pSid))
        {
            fAllowed = true;
            break;
        }
    }

error:
    return hr;
}

HRESULT CertSvrCA::AllowCAFullControl(
    PSECURITY_DESCRIPTOR pSDRead,
    PSID pSid,
    PSECURITY_DESCRIPTOR& pSDWrite)
{
    HRESULT hr = S_OK;
    BOOL fRet = 0;
    LPBYTE pSDTemp = NULL;
    PACL pDaclWrite = NULL;
    PACL pDaclRead = NULL; // no free
    PVOID pAce = NULL; // no free
    DWORD dwAbsoluteSDSize = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;
    DWORD dwOwnerSize = 0;
    DWORD dwGroupSize = 0;
    DWORD dwSDWriteSize = 0;
    DWORD dwDaclWriteSize = 0;

    hr = myGetSecurityDescriptorDacl(
        pSDRead,
        &pDaclRead);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");
    
    fRet = MakeAbsoluteSD(
        pSDRead,
        NULL,
        &dwAbsoluteSDSize,
        NULL,
        &dwDaclSize,
        NULL,
        &dwSaclSize,
        NULL,
        &dwOwnerSize,
        NULL,
        &dwGroupSize); // should always fail with insufficient buffer
    if(fRet || ERROR_INSUFFICIENT_BUFFER!=GetLastError())
    {
        hr = fRet?E_FAIL:HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "MakeAbsoluteSD");
    }

    // alloc all buffers together
    pSDTemp = (LPBYTE)LocalAlloc(
        LMEM_FIXED,
        dwAbsoluteSDSize+dwDaclSize+dwSaclSize+dwOwnerSize+dwGroupSize);
    _JumpIfAllocFailed(pSDTemp, error);
    
    fRet = MakeAbsoluteSD(
        pSDRead,
        (PSECURITY_DESCRIPTOR)pSDTemp,
        &dwAbsoluteSDSize,
        (PACL)(pSDTemp+dwAbsoluteSDSize),
        &dwDaclSize,
        (PACL)(pSDTemp+dwAbsoluteSDSize+dwDaclSize),
        &dwSaclSize,
        (PSID)(pSDTemp+dwAbsoluteSDSize+dwDaclSize+dwSaclSize),
        &dwOwnerSize,
        (PSID)(pSDTemp+dwAbsoluteSDSize+dwDaclSize+dwSaclSize+dwOwnerSize),
        &dwGroupSize); // should always fail with insufficient buffer
    if(!fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "MakeAbsoluteSD");
    }

    dwDaclWriteSize = dwDaclSize+sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+
        GetLengthSid(pSid);

    pDaclWrite = (PACL) LocalAlloc(LMEM_FIXED, dwDaclWriteSize);
    _JumpIfAllocFailed(pDaclWrite, error);

    fRet = InitializeAcl(pDaclWrite, dwDaclWriteSize, ACL_REVISION_DS);
    if(!fRet)
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "InitializeAcl");
    }

    fRet = GetAce(pDaclRead, 0, &pAce);
    if(!fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetAce");
    }

    fRet = AddAce(pDaclWrite, ACL_REVISION_DS, 0, pAce, dwDaclSize-sizeof(ACL));
    if(!fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "AddAce");
    }

    fRet = AddAccessAllowedAce(
        pDaclWrite,
        ACL_REVISION_DS,
        ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS,
        pSid);
    if(!fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "AddAccessAllowedAce");
    }

    fRet = SetSecurityDescriptorDacl(
        pSDTemp,
        TRUE,
        pDaclWrite,
        FALSE);
    if(!fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    fRet = MakeSelfRelativeSD(
        pSDTemp,
        NULL,
        &dwSDWriteSize);
    if(fRet || ERROR_INSUFFICIENT_BUFFER!=GetLastError())
    {
        hr = fRet?E_FAIL:HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

    pSDWrite = LocalAlloc(LMEM_FIXED, dwSDWriteSize);
    _JumpIfAllocFailed(pSDWrite, error);

    fRet = MakeSelfRelativeSD(
        pSDTemp,
        pSDWrite,
        &dwSDWriteSize);
    if(!fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

error:

    LOCAL_FREE(pSDTemp);
    LOCAL_FREE(pDaclWrite);
    return hr;
}


BOOL  CertSvrCA::FIsUsingDS()
{
    DWORD dwRet;
    variant_t varUsingDS;

    if (m_fIsUsingDSKnown)
       return m_fIsUsingDS;

    dwRet = GetConfigEntry(
            NULL,
            wszREGCAUSEDS,
            &varUsingDS);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");

    CSASSERT ((V_VT(&varUsingDS)== VT_I4));
    m_fIsUsingDS = V_I4(&varUsingDS);

Ret:
    m_fIsUsingDSKnown = TRUE;
    return m_fIsUsingDS;
}

BOOL  CertSvrCA::FIsAdvancedServer()
{
    HRESULT hr = S_OK;
    variant_t var;
    ICertAdmin2Ptr pCertAdmin;
    CString strCADN, strCALDAP = L"LDAP://";
    IADsPtr pADs;

    if (!m_fAdvancedServerKnown)
    {

	    hr = m_pParentMachine->GetAdmin2(&pCertAdmin);
        if(S_OK==hr)
        {

	        hr = pCertAdmin->GetCAProperty(
		        m_bstrConfig,
		        CR_PROP_ADVANCEDSERVER, // PropId 
		        0, // Index
		        PROPTYPE_LONG, // PropType 
		        0, // Flags 
		        &var);
        }
	    if(S_OK != hr)
        {
            // couldn't figure it out from CA, try DS
            DWORD dwFlags;
            hr = GetCAFlagsFromDS(&dwFlags);
            _JumpIfError(hr, error, "GetCAFlags");
            
            m_fAdvancedServer = 
                (dwFlags & CA_FLAG_CA_SERVERTYPE_ADVANCED)?
                TRUE:
                FALSE;
            m_fAdvancedServerKnown = TRUE;
        }
        else
        {
            CSASSERT ((V_VT(&var)== VT_I4));
            m_fAdvancedServer = V_I4(&var);
            m_fAdvancedServerKnown = TRUE;
        }
        _JumpIfError(hr, error, "GetCAProperty");
    }

error:

    return m_fAdvancedServer;
}


ENUM_CATYPES CertSvrCA::GetCAType()
{
    DWORD dwRet;
    variant_t varCAType;

    if (m_fCATypeKnown)
        return m_enumCAType;

    dwRet = GetConfigEntry(
            NULL,
            wszREGCATYPE, 
            &varCAType);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");

    CSASSERT ((V_VT(&varCAType)== VT_I4));
    m_enumCAType = (ENUM_CATYPES)V_I4(&varCAType);

Ret:
    m_fCATypeKnown = TRUE;
    return m_enumCAType;
}

BOOL CertSvrCA::FIsIncompleteInstallation()
{
    DWORD dwStatus;

    if (S_OK == GetSetupStatus(m_strSanitizedName, &dwStatus))
    {
        if(SETUP_SUSPEND_FLAG & dwStatus)
            return TRUE;
    }

    return FALSE;
}

BOOL CertSvrCA::FIsRequestOutstanding()
{
    DWORD dwStatus;

    if (S_OK == GetSetupStatus(m_strSanitizedName, &dwStatus))
    {
        if(SETUP_REQUEST_FLAG & dwStatus)
            return TRUE;
    }

    return FALSE;
}

BOOL CertSvrCA::FDoesSecurityNeedUpgrade()
{
    DWORD dwStatus;

    if (S_OK == GetSetupStatus(m_strSanitizedName, &dwStatus))
    {
        if(SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG & dwStatus)
            return TRUE;
    }

    return FALSE;
}

BOOL  CertSvrCA::FDoesServerAllowForeignCerts()
{
    HRESULT hr;
    DWORD dwStatus;
    variant_t varKRAFlags;

    hr = GetConfigEntry(
         NULL,
         wszREGKRAFLAGS,
         &varKRAFlags);
    _JumpIfError(hr, Ret, "GetConfigEntry");

    CSASSERT ((V_VT(&varKRAFlags)== VT_I4));
    dwStatus = V_I4(&varKRAFlags);

    return ((dwStatus & KRAF_ENABLEFOREIGN) != 0);

Ret:
    return FALSE;
}




DWORD CertSvrCA::GetCACertByKeyIndex(PCCERT_CONTEXT* ppCertCtxt, int iKeyIndex)
{
    // don't cache CA cert

    DWORD dwErr;
    ICertAdmin2* pCertAdmin = NULL; // must free this!!
	VARIANT varPropertyValue;
	VariantInit(&varPropertyValue);

    *ppCertCtxt = NULL;

	dwErr = m_pParentMachine->GetAdmin2(&pCertAdmin);
    _JumpIfError(dwErr, Ret, "GetAdmin2");
	
	// To get key's Cert
	dwErr = pCertAdmin->GetCAProperty(
		m_bstrConfig,
		CR_PROP_CASIGCERT, // PropId 
		iKeyIndex, // PropIndex key index 
		PROPTYPE_BINARY, // PropType 
		CR_OUT_BINARY, // Flags 
		&varPropertyValue);
	_JumpIfError(dwErr, Ret, "GetCAProperty");

	// varPropertyValue.vt will be VT_BSTR
	if (VT_BSTR != varPropertyValue.vt)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		_JumpError(dwErr, Ret, "GetCAProperty");
	}

    *ppCertCtxt = CertCreateCertificateContext(
        CRYPT_ASN_ENCODING,
        (PBYTE)varPropertyValue.bstrVal,
        SysStringByteLen(varPropertyValue.bstrVal));
    if (*ppCertCtxt == NULL)
    {
        dwErr = GetLastError();
        _JumpError(dwErr, Ret, "CertCreateCertContext");
    }

    dwErr = ERROR_SUCCESS;
Ret:
    VariantClear(&varPropertyValue);

    if (pCertAdmin)
        pCertAdmin->Release();

    return dwErr;
}


DWORD CertSvrCA::GetCurrentCRL(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL)
{
	return GetCRLByKeyIndex(ppCRLCtxt, fBaseCRL, -1);
}

DWORD CertSvrCA::GetCRLByKeyIndex(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL, int iKeyIndex)
{
    // don't cache CRL

    DWORD dwErr;
    ICertAdmin2* pCertAdmin = NULL; // must free this!!
	VARIANT varPropertyValue;
	VariantInit(&varPropertyValue);

    *ppCRLCtxt = NULL;

    dwErr = m_pParentMachine->GetAdmin2(&pCertAdmin);
    _JumpIfError(dwErr, Ret, "GetAdmin2");
	
	// To get each key's BASE CRL
	dwErr = pCertAdmin->GetCAProperty(
		m_bstrConfig,
		fBaseCRL ? CR_PROP_BASECRL : CR_PROP_DELTACRL, // PropId 
		iKeyIndex, // PropIndex key index 
		PROPTYPE_BINARY, // PropType 
		CR_OUT_BINARY, // Flags 
		&varPropertyValue);
	_JumpIfError(dwErr, Ret, "GetCAProperty");

	// varPropertyValue.vt will be VT_BSTR
	if (VT_BSTR != varPropertyValue.vt)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		_JumpError(dwErr, Ret, "GetCAProperty");
	}


    *ppCRLCtxt = CertCreateCRLContext(
        CRYPT_ASN_ENCODING,
        (PBYTE)varPropertyValue.bstrVal,
        SysStringByteLen(varPropertyValue.bstrVal));
    if (*ppCRLCtxt == NULL)
    {
        dwErr = GetLastError();
        _JumpError(dwErr, Ret, "CertCreateCRLContext");
    }

    dwErr = ERROR_SUCCESS;
Ret:
    VariantClear(&varPropertyValue);

    if (pCertAdmin)
        pCertAdmin->Release();

    return dwErr;
}


HRESULT CertSvrCA::GetConfigEntry(
    LPWSTR szConfigSubKey,
    LPWSTR szConfigEntry,
    VARIANT *pvarOut)
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszLocalMachine = NULL;
    CString strConfig = m_pParentMachine->m_strMachineName;

    if(m_pParentMachine->m_strMachineName.IsEmpty())
    {
        hr = myGetMachineDnsName(&pwszLocalMachine);
        _JumpIfError(hr, Err, "myGetMachineDnsName");
        strConfig = pwszLocalMachine;
    }
    
    strConfig += L"\\";
    strConfig += m_strSanitizedName;

    VariantInit(pvarOut);

	hr = m_pParentMachine->GetAdmin2(&pAdmin, true);
    _JumpIfError(hr, Err, "GetAdmin2");

    hr = pAdmin->GetConfigEntry(
            strConfig.GetBuffer(),
            szConfigSubKey,
            szConfigEntry,
            pvarOut);
    _JumpIfError2(hr, Err, "GetConfigEntry", 
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

Err:
    LOCAL_FREE(pwszLocalMachine);
    return hr;
}



HRESULT CertSvrCA::SetConfigEntry(
    LPWSTR szConfigSubKey,
    LPWSTR szConfigEntry,
    VARIANT *pvarIn)
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszLocalMachine = NULL;
    CString strConfig = m_pParentMachine->m_strMachineName;

    if(m_pParentMachine->m_strMachineName.IsEmpty())
    {
        hr = myGetMachineDnsName(&pwszLocalMachine);
        _JumpIfError(hr, Err, "myGetMachineDnsName");
        strConfig = pwszLocalMachine;
    }
    
    strConfig += L"\\";
    strConfig += m_strSanitizedName;

	hr = m_pParentMachine->GetAdmin2(&pAdmin, true);
    _JumpIfError(hr, Err, "GetAdmin2");

    hr = pAdmin->SetConfigEntry(
            strConfig.GetBuffer(),
            szConfigSubKey,
            szConfigEntry,
            pvarIn);
    _JumpIfError(hr, Err, "SetConfigEntry");

Err:
    LOCAL_FREE(pwszLocalMachine);
    return hr;
}

////////////////////////////////////////////////////////////////
// CertStor stub
DWORD CertSvrCA::GetRootCertStore(HCERTSTORE* phCertStore)
{
    if (m_fRootStoreOpenAttempted)
    {
        *phCertStore = m_hRootCertStore;
        return m_hrRootCertStoreOpen;
    }
    m_fRootStoreOpenAttempted = TRUE;

    LONG dwRet;
    CString cstrCertStorePath;
    
    if (! m_pParentMachine->IsLocalMachine())
    {
        // if remote, prefix with "\\mattt3\"
        cstrCertStorePath = m_strServer;
        cstrCertStorePath += L"\\";
    }
    cstrCertStorePath += L"ROOT";

    m_hRootCertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM,
        CRYPT_ASN_ENCODING,
        NULL,   // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE | 
        CERT_STORE_OPEN_EXISTING_FLAG   |
        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
        (const void *)(LPCWSTR)cstrCertStorePath);
    if (m_hRootCertStore == NULL)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CertOpenStore");
    }
   
    dwRet = ERROR_SUCCESS;
Ret:
    *phCertStore = m_hRootCertStore;
    m_hrRootCertStoreOpen = HRESULT_FROM_WIN32(dwRet);

    return dwRet;
}

DWORD CertSvrCA::GetCACertStore(HCERTSTORE* phCertStore)
{
    if (m_fCertStoreOpenAttempted)
    {
        *phCertStore = m_hCACertStore;
        return m_hrCACertStoreOpen;
    }
    m_fCertStoreOpenAttempted = TRUE;

    LONG dwRet;
    CString cstrCertStorePath;
    
    if (! m_pParentMachine->IsLocalMachine())
    {
        // if remote, prefix with "\\mattt3\"
        cstrCertStorePath = m_strServer;
        cstrCertStorePath += L"\\";
    }
	cstrCertStorePath += wszCA_CERTSTORE;

    m_hCACertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM,
        CRYPT_ASN_ENCODING,
        NULL,   // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE | 
        CERT_STORE_OPEN_EXISTING_FLAG   |
        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
        (const void *)(LPCWSTR)cstrCertStorePath);
    if (m_hCACertStore == NULL)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CertOpenStore");
    }
   
    dwRet = ERROR_SUCCESS;
Ret:

    *phCertStore = m_hCACertStore;
    m_hrCACertStoreOpen = HRESULT_FROM_WIN32(dwRet);

    return dwRet;
}

DWORD CertSvrCA::GetKRACertStore(HCERTSTORE* phCertStore)
{
    if (m_fKRAStoreOpenAttempted)
    {
        *phCertStore = m_hKRACertStore;
        return m_hrKRACertStoreOpen;
    }
    m_fKRAStoreOpenAttempted = TRUE;

    LONG dwRet;
    CString cstrCertStorePath;
    
    if (! m_pParentMachine->IsLocalMachine())
    {
        // if remote, prefix with "\\mattt3\"
        cstrCertStorePath = m_strServer;
        cstrCertStorePath += L"\\";
    }
    cstrCertStorePath += wszKRA_CERTSTORE;

    m_hKRACertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM,
        CRYPT_ASN_ENCODING,
        NULL,   // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE|
        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
        (const void *)(LPCWSTR)cstrCertStorePath);
    if (m_hKRACertStore == NULL)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CertOpenStore");
    }
   
    dwRet = ERROR_SUCCESS;
Ret:
    *phCertStore = m_hKRACertStore;
    m_hrKRACertStoreOpen = HRESULT_FROM_WIN32(dwRet);

    return dwRet;
}

//////////////////////////
// CertSvrMachine class
CertSvrMachine::CertSvrMachine()
{
    m_dwServiceStatus = ERROR_SERVICE_NOT_ACTIVE;

    m_hCachedConfigBaseKey = NULL;
    m_bAttemptedBaseKeyOpen = FALSE;
    
    m_fLocalIsKnown = FALSE;

    m_fIsWhistlerMachine = FALSE;
    m_fIsWhistlerMachineKnown = FALSE;

    m_cRef = 1; // one "Release()" will initiate clean up

}

CertSvrMachine::~CertSvrMachine()
{
    CSASSERT(m_cRef == 0);
    // delete any CAs that we still hold on to -- we own this memory
    for (int i=0; i<m_CAList.GetSize(); i++)
    {
        delete m_CAList[i];
    }

    Init();
}

void CertSvrMachine::Init()
{
    // on initialization, caller owns memory contents of m_CAList --
    // we no longer do
    m_dwServiceStatus = ERROR_SERVICE_NOT_ACTIVE;

    if (m_hCachedConfigBaseKey)
    {
        RegCloseKey(m_hCachedConfigBaseKey);
        m_hCachedConfigBaseKey = NULL;
    }
    m_bAttemptedBaseKeyOpen = FALSE;

    // clean other objects
    m_CAList.Init();    // scope owns memory
    m_strMachineNamePersist.Init();
    m_strMachineName.Init();
}


BOOL CertSvrMachine::FIsWhistlerMachine()
{
    HRESULT hr = S_OK;
    VARIANT varTmp;
    VariantInit(&varTmp);

    if(!m_fIsWhistlerMachineKnown)
    {
        hr = GetRootConfigEntry(
                wszREGVERSION,
                &varTmp);
        _JumpIfError(hr, Err, "GetConfigEntry");

    DBGPRINT((DBG_SS_INFO, "Found version: 0x%x", V_I4(&varTmp)));

        CSASSERT ((V_VT(&varTmp)== VT_I4));
        m_fIsWhistlerMachine =  (V_I4(&varTmp) >= CSVER_WHISTLER); // bigger than or equal to major Whistler version? return TRUE!
        m_fIsWhistlerMachineKnown = TRUE;
    }

Err:

    VariantClear(&varTmp);
    return m_fIsWhistlerMachine;
}

HRESULT CertSvrMachine::GetRootConfigEntry(
    LPWSTR szConfigEntry,
    VARIANT *pvarOut)
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszLocalMachine = NULL;
    CString strConfig = m_strMachineName;

    if(m_strMachineName.IsEmpty())
    {
        hr = myGetMachineDnsName(&pwszLocalMachine);
        _JumpIfError(hr, Err, "myGetMachineDnsName");
        strConfig = pwszLocalMachine;
    }
    
    VariantInit(pvarOut);

    hr = GetAdmin2(&pAdmin, true);
    _JumpIfError(hr, Err, "GetAdmin2");

    hr = pAdmin->GetConfigEntry(
            strConfig.GetBuffer(),
            NULL,
            szConfigEntry,
            pvarOut);
    _JumpIfError(hr, Err, "GetConfigEntry");

Err:
    LOCAL_FREE(pwszLocalMachine);
    return hr;

}

HRESULT CertSvrMachine::GetAdmin(ICertAdmin** ppAdmin)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;

    if (!IsCertSvrServiceRunning())
    {
        *ppAdmin = NULL;
        return RPC_S_NOT_LISTENING;
    }

    // ensure this thread initialized
    hr = CoInitialize(NULL);
    if ((S_OK == hr) || (S_FALSE == hr))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();

    return hr;
}

HRESULT CertSvrMachine::GetAdmin2(
    ICertAdmin2** ppAdmin, 
    bool fIgnoreServiceDown /* = false*/)
{
    HRESULT hr = S_OK, hr1;
    BOOL fCoInit = FALSE;

    if (!fIgnoreServiceDown && !IsCertSvrServiceRunning())
    {
        *ppAdmin = NULL;
        return RPC_S_NOT_LISTENING;
    }

    hr1 = CoInitialize(NULL);
    if ((S_OK == hr1) || (S_FALSE == hr1))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin2,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();


    return hr;
}

#define STARTSTOP_MAX_RETRY_SECONDS 30

DWORD CertSvrMachine::CertSvrStartStopService(HWND hwndParent, BOOL fStartSvc)
{
    DWORD       dwRet;
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager = NULL;
    SERVICE_STATUS ServiceStatus;
    HANDLE hProgressDlg = NULL;
    DWORD dwAttempts = 0;

    CWaitCursor cwait;

    schSCManager = OpenSCManagerW(
                        GetNullMachineName(&m_strMachineName),// machine (NULL == local)
                        NULL,               // database (NULL == default)
                        SC_MANAGER_CONNECT  // access required
                        );
    if ( NULL == schSCManager )
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenSCManagerW");
    }

    schService = OpenServiceW(
                    schSCManager,
                    wszSERVICE_NAME,
                    ( fStartSvc ? SERVICE_START : SERVICE_STOP ) | SERVICE_QUERY_STATUS 
                    );

    if (NULL == schService)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenServiceW");
    }


    // UNDONE: TRY/EXCEPT
    hProgressDlg = StartProgressDlg(
                        g_hInstance, 
                        hwndParent, 
                        STARTSTOP_MAX_RETRY_SECONDS, 
                        0,
                        fStartSvc ? IDS_STARTING_SVC : IDS_STOPPING_SVC);

    //
    // try to start the service
    //
    if (fStartSvc)
    {
        if (!StartService( schService, 0, NULL))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_SERVICE_ALREADY_RUNNING)
                dwRet = ERROR_SUCCESS;
            _JumpError2(dwRet, Ret, "StartService", ERROR_SUCCESS);
        }
    }
    else
    {
        if (! ControlService( schService, SERVICE_CONTROL_STOP, &ServiceStatus ) )
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_SERVICE_NOT_ACTIVE)
                dwRet = ERROR_SUCCESS;
            _JumpError2(dwRet, Ret, "ControlService", ERROR_SUCCESS);
        }
    }

    while( QueryServiceStatus( schService, &ServiceStatus ) )
    {
        //
        // FProgressDlgRunning sets upper time bound on loop 
        //

        if( !FProgressDlgRunning() )
            break;

        if (fStartSvc)
        {
            // demorgan's on (pending OR (running AND !pausable))

            if ((ServiceStatus.dwCurrentState != (DWORD) SERVICE_START_PENDING) &&      // not pending AND
                ((ServiceStatus.dwCurrentState != (DWORD) SERVICE_RUNNING) ||           // (not running OR is pausable)
                 (0 != (ServiceStatus.dwControlsAccepted & (DWORD) SERVICE_ACCEPT_PAUSE_CONTINUE) )) )
               break;
        }
        else
        {
            if (ServiceStatus.dwCurrentState != (DWORD) SERVICE_STOP_PENDING)
                break;
        }

        Sleep( 500 );
    }

    if ( ServiceStatus.dwCurrentState != (DWORD)(fStartSvc ? SERVICE_RUNNING : SERVICE_STOPPED))
    {
        dwRet = ServiceStatus.dwWin32ExitCode;

        if (ERROR_SERVICE_SPECIFIC_ERROR  == dwRet)
            dwRet = ServiceStatus.dwServiceSpecificExitCode;

        _JumpError(dwRet, Ret, "ServiceStatus.dwServiceSpecificExitCode");
    }

    dwRet = ERROR_SUCCESS;


Ret:
    if (hProgressDlg)
        EndProgressDlg(hProgressDlg);

    if (schService)
        CloseServiceHandle(schService);
    if (schSCManager)
        CloseServiceHandle(schSCManager);

    if (ERROR_SUCCESS == dwRet)
        m_dwServiceStatus = ServiceStatus.dwCurrentState;
    else
        m_dwServiceStatus = SERVICE_STOPPED;

    return dwRet;
}

DWORD CertSvrMachine::RefreshServiceStatus()
{
    DWORD       dwRet;
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager = NULL;
    SERVICE_STATUS ServiceStatus;

    HCURSOR hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    m_dwServiceStatus = 0;

    schSCManager = OpenSCManagerW(
                        GetNullMachineName(&m_strMachineName),// machine (NULL == local)
                        NULL,               // database (NULL == default)
                        SC_MANAGER_CONNECT  // access required
                        );
    if ( NULL == schSCManager )
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenSCManagerW");
    }

    schService = OpenServiceW(
                    schSCManager,
                    wszSERVICE_NAME,
                    SERVICE_INTERROGATE
                    );

    if (NULL == schService)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenServiceW");
    }


    if (!ControlService(schService, SERVICE_CONTROL_INTERROGATE, &ServiceStatus) )
    {
        dwRet = GetLastError();
        if (dwRet != ERROR_SERVICE_NOT_ACTIVE)
        {
            _JumpError(dwRet, Ret, "ControlService");
        }
    }

    m_dwServiceStatus = ServiceStatus.dwCurrentState;

    
    dwRet = ERROR_SUCCESS;
Ret:
    SetCursor(hPrevCur);

    if (schService)
        CloseServiceHandle(schService);
    if (schSCManager)
        CloseServiceHandle(schSCManager);

    return dwRet;
}

LPCWSTR CertSvrMachine::GetCaCommonNameAtPos(DWORD iPos)
{
//    if (iPos > (m_cCAList-1))
    if (iPos > (DWORD)m_CAList.GetUpperBound())
        return NULL;

    return GetCaAtPos(iPos)->m_strCommonName;
}

CertSvrCA* CertSvrMachine::GetCaAtPos(DWORD iPos)
{
//    if (iPos > (m_cCAList-1))
    if (iPos > (DWORD)m_CAList.GetUpperBound())
        return NULL;

    return m_CAList[iPos];
//    return m_rgpCAList[iPos];
}

DWORD CertSvrMachine::PrepareData(HWND hwndParent)
{
    // hwndParent: we will display a dlg describing what we're waiting for

    HANDLE hDlg = NULL;
    DWORD dwRet; 
    
    __try
    {
        CSASSERT(hwndParent);
        hDlg = StartProgressDlg(g_hInstance, hwndParent, 10, 0, IDS_CA_REDISCOVER);    // don't time out
   
        dwRet = RefreshServiceStatus();
        _LeaveIfError(dwRet, "RefreshServiceStatus");
    
        dwRet = RetrieveCertSvrCAs(0);
        _LeaveIfError(dwRet, "RetrieveCertSvrCAs");
    }
    __finally
    {
        if (hDlg)
            EndProgressDlg(hDlg);
    }

    return dwRet;
}



#include "csdisp.h"
LPWSTR szConfigFieldDescription[] = 
{
    L"Server",
    L"CommonName",
    L"OrgUnit",
    L"Organization",
    L"Locality",
    L"State",
    L"Country",
    L"Config",
    L"Comment",
};

DWORD
CertSvrMachine::RetrieveCertSvrCAs(
    IN DWORD Flags)
{
    HRESULT hr;
    LONG i, iEntries;
    LONG count=0, Index;
    LPWSTR szTargetMachine = NULL;
    LPWSTR szTargetMachine2 = NULL;
    WCHAR* szRegActive; // no delete;
    LPWSTR pwszzCAList = NULL;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszSanitizedName = NULL;
            LPWSTR pwszCAList = NULL;
            size_t len;
    bool fNameIsAlreadySanitized = false;
    DWORD dwVersion;

    // init var containing machine sans whacks
    Index = sizeof(szTargetMachine);
    if (!m_strMachineName.IsEmpty())
    {
        const WCHAR* pch = (LPCWSTR)m_strMachineName;
        // skip whack whack
        if ((pch[0] == '\\') && (pch[1] == '\\'))
            pch+=2;
        
        szTargetMachine = (LPWSTR)LocalAlloc(LPTR, WSZ_BYTECOUNT(pch));
        _JumpIfOutOfMemory(hr, error, szTargetMachine);

        wcscpy(szTargetMachine, pch);
    }
    else
    {
        hr = myGetComputerNames(&szTargetMachine, &szTargetMachine2);
        _JumpIfError(hr, error, "myGetComputerNames");
    }

    // Don't go to DS for this, just RegConnect
    // DS would give us: strConfig, szMachine, and Template info.
    // we already can derive strConfig, szMachine; we weren't using template info here

    // look for CAs that aren't yet completely set up
    do 
    {
        HKEY hBaseKey;  // this is cached
        DWORD cbOut, dwType;

        hr = myPingCertSrv(
                   szTargetMachine,
                   NULL,
                   &pwszzCAList,
                   NULL,
                   NULL,
                   &dwVersion,
                   NULL);

        if(S_OK==hr)
        {
            if(dwVersion<2)
                hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
            _JumpIfError(hr, error, "Whistler CA snapin cannot connect to older CAs");
        }


        // If for any reason we couldn't ping the CA, fail over to 
        // registry; we currently support only one CA per machine, if this
        // changes in the future, replace the code below with an enumeration
        // of nodes under configuration regkey.
        if(S_OK!=hr)
        {
            hr = myGetCertRegValue(
                szTargetMachine,
                NULL,
                NULL,
                NULL,
                wszREGACTIVE,
                (BYTE**)&pwszCAList,
                NULL,
                &dwType);
            _JumpIfError(hr, error, "myGetCertRegValue");

            CSASSERT(dwType==REG_SZ);

            len = wcslen(pwszCAList)+1;
            pwszzCAList = (LPWSTR)LocalAlloc(LMEM_FIXED, (len+1)*sizeof(WCHAR));
            _JumpIfAllocFailed(pwszzCAList, error);

            wcscpy(pwszzCAList, pwszCAList);
            pwszzCAList[len] = L'\0';

            // regactive gives us already sanitized ca name
            fNameIsAlreadySanitized = true;
        }
        _JumpIfError(hr, error, "myPingCertSrv");

        szRegActive = pwszzCAList;

        while (szRegActive[0] != '\0') // while we don't hit end-of-string
        {
            for (int ii=0; ii<m_CAList.GetSize(); ii++)
            {
                // Common name match? break early
                if (m_CAList[ii]->m_strCommonName.IsEqual(szRegActive))
                    break;
            }

            // not found?
            if (ii == m_CAList.GetSize())
            {
                // and insert it into the list
                CertSvrCA* pIssuer = new CertSvrCA(this);
                _JumpIfOutOfMemory(hr, error, pIssuer);

                pIssuer->m_strServer = szTargetMachine;

                if(!fNameIsAlreadySanitized)
                {
                    hr = mySanitizeName(szRegActive, &pwszSanitizedName);
                    _JumpIfError(hr, error, "mySanitizeName");

                    pIssuer->m_strSanitizedName = pwszSanitizedName;
                }
                else
                {
                    pIssuer->m_strSanitizedName = szRegActive;
                }

                LPWSTR pszString = NULL;
                DWORD cbString = 0;
                variant_t varCommonName;
            
                // get prettified common name 
                hr = pIssuer->GetConfigEntry(
                        NULL, 
                        wszREGCOMMONNAME, 
                        &varCommonName);
                _JumpIfError(hr, error, "GetConfigEntry");

                if (V_VT(&varCommonName)!=VT_BSTR || 
                    V_BSTR(&varCommonName)==NULL)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                    _JumpError(hr, error, "GetConfigEntry");
                }

                pIssuer->m_strCommonName = V_BSTR(&varCommonName);
                varCommonName.Clear();

                // config is common name (not sanitized)
                pIssuer->m_strConfig = szTargetMachine;
                pIssuer->m_strConfig += L"\\";
                pIssuer->m_strConfig += pIssuer->m_strCommonName;

                // Last: get description if exists
                if (S_OK == pIssuer->GetConfigEntry(
                        NULL, 
                        wszREGCADESCRIPTION, 
                        &varCommonName))
                {
                    if (V_VT(&varCommonName)==VT_BSTR &&
                        V_BSTR(&varCommonName)!=NULL)
                    {
                        pIssuer->m_strComment = V_BSTR(&varCommonName);
                    }
                }

                // create oft-used bstr 
                pIssuer->m_bstrConfig = pIssuer->m_strConfig.AllocSysString();
                _JumpIfOutOfMemory(hr, error, pIssuer->m_bstrConfig);

                m_CAList.Add(pIssuer);
            }

            // REG_MULTI_SZ: fwd to next string
            szRegActive += wcslen(szRegActive)+1;
        }

    } while(0);

error:

    LOCAL_FREE(pwszzCAList);
    LOCAL_FREE(pwszSanitizedName);
    LOCAL_FREE(pwszCAList);

    if (szTargetMachine)
        LocalFree(szTargetMachine);

    if (szTargetMachine2)
        LocalFree(szTargetMachine2);

    return(hr);
}


STDMETHODIMP 
CertSvrMachine::Load(IStream *pStm)
{
    CSASSERT(pStm);
    HRESULT hr;

    // no header magic ?

    // Read the string
    hr = CStringLoad(m_strMachineNamePersist, pStm);
    m_strMachineName = m_strMachineNamePersist;

    if (FAILED(hr))
        return E_FAIL;

    return S_OK;
}

STDMETHODIMP 
CertSvrMachine::Save(IStream *pStm, BOOL fClearDirty)
{
    CSASSERT(pStm);
    HRESULT hr;

    // no header magic ?

    // save the string
    hr = CStringSave(m_strMachineNamePersist, pStm, fClearDirty);
    _PrintIfError(hr, "CStringSave");

    // Verify that the write operation succeeded
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    return S_OK;
}

STDMETHODIMP CertSvrMachine::GetSizeMax(int *pcbSize)
{
    CSASSERT(pcbSize);

    *pcbSize = (m_strMachineNamePersist.GetLength()+1)* sizeof(WCHAR);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\certif.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certif.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "csprop.h"
#include "ciinit.h"

FNCIGETPROPERTY PropCIGetProperty;
FNCISETPROPERTY PropCISetProperty;
FNCIGETEXTENSION PropCIGetExtension;
FNCISETPROPERTY PropCISetExtension;
FNCIENUMSETUP PropCIEnumSetup;
FNCIENUMNEXT PropCIEnumNext;
FNCIENUMCLOSE PropCIEnumClose;

SERVERCALLBACKS ThunkedCallbacks = 
{
    PropCIGetProperty,  //    FNCIGETPROPERTY  *pfnGetProperty;
    PropCISetProperty,  //    FNCISETPROPERTY  *pfnSetProperty;
    PropCIGetExtension, //    FNCIGETEXTENSION *pfnGetExtension;
    PropCISetExtension, //    FNCISETEXTENSION *pfnSetExtension;
    PropCIEnumSetup,    //    FNCIENUMSETUP    *pfnEnumSetup;
    PropCIEnumNext,     //    FNCIENUMNEXT     *pfnEnumNext;
    PropCIEnumClose,    //    FNCIENUMCLOSE    *pfnEnumClose;
};

CertSvrCA* g_pCA = NULL;

HRESULT ThunkServerCallbacks(CertSvrCA* pCA)
{
    HRESULT hr = S_OK;
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        fInitialized = TRUE;

        // initialize certif.dll
        hr = CertificateInterfaceInit(
            &ThunkedCallbacks,
            sizeof(ThunkedCallbacks));

    }
    
    g_pCA = pCA;

    return hr;
}




HRESULT
PropCIGetProperty(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    
    if (NULL != pvarPropertyValue)
    {
        VariantInit(pvarPropertyValue);
    }
    if (NULL == pwszPropertyName || NULL == pvarPropertyValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    
    hr = E_INVALIDARG;
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY &&
        (PROPCALLER_MASK & Flags) != PROPCALLER_EXIT)
    {
        _JumpError(hr, error, "Flags: Invalid caller");
    }
    
    // Special, hard-coded properties we need to support
    if (0 == lstrcmpi(pwszPropertyName, wszPROPCATYPE))
    {
        ENUM_CATYPES caType = g_pCA->GetCAType();
        hr = myUnmarshalVariant(
		        Flags,
		        sizeof(DWORD),
		        (PBYTE)&caType,
		        pvarPropertyValue);
        _JumpIfError(hr, error, "myUnmarshalVariant");
    }
    else if (0 == lstrcmpi(pwszPropertyName, wszPROPUSEDS))
    {
       BOOL fUseDS = g_pCA->FIsUsingDS();
       hr = myUnmarshalVariant(
                        Flags,
                        sizeof(BOOL),
                        (PBYTE)&fUseDS,
                        pvarPropertyValue);
        _JumpIfError(hr, error, "myUnmarshalVariant");
    }
    else
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
    }

error:

    return(myHError(hr));
}




HRESULT
PropCISetProperty(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue)
{
    return E_NOTIMPL;
}



HRESULT
PropCIGetExtension(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue)
{
    return E_NOTIMPL;
}


HRESULT
PropCISetExtension(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue)
{
    return E_NOTIMPL;
}



HRESULT 
PropCIEnumSetup(
    IN LONG Context,
    IN LONG Flags,
    IN OUT CIENUM *pciEnum)
{
    return E_NOTIMPL;
}



HRESULT PropCIEnumNext(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName)
{
    return E_NOTIMPL;
}


HRESULT PropCIEnumClose(
    IN OUT CIENUM *pciEnum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\certwrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certwrap.h
//
//--------------------------------------------------------------------------

#ifndef _CERTWRAP_H_
#define _CERTWRAP_H_

#include <iads.h>
#include <adshlp.h>

// fwd
class CertSvrMachine;


class CertSvrCA
{
protected:

    HCERTSTORE          m_hCACertStore;          // our cert store
    BOOL                m_fCertStoreOpenAttempted;
    HRESULT             m_hrCACertStoreOpen;

    HCERTSTORE          m_hRootCertStore;        // root store on machine
    BOOL                m_fRootStoreOpenAttempted;
    HRESULT             m_hrRootCertStoreOpen;

    HCERTSTORE          m_hKRACertStore;        // KRA store on machine
    BOOL                m_fKRAStoreOpenAttempted;
    HRESULT             m_hrKRACertStoreOpen;

    BOOL 		m_fIsUsingDS;
    BOOL 		m_fIsUsingDSKnown;

    ENUM_CATYPES	m_enumCAType;
    BOOL 		m_fCATypeKnown;

    BOOL m_fAdvancedServer;
    BOOL m_fAdvancedServerKnown;

    DWORD m_dwRoles;
    BOOL  m_fRolesKnown;


public:
    CertSvrMachine*     m_pParentMachine;

    CString m_strServer;
    CString m_strCommonName;
    CString m_strSanitizedName;
    CString m_strConfig;
    CString m_strComment;
    CString m_strCAObjectDN;

    BSTR    m_bstrConfig;   // oft used as BSTR
public:
    CertSvrCA(CertSvrMachine* pParent);
    ~CertSvrCA();

public:

    DWORD GetMyRoles();
    BOOL AccessAllowed(DWORD dwAccess);

    HRESULT GetConfigEntry(
            LPWSTR szConfigSubKey,
            LPWSTR szConfigEntry, 
            VARIANT *pvarOut);

    HRESULT SetConfigEntry(
            LPWSTR szConfigSubKey,
            LPWSTR szConfigEntry, 
            VARIANT *pvarIn);

    DWORD DeleteConfigEntry(
        LPWSTR szConfigSubKey,
        LPWSTR szConfigEntry);

    ENUM_CATYPES GetCAType();
    BOOL  FIsUsingDS();
    BOOL  FIsIncompleteInstallation();
    BOOL  FIsRequestOutstanding();
    BOOL  FIsAdvancedServer();
    BOOL  FDoesSecurityNeedUpgrade();
    BOOL  FDoesServerAllowForeignCerts();


    DWORD GetCACertStore(HCERTSTORE* phCertStore);  // class frees
    DWORD GetRootCertStore(HCERTSTORE* phCertStore); // class frees
    DWORD GetKRACertStore(HCERTSTORE* phCertStore); // class frees

	DWORD GetCurrentCRL(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL); // use CertFreeCRLContext()
	DWORD GetCRLByKeyIndex(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL, int iKeyIndex); // use CertFreeCRLContext()
	DWORD GetCACertByKeyIndex(PCCERT_CONTEXT*ppCertCtxt, int iKeyIndex); // use CertFreeCertificateContext()

    HRESULT FixEnrollmentObject();

protected:

    HRESULT IsCAAllowedFullControl(
        PSECURITY_DESCRIPTOR pSDRead,
        PSID pSid,
        bool& fAllowed);
   
    HRESULT AllowCAFullControl(
        PSECURITY_DESCRIPTOR pSDRead,
        PSID pSid,
        PSECURITY_DESCRIPTOR& pSDWrite);

    HRESULT GetCAFlagsFromDS(
        PDWORD pdwFlags);
};

class CertSvrMachine
{
friend CComponentDataImpl;

public:

// IPersistStream interface members
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(int *pcbSize);

#if DBG
    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;
#endif

public:
    CString m_strMachineNamePersist;	// Machine name to persist into .msc file
    CString m_strMachineName;           // Effective machine name

    DWORD   m_dwServiceStatus;          // 

    HKEY    m_hCachedConfigBaseKey;     // base registry key
    BOOL    m_bAttemptedBaseKeyOpen;

    BOOL 		m_fIsWhistlerMachine;
    BOOL 		m_fIsWhistlerMachineKnown;

protected:

    CArray<CertSvrCA*, CertSvrCA*> m_CAList;

public:
    CertSvrMachine();
    ~CertSvrMachine();

    ULONG AddRef() { return(InterlockedIncrement(&m_cRef)); }
    ULONG Release() 
    { 
        ULONG cRef = InterlockedDecrement(&m_cRef);

        if (0 == cRef)
        {
	    delete this;
        }
        return cRef;
    }

private:
    DWORD RetrieveCertSvrCAs(DWORD dwFlags);

    LONG m_cRef;

    BOOL m_fLocalIsKnown, m_fIsLocal;

    void Init();

public:
    HRESULT GetAdmin(ICertAdmin** ppAdmin);
    HRESULT GetAdmin2(ICertAdmin2** ppAdmin, bool fIgnoreServiceDown = false);

    // Fills local cache with CAs for current machine
    DWORD   PrepareData(HWND hwndParent);

    // enum CAs on current machine
    LPCWSTR GetCaCommonNameAtPos(DWORD iPos);
    CertSvrCA* GetCaAtPos(DWORD iPos);


    HRESULT GetRootConfigEntry(
        LPWSTR szConfigEntry,
        VARIANT *pvarOut);

    DWORD GetCaCount()
    { return m_CAList.GetSize(); }

    BOOL  FIsWhistlerMachine();

    // control CA on current machine
    DWORD   CertSvrStartStopService(HWND hwndParent, BOOL fStartSvc);
    DWORD   RefreshServiceStatus();
    DWORD   GetCertSvrServiceStatus()
        { return m_dwServiceStatus; };
    BOOL    IsCertSvrServiceRunning()
        { return (m_dwServiceStatus == SERVICE_RUNNING); };

    BOOL    IsLocalMachine() 
    { 
        if (!m_fLocalIsKnown) 
        {
            m_fLocalIsKnown = TRUE; 
            m_fIsLocal = FIsCurrentMachine(m_strMachineName);
        }
        return m_fIsLocal;
    };

};



#endif // _CERTWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\casec.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       casec.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	casec.cpp
//
//	ISecurityInformation implementation for CA objects
//  and the new acl editor
//
//	PURPOSE

//
//
//  DYNALOADED LIBRARIES
//
//	HISTORY
//	5-Nov-1998		petesk		Copied template from privobsi.cpp sample.
//
/////////////////////////////////////////////////////////////////////


#include <stdafx.h>
#include <accctrl.h>
#include <certca.h>
#include <sddl.h>
#include "certsrvd.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_CERTMMC_CASEC_CPP__


//
// defined in Security.cpp 
//
// // define our generic mapping structure for our private objects // 


#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)


GENERIC_MAPPING ObjMap = 
{     
    ACTRL_CERTSRV_READ,
    DELETE | WRITE_DAC | WRITE_OWNER | ACTRL_DS_WRITE_PROP,     
    0, 
    ACTRL_CERTSRV_MANAGE 
}; 


//
// DESCRIPTION OF ACCESS FLAG AFFECTS
//
// SI_ACCESS_GENERAL shows up on general properties page
// SI_ACCESS_SPECIFIC shows up on advanced page 
// SI_ACCESS_CONTAINER shows on general page IF object is a container
//

SI_ACCESS g_siObjAccesses[] = {CERTSRV_SI_ACCESS_LIST};

#define g_iObjDefAccess    3   // ENROLL enabled by default

// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0,                                            MAKEINTRESOURCE(IDS_INH_NONE),
};


HRESULT
LocalAllocString(LPWSTR* ppResult, LPCWSTR pString)
{
    if (!ppResult || !pString)
        return E_INVALIDARG;

    *ppResult = (LPWSTR)LocalAlloc(LPTR, (lstrlen(pString) + 1) * sizeof(WCHAR));

    if (!*ppResult)
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;
}

void
LocalFreeString(LPWSTR* ppString)
{
    if (ppString)
    {
        if (*ppString)
            LocalFree(*ppString);
        *ppString = NULL;
    }   
}

class CCASecurityObject : public ISecurityInformation
{
protected:
    ULONG                   m_cRef;
    CertSvrCA *             m_pSvrCA;
//    PSECURITY_DESCRIPTOR    m_pSD;

public:
    CCASecurityObject() : m_cRef(1) 
    { 
        m_pSvrCA = NULL;
//        m_pSD = NULL;
    }
    virtual ~CCASecurityObject();

    STDMETHOD(Initialize)(CertSvrCA *pCA);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};

///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code that establishes
//  what the ACLUI interface is going to need to know.
//
//
///////////////////////////////////////////////////////////////////////////////

extern "C"
HRESULT
CreateCASecurityInfo(  CertSvrCA *pCA,
                        LPSECURITYINFO *ppObjSI)
{
    HRESULT hr;
    CCASecurityObject *psi;

    *ppObjSI = NULL;

    psi = new CCASecurityObject;
    if (!psi)
        return E_OUTOFMEMORY;

    hr = psi->Initialize(pCA);

    if (SUCCEEDED(hr))
        *ppObjSI = psi;
    else
        delete psi;

    return hr;
}


CCASecurityObject::~CCASecurityObject()
{
}

STDMETHODIMP
CCASecurityObject::Initialize(CertSvrCA *pCA)
{
    m_pSvrCA = pCA;
    return S_OK;
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CCASecurityObject::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CCASecurityObject::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CCASecurityObject::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CCASecurityObject::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{


    if(pObjectInfo == NULL)
    {
        return E_POINTER;
    }
    if(m_pSvrCA == NULL)
    {
        return E_POINTER;
    }

    ZeroMemory(pObjectInfo, sizeof(SI_OBJECT_INFO));
    pObjectInfo->dwFlags = SI_EDIT_PERMS | 
                           SI_NO_TREE_APPLY |
                           SI_EDIT_AUDITS |
                           SI_NO_ACL_PROTECT |
                           SI_NO_ADDITIONAL_PERMISSION;

    if(!m_pSvrCA->AccessAllowed(CA_ACCESS_ADMIN))
        pObjectInfo->dwFlags |= SI_READONLY;

    pObjectInfo->hInstance = g_hInstance;

    if(m_pSvrCA->m_pParentMachine)
    {
        pObjectInfo->pszServerName = const_cast<WCHAR *>((LPCTSTR)m_pSvrCA->m_pParentMachine->m_strMachineName);
    }

    pObjectInfo->pszObjectName = const_cast<WCHAR *>((LPCTSTR)m_pSvrCA->m_strCommonName);

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    HRESULT hr = S_OK;
//    DWORD dwLength = 0;
    DWORD dwErr = ERROR_SUCCESS;
//    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD  dwRevision = 0;

    *ppSD = NULL;

    if (fDefault||
        DACL_SECURITY_INFORMATION!=si)
        return E_NOTIMPL;

    //
    // Assume that required privileges have already been enabled
    //
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 0;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    if(m_pSvrCA)
    {
        hr = myOpenAdminDComConnection(
                        m_pSvrCA->m_bstrConfig,
                        &pwszAuthority,
                        NULL,
			&dwServerVersion,
                        &pICertAdminD);
        _JumpIfError(hr, error, "myOpenAdminDComConnection");

	    if (2 > dwServerVersion)
	    {
	        hr = RPC_E_VERSION_MISMATCH;
	        _JumpError(hr, error, "old server");
	    }

        __try
        {
            hr = pICertAdminD->GetCASecurity(
                     pwszAuthority,
                     &ctbSD);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "pICertAdminD->GetCASecurity");

        myRegisterMemAlloc(ctbSD.pb, ctbSD.cb, CSM_COTASKALLOC);

        // take the return
        *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, ctbSD.cb);
        if (NULL == *ppSD)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        MoveMemory(*ppSD, ctbSD.pb, ctbSD.cb);
    }

    if (NULL == *ppSD)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "NULL secdescr");
    }

    if(GetSecurityDescriptorControl(*ppSD, &Control, &dwRevision))
    {
        Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
        SetSecurityDescriptorControl(*ppSD, 
                                     SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                                     Control);
    }
#if DBG
// dump *ppSD
{
LPWSTR szSecDescr = NULL;

ConvertSecurityDescriptorToStringSecurityDescriptor(
  *ppSD,
  SDDL_REVISION_1,
  DACL_SECURITY_INFORMATION,
  &szSecDescr,
  NULL);

  if (szSecDescr)
  {
     myRegisterMemAlloc(szSecDescr, -1, CSM_LOCALALLOC);
     DBGPRINT((DBG_SS_CERTMMCI, "GetSecurity: %ws\n", szSecDescr));
     LocalFree(szSecDescr);
  }
}
#endif

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    if (NULL != ctbSD.pb)
    {
        CoTaskMemFree(ctbSD.pb);
    }

    return hr;
}

STDMETHODIMP
CCASecurityObject::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;

    HANDLE hClientToken = NULL;
    HANDLE hHandle = NULL;
    HKEY   hConfigKey = NULL;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD  dwRevision = 0;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 0;
    CERTTRANSBLOB ctbSD;
    WCHAR const *pwszAuthority;
    DWORD dwSize;
    PSECURITY_DESCRIPTOR pSDSelfRel = NULL;

    if (DACL_SECURITY_INFORMATION!=si)
        return E_NOTIMPL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = myHLastError();
    }
    else
    {
        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = myHLastError();
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = myHLastError();
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = myHLastError();
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = myHLastError();
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }

    if(hr != S_OK)
    {
        goto error;
    }

    if(si & DACL_SECURITY_INFORMATION)
    {
        if(GetSecurityDescriptorControl(pSD, &Control, &dwRevision))
        {
            Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
            SetSecurityDescriptorControl(pSD, 
                                         SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                                         Control);
        }
    }

    dwSize = GetSecurityDescriptorLength(pSD);

    pSDSelfRel = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
    if(NULL == pSDSelfRel)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSize))
    {
        LocalFree(pSDSelfRel);
        pSDSelfRel = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
        if(NULL == pSDSelfRel)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if(!MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "LocalAlloc");
        }
    }

    hr = myOpenAdminDComConnection(
		    m_pSvrCA->m_bstrConfig,
		    &pwszAuthority,
		    NULL,
		    &dwServerVersion,
		    &pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }

    __try
    {
        ctbSD.cb = GetSecurityDescriptorLength(pSDSelfRel);
        ctbSD.pb = (BYTE*)pSDSelfRel;
        hr = pICertAdminD->SetCASecurity(
                     pwszAuthority,
                     &ctbSD);

        if(hr == HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE))
        {
            // Attempt to fix enrollment object, see bug# 193388
            m_pSvrCA->FixEnrollmentObject();

            // try again
            hr = pICertAdminD->SetCASecurity(
                         pwszAuthority,
                         &ctbSD);
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->SetCASecurity");

#if DBG
// dump m_pSD
{
LPWSTR szSecDescr = NULL;

ConvertSecurityDescriptorToStringSecurityDescriptor(
  pSD,
  SDDL_REVISION_1,
  DACL_SECURITY_INFORMATION,
  &szSecDescr,
  NULL);


  if (szSecDescr)
  {
     myRegisterMemAlloc(szSecDescr, -1, CSM_LOCALALLOC);
     DBGPRINT((DBG_SS_CERTMMCI, "SetSecurity: %ws\n", szSecDescr));
     LocalFree(szSecDescr);
  }
}
#endif

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    if(hClientToken)
    {
        CloseHandle(hClientToken);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }

    if(NULL != pSDSelfRel)
    {
        LocalFree(pSDSelfRel);
    }

    return hr;
}

STDMETHODIMP
CCASecurityObject::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    *ppAccesses = g_siObjAccesses;
    *pcAccesses = sizeof(g_siObjAccesses)/sizeof(g_siObjAccesses[0]);
    *piDefaultAccess = g_iObjDefAccess;

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::PropertySheetPageCallback(HWND /*hwnd*/,
                                         UINT /*uMsg*/,
                                         SI_PAGE_TYPE /*uPage*/)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\chooser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chooser.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Chooser.cpp
//
//	Dialog to choose a machine name.
//
//	PURPOSE
//	What you have to do is to copy all the files from the
//	snapin\chooser\ directory into your project (you may add
//	\nt\private\admin\snapin\chooser\ to your include directory if
//	you prefer not copying the code).
//	If you decide to copy the code to your project, please send mail
//	to Dan Morin (T-DanM) and cc to Jon Newman (JonN) so we can
//	mail you when we have updates available.  The next update will
//	be the "Browse" button to select a machine name.
//
//
//  DYNALOADED LIBRARIES
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//	23-May-1997		t-danm		Checkin into public tree. Comments updates.
//	25-May-1997		t-danm		Added MMCPropPageCallback().
//      31-Oct-1997             mattt           Added dynaload, fixed user <CANCEL> logic
//       1-Oct-1998             mattt           Removed reliance on MFC, changed default look to enable certsvr picker
//
/////////////////////////////////////////////////////////////////////

#include <stdafx.h>

#include "chooser.h"
#include "csdisp.h" // certsrv picker

#ifdef _DEBUG
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#ifndef INOUT		
// The following defines are found in \nt\private\admin\snapin\filemgmt\stdafx.h

#define INOUT
#define	Endorse(f)		// Dummy macro
#define LENGTH(x)		(sizeof(x)/sizeof(x[0]))
#define Assert(f)		ASSERT(f)
#endif

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Replacement for BEGIN_MESSAGE_MAP
BOOL CAutoDeletePropPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    }
*/
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : PropertyPage(uIDD)
{
    m_prgzHelpIDs = NULL;
    m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
    m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;

    m_psp.dwFlags |= PSP_USECALLBACK;
    m_psp.pfnCallback = S_PropSheetPageProc;
    m_psp.lParam = reinterpret_cast<LPARAM>(this);
}

CAutoDeletePropPage::~CAutoDeletePropPage()
{
}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
{
    m_strCaption = pszCaption;		// Copy the caption
    m_psp.pszTitle = m_strCaption;	// Set the title
    m_psp.dwFlags |= PSP_USETITLE;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
{
    VERIFY(m_strCaption.LoadString(uStringID));
    SetCaption(m_strCaption);
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    m_strHelpFile = szHelpFile;
    m_prgzHelpIDs = rgzHelpIDs;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
    Assert(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
    ::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
{
    HWND hwndParent = ::GetParent(m_hWnd);
    Assert(IsWindow(hwndParent));
    ::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);
    return PropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnHelp(LPHELPINFO pHelpInfo)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        ::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnContextHelp(HWND hwnd)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    Assert(IsWindow(hwnd));
    ::WinHelp(hwnd, m_strHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    return;
}


/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//
UINT CALLBACK CAutoDeletePropPage::S_PropSheetPageProc(
                                                       HWND hwnd,	
                                                       UINT uMsg,	
                                                       LPPROPSHEETPAGE ppsp)
{
    Assert(ppsp != NULL);
    CAutoDeletePropPage * pThis;
    pThis = reinterpret_cast<CAutoDeletePropPage*>(ppsp->lParam);
    Assert(pThis != NULL);

    BOOL fDefaultRet;

    switch (uMsg)
    {
    case PSPCB_RELEASE:

        fDefaultRet = FALSE;

        if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
        {
            // Remember callback on stack since "this" will be deleted
            LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
            delete pThis;

            if (pfnOrig)
                return (pfnOrig)(hwnd, uMsg, ppsp);
            else
                return fDefaultRet;
        }
        break;
    case PSPCB_CREATE:
        fDefaultRet = TRUE;
        // do not increase refcount, PSPCB_CREATE may or may not be called
        // depending on whether the page was created.  PSPCB_RELEASE can be
        // depended upon to be called exactly once per page however.
        break;

    } // switch

    if (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)
        return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
    else
        return fDefaultRet;
} // CAutoDeletePropPage::S_PropSheetPageProc()





/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Replacement for BEGIN_MESSAGE_MAP
BOOL CChooseMachinePropPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
        OnRadioLocalMachine();
        break;
    case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
        OnRadioSpecificMachine();
        break;
    case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
        OnBrowse();
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


#ifdef _DEBUG
static void AssertValidDialogTemplate(HWND hwnd)
{
    ASSERT(::IsWindow(hwnd));
    // Mandatory controls for a valid dialog template
    static const UINT rgzidDialogControl[] =
    {
        IDC_CHOOSER_RADIO_LOCAL_MACHINE,
            IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,
            IDC_CHOOSER_EDIT_MACHINE_NAME,
            0
    };

    for (int i = 0; rgzidDialogControl[i] != 0; i++)
    {
        ASSERT(NULL != GetDlgItem(hwnd, rgzidDialogControl[i]) &&
            "Control ID not found in dialog template.");
    }
} // AssertValidDialogTemplate()
#else
#define AssertValidDialogTemplate(hwnd)
#endif	// ~_DEBUG

/////////////////////////////////////////////////////////////////////
//	Constructor
CChooseMachinePropPage::CChooseMachinePropPage(UINT uIDD) : CAutoDeletePropPage(uIDD)
{
    m_fIsRadioLocalMachine = TRUE;
    m_fEnableMachineBrowse = FALSE;

    m_pstrMachineNameOut = NULL;
    m_pstrMachineNameEffectiveOut = NULL;
    m_pdwFlags = NULL;
}

/////////////////////////////////////////////////////////////////////
CChooseMachinePropPage::~CChooseMachinePropPage()
{
}

/////////////////////////////////////////////////////////////////////
//	Load the initial state of CChooseMachinePropPage
void CChooseMachinePropPage::InitMachineName(LPCTSTR pszMachineName)
{
    m_strMachineName = pszMachineName;
    m_fIsRadioLocalMachine = m_strMachineName.IsEmpty();
}

/////////////////////////////////////////////////////////////////////
//	SetOutputBuffers()
//
//	- Set the pointer to the CString object to store the machine name.
//	- Set the pointer to the boolean flag for command line override.
//	- Set the pointer pointer to store the overriden machine name.
//
void CChooseMachinePropPage::SetOutputBuffers(
                                              OUT CString * pstrMachineNamePersist,	// Machine name the user typed.  Empty string == local machine.
                                              OUT CString * pstrMachineNameEffective,
                                              OUT DWORD*    pdwFlags)
{
    Assert(pstrMachineNamePersist != NULL && "Invalid output buffer");

    // point members at params
    m_pstrMachineNameOut = pstrMachineNamePersist;
    m_pstrMachineNameEffectiveOut = pstrMachineNameEffective;
    m_pdwFlags = pdwFlags;
    *m_pdwFlags = 0;
}

/////////////////////////////////////////////////////////////////////
// Replacement for DoDataExchange
BOOL CChooseMachinePropPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_strMachineName.FromWindow(GetDlgItem(m_hWnd, IDC_CHOOSER_EDIT_MACHINE_NAME));

        int iCheck = (int)SendMessage(GetDlgItem(m_hWnd, IDC_CHOOSER_MACHINE_OVERRIDE), BM_GETCHECK, 0, 0);
        if (iCheck == BST_CHECKED)
            *m_pdwFlags |= CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE;
        else
            *m_pdwFlags &= ~CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE;
    }
    else
    {
        m_strMachineName.ToWindow(GetDlgItem(m_hWnd, IDC_CHOOSER_EDIT_MACHINE_NAME));

        int iCheck;
        iCheck = (*m_pdwFlags & CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE) ? BST_CHECKED : BST_UNCHECKED;
        SendMessage(GetDlgItem(m_hWnd, IDC_CHOOSER_MACHINE_OVERRIDE), BM_SETCHECK, iCheck, 0);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnInitDialog()
{
    AssertValidDialogTemplate(m_hWnd);
    CAutoDeletePropPage::OnInitDialog();
    InitChooserControls();

    PropSheet_SetWizButtons(GetParent(), PSWIZB_FINISH);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnWizardFinish()
{
    if (!UpdateData())		// Do the data exchange to collect data
        return FALSE;       // don't destroy on error

    if (m_fIsRadioLocalMachine)
        m_strMachineName.Empty();
    else
        if (m_strMachineName.IsEmpty())
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_MUST_CHOOSE_MACHINE);
            return FALSE;
        }

    if (m_pstrMachineNameOut != NULL)
    {
        // Store the machine name into its output buffer
        *m_pstrMachineNameOut = m_strMachineName;
        if (m_pstrMachineNameEffectiveOut != NULL)
        {
            *m_pstrMachineNameEffectiveOut = m_strMachineName;
        } // if
    }
    else
        Assert(FALSE && "FYI: You have not specified any output buffer to store the machine name.");

    return CAutoDeletePropPage::OnWizardFinish();
}

void CChooseMachinePropPage::InitChooserControls()
{
    SendDlgItemMessage(IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, m_fIsRadioLocalMachine);
    SendDlgItemMessage(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !m_fIsRadioLocalMachine);
    EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, !m_fIsRadioLocalMachine);

    PCCRYPTUI_CA_CONTEXT  pCAContext = NULL;
    DWORD dwCACount;
    HRESULT hr = myGetConfigFromPicker(
              m_hWnd,
              NULL, //sub title
              NULL, //title
              NULL,
              TRUE, //use ds
              TRUE, // count only
              &dwCACount,
              &pCAContext);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
    {
        _PrintError(hr, "myGetConfigFromPicker");
        goto done;
    }
    m_fEnableMachineBrowse = (0 == dwCACount) ? FALSE : TRUE;
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }

done:
    EnableDlgItem(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES,
                  !m_fIsRadioLocalMachine && m_fEnableMachineBrowse);
}

void CChooseMachinePropPage::OnRadioLocalMachine()
{
    m_fIsRadioLocalMachine = TRUE;
    EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, FALSE);
    EnableDlgItem(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, FALSE);
}

void CChooseMachinePropPage::OnRadioSpecificMachine()
{
    m_fIsRadioLocalMachine = FALSE;
    EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, TRUE);
    EnableDlgItem(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, m_fEnableMachineBrowse);
}

void CChooseMachinePropPage::OnBrowse()
{
    HRESULT hr;
    WCHAR *szConfig = NULL;
    CWaitCursor cwait;

    // UNDONE: expand config picker to non-published (DS chooser dlg)
    hr = myGetConfigStringFromPicker(m_hWnd,
        NULL, //use default prompt
        NULL, //use default title
        NULL, //use default shared folder
        TRUE, //use DS
        &szConfig);
    if (hr == S_OK)
    {
        LPWSTR szWhack = wcschr(szConfig, L'\\');
        if (szWhack != NULL)
            szWhack[0] = L'\0';
        m_strMachineName = szConfig;

        LocalFree(szConfig);
    }

    // push result back to ui
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\chooser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       chooser.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Chooser.h
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHOOSER_H_INCLUDED__
#define __CHOOSER_H_INCLUDED__

#include "tfcprop.h"

LPCTSTR PchGetMachineNameOverride();

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//	INHERITANCE TREE (so far)
//	CAutoDeletePropPage - Base object
//		CChooseMachinePropPage - Dialog to select a machine name
//			CFileMgmtGeneral - Dialog to select "File Services" (snapin\filemgmt\snapmgr.h)
//			CMyComputerGeneral - Dialog for the "My Computer" (snapin\mycomput\snapmgr.h)
//		CChoosePrototyperPropPage - Dialog to select prototyper demo (NYI)
//	
//	HISTORY
//	15-May-1997		t-danm		Creation. Split of CChooseMachinePropPage
//					to allow property pages to have more flexible dialog
//					templates.
//
class CAutoDeletePropPage : public PropertyPage
{
public:
// Construction
	CAutoDeletePropPage(UINT uIDD);
	virtual ~CAutoDeletePropPage();

protected:
// Dialog Data

// Overrides
	virtual BOOL OnSetActive();

// Implementation
protected:
    void OnHelp(LPHELPINFO lpHelp);
    void OnContextHelp(HWND hwnd);

    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    
	// This mechanism deletes the CAutoDeletePropPage object
	// when the wizard is finished
	struct
    {
        INT cWizPages;	// Number of pages in wizard
        LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
    } m_autodeleteStuff;

	static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);


protected:
    CString m_strCaption;               // Covers for MFC4.2's missing support for Wiz97. 
                                        // without this override, CPropertyPage::m_strCaption 
                                        // address is miscalculated and GPF ensues.

	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
	
public:
	/////////////////////////////////////////////////////////////////////	
	void SetCaption(UINT uStringID);
	void SetCaption(LPCTSTR pszCaption);
	void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);
}; // CAutoDeletePropPage


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CChooseMachinePropPage
//
//	This object is a stand-alone property page used to
//	select a computer name.
//
//	The object CChooseMachinePropPage can have its dialog
//	template replaced to allow a new wizard without any new code.
//	The object can also be inherited, allowing easy extentionability.
//
//	RESTRICTIONS:
//	If the user wishes to provide its own dialog template, here
//	are the dialog IDs that must present:
//		IDC_CHOOSER_RADIO_LOCAL_MACHINE - Select local machine.
//		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE - Select a specific machine.
//		IDC_CHOOSER_EDIT_MACHINE_NAME - Edit field to enter the machine name.
//	There are also optional IDs:
//		IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES - Browse to select a machine name.
//		IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME - Checkbox to allow the machine name to be overriden by command line.
//
class CChooseMachinePropPage : public CAutoDeletePropPage
{
public:
	enum { IID_DEFAULT = IDD_CHOOSER_CHOOSE_MACHINE };

public:
// Construction
	CChooseMachinePropPage(UINT uIDD = IID_DEFAULT);
	virtual ~CChooseMachinePropPage();

protected:
	void InitChooserControls();

    // MFC replacements
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    
// Dialog Data
	BOOL m_fIsRadioLocalMachine;
	BOOL m_fEnableMachineBrowse;
    CString	m_strMachineName;
    DWORD* m_pdwFlags;

// Overrides
	public:
	virtual BOOL OnWizardFinish();
	protected:

// Implementation
protected:
	virtual BOOL OnInitDialog();
	void OnRadioLocalMachine();
	void OnRadioSpecificMachine();
    void OnBrowse();


protected:
	CString * m_pstrMachineNameOut;	// OUT: Pointer to the CString object to store the machine name
	CString * m_pstrMachineNameEffectiveOut;	// OUT: Pointer to the CString object to store the effective machine name

public:
	void InitMachineName(LPCTSTR pszMachineName);
	void SetOutputBuffers(
		OUT CString * pstrMachineNamePersist,
		OUT OPTIONAL CString * pstrMachineNameEffective,
        OUT DWORD* m_pdwFlags);

}; // CChooseMachinePropPage


#endif // ~__CHOOSER_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\compdata.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// Compdata.h : Declaration of the CComponentDataImpl

#ifndef _COMPDATA_H_
#define _COMPDATA_H_

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

class CFolder; 


/////////////////////////////
// File Versions

// current version
// VER_CCOMPDATA_SAVE_STREAM_3 includes dwFlags,
// m_cLastKnownSchema, m_rgLastKnownSchema
#define VER_CCOMPDATA_SAVE_STREAM_3  0x003

// version written through Win2000 beta 3 
#define VER_CCOMPDATA_SAVE_STREAM_2  0x002
/////////////////////////////


// CCompDataImpl dwFlags
#define WSZ_MACHINE_OVERRIDE_SWITCH L"/MACHINE:"



#define CERTMMC_PROPERTY_CHANGE_REFRESHVIEWS  0x200

// Note - This is the offset in my image list that represents the folder
enum IMAGE_INDEXES
{
    IMGINDEX_FOLDER = 0,
    IMGINDEX_FOLDER_OPEN,
    IMGINDEX_CRL,
    IMGINDEX_CERT,
    IMGINDEX_PENDING_CERT,
    IMGINDEX_CERTSVR,
    IMGINDEX_CERTSVR_RUNNING,
    IMGINDEX_CERTSVR_STOPPED,
    IMGINDEX_NO_IMAGE,
};

// Event Values
#define IDC_STOPSERVER              0x100
#define IDC_STARTSERVER             0x101

#define IDC_PUBLISHCRL              0x110
#define IDC_REVOKECERT              0x112
#define IDC_RESUBMITREQUEST         0x113
#define IDC_DENYREQUEST             0x114
#define IDC_BACKUP_CA               0x115
#define IDC_RESTORE_CA              0x116
#define IDC_INSTALL_CA              0x117
#define IDC_REQUEST_CA              0x118
#define IDC_ROLLOVER_CA             0x119
#define IDC_SUBMITREQUEST           0x11a

#define IDC_VIEW_CERT_PROPERTIES    0x140
#define IDC_VIEW_ALLRECORDS         0x141
#define IDC_VIEW_FILTER             0x142
#define IDC_VIEW_ATTR_EXT           0x143

#define IDC_RETARGET_SNAPIN         0x150

#define IDC_UNREVOKE_CERT           0x160

#define HTMLHELP_FILENAME L"cs.chm"
#define HTMLHELP_COLLECTION_FILENAME 	L"\\help\\" HTMLHELP_FILENAME 
#define HTMLHELP_COLLECTIONLINK_FILENAME 	L"\\help\\csconcepts.chm"


#define MFS_HIDDEN 0xFFFFFFFF

#define MAX_RESOURCE_STRLEN 256
typedef struct _MY_CONTEXTMENUITEM
{
    CONTEXTMENUITEM item;
    UINT uiString1;
    UINT uiString2;
    WCHAR szString1[MAX_RESOURCE_STRLEN];
    WCHAR szString2[MAX_RESOURCE_STRLEN];
} MY_CONTEXTMENUITEM, *PMY_CONTEXTMENUITEM;


#define TASKITEM_FLAG_RESULTITEM 0x1 
#define TASKITEM_FLAG_LOCALONLY  0x2

typedef struct _TASKITEM
{
    FOLDER_TYPES    type;
    DWORD           dwFlags;
    MY_CONTEXTMENUITEM myitem;
} TASKITEM;


MY_CONTEXTMENUITEM menuItems[];
MY_CONTEXTMENUITEM  taskStartStop[];
TASKITEM        taskItems[];
TASKITEM        viewItems[];
TASKITEM        topItems[];

// ICompData inserted
TASKITEM taskResultItemsSingleSel[];
MY_CONTEXTMENUITEM viewResultItems[];



// m_dwPersistFlags
#define CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE 0x1


class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public CComObjectRoot,
    public ISnapinHelp2
{
BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    virtual ~CComponentDataImpl();

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
// ISnapinHelp2 interface members
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);       
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle, 
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, 
                            LONG *pInsertionAllowed);
    STDMETHOD(Command)(LONG nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

#if DBG
    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;
#endif

// Notify handler declarations
private:
    HRESULT OnDelete(MMC_COOKIE cookie);
    HRESULT OnRemoveChildren(LPARAM arg);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);


public:
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();
    LONG _cRefs;

// Scope item creation helpers
private:
    BOOL AddStartStopTasks(
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            BOOL fSvcRunning);

    void UpdateScopeIcons();
    HRESULT DisplayProperRootNodeName(HSCOPEITEM hScopeItem);

private:
    CFolder* FindObject(MMC_COOKIE cookie); 

    // display synchronization code
    HRESULT SynchDisplayedCAList(LPDATAOBJECT lpDataObject);
    HRESULT BaseFolderInsertIntoScope(CFolder* pFolder, CertSvrCA* pCA);
    HRESULT CreateTemplateFolders(CertSvrCA* pCA);
    void EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent);

    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);    

private:
    LPCONSOLENAMESPACE2     m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE2              m_pConsole;     // My interface pointer to the console
    HSCOPEITEM              m_pStaticRoot;

    DWORD                   m_dwNextViewIndex; // assign to CComponent to keep them seperate

    BOOL                    m_bIsDirty;
    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    ////////
    // persist

    // General-purpose flags to be persisted into .msc file
    DWORD           m_dwFlagsPersist;				

    CertSvrMachine* m_pCertMachine;
    CFolder*        m_pCurSelFolder;
    
    GUID            m_guidInstance;     // keeps column data straight -- new id for each instance

    DWORD           m_cLastKnownSchema;
    CString*        m_rgcstrLastKnownSchema;
    // end persist
    ///////////////

    // non-persistent schema info
    LONG*           m_rgltypeLastKnownSchema;
    BOOL*           m_rgfindexedLastKnownSchema;

    BOOL            m_fSchemaWasResolved;   // only resolve once

public:

    int FindColIdx(IN LPCWSTR szHeading);
    DWORD   GetSchemaEntries() { return m_cLastKnownSchema; }
    HRESULT GetDBSchemaEntry(int iIndex, LPCWSTR* pszHeading, LONG* plType, BOOL* pfIndexed);
    HRESULT SetDBSchema(CString* rgcstr, LONG* rgtype, BOOL* rgfIndexed, DWORD cEntries);

    void ResetPersistedColumnInformation() {  HRESULT hr = UuidCreate(&m_guidInstance); }

private:
    CList<CFolder*, CFolder*> m_scopeItemList; 

    BOOL    m_fScopeAlreadyEnumerated;
};


class CComponentDataPrimaryImpl : public CComponentDataImpl,
    public CComCoClass<CComponentDataPrimaryImpl, &CLSID_Snapin>
{
public:
    DECLARE_REGISTRY(CSnapin, _T("CertSvrAdmin Snapin.Snapin.1"), _T("CertSvrAdmin Snapin.Snapin"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_Snapin; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }
    
};

#endif // #define _COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\compdata.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
#include "setupids.h"
#include "resource.h"
#include "genpage.h"  

#include "chooser.h"
#include "misc.h"

#include "csdisp.h" // picker
#include <esent.h>   // database error
#include <aclui.h>

#include <atlimpl.cpp>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



struct FOLDER_DATA
{
    FOLDER_TYPES    type;
    UINT            iNameRscID;
};
static FOLDER_DATA SvrFuncFolderData[] =
{
    {SERVERFUNC_CRL_PUBLICATION, IDS_CERTS_REVOKED},
    {SERVERFUNC_ISSUED_CERTIFICATES, IDS_CERTS_ISSUED},
    {SERVERFUNC_PENDING_CERTIFICATES, IDS_CERTS_PENDING},
    {SERVERFUNC_FAILED_CERTIFICATES, IDS_CERTS_FAILED},
    {SERVERFUNC_ALIEN_CERTIFICATES, IDS_CERTS_IMPORTED},
};
// keep this enum in synch with SvrFuncFolderData[]
enum ENUM_FOLDERS
{
ENUM_FOLDER_CRL=0,
ENUM_FOLDER_ISSUED,
ENUM_FOLDER_PENDING,
ENUM_FOLDER_FAILED,
ENUM_FOLDER_ALIEN
};



// Array of view items to be inserted into the context menu.
// keep this enum in synch with viewItems[]
enum ENUM_TASK_STARTSTOP_ITEMS
{
    ENUM_TASK_START=0,
    ENUM_TASK_STOP, 
    ENUM_TASK_SEPERATOR,
};

MY_CONTEXTMENUITEM  taskStartStop[] = 
{
    {
        {
        L"", L"",
        IDC_STARTSERVER, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        IDS_TASKMENU_STARTSERVICE,
        IDS_TASKMENU_STATUSBAR_STARTSERVICE,
    },

    {
        {
        L"", L"",
        IDC_STOPSERVER, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        IDS_TASKMENU_STOPSERVICE,
        IDS_TASKMENU_STATUSBAR_STOPSERVICE,
    },

    {
        { NULL, NULL, 0, 0, 0 },
        IDS_EMPTY,
        IDS_EMPTY,
    },
};


// Array of view items to be inserted into the context menu.
// WARNING: keep this enum in synch with taskItems[]
enum ENUM_TASK_ITEMS
{
    ENUM_TASK_CRLPUB=0,
    ENUM_TASK_ATTREXTS_CRL,
    ENUM_TASK_ATTREXTS_ISS,
    ENUM_TASK_ATTREXTS_PEND,
    ENUM_TASK_ATTREXTS_FAIL,
    ENUM_TASK_DUMP_ASN_CRL,
    ENUM_TASK_DUMP_ASN_ISS,
    ENUM_TASK_DUMP_ASN_PEND,
    ENUM_TASK_DUMP_ASN_FAIL,
    ENUM_TASK_DUMP_ASN_ALIEN,
    ENUM_TASK_SEPERATOR1,
    ENUM_TASK_SEPERATOR4,
    ENUM_TASK_SUBMIT_REQUEST,
    ENUM_TASK_REVOKECERT,
    ENUM_TASK_RESUBMITREQ,
    ENUM_TASK_DENYREQ,
    ENUM_TASK_RESUBMITREQ2,
    ENUM_TASK_SEPERATOR2,
    ENUM_TASK_BACKUP,
    ENUM_TASK_RESTORE,
    ENUM_TASK_SEPERATOR3,
    ENUM_TASK_INSTALL,
    ENUM_TASK_REQUEST,
    ENUM_TASK_ROLLOVER,
};

TASKITEM taskItems[] = 
{ 

    {   SERVERFUNC_CRL_PUBLICATION,
        0,
        {
            {
            L"", L"",
            IDC_PUBLISHCRL, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_PUBLISHCRL,
            IDS_TASKMENU_STATUSBAR_PUBLISHCRL,
        }
    },

/////////////////////
// BEGIN ATTR/EXT
    {   SERVERFUNC_CRL_PUBLICATION,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
        }
    },
    {   SERVERFUNC_ISSUED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
        }
    },
    {   SERVERFUNC_PENDING_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
        }
    },
    {   SERVERFUNC_FAILED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
        }
    },

// END ATTR/EXT
/////////////////////

/////////////////////
// BEGIN ENUM_TASK_DUMP_ASN*
    {   SERVERFUNC_CRL_PUBLICATION,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
        }
    },
    {   SERVERFUNC_ISSUED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
        }
    },
    {   SERVERFUNC_PENDING_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
        }
    },
    {   SERVERFUNC_FAILED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
        }
    },
    {   SERVERFUNC_ALIEN_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
        }
    },
// END ENUM_TASK_DUMP_ASN*
/////////////////////


    // seperator
    {	SERVERFUNC_ALL_FOLDERS,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },

    // seperator
    {	SERVER_INSTANCE,
        0,       // dwFlags
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },

    {   SERVER_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_SUBMITREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_SUBMITREQUEST,
            IDS_TASKMENU_STATUSBAR_SUBMITREQUEST,
        }
    },

    {   SERVERFUNC_ISSUED_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_REVOKECERT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_REVOKECERT,
            IDS_TASKMENU_STATUSBAR_REVOKECERT,
        }
    },

    {   SERVERFUNC_PENDING_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_RESUBMITREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_RESUBMIT,
            IDS_TASKMENU_STATUSBAR_RESUBMIT,
        }
    },

    {   SERVERFUNC_PENDING_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DENYREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DENYREQUEST,
            IDS_TASKMENU_STATUSBAR_DENYREQUEST,
        }
    },

    {   SERVERFUNC_FAILED_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_RESUBMITREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_RESUBMIT,
            IDS_TASKMENU_STATUSBAR_RESUBMIT,
        }
    },

    // seperator
    {	SERVERFUNC_ALL_FOLDERS,
        0,       // dwFlags
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },

	{   SERVER_INSTANCE,
        TASKITEM_FLAG_LOCALONLY,
        {
            {
            L"", L"",
            IDC_BACKUP_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_BACKUP,
            IDS_TASKMENU_STATUSBAR_BACKUP,
        }
    },

	{   SERVER_INSTANCE,
        TASKITEM_FLAG_LOCALONLY,
        {
            {
            L"", L"",
            IDC_RESTORE_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_RESTORE,
            IDS_TASKMENU_STATUSBAR_RESTORE,
        }
    },

    // seperator
    {	SERVER_INSTANCE,
		0,
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },


    {   SERVER_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_INSTALL_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_INSTALL_CA,
            IDS_TASKMENU_STATUSBAR_INSTALL_CA,
        }
    },

    {   SERVER_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_REQUEST_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_REQUEST_CA,
            IDS_TASKMENU_STATUSBAR_REQUEST_CA,
        }
   },

    {   SERVER_INSTANCE,
        TASKITEM_FLAG_LOCALONLY,
        {
            {
            L"", L"",
            IDC_ROLLOVER_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_GRAYED, 0
            },
            IDS_TASKMENU_ROLLOVER,
            IDS_TASKMENU_STATUSBAR_ROLLOVER,
        }
    },


   {   NONE, 
        FALSE, 
        {
            { NULL, NULL, 0, 0, 0 },
            IDS_EMPTY,
            IDS_EMPTY,
        }
    }
};


// Array of view items to be inserted into the context menu.
// keep this enum in synch with topItems[]
enum ENUM_TOP_ITEMS
{
    ENUM_TOP_REVOKEDOPEN=0,
    ENUM_TOP_ISSUEDOPEN,
    ENUM_TOP_ALIENOPEN,
    ENUM_RETARGET_SNAPIN,
};

TASKITEM topItems[] = 
{ 

    {   SERVERFUNC_CRL_PUBLICATION,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
        }
    },

    {   SERVERFUNC_ISSUED_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
        }
    },

    {   SERVERFUNC_ALIEN_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
        }
    },

    {
        MACHINE_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_RETARGET_SNAPIN, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, 0
            },
            IDS_RETARGET_SNAPIN,
            IDS_STATUSBAR_RETARGET_SNAPIN,
        }
    },

    {   NONE, 
        0, 
        {
            { NULL, NULL, 0, 0, 0 },
            IDS_EMPTY,
            IDS_EMPTY,
        }
    }
};



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
    : m_bIsDirty(TRUE), m_pScope(NULL), m_pConsole(NULL) 
#if DBG
    , m_bInitializedCD(false), m_bDestroyedCD(false)
#endif
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    m_dwFlagsPersist = 0;
    
    m_pStaticRoot = NULL;
    m_pCurSelFolder = NULL;

    m_fScopeAlreadyEnumerated = FALSE;
    m_fSchemaWasResolved = FALSE;   // resolve schema once per load

    // checked in ::Initialize, ::CreatePropertyPages
    m_pCertMachine = new CertSvrMachine;

    m_cLastKnownSchema = 0;
    m_rgcstrLastKnownSchema = NULL;
    m_rgltypeLastKnownSchema = NULL;
    m_rgfindexedLastKnownSchema = NULL;

    m_dwNextViewIndex = 0;
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);
    ASSERT(!m_bInitializedCD || m_bDestroyedCD);

    // Delete enumerated scope items
    // note: we don't own pCA memory, m_pCertMachine does
    POSITION pos = m_scopeItemList.GetHeadPosition();
    while (pos)
        delete m_scopeItemList.GetNext(pos);
    m_scopeItemList.RemoveAll();

    m_pCurSelFolder = NULL;
    m_fScopeAlreadyEnumerated = FALSE;

    if (m_pCertMachine)
        m_pCertMachine->Release();

    m_cLastKnownSchema = 0;
    if (m_rgcstrLastKnownSchema)
        delete [] m_rgcstrLastKnownSchema;
    if (m_rgltypeLastKnownSchema)
        delete [] m_rgltypeLastKnownSchema;
    if (m_rgfindexedLastKnownSchema)
        delete [] m_rgfindexedLastKnownSchema;
}


STDMETHODIMP_(ULONG)
CComponentDataImpl::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}

STDMETHODIMP_(ULONG)
CComponentDataImpl::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}

int CComponentDataImpl::FindColIdx(IN LPCWSTR szHeading)
{
    for (DWORD dw=0; dw<m_cLastKnownSchema; dw++)
    {
        if (m_rgcstrLastKnownSchema[dw].IsEqual(szHeading))
            return dw;
    }
    
    return -1;
}

HRESULT CComponentDataImpl::GetDBSchemaEntry(
            IN int iIndex, 
            OUT OPTIONAL LPCWSTR* pszHeading, 
            OUT OPTIONAL LONG* plType, 
            OUT OPTIONAL BOOL* pfIndexed)
{
    if (m_cLastKnownSchema<= (DWORD)iIndex)
        return HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);

    if (pszHeading)
        *pszHeading = m_rgcstrLastKnownSchema[iIndex];
    if (plType)
        *plType = m_rgltypeLastKnownSchema[iIndex];
    if (pfIndexed)
        *pfIndexed = m_rgfindexedLastKnownSchema[iIndex];

    return S_OK;
}

HRESULT CComponentDataImpl::SetDBSchema(
            IN CString* rgcstr, 
            LONG* rgtype, 
            BOOL* rgfIndexed, 
            DWORD cEntries)
{
    if (m_rgcstrLastKnownSchema)
        delete [] m_rgcstrLastKnownSchema;
    m_rgcstrLastKnownSchema = rgcstr;

    if (m_rgltypeLastKnownSchema)
        delete [] m_rgltypeLastKnownSchema;
    m_rgltypeLastKnownSchema = rgtype;

    if (m_rgfindexedLastKnownSchema)
        delete [] m_rgfindexedLastKnownSchema;
    m_rgfindexedLastKnownSchema = rgfIndexed;

    m_cLastKnownSchema = cEntries;

    return S_OK;
}



STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    // NOTA BENE: Init is called when a snap-in is being 
    // created and has items to enumerate in the scope pane ... NOT BEFORE
    // Example: Add/Remove snapin, Add...
    //  -> CComponentDataImpl will get called for CreatePropertyPages() before ::Initialize is called

#if DBG
    m_bInitializedCD = true;
#endif

    ASSERT(pUnknown != NULL);
    HRESULT hr;

    LPIMAGELIST lpScopeImage = NULL;
    CBitmap bmpResultStrip16x16, bmpResultStrip32x32;

    // Load resources
    if (!g_cResources.Load())
    {
        hr = GetLastError();
        _JumpError(hr, Ret, "Load Resources");
    }

    // create a per-instance id (failure not fatal)
    ResetPersistedColumnInformation();

    // MMC should only call ::Initialize once!

    // m_pCertMachine created in constructor, but verified here
    ASSERT(m_pCertMachine != NULL);
    _JumpIfOutOfMemory(hr, Ret, m_pCertMachine);
    
    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, reinterpret_cast<void**>(&m_pScope));
    _JumpIfError(hr, Ret, "QueryInterface IID_IConsoleNameSpace2");

    // add the images for the scope tree
    hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);
    _JumpIfError(hr, Ret, "QueryInterface IID_IConsole2");

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);
    _JumpIfError(hr, Ret, "QueryScopeImageList");

    if ( (NULL == bmpResultStrip16x16.LoadBitmap(IDB_16x16)) || 
         (NULL == bmpResultStrip32x32.LoadBitmap(IDB_32x32)) )
    {
        hr = S_FALSE;
        _JumpError(hr, Ret, "LoadBitmap");
    }

    // Load the bitmaps from the dll
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmpResultStrip16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmpResultStrip32x32)),
                       0, RGB(255, 0, 255));
    _JumpIfError(hr, Ret, "ImageListSetStrip");


Ret:
    if (lpScopeImage)
        lpScopeImage->Release();
    
    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    // release all references to the console here
    ASSERT(m_bInitializedCD);
#if DBG
    m_bDestroyedCD = true;
#endif

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    HRESULT hr = S_OK;
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    _JumpIfOutOfMemory(hr, Ret, pObject);

    // Store IComponentData
    pObject->SetIComponentData(this);
    pObject->SetViewID(m_dwNextViewIndex++);

    hr = pObject->QueryInterface(IID_IComponent, 
                    reinterpret_cast<void**>(ppComponent));
Ret:
    return hr;
}


STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;
    INTERNAL* pInternal = NULL;
    MMC_COOKIE cookie = NULL;

    // handle events with (NULL == lpDataObject)
    switch(event)
    {
        case MMCN_PROPERTY_CHANGE:
        {
            // Notification from property page "notify change"
            //
            // arg == fIsScopeItem
            // lParam == page param value
            // return value unused

            if (param == CERTMMC_PROPERTY_CHANGE_REFRESHVIEWS)
            {
                m_pConsole->UpdateAllViews(
                    lpDataObject,
                    0,
                    0);
            }

            goto Ret;
        }

        default: // all others
            break; 
    }


    pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }

    cookie = pInternal->m_cookie;
    FREE_DATA(pInternal);

    switch(event)
    {
    case MMCN_PASTE:
        DBGPRINT((DBG_SS_CERTMMC, "CComponentDataImpl::MMCN_PASTE"));
        break;
    
    case MMCN_DELETE:
        hr = OnDelete(cookie);
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = OnRemoveChildren(arg);
        break;

    case MMCN_RENAME:
        hr = OnRename(cookie, arg, param);
        break;

    case MMCN_EXPAND:
        hr = OnExpand(lpDataObject, arg, param);
        break;

    case MMCN_PRELOAD:
        {
            if (NULL == cookie)
            {
                // base node 

                // this call gave us time to load our dynamic base nodename (Certification Authority on %s)
                DisplayProperRootNodeName((HSCOPEITEM)arg);
            }
        }

    default:
        break;
    }

Ret:
    return hr;
}

HRESULT CComponentDataImpl::DisplayProperRootNodeName(HSCOPEITEM hRoot)
{
    // hRoot not optional
    if (hRoot == NULL)
        return E_POINTER;

    // if static root not yet set, save it (CASE: load from file)
    if (m_pStaticRoot == NULL)
        m_pStaticRoot = hRoot;

    // let us have time to load our dynamic base nodename (Certification Authority on %s)
    SCOPEDATAITEM item;
    item.mask = SDI_STR;
    item.ID = hRoot;

    CString cstrMachineName;
    CString cstrDisplayStr, cstrFormatStr, cstrMachine;

    cstrFormatStr.LoadString(IDS_NODENAME_FORMAT);
    if (m_pCertMachine->m_strMachineName.IsEmpty())
        cstrMachine.LoadString(IDS_LOCALMACHINE);
    else
        cstrMachine = m_pCertMachine->m_strMachineName;
    
    if (!cstrFormatStr.IsEmpty())
    {
        cstrMachineName.Format(cstrFormatStr, cstrMachine);
        item.displayname = (LPWSTR)(LPCWSTR)cstrMachineName;
    }
    else
    {  
        // protect against null formatstring
        item.displayname = (LPWSTR)(LPCWSTR)cstrMachine;
    }
    m_pScope->SetItem (&item);
    
    return S_OK;
}


STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
#ifdef _DEBUG
    if (cookie == 0)
    {
        ASSERT(type != CCT_RESULT);
    }
    else 
    {
        ASSERT(type == CCT_SCOPE);
        
        DWORD dwItemType = *reinterpret_cast<DWORD*>(cookie);
        ASSERT((dwItemType == SCOPE_LEVEL_ITEM) || (dwItemType == CA_LEVEL_ITEM));
    }
#endif 

    return _QueryDataObject(cookie, type, -1, this, ppDataObject);
}

///////////////////////////////////////////////////////////////////////////////
//// ISnapinHelp interface
STDMETHODIMP CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH];
  szWindows[0] = L'\0';

  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFile = (LPOLESTR) CoTaskMemAlloc(sizeof(HTMLHELP_COLLECTION_FILENAME) + cbWindows);
  if (*lpCompiledHelpFile == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFile, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFile, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFile, T2OLE(HTMLHELP_COLLECTION_FILENAME));

  return S_OK;
}

// tells of other topics my chm links to
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR* lpCompiledHelpFiles)
{
  if (lpCompiledHelpFiles == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH];
  szWindows[0] = L'\0';

  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFiles = (LPOLESTR) CoTaskMemAlloc(sizeof(HTMLHELP_COLLECTIONLINK_FILENAME) + cbWindows);
  if (*lpCompiledHelpFiles == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFiles, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFiles, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFiles, T2OLE(HTMLHELP_COLLECTIONLINK_FILENAME));

  return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}


STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Read the string
    BOOL fMachineOverrideFound = FALSE;
    DWORD dwVer;

    CertSvrCA* pDummyCA = NULL;
    HRESULT hr;

    // read version
    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Read dwVer");

    // flags is version-dependent
    if (VER_CCOMPDATA_SAVE_STREAM_3 == dwVer)
    {
        // version 3 includes file flags

        hr = ReadOfSize(pStm, &m_dwFlagsPersist, sizeof(DWORD));
        _JumpIfError(hr, Ret, "Read m_dwFlagsPersist");
    }
    else if (VER_CCOMPDATA_SAVE_STREAM_2 != dwVer)
    {
        // not version 2 or 3
        return STG_E_OLDFORMAT;
    }

    // load machine data
    hr = m_pCertMachine->Load(pStm);
    _JumpIfError(hr, Ret, "Load m_pCertMachine")

    if (m_dwFlagsPersist & CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE)
    {
        // override m_pCertMachine->m_strMachineName (not to be persisted)
        LPWSTR lpCommandLine = GetCommandLine();    // no need to free
        DBGPRINT((DBG_SS_CERTMMC, "CComponentData::Load: Command line switch override enabled.  Searching command line(%ws)\n", lpCommandLine));

        LPWSTR pszMachineStart, pszMachineEnd;

        // search for "/machine" in cmd line
        _wcsupr(lpCommandLine);  // convert to uppercase
        pszMachineStart = wcsstr(lpCommandLine, WSZ_MACHINE_OVERRIDE_SWITCH);

        do  // not a loop
        {
            if (NULL == pszMachineStart)    // user did not override
                break;

            pszMachineStart += WSZARRAYSIZE(WSZ_MACHINE_OVERRIDE_SWITCH);   // skip past "/machine:"

            //
            // Found the hint switch
            //
            pszMachineEnd = wcschr(pszMachineStart, L' ');  // look for first space char, call this end
            if (NULL == pszMachineEnd)
                pszMachineEnd = &pszMachineStart[wcslen(pszMachineStart)];  // space not found in this string; 
            
            m_pCertMachine->m_strMachineName = pszMachineStart;
            m_pCertMachine->m_strMachineName.SetAt(SAFE_SUBTRACT_POINTERS(pszMachineEnd, pszMachineStart), L'\0'); 

            DBGPRINT((DBG_SS_CERTMMC,  "CComponentData::Load: Found machinename (%ws)\n", m_pCertMachine->m_strMachineName));
            fMachineOverrideFound = TRUE;

        } while (0);
    }

    if (!fMachineOverrideFound) 
    {
        // Get CA count
        DWORD dwNumCAs;
        hr = ReadOfSize(pStm, &dwNumCAs, sizeof(DWORD));
        _JumpIfError(hr, Ret, "Load dwNumCAs");

        // for each CA, get folder data
        for (DWORD dwCA=0; dwCA< dwNumCAs; dwCA++)
        {
            CString cstrThisCA;
            DWORD dwParticularCA;

            hr = CStringLoad(cstrThisCA, pStm);
            _JumpIfError(hr, Ret, "CStringLoad");
        
            // create a dummy CA with the correct common name; we'll fix this later (see Synch CA)
            pDummyCA = new CertSvrCA(m_pCertMachine);
            _JumpIfOutOfMemory(hr, Ret, pDummyCA);

            pDummyCA->m_strCommonName = cstrThisCA;

            if (VER_CCOMPDATA_SAVE_STREAM_2 < dwVer)
            {
                m_fSchemaWasResolved = FALSE;   // resolve schema once per CComponentData load

                // LOAD last known schema
                hr = ReadOfSize(pStm, &m_cLastKnownSchema, sizeof(DWORD));
                _JumpIfError(hr, Ret, "Load m_cLastKnownSchema");
            
                // alloc
                if (m_cLastKnownSchema != 0)
                {
                    m_rgcstrLastKnownSchema = new CString[m_cLastKnownSchema];
                    _JumpIfOutOfMemory(hr, Ret, m_rgcstrLastKnownSchema);
                 
                    for (unsigned int i=0; i<m_cLastKnownSchema; i++)
                    {
                        hr = CStringLoad(m_rgcstrLastKnownSchema[i], pStm);
                        _JumpIfError(hr, Ret, "Load m_rgcstrLastKnownSchema");

                    }
                }
            }

            // find out how many folders are in the stream under this CA
            DWORD dwNumFolders=0;
            hr = ReadOfSize(pStm, &dwNumFolders, sizeof(DWORD));
            _JumpIfError(hr, Ret, "Load dwNumFolders");

            // load each of these
            for(DWORD dwCount=0; dwCount<dwNumFolders; dwCount++)
            {
                CFolder* pFolder = new CFolder();
                _JumpIfOutOfMemory(hr, Ret, pFolder);
 
                // point at previously constructed dummy ca; we'll fix this later
                pFolder->m_pCertCA = pDummyCA;

                hr = pFolder->Load(pStm);
                _JumpIfError(hr, Ret, "Load CFolder");

                m_scopeItemList.AddTail(pFolder);
            }
            pDummyCA = NULL; // owned by at least one folder
        }
    }
    
    // version-dependent info
    if (VER_CCOMPDATA_SAVE_STREAM_2 < dwVer)
    {
        // per-instance guid for identifying columns uniquely
        hr = ReadOfSize(pStm, &m_guidInstance, sizeof(GUID));
        _JumpIfError(hr, Ret, "ReadOfSize instance guid");

        hr = ReadOfSize(pStm, &m_dwNextViewIndex, sizeof(DWORD));
        _JumpIfError(hr, Ret, "ReadOfSize view index");
    }
    
Ret:
    if (pDummyCA)
        delete pDummyCA;

    ClearDirty();

    return hr;
}



STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    HRESULT hr;
    DWORD dwVer;
    DWORD dwCA;
    DWORD dwNumCAs;

#if DBG_CERTSRV
    bool fSaveConsole = false;

    LPWSTR lpCommandLine = GetCommandLine();    // no need to free
    _wcsupr(lpCommandLine);  // convert to uppercase
    fSaveConsole = (NULL!=wcsstr(lpCommandLine, L"/certsrv_saveconsole"));
#endif

    // Write the version
    dwVer = VER_CCOMPDATA_SAVE_STREAM_3;
    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Save dwVer");

    // write dwFlags (a VERSION 3 addition)
    hr = WriteOfSize(pStm, &m_dwFlagsPersist, sizeof(DWORD));
    _JumpIfError(hr, Ret, "pStm->Write m_dwFlagsPersist");

#if DBG_CERTSRV
    if(fSaveConsole)
        m_pCertMachine->m_strMachineNamePersist.Empty();
#endif

    hr = m_pCertMachine->Save(pStm, fClearDirty);
    _JumpIfError(hr, Ret, "Save m_pCertMachine");

    // save CA count
    dwNumCAs = m_pCertMachine->GetCaCount();
    hr = WriteOfSize(pStm, &dwNumCAs, sizeof(DWORD));
    _JumpIfError(hr, Ret, "pStm->Write dwNumCAs");

    // for each CA, save folder info
    for (dwCA=0; dwCA < dwNumCAs; dwCA++)
    {
        DWORD dwNumFolders=0;
        CString cstrThisCA, cstrThisCASave;
        cstrThisCASave = cstrThisCA = m_pCertMachine->GetCaCommonNameAtPos(dwCA);

#if DBG_CERTSRV
        if(fSaveConsole)
            cstrThisCASave.Empty();
#endif
        hr = CStringSave(cstrThisCASave, pStm, fClearDirty);
        _JumpIfError(hr, Ret, "CStringSave");

        // SAVE last known schema
        hr = WriteOfSize(pStm, &m_cLastKnownSchema, sizeof(DWORD));
        _JumpIfError(hr, Ret, "pStm->Write m_cLastKnownSchema");

        for (unsigned int i=0; i<m_cLastKnownSchema; i++)
        {
            hr = CStringSave(m_rgcstrLastKnownSchema[i], pStm, fClearDirty);
            _JumpIfError(hr, Ret, "CStringSave");
        }

        // walk through every folder, find how many folders to save
        POSITION pos = m_scopeItemList.GetHeadPosition();
        while(pos)
        {
            CFolder* pFolder = m_scopeItemList.GetNext(pos);
            if (pFolder->GetCA()->m_strCommonName.IsEqual(cstrThisCA))
                dwNumFolders++;
        }

        // write how many folders under this CA
        hr = WriteOfSize(pStm, &dwNumFolders, sizeof(DWORD));
        _JumpIfError(hr, Ret, "pStm->Write dwNumFolders");

        pos = m_scopeItemList.GetHeadPosition();
        while(pos)
        {
            CFolder* pFolder = m_scopeItemList.GetNext(pos);
            if (pFolder->GetCA()->m_strCommonName.IsEqual(cstrThisCA))
            {
                hr = pFolder->Save(pStm, fClearDirty);
                _JumpIfError(hr, Ret, "Save CFolder");
            }
        }
    }

    // per-instance guid for identifying columns uniquely
    hr = WriteOfSize(pStm, &m_guidInstance, sizeof(GUID));
    _JumpIfError(hr, Ret, "WriteOfSize instance guid");

    hr = WriteOfSize(pStm, &m_dwNextViewIndex,  sizeof(DWORD));
    _JumpIfError(hr, Ret, "WriteOfSize view index");
     
Ret:
    if (fClearDirty)
        ClearDirty();

    return hr;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    int iTotalSize=0;

    // version 
    iTotalSize = sizeof(DWORD) + sizeof(m_dwFlagsPersist);

    // machine info
    int iSize;
    m_pCertMachine->GetSizeMax(&iSize);
    iTotalSize += iSize;

    // CA count
    iTotalSize += sizeof(DWORD);

    DWORD dwNumCAs = m_pCertMachine->GetCaCount();
    for (DWORD dwCA=0; dwCA < dwNumCAs; dwCA++)
    {
        DWORD dwNumFolders=0;
        CString cstrThisCA;
        cstrThisCA = m_pCertMachine->GetCaCommonNameAtPos(dwCA);
        CStringGetSizeMax(cstrThisCA, &iSize);
        iTotalSize += iSize;

        // Number of folders under this CA
        iTotalSize += sizeof(DWORD);

        // walk through every folder, find how many folders to save
        POSITION pos = m_scopeItemList.GetHeadPosition();
        while(pos)
        {
            CFolder* pFolder = m_scopeItemList.GetNext(pos);
            if (pFolder->GetCA()->m_strCommonName.IsEqual(cstrThisCA))
            {
                // folder size
                pFolder->GetSizeMax(&iSize);
                iTotalSize += iSize;
            }
        }
    }

    // per-instance guid for identifying columns uniquely
    iTotalSize += sizeof(GUID);
    
    // next View Index to assign
    iTotalSize += sizeof(DWORD);
 

    // size of string to be saved
    pcbSize->QuadPart = iTotalSize;


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnDelete(MMC_COOKIE cookie)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRemoveChildren(LPARAM arg)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    // cookie is cookie
    // arg is fRenamed (ask for permission/notify of rename)
    // param (szNewName)

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    BOOL fRenamed = (BOOL)arg;

    if (!fRenamed)
    {
        if (pFolder)
            return S_FALSE; // don't allow children to be renamed
        else
            return S_OK; // allow root to be renamed
    }

    LPOLESTR pszNewName = reinterpret_cast<LPOLESTR>(param);
    if (pszNewName == NULL)
        return E_INVALIDARG;

    if (pFolder)
    {
        ASSERT(pFolder != NULL);
        if (pFolder == NULL)
            return E_INVALIDARG;

        pFolder->SetName(pszNewName);
    }
    
    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(lpDataObject, param);
    }

    return S_OK;
}


HRESULT CComponentDataImpl::SynchDisplayedCAList(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;
    BOOL fFound;
    POSITION pos, nextpos;
    DWORD dwKnownCAs;

    m_fScopeAlreadyEnumerated = TRUE;  // don't need to refresh view automagically from enum if we get here 

    // should never get here otherwise
    ASSERT(m_pStaticRoot);
    if (NULL == m_pStaticRoot)
        return E_POINTER;

    // select root node, delete all items in UI underneath (we'll readd if necessary)
    hr = m_pConsole->SelectScopeItem(m_pStaticRoot);
    _PrintIfError(hr, "SelectScopeItem");

    hr = m_pScope->DeleteItem(m_pStaticRoot, FALSE);     // remove everything from UI
    _PrintIfError(hr, "DeleteItem");



    // build knowledge of current CAs
    // note: this may orphan some pCAs, but we'll catch it during cleanup
    HWND hwndMain = NULL;
    hr = m_pConsole->GetMainWindow(&hwndMain);
    if (hr != S_OK)
        hwndMain = NULL;        // this should work

    // this hr gets returned after we're done
    hr = m_pCertMachine->PrepareData(hwndMain);

    // don't fail out if PrepareData fails -- we still need to 
    // make the snapin state reflect no known nodes!
    ASSERT((hr == S_OK) || (0 == m_pCertMachine->GetCaCount()) );  // make sure m_pCertMachine zeros itself

    // Tasks
    // #1: Remove folders in m_scopeItemList for CAs that no longer exist in m_pCertMachine.m_rgpCAList[]

    // #2: Add folders to m_scopeItemList for CAs that now exist in m_pCertMachine.m_rgpCAList[]

    // Task #1
    // scour m_scopeItemList for entries we already know about, delete stale folders

    for (pos = m_scopeItemList.GetHeadPosition(); (NULL != pos); )
    {
        // ASSERTION: every folder has an associated m_pCertCA
        ASSERT(NULL != m_scopeItemList.GetAt(pos)->m_pCertCA);

        nextpos = pos;             // save next position off
        fFound = FALSE;

        // for each scope item, walk through m_rgpCAList looking for current
        for (dwKnownCAs=0; dwKnownCAs<(DWORD)m_pCertMachine->m_CAList.GetSize(); dwKnownCAs++)
        {
            if (m_scopeItemList.GetAt(pos)->m_pCertCA->m_strCommonName.IsEqual(m_pCertMachine->GetCaCommonNameAtPos(dwKnownCAs)))
            {
                fFound = TRUE;
                break;
            }
        }

        CFolder* pFolder = m_scopeItemList.GetAt(pos);
        ASSERT(pFolder); // this should never happen
        if (pFolder == NULL)
        {
            hr = E_POINTER;
            _JumpError(hr, Ret, "GetAt");
        }

        if (fFound)
        {
            // always point to latest pCA:
            // NOTE: this allows for load to populate us with dummy CAs!
            pFolder->m_pCertCA = m_pCertMachine->GetCaAtPos(dwKnownCAs);

            // if base node, do insert (other nodes get inserted during Expand() notification)
            if (SERVER_INSTANCE == pFolder->GetType())
                BaseFolderInsertIntoScope(pFolder, pFolder->m_pCertCA);

            // fwd to next elt
            m_scopeItemList.GetNext(pos);
        }
        else // !fFound
        {
            // delete immediately from m_scopeItemList
            m_scopeItemList.GetNext(nextpos);

            delete pFolder;                     // destroy the elt
            m_scopeItemList.RemoveAt(pos);

            pos = nextpos;                      // restore next position
        }
    }

    // Task #2
    // scour m_pCertMachine[] for new entries, create default folders

    for (dwKnownCAs=0; dwKnownCAs<(DWORD)m_pCertMachine->m_CAList.GetSize(); dwKnownCAs++)
    {
        fFound = FALSE;
        for (pos = m_scopeItemList.GetHeadPosition(); (NULL != pos); m_scopeItemList.GetNext(pos))
        {
            if (m_scopeItemList.GetAt(pos)->m_pCertCA->m_strCommonName.IsEqual(m_pCertMachine->GetCaCommonNameAtPos(dwKnownCAs)))
            {
                fFound = TRUE;
                break;  // if matches something in the refreshed list, we're fine 
            }
        }

        // found? 
        if (!fFound)
        {
            CertSvrCA* pCA;
            CFolder* pFolder;

            pCA = m_pCertMachine->GetCaAtPos(dwKnownCAs);
            if (NULL == pCA)
            {
                hr = E_POINTER;
                _JumpError(hr, Ret, "m_pCertMachine->GetCaAtPos(iCAPos)");
            }

            // create base node, add to list, insert into scope pane
            pFolder = new CFolder();
            _JumpIfOutOfMemory(hr, Ret, pFolder);

            m_scopeItemList.AddTail(pFolder);
            
            hr = BaseFolderInsertIntoScope(pFolder, pCA);
            _JumpIfError(hr, Ret, "BaseFolderInsertIntoScope");

            // and create all template folders underneath
            hr = CreateTemplateFolders(pCA);
            _JumpIfError(hr, Ret, "CreateTemplateFolders");
        }
        else
        {
            // no need to do anything, ca is already known & inserted into scope
        }
    }


// BOGDANT
/*
    // Task #3
    // for each CA, offer to do any one-time per-CA upgrades
    for (dwKnownCAs=0; dwKnownCAs<(DWORD)m_pCertMachine->m_CAList.GetSize(); dwKnownCAs++)
    {
            CertSvrCA* pCA;
            CFolder* pFolder;

            pCA = m_pCertMachine->GetCaAtPos(dwKnownCAs);
            if (NULL == pCA)
            {
                hr = E_POINTER;
                _JumpError(hr, Ret, "m_pCertMachine->GetCaAtPos(iCAPos)");
            }

            if (pCA->FDoesSecurityNeedUpgrade())
            {
                BOOL fIsDomainAdmin = FALSE;
                CString cstrMsg, cstrTitle;
                cstrMsg.LoadString(IDS_W2K_SECURITY_UPGRADE_DESCR);
                cstrTitle.LoadString(IDS_W2K_UPGRADE_DETECTED_TITLE);

                hr = IsUserDomainAdministrator(&fIsDomainAdmin);
                _JumpIfError(hr, Ret, "IsUserDomainAdministrator");

                if (fIsDomainAdmin)
                {
                    // ask to upgrade security

                    // confirm this action
                    CString cstrTmp;
                    cstrTmp.LoadString(IDS_CONFIRM_W2K_SECURITY_UPGRADE);
                    cstrMsg += cstrTmp;

                    int iRet;
                    if ((S_OK == m_pConsole->MessageBox(cstrMsg, cstrTitle, MB_YESNO, &iRet)) &&
                        (iRet == IDYES))
                    {
                        // do stuff
hr = csiUpgradeCertSrvSecurity(
	pCA->m_strCommonName, 
	IsEnterpriseCA(pCA->GetCAType()), 	// likely always enterprise, tho
	TRUE, 	// write it to the DS
	CS_UPGRADE_WIN2000);
_JumpIfError(hr, error, "csiUpgradeCertSrvSecurity");

        hr = AddCAMachineToCertPublishers();
        _JumpIfError(hr, error, "AddCAMachineToCertPublishers");

        if (RestartService(hwndMain, pCA->m_pParentMachine))
        {
        // notify views: refresh service toolbar buttons
        m_pConsole->UpdateAllViews(
            lpDataObject,
            0,
            0);
        }

error:
if (hr != S_OK)
    DisplayGenericCertSrvError(m_pConsole, hr);

                    }
                }
                else
                {
                    // just warn
                    CString cstrTmp;
                    cstrTmp.LoadString(IDS_BLOCK_W2K_SECURITY_UPGRADE);
                    cstrMsg += cstrTmp;

                    m_pConsole->MessageBoxW(cstrMsg, cstrTitle, MB_OK, NULL);
                }
            }
    }
*/

Ret:

    return hr;
}

HRESULT CComponentDataImpl::BaseFolderInsertIntoScope(CFolder* pFolder, CertSvrCA* pCA)
{
    HRESULT hr = S_OK;
    int nImage;
    
    HSCOPEITEM pParent = m_pStaticRoot; // we'll always be initialized by this time if parent exists
    ASSERT(m_pStaticRoot);
    if (NULL == m_pStaticRoot)
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "m_pStaticRoot");
    }

    if ((NULL == pFolder) || (NULL == pCA))
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "NULL ptr");
    }


    if (pCA->m_strCommonName.IsEmpty())
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "m_strCommonName");
    }

    if (m_pCertMachine->IsCertSvrServiceRunning())
        nImage = IMGINDEX_CERTSVR_RUNNING;
    else
        nImage = IMGINDEX_CERTSVR_STOPPED;

    pFolder->SetScopeItemInformation(nImage, nImage);
    pFolder->SetProperties(
            pCA->m_strCommonName, 
            SCOPE_LEVEL_ITEM, 
            SERVER_INSTANCE, 
            TRUE);

    pFolder->m_pCertCA = pCA; // fill this in as root

    // Set the parent
    pFolder->m_ScopeItem.mask |= SDI_PARENT;
    pFolder->m_ScopeItem.relativeID = pParent;

    // Set the folder as the cookie
    pFolder->m_ScopeItem.mask |= SDI_PARAM;
    pFolder->m_ScopeItem.lParam = reinterpret_cast<LPARAM>(pFolder);
    pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));

    // insert SCOPE_LEVEL_ITEM into scope pane
    m_pScope->InsertItem(&pFolder->m_ScopeItem);


    // Note - On return, the ID member of 'm_ScopeItem' 
    // contains the handle to the newly inserted item!
    ASSERT(pFolder->m_ScopeItem.ID != NULL);
Ret:

    return hr;
}

HRESULT CComponentDataImpl::CreateTemplateFolders(CertSvrCA* pCA)
{
    HRESULT hr = S_OK;

    // add all template folders under it
    for (int iUnder=0; iUnder < ARRAYLEN(SvrFuncFolderData); iUnder++)
    {
        // skip alien if svr doesn't support
        if ((iUnder==ENUM_FOLDER_ALIEN) && !pCA->FDoesServerAllowForeignCerts())
            continue;

        CString cstrRsc;
        cstrRsc.LoadString(SvrFuncFolderData[iUnder].iNameRscID);

        CFolder* pFolder;
        pFolder = new CFolder();
        _JumpIfOutOfMemory(hr, Ret, pFolder);

        pFolder->m_pCertCA = pCA;
        pFolder->SetScopeItemInformation(IMGINDEX_FOLDER, IMGINDEX_FOLDER_OPEN);
        pFolder->SetProperties(
                        cstrRsc, 
                        CA_LEVEL_ITEM,
                        SvrFuncFolderData[iUnder].type, 
                        FALSE);

        m_scopeItemList.AddTail(pFolder);
    }

Ret:
    return hr;
}


void CComponentDataImpl::EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent)
{
    ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface
    ASSERT(lpDataObject != NULL);

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
        return;

    MMC_COOKIE cookie = pInternal->m_cookie;

    FREE_DATA(pInternal);

    // Enumerate the scope pane
    // return the folder object that represents the cookie
    // Note - for large list, use dictionary
    CFolder* pStatic = FindObject(cookie);
    if (pStatic)
        ASSERT(!pStatic->IsEnumerated());

    if (NULL == cookie)    
    {
        if (!m_fScopeAlreadyEnumerated)               // if base node and we've never inserted nodes
        {
            // TASK: expand machine node

            // Note - Each cookie in the scope pane represents a folder.
            // Cache the HSCOPEITEM of the static root.
            ASSERT(pParent != NULL); 
            m_pStaticRoot = pParent;    // add/remove: EXPAND case

            // synch folder list if asking to expand machine node
            // SyncDisplayedCAList adds all necessary folders
            HRESULT hr = SynchDisplayedCAList(lpDataObject);
            if (hr != S_OK)
            {
                HWND hwnd;
                DWORD dwErr2 = m_pConsole->GetMainWindow(&hwnd);
                ASSERT(dwErr2 == ERROR_SUCCESS);
                if (dwErr2 != ERROR_SUCCESS)
                    hwnd = NULL;        // should work

                if (((HRESULT)RPC_S_SERVER_UNAVAILABLE) == hr)
                {
                    DisplayCertSrvErrorWithContext(hwnd, hr, IDS_SERVER_UNAVAILABLE);
                }
                else if(HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)==hr ||
                        ((HRESULT)ERROR_OLD_WIN_VERSION)==hr)
                {
                    DisplayCertSrvErrorWithContext(hwnd, hr, IDS_OLD_CA);
                }
                else
                {
                    DisplayGenericCertSrvError(hwnd, hr);
                }
            }
        }
    }
    else
    {
        // TASK: expand non-machine node
        if (NULL == pStatic)
            return;

        switch(pStatic->GetType())
        {
        case SERVER_INSTANCE:
            {
                // TASK: expand CA instance node

                POSITION pos = m_scopeItemList.GetHeadPosition();
                while(pos)
                {
                    CFolder* pFolder;
                    pFolder = m_scopeItemList.GetNext(pos);
                    if (pFolder==NULL)
                        break;

                    // only expand folders that belong under the SERVER_INSTANCE
                    if (pFolder->m_itemType != CA_LEVEL_ITEM)
                        continue;

                    // and only those under the correct CA
                    if (pFolder->m_pCertCA != pStatic->m_pCertCA)
                        continue;

                    // Set the parent
                    pFolder->m_ScopeItem.relativeID = pParent;

                    // Set the folder as the cookie
                    pFolder->m_ScopeItem.mask |= SDI_PARAM;
                    pFolder->m_ScopeItem.lParam = reinterpret_cast<LPARAM>(pFolder);
                    pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
                    m_pScope->InsertItem(&pFolder->m_ScopeItem);

                    // Note - On return, the ID member of 'm_ScopeItem' 
                    // contains the handle to the newly inserted item!
                    ASSERT(pFolder->m_ScopeItem.ID != NULL);
                }
            }
            break;
        default:
            // TASK: expand nodes with no folders under them
            break;
        }
    }
}


CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie)
{
    CFolder* pFolder = NULL;
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);

        if (*pFolder == cookie)
            return pFolder;
    }

    return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

    if ((pScopeDataItem->mask & SDI_STR) && (pFolder != NULL))
    {
        pScopeDataItem->displayname = pFolder->m_pszName;
    }

    // I was told by Ravi Rudrappa that these notifications 
    // would never be given. If it is given, move UpdateScopeIcons() 
    // functionality here!!!
    ASSERT(0 == (pScopeDataItem->mask & SDI_IMAGE));
    ASSERT(0 == (pScopeDataItem->mask & SDI_OPENIMAGE));

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    HRESULT hr = S_FALSE;

    // Make sure both data object are mine
    INTERNAL* pA = ExtractInternalFormat(lpDataObjectA);
    INTERNAL* pB = ExtractInternalFormat(lpDataObjectA);

   if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

   
   FREE_DATA(pA);
   FREE_DATA(pB);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle, 
                    LPDATAOBJECT lpIDataObject)
{
    HRESULT hr = S_OK;

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);

    PropertyPage* pBasePage;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (pInternal == NULL)
        return S_OK;
   
    switch (pInternal->m_type)
    {
    case CCT_SNAPIN_MANAGER:
        {
            CChooseMachinePropPage* pPage = new CChooseMachinePropPage();
            _JumpIfOutOfMemory(hr, Ret, pPage);

            // this alloc might have failed (should be in ctor)
            _JumpIfOutOfMemory(hr, Ret, m_pCertMachine);

            pPage->SetCaption(IDS_SCOPE_MYCOMPUTER);

	        // Initialize state of object
        	pPage->InitMachineName(NULL);
           
            // point to our member vars
            pPage->SetOutputBuffers(
		        &m_pCertMachine->m_strMachineNamePersist,
		        &m_pCertMachine->m_strMachineName,
                &m_dwFlagsPersist);	

            pBasePage = pPage;

            // Object gets deleted when the page is destroyed
            ASSERT(lpProvider != NULL);

            ASSERT(pBasePage != NULL);
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
            if (hPage == NULL)
            {
                hr = myHLastError();
                _JumpError(hr, Ret, "CreatePropertySheetPage");
            }

            lpProvider->AddPage(hPage);

            break;
        }
    case CCT_SCOPE:
        {
            // if not base scope
            if (0 != pInternal->m_cookie)
            {
                // switch on folder type
                CFolder* pFolder = GetParentFolder(pInternal);
                ASSERT(pFolder != NULL);
                if (pFolder == NULL)
                {
                    hr = E_POINTER;
                    _JumpError(hr, Ret, "GetParentFolder");
                }

                switch(pFolder->m_type) 
                {
                case SERVER_INSTANCE:
                {
                    //1 
                    CSvrSettingsGeneralPage* pControlPage = new CSvrSettingsGeneralPage(pFolder->m_pCertCA);
                    if (pControlPage != NULL)
                    {
                        pControlPage->m_hConsoleHandle = handle;   // only do this on primary
                        pBasePage = pControlPage;
                        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                        if (hPage == NULL)
                        {
                            hr = myHLastError();
                            _JumpError(hr, Ret, "CreatePropertySheetPage");
                        }
                        lpProvider->AddPage(hPage);
                    }

                    //2
                    {
                        CSvrSettingsPolicyPage* pPage = new CSvrSettingsPolicyPage(pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }

                    //3
                    {
                        CSvrSettingsExitPage* pPage = new CSvrSettingsExitPage(pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }
            
                    //4 
                    {
                        // Centralized extensions page available only in whistler
                        if (pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine())
                        {

                        CSvrSettingsExtensionPage* pPage = new CSvrSettingsExtensionPage(pFolder->m_pCertCA, pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                        } 
                    }

                    //5
                    {
                        CSvrSettingsStoragePage* pPage = new CSvrSettingsStoragePage(pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }
                    //6
                    {
                        // audit available only in whistler advanced server
                        if(pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine() && pFolder->m_pCertCA->FIsAdvancedServer())
                        {
                            CSvrSettingsCertManagersPage* pPage = 
                                new CSvrSettingsCertManagersPage(pControlPage);
                            if (pPage != NULL)
                            {
                                pBasePage = pPage;
                                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                                if (hPage == NULL)
                                {
                                    hr = myHLastError();
                                    _JumpError(hr, Ret, "CreatePropertySheetPage");
                                }
                                lpProvider->AddPage(hPage);
                            }
                        }
                    }
                    //7
                    {
                        // audit available only in whistler advanced server
                        if(pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine() && pFolder->m_pCertCA->FIsAdvancedServer())
                        {
                            CSvrSettingsAuditFilterPage* pPage = 
                                new CSvrSettingsAuditFilterPage(pControlPage);
                            if (pPage != NULL)
                            {
                                pBasePage = pPage;
                                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                                if (hPage == NULL)
                                {
                                    hr = myHLastError();
                                    _JumpError(hr, Ret, "CreatePropertySheetPage");
                                }
                                lpProvider->AddPage(hPage);
                            }
                        }
                    }
                    //8
                    {
                        // audit available only in whistler advanced server, enterprise
                        if(pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine() && pFolder->m_pCertCA->FIsAdvancedServer() && IsEnterpriseCA(pFolder->m_pCertCA->GetCAType()) )
                        {
                        CSvrSettingsKRAPage* pPage = new CSvrSettingsKRAPage(
                                                            pFolder->m_pCertCA,
                                                            pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                        }
                    }
                    //9
                    {
                        // if error, don't display this page
                        LPSECURITYINFO pCASecurity = NULL;

                        hr = CreateCASecurityInfo(pFolder->m_pCertCA,  &pCASecurity);
                        _PrintIfError(hr, "CreateCASecurityInfo");
                        
                        if (hr == S_OK)
                        {
                            // allow proppages to clean up security info
                            pControlPage->SetAllocedSecurityInfo(pCASecurity);
                        
                            HPROPSHEETPAGE hPage = CreateSecurityPage(pCASecurity);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }    

                    hr = S_OK;
                    break;
                }// end  case SERVER_INSTANCE
                case SERVERFUNC_CRL_PUBLICATION:
                {
                    //1
                    CCRLPropPage* pControlPage = new CCRLPropPage(pFolder->m_pCertCA);
                    if (pControlPage != NULL)
                    {
                        pControlPage->m_hConsoleHandle = handle;
                        pBasePage = pControlPage;

                        // Object gets deleted when the page is destroyed
                        ASSERT(lpProvider != NULL);
        
                        ASSERT(pBasePage != NULL);
                        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                        if (hPage == NULL)
                        {
                            hr = myHLastError();
                            _JumpError(hr, Ret, "CreatePropertySheetPage");
                        }

                        lpProvider->AddPage(hPage);
                    }
                    //2
                    {
                    CCRLViewPage* pPage = new CCRLViewPage(pControlPage);
                    if (pPage != NULL)
                    {
                        pBasePage = pPage;
                        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                        if (hPage == NULL)
                        {
                            hr = myHLastError();
                            _JumpError(hr, Ret, "CreatePropertySheetPage");
                        }

                        lpProvider->AddPage(hPage);
                    }
                    }
                    break;
                }
                default:
                    break;
                }   // end  switch(pFolder->m_type)
        
            } // end  switch(scope)
        }
        break;
    default:
        break;
    }

Ret:
    FREE_DATA(pInternal);
    return hr;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (NULL == pInternal)
        return S_FALSE;

    if (pInternal->m_cookie != NULL)
    {
        CFolder* pFolder = GetParentFolder(pInternal);
        if (pFolder != NULL)
        {
            switch(pFolder->m_type)
            {
            case SERVER_INSTANCE:
            case SERVERFUNC_CRL_PUBLICATION:
                bResult = TRUE;
            default:
                break;
            }
        }
    }
    else
    {
        // say YES to snapin manager
        if (CCT_SNAPIN_MANAGER == pInternal->m_type)
            bResult = TRUE;
    }
            
    FREE_DATA(pInternal);
    return (bResult) ? S_OK : S_FALSE;

    // Look at the data object and see if it an item in the scope pane
    // return IsScopePaneNode(lpDataObject) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject, 
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;

    // Note - snap-ins need to look at the data object and determine
    // in what context, menu items need to be added. They must also
    // observe the insertion allowed flags to see what items can be 
    // added.


    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (NULL == pInternal)
        return S_OK;

    BOOL fResultItem = (pInternal->m_type == CCT_RESULT);
    BOOL fMultiSel = IsMMCMultiSelectDataObject(pDataObject);

    CFolder* pFolder;
    if (!fResultItem)
        pFolder = GetParentFolder(pInternal);
    else
    {
        // GetParent might work, but doesn't for virtual items...
        ASSERT(m_pCurSelFolder);
        pFolder = m_pCurSelFolder;
    }

    FOLDER_TYPES folderType = NONE;
    if (pFolder == NULL)
        folderType = MACHINE_INSTANCE;
    else
        folderType = pFolder->GetType();

    // Loop through and add each of the "topItems"
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        // don't do for multisel
        if (!fMultiSel)
        {
            TASKITEM* pm = topItems;

            // Disable retarget if we haven't yet clicked on the static root. Otherwise, 
            // DisplayProperRootNodeName handles load-from-file
            // MMCN_EXPAND handles add/remove and expanded
            pm[ENUM_RETARGET_SNAPIN].myitem.item.fFlags = m_pStaticRoot ? MFS_ENABLED : MFS_GRAYED;

            for (; pm->myitem.item.strName; pm++)
            {
                // does it match scope/result type?
                if (fResultItem != ((pm->dwFlags & TASKITEM_FLAG_RESULTITEM) != 0) )
                    continue;

                // does it match area it should be in?
                // for each task, insert if matches the current folder
                if ((pm->type != SERVERFUNC_ALL_FOLDERS) && (folderType != pm->type))
                    continue;

                hr = pContextMenuCallback->AddItem(&pm->myitem.item);
                _JumpIfError(hr, Ret, "AddItem");
            }
        }
    }

    // this is the end of the line if folder nonexistant
    if (pFolder == NULL)
        goto Ret;

    // Loop through and add each of the view items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        // ptr to tasks
        TASKITEM* pm = taskItems;

        BOOL fRunningLocally = m_pCertMachine->IsLocalMachine();
        BOOL fSvcRunning = m_pCertMachine->IsCertSvrServiceRunning();
        if ( IsAllowedStartStop(pFolder, m_pCertMachine) )
            AddStartStopTasks(pContextMenuCallback, fSvcRunning);

        // only fixup on server instance
        if (folderType == SERVER_INSTANCE)
        {
            // fixup entries depending on install type/state
            if (IsRootCA(pFolder->GetCA()->GetCAType()))  // root ca?
            {
                pm[ENUM_TASK_INSTALL].myitem.item.fFlags = MFS_HIDDEN; // not available
                pm[ENUM_TASK_REQUEST].myitem.item.fFlags = MFS_HIDDEN; // not available
                pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_ENABLED; 
            }
            else   // sub ca
            {
                if (pFolder->GetCA()->FIsRequestOutstanding())
                    pm[ENUM_TASK_INSTALL].myitem.item.fFlags = MFS_ENABLED; 
                else
                    pm[ENUM_TASK_INSTALL].myitem.item.fFlags = MFS_HIDDEN; 
      
                if (pFolder->GetCA()->FIsIncompleteInstallation()) // incomplete
                {
                    pm[ENUM_TASK_REQUEST].myitem.item.fFlags = MFS_ENABLED; 
                    pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_HIDDEN;     // not available
                }
                else // complete install
                {
                    pm[ENUM_TASK_REQUEST].myitem.item.fFlags = MFS_HIDDEN; // not available
                    pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_ENABLED; 
                }
            }

            static bool fIsMember;
            static bool fIsMemberChecked = false;

            if(!fIsMemberChecked)
            {
                hr = IsCurrentUserBuiltinAdmin(&fIsMember);
                if(S_OK==hr)
                {
                    fIsMemberChecked = true;
                }
            }

            // Hide renew/install CA cert item if not local admin or if we
            // failed to figure it out. Ignore the error.

            // !!! Post Whistler when we get renew CA cert to work for non
            // local admin we should change the code here to hide the item
            // based on the role that is allowed to do it.
            if(S_OK != hr || !fIsMember)
            {
                pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_HIDDEN;
                
                hr = S_OK;
            }
        }


        // don't allow properties on multisel
        pm[ENUM_TASK_ATTREXTS_CRL].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;
        pm[ENUM_TASK_ATTREXTS_ISS].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;
        pm[ENUM_TASK_ATTREXTS_PEND].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;
        pm[ENUM_TASK_ATTREXTS_FAIL].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;

        // insert all other tasks per folder
        for (; pm->myitem.item.strName; pm++)
        {
            // does it match scope/result type?
            if (fResultItem != ((pm->dwFlags & TASKITEM_FLAG_RESULTITEM) != 0))
                continue;

            // are we remote, and is it marked localonly? (not yes/no like other tests here)
            if (((pm->dwFlags & TASKITEM_FLAG_LOCALONLY)) && (!fRunningLocally))
                continue;

            // does it match area it should be in?
            // for each task, insert if matches the current folder
            if ((pm->type != SERVERFUNC_ALL_FOLDERS) && (folderType != pm->type))
                continue;

            // is this task supposed to be hidden?
            if (MFS_HIDDEN == pm->myitem.item.fFlags)
                continue;

            hr = pContextMenuCallback->AddItem(&pm->myitem.item);
            _JumpIfError(hr, Ret, "AddItem");
        }        
    }

Ret:
    FREE_DATA(pInternal);
    return hr;
}


BOOL CComponentDataImpl::AddStartStopTasks(
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            BOOL fSvcRunning)
{
    HRESULT hr;
    MY_CONTEXTMENUITEM* pm = taskStartStop; 

    pm[ENUM_TASK_START].item.fFlags = fSvcRunning ? MF_GRAYED : MF_ENABLED;
    hr = pContextMenuCallback->AddItem(&pm[ENUM_TASK_START].item);
    _JumpIfError(hr, Ret, "AddItem");

    pm[ENUM_TASK_STOP].item.fFlags = fSvcRunning ? MF_ENABLED : MF_GRAYED;
    hr = pContextMenuCallback->AddItem(&pm[ENUM_TASK_STOP].item);
    _JumpIfError(hr, Ret, "AddItem");

Ret:
    return (hr == ERROR_SUCCESS);
}

STDMETHODIMP CComponentDataImpl::Command(LONG nCommandID, LPDATAOBJECT pDataObject)
{
    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.
    HRESULT dwErr = S_OK;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    ASSERT(pInternal);
    if (NULL == pInternal)
        return S_OK;

    BOOL fMustRefresh = FALSE;
    BOOL fPopup = TRUE;

    CFolder* pFolder = GetParentFolder(pInternal);

    // Handle each of the commands.
    switch (nCommandID)
    {
    case IDC_STOPSERVER:
    {
        HWND hwndMain;
        dwErr = m_pConsole->GetMainWindow(&hwndMain);

        if (dwErr == S_OK)
            dwErr = m_pCertMachine->CertSvrStartStopService(hwndMain, FALSE);


        // notify views: refresh service toolbar buttons
        fMustRefresh = TRUE;
        break;
    }
    case IDC_STARTSERVER:
    {
        HWND hwndMain;
        dwErr = m_pConsole->GetMainWindow(&hwndMain);
        
        if (S_OK == dwErr)
            dwErr = m_pCertMachine->CertSvrStartStopService(hwndMain, TRUE);


        // check for ERROR_INSTALL_SUSPEND or HR(ERROR_INSTALL_SUSPEND)!!
        if ((((HRESULT)ERROR_INSTALL_SUSPEND) == dwErr) || (HRESULT_FROM_WIN32(ERROR_INSTALL_SUSPEND) == dwErr))
        {
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_COMPLETE_HIERARCHY_INSTALL_MSG); 
            cstrTitle.LoadString(IDS_MSG_TITLE);

            CertSvrCA* pCA;

            for (DWORD i=0; i<m_pCertMachine->GetCaCount(); i++)
            {
                pCA = m_pCertMachine->GetCaAtPos(i);

                // search for any/all incomplete hierarchies
                if (pCA->FIsIncompleteInstallation())
                {
                    int iRet;
                    WCHAR sz[512];
                    wsprintf(sz, (LPCWSTR)cstrMsg, (LPCWSTR)pCA->m_strCommonName, (LPCWSTR)pCA->m_strServer);

                    m_pConsole->MessageBox(
                        sz, 
                        cstrTitle,
                        MB_YESNO,
                        &iRet);
            
                    if (IDYES != iRet)
                        break;

	            dwErr = CARequestInstallHierarchyWizard(pCA, hwndMain, FALSE, FALSE);
                    if (dwErr != S_OK)
                    {
//                         fPopup = FALSE;// sometimes no notification -- better to have 2 dlgs
                         break;
                    }
                }
            }

            // my responsibility to start the service again
            if (dwErr == S_OK)
                dwErr = m_pCertMachine->CertSvrStartStopService(hwndMain, TRUE);
        }
        else if ((((HRESULT)ERROR_FILE_NOT_FOUND) == dwErr) || (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == dwErr))
        {
            // file not found error could be related to policy module
            WCHAR const *pwsz = myGetErrorMessageText(dwErr, TRUE);
            CString cstrFullMessage = pwsz;
	    if (NULL != pwsz)
	    {
		LocalFree(const_cast<WCHAR *>(pwsz));
	    }
            cstrFullMessage += L"\n\n";

            CString cstrHelpfulMessage;
            cstrHelpfulMessage.LoadString(IDS_POSSIBLEERROR_NO_POLICY_MODULE);
            cstrFullMessage += cstrHelpfulMessage;

            CString cstrTitle;
            cstrTitle.LoadString(IDS_MSG_TITLE);

            int iRet;
            m_pConsole->MessageBox(
                cstrFullMessage, 
                cstrTitle,
                MB_OK,
                &iRet);

            dwErr = ERROR_SUCCESS;
        }

        // notify views: refresh service toolbar buttons
        fMustRefresh = TRUE;
        break;
    }
    case IDC_PUBLISHCRL:
        {
        ASSERT(pInternal->m_type != CCT_RESULT);
        if (NULL == pFolder)
            break;

        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        ASSERT(dwErr == ERROR_SUCCESS);
        if (dwErr != ERROR_SUCCESS)
            hwnd = NULL;        // should work

        dwErr = PublishCRLWizard(pFolder->m_pCertCA, hwnd);
        break;

        // no refresh
        }
    case IDC_BACKUP_CA:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
            break;

        dwErr = CABackupWizard(pFolder->GetCA(), hwnd);

        // refresh the status of the CA -- may have started it during this operation
        fMustRefresh = TRUE;
        break;
        }
    case IDC_RESTORE_CA:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
            break;
         
        dwErr = CARestoreWizard(pFolder->GetCA(), hwnd);

        if ((myJetHResult(JET_errDatabaseDuplicate) == dwErr) || 
            HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY) == dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_ERR_RESTORE_OVER_EXISTING_DATABASE);
            dwErr = S_OK;
        }

        if (HRESULT_FROM_WIN32(ERROR_DIRECTORY) == dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_ERR_RESTORE_OUT_OF_ORDER);
            dwErr = S_OK;
        }

        // refresh after restore
        fMustRefresh = TRUE;

        break;
        }
    case IDC_SUBMITREQUEST:
        {
        HWND hwnd;
        WCHAR szCmdLine[MAX_PATH], szSysDir[MAX_PATH];

        STARTUPINFO sStartup;
        ZeroMemory(&sStartup, sizeof(sStartup));
        PROCESS_INFORMATION sProcess;
        ZeroMemory(&sProcess, sizeof(sProcess));
        sStartup.cb = sizeof(sStartup);

        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
            break;

 
        if (0 == GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
        {
           dwErr = GetLastError();
           break;
        }

        // exec "certutil -dump szReqFile szTempFile"
        wsprintf(szCmdLine, L"%s\\certreq.exe -config \"%s\"", szSysDir, (LPCWSTR)pFolder->GetCA()->m_strConfig);
        wcscat(szSysDir, L"\\certreq.exe");

        if (!CreateProcess(
          szSysDir, // exe
          szCmdLine, // full cmd line
          NULL,
          NULL,
          FALSE,
          CREATE_NO_WINDOW,
          NULL,
          NULL,
          &sStartup,
          &sProcess))
        {
            dwErr = GetLastError();
            break;
        }

        dwErr = S_OK;
        break;
        }
    case IDC_INSTALL_CA:
    case IDC_REQUEST_CA:
    case IDC_ROLLOVER_CA:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
        {
            dwErr = E_UNEXPECTED;
            break;
        }
        dwErr = CARequestInstallHierarchyWizard(pFolder->GetCA(), hwnd, (nCommandID==IDC_ROLLOVER_CA), TRUE);
        if (S_OK != dwErr)
        {
            // low level lib had popup 
//            fPopup = FALSE; // sometimes no notification -- better to have 2 dlgs
        }

        // notify views: refresh service toolbar buttons
        fMustRefresh = TRUE;

        break;
        }
    case IDC_RETARGET_SNAPIN:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        // this should be base folder ONLY
        if(pFolder != NULL)
        {
            dwErr = E_POINTER;
            break;
        }

        CString strMachineNamePersist, strMachineName;
        CChooseMachinePropPage* pPage = new CChooseMachinePropPage();       // autodelete proppage -- don't delete
        if (pPage == NULL)
        {
            dwErr = E_OUTOFMEMORY;
            break;
        }

        pPage->SetCaption(IDS_SCOPE_MYCOMPUTER);

	    // Initialize state of object
        pPage->InitMachineName(NULL);
       
        // populate UI 
        strMachineNamePersist = m_pCertMachine->m_strMachineNamePersist;
        strMachineName = m_pCertMachine->m_strMachineName;

        // point to our member vars
        pPage->SetOutputBuffers(
		    &strMachineNamePersist,
		    &strMachineName,
            &m_dwFlagsPersist);	

        ASSERT(pPage != NULL);
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pPage->m_psp);
        if (hPage == NULL)
        {
            dwErr = E_UNEXPECTED;
            break;
        }

        PROPSHEETHEADER sPsh;
        ZeroMemory(&sPsh, sizeof(sPsh));
        sPsh.dwSize = sizeof(sPsh);
        sPsh.dwFlags = PSH_WIZARD;
        sPsh.hwndParent = hwnd;
        sPsh.hInstance = g_hInstance;
        sPsh.nPages = 1;
        sPsh.phpage = &hPage;

        dwErr = (DWORD) PropertySheet(&sPsh);
        if (dwErr == (HRESULT)-1)
        {
            // error
            dwErr = GetLastError();
            break;
        }
        if (dwErr == (HRESULT)0)
        {
            // cancel
            break;
        }

        // we've grabbed the user's choice by now, finish retargetting
        CertSvrMachine* pOldMachine = m_pCertMachine;
        m_pCertMachine = new CertSvrMachine;
        if (NULL == m_pCertMachine)
        {
            m_pCertMachine = pOldMachine;
            break;  // bail!
        }

        // copy to machine object
        m_pCertMachine->m_strMachineNamePersist = strMachineNamePersist;
        m_pCertMachine->m_strMachineName = strMachineName;

        dwErr = DisplayProperRootNodeName(m_pStaticRoot); // fix display
        _PrintIfError(dwErr, "DisplayProperRootNodeName");

        dwErr = SynchDisplayedCAList(pDataObject);      // add/remove folders 
        _PrintIfError(dwErr, "SynchDisplayedCAList");
            
        // after Synch, we remove old machine -- there are no references left to it
        if (pOldMachine)
            pOldMachine->Release();

        fMustRefresh = TRUE;    // update folder icons, descriptions

        break;
        }
    default:
        ASSERT(FALSE); // Unknown command!
        break;
    }



    FREE_DATA(pInternal);

    if ((dwErr != ERROR_SUCCESS) && 
        (dwErr != ERROR_CANCELLED) && 
        (dwErr != HRESULT_FROM_WIN32(ERROR_CANCELLED)) && 
        (dwErr != HRESULT_FROM_WIN32(ERROR_NOT_READY))
        && fPopup)
    {
        HWND hwnd;
        DWORD dwErr2 = m_pConsole->GetMainWindow(&hwnd);
        ASSERT(dwErr2 == ERROR_SUCCESS);
        if (dwErr2 != ERROR_SUCCESS)
            hwnd = NULL;        // should work

        if (((HRESULT)RPC_S_SERVER_UNAVAILABLE) == dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_SERVER_UNAVAILABLE);
        }
        else if(HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)==dwErr ||
                ((HRESULT)ERROR_OLD_WIN_VERSION)==dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_OLD_CA);
        }
        else
        {
            DisplayGenericCertSrvError(hwnd, dwErr);
        }
    }

    // only do this once
    if (fMustRefresh)
    {
        // notify views: refresh service toolbar buttons
        m_pConsole->UpdateAllViews(
            pDataObject,
            0,
            0);
    }

    return S_OK;
}

void CComponentDataImpl::UpdateScopeIcons()
{
    CFolder* pFolder;
    POSITION pos;
    
    int nImage;
    
    // walk through our internal list, modify, and resend to scope
    pos = m_scopeItemList.GetHeadPosition();
    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);
        ASSERT(pFolder);
        if (NULL == pFolder)
            break;

        // only modify server instances
        if (pFolder->GetType() != SERVER_INSTANCE)
            continue;

        if (pFolder->m_pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
            nImage = IMGINDEX_CERTSVR_RUNNING;
        else
            nImage = IMGINDEX_CERTSVR_STOPPED;

        // folder currently has these values defined, right?
        ASSERT(pFolder->m_ScopeItem.mask & SDI_IMAGE);
        ASSERT(pFolder->m_ScopeItem.mask & SDI_OPENIMAGE);

        // These are the only values we wish to reset
        pFolder->m_ScopeItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        
        pFolder->m_ScopeItem.nImage = nImage;
        pFolder->m_ScopeItem.nOpenImage = nImage;

        // and send these changes back to scope
        m_pScope->SetItem(&pFolder->m_ScopeItem);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin

#ifndef _CSNAPIN_H_
#define _CSNAPIN_H_

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

typedef struct _MY_MMCBUTTON
{
    MMCBUTTON item;
    UINT uiString1;
    UINT uiString2;
    WCHAR szString1[MAX_RESOURCE_STRLEN];
    WCHAR szString2[MAX_RESOURCE_STRLEN];
} MY_MMCBUTTON, *PMY_MMCBUTTON;

MY_MMCBUTTON SvrMgrToolbar1Buttons[];

// File Versions
// current version
#define VER_CSNAPIN_SAVE_STREAM_3     0x03
// includes  m_dwViewID, m_RowEnum

// version written through Win2000 beta 3
#define VER_CSNAPIN_SAVE_STREAM_2     0x02
/////////////////////////////

template <class TYPE>
TYPE*       Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf);
CLSID*      ExtractClassID(LPDATAOBJECT lpDataObject);
GUID*       ExtractNodeType(LPDATAOBJECT lpDataObject);
INTERNAL*   ExtractInternalFormat(LPDATAOBJECT lpDataObject);

BOOL        IsMMCMultiSelectDataObject(IDataObject* pDataObject);
HRESULT     _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, DWORD dwViewID,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject);

CFolder*    GetParentFolder(INTERNAL* pInternal);


/////////////////////////////////////////////////////////////////////////////
// Snapin

//
// helper methods extracting data from data object
//
INTERNAL *   ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *    ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *       ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *      ExtractClassID(LPDATAOBJECT lpDataObject);


#define         g_szEmptyHeader L" "



enum CUSTOM_VIEW_ID
{
    VIEW_DEFAULT_LV = 0,
    VIEW_MICROSOFT_URL = 2,
};

class CSnapin :
    public IComponent,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IResultDataCompare,
    public IResultOwnerData,
    public IPersistStream,
    public CComObjectRoot
{
public:
    CSnapin();
    virtual ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
    COM_INTERFACE_ENTRY(IResultOwnerData)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()


// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, LONG* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IResultOwnerData
    STDMETHOD(FindItem)(LPRESULTFINDINFO pFindInfo, int* pnFoundIndex);
    STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex);
    STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // Only for debug purpose
    bool m_bInitializedC;
    bool m_bLoadedC;
    bool m_bDestroyedC;

// Helpers for CSnapin
public:
    void SmartEnableServiceControlButtons();
    void SetIComponentData(CComponentDataImpl* pData);

//    void RefreshFolder(CFolder* pFolder);
    CFolder* GetVirtualFolder();
    CFolder* GetParentFolder(INTERNAL* pInternal);

    BOOL IsPrimaryImpl()
    {
        CComponentDataImpl* pData =
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->IsPrimaryImpl();

        return FALSE;
    }

    void SetViewID(DWORD id) { m_dwViewID = id; }

#if DBG
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG

// Notify event handlers
protected:
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject, LPARAM arg);
    HRESULT OnContextHelp(LPDATAOBJECT lpDataObject);
    void    OnButtonClick(LPDATAOBJECT pdtobj, int idBtn);

    HRESULT QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                   LPDATAOBJECT* ppDataObject);

// IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                            LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            LONG *pInsertionAllowed);
    STDMETHOD(Command)(LONG nCommandID, LPDATAOBJECT pDataObject);


// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();

    HRESULT GetColumnSetData(MMC_COOKIE cookie, MMC_COLUMN_SET_DATA** ppColSetData);
    HRESULT GetColumnSortData(MMC_COOKIE cookie, int* piColSortIdx, BOOL* pfAscending);

    HRESULT BuildTemplateDisplayName(
        LPCWSTR pcwszFriendlyName, 
        LPCWSTR pcwszTemplateName,
        VARIANT& varDisplayName);

    HRESULT InitializeHeaders(MMC_COOKIE cookie);
    HRESULT InsertAllColumns(MMC_COOKIE cookie, CertViewRowEnum* pCertViewRowEnum);
    HRESULT DoInsertAllColumns(MMC_COLUMN_SET_DATA* pCols);
    HRESULT SynchColumns(MMC_COOKIE cookie);

// Result Helpers
    HRESULT GetRowColContents(CFolder* pFolder, LONG idxRow, LPCWSTR szColHead, PBYTE* ppbData, DWORD* pcbData, BOOL fStringFmt=FALSE);
    HRESULT GetCellContents(CertViewRowEnum* pCRowEnum, CertSvrCA* pCA, LONG idxRow, LONG idxCol, PBYTE pbData, DWORD* pcbData, BOOL fStringFmt);

// UI Helpers
    void HandleStandardVerbs(bool bDeselectAll, LPARAM arg, LPDATAOBJECT lpDataObject);
    void HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param);
	void HandleExtMenus(LPARAM arg, LPARAM param);
    void OnRefresh(LPDATAOBJECT pDataObject);

// Interface pointers
protected:
    LPCONSOLE2          m_pConsole;         // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;          // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPRESULTDATA        m_pResult;          // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult;     // My interface pointer to the result pane image list

    LPCONTROLBAR        m_pControlbar;      // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb;     // pointer the console verb

    LPTOOLBAR           m_pSvrMgrToolbar1;    // Toolbar for view
    LPCOLUMNDATA        m_pViewData;        // info on our columns


    CFolder*            m_pCurrentlySelectedScopeFolder;    // keep track of who has focus

    // all interesting view data here
    CertViewRowEnum     m_RowEnum;

private:
    BOOL                m_bIsDirty;
    CUSTOM_VIEW_ID      m_CustomViewID;
    BOOL                m_bVirtualView;

    // HACK HACK
    // used to override the sort order on MMCN_CLICK notifications --
    // the view data isn't set early enough in the process for us to use it
    // This must remain with view, there might be multiple near-simultaneous clicks happening
    typedef struct _COLCLICK_SORT_OVERRIDE
    {
        BOOL    fClickOverride;
        int     colIdx;
        DWORD   dwOptions;
    } COLCLICK_SORT_OVERRIDE;
    COLCLICK_SORT_OVERRIDE m_ColSortOverride;

    // HACK HACK
    // used to override the column selection on MMCN_COLUMNS_CHANGED notifications --
    // the view data isn't set early enough in the process for us to use it
    // This must remain with view, there might be multiple near-simultaneous insertions happening
    typedef struct _COLCLICK_SET_OVERRIDE
    {
        BOOL    fClickOverride;
        MMC_COLUMN_SET_DATA* pColSetData;
    } COLCLICK_SET_OVERRIDE;
    COLCLICK_SET_OVERRIDE m_ColSetOverride;


    // result row flag
    DWORD               m_dwKnownResultRows;
    DWORD KnownResultRows()      { return m_dwKnownResultRows; };
    void SetKnowResultRows(DWORD dwRows)     { m_dwKnownResultRows = dwRows; };
    void ResetKnowResultRows()   { m_dwKnownResultRows = 1; m_dwViewErrorMsg = S_OK; };

    DWORD               m_dwViewErrorMsg;
    CString             m_cstrViewErrorMsg;

    // keeps our col views seperate
    DWORD               m_dwViewID;

    // counter used to protect from reentrancy in ICertView (bug 339811)
    LONG   m_cViewCalls;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
};



class CSnapinAboutImpl :
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CSnapinAboutImpl, &CLSID_About>
{
public:
    CSnapinAboutImpl();
    ~CSnapinAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.About.1"), _T("Snapin.About"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CSnapinAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage,
                                    HBITMAP* hSmallImageOpen,
                                    HBITMAP* hLargeImage,
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};



#endif // #define _CSNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = 0;
unsigned int CDataObject::m_cfNodeID         = 0;
unsigned int CDataObject::m_cfCoClass        = 0; 
unsigned int CDataObject::m_cfNodeTypeString = 0;  
unsigned int CDataObject::m_cfDisplayName    = 0; 

unsigned int CDataObject::m_cfInternal       = 0;
unsigned int CDataObject::m_cfObjInMultiSel  = 0;
unsigned int CDataObject::m_cfIsMultiSel     = 0;
unsigned int CDataObject::m_cfPreloads       = 0;

                                                 

    
// The only additional clipboard format supported is to get the workstation name.
unsigned int CDataObject::m_cfSelectedCA_InstallType  = 0;
unsigned int CDataObject::m_cfSelectedCA_CommonName   = 0;
unsigned int CDataObject::m_cfSelectedCA_SanitizedName= 0;
unsigned int CDataObject::m_cfSelectedCA_MachineName  = 0;

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

CDataObject::CDataObject()
{
	USES_CONVERSION;

	m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
    m_cfNodeID         = RegisterClipboardFormat(CCF_COLUMN_SET_ID);
	m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
	m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  
	m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 

    m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);
    m_cfObjInMultiSel  = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
    m_cfIsMultiSel     = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
    m_cfPreloads       = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);


    m_cfSelectedCA_InstallType  = RegisterClipboardFormat(SNAPIN_CA_INSTALL_TYPE);
    m_cfSelectedCA_CommonName   = RegisterClipboardFormat(SNAPIN_CA_COMMON_NAME);
    m_cfSelectedCA_MachineName  = RegisterClipboardFormat(SNAPIN_CA_MACHINE_NAME);
    m_cfSelectedCA_SanitizedName   = RegisterClipboardFormat(SNAPIN_CA_SANITIZED_NAME);

    m_pComponentData = NULL;
    #ifdef _DEBUG
        dbg_refCount = 0;
    #endif

    m_cbMultiSelData = 0;
    m_bMultiSelDobj = FALSE;

    m_dwViewID = -1;
}

STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
	HRESULT hr = S_FALSE;

    if ( lpFormatetc )
    {
		const CLIPFORMAT cf = lpFormatetc->cfFormat;

        if ( cf == m_cfIsMultiSel )
        {
        hr = S_FALSE;   // always return this; MMC returns S_OK if ptr to SI_MS_DO 
//            hr = (m_bMultiSelDobj ? S_OK : S_FALSE);
        }
		else if (	cf == m_cfNodeType ||
                    cf == m_cfNodeID ||
					cf == m_cfCoClass ||
					cf == m_cfNodeTypeString ||
					cf == m_cfDisplayName ||
                    cf == m_cfObjInMultiSel ||
					cf == m_cfInternal ||
                    cf == m_cfPreloads ||
                    cf == m_cfSelectedCA_SanitizedName ||
                    cf == m_cfSelectedCA_MachineName ||
                    cf == m_cfSelectedCA_CommonName ||
                    cf == m_cfSelectedCA_InstallType

				)
			{
				hr = S_OK;
			}
    }

    return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfObjInMultiSel)
    {
        hr = CreateObjInMultiSel(lpMedium);
    }
    else if (cf == m_cfNodeID)
    {
        hr = CreateNodeIDData(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfPreloads)
    {
        hr = CreatePreloadsData(lpMedium);
    }
    else if (cf == m_cfSelectedCA_CommonName)
    {
        hr = CreateSelectedCA_CommonName(lpMedium);
    }
    else if (cf == m_cfSelectedCA_SanitizedName)
    {
        hr = CreateSelectedCA_SanitizedName(lpMedium);
    }
    else if (cf == m_cfSelectedCA_MachineName)
    {
        hr = CreateSelectedCA_MachineName(lpMedium);
    }
    else if (cf == m_cfSelectedCA_InstallType)
    {
        hr = CreateSelectedCA_InstallType(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            ULONG written;

            if (NULL == lpMedium->hGlobal) 
            {
                // always return a valid hGlobal for the caller
                hr = GetHGlobalFromStream(lpStream, &lpMedium->hGlobal);
                if (hr != S_OK)
                    goto err;
            }

            // Write to the stream the number of bytes
            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

err:
    return hr;
}

HRESULT CDataObject::CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;
    BYTE* pb;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "Invalid args");
    }

    // Make sure the type medium is HGLOBAL
    lpMedium->tymed = TYMED_HGLOBAL; 

    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, (len));
    _JumpIfOutOfMemory(hr, Ret, lpMedium->hGlobal);

    pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    CopyMemory(pb, pBuffer, len);
    ::GlobalUnlock(lpMedium->hGlobal);

    hr = S_OK;

Ret:
    return hr;
}

const GUID* FolderTypeToNodeGUID(DATA_OBJECT_TYPES type, CFolder* pFolder)
{
    const GUID* pcObjectType = NULL;

    if (pFolder == NULL)
    {
        pcObjectType = &cNodeTypeMachineInstance;
    }
    else if (type == CCT_SCOPE)
    {
        switch (pFolder->GetType())
        {
        case SERVER_INSTANCE:
            pcObjectType = &cNodeTypeServerInstance;
            break;

        case SERVERFUNC_CRL_PUBLICATION:
            pcObjectType = &cNodeTypeCRLPublication;
            break;

        case SERVERFUNC_ISSUED_CERTIFICATES:
            pcObjectType = &cNodeTypeIssuedCerts;
            break;

        case SERVERFUNC_PENDING_CERTIFICATES:
            pcObjectType = &cNodeTypePendingCerts;
            break;

        case SERVERFUNC_FAILED_CERTIFICATES:
            pcObjectType = &cNodeTypeFailedCerts;
            break;

        case SERVERFUNC_ALIEN_CERTIFICATES:
            pcObjectType = &cNodeTypeAlienCerts;
            break;
        
        default:
            ASSERT(0);
            pcObjectType = &cNodeTypeDynamic;
            break;
        }
    }
    else if (type == CCT_RESULT)
    {
        // RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(m_internal.m_cookie);
        
        pcObjectType = &cObjectTypeResultItem;
    }
    else
    {
        ASSERT(0);
    }

    return pcObjectType;
}

HRESULT CDataObject::CreateNodeIDData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pFolderGuid = NULL;
    PBYTE pbWritePtr;

// Instance guid, node guid, dwViewIndex
#define CDO_CNID_SIZE ( (2*sizeof(GUID))+ sizeof(DWORD) + FIELD_OFFSET(SNodeID2, id) )

    BYTE bSNodeID2[CDO_CNID_SIZE];
    ZeroMemory(&bSNodeID2, CDO_CNID_SIZE);
    SNodeID2* psColID = (SNodeID2*)bSNodeID2;

    pFolderGuid = FolderTypeToNodeGUID(m_internal.m_type, reinterpret_cast<CFolder*>(m_internal.m_cookie));
    if (pFolderGuid == NULL)
        return E_FAIL;

    if (m_pComponentData == NULL)
        return E_FAIL;

    // node ID is {GUIDInstance|GUIDNode}
    psColID->cBytes = 2*sizeof(GUID) + sizeof(DWORD);

    pbWritePtr = psColID->id;
    CopyMemory(pbWritePtr, &m_pComponentData->m_guidInstance, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

    CopyMemory(pbWritePtr, pFolderGuid, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

//    ASSERT(m_dwViewID != -1);
//  UNDONE UNDONE: MMC will soon call for this data through IComponent, not IComponentData
//    this will allow us to set this as we desire
    *(DWORD*)pbWritePtr = m_dwViewID;

    // copy structure only
    return CreateVariableLen(reinterpret_cast<const void*>(psColID), CDO_CNID_SIZE, lpMedium);
}

HRESULT CDataObject::CreateObjInMultiSel(LPSTGMEDIUM lpMedium)
{
    HRESULT hr;
    ASSERT(m_cbMultiSelData != 0);

    ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
    if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
        return E_FAIL;
    
    // copy guid + len
    hr = CreateVariableLen(&m_sGuidObjTypes, m_cbMultiSelData, lpMedium);

//Ret:
    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pcObjectType = NULL;

    pcObjectType = FolderTypeToNodeGUID(m_internal.m_type, reinterpret_cast<CFolder*>(m_internal.m_cookie));
    if (pcObjectType == NULL)
        return E_FAIL;

    return Create(reinterpret_cast<const void*>(pcObjectType), sizeof(GUID), 
                  lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    const WCHAR* cszObjectType = NULL;

    if (m_internal.m_cookie == NULL)
    {
        cszObjectType = cszNodeTypeMachineInstance;
    }
    else if (m_internal.m_type == CCT_SCOPE)
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
        ASSERT(pFolder != NULL);
        if (pFolder == NULL)
            return E_UNEXPECTED;

        switch (pFolder->GetType())
        {
        case SERVER_INSTANCE:
            cszObjectType = cszNodeTypeServerInstance;
            break;
    
        case SERVERFUNC_CRL_PUBLICATION:
            cszObjectType = cszNodeTypeCRLPublication;
            break;

        case SERVERFUNC_ISSUED_CERTIFICATES:
            cszObjectType = cszNodeTypeIssuedCerts;
            break;

        case SERVERFUNC_PENDING_CERTIFICATES:
            cszObjectType = cszNodeTypePendingCerts;
            break;

        case SERVERFUNC_FAILED_CERTIFICATES:
            cszObjectType = cszNodeTypeFailedCerts;
            break;

        default:
            ASSERT(0);
            cszObjectType = cszNodeTypeDynamic;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        // RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(m_internal.m_cookie);
        
        cszObjectType = cszObjectTypeResultItem;
    }
    else
        return E_UNEXPECTED;

    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name to display
    // Note - if this is not provided, the console will used the snap-in name
    CString strFormat, strMachine, strFinished;
    strFormat.LoadString(IDS_NODENAME_FORMAT);

    if (NULL == m_pComponentData)
        return E_POINTER;

    if (m_pComponentData->m_pCertMachine->m_strMachineName.IsEmpty())
        strMachine.LoadString(IDS_LOCALMACHINE);
    else
        strMachine = m_pComponentData->m_pCertMachine->m_strMachineName;

    strFinished.Format(strFormat, strMachine);

	return Create(strFinished, ((strFinished.GetLength()+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_CommonName(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();

    ASSERT(pCA != NULL);
    ASSERT(pCA->m_strCommonName.GetLength() != 0);


    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pCA->m_strCommonName, ((pCA->m_strCommonName.GetLength()+1)*sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_SanitizedName(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();

    ASSERT(pCA != NULL);
    ASSERT(pCA->m_strSanitizedName.GetLength() != 0);


    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pCA->m_strSanitizedName, ((pCA->m_strSanitizedName.GetLength()+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_MachineName(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();
    ASSERT(pCA != NULL);
    
    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pCA->m_strServer, ((pCA->m_strServer.GetLength()+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_InstallType(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();
    ASSERT(pCA != NULL);
    
    DWORD dwFlags[2] = 
    {
        (DWORD) pCA->GetCAType(),
        (DWORD) pCA->FIsAdvancedServer(),
    };

    return Create(&dwFlags, sizeof(dwFlags), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}


HRESULT CDataObject::CreatePreloadsData(LPSTGMEDIUM lpMedium)
{
    BOOL bPreload = TRUE;

    return Create((LPVOID)&bPreload, sizeof(bPreload), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
#include "resource.h"
#include "genpage.h"

#include "chooser.h"
#include "cryptui.h"

#include "misc.h"

#include <htmlhelp.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// approx convert chars->pixels
#define CHARS_TO_MMCCOLUMNWIDTH(__strlen__)  ((int)(__strlen__ * 7))



enum ENUM_MMCBUTTONS
{
    ENUM_BUTTON_STARTSVC=0,
    ENUM_BUTTON_STOPSVC,
};

MY_MMCBUTTON SvrMgrToolbar1Buttons[] =
{
    {
        { 0, IDC_STARTSERVER, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"", L"" },
        IDS_TASKMENU_STARTSERVICE,
        IDS_TASKMENU_STATUSBAR_STARTSERVICE,
    },

    {
        { 1, IDC_STOPSERVER,  TBSTATE_ENABLED, TBSTYLE_BUTTON, L"",  L"" },
        IDS_TASKMENU_STOPSERVICE,
        IDS_TASKMENU_STATUSBAR_STOPSERVICE,
    },

    {
        { 0, 0, 0, 0, NULL, NULL },
        IDS_EMPTY,
        IDS_EMPTY,
    }
};

// Array of view items to be inserted into the context menu.
// keep this enum in synch with viewItems[]
enum ENUM_VIEW_ITEMS
{
    ENUM_VIEW_ALL=0,
    ENUM_VIEW_FILTER,
    ENUM_VIEW_SEPERATOR,
};

MY_CONTEXTMENUITEM viewResultItems[] =
{
    {
        {
        L"", L"",
        IDC_VIEW_ALLRECORDS, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
        },
        IDS_VIEWMENU_ALL_RECORDS,
        IDS_VIEWMENU_STATUSBAR_ALL_RECORDS,
    },

    {
        {
        L"", L"",
        IDC_VIEW_FILTER, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
        },
        IDS_VIEWMENU_FILTER,
        IDS_VIEWMENU_STATUSBAR_FILTER,
    },

    // seperator
    {
        {
        L"", L"",
        0, CCM_INSERTIONPOINTID_PRIMARY_VIEW, MF_ENABLED, CCM_SPECIAL_SEPARATOR
        },
        IDS_EMPTY,
        IDS_EMPTY,
    },

    {
        { NULL, NULL, 0, 0, 0 },
        IDS_EMPTY,
        IDS_EMPTY,
    }
};

enum ENUM_TASK_SINGLESELITEMS
{
    ENUM_TASK_SEPERATOR1=0,
    ENUM_TASK_UNREVOKE,
};

TASKITEM taskResultItemsSingleSel[] =
{
    // seperator

    {   SERVERFUNC_CRL_PUBLICATION,
        TRUE,
    {
        {
        L"", L"",
        0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
        },
        IDS_EMPTY,
        IDS_EMPTY,
    }
    },

    {   SERVERFUNC_CRL_PUBLICATION,
        TRUE,
        {
            {
            L"", L"",
            IDC_UNREVOKE_CERT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_UNREVOKECERT,
            IDS_TASKMENU_STATUSBAR_UNREVOKECERT,
        }
    },

    {   NONE,
        FALSE,
        {
            { NULL, NULL, 0, 0, 0 },
            IDS_EMPTY,
            IDS_EMPTY,
        }
    }
};


//
// Extracts the coclass guid format from the data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int cf)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)cf, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    int len;

    if (cf == CDataObject::m_cfSelectedCA_CommonName)
        len = (MAX_PATH+1) * sizeof(TYPE);
    else if (cf == CDataObject::m_cfSelectedCA_MachineName)
        len = (MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE);
    else
        len = sizeof(TYPE);


    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

    // Get the workstation name from the data object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;

    } while (FALSE);

    return p;
}

BOOL IsMMCMultiSelectDataObject(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    FORMATETC fmt = {(CLIPFORMAT)CDataObject::m_cfIsMultiSel, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}

// rip real pDataObject out of SMMCDataObjects struct
HGLOBAL GetMMCMultiSelDataObject(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static unsigned int s_cf = 0;
    if (s_cf == 0)
        s_cf = RegisterClipboardFormatW(CCF_MULTI_SELECT_SNAPINS);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (FAILED(pDataObject->GetData(&fmt, &stgmedium)))
        return NULL;

    return stgmedium.hGlobal;
}

// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    return Extract<CLSID>(lpDataObject, CDataObject::m_cfCoClass);
}

HGLOBAL ExtractNodeID(LPDATAOBJECT lpDataObject)
{
    if (lpDataObject == NULL)
        return FALSE;

    static unsigned int s_cf = 0;
    if (s_cf == 0)
        s_cf = RegisterClipboardFormatW(CCF_COLUMN_SET_ID);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (FAILED(lpDataObject->GetData(&fmt, &stgmedium)))
        return NULL;

    return stgmedium.hGlobal;
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    return Extract<GUID>(lpDataObject, CDataObject::m_cfNodeType);
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;
    if (lpDataObject == NULL)
        return NULL;

    // see if this is a multisel object
    HGLOBAL hMem = NULL;
    SMMCDataObjects* pRealObjectStruct = NULL;
    INTERNAL* pRet = NULL;

    if (IsMMCMultiSelectDataObject(lpDataObject))
    {
        // multisel object: extract real SMMCDataObjects
        hMem = GetMMCMultiSelDataObject(lpDataObject);
        _JumpIfOutOfMemory(hr, Ret, hMem);

        pRealObjectStruct = (SMMCDataObjects*)::GlobalLock(hMem);
        _JumpIfOutOfMemory(hr, Ret, pRealObjectStruct);

        // may be a number of data objs in here; find OURS
        BOOL fFound = FALSE;
        for (DWORD i=0; i<pRealObjectStruct->count; i++)
        {
            CLSID* pExtractedID = ExtractClassID(pRealObjectStruct->lpDataObject[i]);
            if (NULL != pExtractedID)
            {
                if (IsEqualCLSID(CLSID_Snapin, *pExtractedID))
                {
                    fFound = TRUE;
                    break;
                }

                // Free resources
                GlobalFree(reinterpret_cast<HANDLE>(pExtractedID));
           }
        }

        if (!fFound)
            goto Ret;

        // data obj that matches our CLSID
        lpDataObject = pRealObjectStruct->lpDataObject[i];
    }
    pRet = Extract<INTERNAL>(lpDataObject, CDataObject::m_cfInternal);
    if (pRet == NULL)
    {
        hr = myHLastError();
        _PrintIfError(hr, "Extract CDO::m_cfInternal returned NULL");
    }

Ret:
    // free hMem
    if (NULL != hMem)
    {
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }

    return pRet;
}


/*
// only for use by OnRefresh -- this is a worker fxn
void CSnapin::RefreshFolder(CFolder* pFolder)
{
    MMC_COOKIE cookie = (MMC_COOKIE)pFolder;

    if (pFolder != NULL)    // not base folder
    {
        // HIDE, remove all items, remove header, SHOW
        OnShow(cookie, FALSE, 0);              // emulate HIDE
        m_pResult->DeleteAllRsltItems();                    // delete items from m_pResult
        while(S_OK == m_pHeader->DeleteColumn(0)) {};       // remove all cols from header

        OnShow(cookie, TRUE, 0);               // emulate SHOW
    }
    return;
}
*/

CFolder*    CSnapin::GetParentFolder(INTERNAL* pInternal)
{
    CFolder* p;

    if(m_bVirtualView)
        p = GetVirtualFolder();
    else
        p = ::GetParentFolder(pInternal);

#if DBG
    if (p != m_pCurrentlySelectedScopeFolder)
    {
        if (NULL == p)
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived NULL, current saved folder is <%ws>\n", m_pCurrentlySelectedScopeFolder->m_pszName));
        else if (NULL == m_pCurrentlySelectedScopeFolder)
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived as <%ws>, current saved folder is NULL\n", p->m_pszName));
        else
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived as <%ws>, current saved folder is <%ws>\n", p->m_pszName, m_pCurrentlySelectedScopeFolder->m_pszName));
    }
#endif

    return p;
}

// independent of scope/result type, will return parent folder
CFolder*    GetParentFolder(INTERNAL* pInternal)
{
    if (NULL == pInternal)
        return NULL;

    if (CCT_SCOPE == pInternal->m_type)
    {
        return reinterpret_cast<CFolder*>(pInternal->m_cookie);
    }
    else if (CCT_RESULT == pInternal->m_type)
    {
        RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->pParentFolder;
    }

    return NULL;
}


HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, DWORD dwViewID,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    ASSERT(pImpl != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return E_OUTOFMEMORY;

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);
    pObject->SetViewID(dwViewID);

    // tell dataobj who we are
    pObject->SetComponentData(pImpl);

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}



/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CSnapin::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    ASSERT(lpDataObject);
    GUID* nodeType = ExtractNodeType(lpDataObject);

    if (NULL != nodeType)
    {
	    // Is this my main node (static folder node type)
	    if (::IsEqualGUID(*nodeType, cNodeTypeMachineInstance) == TRUE)
	        bResult = TRUE;

	    // Free resources
	    ::GlobalFree(reinterpret_cast<HANDLE>(nodeType));
    }
    return bResult;
}



/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation

STDMETHODIMP CSnapin::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType, LONG* pViewOptions)
{
    m_bVirtualView = FALSE;

    // custom view: check guid

    if (NULL == cookie)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        return S_FALSE;
    }

    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT | MMC_VIEW_OPTIONS_NOLISTVIEWS;

    // if ISSUED_CERT then make virtual list
    CFolder* pFolder = (CFolder*)cookie;
    if ((SERVERFUNC_CRL_PUBLICATION == pFolder->GetType()) ||
        (SERVERFUNC_ISSUED_CERTIFICATES == pFolder->GetType()) ||
        (SERVERFUNC_PENDING_CERTIFICATES == pFolder->GetType()) ||
        (SERVERFUNC_FAILED_CERTIFICATES == pFolder->GetType())  ||
        (SERVERFUNC_ALIEN_CERTIFICATES == pFolder->GetType()) )
    {
        *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
        m_bVirtualView = TRUE;
    }

    // if list view
    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    ASSERT(lpConsole != NULL);
    m_bInitializedC = true;

    // Save the IConsole pointer
    if (lpConsole == NULL)
        return E_POINTER;
    hr = lpConsole->QueryInterface(IID_IConsole2,
                        reinterpret_cast<void**>(&m_pConsole));
    _JumpIfError(hr, Ret, "QI IID_IConsole2");

    // QI for a IHeaderCtrl
    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));
    _JumpIfError(hr, Ret, "QI IID_IHeaderCtrl");

    // Give the console the header control interface pointer
    m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));
    _JumpIfError(hr, Ret, "QI IID_IResultData");

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    _JumpIfError(hr, Ret, "QueryResultImageList");

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    _JumpIfError(hr, Ret, "QueryConsoleVerb");

    hr = m_pConsole->QueryInterface(IID_IColumnData,
                        reinterpret_cast<void**>(&m_pViewData));
    _JumpIfError(hr, Ret, "QI IID_IViewData");

Ret:
    return hr;
}

// called by CompDataImpl on creation
void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}

STDMETHODIMP CSnapin::Destroy(MMC_COOKIE cookie)
{
    ASSERT(m_bInitializedC);
    m_bDestroyedC = true;

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in CSnapin::SetIComponent

        SAFE_RELEASE(m_pConsoleVerb);
        SAFE_RELEASE(m_pViewData);
    }

    return S_OK;
}


STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MMC_COOKIE cookie=0;

    if (IS_SPECIAL_DATAOBJECT(lpDataObject))
    {
        if (event == MMCN_BTN_CLICK)
        {
            if (m_CustomViewID != VIEW_DEFAULT_LV)
            {
                switch (param)
                {
                case MMC_VERB_REFRESH:

                    OnRefresh(lpDataObject);
                    break;

                case MMC_VERB_PROPERTIES:
                    break;

                default:
                    DBGPRINT((DBG_SS_CERTMMC, "MMCN_BTN_CLICK::param unknown"));
                    break;
                }
            }
        }
        else
        {
            switch (event)
            {
            case MMCN_VIEW_CHANGE:
            case MMCN_REFRESH:
                OnRefresh(lpDataObject);
                break;

            case MMCN_COLUMN_CLICK:

                // On click, we need to fix sorting.
                // Sorting info is usually retrieved from the view, but if a user column-clicks,
                // IComponent::Sort is called before GetColumnSortData() is updated.
                // In this case, we capture notification here and override GetColumnSortData() wrapper,
                // and force a folder refresh.

                // ask "IComponent::SortItems" if this is a valid column to sort on
                hr = SortItems((int)arg, (DWORD)param, NULL);

                // is sort allowed?
                if (S_OK == hr)
                {
                    m_ColSortOverride.colIdx = (int)arg;
                    m_ColSortOverride.dwOptions = (DWORD)param;
                }
                else
                {
                    // don't allow sort
                    m_ColSortOverride.colIdx = -1;
                }

                m_ColSortOverride.fClickOverride = TRUE;

                // notify view: sort was chosen
                OnRefresh(lpDataObject);

                m_ColSortOverride.fClickOverride = FALSE;

                // bug 322746: since we're add/removing columns we should send Sort request
            //    m_pResult->Sort((int)arg, (DWORD)param, NULL);

                break;
            }
        }

        return S_OK;
    }

    switch(event)
    {
    case MMCN_VIEW_CHANGE:
        hr = OnUpdateView(lpDataObject, arg);
        break;
    case MMCN_DESELECT_ALL:
        break;
    case MMCN_COLUMN_CLICK:
        break;
    case MMCN_SNAPINHELP:
        break;
    case MMCN_HELP:
    default:
        {
            INTERNAL* pInternal = NULL;

            if (IsMMCMultiSelectDataObject(lpDataObject) == FALSE)
            {
                pInternal = ExtractInternalFormat(lpDataObject);

                if (pInternal == NULL)
                {
                    ASSERT(FALSE);
                    return S_OK;
                }

                if (pInternal)
                    cookie = pInternal->m_cookie;
            }

            switch(event)
            {
            case MMCN_ACTIVATE:
                break;

            case MMCN_CLICK:
                hr = S_OK;
                break;

            case MMCN_DBLCLICK:

                // handle dblclick on Issued, CRL result items
                if (pInternal && (CCT_RESULT == pInternal->m_type))
                {
                    CFolder* pFolder = GetParentFolder(pInternal);

                    // if not base scope
                    ASSERT(pFolder != NULL);
                    if (pFolder == NULL)
                    {
                        hr = S_FALSE;
                        break;
                    }

                    // switch on folder type
                    switch(pFolder->m_type)
                    {
                    case SERVERFUNC_ISSUED_CERTIFICATES:
                    case SERVERFUNC_CRL_PUBLICATION:
                    case SERVERFUNC_ALIEN_CERTIFICATES:
                        ASSERT(!IsMMCMultiSelectDataObject(lpDataObject));
                        if (!IsMMCMultiSelectDataObject(lpDataObject))
                            Command(IDC_VIEW_CERT_PROPERTIES, lpDataObject);
                        break;
                    default:
                        break;
                    }
                }

                hr = S_FALSE; // returning S_FALSE here means "Do the default verb"
                break;

            case MMCN_ADD_IMAGES:
                OnAddImages(cookie, arg, param);
                break;

            case MMCN_SHOW:
                hr = OnShow(cookie, arg, param);
                break;

            case MMCN_MINIMIZED:
                hr = S_OK;
                break;

            case MMCN_INITOCX:
                break;

            case MMCN_DESELECT_ALL:
            case MMCN_SELECT:
                HandleStandardVerbs((event == MMCN_DESELECT_ALL),
                                    arg, lpDataObject);
                break;

            case MMCN_PASTE:
                break;

            case MMCN_DELETE:
                break;

            case MMCN_CONTEXTHELP:
                hr = OnContextHelp(lpDataObject);
                break;

            case MMCN_REFRESH:
                OnRefresh(lpDataObject);
                break;

            case MMCN_RENAME:
                break;

            case MMCN_COLUMNS_CHANGED:
                {
                    MMC_VISIBLE_COLUMNS* psMMCCols = (MMC_VISIBLE_COLUMNS*)param;
                    if (psMMCCols == NULL)
                        break;

                    MMC_COLUMN_SET_DATA* pColSetData;
#if DEBUG_COLUMNS_CHANGED

                    hr = GetColumnSetData(cookie, &pColSetData);
                    if (hr == S_OK)
                    {
                        DBGPRINT((DBG_SS_CERTMMC, "GetColumnSetData:\n"));
                        for (int i=0; i<pColSetData->nNumCols; i++)
                        {
                            DBGPRINT((DBG_SS_CERTMMC, 
                                L"pColData[%i]->nColIndex=%i (%s)\n", i, pColSetData->pColData[i].nColIndex, 
                                (pColSetData->pColData[i].dwFlags == HDI_HIDDEN) ? "hidden" : "shown"));
                        }

                        DBGPRINT((DBG_SS_CERTMMC, "VISIBLE_COLUMNS structure:\n"));
                        for (i=0; i<psMMCCols->nVisibleColumns; i++)
                        {
                            DBGPRINT((DBG_SS_CERTMMC, L"Col %i is shown\n", psMMCCols->rgVisibleCols[i]));
                        }

                        if (pColSetData)
                            CoTaskMemFree(pColSetData);
                    }
#endif // DEBUG_COLUMNS_CHANGED

                    // On click, we need to fix column data
                    // This is analagous to the sort problem above -- we're given this notification
                    // before we can properly call GetColumnSetData(). Refresh does this, so we 
                    // have to inform GetColumnSetData() of our true intent.

                    // fill in a fake COLUMN_SET_DATA, make it override 
                    DWORD dwSize = sizeof(MMC_COLUMN_SET_DATA) + (psMMCCols->nVisibleColumns)*sizeof(MMC_COLUMN_DATA);
                    pColSetData = (MMC_COLUMN_SET_DATA* )LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, dwSize);
                
                    if (pColSetData)
                    {
                        pColSetData->cbSize = sizeof(MMC_COLUMN_SET_DATA);
                        pColSetData->nNumCols = psMMCCols->nVisibleColumns;
                        pColSetData->pColData = (MMC_COLUMN_DATA*) ((PBYTE)pColSetData + sizeof(MMC_COLUMN_SET_DATA)); // point just after struct
                        MMC_COLUMN_DATA* pEntry = pColSetData->pColData;
                        for (int i=0; i<pColSetData->nNumCols ; i++)
                        {
                            pEntry->nColIndex = psMMCCols->rgVisibleCols[i];
                            pEntry++;
                        }
                        m_ColSetOverride.pColSetData = pColSetData;
                        m_ColSetOverride.fClickOverride = TRUE;
                    }
          
                    // refresh to kick off requery: columns changed!
                    OnRefresh(lpDataObject);

                    // teardown
                    m_ColSetOverride.fClickOverride = FALSE;
                    if (m_ColSetOverride.pColSetData)
                        LocalFree(m_ColSetOverride.pColSetData);
                }
                break;

            // Note - Future expansion of notify types possible
            default:
                hr = E_UNEXPECTED;
                break;
            }

            FREE_DATA(pInternal);

            break;
        }
    }

    return hr;
}

HRESULT CSnapin::OnUpdateView(LPDATAOBJECT pDataObject, LPARAM arg)
{
    OnRefresh(pDataObject);
    return S_OK;
}


void CSnapin::OnRefresh(LPDATAOBJECT pDataObject)
{
    CWaitCursor cwait;  // Could be long operation

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pData != NULL);

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

    // only allow scope refresh
    if ((pInternal == NULL) || (pInternal->m_type == CCT_SCOPE))
    {
        // refresh toolbars
        pData->m_pCertMachine->RefreshServiceStatus();
        pData->UpdateScopeIcons();
        SmartEnableServiceControlButtons();
    }
/*
    // Refresh the selected folder
    CFolder* pFolder = GetParentFolder(pInternal);
    RefreshFolder(pFolder);
*/
    // Instead, re-select the current folder (acts like refresh)
    // note side-effect: it causes race condition between redraw and 
    // MMCN_COLUMN_CLICKED database query -- MMC asks to draw cols that don't exist
    if (m_pConsole && m_pCurrentlySelectedScopeFolder)
        m_pConsole->SelectScopeItem(m_pCurrentlySelectedScopeFolder->m_ScopeItem.ID);

    FREE_DATA(pInternal);
}


HRESULT CSnapin::OnContextHelp(LPDATAOBJECT pdtobj)
{
    HRESULT	hr = S_OK;

    CString cstrHelpFile;
    IDisplayHelp*	pDisplayHelp = NULL;
    WCHAR szWindows[MAX_PATH];
    szWindows[0] = L'\0';

    hr = m_pConsole->QueryInterface (IID_IDisplayHelp, (void**)&pDisplayHelp);
    _JumpIfError(hr, Ret, "QI IDisplayHelp");

    if (0 == GetSystemWindowsDirectory(szWindows, MAX_PATH))
    {
        hr = myHLastError();
        _JumpError(hr, Ret, "GetSystemWindowsDirectory");
    }

    cstrHelpFile = szWindows;
    cstrHelpFile += HTMLHELP_COLLECTIONLINK_FILENAME;
    cstrHelpFile += L"::/sag_cs_topnode.htm";

    hr = pDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR)cstrHelpFile));
    _JumpIfError(hr, Ret, "ShowTopic");

Ret:
    if (pDisplayHelp)
        pDisplayHelp->Release();

    return hr;
}

HRESULT CSnapin::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    const GUID* pguid;

    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

    if (m_bVirtualView == TRUE)
    {
        ASSERT(GetVirtualFolder());
        switch(GetVirtualFolder()->GetType())
        {
            case SERVERFUNC_CRL_PUBLICATION:
                pguid = &cNodeTypeCRLPublication;
                break;
            case SERVERFUNC_ISSUED_CERTIFICATES:
                pguid = &cNodeTypeIssuedCerts;
                break;
            case SERVERFUNC_PENDING_CERTIFICATES:
                pguid = &cNodeTypePendingCerts;
                break;
            case SERVERFUNC_FAILED_CERTIFICATES:
                pguid = &cNodeTypeFailedCerts;
                break;
            case SERVERFUNC_ALIEN_CERTIFICATES:
                pguid = &cNodeTypeAlienCerts;
                break;
            default:
                return E_FAIL;
        }
    }

    CComObject<CDataObject>* pObject;
    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    if (NULL == pObject)
        return E_FAIL;

    // Save cookie and type for delayed rendering

    // fix type if unknown (is this valid?)
    if (type == CCT_UNINITIALIZED)
        type = CCT_RESULT;

    pObject->SetType(type);
    pObject->SetCookie(cookie);
    pObject->SetMultiSelDobj();

    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
#ifdef _DEBUG
    pObject->SetComponentData(pImpl);
#endif

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    // right now we know we have just 1 objtype
    SMMCObjectTypes sGuidObjTypes;
    sGuidObjTypes.count = 1;
    CopyMemory(&sGuidObjTypes.guid[0], pguid, sizeof(GUID));
    pObject->SetMultiSelData(&sGuidObjTypes, sizeof(sGuidObjTypes));

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    HRESULT hr;
    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        hr = QueryMultiSelectDataObject(cookie, type, ppDataObject);
    }
    else
    {
        // behavior: we may query for result or scope pane dataobjects
        // Delegate it to the IComponentData
        ASSERT(m_pComponentData != NULL);
        CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pImpl != NULL);

        // Query for dataobj -- cookie is index
        hr = _QueryDataObject(cookie, type, m_dwViewID, pImpl, ppDataObject);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
: m_bIsDirty(TRUE), m_bInitializedC(false), m_bDestroyedC(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    SAFE_RELEASE(m_pSvrMgrToolbar1);

    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    ASSERT(m_pSvrMgrToolbar1 == NULL);

    ASSERT(!m_bInitializedC || m_bDestroyedC);

    Construct();
}

void CSnapin::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;

    m_bVirtualView = FALSE;
    m_pCurrentlySelectedScopeFolder = NULL;

    m_pControlbar = NULL;

    m_pSvrMgrToolbar1 = NULL;

    m_pConsoleVerb = NULL;

    m_ColSortOverride.fClickOverride = FALSE;
    m_ColSetOverride.fClickOverride = FALSE;
    m_ColSetOverride.pColSetData = NULL;

    m_CustomViewID = VIEW_DEFAULT_LV;
    m_dwViewID = -1;

    m_cViewCalls = 0;
}

HRESULT CSnapin::SynchColumns(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;


    CString*    rgcstrCurSchemaHeading  = NULL;
    LONG*       rglCurSchemaType        = NULL;
    BOOL*       rgfCurSchemaIndexed     = NULL;
    DWORD       cCurSchemaEntries       = 0;

    int         i;
    BOOL        fSchemaChanged = FALSE;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if ((pFolder == NULL) || (NULL == pData))
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "pFolder or pData");
    }

    // if CCompDataImpl.m_rgLastKnownSchema is empty
    //      enumerate "Current Schema" and save in CCompDataImpl.m_rgLastKnownSchema

    // only resolve schema once per ccompdataimpl load
    if (!pData->m_fSchemaWasResolved)   // really, "SchemaWasUpdated"
    {
        pData->m_fSchemaWasResolved = TRUE;

        // get new schema
        hr = GetCurrentColumnSchema(
            pFolder->m_pCertCA->m_strConfig,
            &rgcstrCurSchemaHeading,
            &rglCurSchemaType,
            &rgfCurSchemaIndexed,
            (LONG*) &cCurSchemaEntries);
        _JumpIfError(hr, Ret, "GetCurrentColumnSchema");

        if (cCurSchemaEntries != pData->GetSchemaEntries())
        {
            fSchemaChanged = TRUE;
            DBGPRINT((DBG_SS_CERTMMC, "Schema change detected: knew %i, now %i entries\n", pData->GetSchemaEntries(), cCurSchemaEntries));
        }
        else
        {
            // for each entry, compare headings
            // report any diffc
            for (DWORD iEntry=0; iEntry<cCurSchemaEntries; iEntry++)
            {
                LPCWSTR sz;
                hr = pData->GetDBSchemaEntry(iEntry, &sz, NULL, NULL);
                _JumpIfError(hr, Ret, "GetDbSchemaEntry");

                if (!rgcstrCurSchemaHeading[iEntry].IsEqual(sz))
                {
                    fSchemaChanged = TRUE;
                    DBGPRINT((DBG_SS_CERTMMC, "Schema change detected: entry %i changed\n", iEntry));
                    break;
                }
            }
        }

        // boot old schema which only included strings.
        // now we have types and indexes
        DBGPRINT((DBG_SS_CERTMMC, "Updating saved schema\n"));
        hr = pData->SetDBSchema(rgcstrCurSchemaHeading, rglCurSchemaType, rgfCurSchemaIndexed, cCurSchemaEntries);
        _JumpIfError(hr, Ret, "SetDBSchema");

        // these are now owned by the class
        rgcstrCurSchemaHeading  = NULL;
        rglCurSchemaType        = NULL;
        rgfCurSchemaIndexed     = NULL;
        cCurSchemaEntries       = 0;

        if (fSchemaChanged)
        {
            DBGPRINT((DBG_SS_CERTMMC, "Resetting folders\n"));

            pData->ResetPersistedColumnInformation();    // create a new instance id (throws away all column width info)

            // whack every loaded folder
            POSITION pos = pData->m_scopeItemList.GetHeadPosition();
            while (pos)
            {
                CFolder* pTmp = pData->m_scopeItemList.GetNext(pos);
                ASSERT(pTmp);
                if (pTmp == NULL)
                    hr = E_UNEXPECTED;
                _JumpIfError(hr, Ret, "GetNext(pos) returns NULL");

                // if we find a folder with the same CA
                if (pTmp->GetCA() == pFolder->GetCA())
                {
                    switch (pTmp->GetType())
                    {
                    case SERVERFUNC_PENDING_CERTIFICATES:
                    case SERVERFUNC_CRL_PUBLICATION:
                    case SERVERFUNC_ISSUED_CERTIFICATES:
                    case SERVERFUNC_FAILED_CERTIFICATES:
                    case SERVERFUNC_ALIEN_CERTIFICATES:
                        // clear out cached data, it is stale
                        m_RowEnum.ResetColumnCount(pData->GetSchemaEntries());
                        break;

                    default:
                        break;
                    }   // end case
                }   // end if
            }   // end while folders
        }   // end if schema changed
    }

Ret:
    if (rgcstrCurSchemaHeading)
        delete [] rgcstrCurSchemaHeading;
    if (rglCurSchemaType)
        delete [] rglCurSchemaType;
    if (rgfCurSchemaIndexed)
        delete [] rgfCurSchemaIndexed;

    return hr;
}



HRESULT CSnapin::GetColumnSetData(MMC_COOKIE cookie, MMC_COLUMN_SET_DATA** ppColSetData)
{
    HRESULT hr;

    if (m_ColSetOverride.fClickOverride)
    {
        // give caller structure to free, but caller doesn't care that
        // he just gets a reference to our COLUMN_DATA array...

        *ppColSetData = (MMC_COLUMN_SET_DATA*)CoTaskMemAlloc(sizeof(MMC_COLUMN_SET_DATA));
        if (NULL != *ppColSetData)
        {
            CopyMemory(*ppColSetData, m_ColSetOverride.pColSetData, sizeof(MMC_COLUMN_SET_DATA));
            return S_OK;
        }
        // else fall through; worst case is "Err Invalid Index..." in UI
    }

    HGLOBAL hSNode2 = NULL;
    SColumnSetID* pColID = NULL;

    LPDATAOBJECT lpDataObject = NULL;

    hr = _QueryDataObject(cookie, CCT_SCOPE, m_dwViewID,
                         reinterpret_cast<CComponentDataImpl*>(m_pComponentData), &lpDataObject);
    _JumpIfError(hr, Ret, "_QueryDataObject");

    hSNode2 = ExtractNodeID(lpDataObject);
    _JumpIfOutOfMemory(hr, Ret, hSNode2);

    pColID = (SColumnSetID*)GlobalLock(hSNode2);
    _JumpIfOutOfMemory(hr, Ret, pColID);

    hr = m_pViewData->GetColumnConfigData(pColID, ppColSetData);
    _PrintIfError(hr, "GetColumnConfigData");

    if (*ppColSetData == NULL)
    {
        hr = E_FAIL;
        _JumpError(hr, Ret, "*ppColSetData NULL");
    }
    // register this allocation
    myRegisterMemAlloc(*ppColSetData, -1, CSM_COTASKALLOC);

Ret:
    if (hSNode2)
    {
        GlobalUnlock(hSNode2);
        GlobalFree(hSNode2);
    }

    if (lpDataObject)
        lpDataObject->Release();


    return hr;
}

HRESULT CSnapin::GetColumnSortData(MMC_COOKIE cookie, int* piColSortIdx, BOOL* pfAscending)
{
    HRESULT hr;

    if (m_ColSortOverride.fClickOverride)
    {
        // remove sort
        if (m_ColSortOverride.colIdx == -1)
            return E_FAIL;

        *piColSortIdx = m_ColSortOverride.colIdx;
        *pfAscending = ((m_ColSortOverride.dwOptions  & RSI_DESCENDING) == 0) ? TRUE : FALSE;
        return S_OK;
    }

    HGLOBAL hSNode2 = NULL;
    SColumnSetID* pColID = NULL;
    MMC_SORT_SET_DATA* pSortSetData = NULL;

    LPDATAOBJECT lpDataObject = NULL;

    hr = _QueryDataObject(cookie, CCT_SCOPE, m_dwViewID,
                         reinterpret_cast<CComponentDataImpl*>(m_pComponentData), &lpDataObject);
    _JumpIfError(hr, Ret, "_QueryDataObject");

    hSNode2 = ExtractNodeID(lpDataObject);
    _JumpIfOutOfMemory(hr, Ret, hSNode2);

    pColID = (SColumnSetID*)GlobalLock(hSNode2);
    _JumpIfOutOfMemory(hr, Ret, pColID);

    hr = m_pViewData->GetColumnSortData(pColID, &pSortSetData);
    _JumpIfError(hr, Ret, "GetColumnSortData");

    if (NULL == pSortSetData)
    {
        hr = E_FAIL;
        _JumpError(hr, Ret, "pSortSetData NULL");
    }
    myRegisterMemAlloc(pSortSetData, -1, CSM_COTASKALLOC);

    ASSERT(pSortSetData->nNumItems <= 1);
    if (pSortSetData->nNumItems == 0)
    {
        hr = E_FAIL;
        _JumpError(hr, Ret, "pSortSetData no sort");
    }

    *piColSortIdx = pSortSetData->pSortData[0].nColIndex;
    *pfAscending = ((pSortSetData->pSortData[0].dwSortOptions & RSI_DESCENDING) == 0) ? TRUE : FALSE;

Ret:
    if (hSNode2)
    {
        GlobalUnlock(hSNode2);
        GlobalFree(hSNode2);
    }

    if (lpDataObject)
        lpDataObject->Release();

    if (pSortSetData)
        CoTaskMemFree(pSortSetData);

    return hr;
}

HRESULT CSnapin::InsertAllColumns(MMC_COOKIE cookie, CertViewRowEnum* pCertViewRowEnum)
{
    HRESULT hr = S_OK;
    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    IEnumCERTVIEWCOLUMN* pColEnum = NULL;

    BOOL fColumnDataBad = FALSE;
    LONG iResultColCount;
    int iCachedColCount, iCache, i;
    BSTR bstrColumn = NULL;

    MMC_COLUMN_SET_DATA* pColConfigData = NULL;

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (NULL == pData)
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "pData NULL");
    }

    ICertView* pICertView;  // this is const, don't free
    hr = pCertViewRowEnum->GetView(pFolder->GetCA(), &pICertView);
    _JumpIfError(hr, Ret, "GetView");

    // always reset our column cache map
    hr = m_RowEnum.ResetColumnCount(pData->m_cLastKnownSchema);
    _JumpIfError(hr, Ret, "ResetColumnCount");

    // attempt to get column set data
    hr = GetColumnSetData(cookie, &pColConfigData);
    _PrintIfError2(hr, "GetColumnConfigData", E_FAIL);


    // call SetColumnCacheInfo to update final Result Indexes
    if ((hr != S_OK) ||                     // given    1) canned view or
        (pData->m_cLastKnownSchema != (unsigned int)pColConfigData->nNumCols) )
                                            //          2) pColConfigData doesn't agree with schema
    {
        if (hr == S_OK)
            fColumnDataBad = TRUE;

        // get col enumerator
        hr = pICertView->EnumCertViewColumn(TRUE, &pColEnum);
        _JumpIfError(hr, Ret, "EnumCertViewColumn");

        // get # of result cols
        hr = pICertView->GetColumnCount(TRUE, &iResultColCount);
        _JumpIfError(hr, Ret, "GetColumnCount");

        // this doesn't agree with schema -- throw it away
        if (pColConfigData)
        {
            CoTaskMemFree(pColConfigData);
            pColConfigData = NULL;
        }
        ASSERT(pColConfigData == NULL);

        // rig up a column set data as if we got it from mmc
        pColConfigData = (MMC_COLUMN_SET_DATA*)CoTaskMemAlloc(sizeof(MMC_COLUMN_SET_DATA) + (sizeof(MMC_COLUMN_DATA)*pData->m_cLastKnownSchema));
        _JumpIfOutOfMemory(hr, Ret, pColConfigData);

        ZeroMemory(pColConfigData, sizeof(MMC_COLUMN_SET_DATA) + (sizeof(MMC_COLUMN_DATA)*pData->m_cLastKnownSchema));
        pColConfigData->pColData = (MMC_COLUMN_DATA*) (((BYTE*)pColConfigData) + sizeof(MMC_COLUMN_SET_DATA)); // points to just after our struct
        pColConfigData->cbSize = sizeof(MMC_COLUMN_SET_DATA);
        pColConfigData->nNumCols = pData->m_cLastKnownSchema;

        for (i=0; i<(int)pData->m_cLastKnownSchema; i++)
        {
            pColConfigData->pColData[i].nColIndex = i;
            pColConfigData->pColData[i].dwFlags = HDI_HIDDEN;
        }

        for (i=0; i< iResultColCount; i++)
        {
            hr = pColEnum->Next((LONG*)&iCache);
            _JumpIfError(hr, Ret, "Next");

            hr = pColEnum->GetName(&bstrColumn);
            _JumpIfError(hr, Ret, "GetName");

            iCache = pData->FindColIdx(bstrColumn);
            _JumpIfError(hr, Ret, "FindColIdx");

            SysFreeString(bstrColumn);
            bstrColumn = NULL;

             // rig up column set data as if we got it from mmc
            pColConfigData->pColData[iCache].dwFlags = AUTO_WIDTH;

            hr = m_RowEnum.SetColumnCacheInfo(iCache, i);
            _JumpIfError(hr, Ret, "SetColumnCacheInfo");
        }
    }
    else
    {
        // get # of cols
        iResultColCount = m_RowEnum.GetColumnCount();

        // set col cache correctly
        int iResultIdx = 0;
        for (i=0; i< iResultColCount; i++)
        {
            BOOL fShown;
            hr = IsColumnShown(pColConfigData, i, &fShown);
            _JumpIfError(hr, Ret, "IsColumnShown");

            // update idxViewCol
            if (fShown)
            {
                hr = m_RowEnum.SetColumnCacheInfo(pColConfigData->pColData[i].nColIndex, iResultIdx);
                _JumpIfError(hr, Ret, "SetColumnCacheInfo");

                iResultIdx++;
            }
        }
    }

    hr = DoInsertAllColumns(pColConfigData);
    _JumpIfError(hr, Ret, "DoInsertAllColumns");

Ret:
    if (pColEnum)
        pColEnum->Release();

    if (bstrColumn)
        SysFreeString(bstrColumn);

    if(pColConfigData)
        CoTaskMemFree(pColConfigData);

    return hr;
}

HRESULT CSnapin::DoInsertAllColumns(MMC_COLUMN_SET_DATA* pCols)
{
    HRESULT hr = S_OK;

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    int i;

    if ((pCols == NULL) || (pData == NULL))
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "pCols or pData");
    }

    for (i=0; i<pCols->nNumCols; i++)
    {
        LPCWSTR szCachedHeading, pszLocal, pszUnlocal;
        BOOL fShown;

        hr = IsColumnShown(pCols, i, &fShown);
        _JumpIfError(hr, Ret, "IsColumnShown");

        hr = pData->GetDBSchemaEntry(i, &pszUnlocal, NULL, NULL);
        _JumpIfError(hr, Ret, "GetDBSchemaEntry");

        // returns pointer to static data; don't bother to free
        hr = myGetColumnDisplayName(
            pszUnlocal,
            &pszLocal);
        _PrintIfError(hr, "myGetColumnDisplayName");

        // if localized version not found, slap with raw name
        if (pszLocal == NULL)
            pszLocal = pszUnlocal;

        m_pHeader->InsertColumn(i, pszLocal, LVCFMT_LEFT, fShown ? AUTO_WIDTH : HIDE_COLUMN);
    }

Ret:
    return hr;
}


HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
    ASSERT(m_pHeader);

    HRESULT hr = S_OK;
    BOOL fInsertedHeaders=FALSE;

    USES_CONVERSION;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    MMC_COLUMN_SET_DATA* pColSetData = NULL;

    // Put the correct headers depending on the cookie
    if (pFolder == NULL)
    {
        // base scope
        m_pHeader->InsertColumn(0, W2COLE(g_cResources.m_ColumnHead_Name), LVCFMT_LEFT, 180);     // Name
        m_pHeader->InsertColumn(1, W2COLE(g_cResources.m_ColumnHead_Description), LVCFMT_LEFT, 180);     // Description
        fInsertedHeaders = TRUE;
    }
    else
    {
        switch (pFolder->m_type)
        {
        case SERVERFUNC_ISSUED_CERTIFICATES:
        case SERVERFUNC_CRL_PUBLICATION:    // or server functions
        case SERVERFUNC_PENDING_CERTIFICATES:
        case SERVERFUNC_ALIEN_CERTIFICATES:
        case SERVERFUNC_FAILED_CERTIFICATES:
            {
                LONG lCols;
                ICertView* pICertView;  // this is const, don't free
                IEnumCERTVIEWCOLUMN* pColEnum = NULL;

                m_dwViewErrorMsg = S_OK; // assume everything OK when initializing view

                // although we don't allow unsetting this mode,
                // we may inherit it from another snapin. Force report mode.
                hr = m_pResult->SetViewMode(MMCLV_VIEWSTYLE_REPORT);
                if (hr != S_OK)
                    break;

                // force reload of view (otherwise: multiple restriction error)
                ResetKnowResultRows();
                m_RowEnum.ClearCachedCertView();
                m_RowEnum.InvalidateCachedRowEnum();
                hr = m_RowEnum.GetView(pFolder->GetCA(), &pICertView);
                if (hr != S_OK)
                    break;

                int iSortOrder = CVR_SORT_NONE;
                int idxSortCol = -1;

                ASSERT(pICertView != NULL);
                VARIANT var;
                VariantInit(&var);

                {
                    BOOL fAscending;
                    hr = GetColumnSortData(cookie, &idxSortCol, &fAscending);
                    _PrintIfError2(hr, "GetColumnSortData", E_FAIL);

                    if (hr == S_OK)
                    {
                        if (fAscending)
                            iSortOrder = CVR_SORT_ASCEND;
                        else
                            iSortOrder = CVR_SORT_DESCEND;

                    }
                }

                // first restriction is always sort request
                if (iSortOrder != CVR_SORT_NONE)
                {
                    ASSERT( (iSortOrder == CVR_SORT_ASCEND) ||
                              (iSortOrder == CVR_SORT_DESCEND));

                    var.vt = VT_EMPTY;

                    if (S_OK == hr)
                    {
                        hr = pICertView->SetRestriction(
			                idxSortCol,		                // ColumnIndex
			                CVR_SEEK_NONE,	                // SeekOperator
                            iSortOrder,                     // SortOrder
			                &var);		                    // pvarValue
                    }

                    VariantClear(&var);
                }



                // set restriction on rows to view
                if (m_RowEnum.FAreQueryRestrictionsActive() &&
                    (m_RowEnum.GetQueryRestrictions() != NULL))
                {
                    PQUERY_RESTRICTION pCurRestrict = m_RowEnum.GetQueryRestrictions();
                    while (pCurRestrict)
                    {
                        LONG idxCol;
                        hr = pICertView->GetColumnIndex(FALSE, pCurRestrict->szField, &idxCol);
                        if (hr == S_OK)
                        {
                            // set restriction if column found
                            hr = pICertView->SetRestriction(
			                        idxCol,		                // Request Disposition's ColumnIndex
			                        pCurRestrict->iOperation,	// SeekOperator
			                        CVR_SORT_NONE,              // SortOrder
			                        &pCurRestrict->varValue);	// Value
                        }

                        // don't VarClear here!
                        pCurRestrict = pCurRestrict->pNext;
                    }
                }

                // set query restrictions
                if (SERVERFUNC_CRL_PUBLICATION == pFolder->m_type)
                {
                    // build special Revoked view
                    var.lVal = DB_DISP_REVOKED;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_ISSUED_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_ISSUED;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_PENDING_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_PENDING; //DB_DISP_QUEUE_MAX;    // don't include active
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_FAILED_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_LOG_FAILED_MIN;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_GE,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_ALIEN_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_FOREIGN;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else
                {
                    ASSERT(FALSE); // do we ever get here??
                    break;
                }

                // RESOLVE schema changes here
                hr = SynchColumns(cookie);
                _PrintIfError(hr, "SynchColumns");

                hr = GetColumnSetData(cookie, &pColSetData);
                if ((hr != S_OK) || (pColSetData == NULL))
                {
                    LONG lViewType;

                    // problem or no column set data? Revert to the default canned view
                    if (SERVERFUNC_PENDING_CERTIFICATES == pFolder->m_type)
                        lViewType = CV_COLUMN_QUEUE_DEFAULT;
                    else if (SERVERFUNC_FAILED_CERTIFICATES == pFolder->m_type)
                        lViewType = CV_COLUMN_LOG_FAILED_DEFAULT;
                    else if (SERVERFUNC_CRL_PUBLICATION == pFolder->m_type)
                        lViewType = pFolder->GetCA()->m_pParentMachine->FIsWhistlerMachine() ?  CV_COLUMN_LOG_REVOKED_DEFAULT : CV_COLUMN_LOG_DEFAULT; // w2k doesn't understand revoked view
                    else if (SERVERFUNC_ALIEN_CERTIFICATES == pFolder->m_type)
                        lViewType = CV_COLUMN_LOG_DEFAULT;
                    else
                        lViewType = CV_COLUMN_LOG_DEFAULT;

                    hr = pICertView->SetResultColumnCount(lViewType);
                    if (hr != S_OK)
                        break;
                }
                else
                {
                    // manual view
                    ULONG lColCount;

                    hr = CountShownColumns(pColSetData, &lColCount);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetResultColumnCount(lColCount);
                    if (hr != S_OK)
                        break;

                     // for all non-hidden columns, add to Query
                     for (lColCount=0; lColCount<(ULONG)pColSetData->nNumCols; lColCount++)
                     {
                        BOOL fShown;
                        hr = IsColumnShown(pColSetData, lColCount, &fShown);
                        if ((hr != S_OK) || (!fShown))
                            continue;

                        hr = pICertView->SetResultColumn(pColSetData->pColData[lColCount].nColIndex);
                        if (hr != S_OK)
                           break;
                      }
                }
                // Open the view
                IEnumCERTVIEWROW* pRowEnum;  // don't free
                hr = m_RowEnum.GetRowEnum(pFolder->GetCA(), &pRowEnum);
                if (hr != S_OK)
                    break;


                hr = InsertAllColumns(cookie, &m_RowEnum);
                _PrintIfError(hr, "InsertAllColumns");

                if (hr == S_OK)
                    fInsertedHeaders = TRUE;


                // set description bar text
                {
                    CString cstrStatusBar;
                    BOOL fFiltered = FALSE;

                    if (m_RowEnum.FAreQueryRestrictionsActive() &&
                        (m_RowEnum.GetQueryRestrictions() != NULL))
                    {
                        cstrStatusBar = g_cResources.m_szFilterApplied;
                        fFiltered = TRUE;
                    }

                    if (iSortOrder != CVR_SORT_NONE)
                    {
                        LPCWSTR pszTemplate = NULL;
                        if (iSortOrder == CVR_SORT_ASCEND)
                            pszTemplate = (LPCWSTR)g_cResources.m_szSortedAscendingTemplate;

                        if (iSortOrder == CVR_SORT_DESCEND)
                            pszTemplate = (LPCWSTR)g_cResources.m_szSortedDescendingTemplate;

                        if (pszTemplate)
                        {
                            // localize
                            LPCWSTR szUnlocalizedCol;
                            LPCWSTR szLocalizedCol;

                            hr = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->GetDBSchemaEntry(idxSortCol, &szUnlocalizedCol, NULL, NULL);
                            if (hr == S_OK)
                            {
                                hr = myGetColumnDisplayName(
                                        szUnlocalizedCol,
                                        &szLocalizedCol);
                                if ((S_OK == hr) && (NULL != szLocalizedCol))
                                {
                                    WCHAR rgszSortText[MAX_PATH+1];
                                    ASSERT((MAX_PATH*sizeof(WCHAR)) > (WSZ_BYTECOUNT(pszTemplate) + WSZ_BYTECOUNT(szLocalizedCol)));
                                    wsprintf(rgszSortText, pszTemplate, szLocalizedCol);

                                    if (fFiltered)
                                        cstrStatusBar += L"; ";
                                    cstrStatusBar += rgszSortText;
                                }
                            }
                        }
                    }

                    // Progress: cstrStatusBar += L"|%69";
                    //m_pResult->SetDescBarText((LPWSTR)(LPCWSTR)cstrStatusBar);
                    m_pConsole->SetStatusText((LPWSTR)(LPCWSTR)cstrStatusBar);
                }

                break;
            }

        case SERVER_INSTANCE:   // any issuing server instance
            m_pHeader->InsertColumn(0, W2COLE(g_cResources.m_ColumnHead_Name), LVCFMT_LEFT, 260);     // Name
            fInsertedHeaders = TRUE;
            break;
        default:
            // other scopes
            m_pHeader->InsertColumn(0, W2COLE(g_cResources.m_ColumnHead_Name), LVCFMT_LEFT, 180);     // Name
            m_pHeader->InsertColumn(1, W2COLE(g_cResources.m_ColumnHead_Size), LVCFMT_LEFT, 90);      // Size
            m_pHeader->InsertColumn(2, W2COLE(g_cResources.m_ColumnHead_Type), LVCFMT_LEFT, 160);     // Type
            fInsertedHeaders = TRUE;
        }
    }

    if (!fInsertedHeaders)
    {
        // insert error msg
        CString cstrViewErrorMsg, cstrStatusText;

        if ((pFolder != NULL ) && (!pFolder->GetCA()->m_pParentMachine->IsCertSvrServiceRunning()))
        {
            // handle server stopped msg
            cstrViewErrorMsg = g_cResources.m_szStoppedServerMsg;
        }
        else
        {
            // handle any other error (except empty db)
            cstrViewErrorMsg = myGetErrorMessageText(hr, TRUE);
        }

        cstrStatusText.Format(g_cResources.m_szStatusBarErrorFormat, cstrViewErrorMsg);

        m_pHeader->InsertColumn(0, W2COLE(L" "), LVCFMT_LEFT, 500);     // Error
        m_pConsole->SetStatusText((LPWSTR)(LPCWSTR)cstrStatusText);
    }

//Ret:
    if (pColSetData)
        CoTaskMemFree(pColSetData);

    return hr;
}


LPCWSTR DescriptionStringFromFolderType(FOLDER_TYPES type)
{
    ASSERT(g_cResources.m_fLoaded);

    switch (type)
    {
    case SERVER_INSTANCE:
        return (LPCWSTR) g_cResources.m_DescrStr_CA;
    default:
        break;
    }
    return (LPCWSTR)g_cResources.m_DescrStr_Unknown;
}

#define MMCVIEW_DB_MINPAGESIZE      32
#define MAX_VIEWABLE_STRING_LEN     MAX_PATH
static WCHAR szVirtualStrBuf[MAX_VIEWABLE_STRING_LEN+1];
static DWORD cbVirtualStrBuf = sizeof(szVirtualStrBuf);

STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    HRESULT hr = S_OK;
    ASSERT(pResult != NULL);

    if ((pResult) && (pResult->mask))
    {
        // a folder or a result?
        if (pResult->bScopeItem == TRUE)
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
            ASSERT(pFolder);

            if (pResult->mask & RDI_STR)
            {
                switch (pFolder->m_type)
                {
                case MACHINE_INSTANCE:
                case SERVER_INSTANCE:
                    switch(pResult->nCol)
                    {
                    case 0:
                        pResult->str = pFolder->m_pszName;
                        break;
                    case 1:
                        pResult->str = (LPOLESTR)DescriptionStringFromFolderType(pFolder->m_type);
                    default:
                        break;
                    }
                    break;

                case SERVERFUNC_CRL_PUBLICATION:
                case SERVERFUNC_ISSUED_CERTIFICATES:
                case SERVERFUNC_PENDING_CERTIFICATES:
                case SERVERFUNC_FAILED_CERTIFICATES:
                case SERVERFUNC_ALIEN_CERTIFICATES:
                    // just a single column here
                    pResult->str = pFolder->m_pszName;
                default:
                    break;
                }

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (pResult->nState & TVIS_EXPANDED)
                    pResult->nImage = pFolder->m_ScopeItem.nOpenImage;
                else
                    pResult->nImage = pFolder->m_ScopeItem.nImage;
            }
        }
        else
        {
            RESULT_DATA*    pData = NULL;
            CFolder*        pFolder = NULL;

            // if non-virtual, lParam is the item pointer
            if (m_bVirtualView)
                pFolder = GetVirtualFolder();
            else
            {
                pData= reinterpret_cast<RESULT_DATA*>(pResult->lParam);
                pFolder = pData->pParentFolder;

                ASSERT(pData->pParentFolder == m_pCurrentlySelectedScopeFolder);
            }


            if (pResult->mask & RDI_STR)
            {
                switch(pFolder->GetType())
                {
                case SERVERFUNC_CRL_PUBLICATION:
                case SERVERFUNC_PENDING_CERTIFICATES:
                case SERVERFUNC_ISSUED_CERTIFICATES:
                case SERVERFUNC_FAILED_CERTIFICATES:
                case SERVERFUNC_ALIEN_CERTIFICATES:
                    {
                        szVirtualStrBuf[0] = L'\0'; // zero
                        pResult->str = szVirtualStrBuf;


                        // have we had an error enumerating elts?
                        if (S_OK != m_dwViewErrorMsg)
                        {
                            // rtn err msg or blank
//                            ASSERT(pResult->nIndex == 0);
                            if (pResult->nIndex == 0)
                                pResult->str = (LPWSTR)(LPCWSTR)m_cstrViewErrorMsg;

                            break;
                        }

                        // Don't attempt to cache iViewCol -- we're asked
                        int iViewCol;

                        // if this request isn't the last one that came through, look it up
                        hr = m_RowEnum.GetColumnCacheInfo(
                            pResult->nCol,
                            &iViewCol);
                        _PrintIfError(hr, "GetColumnCacheInfo");

                        // HACKHACK
                        // if we get ErrorContinue, we should just take it
                        // in stride and return \0 (see GetColumnCacheInfo for details)
                        if (hr == HRESULT_FROM_WIN32(ERROR_CONTINUE))
                            break;                            

                        if (hr != S_OK)
                        {
                            // assume error
                            iViewCol = 0;
                        }

                        DWORD cbSize = cbVirtualStrBuf;

                        // protect ICertAdminD->EnumView from reentrant calls (see bug 339811)
                        if(2>InterlockedIncrement(&m_cViewCalls))
                        {
                            hr = GetCellContents(
                                        &m_RowEnum,
                                        pFolder->GetCA(),
                                        pResult->nIndex,
                                        pResult->nCol,
                                        (PBYTE)szVirtualStrBuf,
                                        &cbSize,
                                        TRUE);
                            _PrintIfError2(hr, "GetCellContents", S_FALSE); // ignore end of db msg
                        }
                        
                        InterlockedDecrement(&m_cViewCalls);

                        // only deal with 1st col
                        if (iViewCol != 0)
                            break;

                        // On Error
                        if ( (S_OK != hr) && (S_FALSE != hr) )
                        {
                            // stash error return
                            m_dwViewErrorMsg = hr;

                            if (!pFolder->GetCA()->m_pParentMachine->IsCertSvrServiceRunning())
                            {
                                // handle server stopped msg

                                // copy to stateful str
                                m_cstrViewErrorMsg = g_cResources.m_szStoppedServerMsg;

                                // copy to output
                                pResult->str = (LPWSTR)(LPCWSTR)g_cResources.m_szStoppedServerMsg;
                            }
                            else
                            {
                                // handle any other error (except empty db)
                                m_cstrViewErrorMsg = myGetErrorMessageText(hr, TRUE);

                                // truncate if necessary
                                ASSERT(MAX_VIEWABLE_STRING_LEN >= wcslen((LPWSTR)(LPCWSTR)m_cstrViewErrorMsg) );
                                if (MAX_VIEWABLE_STRING_LEN < wcslen((LPWSTR)(LPCWSTR)m_cstrViewErrorMsg) )
                                    m_cstrViewErrorMsg.SetAt(MAX_VIEWABLE_STRING_LEN, L'\0');

                                pResult->str = (LPWSTR)(LPCWSTR)m_cstrViewErrorMsg;
                            }

                            // on error, just display this msg
                            if (!m_RowEnum.m_fKnowNumResultRows)
                            {
                                // upd view
                                SetKnowResultRows(1);
                                m_pResult->SetItemCount(1, MMCLV_UPDATE_NOSCROLL | MMCLV_UPDATE_NOINVALIDATEALL);

                                // don't destroy column widths!
                                // OLD: make col width large enough to hold msg
//                                m_pHeader->SetColumnWidth(0, CHARS_TO_MMCCOLUMNWIDTH(wcslen(pResult->str)));
                            }
                            break;
                        }

                        // if 1st col and don't know the final tally, might have to update best guess
                        if (hr == S_OK)
                        {
                            if (KnownResultRows() == (DWORD)(pResult->nIndex+1))
                                                                // if asking for the last element (ones based)
                            {
                                // next guess at end
                                BOOL fSetViewCount = FALSE;
                                DWORD dwNextEnd;

                                if (!m_RowEnum.m_fKnowNumResultRows) // only make guess if enum doesn't have a clue yet
                                {
                                    // double where we are now, make sure we're at least moving MMCVIEW_DB_MINPAGESIZE rows
                                    dwNextEnd = max( ((pResult->nIndex+1)*2), MMCVIEW_DB_MINPAGESIZE);

                                    DBGPRINT((DBG_SS_CERTMMC, "RowEnum dwResultRows = %i, requested Index = %i. Creating Guess = %i\n", m_RowEnum.m_dwResultRows, pResult->nIndex, dwNextEnd));

                                    // upd enumerator with our best guess
                                    fSetViewCount = TRUE;
                                }
                                else if (KnownResultRows() != m_RowEnum.m_dwResultRows)
                                {
                                    dwNextEnd = m_RowEnum.m_dwResultRows;
                                    fSetViewCount = TRUE;
                                }

                                // upd view
                                if (fSetViewCount)
                                {
                                    SetKnowResultRows(dwNextEnd);
                                    m_pResult->SetItemCount(dwNextEnd, MMCLV_UPDATE_NOSCROLL | MMCLV_UPDATE_NOINVALIDATEALL);
                                }

                            } // if the enumerator doesn't have a clue yet
                        }
                        else
                        {
                            ASSERT(hr == S_FALSE);

                            // end-of-db should only come on first col
                            // if error while retrieving first elt in row, ASSUME end of DB
                            LONG lRetrievedIndex;
                            hr = m_RowEnum.GetRowMaxIndex(pFolder->GetCA(), &lRetrievedIndex);
                            if (S_OK != hr)
                                break;

                            DBGPRINT((DBG_SS_CERTMMC, "Hit end, setting max index to %i\n", lRetrievedIndex));

                            SetKnowResultRows(lRetrievedIndex);
                            m_pResult->SetItemCount(lRetrievedIndex, MMCLV_UPDATE_NOSCROLL | MMCLV_UPDATE_NOINVALIDATEALL);
//                                m_pResult->ModifyItemState(lRetrievedIndex-1, 0, (LVIS_FOCUSED | LVIS_SELECTED), 0);  // set focus to last item
// BUG BUG MMC fails to re-select scope pane when we set selection here, so just set focus (build 2010)
                            if (lRetrievedIndex != 0)
                                m_pResult->ModifyItemState(lRetrievedIndex-1, 0, LVIS_FOCUSED, 0);  // set focus to last item
                        }
                    } // end case
                    break;
                case SERVER_INSTANCE:
                default:                    // try this, no guarantee
                    if (NULL == pData)
                        break;
                    ASSERT(pResult->nCol < (int)pData->cStringArray);
                    pResult->str = (LPOLESTR)pData->szStringArray[pResult->nCol];
                    break;
                }

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            // MMC can request image and indent for virtual data
            if (pResult->mask & RDI_IMAGE)
            {
                if ((pResult->nIndex >= (int)m_RowEnum.m_dwResultRows) || (hr != S_OK) || (S_OK != m_dwViewErrorMsg))
                {
                    // MMC bug: using SetItemCount doesn't stick early enough to keep it from
                    // asking for icons for the first page.
                    pResult->nImage = IMGINDEX_NO_IMAGE;
                }
                else
                {
                    switch(pFolder->GetType())
                    {
                    case SERVERFUNC_FAILED_CERTIFICATES:
                    case SERVERFUNC_CRL_PUBLICATION:
                        pResult->nImage = IMGINDEX_CRL;
                        break;
                    case SERVERFUNC_PENDING_CERTIFICATES:
                        pResult->nImage = IMGINDEX_PENDING_CERT;
                        break;
                    case SERVERFUNC_ISSUED_CERTIFICATES:
                    case SERVERFUNC_ALIEN_CERTIFICATES:
                        pResult->nImage = IMGINDEX_CERT;
                        break;
                    default:
                        // should never get here
                        ASSERT(0);
                        pResult->nImage = IMGINDEX_NO_IMAGE;
                        break;
                    } // end switch
                } // end > rows test
            }
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation
STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    LONG *pInsertionAllowed)
{
    dynamic_cast<CComponentDataImpl*>(m_pComponentData)->m_pCurSelFolder = m_pCurrentlySelectedScopeFolder;

    HRESULT hr;
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (NULL == pInternal)
        return S_OK;

    BOOL bMultiSel =  IsMMCMultiSelectDataObject(pDataObject);

    BOOL fResultItem = (pInternal->m_type == CCT_RESULT);

    CFolder* pFolder = m_pCurrentlySelectedScopeFolder;

    FOLDER_TYPES folderType = NONE;
    if (pFolder == NULL)
        folderType = MACHINE_INSTANCE;
    else
        folderType = pFolder->GetType();

    hr = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
    if (hr != S_OK)
       goto Ret;

    // Loop through and add each of the view items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        // fixup entries
        MY_CONTEXTMENUITEM* pm = viewResultItems;
        if (m_RowEnum.FAreQueryRestrictionsActive())  // filtered?
        {
            pm[ENUM_VIEW_FILTER].item.fFlags =
                MFT_RADIOCHECK | MFS_CHECKED | MFS_ENABLED;
            pm[ENUM_VIEW_ALL].item.fFlags =
                MFS_ENABLED;
        }
        else
        {
            pm[ENUM_VIEW_FILTER].item.fFlags =
                MFS_ENABLED;
            pm[ENUM_VIEW_ALL].item.fFlags =
                MFT_RADIOCHECK | MFS_CHECKED | MFS_ENABLED;
        }

        for (; pm->item.strName; pm++)
        {
            // show in both scope/result panes
            // fResultItem

            // Only support views in known containers
            // for each task, insert if matches the current folder
            if ((folderType  == SERVERFUNC_CRL_PUBLICATION) ||
                (folderType  == SERVERFUNC_ISSUED_CERTIFICATES) ||
                (folderType  == SERVERFUNC_PENDING_CERTIFICATES) ||
                (folderType  == SERVERFUNC_ALIEN_CERTIFICATES) ||
                (folderType  == SERVERFUNC_FAILED_CERTIFICATES))
            {
                hr = pContextMenuCallback->AddItem(&pm->item);
                _JumpIfError(hr, Ret, "AddItem");
            }
        }
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        // ptr to tasks
        TASKITEM* pm = taskResultItemsSingleSel;

        if (!bMultiSel)
        {
            // insert all other tasks per folder
            for (; pm->myitem.item.strName; pm++)
            {
                // does it match scope/result type?
                // if (value where we are !=
                //    whether or not the resultitem bit is set)
                if (fResultItem != (0 != (pm->dwFlags & TASKITEM_FLAG_RESULTITEM)) )
                    continue;

                // does it match area it should be in?
                // for each task, insert if matches the current folder
                if (folderType != pm->type)
                    continue;

                // is this task supposed to be hidden?
                if (MFS_HIDDEN == pm->myitem.item.fFlags)
                    continue;

                hr = pContextMenuCallback->AddItem(&pm->myitem.item);
                _JumpIfError(hr, Ret, "AddItem");
            }
        }
    }

Ret:
    FREE_DATA(pInternal);

    return hr;
}


STDMETHODIMP CSnapin::Command(LONG nCommandID, LPDATAOBJECT pDataObject)
{
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
        return E_FAIL;

    BOOL fConfirmedAction = FALSE;
    BOOL fMustRefresh = FALSE;

    LONG lReasonCode = CRL_REASON_UNSPECIFIED;

    HRESULT hr = S_OK;

    CFolder* pFolder = GetParentFolder(pInternal);
    ICertAdmin* pAdmin = NULL;      // free this
    CWaitCursor* pcwait = NULL; // some of these commands are multiselect and could take awhile.  
                         // On those that are lengthy, this will be created and needs to be deleted at exit

    if (pInternal->m_type == CCT_SCOPE)
    {
        // Handle view specific commands here
        switch (nCommandID)
        {
        case MMCC_STANDARD_VIEW_SELECT:
            m_CustomViewID = VIEW_DEFAULT_LV;
            break;
        case IDC_VIEW_ALLRECORDS:
            {
            if (NULL == pFolder)
                break;

            // if restricted view, change
            if (m_RowEnum.FAreQueryRestrictionsActive())
            {
                // switch off active flag
                m_RowEnum.SetQueryRestrictionsActive(FALSE);

                // refresh just this folder
                OnRefresh(pDataObject);
                SetDirty();
            }

            break;
            }
        case IDC_VIEW_FILTER:
            {
            if (NULL == pFolder)
                break;

            HWND hwnd;
            hr = m_pConsole->GetMainWindow(&hwnd);
            ASSERT(hr == ERROR_SUCCESS);
            if (hr != ERROR_SUCCESS)
                hwnd = NULL;        // should work

            hr = ModifyQueryFilter(hwnd, &m_RowEnum, dynamic_cast<CComponentDataImpl*>(m_pComponentData));

            // refresh only if successful
            if (hr == ERROR_SUCCESS)
            {
                // refresh just this folder
                OnRefresh(pDataObject);
                SetDirty();
            }

            break;
            }


        default:
            // Pass non-view specific commands to ComponentData
            return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(nCommandID, pDataObject);
        }
    }
    else if (pInternal->m_type == CCT_RESULT)
    {
        // get this only ONCE, it's freed later
        if ((nCommandID == IDC_RESUBMITREQUEST) ||
            (nCommandID == IDC_DENYREQUEST) ||
            (nCommandID == IDC_REVOKECERT) ||
            (nCommandID == IDC_UNREVOKE_CERT))
        {
            if (pFolder == NULL)
            {
               hr = E_POINTER;
               goto ExitCommand;
            }

            // have pAdmin allocated
            hr = pFolder->GetCA()->m_pParentMachine->GetAdmin(&pAdmin);
            if (S_OK != hr)
                goto ExitCommand;
        }

        // snag the selected items

        RESULTDATAITEM rdi;
        rdi.mask = RDI_STATE;

        rdi.nState = LVIS_SELECTED;
        rdi.nIndex = -1;


        // must sit outside loop so multi-select works
        LPCWSTR szCol=NULL; // don't free
        BOOL fSaveInstead = FALSE;


        while(S_OK == m_pResult->GetNextItem(&rdi))
        {
            int iSel = rdi.nIndex;

            // Handle each of the commands seperately
            switch (nCommandID)
            {
            case IDC_VIEW_CERT_PROPERTIES:
            {
                if (NULL == pFolder)
                    break;

                switch (pFolder->GetType())
                {
                case SERVERFUNC_ISSUED_CERTIFICATES:
                case SERVERFUNC_CRL_PUBLICATION:
                case SERVERFUNC_ALIEN_CERTIFICATES:
                    {
                    CertSvrCA* pCA = pFolder->GetCA();
                    CRYPTUI_VIEWCERTIFICATE_STRUCTW sViewCert;
                    ZeroMemory(&sViewCert, sizeof(sViewCert));
                    HCERTSTORE rghStores[2];    // don't close these stores
                    PCCRL_CONTEXT pCRL = NULL;


                    // get this cert
                    PBYTE pbCert = NULL;
                    DWORD cbCert;
                    hr = GetRowColContents(pFolder, rdi.nIndex, wszPROPRAWCERTIFICATE, &pbCert, &cbCert);
                    if (S_OK != hr)
                        break;

                    sViewCert.pCertContext = CertCreateCertificateContext(
                        CRYPT_ASN_ENCODING,
                        pbCert,
                        cbCert);
                    delete [] pbCert;

                    if (sViewCert.pCertContext == NULL)
                        break;

                    // get stores the CA sees
                    hr = pCA->GetRootCertStore(&rghStores[0]);
                    if (S_OK != hr)
                        break;
                    hr = pCA->GetCACertStore(&rghStores[1]);
                    if (S_OK != hr)
                        break;

                    hr = m_pConsole->GetMainWindow(&sViewCert.hwndParent);
                    if (S_OK != hr)
                        sViewCert.hwndParent = NULL;    // should work

                    sViewCert.dwSize = sizeof(sViewCert);
                    sViewCert.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING | CRYPTUI_WARN_UNTRUSTED_ROOT | CRYPTUI_DISABLE_ADDTOSTORE;

                    // if we're opening remotely, don't open local stores
                    if (!FIsCurrentMachine(pCA->m_pParentMachine->m_strMachineName))
                        sViewCert.dwFlags |= CRYPTUI_DONT_OPEN_STORES;

                    sViewCert.cStores = 2;
                    sViewCert.rghStores = rghStores;

                    if (!CryptUIDlgViewCertificateW(&sViewCert, NULL))
                        hr = GetLastError();

                    VERIFY(CertFreeCertificateContext(sViewCert.pCertContext));
                    }
                break;

                default:
                    break;
                }
            }
            break;
        case IDC_RESUBMITREQUEST:
            {
            LPWSTR szReqID = NULL;
            DWORD cbReqID;
            LONG lReqID;
            if (NULL == pFolder)
                break;

            if (pcwait == NULL)		// this might take awhile
                pcwait = new CWaitCursor;

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&szReqID, &cbReqID, TRUE);
            if (S_OK != hr)
                break;

            lReqID = _wtol(szReqID);
            delete [] szReqID;

            hr = CertAdminResubmitRequest(pFolder->GetCA(), pAdmin, lReqID);
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;

            break;
            }
        case IDC_DENYREQUEST:
            {
            LPWSTR szReqID = NULL;
            DWORD cbReqID;
            LONG lReqID;

            if (NULL == pFolder)
                break;

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&szReqID, &cbReqID, TRUE);
            if (S_OK != hr)
                break;

            lReqID = _wtol(szReqID);
            delete [] szReqID;

            if (!fConfirmedAction)
            {
                // confirm this action
                CString cstrMsg, cstrTitle;
                cstrMsg.LoadString(IDS_CONFIRM_DENY_REQUEST);
                cstrTitle.LoadString(IDS_DENY_REQUEST_TITLE);
                int iRet;
                if ((S_OK != m_pConsole->MessageBox(cstrMsg, cstrTitle, MB_YESNO, &iRet)) ||
                    (iRet != IDYES))
                {
                    hr = ERROR_CANCELLED;
                    goto ExitCommand;
                }

                fConfirmedAction = TRUE;
            }

            if (pcwait == NULL)		// this might take awhile
                pcwait = new CWaitCursor;

            hr = CertAdminDenyRequest(pFolder->GetCA(), pAdmin, lReqID);
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;

            break;
            }
        case IDC_VIEW_ATTR_EXT:
        {
            IEnumCERTVIEWEXTENSION* pExtn = NULL;
            IEnumCERTVIEWATTRIBUTE* pAttr = NULL;
            LPWSTR szReqID = NULL;
            DWORD cbReqID;
            HWND hwnd;

            ASSERT(pInternal->m_type == CCT_RESULT);

            if (NULL == pFolder)
                break;

            hr = m_pConsole->GetMainWindow(&hwnd);
            if (S_OK != hr)
                hwnd = NULL;    // should work

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&szReqID, &cbReqID, TRUE);
            if (S_OK != hr)
                break;

            // pollute the row enumerator we've got (doesn't alloc new IF)
            hr = m_RowEnum.SetRowEnumPos(rdi.nIndex);
            if (hr != S_OK)
               break;

            IEnumCERTVIEWROW* pRow; 
            hr = m_RowEnum.GetRowEnum(pFolder->GetCA(), &pRow);
            if (hr != S_OK)
                break;

            hr = pRow->EnumCertViewAttribute(0, &pAttr);
            if (hr != S_OK)
               break;

            hr = pRow->EnumCertViewExtension(0, &pExtn);
            if (hr != S_OK)
               break;

            hr = ViewRowAttributesExtensions(hwnd, pAttr, pExtn, szReqID);
            delete [] szReqID;
            if (pExtn)
                pExtn->Release();
            if (pAttr)
                pAttr->Release();

            if (hr != S_OK)
                break;

            break;
        }

        case IDC_DUMP_ASN:
        {
            PBYTE pbReq = NULL;
            DWORD cbReq;
			CString cstrFileName;
			LPCWSTR pszLocalizedCol = NULL;

            ASSERT(pInternal->m_type == CCT_RESULT);
            if (NULL == pFolder)
                break;

            CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
            HWND hwnd;

            hr = m_pConsole->GetMainWindow(&hwnd);
            if (S_OK != hr)
                hwnd = NULL;    // should work

            if (!fConfirmedAction)
            {
				hr = ChooseBinaryColumnToDump(hwnd, pData, &szCol, &fSaveInstead);
				if (hr != S_OK)
				   break;

				if (szCol == NULL) // strangeness
				{
				   hr = E_UNEXPECTED;
				   break;
				}
					fConfirmedAction = TRUE;
            }

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&pbReq, &cbReq, TRUE);
            if (S_OK != hr)
                break;

			hr = myGetColumnDisplayName(szCol, &pszLocalizedCol);
			if ((hr != S_OK) || (pszLocalizedCol == NULL))
				pszLocalizedCol = L"";
				
			cstrFileName = pszLocalizedCol;
			cstrFileName += L" - ";
			cstrFileName += (LPCWSTR)pbReq;
                        cstrFileName += L".tmp";
            delete [] pbReq;

            // get the request
            hr = GetRowColContents(pFolder, rdi.nIndex, szCol, &pbReq, &cbReq);
            if (S_OK != hr)
                break;

            hr = ViewRowRequestASN(hwnd, cstrFileName, pbReq, cbReq, fSaveInstead);
            delete [] pbReq;
            if (hr != S_OK)
                break;

            break;
        }
        case IDC_UNREVOKE_CERT:
            {
            ASSERT(pInternal->m_type == CCT_RESULT);
            if (NULL == pFolder)
                break;

            LPWSTR szCertSerNum = NULL;
            DWORD cbSerNum;
            PBYTE pbRevocationReason = NULL;
            DWORD cbRevocationReason;

            HWND hwnd;
            hr = m_pConsole->GetMainWindow(&hwnd);
            if (S_OK != hr)
                hwnd = NULL;    // should work

            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON, &pbRevocationReason, &cbRevocationReason);
            if (S_OK != hr)
                break;
            if ((cbRevocationReason != sizeof(DWORD)) || (*(DWORD*)pbRevocationReason != CRL_REASON_CERTIFICATE_HOLD))
            {
                delete [] pbRevocationReason;
                DisplayCertSrvErrorWithContext(hwnd, S_OK, IDS_UNREVOKE_FAILED);   // don't display hokey "invalid state" error, just nice text

                hr = S_OK;
                break;
            }
            delete [] pbRevocationReason;
            // otherwise, continue

            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPCERTIFICATESERIALNUMBER, (PBYTE*)&szCertSerNum, &cbSerNum);
            if (S_OK != hr)
                break;

            // zero terminate
            WCHAR szTmpSerNum[MAX_PATH+1];
            CopyMemory(szTmpSerNum, szCertSerNum, cbSerNum);
            ASSERT((cbSerNum & 0x1) == 0x00);   // better be even!
            szTmpSerNum[cbSerNum>>1] = 0x00;
            delete [] szCertSerNum;

            hr = CertAdminRevokeCert(pFolder->GetCA(), pAdmin, MAXDWORD, szTmpSerNum);  // MAXDWORD == unrevoke
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;
            break;
            }

        case IDC_REVOKECERT:
            {
            ASSERT(pInternal->m_type == CCT_RESULT);
            if (NULL == pFolder)
                break;

            LPWSTR szCertSerNum = NULL;
            DWORD cbSerNum;

            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPCERTIFICATESERIALNUMBER, (PBYTE*)&szCertSerNum, &cbSerNum);
            if (S_OK != hr)
                break;

            // zero terminate
            WCHAR szTmpSerNum[MAX_PATH+1];
            CopyMemory(szTmpSerNum, szCertSerNum, cbSerNum);
            ASSERT((cbSerNum & 0x1) == 0x00);   // better be even!
            szTmpSerNum[cbSerNum>>1] = 0x00;
            delete [] szCertSerNum;

            if (!fConfirmedAction)
            {
                HWND hwnd;
                hr = m_pConsole->GetMainWindow(&hwnd);
                if (S_OK != hr)
                    hwnd = NULL;    // should work

                hr = GetUserConfirmRevocationReason(&lReasonCode, hwnd);
                if (hr != S_OK)
                    goto ExitCommand;

                fConfirmedAction = TRUE;
            }
            if (pcwait == NULL)		// this might take awhile
                pcwait = new CWaitCursor;

            hr = CertAdminRevokeCert(pFolder->GetCA(), pAdmin, lReasonCode, szTmpSerNum);
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;
            break;
            }

        default:
                ASSERT(FALSE);  // Unknown command!
                break;
            }


            // if ever the user says stop, halt everything
            if (((HRESULT)ERROR_CANCELLED) == hr)
                goto ExitCommand;
        } // end loop
    } // if result
    else
    {
        ASSERT(FALSE);
    }

ExitCommand:
    FREE_DATA(pInternal);

    if (pcwait != NULL)
        delete pcwait;

    // might've been cached over multiple selections
    if (pAdmin)
        pAdmin->Release();

    if ((hr != S_OK) && (hr != ERROR_CANCELLED) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
        DisplayGenericCertSrvError(m_pConsole, hr);

    // only do this once
    if (fMustRefresh)
    {
        // notify views: refresh service toolbar buttons
        m_pConsole->UpdateAllViews(
            pDataObject,
            0,
            0);
    }

    return S_OK;
}

STDMETHODIMP CSnapin::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return E_NOTIMPL;
}

STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    HRESULT hr;
    ASSERT(m_bInitializedC);
    ASSERT(pStm);

    // Read the string
    DWORD dwVer;

    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Load: dwVer");

    ASSERT((VER_CSNAPIN_SAVE_STREAM_3 == dwVer) || (VER_CSNAPIN_SAVE_STREAM_2 == dwVer));
    if ((VER_CSNAPIN_SAVE_STREAM_3 != dwVer) &&
        (VER_CSNAPIN_SAVE_STREAM_2 != dwVer))
    {
        hr = STG_E_OLDFORMAT;
        _JumpError(hr, Ret, "dwVer");
    }

    // version-dependent info
    if (VER_CSNAPIN_SAVE_STREAM_3 == dwVer)
    {
        // View ID
        hr = ReadOfSize(pStm, &m_dwViewID, sizeof(DWORD));
        _JumpIfError(hr, Ret, "Load: m_dwViewID");

        // row enum
        hr = m_RowEnum.Load(pStm);
        _JumpIfError(hr, Ret, "Load::m_RowEnum");
    }

Ret:
    ClearDirty();

    return hr;
}


STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;

    ASSERT(m_bInitializedC);
    ASSERT(pStm);

    // Write the version
    DWORD dwVer = VER_CSNAPIN_SAVE_STREAM_3;

    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Save: dwVer");

    // View ID
    hr = WriteOfSize(pStm, &m_dwViewID, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Save: m_dwViewID");

    hr = m_RowEnum.Save(pStm, fClearDirty);
    _JumpIfError(hr, Ret, "Save::m_RowEnum");

Ret:
    if (fClearDirty)
        ClearDirty();
    return hr;
}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    DWORD cbSize;
    cbSize = sizeof(DWORD);     // Version

    cbSize += sizeof(DWORD);    // m_dwViewID

    int iAdditionalSize = 0;
    m_RowEnum.GetSizeMax(&iAdditionalSize);
    cbSize += iAdditionalSize;

    // Set the size of the string to be saved
    ULISet32(*pcbSize, cbSize);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet implementation
//
STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    // no property pages
    return S_OK;
}

STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    // Get the node type and see if it's one of mine

    // if (nodetype == one of mine)
    //      do this
    // else
    //      see which node type it is and answer the question

    BOOL bResult = FALSE;

    return (bResult) ? S_OK : S_FALSE;

    // Look at the data object and see if it an item in the scope pane
    // return IsScopePaneNode(lpDataObject) ? S_OK : S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{
    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    if (pControlbar != NULL)
    {
        // Hold on to the controlbar interface.
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr=S_FALSE;

        // SvrMgrToolbar1
        if (!m_pSvrMgrToolbar1)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pSvrMgrToolbar1));
            ASSERT(SUCCEEDED(hr));

            // Add the bitmap
            ASSERT(g_cResources.m_fLoaded);
            hr = m_pSvrMgrToolbar1->AddBitmap(2, g_cResources.m_bmpSvrMgrToolbar1, 16, 16, RGB(192,192,192));
            ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            for (int i=0; ((SvrMgrToolbar1Buttons[i].item.lpButtonText != NULL) && (SvrMgrToolbar1Buttons[i].item.lpTooltipText != NULL)); i++)
            {
                hr = m_pSvrMgrToolbar1->AddButtons(1, &SvrMgrToolbar1Buttons[i].item);
                ASSERT(SUCCEEDED(hr));
            }
        }
    }

    return S_OK;
}


void CSnapin::OnButtonClick(LPDATAOBJECT pdtobj, int idBtn)
{

    switch(idBtn)
    {
    case IDC_STOPSERVER:
    case IDC_STARTSERVER:
        // bubble this to our other handler
        dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(idBtn, pdtobj);
        break;
    default:
        {
        ASSERT(FALSE);
        }
        break;
    }
}


STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr=S_FALSE;

    switch (event)
    {
    case MMCN_BTN_CLICK:
        OnButtonClick(reinterpret_cast<LPDATAOBJECT>(arg), (INT)param);
        break;

    case MMCN_DESELECT_ALL:
    case MMCN_SELECT:
        HandleExtToolbars((event == MMCN_DESELECT_ALL), arg, param);
        break;

    case MMCN_MENU_BTNCLICK:
        HandleExtMenus(arg, param);
        break;

    default:
        break;
    }


    return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}


// This compare is used to sort the items in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing -- mmc reverses the result if it needs to
STDMETHODIMP CSnapin::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    HRESULT hr;

    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    LONG nCol = (LONG) *pnResult;
    ASSERT(nCol >=0);

    *pnResult = 0;

    USES_CONVERSION;

    LPWSTR szStringA;
    LPWSTR szStringB;

    RESULT_DATA* pDataA = reinterpret_cast<RESULT_DATA*>(cookieA);
    RESULT_DATA* pDataB = reinterpret_cast<RESULT_DATA*>(cookieB);


    ASSERT(pDataA != NULL && pDataB != NULL);

    ASSERT(nCol < (int)pDataA->cStringArray);
    ASSERT(nCol < (int)pDataB->cStringArray);

    szStringA = OLE2T(pDataA->szStringArray[nCol]);
    szStringB = OLE2T(pDataB->szStringArray[nCol]);

    ASSERT(szStringA != NULL);
    ASSERT(szStringB != NULL);

    if ((szStringA == NULL) || (szStringB == NULL))
        return E_POINTER;


    // return simple strcmp
    *pnResult = wcscmp(szStringA, szStringB);

    return S_OK;
}

STDMETHODIMP CSnapin::FindItem(LPRESULTFINDINFO pFindInfo, int* pnFoundIndex)
{
    // not implemented: S_FALSE == no find
    return S_FALSE;
}


STDMETHODIMP CSnapin::CacheHint(int nStartIndex, int nEndIndex)
{
    return S_OK;
}

STDMETHODIMP CSnapin::SortItems(int nColumn, DWORD dwSortOptions, LPARAM lUserParam)
{
    HRESULT hr;

    LPCWSTR pszHeading;
    BOOL fIndexed = FALSE;
    CComponentDataImpl* pCompData;
    CFolder* pFolder;

    // if non-virtual, report "we don't allow sort"
    if (!m_bVirtualView)
        goto Ret;

    pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (pCompData == NULL)
        goto Ret;

    pFolder = GetVirtualFolder();
    if (pFolder == NULL)
        goto Ret;

    // responding S_OK to this allows ^ and down arrow display
    hr = pCompData->GetDBSchemaEntry(nColumn, &pszHeading, NULL, &fIndexed);
    _JumpIfError(hr, Ret, "GetDBSchemaEntry");

    if (fIndexed)
    {
        // special case: disallow sort on serial# in failed, pending folders
        // this column has "ignore null" bit set, and sort results in {} set.
        if ((pFolder->GetType() == SERVERFUNC_FAILED_CERTIFICATES) ||
            (pFolder->GetType() == SERVERFUNC_PENDING_CERTIFICATES))
        {
            // if serial number click, act like not indexed -- NO SORT
            if (0 == wcscmp(pszHeading, wszPROPCERTIFICATESERIALNUMBER))
                fIndexed = FALSE;
        }
    }


Ret:
    // S_FALSE == no sort
    return fIndexed ? S_OK : S_FALSE;
}



#define HIDEVERB(__x__) \
    do {                \
        m_pConsoleVerb->SetVerbState(__x__, HIDDEN, TRUE);  \
        m_pConsoleVerb->SetVerbState(__x__, ENABLED, FALSE); \
    } while(0)

#define SHOWVERB(__x__) \
    do {                \
        m_pConsoleVerb->SetVerbState(__x__, HIDDEN, FALSE);  \
        m_pConsoleVerb->SetVerbState(__x__, ENABLED, TRUE); \
    } while(0)


void CSnapin::HandleStandardVerbs(bool bDeselectAll, LPARAM arg,
                                  LPDATAOBJECT lpDataObject)
{
    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.


    if (m_CustomViewID != VIEW_DEFAULT_LV)
    {
        // UNDONE: When is this executed?
        SHOWVERB(MMC_VERB_REFRESH);
        SHOWVERB(MMC_VERB_PROPERTIES);

        return;
    }

    if (!bDeselectAll && lpDataObject == NULL)
        return;

    WORD bScope = LOWORD(arg);
    WORD bSelect = HIWORD(arg);
    BOOL bMultiSel =  IsMMCMultiSelectDataObject(lpDataObject);


    //
    // Derive internal, pfolder
    //
    INTERNAL* pInternal = lpDataObject ? ExtractInternalFormat(lpDataObject) : NULL;
    // if scope item, derive parent folder from pInternal.
    // if result item, recall parent folder from saved state
    CFolder* pFolder = (bScope) ? ::GetParentFolder(pInternal) : GetParentFolder(pInternal);

    //
    // set state appropriately
    //
    if (bDeselectAll || !bSelect)
    {
        // deselection notification

        // verbs cleared for us, right?
    }
    else if (m_pConsoleVerb && pInternal)   // selected
    {
        _MMC_CONSOLE_VERB verbDefault = MMC_VERB_NONE;

        // unsupported properties
        HIDEVERB(MMC_VERB_OPEN);
        HIDEVERB(MMC_VERB_COPY);
        HIDEVERB(MMC_VERB_PASTE);
        HIDEVERB(MMC_VERB_DELETE);
        HIDEVERB(MMC_VERB_PRINT);
        HIDEVERB(MMC_VERB_RENAME); // could easily be supported, but was removed (bug 217502)
        // MMC_VERB_REFRESH is supported
        // MMC_VERB_PROPERTIES is supported

        if (pInternal->m_type == CCT_SCOPE)
        {
            // selected scope item

            // Standard functionality support by scope items
            SHOWVERB(MMC_VERB_REFRESH);

            // Disable properties for static node,
            // enable properties only for server instance, crl
            if  ((pInternal->m_cookie != 0) &&
                 ((SERVER_INSTANCE == pFolder->m_type) ||
                  (SERVERFUNC_CRL_PUBLICATION == pFolder->m_type)) )
            {
                SHOWVERB(MMC_VERB_PROPERTIES);
            }
            else
                HIDEVERB(MMC_VERB_PROPERTIES);

            // default folder verb is open
            verbDefault = MMC_VERB_OPEN;
        }
        else
        {
            // selected result item

            // Standard functionality supported by result items
            SHOWVERB(MMC_VERB_REFRESH);

            HIDEVERB(MMC_VERB_PROPERTIES);
        }

        m_pConsoleVerb->SetDefaultVerb(verbDefault);
    }

    FREE_DATA(pInternal);
}

void CSnapin::SmartEnableServiceControlButtons()
{
    BOOL fSvcRunning;
    CComponentDataImpl* pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (pCompData)
    {

    fSvcRunning = pCompData->m_pCertMachine->IsCertSvrServiceRunning();
    if (m_pSvrMgrToolbar1)
    {
        m_pSvrMgrToolbar1->SetButtonState(SvrMgrToolbar1Buttons[ENUM_BUTTON_STARTSVC].item.idCommand, ENABLED, !fSvcRunning);
        m_pSvrMgrToolbar1->SetButtonState(SvrMgrToolbar1Buttons[ENUM_BUTTON_STOPSVC].item.idCommand, ENABLED, fSvcRunning);
    }

    }
}

void CSnapin::HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param)
{
    INTERNAL* pInternal = NULL;
    HRESULT hr;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    if (param)
        pInternal = ExtractInternalFormat(reinterpret_cast<LPDATAOBJECT>(param));


    // Deselection Notification?
    if (bDeselectAll || bSelect == FALSE)
        return;


    ASSERT(bSelect == TRUE);
    bool bFileExBtn = false;


    if (pInternal == NULL)
        return;

    CFolder* pFolder = GetParentFolder(pInternal);

    if (bScope == TRUE)
    {
        // special stuff to do at SCOPE level?
    }
    else // result item selected: result or subfolder
    {
        // special stuff to do at RESULTS level
        if (pInternal->m_type == CCT_RESULT)
        {
            bFileExBtn = true;

            // UNDONE: what to do here with SvrMgrToolbar1Buttons1?
            // For now, do nothing: allow them to remain in same state
        }
    }

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pData != NULL);

    if ((IsPrimaryImpl() == TRUE) &&
        (IsAllowedStartStop(pFolder, pData->m_pCertMachine)) )
    {
        // Attach the SvrMgrToolbar1 to the window
        hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        // Detach the SvrMgrToolbar1 to the window
        hr = m_pControlbar->Detach((LPUNKNOWN) m_pSvrMgrToolbar1);
        ASSERT(SUCCEEDED(hr));
    }

    SmartEnableServiceControlButtons();

    FREE_DATA(pInternal);
}

// dropdown menu addition
void CSnapin::HandleExtMenus(LPARAM arg, LPARAM param)
{
}


CFolder* CSnapin::GetVirtualFolder()
{
    ASSERT(m_bVirtualView);
    return m_pCurrentlySelectedScopeFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "certsrv.h"
#include "setupids.h"
#include "misc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT CSnapin::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
        return E_INVALIDARG;
    
    ASSERT(m_pImageResult != NULL);
    ASSERT((IImageList*)arg == m_pImageResult);

    CBitmap bmpResultStrip16x16, bmpResultStrip32x32;
    if (NULL == bmpResultStrip16x16.LoadBitmap(IDB_16x16))
        return S_FALSE;
    
    if (NULL == bmpResultStrip32x32.LoadBitmap(IDB_32x32))
        return S_FALSE;

    // Set the images
    m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmpResultStrip16x16)),
                      reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmpResultStrip32x32)),
                       0, RGB(255, 0, 255));

    return S_OK;
}


HRESULT CSnapin::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    HRESULT hr;
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        m_pCurrentlySelectedScopeFolder = pFolder;

        // if list view on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
             // Show the headers for this nodetype
             hr = InitializeHeaders(cookie);

            // virtual list support
            if (m_bVirtualView)
                m_pResult->SetItemCount(1, 0);
        }
    }
    else
    {
        // if list view is on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            // Free data associated with the result pane items, because
            // your node is no longer being displayed.
        }


        // Note: The console will remove the items from the result pane
    }

    return S_OK;
}


HRESULT CSnapin::GetRowColContents(CFolder* pFolder, LONG idxRow, LPCWSTR szColHead, PBYTE* ppbData, DWORD* pcbData, BOOL fStringFmt /*FALSE*/)
{
    HRESULT hr;
    LONG idxCol;
    IEnumCERTVIEWROW* pRow = NULL;
    IEnumCERTVIEWCOLUMN* pCol = NULL;
    ICertView* pView = NULL;

#if DBG
    DWORD dwVerifySize;
#endif

    CComponentDataImpl* pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);

    ASSERT(pFolder != NULL);

    // pollute the row enumerator we've got
    hr = m_RowEnum.GetRowEnum(pFolder->GetCA(), &pRow);
    _JumpIfError(hr, Ret, "GetRowEnum");

    hr = m_RowEnum.SetRowEnumPos(idxRow);
    _JumpIfError(hr, Ret, "SetRowEnumPos");

    // now we have the correct row; siphon data out of the correct column
    hr = m_RowEnum.GetView(pFolder->GetCA(), &pView);
    _JumpIfError(hr, Ret, "GetView");

    // get column number in schema
    idxCol = pCompData->FindColIdx(szColHead);

    // retrieve and alloc
    *pcbData = 0;
    hr = GetCellContents(&m_RowEnum, pFolder->GetCA(), idxRow, idxCol, NULL, pcbData, fStringFmt);
    _JumpIfError(hr, Ret, "GetCellContents");

    *ppbData = new BYTE[*pcbData];
    _JumpIfOutOfMemory(hr, Ret, *ppbData);

#if DBG
    dwVerifySize = *pcbData;
#endif
    hr = GetCellContents(&m_RowEnum, pFolder->GetCA(), idxRow, idxCol, *ppbData, pcbData, fStringFmt);
    _JumpIfError(hr, Ret, "GetCellContents");

#if DBG
    ASSERT(dwVerifySize == *pcbData);
#endif

Ret:
    // catch column inclusion errors, handle in a smart way
    if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_INDEX) ||
        hr == HRESULT_FROM_WIN32(ERROR_CONTINUE))
    {
        CString cstrFormat;
        cstrFormat.LoadString(IDS_COLUMN_INCLUSION_ERROR);

        LPCWSTR pszLocalizedCol = NULL;
        hr = myGetColumnDisplayName(szColHead, &pszLocalizedCol);
        ASSERT ((hr == S_OK) && (NULL != pszLocalizedCol));

        CString cstrTmp;
        cstrTmp.Format(cstrFormat, pszLocalizedCol);

        cstrFormat.Empty();
        cstrFormat.LoadString(IDS_MSG_TITLE);
        m_pConsole->MessageBoxW(cstrTmp, cstrFormat, MB_OK, NULL);
        
        hr = ERROR_CANCELLED;   // this is a cancellation so bail silently, we've shown error
    }

    return hr;
}


HRESULT
GetBinaryColumnFormat(
    IN WCHAR const *pwszColumnName,
    OUT LONG *pFormat)
{
    LONG Format = CV_OUT_BINARY;

    if (0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTRAWREQUEST,
		pwszColumnName))
    {
	Format = CV_OUT_BASE64REQUESTHEADER;
    }
    else
    if (0 == lstrcmpi(wszPROPRAWCERTIFICATE, pwszColumnName) ||
	0 == lstrcmpi(
		wszPROPREQUESTDOT wszPROPREQUESTRAWOLDCERTIFICATE,
		pwszColumnName))
    {
	Format = CV_OUT_BASE64HEADER;
    }
    else
    {
	Format = CV_OUT_HEX;
    }

    *pFormat = Format;
    return(S_OK);
}


// Build the display name for templates: "friendly name (internal name)"
HRESULT CSnapin::BuildTemplateDisplayName(
    LPCWSTR pcwszFriendlyName, 
    LPCWSTR pcwszTemplateName,
    VARIANT& varDisplayName)
{

    CString strName;
    strName = pcwszFriendlyName;
    strName += L" (";
    strName += pcwszTemplateName;
    strName += L")";
    V_VT(&varDisplayName) = VT_BSTR;
    V_BSTR(&varDisplayName) = ::SysAllocString(strName);
    if(!V_BSTR(&varDisplayName))
        return E_OUTOFMEMORY;
    return S_OK;
}

// copies cell to pbData, truncates if necessary. Real size passed out in pcbData
HRESULT CSnapin::GetCellContents(CertViewRowEnum* pCRowEnum, CertSvrCA* pCA, LONG idxRow, LONG idxCol, PBYTE pbData, DWORD* pcbData, BOOL fStringFmt)
{
    HRESULT hr;

    CComponentDataImpl* pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (NULL == pCompData)
         return E_POINTER;

    VARIANT varCert;
    VariantInit(&varCert);

    LONG idxViewCol;

    IEnumCERTVIEWROW* pRow;
    IEnumCERTVIEWCOLUMN* pCol = NULL;

    hr = pCRowEnum->GetRowEnum(pCA, &pRow);
    if (hr != S_OK)
        return hr;

    do 
    {
        hr = pCRowEnum->SetRowEnumPos(idxRow);
        if (hr != S_OK)
            break;

        LONG lType;
        LPCWSTR szColHead;  // no free needed
        hr = pCRowEnum->GetColumnCacheInfo(idxCol, (int*)&idxViewCol);
        if (hr != S_OK)
            break;

        // get col enumerator object
        hr = pRow->EnumCertViewColumn(&pCol);
        if (hr != S_OK)
            break;

        hr = pCol->Skip(idxViewCol);
        if (hr != S_OK)
            break;
        // get value there
        hr = pCol->Next(&idxViewCol);
        if (hr != S_OK)
            break;


        if (fStringFmt)
        {
            LONG lFormat = CV_OUT_BINARY;
            VARIANT varTmp;
            VariantInit(&varTmp);

            hr = pCompData->GetDBSchemaEntry(idxCol, &szColHead, &lType, NULL);
            if (hr != S_OK)
                break;

            // New: translate _some_ cols to readable strings
            
            if (PROPTYPE_BINARY == lType)
            {
                hr = GetBinaryColumnFormat(szColHead, &lFormat);
                if (hr != S_OK)
                   break;
            }

            hr = pCol->GetValue(lFormat, &varTmp);
            if (hr != S_OK)
                break;
            
            if (0 == lstrcmpi(wszPROPREQUESTDOT wszPROPREQUESTRAWARCHIVEDKEY, szColHead))
            {
                if (VT_EMPTY != varTmp.vt)
                {
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szYes);
                    varCert.vt = VT_BSTR;
                }
            }
            else if (0 == lstrcmpi(wszPROPCERTTEMPLATE, szColHead))
            {
                LPCWSTR pcwszOID = NULL;
                
                if (VT_BSTR == varTmp.vt)
                {
                    // Map OID or template name to friendly name

                    // Try name first
                    HCERTTYPE hCertType;
                    LPWSTR *pwszCertTypeName;

                    hr = CAFindCertTypeByName(
                           varTmp.bstrVal,
                           NULL,
                           CT_ENUM_MACHINE_TYPES |
                           CT_ENUM_USER_TYPES |
                           0,
                           &hCertType);
                    if(S_OK==hr)
                    {
                        hr = CAGetCertTypeProperty(
                                    hCertType,
                                    CERTTYPE_PROP_FRIENDLY_NAME,
                                    &pwszCertTypeName);
                        if(S_OK==hr)
                        {

                            BuildTemplateDisplayName(
                                pwszCertTypeName[0],
                                varTmp.bstrVal,
                                varCert);

                            CAFreeCertTypeProperty(
                                hCertType,
                                pwszCertTypeName);
                        }

                        CACloseCertType(hCertType);
                    }
                    // Failed to find by name, try OID
                    if(S_OK!=hr)
                    {
                        pcwszOID = myGetOIDName(varTmp.bstrVal);
                        varCert.vt = VT_BSTR;
                        if (EmptyString(pcwszOID))
                        {
                            varCert.bstrVal = ::SysAllocString(varTmp.bstrVal);
                        }
                        else
                        {
                            BuildTemplateDisplayName(
                                pcwszOID,
                                varTmp.bstrVal,
                                varCert);
                        }
                    }
                }
            }
            else if (0 == lstrcmpi(wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE, szColHead))
            {
                if (VT_I4 == varTmp.vt)   // don't be empty
                {
                     WCHAR const *pwszError = myGetErrorMessageText(varTmp.lVal, TRUE);
                     varCert.bstrVal = ::SysAllocString(pwszError);
                     varCert.vt = VT_BSTR;
                }
            }
            else if (0 == lstrcmpi(wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON, szColHead))
            {
                if (VT_I4 == varTmp.vt)   // don't be empty
                {

                // Request.Disposition
                ASSERT(VT_I4 == varTmp.vt); // we'd better be looking at a dword

                switch(varTmp.lVal)
                {
                case CRL_REASON_KEY_COMPROMISE:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_KeyCompromise);
                    break;
                case CRL_REASON_CA_COMPROMISE:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_CaCompromise);
                    break;
                case CRL_REASON_AFFILIATION_CHANGED:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_Affiliation);
                    break;
                case CRL_REASON_SUPERSEDED:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_Superseded);
                    break;
                case CRL_REASON_CESSATION_OF_OPERATION:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_Cessatation);
                    break;
                case CRL_REASON_CERTIFICATE_HOLD:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_CertHold);
                    break;
                case CRL_REASON_UNSPECIFIED:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_Unspecified);
                    break;
                case CRL_REASON_REMOVE_FROM_CRL:
                    varCert.bstrVal = ::SysAllocString(g_cResources.m_szRevokeReason_RemoveFromCRL);
                    break;
                default:
                  {
                    // sprint this into a buffer for display
                    CString cstrSprintVal;
                    cstrSprintVal.Format(L"%i", varTmp.lVal);
                    varCert.bstrVal = cstrSprintVal.AllocSysString();
                    break;
                  }
                }

                if (varCert.bstrVal == NULL)
                {
                     hr = E_OUTOFMEMORY;
                     break;
                }

                varCert.vt = VT_BSTR;
                }
            }

            if (varCert.vt != VT_BSTR)    // if this hasn't been converted yet
            {
                // default: conversion to string

                // returns localized string time (even for date!)
                VERIFY( MakeDisplayStrFromDBVariant(&varTmp, &varCert) ); // variant type change failed!?

                InplaceStripControlChars(varCert.bstrVal);
            }

            VariantClear(&varTmp);
        }
        else
        {
            hr = pCol->GetValue(CV_OUT_BINARY, &varCert);
            if (hr != S_OK)
                break;

            if (VT_EMPTY == varCert.vt)
            {
                hr = CERTSRV_E_PROPERTY_EMPTY;
                break;
            }
        }


        // finally, copy this value out to pb

        // copy, truncate if necessary
        DWORD cbTruncate = *pcbData;
        if (varCert.vt == VT_BSTR)
        {
            *pcbData = SysStringByteLen(varCert.bstrVal) + ((fStringFmt)? sizeof(WCHAR):0);
            CopyMemory(pbData, varCert.bstrVal, min(cbTruncate, *pcbData));
        }
        else if (varCert.vt == VT_I4)
        {
            *pcbData = sizeof(LONG);
            if (pbData != NULL)
                *(DWORD*)pbData = varCert.lVal;
        }
        else 
        {
            hr = E_INVALIDARG;
            break;
        }


    }while(0);

    VariantClear(&varCert);

    if (pCol)
        pCol->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

const GUID* FolderTypeToNodeGUID(DATA_OBJECT_TYPES type, CFolder* pFolder);

class CDataObject : 
    public IDataObject, 
    public CComObjectRoot
{

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


// Construction/Destruction
    CDataObject();
    virtual ~CDataObject() 
    {
        if (m_pComponentData)
        {
            m_pComponentData->Release();        
            m_pComponentData = NULL;
        }
    };

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeID;          // per-node column identifiers
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    static unsigned int    m_cfIsMultiSel;      // Required by the console
    static unsigned int    m_cfObjInMultiSel;   // Required by the console
    static unsigned int    m_cfPreloads;        // Required by the console

    static unsigned int    m_cfInternal;        // 
    static unsigned int    m_cfSelectedCA_InstallType;   // published information
    static unsigned int	   m_cfSelectedCA_CommonName;    // Published information
    static unsigned int	   m_cfSelectedCA_MachineName;   // Published information
    static unsigned int	   m_cfSelectedCA_SanitizedName;    // Published information

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

// Not Implemented
private:

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation

    // This is used only as a diagnostic in debug builds to track if 
    // anyone is hanging on to any data objects that's have been handed out
    // Snapins should view context data objects as ephemeral.
public:
    void SetComponentData(CComponentDataImpl* pCCD) 
    {
        if (NULL != pCCD)
        {           
            ASSERT(m_pComponentData == NULL); 
            m_pComponentData = pCCD;
            m_pComponentData->AddRef();
        }
    } 
private:
    CComponentDataImpl* m_pComponentData;



public:
    void SetViewID(DWORD dwView) { /* m_dwViewID = dwView; */}
    void SetType(DATA_OBJECT_TYPES type) { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }
    void SetCookie(MMC_COOKIE cookie)   { m_internal.m_cookie = cookie; } 
    void SetString(LPTSTR lpString)     { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid)   { m_internal.m_clsid = clsid; }

    void SetMultiSelData(SMMCObjectTypes *psGuidObjTypes, UINT cbMultiSelData)
    {
        // make sure [1] still good enough
        ASSERT(cbMultiSelData == sizeof(m_sGuidObjTypes));
        if (cbMultiSelData == sizeof(m_sGuidObjTypes))
        {
            m_cbMultiSelData = cbMultiSelData;
            CopyMemory(&m_sGuidObjTypes, psGuidObjTypes, cbMultiSelData);
        }
    }

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

#ifdef _DEBUG
    UINT dbg_refCount;

    void AddRefMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        ++dbg_refCount;
    }

    void ReleaseMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        --dbg_refCount;
    }
#endif

private:
    HRESULT CreateObjInMultiSel(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeIDData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); 
    HRESULT CreateWorkstationName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreatePreloadsData(LPSTGMEDIUM lpMedium);
    
    HRESULT CreateSelectedCA_InstallType(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_CommonName(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_MachineName(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_SanitizedName(LPSTGMEDIUM lpMedium);


    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
    HRESULT CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);


private:
    INTERNAL m_internal;    

    SMMCObjectTypes m_sGuidObjTypes; // length[1] good enough for now
    UINT m_cbMultiSelData;
    BOOL m_bMultiSelDobj;

    DWORD m_dwViewID;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\folders.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "csdisp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void CFolder::SetProperties(LPCWSTR szName, SCOPE_TYPES itemType,
                                FOLDER_TYPES type, int iChildren)
{
    // Set folder type 
    m_type = type;

    // Set scope
    m_itemType = itemType;


    // Add node name
    if (szName != NULL)
    {
        m_ScopeItem.mask |= SDI_STR;
    	m_ScopeItem.displayname = MMC_CALLBACK;
        
        UINT uiByteLen = (wcslen(szName) + 1) * sizeof(OLECHAR);
        LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);
    
        if (psz != NULL)
        {
            wcscpy(psz, szName);
            m_pszName = psz;
        }
    }

    // Always tell view if we have children or not
    m_ScopeItem.mask |= SDI_CHILDREN;
    m_ScopeItem.cChildren = iChildren;
}

void CFolder::SetScopeItemInformation(int nImage, int nOpenImage)
{ 
    // Add close image
    m_ScopeItem.mask |= SDI_IMAGE;
    m_ScopeItem.nImage = nImage;

    // Add open image
    m_ScopeItem.mask |= SDI_OPENIMAGE;
    m_ScopeItem.nOpenImage = nOpenImage;
}

// IPersistStream interface members
HRESULT 
CFolder::Load(IStream *pStm)
{
    HRESULT hr;
    ASSERT(pStm);

    DWORD dwVer;
    CString cstr;
    int nImage;
    int nOpenImage;
    SCOPE_TYPES itemScopeType;
    FOLDER_TYPES itemFolderType;
    int iChildren;

    // load important properties
    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Load dwVer");

    // check to see if correct version
    ASSERT(dwVer == VER_FOLDER_SAVE_STREAM_2 || dwVer == VER_FOLDER_SAVE_STREAM_1);
    if ((VER_FOLDER_SAVE_STREAM_2 != dwVer) && (dwVer != VER_FOLDER_SAVE_STREAM_1))
    {
        hr = STG_E_OLDFORMAT;
        _JumpError(hr, Ret, "Unsupported Version");
    }

    // LPCWSTR szName
    hr = CStringLoad(cstr, pStm);
    _JumpIfError(hr, Ret, "CStringLoad");

    hr = ReadOfSize(pStm, &nImage, sizeof(int));
    _JumpIfError(hr, Ret, "ReadOfSize nImage");

    hr = ReadOfSize(pStm, &nOpenImage, sizeof(int));
    _JumpIfError(hr, Ret, "ReadOfSize nOpenImage");

    hr = ReadOfSize(pStm, &itemScopeType, sizeof(SCOPE_TYPES));
    _JumpIfError(hr, Ret, "ReadOfSize itemScopeType");

    hr = ReadOfSize(pStm, &itemFolderType, sizeof(FOLDER_TYPES));
    _JumpIfError(hr, Ret, "ReadOfSize itemFolderType");

    hr = ReadOfSize(pStm, &iChildren, sizeof(int));
    _JumpIfError(hr, Ret, "ReadOfSize iChildren");

    // call create with this data
    SetProperties(cstr, itemScopeType, itemFolderType, iChildren);
    SetScopeItemInformation(nImage, nOpenImage);

    // old ver: pull out dead enumerator
    if (dwVer == VER_FOLDER_SAVE_STREAM_1)
    {
        CertViewRowEnum cRowEnum;
        hr = cRowEnum.Load(pStm);
        _JumpIfError(hr, Ret, "Load cRowEnum");
    }

Ret:

    return hr;
}

HRESULT
CFolder::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;
    ASSERT(pStm);

    DWORD dwVer;
    CString cstr;


    // save important properties
    // Write the version
    dwVer = VER_FOLDER_SAVE_STREAM_2;
    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "WriteOfSize dwVer");

    // LPCWSTR szName
    cstr = (LPCWSTR)m_pszName;
    hr = CStringSave(cstr, pStm, fClearDirty);
    _JumpIfError(hr, Ret, "CStringSave");

    // int nImage
    hr = WriteOfSize(pStm, &m_ScopeItem.nImage, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize nImage");

    // int nOpenImage
    hr = WriteOfSize(pStm, &m_ScopeItem.nOpenImage, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize nOpenImage");

    // SCOPE_TYPES itemType
    hr = WriteOfSize(pStm, &m_itemType, sizeof(SCOPE_TYPES));
    _JumpIfError(hr, Ret, "WriteOfSize m_itemType");

    // FOLDER_TYPES type
    hr = WriteOfSize(pStm, &m_type, sizeof(FOLDER_TYPES));
    _JumpIfError(hr, Ret, "WriteOfSize m_type");

    // int iChildren
    hr = WriteOfSize(pStm, &m_ScopeItem.cChildren, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize cChildren");

//    hr = m_RowEnum.Save(pStm, fClearDirty);
//    _JumpIfError(hr, Ret, "Save m_RowEnum");

Ret:

    return hr;
}

HRESULT
CFolder::GetSizeMax(int *pcbSize)
{
    ASSERT(pcbSize);
    int iSize;
    
    // version
    iSize = sizeof(DWORD);

    // LPCWSTR szName
    CString cstr = m_pszName;
    CStringGetSizeMax(cstr, &iSize);

    // int nImage
    iSize += sizeof(int);

    // int nOpenImage
    iSize += sizeof(int);

    // SCOPE_TYPES
    iSize += sizeof(SCOPE_TYPES);

    // FOLDER_TYPES
    iSize += sizeof(FOLDER_TYPES);

    // BOOL bHasChildren   (actually saved as int)
    iSize += sizeof(int);

    int iAdditionalSize = 0;
//    m_RowEnum.GetSizeMax(&iAdditionalSize);
//    iSize += iAdditionalSize;

    *pcbSize = iSize;

    return S_OK;
}



BOOL IsAllowedStartStop(CFolder* pFolder, CertSvrMachine* pMachine)
{
    BOOL fRightPlace = (pFolder == NULL) || (SERVER_INSTANCE == pFolder->GetType());

    ASSERT(NULL != pMachine);

    // must be at right node and there must be CAs here
    return ( fRightPlace && (0 != pMachine->GetCaCount()) );
}


HRESULT GetCurrentColumnSchema(
            IN  LPCWSTR             szConfig, 
            OUT CString**           pprgcstrColumns, 
            OUT OPTIONAL LONG**     pprglTypes, 
            OUT OPTIONAL BOOL**     pprgfIndexed, 
            OUT LONG*               plEntries)
{
    HRESULT hr; 
    
    BOOL fGetTypes = pprglTypes != NULL;
    LONG* prglTypes = NULL;

    BOOL fGetIsIndexed = pprgfIndexed != NULL;
    BOOL* prgfIndexed = NULL;

    ICertView* pICertView = NULL;
    IEnumCERTVIEWCOLUMN* pColEnum = NULL;
    IEnumCERTVIEWROW *pRowEnum = NULL;

    BSTR bstrColumn = NULL;
    int colIdx=0;
    
    //LPWSTR* prgszCols = NULL;
    CString* prgcstrColumns = NULL;
    LONG lCols; 

    int i;

    hr = CoCreateInstance(
        CLSID_CCertView,
        NULL,		// pUnkOuter
        CLSCTX_INPROC_SERVER,
        IID_ICertView,
        (VOID **) &pICertView);
    _JumpIfError(hr, Ret, "CoCreateInstance");
    
    ASSERT(NULL != szConfig);
    hr = pICertView->OpenConnection(const_cast<WCHAR*>(szConfig));
    _JumpIfError(hr, Ret, "OpenConnection");

    hr = pICertView->OpenView(&pRowEnum);
    _JumpIfError(hr, Ret, "OpenView");
    
    hr = pICertView->GetColumnCount(FALSE, &lCols);
    _JumpIfError(hr, Ret, "GetColumnCount");
    
    // we need a place to store each LPWSTR
    prgcstrColumns = new CString[lCols];
    _JumpIfOutOfMemory(hr, Ret, prgcstrColumns);

    if (fGetTypes)
    {   
        prglTypes = new LONG[lCols];
        _JumpIfOutOfMemory(hr, Ret, prglTypes);
    }

    if (fGetIsIndexed)
    {
        prgfIndexed = new BOOL[lCols];
        _JumpIfOutOfMemory(hr, Ret, prgfIndexed);
    }

    // get column enumerator
    hr = pICertView->EnumCertViewColumn(FALSE, &pColEnum);
    _JumpIfError(hr, Ret, "EnumCertViewColumn");
    
    
    for (i=0; i<lCols; i++)
    {
        hr = pColEnum->Next((LONG*)&colIdx);
        _JumpIfError(hr, Ret, "Next");

        hr = pColEnum->GetName(&bstrColumn);
        if (NULL == bstrColumn)
            hr = E_UNEXPECTED;
        _JumpIfError(hr, Ret, "GetName");

        prgcstrColumns[i] = bstrColumn;    // wcscpy

        if (fGetTypes)
        {   
            hr = pColEnum->GetType(&prglTypes[i]);
            _JumpIfError(hr, Ret, "GetType");
        }

        if (fGetIsIndexed)
        {
            hr = pColEnum->IsIndexed((LONG*)&prgfIndexed[i]);
            _JumpIfError(hr, Ret, "IsIndexed");
        }

        // next GetName call will free bstrColumn
        // SysFreeString(bstrColumn); 
        // bstrColumn = NULL;
    }
    

    // assign to out param
    if (fGetTypes)
    {
        *pprglTypes = prglTypes;
        prglTypes = NULL;
    }
    
    if (fGetIsIndexed)
    {
        *pprgfIndexed = prgfIndexed;
        prgfIndexed = NULL;
    }

    *pprgcstrColumns = prgcstrColumns;
    prgcstrColumns = NULL;

    *plEntries = lCols;

    hr = S_OK;
Ret:
    if (pICertView)
        pICertView->Release();

    if (pColEnum)
        pColEnum->Release();

    if (pRowEnum)
        pRowEnum->Release();

    if (bstrColumn)
        SysFreeString(bstrColumn);

    if (prglTypes)
        delete [] prglTypes;

    if (prgfIndexed)
        delete [] prgfIndexed;

    if (prgcstrColumns)
        delete [] prgcstrColumns;

    return hr;
}

// row operations
CertViewRowEnum::CertViewRowEnum()
{
    m_pICertView = NULL;
    m_fCertViewOpenAttempted = FALSE;

    m_pRowEnum = NULL;

    m_pRestrictions = NULL;
    m_fRestrictionsActive = FALSE;

    m_dwColumnCount = 0;
    m_prgColPropCache = NULL;

    m_dwErr = 0;

    InvalidateCachedRowEnum();
}

CertViewRowEnum::~CertViewRowEnum()
{
    InvalidateCachedRowEnum();
    FreeColumnCacheInfo();

    if (m_pICertView)
    {
        VERIFY(0 == m_pICertView->Release());
        m_pICertView = NULL; 
    }

    if (m_pRestrictions)
    {
        FreeQueryRestrictionList(m_pRestrictions);
        m_pRestrictions = NULL;
    }
    m_fRestrictionsActive = FALSE;
}

HRESULT IsColumnShown(MMC_COLUMN_SET_DATA* pCols, ULONG idxCol, BOOL* pfShown)
{
    if (idxCol > (ULONG)pCols->nNumCols)
        return ERROR_INVALID_INDEX;

    *pfShown = (pCols->pColData[idxCol].dwFlags != HDI_HIDDEN);

    return S_OK;
}


HRESULT CountShownColumns(MMC_COLUMN_SET_DATA* pCols, ULONG* plCols)
{
    HRESULT hr = S_OK;
    *plCols = 0;

    // set col cache correctly
    for (int i=0; i<pCols->nNumCols; i++)
    {
        BOOL fShown;
        hr = IsColumnShown(pCols, i, &fShown);
        _JumpIfError(hr, Ret, "IsColumnShown");

        // update 
        if (fShown)
            (*plCols)++;
    }
Ret:
    return hr;
}


HRESULT CertViewRowEnum::Load(IStream *pStm)
{
    HRESULT hr;
    ASSERT(pStm);

    DWORD dwVer;
    DWORD iRestrictions;
    PQUERY_RESTRICTION pCurRestriction = NULL;
    DWORD iRestrictionNum;
    LONG lCols;

    // load important properties
    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Load dwVer");
    
    // check to see if this is a supported version
    ASSERT((dwVer == VER_CERTVIEWROWENUM_SAVE_STREAM_3) || 
           (dwVer == VER_CERTVIEWROWENUM_SAVE_STREAM_4));
    if ((VER_CERTVIEWROWENUM_SAVE_STREAM_4 != dwVer) && 
        (VER_CERTVIEWROWENUM_SAVE_STREAM_3 != dwVer))
    {
        hr = STG_E_OLDFORMAT;
        _JumpError(hr, Ret, "dwVer");
    }

    // version-dependent: throw away sort order
    if (VER_CERTVIEWROWENUM_SAVE_STREAM_3 == dwVer)
    {
        LONG lSortOrder;
        CString cstrSortCol;

        ReadOfSize(pStm, &lSortOrder, sizeof(LONG));
        _JumpIfError(hr, Ret, "ReadOfSize lSortOrder");

        CStringLoad(cstrSortCol, pStm);
    }

    // fRestrictionsActive;
    hr = ReadOfSize(pStm, &m_fRestrictionsActive, sizeof(BOOL));
    _JumpIfError(hr, Ret, "ReadOfSize m_fRestrictionsActive");


    hr = ReadOfSize(pStm, &iRestrictions, sizeof(DWORD));
    _JumpIfError(hr, Ret, "ReadOfSize iRestrictions");

    for(iRestrictionNum=0; iRestrictionNum<iRestrictions; iRestrictionNum++)
    {
        // LPCWSTR szField
        CString cstr;
        UINT iOperation;
        VARIANT varValue;

        hr = CStringLoad(cstr, pStm);
        _JumpIfError(hr, Ret, "CStringLoad");

        // UINT iOperation
        hr = ReadOfSize(pStm, &iOperation, sizeof(int));
        _JumpIfError(hr, Ret, "ReadOfSize");

        // VARIANT varValue
        hr = VariantLoad(varValue, pStm);
        _JumpIfError(hr, Ret, "VariantLoad");

        // insert at end of list
        if (NULL == pCurRestriction)
        {
            // 1st restriction
            m_pRestrictions = NewQueryRestriction((LPCWSTR)cstr, iOperation, &varValue);
            _JumpIfOutOfMemory(hr, Ret, m_pRestrictions);

            pCurRestriction = m_pRestrictions;
        }
        else
        {
            pCurRestriction->pNext = NewQueryRestriction((LPCWSTR)cstr, iOperation, &varValue);
            _JumpIfOutOfMemory(hr, Ret, pCurRestriction->pNext);

            pCurRestriction = pCurRestriction->pNext;
        }
    }

    // version-dependent data: column sizes
    if (dwVer == VER_CERTVIEWROWENUM_SAVE_STREAM_3)
    {
        // now load column sizes (NOW DEFUNCT -- mmc saves for us)

        // number of cols DWORD dwColSize
        DWORD dwColSize;
        DWORD dwCol;
        LONG lViewType;

        hr = ReadOfSize(pStm, &dwColSize, sizeof(DWORD));
        _JumpIfError(hr, Ret, "ReadOfSize dwColSize");


        for(dwCol=0; dwCol<dwColSize; dwCol++)
        {
            // BOOL fValid
            BOOL fValid;
            int iSize;
            BOOL fUnLocColHead;

            hr = ReadOfSize(pStm, &fValid, sizeof(BOOL));
            _JumpIfError(hr, Ret, "ReadOfSize fValid");

            // int iSize
            hr = ReadOfSize(pStm, &iSize, sizeof(int));
            _JumpIfError(hr, Ret, "ReadOfSize iSize");

            // BOOL fUnLocColHead
            hr = ReadOfSize(pStm, &fUnLocColHead, sizeof(BOOL));
            _JumpIfError(hr, Ret, "ReadOfSize fUnLocColHead");

            // load only if exists
            if (fUnLocColHead)
            {
                CString cstrUnLocColHead;
                hr = CStringLoad(cstrUnLocColHead, pStm);
                _JumpIfError(hr, Ret, "CStringLoad");
            }
        }

        // view type
        hr = ReadOfSize(pStm, &lViewType, sizeof(LONG));
        _JumpIfError(hr, Ret, "ReadOfSize lViewType");

    } // version 3 data

Ret:

    return hr;
}

HRESULT CertViewRowEnum::Save(IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);
    HRESULT hr;

    DWORD dwVer, dwCol;
    int iRestrictions = 0;
    PQUERY_RESTRICTION pRestrict;

    // save important properties

    // Write the version
    dwVer = VER_CERTVIEWROWENUM_SAVE_STREAM_4;
    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "WriteOfSize dwVer");

    // BOOL fRestrictionsActive
    hr = WriteOfSize(pStm, &m_fRestrictionsActive, sizeof(BOOL));
    _JumpIfError(hr, Ret, "WriteOfSize m_fRestrictionsActive");


    // count restrictions
    pRestrict = m_pRestrictions;
    while(pRestrict)
    {
        iRestrictions++;
        pRestrict = pRestrict->pNext;
    }

    // int iRestrictions
    hr = WriteOfSize(pStm, &iRestrictions, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize iRestrictions");

    // write each restriction in turn
    pRestrict = m_pRestrictions;
    while(pRestrict)
    {
        // LPCWSTR szField
        CString cstr = pRestrict->szField;
        hr = CStringSave(cstr, pStm, fClearDirty);
        _JumpIfError(hr, Ret, "CStringSave");

        // UINT iOperation
        hr = WriteOfSize(pStm, &pRestrict->iOperation, sizeof(UINT));
        _JumpIfError(hr, Ret, "WriteOfSize iOperation");

        // VARIANT varValue
        hr = VariantSave(pRestrict->varValue, pStm, fClearDirty);
        _JumpIfError(hr, Ret, "VariantSave varValue");

        pRestrict = pRestrict->pNext;
    }

   
Ret:
    return hr;
}

HRESULT CertViewRowEnum::GetSizeMax(int *pcbSize)
{
    ASSERT(pcbSize);
    
    // version
    *pcbSize = sizeof(DWORD);

    // fRestrictionsActive
    *pcbSize += sizeof(BOOL);

    // iRestrictions
    *pcbSize += sizeof(int);

    // size each restriction
    PQUERY_RESTRICTION pRestrict = m_pRestrictions;
    while(pRestrict)
    {
        // LPCWSTR szField
        int iSize;
        CString cstr = pRestrict->szField;
        CStringGetSizeMax(cstr, &iSize);
        *pcbSize += iSize;
        
        // UINT iOperation        
        *pcbSize += sizeof(UINT);

        // VARIANT
        VariantGetSizeMax(pRestrict->varValue, &iSize);
        *pcbSize += iSize;
    }

    return S_OK;
}


HRESULT CertViewRowEnum::GetView(CertSvrCA* pCA, ICertView** ppView)
{
    HRESULT hr = S_OK;

    // if tried to get result 
    if (m_fCertViewOpenAttempted)
    {
        *ppView = m_pICertView;
        ASSERT(m_pICertView || m_dwErr);
        return (m_pICertView==NULL) ? m_dwErr : S_OK;
    }

    if (m_pICertView)
    {
        m_pICertView->Release();
        m_pICertView = NULL;
    }

    if (!pCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        *ppView = NULL;
        hr = RPC_S_NOT_LISTENING;
        _JumpError(hr, Ret, "IsCertSvrServiceRunning");
    }
    m_fCertViewOpenAttempted = TRUE;


	hr = CoCreateInstance(
			CLSID_CCertView,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertView,
			(VOID **) &m_pICertView);
    _JumpIfError(hr, Ret, "CoCreateInstance");

    ASSERT(NULL != pCA->m_bstrConfig);
    hr = m_pICertView->OpenConnection(pCA->m_bstrConfig);
    _JumpIfError(hr, Ret, "OpenConnection");
    
Ret:
    if (hr != S_OK)
    {
        if (m_pICertView)
        {
            m_pICertView->Release();
            m_pICertView = NULL;
        }
    }
    m_dwErr = hr;

    *ppView = m_pICertView;
    return hr;
}

HRESULT CertViewRowEnum::GetRowEnum(CertSvrCA* pCA, IEnumCERTVIEWROW**   ppRowEnum)
{
    if (m_fRowEnumOpenAttempted)
    {
        *ppRowEnum = m_pRowEnum;
        ASSERT(m_pRowEnum || m_dwErr);
        return (m_pRowEnum == NULL) ? m_dwErr : S_OK;
    }

    ASSERT(m_pRowEnum == NULL);
    ASSERT(m_idxRowEnum == -1);

    m_fRowEnumOpenAttempted = TRUE;

    HRESULT hr;
    ICertView* pView;

    hr = GetView(pCA, &pView);
    _JumpIfError(hr, Ret, "GetView");

    hr = pView->OpenView(&m_pRowEnum);
    _JumpIfError(hr, Ret, "OpenView");

Ret:
    *ppRowEnum = m_pRowEnum;
    m_dwErr = hr;

    return hr;
};


void CertViewRowEnum::InvalidateCachedRowEnum()
{
    if (m_pRowEnum)
    {
        m_pRowEnum->Release();
        m_pRowEnum = NULL;
    }

    m_idxRowEnum = -1;
    m_fRowEnumOpenAttempted = FALSE;

    // results
    m_fKnowNumResultRows = FALSE;
    m_dwResultRows = 0;
}

HRESULT CertViewRowEnum::ResetCachedRowEnum()
{   
    HRESULT hr = S_OK;

    if (m_pRowEnum)
    {   
        hr = m_pRowEnum->Reset(); 
        m_idxRowEnum = -1;
    }

    return hr;
};

HRESULT CertViewRowEnum::GetRowMaxIndex(CertSvrCA* pCA, LONG* pidxMax)
{
    HRESULT hr;
    IEnumCERTVIEWROW*   pRowEnum;   // don't have to free, just a ref to class member

    ASSERT(pidxMax);

    hr = GetRowEnum(pCA, &pRowEnum);
    _JumpIfError(hr, Ret, "GetRowEnum");


    hr = pRowEnum->GetMaxIndex(pidxMax);
    _JumpIfError(hr, Ret, "GetMaxIndex");

    // update max
    if (!m_fKnowNumResultRows)
    {
        m_dwResultRows = *pidxMax;
        m_fKnowNumResultRows = TRUE;
    }

Ret:
    return hr;
}

#if 0// DBG
void ReportMove(LONG idxCur, LONG idxDest, LONG skip)
{
    if ((idxDest == 0) && (skip == 0))
    {
        DBGPRINT((DBG_SS_CERTMMC, "Cur %i Dest 0 <RESET><NEXT>\n", idxCur));
        return;
    }

    DBGPRINT((DBG_SS_CERTMMC, "Cur %i Dest %i <SKIP %i><NEXT>\n", idxCur, idxDest, skip));
}
#else
#define ReportMove(_x_, _y_, _z_)
#endif

HRESULT CertViewRowEnum::SetRowEnumPos(LONG idxRow)
{   
    // make input ones-based

    // seek there smartly
    LONG idxRelative; 
    HRESULT hr;

    // already positioned correctly
    if (idxRow == m_idxRowEnum)
        return S_OK;

    // Next() could take awhile
    CWaitCursor cwait;

    ResetCachedRowEnum();
    hr = m_pRowEnum->Skip(idxRow);
    _JumpIfError(hr, Ret, "Skip");

    LONG lTmp;
    hr = m_pRowEnum->Next(&lTmp);
    if (hr != S_OK)
    {
        // ignore reentrance error in ICertView (bug 339811)
        if(hr != E_UNEXPECTED)
        {
            ResetCachedRowEnum();
        }

        _JumpError2(hr, Ret, "Next", S_FALSE);
    }

    // we should be successfully seeked to result row (ones-based)
    ASSERT(lTmp == idxRow+1);

    // else okay, we seeked correctly
    m_idxRowEnum = idxRow;

    // update max if necessary
    if (m_idxRowEnum+1 > (int)m_dwResultRows)
        m_dwResultRows = m_idxRowEnum+1;

Ret:
    // ignore reentrance error in ICertView (bug 339811)
    if(hr==E_UNEXPECTED)
    {
	hr = S_OK;
    }
    return hr;


};


// DB Column Property Caches
void CertViewRowEnum::FreeColumnCacheInfo()
{
    if (m_prgColPropCache)
    {
        LocalFree(m_prgColPropCache);
        m_prgColPropCache = NULL;
    }
    m_dwColumnCount = 0;
}

HRESULT CertViewRowEnum::SetColumnCacheInfo(
            IN int iIndex,         // db col
            IN int     idxViewCol) // 0...X
{
    if (m_dwColumnCount <= (DWORD)iIndex)
        return HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);

    m_prgColPropCache[iIndex].iViewCol = idxViewCol;
    return S_OK;
}

HRESULT CertViewRowEnum::GetColumnCacheInfo(
            int     iIndex,        // 0..x
            int*    piViewIndex)   // db col
{
    if (m_dwColumnCount <= (DWORD)iIndex)
        return HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);

    // don't let uninitialized elements get through
    if (m_prgColPropCache[iIndex].iViewCol == -1)
    {
        // Handle mmc bug:
        // This is commonly caused by race condition between time
        // we get an MMCN_COLUMNS_CHANGED for a col removal and the 
        // listview asking to update the removed column. AnandhaG knows about
        // this bug.

        // so that we don't fail the whole view, just go on about your business

        DBGPRINT((DBG_SS_CERTMMC, "GetColumnCacheInfo error: unknown dbcol = %i\n", iIndex));
        return HRESULT_FROM_WIN32(ERROR_CONTINUE);
    }

    if (piViewIndex)
        *piViewIndex = m_prgColPropCache[iIndex].iViewCol;

    return S_OK;
}


// This is a destructive operation, and resets EVERYTHING about the column cache
HRESULT CertViewRowEnum::ResetColumnCount(LONG lCols)
{
    HRESULT hr = S_OK;
    DWORD dwCount;

    if ((DWORD)lCols != m_dwColumnCount)
    {
        void* pvNewAlloc;

        // for view properties
        if (m_prgColPropCache)
            pvNewAlloc = LocalReAlloc(m_prgColPropCache, sizeof(COLUMN_TYPE_CACHE)*lCols, LMEM_MOVEABLE);
        else
            pvNewAlloc = LocalAlloc(LMEM_FIXED, sizeof(COLUMN_TYPE_CACHE)*lCols);
        if (NULL == pvNewAlloc)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, Ret, "Local(Re)Alloc");
        }

        m_prgColPropCache = (COLUMN_TYPE_CACHE*)pvNewAlloc;
        m_dwColumnCount = lCols;
    }

    // initialize with -1s -- invalidate cache
    FillMemory(m_prgColPropCache, m_dwColumnCount * sizeof(COLUMN_TYPE_CACHE), 0xff);

Ret:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\genpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       genpage.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "genpage.h"
#include "progress.h"

#include "certsrv.h"
#include "csdisp.h"
//#include "misc.h"

#include "certca.h"
#include <cryptui.h>

#include "csmmchlp.h"
#include "cslistvw.h"
#include "certmsg.h"
#include "urls.h"
#include "certsrvd.h"
#include "certsd.h"
#include "setupids.h"

#include <objsel.h>
#include <comdef.h>

#define __dwFILE__	__dwFILE_CERTMMC_GENPAGE_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CString CSvrSettingsCertManagersPage::m_strButtonAllow;
CString CSvrSettingsCertManagersPage::m_strButtonDeny;
CString CSvrSettingsCertManagersPage::m_strTextAllow;
CString CSvrSettingsCertManagersPage::m_strTextDeny;


UINT g_aidFont[] =
{
    IDS_LARGEFONTNAME,
    IDS_LARGEFONTSIZE,
    IDS_SMALLFONTNAME,
    IDS_SMALLFONTSIZE,
};


// forwards
BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash);

HRESULT GetPolicyManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi);

HRESULT GetExitManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi);


HRESULT ThunkServerCallbacks(CertSvrCA* pCA);

INT_PTR CALLBACK dlgProcChooseModule(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcTimer(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcQuery(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcAddRestriction(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcRenewReuseKeys(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );

// Base/Delta CRL publish chooser
INT_PTR CALLBACK dlgProcRevocationPublishType(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );

#define CERTMMC_HELPFILENAME L"Certmmc.hlp"

//////////////////////////////
// hand-hewn pages

////
// 1

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsGeneralPage property page
CSvrSettingsGeneralPage::CSvrSettingsGeneralPage(CertSvrCA* pCA, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pCA(pCA)
{
    m_cstrCAName = _T("");
    m_cstrDescription = _T("");
    m_cstrProvName = _T("");
    m_cstrHashAlg = _T("");

    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
    m_fRestartServer = FALSE;
    m_wRestart = 0;

	m_fWin2kCA = FALSE;

    CSASSERT(m_pCA);
    if (NULL == m_pCA)
        return;

    // add reference to m_pParentMachine
	// At one time, MMC didn't protect us from
	// going away while proppages were open
    m_pCA->m_pParentMachine->AddRef();

    m_pReleaseMe = NULL;

    m_cstrCAName = m_pCA->m_strCommonName;
    m_cstrDescription = m_pCA->m_strComment;

    m_pAdmin = NULL;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE1);
}

CSvrSettingsGeneralPage::~CSvrSettingsGeneralPage()
{
    if(m_pAdmin)
    {
        m_pAdmin->Release();
        m_pAdmin = NULL;
    }

    if(m_pCA->m_pParentMachine)
    {
        // remove refcount from m_pParentMachine
        m_pCA->m_pParentMachine->Release();
    }

    if (m_pReleaseMe)
    {
        m_pReleaseMe->Release();
        m_pReleaseMe = NULL;
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsGeneralPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrCAName.FromWindow(GetDlgItem(m_hWnd, IDC_CANAME));
	    m_cstrDescription.FromWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrProvName.FromWindow(GetDlgItem(m_hWnd, IDC_CSP_NAME));
	    m_cstrHashAlg.FromWindow(GetDlgItem(m_hWnd, IDC_HASHALG));
    }
    else
    {
        m_cstrCAName.ToWindow(GetDlgItem(m_hWnd, IDC_CANAME));
	    m_cstrDescription.ToWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrProvName.ToWindow(GetDlgItem(m_hWnd, IDC_CSP_NAME));
	    m_cstrHashAlg.ToWindow(GetDlgItem(m_hWnd, IDC_HASHALG));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_VIEW_CERT:
        if (BN_CLICKED == HIWORD(wParam))
            OnViewCert((HWND)lParam);
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsGeneralPage message handlers
BOOL CSvrSettingsGeneralPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    DWORD dwSize, dwType, dwProvType, dwHashAlg;
    DWORD dwRet;
    BOOL  fShowErrPopup = TRUE;

    HWND hwndListCert;
    HWND hwndViewCert;
    DWORD cCertCount, dwCertIndex;
    VARIANT varPropertyValue;
    VariantInit(&varPropertyValue);

    //disable view button
    hwndViewCert = GetDlgItem(m_hWnd, IDC_VIEW_CERT);
    ::EnableWindow(hwndViewCert, FALSE);

    variant_t var;

    dwRet = m_pCA->GetConfigEntry(
                wszREGKEYCSP,
                wszREGPROVIDER,
                &var);
    if(dwRet != S_OK)
        return FALSE;
    m_cstrProvName = V_BSTR(&var);

    var.Clear();

    dwRet = m_pCA->GetConfigEntry(
                wszREGKEYCSP,
                wszREGPROVIDERTYPE,
                &var);
    if(dwRet != S_OK)
        return FALSE;
    dwProvType = V_I4(&var);

    var.Clear();

    dwRet = m_pCA->GetConfigEntry(
                wszREGKEYCSP,
                wszHASHALGORITHM,
                &var);
    if(dwRet != S_OK)
        return FALSE;
    dwHashAlg = V_I4(&var);

    var.Clear();

    VERIFY (ERROR_SUCCESS ==
        CryptAlgToStr(&m_cstrHashAlg, m_cstrProvName, dwProvType, dwHashAlg) );


    dwRet = m_pCA->m_pParentMachine->GetAdmin2(&m_pAdmin);
    if (RPC_S_NOT_LISTENING == dwRet ||
        RPC_S_SERVER_UNAVAILABLE == dwRet)
    {
        //certsrv service is not running
        CString cstrMsg, cstrTitle;
        cstrMsg.LoadString(IDS_VIEW_CERT_NOT_RUNNING);
        cstrTitle.LoadString(IDS_MSG_TITLE);
        MessageBoxW(m_hWnd, cstrMsg, cstrTitle, MB_OK);
        fShowErrPopup = FALSE;
    }
    _JumpIfError(dwRet, Ret, "GetAdmin");

	// load certs here
	dwRet = m_pAdmin->GetCAProperty(
		m_pCA->m_bstrConfig,
		CR_PROP_CASIGCERTCOUNT,
		0, // (unused)
		PROPTYPE_LONG, // PropType
		CR_OUT_BINARY, // Flags
		&varPropertyValue);
	if (dwRet == RPC_E_VERSION_MISMATCH)
	{
		// if we're talking to a downlevel, keep same functionality as before: remove list
		m_fWin2kCA = TRUE;
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_LIST_CERTS), FALSE);
		dwRet = ERROR_SUCCESS;
		goto Ret;
	}
	_JumpIfError(dwRet, Ret, "GetCAProperty");

	// varPropertyValue.vt will be VT_I4
	// varPropertyValue.lVal will be the CA signature cert count
	if (VT_I4 != varPropertyValue.vt)
	{
		dwRet = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		_JumpError(dwRet, Ret, "GetCAProperty");
	}

	cCertCount = varPropertyValue.lVal;

    hwndListCert = GetDlgItem(m_hWnd, IDC_LIST_CERTS);

    // now we have a max count; begin looping
	for (dwCertIndex=0; dwCertIndex<cCertCount; dwCertIndex++)
	{
        int iItemIndex;
		CString cstrItemName, cstrItemFmt;

		VariantClear(&varPropertyValue);

		// get each key's CRL state
		dwRet = m_pAdmin->GetCAProperty(
			m_pCA->m_bstrConfig,
			CR_PROP_CACERTSTATE, //PropId
			dwCertIndex, //PropIndex
			PROPTYPE_LONG, // PropType
			CR_OUT_BINARY, // Flags
			&varPropertyValue);
		_JumpIfError(dwRet, Ret, "GetCAProperty");

		// varPropertyValue.vt will be VT_I4
		// varPropertyValue.lVal will be the CRL state
		if (VT_I4 != varPropertyValue.vt)
		{
			dwRet = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
			_JumpError(dwRet, Ret, "GetCAProperty");
		}

		// put identifying information into dialog depending on cert state
                switch(varPropertyValue.lVal)
                {
case CA_DISP_REVOKED:    // This Cert has been revoked.
        cstrItemFmt.LoadString(IDS_CA_CERT_LISTBOX_REVOKED);
break;
case CA_DISP_VALID:      // This Cert is still valid
        cstrItemFmt.LoadString(IDS_CA_CERT_LISTBOX);
break;
case CA_DISP_INVALID:    // This Cert has expired.
        cstrItemFmt.LoadString(IDS_CA_CERT_LISTBOX_EXPIRED);
break;

                   case CA_DISP_ERROR:
         		// CA_DISP_ERROR means the Cert for that index is missing.
                   default:
                      continue;
                   break;
                }

        // sprintf the cert # into the string
        cstrItemName.Format(cstrItemFmt, dwCertIndex);

        iItemIndex = (INT)::SendMessage(hwndListCert, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)cstrItemName);
        // add cert # as item data
        ::SendMessage(hwndListCert, LB_SETITEMDATA, iItemIndex, (LPARAM)dwCertIndex);

		// in future, maybe we should load Certs here, suck out extra info to display,

		iItemIndex++;
	}

    if (0 < dwCertIndex)
    {
        int c = (int) ::SendMessage(hwndListCert, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

        //select last one
        if (LB_ERR != c)
            ::SendMessage(hwndListCert, LB_SETCURSEL, (WPARAM)(c-1), (LPARAM)0);

        //enable view button
        ::EnableWindow(hwndViewCert, TRUE);
    }

    UpdateData(FALSE);
Ret:
    VariantClear(&varPropertyValue);

    if (fShowErrPopup && ERROR_SUCCESS != dwRet)
		DisplayGenericCertSrvError(m_hWnd, dwRet);

    return TRUE;
}

void CSvrSettingsGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

void CSvrSettingsGeneralPage::OnViewCert(HWND hwndCtrl)
{
    CRYPTUI_VIEWCERTIFICATE_STRUCTW sViewCert;
    ZeroMemory(&sViewCert, sizeof(sViewCert));
    HCERTSTORE rghStores[2];    // don't bother closing these stores
	BSTR bstrCert; ZeroMemory(&bstrCert, sizeof(BSTR));
    PBYTE pbCert = NULL;
    DWORD cbCert;
    BOOL  fShowErrPopup = TRUE;

	DWORD dw = ERROR_SUCCESS;
	ICertRequest* pIRequest = NULL;

	if (m_fWin2kCA)
	{
		dw = CoCreateInstance(
				CLSID_CCertRequest,
				NULL,		// pUnkOuter
				CLSCTX_INPROC_SERVER,
				IID_ICertRequest,
				(VOID **) &pIRequest);

		// get this cert
		dw = pIRequest->GetCACertificate(FALSE, (LPWSTR)(LPCWSTR)m_pCA->m_strConfig, CR_IN_BINARY, &bstrCert);
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == (HRESULT)dw)
        {
            //possible certsrv service is not running but access deny
            //is very confusing error code, so use our own display text
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_VIEW_CERT_DENY_ERROR);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(hwndCtrl, cstrMsg, cstrTitle, MB_OK);
            fShowErrPopup = FALSE;
        }
		_JumpIfError(dw, Ret, "GetCACertificate");

		cbCert = SysStringByteLen(bstrCert);
		pbCert = (PBYTE)bstrCert;

		sViewCert.pCertContext = CertCreateCertificateContext(
			CRYPT_ASN_ENCODING,
			pbCert,
			cbCert);
		if (sViewCert.pCertContext == NULL)
		{
			dw = GetLastError();
			_JumpError(dw, Ret, "CertCreateCertificateContext");
		}
	}
	else
	{
		VARIANT varPropertyValue;
		VariantInit(&varPropertyValue);
		int iCertIndex = 0;

		// get cert # from item data
		HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_CERTS);
		DWORD dwSel = (DWORD)::SendMessage(hwndList, LB_GETCURSEL, 0, 0);
		if (LB_ERR == dwSel)
			goto Ret;

		iCertIndex = (int)::SendMessage(hwndList, LB_GETITEMDATA, (WPARAM)dwSel, 0);

		// get the Cert
		dw = m_pCA->GetCACertByKeyIndex(&(sViewCert.pCertContext), iCertIndex);
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == (HRESULT)dw)
        {
            //possible certsrv service is not running but access deny
            //is very confusing error code, so use our own display text
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_VIEW_CERT_DENY_ERROR);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(hwndCtrl, cstrMsg, cstrTitle, MB_OK);
            fShowErrPopup = FALSE;
        }
        else if (RPC_S_NOT_LISTENING == dw ||
                 RPC_S_SERVER_UNAVAILABLE == dw)
        {
            //certsrv service is not running
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_VIEW_CERT_NOT_RUNNING);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(hwndCtrl, cstrMsg, cstrTitle, MB_OK);
            fShowErrPopup = FALSE;
        }
		_JumpIfError(dw, Ret, "GetCACertByKeyIndex");
	}

    // get CA stores
    dw = m_pCA->GetRootCertStore(&rghStores[0]);
    _JumpIfError(dw, Ret, "GetRootCertStore");

    dw = m_pCA->GetCACertStore(&rghStores[1]);
    _JumpIfError(dw, Ret, "GetCACertStore");

	sViewCert.hwndParent = m_hWnd;
    sViewCert.dwSize = sizeof(sViewCert);
    sViewCert.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING | CRYPTUI_WARN_UNTRUSTED_ROOT | CRYPTUI_DISABLE_ADDTOSTORE;   // this is not the place to allow installs (kelviny discussion 12/11/98)

	// if we're opening remotely, don't open local stores
    if (! m_pCA->m_pParentMachine->IsLocalMachine())
        sViewCert.dwFlags |= CRYPTUI_DONT_OPEN_STORES;

    sViewCert.cStores = 2;
    sViewCert.rghStores = rghStores;

    if (!CryptUIDlgViewCertificateW(&sViewCert, NULL))
    {
        dw = GetLastError();
		if (dw != ERROR_CANCELLED)
	        _JumpError(dw, Ret, "CryptUIDlgViewCertificateW");
    }

Ret:
    VERIFY(CertFreeCertificateContext(sViewCert.pCertContext));

    if (bstrCert)
        SysFreeString(bstrCert);

    if (pIRequest)
        pIRequest->Release();

    if ((dw != ERROR_SUCCESS) && (dw != ERROR_CANCELLED) && fShowErrPopup)
        DisplayGenericCertSrvError(m_hWnd, dw);

}


BOOL CSvrSettingsGeneralPage::OnApply()
{
    return CAutoDeletePropPage::OnApply();
}

BOOL CSvrSettingsGeneralPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
        //handle double click on list items
        case IDC_LIST_CERTS:
            if (pnmh->code == NM_DBLCLK)
                OnViewCert(pnmh->hwndFrom);
            break;
    }
    return FALSE;
}

void CSvrSettingsGeneralPage::TryServiceRestart(WORD wPage)
{
    m_wRestart &= ~wPage; // whack off the page requesting this
    if (m_fRestartServer && (m_wRestart == 0))  // if we got a request to restart and all pages have agreed
    {

        if (RestartService(m_hWnd, m_pCA->m_pParentMachine))
        {
            MMCPropertyChangeNotify(m_hConsoleHandle, CERTMMC_PROPERTY_CHANGE_REFRESHVIEWS);
            m_fRestartServer = FALSE;
        }
    }
}


////
// 2
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsPolicyPage property page
CSvrSettingsPolicyPage::CSvrSettingsPolicyPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    m_cstrModuleName = _T("");
    m_cstrModuleDescr = _T("");
    m_cstrModuleVersion = _T("");
    m_cstrModuleCopyright = _T("");

    m_bUpdate = FALSE;

    m_fLoadedActiveModule = FALSE;
    m_pszprogidPolicyModule = NULL;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE2);
}

CSvrSettingsPolicyPage::~CSvrSettingsPolicyPage()
{
    if (NULL != m_pszprogidPolicyModule)
    {
        CoTaskMemFree(m_pszprogidPolicyModule);
        m_pszprogidPolicyModule = NULL;
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsPolicyPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
	    m_cstrModuleDescr.FromWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
	    m_cstrModuleVersion.FromWindow(GetDlgItem(m_hWnd, IDC_VERSION));
	    m_cstrModuleCopyright.FromWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));
    }
    else
    {
        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
	    m_cstrModuleDescr.ToWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
	    m_cstrModuleVersion.ToWindow(GetDlgItem(m_hWnd, IDC_VERSION));
	    m_cstrModuleCopyright.ToWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsPolicyPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_ACTIVE_MODULE:
        if (BN_CLICKED == HIWORD(wParam))
            OnSetActiveModule();
        break;
    case IDC_CONFIGURE:
        if (BN_CLICKED == HIWORD(wParam))
            OnConfigureModule();
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


HRESULT CSvrSettingsPolicyPage::GetCurrentModuleProperties()
{
    HRESULT hr;
    CString cstrStoragePath;
    BOOL fGotName = FALSE;
    DISPATCHINTERFACE di;
    BOOL fMustRelease = FALSE;
    BSTR bstrTmp=NULL, bstrProperty=NULL, bstrStorageLoc = NULL;

    hr = GetPolicyManageDispatch(
        m_pszprogidPolicyModule,
        m_clsidPolicyModule,
        &di);
    _JumpIfError(hr, Ret, "GetPolicyManageDispatch");

    fMustRelease = TRUE;

    cstrStoragePath = wszREGKEYCONFIGPATH_BS;
    cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += wszREGKEYPOLICYMODULES;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += m_pszprogidPolicyModule;

    bstrStorageLoc = SysAllocString(cstrStoragePath);
    if(!bstrStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, Ret, "SysAllocString");
    }

    bstrProperty = SysAllocString(wszCMM_PROP_NAME);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    ////////////////////
    // NAME
    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleName = bstrTmp;
        fGotName = TRUE;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }
    else
    {
        // have a backup name to display: CLSID of interface?
        m_cstrModuleName = m_pszprogidPolicyModule;
        fGotName = TRUE;

        // now bail
        _JumpError(hr, Ret, "ManageModule_GetProperty");
    }

    ////////////////////
    // DESCRIPTION
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_DESCRIPTION);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleDescr = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }

    ////////////////////
    // COPYRIGHT
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_COPYRIGHT);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleCopyright = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }

    ////////////////////
    // FILEVER
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_FILEVER);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleVersion = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }
Ret:
    if (!fGotName)
    {
        if (CO_E_CLASSSTRING == hr)
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_POLICYMODULE_NOT_REGISTERED);
        }
        else
        {
            WCHAR const *pwsz = myGetErrorMessageText(hr, TRUE);

            m_cstrModuleName = pwsz;
	    if (NULL != pwsz)
	    {
		LocalFree(const_cast<WCHAR *>(pwsz));
	    }
        }
    }
    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrProperty)
        SysFreeString(bstrProperty);

    if (bstrStorageLoc)
        SysFreeString(bstrStorageLoc);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsPolicyPage message handlers
BOOL CSvrSettingsPolicyPage::OnInitDialog()
{
    HRESULT hr;
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    // thse should be emptied
    m_cstrModuleName.Empty();
    m_cstrModuleDescr.Empty();
    m_cstrModuleVersion.Empty();
    m_cstrModuleCopyright.Empty();

    hr = myGetActiveModule(
        m_pControlPage->m_pCA,
        TRUE,
        0,
        &m_pszprogidPolicyModule,  // CoTaskMem*
        &m_clsidPolicyModule);
    _JumpIfError(hr, Ret, "myGetActiveModule");

    hr = GetCurrentModuleProperties();
    _JumpIfError(hr, Ret, "GetCurrentModuleProperties");

Ret:
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CONFIGURE), (hr == S_OK) );
    UpdateData(FALSE);
    return TRUE;
}

void CSvrSettingsPolicyPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}



void CSvrSettingsPolicyPage::OnConfigureModule()
{
    DWORD dw;
    DISPATCHINTERFACE di;
    ZeroMemory(&di, sizeof(DISPATCHINTERFACE));

    BOOL fMustRelease = FALSE;
    BSTR bstrStorageLoc = NULL;
    BSTR bstrVal = NULL;

    do {

        dw = GetPolicyManageDispatch(
            m_pszprogidPolicyModule,
            m_clsidPolicyModule,
            &di);
        _PrintIfError(dw, "GetPolicyManageDispatch");
        if (ERROR_SUCCESS != dw)
            break;

        fMustRelease = TRUE;

        LPWSTR szFullStoragePath = NULL;

        CString cstrStoragePath;
        cstrStoragePath = wszREGKEYCONFIGPATH_BS;
        cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += wszREGKEYPOLICYMODULES;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += m_pszprogidPolicyModule;

        bstrStorageLoc = SysAllocString(cstrStoragePath);
        _JumpIfOutOfMemory(dw, Ret, bstrStorageLoc);

        // Callbacks must be initialized whenever ManageModule_Configure is called
        dw = ThunkServerCallbacks(m_pControlPage->m_pCA);
        _JumpIfError(dw, Ret, "ThunkServerCallbacks");

        // pass an hwnd to the policy module -- this is an optional value
        bstrVal = SysAllocStringByteLen(NULL, sizeof(HWND));
        _JumpIfOutOfMemory(dw, Ret, bstrVal);

        *(HWND*)(bstrVal) = m_hWnd;

        dw = ManageModule_SetProperty(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                const_cast<WCHAR*>(wszCMM_PROP_DISPLAY_HWND),
                0,
                PROPTYPE_BINARY,
                bstrVal);
        _PrintIfError(dw, "ManageModule_SetProperty(HWND)");

        dw = ManageModule_Configure(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                0);
        _PrintIfError(dw, "ManageModule_Configure");

    } while(0);

    if (S_OK != dw)
        DisplayGenericCertSrvError(m_hWnd, dw);

Ret:
    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrStorageLoc)
        ::SysFreeString(bstrStorageLoc);

    if (bstrVal)
        ::SysFreeString(bstrVal);
}

typedef struct _PRIVATE_DLGPROC_MODULESELECT_LPARAM
{
    BOOL        fIsPolicyModuleSelection;
    CertSvrCA*  pCA;

    LPOLESTR*   ppszProgIDModule;
    CLSID*      pclsidModule;

} PRIVATE_DLGPROC_MODULESELECT_LPARAM, *PPRIVATE_DLGPROC_MODULESELECT_LPARAM;

void CSvrSettingsPolicyPage::OnSetActiveModule()
{
    DWORD dwErr;

    // get currently active module
    PRIVATE_DLGPROC_MODULESELECT_LPARAM    sParam;
    ZeroMemory(&sParam, sizeof(sParam));

    sParam.fIsPolicyModuleSelection = TRUE;
    sParam.pCA = m_pControlPage->m_pCA;

    sParam.ppszProgIDModule = &m_pszprogidPolicyModule;
    sParam.pclsidModule = &m_clsidPolicyModule;

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_MODULE),
            m_hWnd,
            dlgProcChooseModule,
            (LPARAM)&sParam);

    // translate ok/cancel into error codes
    if (IDOK == dwErr)
    {
        // dirty bit
        m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_POLICY);
        SetModified(TRUE);
        m_bUpdate = TRUE;
        GetCurrentModuleProperties();
        UpdateData(FALSE);
    }

    if ((dwErr != IDOK) && (dwErr != IDCANCEL))
    {
        _PrintIfError(dwErr, "dlgProcChooseModule");
        DisplayGenericCertSrvError(m_hWnd, dwErr);
    }

    return;
}

BOOL CSvrSettingsPolicyPage::OnApply()
{
    if (m_bUpdate)
    {
        if (NULL != m_pszprogidPolicyModule)
        {
            HRESULT hr;
            variant_t var;

            var = m_pszprogidPolicyModule;
            // now we have the chosen uuid -- set as default in registry
            hr = m_pControlPage->m_pCA->SetConfigEntry(
                wszREGKEYPOLICYMODULES,
                wszREGACTIVE,
                &var);

            if (hr != S_OK)
            {
                DisplayGenericCertSrvError(m_hWnd, hr);
                return FALSE;
            }
        }

        m_bUpdate = FALSE;
        m_pControlPage->TryServiceRestart(SERVERSETTINGS_PROPPAGE_POLICY);
    }


    return CAutoDeletePropPage::OnApply();
}



void ClearModuleDefn(PCOM_CERTSRV_MODULEDEFN pMod)
{
    if (pMod)
    {
        if (pMod->szModuleProgID)
            CoTaskMemFree(pMod->szModuleProgID);
        ZeroMemory(pMod, sizeof(COM_CERTSRV_MODULEDEFN));
    }
}

////
// 3
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExitPage property page
CSvrSettingsExitPage::CSvrSettingsExitPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    m_cstrModuleName = _T("");
    m_cstrModuleDescr = _T("");
    m_cstrModuleVersion = _T("");
    m_cstrModuleCopyright = _T("");

    m_bUpdate = FALSE;

    m_fLoadedActiveModule = FALSE;
    m_iSelected = -1;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE3);
}

CSvrSettingsExitPage::~CSvrSettingsExitPage()
{
    int i;
    for(i=0; i<m_arrExitModules.GetSize(); i++)
    {
        ClearModuleDefn(&m_arrExitModules[i]);
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsExitPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
        m_cstrModuleDescr.FromWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrModuleVersion.FromWindow(GetDlgItem(m_hWnd, IDC_VERSION));
        m_cstrModuleCopyright.FromWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));
    }
    else
    {
        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
        m_cstrModuleDescr.ToWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrModuleVersion.ToWindow(GetDlgItem(m_hWnd, IDC_VERSION));
        m_cstrModuleCopyright.ToWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));

        // if 0 modules, disable REMOVE button
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_REMOVE_MODULE), (0 != m_arrExitModules.GetSize()));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsExitPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_ADD_MODULE:
    case IDC_ACTIVE_MODULE:
        if (BN_CLICKED == HIWORD(wParam))
            OnAddActiveModule();
        break;
    case IDC_CONFIGURE:
        if (BN_CLICKED == HIWORD(wParam))
            OnConfigureModule();
        break;
    case IDC_REMOVE_MODULE:
        if (BN_CLICKED == HIWORD(wParam))
            OnRemoveActiveModule();
        break;
    case IDC_EXIT_LIST:
        if (LBN_SELCHANGE == HIWORD(wParam))
        {
            m_iSelected = (int)SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_GETCURSEL, 0, 0);
            UpdateSelectedModule();
            break;
        }
    default:
        return FALSE;
        break;
    }
    return TRUE;
}

BOOL CSvrSettingsExitPage::UpdateSelectedModule()
{
    HRESULT hr;
    BOOL fGotName = FALSE;
    DISPATCHINTERFACE di;
    BOOL fMustRelease = FALSE;

    LPWSTR szFullStoragePath = NULL;
    CString cstrStoragePath;

    // empty any strings
    m_cstrModuleName.Empty();
    m_cstrModuleDescr.Empty();
    m_cstrModuleVersion.Empty();
    m_cstrModuleCopyright.Empty();

    BSTR bstrTmp=NULL, bstrProperty=NULL, bstrStorageLoc = NULL;
    // no exit module
    if (0 == m_arrExitModules.GetSize())
    {
        hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        _JumpError(hr, Ret, "m_pszprogidExitManage");
    }
    CSASSERT(m_iSelected != -1);

    CSASSERT(m_iSelected <= m_arrExitModules.GetUpperBound());
    if (m_iSelected > m_arrExitModules.GetUpperBound())
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, Ret, "m_iSelected > m_arrExitModules.GetUpperBound()");
    }

    cstrStoragePath = wszREGKEYCONFIGPATH_BS;
    cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += wszREGKEYEXITMODULES;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += m_arrExitModules[m_iSelected].szModuleProgID; //m_pszprogidExitModule;

    bstrStorageLoc = SysAllocString(cstrStoragePath);
    _JumpIfOutOfMemory(hr, Ret, bstrStorageLoc);

    hr = GetExitManageDispatch(
            m_arrExitModules[m_iSelected].szModuleProgID,
            m_arrExitModules[m_iSelected].clsidModule, 
            &di);
    _JumpIfErrorStr(hr, Ret, "GetExitManageDispatch", m_arrExitModules[m_iSelected].szModuleProgID);
    
    fMustRelease = TRUE;

    bstrProperty = SysAllocString(wszCMM_PROP_NAME);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    ////////////////////
    // NAME
    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleName = bstrTmp;
        fGotName = TRUE;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }
    else
    {
        // have a backup name to display: CLSID of interface?
        m_cstrModuleName = m_arrExitModules[m_iSelected].szModuleProgID;
        fGotName = TRUE;

        // bail
        _JumpError(hr, Ret, "ManageModule_GetProperty");
    }

    ////////////////////
    // DESCRIPTION
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_DESCRIPTION);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleDescr = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }

    ////////////////////
    // COPYRIGHT
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_COPYRIGHT);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleCopyright = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }


    ////////////////////
    // FILEVER
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_FILEVER);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleVersion = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }


Ret:
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CONFIGURE), (hr == S_OK) );

    if (!fGotName)
    {
        if (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) == hr)
        {
            m_cstrModuleName.LoadString(IDS_NO_EXIT_MODULE);
        }
        else if (CO_E_CLASSSTRING == hr)
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_EXITMODULE_NOT_REGISTERED);
        }
        else
        {
            WCHAR const *pwsz = myGetErrorMessageText(hr, TRUE);

            m_cstrModuleName = pwsz;
	    if (NULL != pwsz)
	    {
		LocalFree(const_cast<WCHAR *>(pwsz));
	    }
        }
    }

    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrProperty)
        SysFreeString(bstrProperty);

    if (bstrStorageLoc)
        SysFreeString(bstrStorageLoc);


    UpdateData(FALSE);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExitPage message handlers
BOOL CSvrSettingsExitPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    // etc
    HRESULT hr;
    BOOL fCurrentMachine = m_pControlPage->m_pCA->m_pParentMachine->IsLocalMachine();

    if (!m_fLoadedActiveModule)
    {
        m_fLoadedActiveModule = TRUE;

        // load all of the modules
        for (int i=0; ; i++)
        {
            COM_CERTSRV_MODULEDEFN sModule;
            ZeroMemory(&sModule, sizeof(sModule));

            hr = myGetActiveModule(
                m_pControlPage->m_pCA,
                FALSE,
                i,
                &sModule.szModuleProgID,  // CoTaskMem*
                &sModule.clsidModule);
            _PrintIfError(hr, "myGetActiveModule");
            if (hr != S_OK)
                break;

            m_arrExitModules.Add(sModule);
        }

        m_iSelected = 0;    // select 1st element
    }

    InitializeExitLB();

    UpdateSelectedModule();

    UpdateData(FALSE);
    return TRUE;
}

void CSvrSettingsExitPage::OnConfigureModule()
{
    DWORD dw;
    DISPATCHINTERFACE di;
    BOOL fMustRelease = FALSE;
    BSTR bstrStorageLoc = NULL;
    BSTR bstrVal = NULL;

    CSASSERT(m_iSelected <= m_arrExitModules.GetUpperBound());
    if (m_iSelected > m_arrExitModules.GetUpperBound())
    {
        dw = E_UNEXPECTED;
        _JumpError(dw, Ret, "m_iSelected > m_arrExitModules.GetUpperBound()");
    }

    if (NULL == m_arrExitModules[m_iSelected].szModuleProgID)
    {
        dw = ERROR_MOD_NOT_FOUND;
        _JumpError(dw, Ret, "m_pszprogidExitManage");
    }

    do {    // not a loop
        dw = GetExitManageDispatch(
                m_arrExitModules[m_iSelected].szModuleProgID,
                m_arrExitModules[m_iSelected].clsidModule, 
                &di);
        _PrintIfErrorStr(dw, "GetExitManageDispatch", m_arrExitModules[m_iSelected].szModuleProgID);
        if (ERROR_SUCCESS != dw)
            break;
        fMustRelease = TRUE;

        LPWSTR szFullStoragePath = NULL;

        CString cstrStoragePath;
        cstrStoragePath = wszREGKEYCONFIGPATH_BS;
        cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += wszREGKEYEXITMODULES;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += m_arrExitModules[m_iSelected].szModuleProgID;//m_pszprogidExitModule;

        bstrStorageLoc = SysAllocString(cstrStoragePath);
        _JumpIfOutOfMemory(dw, Ret, bstrStorageLoc);

        // Callbacks must be initialized whenever ManageModule_Configure is called
        dw = ThunkServerCallbacks(m_pControlPage->m_pCA);
        _JumpIfError(dw, Ret, "ThunkServerCallbacks");

        // pass an hwnd to the exit module -- this is an optional value
        bstrVal = SysAllocStringByteLen(NULL, sizeof(HWND));
        _JumpIfOutOfMemory(dw, Ret, bstrVal);

        *(HWND*)(bstrVal) = m_hWnd;

        dw = ManageModule_SetProperty(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                const_cast<WCHAR*>(wszCMM_PROP_DISPLAY_HWND),
                0,
                PROPTYPE_BINARY,
                bstrVal);
        _PrintIfError(dw, "ManageModule_SetProperty(HWND)");

        dw = ManageModule_Configure(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                0);
        _PrintIfError(dw, "ManageModule_Configure");

    } while(0);

    if (S_OK != dw)
        DisplayGenericCertSrvError(m_hWnd, dw);

Ret:
    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrStorageLoc)
        ::SysFreeString(bstrStorageLoc);

    if (bstrVal)
        ::SysFreeString(bstrVal);
}

void CSvrSettingsExitPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

HRESULT CSvrSettingsExitPage::InitializeExitLB()
{
    HRESULT hr=S_OK;
    SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_RESETCONTENT, 0, 0);

    int i;

    BSTR bstrProperty = SysAllocString(wszCMM_PROP_NAME);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    for (i=0; i< m_arrExitModules.GetSize(); i++)
    {
	LPWSTR pszDisplayString = m_arrExitModules[i].szModuleProgID; // by default, display progid

        BSTR bstrName = NULL;
        DISPATCHINTERFACE di;

        // attempt to create object (locally)
        hr = GetExitManageDispatch(
                m_arrExitModules[i].szModuleProgID,
                m_arrExitModules[i].clsidModule, 
                &di);
        _PrintIfErrorStr(hr, "GetExitManageDispatch", m_arrExitModules[i].szModuleProgID);

        if (hr == S_OK)
        {
            // get name property
            hr = ManageModule_GetProperty(&di, m_pControlPage->m_pCA->m_bstrConfig, L"", bstrProperty, 0, PROPTYPE_STRING, &bstrName);
            _PrintIfError(hr, "ManageModule_GetProperty");

            // output successful display string
            if (hr == S_OK && bstrName != NULL)
            {
                myRegisterMemAlloc(bstrName, -1, CSM_SYSALLOC);
                pszDisplayString = bstrName;
            }

            ManageModule_Release(&di);
        }

        SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_ADDSTRING, 0, (LPARAM)pszDisplayString);
        if (bstrName)
            SysFreeString(bstrName);
    }

Ret:

    if (m_iSelected >= 0)
        SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_SETCURSEL, m_iSelected, 0);


    if (bstrProperty)
        SysFreeString(bstrProperty);

    return hr;
}

void CSvrSettingsExitPage::OnAddActiveModule()
{
    DWORD dwErr;
    COM_CERTSRV_MODULEDEFN sModule;
    ZeroMemory(&sModule, sizeof(sModule));

    // get currently active module
    PRIVATE_DLGPROC_MODULESELECT_LPARAM    sParam;
    ZeroMemory(&sParam, sizeof(sParam));

    sParam.fIsPolicyModuleSelection = FALSE;
    sParam.pCA = m_pControlPage->m_pCA;

    // don't support hilighting the active modules (there may be multiple)
    sParam.ppszProgIDModule = &sModule.szModuleProgID;
    sParam.pclsidModule = &sModule.clsidModule;

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_MODULE),
            m_hWnd,
            dlgProcChooseModule,
            (LPARAM)&sParam);

    // translate ok/cancel into error codes
    if (IDOK == dwErr)
    {
        // add to array...IFF not duplicate
        for (int i=0; i<m_arrExitModules.GetSize(); i++)
        {
            if (0 == memcmp(&sModule.clsidModule, &m_arrExitModules[i].clsidModule, sizeof(CLSID)) )
                break;
        }
        if (m_arrExitModules.GetSize() == i)
        {
            m_iSelected = m_arrExitModules.Add(sModule);

            OnInitDialog();
            SetModified(TRUE);
            m_bUpdate = TRUE;
            m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_EXIT);
        }
    }

    if ((dwErr != IDOK) && (dwErr != IDCANCEL))
    {
        _PrintIfError(dwErr, "dlgProcChooseModule");
        DisplayGenericCertSrvError(m_hWnd, dwErr);
    }

    return;
}

void CSvrSettingsExitPage::OnRemoveActiveModule()
{
    if (m_iSelected != -1)
    {
        ClearModuleDefn(&m_arrExitModules[m_iSelected]);
        m_arrExitModules.RemoveAt(m_iSelected);

        m_iSelected--;  // will either go to previous in list or -1 (NONE)
        if ((m_iSelected == -1) && (m_arrExitModules.GetSize() != 0))   // if NONE and there are still modules
            m_iSelected = 0;    // select the first one

        OnInitDialog();
        SetModified(TRUE);
        m_bUpdate = TRUE;
        m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_EXIT);
    }

    return;
}

BOOL CSvrSettingsExitPage::OnApply()
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sab;
    SAFEARRAY* psa = NULL; // no cleanup, will be deleted by ~variant_t
    BSTR bstr = NULL;
    variant_t var;
    LONG i;

    if (m_bUpdate)
    {

        sab.cElements = m_arrExitModules.GetSize();
        sab.lLbound = 0;

        psa = SafeArrayCreate(
                            VT_BSTR,
                            1,
                            &sab);
        if(!psa)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "SafeArrayCreate");
        }

        for (i=0; i<m_arrExitModules.GetSize(); i++)
        {
            if(!ConvertWszToBstr(
                    &bstr,
                    m_arrExitModules[i].szModuleProgID,
                    -1))
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "ConvertWszToBstr");
            }

            hr = SafeArrayPutElement(psa, (LONG*)&i, bstr);
            _JumpIfError(hr, error, "SafeArrayPutElement");

            SysFreeString(bstr);
            bstr = NULL;
        }

       V_VT(&var) = VT_ARRAY|VT_BSTR;
       V_ARRAY(&var) = psa;
       psa = NULL;

        // NOTE: could be NULL (no exit module)
        hr = m_pControlPage->m_pCA->SetConfigEntry(
            wszREGKEYEXITMODULES,
            wszREGACTIVE,
            &var);
        _PrintIfError(hr, "SetConfigEntry");

        m_bUpdate = FALSE;

        m_pControlPage->TryServiceRestart(SERVERSETTINGS_PROPPAGE_EXIT);

        OnInitDialog();
    }

error:
    if(psa)
        SafeArrayDestroy(psa);
    if(bstr)
        SysFreeString(bstr);

    if(S_OK!=hr)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}


////
// 4
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExtensionPage property page

HRESULT
AddURLNode(
    IN CSURLTEMPLATENODE **ppURLList,
    IN CSURLTEMPLATENODE *pURLNode)
{
    HRESULT  hr = S_OK;
    CSASSERT(NULL != ppURLList);
    CSASSERT(NULL == pURLNode->pNext);

    if (NULL == *ppURLList)
    {
        //empty list currently
        *ppURLList = pURLNode;
    }
    else
    {
        CSURLTEMPLATENODE *pURLList = *ppURLList;
        //find the end
        while (NULL != pURLList->pNext)
        {
            pURLList = pURLList->pNext;
        }
        //add to the end
        pURLList->pNext = pURLNode;
    }

    return hr;
}

ENUM_URL_TYPE rgAllPOSSIBLE_URL_PREFIXES[] =
{
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
};

HRESULT
BuildURLListFromStrings(
    IN VARIANT &varURLs,
    OUT CSURLTEMPLATENODE **ppURLList)
{
    HRESULT  hr;
    CSURLTEMPLATENODE *pURLList = NULL;
    CSURLTEMPLATENODE *pURLNode = NULL;
    WCHAR *pwsz; // no free
    WCHAR const *pwszURL;
    DWORD  dwFlags;
    ENUM_URL_TYPE  UrlType;
    LONG lUbound, lLbound, lCount;

    CSASSERT(V_VT(&varURLs)==(VT_ARRAY|VT_BSTR));
    CSASSERT(NULL != ppURLList);

    // init
    *ppURLList = NULL;

    SafeArrayEnum<BSTR> saenum(V_ARRAY(&varURLs));

    while(S_OK==saenum.Next(pwsz))
    {
        dwFlags = _wtoi(pwsz);
        pwszURL = pwsz;
        while (pwszURL && iswdigit(*pwszURL))
        {
            pwszURL++;
        }
        if (pwszURL > pwsz && L':' == *pwszURL)
        {
            // ok, one url, create a new node
            pURLNode = (CSURLTEMPLATENODE*)LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(CSURLTEMPLATENODE));
            if (NULL == pURLNode)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
            // skip :
            ++pwszURL;

            // translate %1 -> <CAName> etc.
            hr = ExpandDisplayString(pwszURL, &pURLNode->URLTemplate.pwszURL);
            _JumpIfError(hr, error, "ExpandDisplayString");

/*
            pURLNode->URLTemplate.pwszURL = (WCHAR*)LocalAlloc(
                                LMEM_FIXED,
                                (wcslen(pwszURL) + 1) * sizeof(WCHAR));
            if (NULL == pURLNode->URLTemplate.pwszURL)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
            wcscpy(pURLNode->URLTemplate.pwszURL, pwszURL);
*/
            pURLNode->URLTemplate.Flags = dwFlags;

            //determine url type and assign enable mask
            UrlType = DetermineURLType(
                        rgAllPOSSIBLE_URL_PREFIXES,
                        ARRAYSIZE(rgAllPOSSIBLE_URL_PREFIXES),
                        pURLNode->URLTemplate.pwszURL);
            pURLNode->EnableMask = DetermineURLEnableMask(UrlType);

            hr = AddURLNode(&pURLList, pURLNode);
            _JumpIfError(hr , error, "AddURLNode");
        }
    }

    //out
    *ppURLList = pURLList;

    hr = S_OK;
error:
    return hr;
}

HRESULT
BuildURLStringFromList(
    IN CSURLTEMPLATENODE *pURLList,
    OUT VARIANT          *pvarURLs)
{
    HRESULT hr = S_OK;
    WCHAR wszFlags[10];
    LPWSTR pwszURL = NULL;
    CSURLTEMPLATENODE *pURLNode = pURLList;
    DWORD dwMaxSize = 0;
    DWORD cURLs = 0;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY * psa = NULL;
    long i;

    CSASSERT(NULL != pvarURLs);
    // init

    VariantInit(pvarURLs);

    while (NULL != pURLNode)
    {
        DWORD dwSize;
        wsprintf(wszFlags, L"%d", pURLNode->URLTemplate.Flags);
        dwSize = wcslen(wszFlags) +1;

        // ASSUMPTION
        // %1..%14 will always be = or smaller than shortest <CAName> token
        dwSize += wcslen(pURLNode->URLTemplate.pwszURL) +1;

        // otherwise, run code below
/*
        pszThrowAway = NULL;
        hr = ContractDisplayString(pURLNode->URLTemplate.pwszURL, &pszSizeComputation);
        _JumpIfError(hr, error, "ContractDisplayString");

        dwSize += wcslen(pszSizeComputation) + 1;
        if (NULL != pszSizeComputation)
            LocalFree(pszSizeComputation);
*/
        if(dwSize>dwMaxSize)
            dwMaxSize = dwSize;
        pURLNode = pURLNode->pNext;
        cURLs++;
    }

    pwszURL = (WCHAR*)LocalAlloc(LMEM_FIXED, dwMaxSize * sizeof(WCHAR));
    if (NULL == pwszURL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cURLs;

    psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    if(!psa)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "SafeArrayCreate");
    }

    pURLNode = pURLList;
    i=0;
    while (NULL != pURLNode)
    {
        variant_t vtURL;

        //  translate <CAName> ... to %1
        LPWSTR szContracted = NULL;
        hr = ContractDisplayString(pURLNode->URLTemplate.pwszURL, &szContracted);
        _JumpIfError(hr, error, "ContractDisplayString");

        ASSERT(wcslen(szContracted) <= wcslen(pURLNode->URLTemplate.pwszURL)); // otherwise our assumption above doesn't hold

        wsprintf(pwszURL, L"%d:%s",
            pURLNode->URLTemplate.Flags,
            szContracted);

        // free the tmp
        if (NULL != szContracted)
            LocalFree(szContracted);

        vtURL = pwszURL;

        hr = SafeArrayPutElement(psa, &i, V_BSTR(&vtURL));
        _JumpIfError(hr, error, "LocalAlloc");

        pURLNode = pURLNode->pNext;
        i++;
    }

    V_VT(pvarURLs) = VT_ARRAY|VT_BSTR;
    V_ARRAY(pvarURLs) = psa;

//done:
    hr = S_OK;
error:

    if(S_OK!=hr && psa)
    {
        SafeArrayDestroy(psa);
    }
    LOCAL_FREE(pwszURL);
    return hr;
}

void
FreeURLNode(
    IN CSURLTEMPLATENODE *pURLNode)
{
    CSASSERT(NULL != pURLNode);

    if (NULL != pURLNode->URLTemplate.pwszURL)
    {
        LocalFree(pURLNode->URLTemplate.pwszURL);
    }
}

void
FreeURLList(
    IN CSURLTEMPLATENODE *pURLList)
{
    CSASSERT(NULL != pURLList);

    // assume pURLList is always the 1st node
    CSURLTEMPLATENODE *pURLNode = pURLList;

    while (NULL != pURLNode)
    {
        FreeURLNode(pURLNode);
        pURLNode = pURLNode->pNext;
    }

    LocalFree(pURLList);
}

HRESULT
RemoveURLNode(
    IN OUT CSURLTEMPLATENODE **ppURLList,
    IN CSURLTEMPLATENODE *pURLNode)
{
    HRESULT hr;
    // assume pURLList is always the 1st node
    CSURLTEMPLATENODE *pURLList = *ppURLList;
    BOOL fFound = FALSE;

    if (pURLList == pURLNode)
    {
        //happen want to remove 1st one
        //update the list head
        *ppURLList = pURLList->pNext;
        fFound = TRUE;
    }
    else
    {
        while (pURLList->pNext != NULL)
        {
            if (pURLList->pNext == pURLNode)
            {
                // found it
                fFound = TRUE;
                if (NULL == pURLNode->pNext)
                {
                    // happen removed node is the last
                    // fix the end
                    pURLList->pNext = NULL;
                }
                else
                {
                    // remove the node
                    pURLList->pNext = pURLList->pNext->pNext;
                }
                // out of while loop
                break;
            }
            // go next
            pURLList = pURLList->pNext;
        }
    }

    if (!fFound)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "orphan node");
    }
    // remove the node
    FreeURLNode(pURLNode);

    hr = S_OK;
error:
    return hr;
}

BOOL
IsURLInURLList(
    IN CSURLTEMPLATENODE *pURLList,
    IN WCHAR const *pwszURL)
{
    BOOL fRet = FALSE;

    // assume pURLList is always the 1st node

    while (NULL != pURLList)
    {
        if (0 == lstrcmpi(pwszURL, pURLList->URLTemplate.pwszURL))
        {
            fRet = TRUE;
            break;
        }
        pURLList = pURLList->pNext;
    }

    return fRet;
}

EXTENSIONWIZ_DATA g_ExtensionList[] =
{
    {IDS_EXT_CDP,
     IDS_EXT_CDP_EXPLAIN,
     wszREGCRLPUBLICATIONURLS,
     CSURL_SERVERPUBLISH |
         CSURL_ADDTOCERTCDP |
         CSURL_ADDTOFRESHESTCRL |
         CSURL_ADDTOCRLCDP,
     NULL},
    {IDS_EXT_AIA,
     IDS_EXT_AIA_EXPLAIN,
     wszREGCACERTPUBLICATIONURLS,
     CSURL_ADDTOCERTCDP |
     CSURL_ADDTOCERTOCSP,
     NULL},
    {0, 0, NULL, 0x0, NULL},
};

CSvrSettingsExtensionPage::CSvrSettingsExtensionPage(
    CertSvrCA               *pCertCA,
    CSvrSettingsGeneralPage *pControlPage,
    UINT                     uIDD)
    : m_pCA(pCertCA), CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    m_bUpdate = FALSE;
    m_pExtData = g_ExtensionList;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE4);
}

CSvrSettingsExtensionPage::~CSvrSettingsExtensionPage()
{
    EXTENSIONWIZ_DATA *pExt = m_pExtData;

    while (NULL != pExt->wszRegName)
    {
        if (NULL != pExt->pURLList)
        {
            FreeURLList(pExt->pURLList);
            pExt->pURLList = NULL;
        }
        ++pExt;
    }
}

// get current extension pointer
EXTENSIONWIZ_DATA* CSvrSettingsExtensionPage::GetCurrentExtension()
{
    HWND hwndCtrl;
    LRESULT nIndex;
    EXTENSIONWIZ_DATA *pExt;

    // get extension data
    hwndCtrl = GetDlgItem(m_hWnd, IDC_EXT_SELECT);
    nIndex = SendMessage(hwndCtrl, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    CSASSERT(CB_ERR != nIndex);
    pExt = (EXTENSIONWIZ_DATA*)SendMessage(
                                   hwndCtrl,
                                   CB_GETITEMDATA,
                                   (WPARAM)nIndex,
                                   (LPARAM)0);
    CSASSERT(NULL != pExt);
    return pExt;
}

// get current url pointer
CSURLTEMPLATENODE* CSvrSettingsExtensionPage::GetCurrentURL(
    OUT OPTIONAL LRESULT *pnIndex)
{
    HWND hwndCtrl;
    LRESULT nIndex;
    CSURLTEMPLATENODE *pURLNode;

    //get current url
    hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
    //get current url selection
    nIndex = SendMessage(hwndCtrl, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    CSASSERT(LB_ERR != nIndex);
    // get url data
    pURLNode = (CSURLTEMPLATENODE*)SendMessage(hwndCtrl,
                   LB_GETITEMDATA,
                   (WPARAM)nIndex,
                   (LPARAM)0);
    CSASSERT(NULL != pURLNode);

    if (NULL != pnIndex)
    {
        *pnIndex = nIndex;
    }
    return pURLNode;
}

void CSvrSettingsExtensionPage::UpdateURLFlagControl(
    IN int                idCtrl,
    IN DWORD              dwFlag,
    IN OPTIONAL EXTENSIONWIZ_DATA *pExt,
    IN OPTIONAL CSURLTEMPLATENODE *pURLNode)
{
    HWND hwndCtrl = GetDlgItem(m_hWnd, idCtrl);

    // check extension type, hide/show accordingly
    if (NULL == pExt || 0x0 == (dwFlag & pExt->dwFlagsMask) || NULL == pURLNode)
    {
        //no URLs link to the extension or
        //the flag not making sense for the extension, disable it
        ShowWindow(hwndCtrl, SW_HIDE);
        SendMessage(hwndCtrl, BM_SETCHECK, (WPARAM)BST_UNCHECKED, (LPARAM)0);
    }
    else
    {
        //show the control first
        ShowWindow(hwndCtrl, SW_SHOW);

        if (0x0 == (dwFlag & pURLNode->EnableMask))
        {
            //this url type is not allowed, disbale it and unset it
            SendMessage(hwndCtrl, BM_SETCHECK, BST_UNCHECKED, (LPARAM)0);
            EnableWindow(hwndCtrl, FALSE);
        }
        else
        {
            //enable it
            EnableWindow(hwndCtrl, TRUE);

            WPARAM fCheck = (0x0 != (dwFlag & pURLNode->URLTemplate.Flags)) ?
                            BST_CHECKED : BST_UNCHECKED;
            SendMessage(hwndCtrl, BM_SETCHECK, fCheck, (LPARAM)0);
        }
    }
}

//update check controls from the flag
void
CSvrSettingsExtensionPage::UpdateURLFlags(
    IN EXTENSIONWIZ_DATA *pExt,
    IN OPTIONAL CSURLTEMPLATENODE *pURLNode)
{
    if (NULL != pExt && NULL == pURLNode)
    {
        // use 1st one
        pURLNode = pExt->pURLList;
    }

    UpdateURLFlagControl(IDC_SERVERPUBLISH,
                         CSURL_SERVERPUBLISH,
                         pExt,
                         pURLNode);
    UpdateURLFlagControl(IDC_ADDTOCERTCDP,
                         CSURL_ADDTOCERTCDP,
                         pExt,
                         pURLNode);
    UpdateURLFlagControl(IDC_ADDTOFRESHESTCRL,
                         CSURL_ADDTOFRESHESTCRL,
                         pExt,
                         pURLNode);
    UpdateURLFlagControl(IDC_ADDTOCRLCDP,
                         CSURL_ADDTOCRLCDP,
                         pExt,
                         pURLNode);

    UpdateURLFlagControl(IDC_ADDTOCERTOCSP,
                         CSURL_ADDTOCERTOCSP,
                         pExt,
                         pURLNode);
}

//handle url selection change
void CSvrSettingsExtensionPage::OnURLChange()
{
    // update check controls
    UpdateURLFlags(GetCurrentExtension(), GetCurrentURL(NULL));
}

void AdjustListHScrollWidth(HWND hwndList)
{
    HDC  hdc = GetDC(hwndList);
    int  cItem;
    int  maxWidth = 0;
    int  i;
    SIZE sz;

    WCHAR  *pwszString = NULL;
    if (LB_ERR == (cItem = (int)SendMessage(hwndList, LB_GETCOUNT, (WPARAM)0, (LPARAM)0)))
        goto error;

    //loop through all strings in list and find the largest length
    for (i = 0; i < cItem; i++)
    {
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
            pwszString = NULL;
        }

        //get string length
        int len = (int)SendMessage(hwndList, LB_GETTEXTLEN, (WPARAM)i, (LPARAM)0);
        if (LB_ERR == len)
        {
            //ignore error, skip to next
            continue;
        }
        pwszString = (WCHAR*)LocalAlloc(LMEM_FIXED, (len+1) * sizeof(WCHAR));
        if (NULL == pwszString)
        {
            _JumpError(E_OUTOFMEMORY, error, "Out of memory");
        }
        //get string text
        if (LB_ERR == SendMessage(hwndList, LB_GETTEXT, (WPARAM)i, (LPARAM)pwszString))
        {
            //skip error
            continue;
        }
        //calculate string width
        if (!GetTextExtentPoint32(hdc, pwszString, len, &sz))
        {
            //skip error
            continue;
        }
        if (sz.cx > maxWidth)
        {
            maxWidth = sz.cx;
        }
    }

    if (0 < maxWidth)
    {
        // now set horizontal scroll width
        SendMessage(hwndList,
                    LB_SETHORIZONTALEXTENT,
                    (WPARAM)maxWidth,
                    (LPARAM)0);
    }

error:
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
            pwszString = NULL;
        }

}

// handle extension selection change in the combo box
void CSvrSettingsExtensionPage::OnExtensionChange()
{
    EXTENSIONWIZ_DATA *pExt;
    LRESULT nIndex;
    LRESULT nIndex0=0;
    CString strExplain;
    HWND    hwndCtrl;
    CSURLTEMPLATENODE *pURLNode;
    BOOL fEnable = TRUE;

    // get extension data
    pExt = GetCurrentExtension();

    // update extension explaination
    strExplain.LoadString(pExt->idExtensionExplain);
    SetWindowText(GetDlgItem(m_hWnd, IDC_EXT_EXPLAIN), strExplain);

    // remove the current URLs in the list
    hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
    while (0 < SendMessage(hwndCtrl, LB_GETCOUNT, (WPARAM)0, (LPARAM)0))
    {
        SendMessage(hwndCtrl, LB_DELETESTRING, (WPARAM)0, (LPARAM)0);
    }

    // list URLs of the current extension
    pURLNode = pExt->pURLList;
    while (NULL != pURLNode)
    {
        nIndex = SendMessage(hwndCtrl,
                    LB_ADDSTRING,
                    (WPARAM)0,
                    (LPARAM)pURLNode->URLTemplate.pwszURL);
        CSASSERT(CB_ERR != nIndex);
        if (pURLNode == pExt->pURLList)
        {
            //remember the 1st
            nIndex0 = nIndex;
        }
        //set list item data
        SendMessage(hwndCtrl, LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pURLNode);
        pURLNode = pURLNode->pNext;
    }

    //adjust horizontal scroll width
    AdjustListHScrollWidth(hwndCtrl);

    if (NULL != pExt->pURLList)
    {
        // select the first one
        SendMessage(hwndCtrl, LB_SETCURSEL, (WPARAM)nIndex0, (LPARAM)0);
    }
    else
    {
        //empty url list
        fEnable = FALSE;
    }
    EnableWindow(GetDlgItem(m_hWnd, IDC_URL_REMOVE), fEnable);
    UpdateURLFlags(pExt, NULL);
}

// handle check control change
void CSvrSettingsExtensionPage::OnFlagChange(DWORD dwFlag)
{
    //get current url
    CSURLTEMPLATENODE *pURLNode = GetCurrentURL(NULL);

    // update flag
    if (0x0 != (pURLNode->URLTemplate.Flags & dwFlag))
    {
        // means the current bit is on, trun it off
        pURLNode->URLTemplate.Flags &= ~dwFlag;
    }
    else
    {
        // means the current bit is off, trun it on
        pURLNode->URLTemplate.Flags |= dwFlag;
    }

    m_bUpdate = TRUE;
    SetModified(m_bUpdate);
}

// handle remove url
BOOL CSvrSettingsExtensionPage::OnURLRemove()
{
    LRESULT nIndex;
    LRESULT nCount = 0;
    HRESULT hr;
    HWND hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);

    // get extension data
    EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
    //get current url
    CSURLTEMPLATENODE *pURLNode = GetCurrentURL(&nIndex);

    // confirm this action
    CString cstrMsg, cstrTitle;
    cstrMsg.LoadString(IDS_CONFIRM_REMOVE_URL);
    cstrTitle.LoadString(IDS_CONFIRM_REMOVE_TITLE);
    if (IDYES != MessageBox(m_hWnd, cstrMsg, cstrTitle, MB_YESNO))
        goto bailout;

    // remove it from the list
    hr = RemoveURLNode(&pExt->pURLList, pURLNode);
    if (S_OK == hr)
    {
        // ok, remove it from UI
        nCount = SendMessage(hwndCtrl,
                    LB_DELETESTRING,
                    (WPARAM)nIndex,
                    (LPARAM)0);
        m_bUpdate = TRUE;
        SetModified(m_bUpdate);
        // select a previous one, if 1st one, still 1st one
        if (0 < nIndex)
        {
            --nIndex;
        }
        if (0 < nCount)
        {
            SendMessage(hwndCtrl, LB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
            pURLNode = GetCurrentURL(&nIndex);
            UpdateURLFlags(pExt, pURLNode);
        }
    }
    else
    {
        _PrintError(hr, "RemoveURLNode");
        return FALSE;
    }

    if (0 >= nCount)
    {
        //now is empty list, disable remove button
        EnableWindow(GetDlgItem(m_hWnd, IDC_URL_REMOVE), FALSE);
        //disable all check controls
        UpdateURLFlags(NULL, NULL);
    }

bailout:
    return TRUE;
}

INT_PTR CALLBACK dlgAddURL(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam)
{
    HRESULT hr;
    BOOL fReturn = FALSE;

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            ::SetWindowLong(
                hwnd,
                GWL_EXSTYLE,
                ::GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // stash the ADDURL_DIALOGARGS pointer
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lParam);

            // dump knowledge of tokens into dropdown, item data is description
            HWND hCombo = GetDlgItem(hwnd, IDC_COMBO_VARIABLE);
            for (int i=0; i<DISPLAYSTRINGS_TOKEN_COUNT; i++)
            {
                // skip invalid tokens
                if (0 == wcscmp(L"", g_displayStrings[i].szContractedToken))
                    continue;

                INT nItemIndex = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) (LPCWSTR) (*g_displayStrings[i].pcstrExpansionString));
                if (CB_ERR == nItemIndex)
                    continue;
                SendMessage(hCombo, CB_SETITEMDATA, (WPARAM)nItemIndex, (LPARAM) (LPCWSTR) (*g_displayStrings[i].pcstrExpansionStringDescr));
            }

            // set start value
            SendMessage(hCombo, CB_SETCURSEL, 0, 0);
            SetDlgItemText(hwnd, IDC_EDIT_VARIABLEDESCRIPTION, (LPCWSTR) (*g_displayStrings[0].pcstrExpansionStringDescr));

            break;
        }
        case WM_HELP:
        {
            OnDialogHelp((LPHELPINFO)lParam,
                         CERTMMC_HELPFILENAME,
                         g_aHelpIDs_IDD_ADDURL);
            break;
        }
        case WM_CONTEXTMENU:
        {
            OnDialogContextHelp((HWND)wParam,
                         CERTMMC_HELPFILENAME,
                         g_aHelpIDs_IDD_ADDURL);
            break;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_COMBO_VARIABLE:
                {
                    if (HIWORD(wParam) == LBN_SELCHANGE)
                    {
                        // On selection change, ask for the selection idx
                        int nItemIndex = (INT)SendMessage((HWND)lParam,
                            CB_GETCURSEL,
                            0,
                            0);

                        LPCWSTR sz;
                        sz = (LPCWSTR) SendMessage(
                                (HWND)lParam,
                                CB_GETITEMDATA,
                                (WPARAM)nItemIndex,
                                0);
                        if (CB_ERR == (DWORD_PTR)sz)
                            break;  // get out of here

                            // otherwise, we just got descr... set it!
                            SetDlgItemText(hwnd, IDC_EDIT_VARIABLEDESCRIPTION, sz);
                        }
                }
                break;
                case IDC_BUTTON_INSERTVAR:
                {
                    WCHAR sz[64]; // ASSUME: no token is > 64 char
                    if (0 != GetDlgItemText(hwnd, IDC_COMBO_VARIABLE, sz, ARRAYLEN(sz)))
                    {
                        // insert <token> at cursor
                        SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_REPLACESEL, TRUE, (LPARAM)sz);
                    }
                }
                break;

                case IDOK:
                {
                    // snatch the ADDURL_DIALOGARGS* we were given
                    ADDURL_DIALOGARGS* pArgs = (ADDURL_DIALOGARGS*)
                                GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    if (pArgs == NULL)
                    {
                        hr = E_UNEXPECTED;
                        _PrintError(hr, "unexpected null data");
                        break;
                    }

                    hr = myUIGetWindowText(GetDlgItem(hwnd, IDC_EDITURL),
                                           pArgs->ppszNewURL);
                    if (S_OK != hr)
                    {
                        _PrintError(hr, "myUIGetWindowText");
                        break;
                    }

                    if (NULL == *pArgs->ppszNewURL)
                    {
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_EMPTY_URL,
                                0,
                                NULL);
                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        SetFocus(hwndCtrl);
                        break;
                    }

                    if (URL_TYPE_UNKNOWN == DetermineURLType(
                                                pArgs->rgAllowedURLs,
                                                pArgs->cAllowedURLs,
                                                *pArgs->ppszNewURL))
                    {
                        // not found; bail with message
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_INVALID_PREFIX,
                                0,
                                NULL);
                        SetFocus(GetDlgItem(hwnd, IDC_EDITURL));
                        break;
                    }

                    DWORD chBadBegin, chBadEnd;
                    if (S_OK != ValidateTokens(
                            *pArgs->ppszNewURL,
                            &chBadBegin,
                            &chBadEnd))
                    {
                        // not found; bail with message
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_INVALID_TOKEN,
                                0,
                                NULL);
                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        // set selection starting from where validation failed
                        SetFocus(hwndCtrl);
                        SendMessage(hwndCtrl, EM_SETSEL, chBadBegin, chBadEnd);
                        break;
                    }

                    if (IsURLInURLList(pArgs->pURLList, *pArgs->ppszNewURL))
                    {
                        CString cstrMsg, cstrTemplate;
                        cstrTemplate.LoadString(IDS_SAME_URL_EXIST);
                        cstrMsg.Format(cstrTemplate, *pArgs->ppszNewURL);

                        if (IDYES != MessageBox(hwnd, cstrMsg, (LPCWSTR)g_cResources.m_DescrStr_CA, MB_YESNO))
                        { 
                            HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                            // set selection starting from where validation failed 
                            SetFocus(hwndCtrl);
                            SendMessage(hwndCtrl, EM_SETSEL, 0, -1);
                            break;
                        }

// mattt, 1/15/01
// we want to warn but allow multiples so people can work around
// not being able to sort entries -- now they can create
// multiples of the same place but place them differently in the list
/*
                        // the same url is defined already
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_SAME_URL_EXIST,
                                0,
                                *pArgs->ppszNewURL);

                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        // set selection starting from where validation failed
                        SetFocus(hwndCtrl);
                        SendMessage(hwndCtrl, EM_SETSEL, 0, -1);
                        break;
*/
                    }

                    PBYTE pb=NULL;
                    DWORD cb;
                    // attempt IA5 encoding
                    if (S_OK != myEncodeExtension(
                         PROPTYPE_STRING,
                         (PBYTE)*pArgs->ppszNewURL,
                         (wcslen(*pArgs->ppszNewURL)+1)*sizeof(WCHAR),
                         &pb,
                         &cb))
                    {
                        // encoding error; bail with message
                        WCHAR szMsg[MAX_PATH*2];
                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        LoadString(g_hInstance, IDS_INVALID_ENCODING, szMsg, ARRAYLEN(szMsg));
                        MessageBox(hwnd, szMsg, NULL, MB_OK);

                        // set selection starting from where validation failed
                        SetFocus(hwndCtrl);
                        SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_SETSEL,  -1, -1);
                        break;
                    }
                    if (pb)
                    {
                        LocalFree(pb);
                    }

                }
                // fall through for cleanup
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    fReturn = TRUE;
                break;
                default:
                break;
            }
        default:
        break;  //WM_COMMAND
    }
    return fReturn;
}

ENUM_URL_TYPE rgPOSSIBLE_CRL_URLs[] =
{
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
};

ENUM_URL_TYPE rgPOSSIBLE_AIA_URLs[] =
{
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
};

// handle add url
BOOL CSvrSettingsExtensionPage::OnURLAdd()
{
    HRESULT hr;
    WCHAR *pwszURL = NULL;
    CSURLTEMPLATENODE *pURLNode;
    HWND  hwndCtrl;
    LRESULT nIndex;
    // get current extension
    EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
    BOOL fCDP = (IDS_EXT_CDP == pExt->idExtensionName) ? TRUE : FALSE;

    ADDURL_DIALOGARGS dlgArgs = {
        fCDP ? rgPOSSIBLE_CRL_URLs : rgPOSSIBLE_AIA_URLs,
        (DWORD)(fCDP ? ARRAYLEN(rgPOSSIBLE_CRL_URLs) : ARRAYLEN(rgPOSSIBLE_AIA_URLs)),
        &pwszURL,
        pExt->pURLList};

    if (IDOK != DialogBoxParam(
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_ADDURL),
                    m_hWnd,
                    dlgAddURL,
                    (LPARAM)&dlgArgs))
    {
        //cancel
        return TRUE;
    }

    if (NULL != pwszURL && L'\0' != *pwszURL)
    {
        // a new url, add into the list
        pURLNode = (CSURLTEMPLATENODE*)LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(CSURLTEMPLATENODE));
        if (NULL == pURLNode)
        {
            hr = E_OUTOFMEMORY;
            _PrintError(hr, "LocalAlloc");
            return FALSE;
        }
        pURLNode->URLTemplate.pwszURL = pwszURL;
        pURLNode->EnableMask = DetermineURLEnableMask(
                    DetermineURLType(
                        rgAllPOSSIBLE_URL_PREFIXES,
                        ARRAYSIZE(rgAllPOSSIBLE_URL_PREFIXES),
                        pURLNode->URLTemplate.pwszURL));
        //add to the data structure
        hr = AddURLNode(&pExt->pURLList, pURLNode);
        if (S_OK != hr)
        {
            _PrintError(hr, "AddURLNode");
            return FALSE;
        }
        hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
        nIndex = SendMessage(hwndCtrl,
                             LB_ADDSTRING,
                             (WPARAM)0,
                             (LPARAM)pURLNode->URLTemplate.pwszURL);
        CSASSERT(LB_ERR != nIndex);
        //set item data
        SendMessage(hwndCtrl, LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pURLNode);
        //set it as current selection
        SendMessage(hwndCtrl, LB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
        //update flag controls
        UpdateURLFlags(pExt, pURLNode);
        m_bUpdate = TRUE;
        SetModified(m_bUpdate);
        //alway enable remove button
        EnableWindow(GetDlgItem(m_hWnd, IDC_URL_REMOVE), TRUE);

        //adjust list control width accordingly
        AdjustListHScrollWidth(hwndCtrl);
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsExtensionPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
        case IDC_EXT_SELECT:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                    // extension selection is changed
                    OnExtensionChange();
                break;
            }
        break;
        case IDC_URL_LIST:
            switch (HIWORD(wParam))
            {
                case LBN_SELCHANGE:
                    // url selection is changed
                    OnURLChange();
                break;
            }
        break;
        case IDC_URL_ADD:
            return OnURLAdd();
        break;
        case IDC_URL_REMOVE:
            OnURLRemove();
        break;
        case IDC_SERVERPUBLISH:
            OnFlagChange(CSURL_SERVERPUBLISH);
        break;
        case IDC_ADDTOCERTCDP:
            OnFlagChange(CSURL_ADDTOCERTCDP);
        break;
        case IDC_ADDTOFRESHESTCRL:
            OnFlagChange(CSURL_ADDTOFRESHESTCRL);
        break;
        case IDC_ADDTOCRLCDP:
            OnFlagChange(CSURL_ADDTOCRLCDP);
        break;
        case IDC_ADDTOCERTOCSP:
            OnFlagChange(CSURL_ADDTOCERTOCSP);
        break;
        default:
        return FALSE;
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExtensionPage message handlers
BOOL CSvrSettingsExtensionPage::OnInitDialog()
{
    CSASSERT(NULL != m_pExtData);

    EXTENSIONWIZ_DATA *pExt = m_pExtData;
    DWORD              dwRet;
    HWND               hwndCtrl;
    CString            strName;
    LRESULT            nIndex;
    LRESULT            nIndex0 = 0;
    HRESULT            hr;
    VARIANT            var;

    // does parent init
    CAutoDeletePropPage::OnInitDialog();

    //go through each extension and init data from reg
    while (NULL != pExt->wszRegName)
    {
        dwRet = m_pControlPage->m_pCA->GetConfigEntry(
                    NULL,
                    pExt->wszRegName,
                    &var);
        if(dwRet != S_OK)
            return FALSE;
        CSASSERT(V_VT(&var)==(VT_ARRAY|VT_BSTR));

        hr = BuildURLListFromStrings(var, &pExt->pURLList);
        _PrintIfError(hr, "BuildURLListFromStrings");
        ++pExt;

        VariantClear(&var);
    }

    // add extensions into UI combo list
    pExt = m_pExtData;
    hwndCtrl = GetDlgItem(m_hWnd, IDC_EXT_SELECT);
    while (NULL != pExt->wszRegName)
    {
        // load current extension display name into the list
        strName.LoadString(pExt->idExtensionName);
        nIndex = (INT)SendMessage(hwndCtrl,
                                  CB_ADDSTRING,
                                  (WPARAM)0,
                                  (LPARAM)(LPCWSTR)strName);
        CSASSERT(CB_ERR != nIndex);

        //remember index of the first extension
        if (pExt == m_pExtData)
        {
            nIndex0 = nIndex;
        }
        //link current extension to the item
        nIndex = SendMessage(hwndCtrl,
                                  CB_SETITEMDATA,
                                  (WPARAM)nIndex,
                                  (LPARAM)pExt);
        CSASSERT(CB_ERR != nIndex);
        ++pExt;
    }

    // select the 1st one as default
    nIndex = SendMessage(hwndCtrl,
                         CB_SETCURSEL,
                         (WPARAM)nIndex0,
                         (LPARAM)0);
    CSASSERT(CB_ERR != nIndex);

    OnExtensionChange();
    return TRUE;
}


void CSvrSettingsExtensionPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

BOOL CSvrSettingsExtensionPage::OnApply()
{
    DWORD dwRet = ERROR_SUCCESS;
    EXTENSIONWIZ_DATA *pExt = m_pExtData;
    WCHAR *pwszzURLs;
    DWORD dwSize;
    HRESULT hr;
    variant_t varURLs;

	if (m_bUpdate == TRUE)
    {
        //go through each extension and init data from reg
        while (NULL != pExt->wszRegName)
        {
            pwszzURLs = NULL;
            hr = BuildURLStringFromList(
                        pExt->pURLList,
                        &varURLs);
            if (S_OK != hr)
            {
                _PrintError(hr, "BuildURLStringFromList");
                return FALSE;
            }
            dwRet = m_pControlPage->m_pCA->SetConfigEntry(
                        NULL,
                        pExt->wszRegName,
                        &varURLs);
            if (dwRet != ERROR_SUCCESS)
            {
                DisplayGenericCertSrvError(m_hWnd, dwRet);
                _PrintError(dwRet, "SetConfigEntry");
                return FALSE;
            }
            ++pExt;
            varURLs.Clear();
        }

        //check to see if service is running
        if (m_pCA->m_pParentMachine->IsCertSvrServiceRunning())
        {
            //throw a confirmation
            CString cstrMsg;
            cstrMsg.LoadString(IDS_CONFIRM_SERVICE_RESTART);

            if (IDYES == ::MessageBox(m_hWnd, (LPCWSTR)cstrMsg, (LPCWSTR)g_cResources.m_DescrStr_CA, MB_YESNO | MB_ICONWARNING ))
            {
                //stop first
                hr = m_pCA->m_pParentMachine->CertSvrStartStopService(m_hWnd, FALSE);
                _PrintIfError(hr, "CertSvrStartStopService");
                //should check status?
                //start again
                hr = m_pCA->m_pParentMachine->CertSvrStartStopService(m_hWnd, TRUE);
                _PrintIfError(hr, "CertSvrStartStopService");
            }
        }

        m_bUpdate = FALSE;
    }
	
    return CAutoDeletePropPage::OnApply();
}


////
// 5
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsStoragePage property page
CSvrSettingsStoragePage::CSvrSettingsStoragePage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    m_cstrDatabasePath = _T("");
    m_cstrLogPath = _T("");
    m_cstrSharedFolder = _T("");

    m_bUpdate = FALSE;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE5);
}

CSvrSettingsStoragePage::~CSvrSettingsStoragePage()
{
}

// replacement for DoDataExchange
BOOL CSvrSettingsStoragePage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrDatabasePath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_DATABASE_LOC));
        m_cstrLogPath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOG_LOC));
        m_cstrSharedFolder.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_SHAREDFOLDER));
    }
    else
    {
        m_cstrDatabasePath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DATABASE_LOC));
        m_cstrLogPath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOG_LOC));
        m_cstrSharedFolder.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_SHAREDFOLDER));
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsStoragePage message handlers
BOOL CSvrSettingsStoragePage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    // DS or shared folder?
    BOOL fUsesDS = m_pControlPage->m_pCA->FIsUsingDS();
    ::SendDlgItemMessage(m_hWnd, IDC_CHECK1, BM_SETCHECK, (WPARAM) fUsesDS, 0);

    HRESULT hr = S_OK;
    variant_t var;
    CertSvrMachine *pMachine = m_pControlPage->m_pCA->m_pParentMachine;

    hr = pMachine->GetRootConfigEntry(
                wszREGDIRECTORY,
                &var);
    // shared folder might not be configured, ignore
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
        hr = S_OK;
    _JumpIfError(hr, Ret, "GetRootConfigEntry wszREGDIRECTORY");

    m_cstrSharedFolder = V_BSTR(&var);

    var.Clear();

    hr = pMachine->GetRootConfigEntry(
                wszREGDBDIRECTORY,
                &var);
    _JumpIfError(hr, Ret, "GetRootConfigEntry wszREGDBDIRECTORY");

    m_cstrDatabasePath = V_BSTR(&var);

    var.Clear();

    hr = pMachine->GetRootConfigEntry(
                wszREGDBLOGDIRECTORY,
                &var);
    _JumpIfError(hr, Ret, "GetRootConfigEntry wszREGDBLOGDIRECTORY");

    m_cstrLogPath = V_BSTR(&var);

    UpdateData(FALSE);

Ret:
    if (S_OK != hr)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////
// CCRLPropPage
/////////////////////////////////////////////////////////////////////////////
// CCRLPropPage property page
CCRLPropPage::CCRLPropPage(CertSvrCA* pCA, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pCA(pCA)
{
    m_cstrPublishPeriodCount = "1";
    m_cstrLastCRLPublish = _T("");
//    m_iNoAutoPublish = BST_UNCHECKED;

    m_cstrDeltaPublishPeriodCount = "1";
    m_cstrDeltaLastCRLPublish = _T("");
    m_iDeltaPublish = BST_CHECKED;


    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;


    CSASSERT(m_pCA);
    if (NULL == m_pCA)
        return;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CRL_PROPPAGE);
}

CCRLPropPage::~CCRLPropPage()
{
}

// replacement for DoDataExchange
BOOL CCRLPropPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrPublishPeriodCount.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT));
//        m_cstrLastCRLPublish.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LASTUPDATE));
//        m_iNoAutoPublish = (INT)SendDlgItemMessage(IDC_DISABLE_PUBLISH, BM_GETCHECK, 0, 0);

        m_cstrDeltaPublishPeriodCount.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT));
//        m_cstrDeltaLastCRLPublish.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE));
        m_iDeltaPublish = (INT)SendDlgItemMessage(IDC_ENABLE_DELTAPUBLISH, BM_GETCHECK, 0, 0);
    }
    else
    {
        m_cstrPublishPeriodCount.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT));
        m_cstrLastCRLPublish.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LASTUPDATE));
//        SendDlgItemMessage(IDC_DISABLE_PUBLISH, BM_SETCHECK, (WPARAM)m_iNoAutoPublish, 0);

        m_cstrDeltaPublishPeriodCount.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT));
        m_cstrDeltaLastCRLPublish.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE));
        SendDlgItemMessage(IDC_ENABLE_DELTAPUBLISH, BM_SETCHECK, (WPARAM)m_iDeltaPublish, 0);
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CCRLPropPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_EDIT_CRLPERIODCOUNT:
    case IDC_EDIT_DELTACRLPERIODCOUNT:
        if (EN_CHANGE == HIWORD(wParam))
            OnEditChange();
        break;
    case IDC_COMBO_CRLPERIODSTRING:
    case IDC_COMBO_DELTACRLPERIODSTRING:
        if (CBN_SELCHANGE == HIWORD(wParam))
            OnEditChange();
        break;
    case IDC_DISABLE_PUBLISH:
    case IDC_DISABLE_DELTAPUBLISH:
        if (BN_CLICKED == HIWORD(wParam))
            OnCheckBoxChange(LOWORD(wParam) == IDC_DISABLE_PUBLISH);
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCRLPropPage message handlers

void CCRLPropPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}



BOOL CCRLPropPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    m_cboxPublishPeriodString.Init(GetDlgItem(m_hWnd, IDC_COMBO_CRLPERIODSTRING));
    m_cboxDeltaPublishPeriodString.Init(GetDlgItem(m_hWnd, IDC_COMBO_DELTACRLPERIODSTRING));

    int iPublishPeriodCount = 0, iDeltaPublishPeriodCount = 0;
    CString cstr;
    HRESULT hr = S_OK;
    variant_t var;
    FILETIME ftBase, ftDelta;
	ZeroMemory(&ftBase, sizeof(ftBase));
	ZeroMemory(&ftDelta, sizeof(ftDelta));

    // add strings to dropdown
    m_cboxPublishPeriodString.ResetContent();
    m_cboxDeltaPublishPeriodString.ResetContent();

    int iEnum;

    // y
    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Years);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_YEARS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_cResources.m_szPeriod_Years);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_YEARS);

    // m
    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Months);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_MONTHS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_cResources.m_szPeriod_Months);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_MONTHS);

    // w
    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Weeks);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_WEEKS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_cResources.m_szPeriod_Weeks);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_WEEKS);

    // d
    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Days);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_DAYS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_cResources.m_szPeriod_Days);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_DAYS);

    // h
    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Hours);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_HOURS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_cResources.m_szPeriod_Hours);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_HOURS);

//    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Minutes);
//    if (iEnum >= 0)
//        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_MINUTES);

//    iEnum = m_cboxPublishPeriodString.AddString(g_cResources.m_szPeriod_Seconds);
//    if (iEnum >= 0)
//        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_SECONDS);

    // base period count
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLPERIODCOUNT,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)==VT_I4);
    iPublishPeriodCount = V_I4(&var);

    var.Clear();

    // Base CRL Period
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLPERIODSTRING,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)== VT_BSTR);

    // match validity internally, select combo
    if (StringFromDurationEnum( DurationEnumFromNonLocalizedString(V_BSTR(&var)), &cstr, TRUE))
    {
        m_cboxPublishPeriodString.SelectString(
            -1,
            cstr);
    }

    // create comparison value for later
    myMakeExprDateTime(
        &ftBase,
        iPublishPeriodCount,
        DurationEnumFromNonLocalizedString(V_BSTR(&var)));

    var.Clear();

    // DELTA period count
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTAPERIODCOUNT,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)==VT_I4);
    iDeltaPublishPeriodCount = V_I4(&var);

    var.Clear();

    // delta CRL Period
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTAPERIODSTRING,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)== VT_BSTR);

    // match validity internally, select combo
    if (StringFromDurationEnum( DurationEnumFromNonLocalizedString(V_BSTR(&var)), &cstr, TRUE))
    {
        m_cboxDeltaPublishPeriodString.SelectString(
            -1,
            cstr);
    }

    // create comparison value for later
    myMakeExprDateTime(
        &ftDelta,
        iDeltaPublishPeriodCount,
        DurationEnumFromNonLocalizedString(V_BSTR(&var)));

    var.Clear();

    // base Next publish
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLNEXTPUBLISH,
            &var);
    _PrintIfError(hr, "GetConfigEntry");

    CSASSERT(V_VT(&var)==(VT_ARRAY|VT_UI1));

    // optional value: might have never been published
    if (hr == S_OK)
    {
        DWORD dwType, dwSize;
        BYTE *pbTmp = NULL;
        hr = myVariantToRegValue(
                &var,
                &dwType,
                &dwSize,
                &pbTmp);
        _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");
        CSASSERT(dwType == REG_BINARY);

        // push result into FileTime
        CSASSERT(dwSize == sizeof(FILETIME));
        FILETIME ftGMT;
        CopyMemory(&ftGMT, pbTmp, sizeof(FILETIME));
        LOCAL_FREE(pbTmp);

        // Convert to localized time localized string
        hr = myGMTFileTimeToWszLocalTime(&ftGMT, FALSE, (LPWSTR*) &pbTmp);
        _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
        if (S_OK == hr)
        {
            m_cstrLastCRLPublish = (LPWSTR)pbTmp;
            LOCAL_FREE(pbTmp);
        }
    }

    var.Clear();

    GetDeltaNextPublish();

    // base autopublish
    // don't allow 0 : use chkbox
//    m_iNoAutoPublish = (iPublishPeriodCount == 0) ? BST_CHECKED : BST_UNCHECKED;
    if (iPublishPeriodCount <= 0)
        iPublishPeriodCount = 1;

    m_cstrPublishPeriodCount.Format(L"%i", iPublishPeriodCount);
//    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_CRLPERIODSTRING), (m_iNoAutoPublish == BST_UNCHECKED));
//    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT), (m_iNoAutoPublish == BST_UNCHECKED));
//    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_LASTUPDATE), (m_iNoAutoPublish == BST_UNCHECKED));

    // DELTA autopublish
    // don't allow 0 and don't allow delta>=Base: use chkbox
    m_iDeltaPublish = (
		(iDeltaPublishPeriodCount == 0) ||  // if disabled OR
		(-1 != CompareFileTime(&ftDelta,&ftBase)) ) // delta not less than base
			? BST_UNCHECKED : BST_CHECKED;
    if (iDeltaPublishPeriodCount <= 0)
        iDeltaPublishPeriodCount = 1;

    m_cstrDeltaPublishPeriodCount.Format(L"%i", iDeltaPublishPeriodCount);
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_DELTACRLPERIODSTRING), (m_iDeltaPublish == BST_CHECKED));
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT), (m_iDeltaPublish == BST_CHECKED));
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE), (m_iDeltaPublish == BST_CHECKED));


    UpdateData(FALSE);
    return TRUE;

error:
    DisplayGenericCertSrvError(m_hWnd, hr);
    return TRUE;
}

void CCRLPropPage::GetDeltaNextPublish()
{
    HRESULT hr = S_OK;
    variant_t var;

    // DELTA Next publish
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTANEXTPUBLISH,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)==(VT_ARRAY|VT_UI1));

    DWORD dwType, dwSize;
    BYTE* pbTmp = NULL;

    hr = myVariantToRegValue(
            &var,
            &dwType,
            &dwSize,
            &pbTmp);
    _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");

    CSASSERT(dwType == REG_BINARY);

    // push result into FileTime
    CSASSERT(dwSize == sizeof(FILETIME));
    FILETIME ftGMT;
    CopyMemory(&ftGMT, pbTmp, sizeof(FILETIME));

    // Convert to localized time localized string
    hr = myGMTFileTimeToWszLocalTime(&ftGMT, FALSE, (LPWSTR*) &pbTmp);
    _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");

    m_cstrDeltaLastCRLPublish = (LPWSTR)pbTmp;

error:
    LOCAL_FREE(pbTmp);
    return; // ignore errors
}

void CCRLPropPage::OnCheckBoxChange(BOOL fDisableBaseCRL)
{
    UpdateData(TRUE);

    if(m_iDeltaPublish == BST_UNCHECKED)
    {
        m_cstrDeltaLastCRLPublish = L"";
        m_cstrDeltaLastCRLPublish.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE));
    }

    // pull in new selection
/*
    if (fDisableBaseCRL)
    {
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_CRLPERIODSTRING), (m_iNoAutoPublish == BST_UNCHECKED));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT), (m_iNoAutoPublish == BST_UNCHECKED));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_LASTUPDATE), (m_iNoAutoPublish == BST_UNCHECKED));
    }
    else
*/
    {
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_DELTACRLPERIODSTRING), (m_iDeltaPublish == BST_CHECKED));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT), (m_iDeltaPublish == BST_CHECKED));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE), (m_iDeltaPublish == BST_CHECKED));
    }

    // call normal edit change to whack modified bit
    OnEditChange();
}

void CCRLPropPage::OnEditChange()
{
    // Page is dirty, mark it.
    SetModified();	
    m_bUpdate = TRUE;
}


BOOL CCRLPropPage::OnApply()
{
    HRESULT hr = S_OK;
    BOOL fValidDigitString;
    variant_t var;
    FILETIME ftBase, ftDelta;
	ZeroMemory(&ftBase, sizeof(ftBase));
	ZeroMemory(&ftDelta, sizeof(ftDelta));


    if (m_bUpdate == TRUE)
    {
        int iPublishPeriodCount, iDeltaPublishPeriodCount;

        // check for invalid data in IDC_EDIT_CRLPERIODCOUNT if not autopublishing
        iPublishPeriodCount = myWtoI(m_cstrPublishPeriodCount, &fValidDigitString);
//        if (!m_iNoAutoPublish)
        {
            // invalid data is zero, negative, or not reproducible
            if (!fValidDigitString || 0 == iPublishPeriodCount)
            {
                DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_POSITIVE_NUMBER);
                ::SetFocus(::GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT));
                return FALSE;
            }

        }

        // check for invalid data in IDC_EDIT_DELTACRLPERIODCOUNT if not autopublishing
        iDeltaPublishPeriodCount = myWtoI(m_cstrDeltaPublishPeriodCount, &fValidDigitString);
        if (m_iDeltaPublish)
        {
            if (!fValidDigitString || 0 == iDeltaPublishPeriodCount)
            {
                DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_POSITIVE_NUMBER);
                ::SetFocus(::GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT));
                return FALSE;
            }
        }

        CString cstrTmp;
        ENUM_PERIOD iEnum = (ENUM_PERIOD) m_cboxPublishPeriodString.GetItemData(m_cboxPublishPeriodString.GetCurSel());
        if (StringFromDurationEnum(iEnum, &cstrTmp, FALSE))
        {
//            DWORD dwPublishPeriodCount = (m_iNoAutoPublish == BST_CHECKED) ? 0 : iPublishPeriodCount;
            DWORD dwPublishPeriodCount = iPublishPeriodCount;
            var = cstrTmp;

            // create comparison value for later
            myMakeExprDateTime(
                &ftBase,
                dwPublishPeriodCount,
                iEnum);

            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLPERIODSTRING,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");

            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = dwPublishPeriodCount;

            // use chkbox
            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLPERIODCOUNT,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");
        }

        iEnum = (ENUM_PERIOD)m_cboxDeltaPublishPeriodString.GetItemData(m_cboxDeltaPublishPeriodString.GetCurSel());
        if (StringFromDurationEnum(iEnum, &cstrTmp, FALSE))
        {
            DWORD dwDeltaPublishPeriodCount = (m_iDeltaPublish == BST_UNCHECKED) ? 0 : iDeltaPublishPeriodCount;
            var = cstrTmp;

            // create comparison value for later
            myMakeExprDateTime(
                &ftDelta,
                dwDeltaPublishPeriodCount,
                iEnum);

            if (-1 != CompareFileTime(&ftDelta,&ftBase))	// if delta not less
            {
                 dwDeltaPublishPeriodCount = 0; // disable
                 m_iDeltaPublish = BST_UNCHECKED;
            }
//            else
//                 m_iDeltaPublish = BST_CHECKED;

            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLDELTAPERIODSTRING,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");

            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = dwDeltaPublishPeriodCount;

            // use chkbox
            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLDELTAPERIODCOUNT,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");

            if(!m_iDeltaPublish)
            {
                var.Clear();
                V_VT(&var) = VT_EMPTY; // delete entry
                hr = m_pCA->SetConfigEntry(
                    NULL,
                    wszREGCRLDELTANEXTPUBLISH,
                    &var);
                _JumpIfError(hr, Ret, "SetConfigEntry");
            }
        }

        m_bUpdate = FALSE;
    }
Ret:
    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    GetDeltaNextPublish();

	// delta checkbox change: set UI then update data
    SendDlgItemMessage(IDC_ENABLE_DELTAPUBLISH, BM_SETCHECK, (WPARAM)m_iDeltaPublish, 0);
    OnCheckBoxChange(FALSE);

    return CAutoDeletePropPage::OnApply();
}


///////////////////////////////////////////
// CCRLViewPage
/////////////////////////////////////////////////////////////////////////////
// CCRLViewPage property page
CCRLViewPage::CCRLViewPage(CCRLPropPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CRL_VIEWPAGE);
}

CCRLViewPage::~CCRLViewPage()
{
}

// replacement for DoDataExchange
BOOL CCRLViewPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CCRLViewPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL  fBaseCRL = TRUE;
    switch(LOWORD(wParam))
    {
        case IDC_CRL_VIEW_BTN_VIEWDELTA:
            fBaseCRL = FALSE;
            //fall through
        case IDC_CRL_VIEW_BTN_VIEWCRL:
        if (BN_CLICKED == HIWORD(wParam))
            OnViewCRL(fBaseCRL);
        break;
        default:
        //return FALSE;
	return TRUE;
        break;
    }
    return TRUE;
}

BOOL CCRLViewPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    BOOL fBaseCRL = TRUE;

    switch(idCtrl)
    {
        //handle double click on list items
        case IDC_CRL_VIEW_LIST_DELTA:
            fBaseCRL = FALSE;
            //fall through
        case IDC_CRL_VIEW_LIST_CRL:
            if (pnmh->code == NM_DBLCLK)
                OnViewCRL(fBaseCRL);
            break;
    }
    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCRLViewPage message handlers

/*

To get the CA signature cert count, use ICertAdmin::GetCAProperty(
strConfig,
PropId == CR_PROP_CASIGCERTCOUNT,
PropIndex == 0 (unused),
PropType == PROPTYPE_LONG,
Flags == CR_OUT_BINARY,
&varPropertyValue);
varPropertyValue.vt will be VT_I4
varPropertyValue.lVal will be the CA signature cert count

then step key index from 0 to 1 less than the count of signature certs to determine which key indices have valid CRLs:
To get each key's CRL state, call ICertAdmin2::GetCAProperty(
strConfig,
PropId == CR_PROP_CRLSTATE,
PropIndex == key index (MAXDWORD for current key),
PropType == PROPTYPE_LONG,
Flags == CR_OUT_BINARY,
&varPropertyValue);
varPropertyValue.vt will be VT_I4
varPropertyValue.lVal will be the CRL state, CA_DISP_VALID means you can fetch the CRL for that index.

To get each key's CRL, call ICertAdmin2::GetCAProperty(
strConfig,
PropId == CR_PROP_BASECRL or CR_PROP_DELTACRL,
PropIndex == key index (MAXDWORD for current key),
PropType == PROPTYPE_BINARY,
Flags == CR_OUT_BINARY,
&varPropertyValue);
varPropertyValue.vt will be VT_BSTR
varPropertyValue.bstrVal can be cast to BYTE *pbCRL
SysStringByteLen(varPropertyValue.bstrVal) will be cbCRL

If the server is down level, all GetCAProperty method calls will return RPC_E_VERSION_MISMATCH.  Then you have two choices:
use ICertAdmin::GetCRL, which will only retrieve the current key's base CRL
to fetch a CAINFO structure to get the CA signature cert count, use ICertRequest::GetCACertificate(
fExchangeCertificate == GETCERT_CAINFO,
strConfig,
Flags == CR_OUT_BINARY,
&strOut);
strCACertificate will be a Unicode BSTR, something like: L"3,1".  The first number is the CA Type, and the second is the count of CA signature certs.

then step key index from 0 to 1 less than the count of signature certs to determine which key indices have valid CRLs:
To get each key's CRL state, call ICertRequest::GetCACertificate(
fExchangeCertificate == GETCERT_CRLSTATEBYINDEX | key index),
strConfig,
Flags == CR_OUT_BINARY,
&strOut);
strCACertificate will be a Unicode BSTR, something like: L"3".  After converting to a DWORD, CA_DISP_VALID means you can fetch the CRL for that index.

To get each key's CRL, call ICertRequest::GetCACertificate(	// can retrieve only base CRLs for all server keys
fExchangeCertificate == GETCERT_CRLBYINDEX | key index (MAXDWORD not supported here),
strConfig,
Flags == CR_OUT_BINARY,
&strOut);
strOut can be cast to BYTE *pbCRL
SysStringByteLen(strOut) will be cbCRL

*/

void MapCRLPublishStatusToString(DWORD dwStatus, CString& strStatus)
{
    strStatus.LoadString(
        dwStatus?
        ((dwStatus&CPF_COMPLETE)?
          IDS_CRLPUBLISHSTATUS_OK:
          IDS_CRLPUBLISHSTATUS_FAILED):
        IDS_CRLPUBLISHSTATUS_UNKNOWN);
}

void
ListView_AddCRLItem(
    IN HWND hwndList,
    IN int iItem,
    IN DWORD dwIndex,
    IN PCCRL_CONTEXT pCRLContext,
    IN DWORD dwCRLPublishStatus)
{
    CString cstrItemName;
    CString cstrCRLPublishStatus;

    MapCRLPublishStatusToString(dwCRLPublishStatus, cstrCRLPublishStatus);

    // add column data for crl
    // renew index
    cstrItemName.Format(L"%d", dwIndex);
    ListView_NewItem(hwndList, iItem, cstrItemName, (LPARAM)pCRLContext);

    if (pCRLContext)	// on error, don't add these
{
    // crl effective date
    ListView_SetItemFiletime(hwndList, iItem, 1, &pCRLContext->pCrlInfo->ThisUpdate);
    // crl expiration date
    ListView_SetItemFiletime(hwndList, iItem, 2, &pCRLContext->pCrlInfo->NextUpdate);
}
    // crl publish status
    ListView_SetItemText(hwndList, iItem, 3, cstrCRLPublishStatus.GetBuffer());
}

BOOL CCRLViewPage::OnInitDialog()
{
	HRESULT hr;
	ICertAdmin2* pAdmin = NULL;
	VARIANT varPropertyValue, varCRLStatus;
	VariantInit(&varPropertyValue);
    VariantInit(&varCRLStatus);

	DWORD cCertCount, dwCertIndex;
	CString cstrItemName;
	int  iItem = 0;
    HWND hwndListCRL, hwndListDeltaCRL;
    PCCRL_CONTEXT pCRLContext = NULL;
    PCCRL_CONTEXT pDeltaCRLContext = NULL;
    CWaitCursor WaitCursor;

    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

	// init listview
	hwndListCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_CRL);
	hwndListDeltaCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_DELTA);

    //make listviews whole row selection
    ListView_SetExtendedListViewStyle(hwndListCRL, LVS_EX_FULLROWSELECT);
    ListView_SetExtendedListViewStyle(hwndListDeltaCRL, LVS_EX_FULLROWSELECT);

    //add multiple columns
    //column 0
    cstrItemName.LoadString(IDS_CRL_LISTCOL_INDEX);
    ListView_NewColumn(hwndListCRL, 0, 60, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 0, 60, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 1
    cstrItemName.LoadString(IDS_LISTCOL_EFFECTIVE_DATE);
    ListView_NewColumn(hwndListCRL, 1, 105, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 1, 105, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 2
    cstrItemName.LoadString(IDS_LISTCOL_EXPIRATION_DATE);
    ListView_NewColumn(hwndListCRL, 2, 105, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 2, 105, (LPWSTR)(LPCWSTR)cstrItemName);

    //column 3
    cstrItemName.LoadString(IDS_LISTCOL_PUBLISH_STATUS);
    ListView_NewColumn(hwndListCRL, 3, 83, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 3, 83, (LPWSTR)(LPCWSTR)cstrItemName);

    hr = m_pControlPage->m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
    _JumpIfError(hr, Ret, "GetAdmin");

	// load crls here
	hr = pAdmin->GetCAProperty(
		m_pControlPage->m_pCA->m_bstrConfig,
		CR_PROP_CASIGCERTCOUNT,
		0, // (unused)
		PROPTYPE_LONG, // PropType
		CR_OUT_BINARY, // Flags
		&varPropertyValue);
	_JumpIfError(hr, Ret, "GetCAProperty");

	// varPropertyValue.vt will be VT_I4
	// varPropertyValue.lVal will be the CA signature cert count
	if (VT_I4 != varPropertyValue.vt)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		_JumpError(hr, Ret, "GetCAProperty");
	}

	cCertCount = varPropertyValue.lVal;

    iItem = 0;
	// now we have a max count; begin looping
	for (dwCertIndex=0; dwCertIndex<cCertCount; dwCertIndex++)
	{
		VariantClear(&varPropertyValue);
        VariantClear(&varCRLStatus);


		// get each key's CRL state
		hr = pAdmin->GetCAProperty(
			m_pControlPage->m_pCA->m_bstrConfig,
			CR_PROP_CRLSTATE, //PropId
			dwCertIndex, //PropIndex
			PROPTYPE_LONG, // PropType
			CR_OUT_BINARY, // Flags
			&varPropertyValue);
                _PrintIfError(hr, "GetCAProperty");

        // if this CRL doesn't exist, skip it
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            continue;

		// varPropertyValue.vt will be VT_I4
		// varPropertyValue.lVal will be the CRL state
		if (VT_I4 != varPropertyValue.vt)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
			_JumpError(hr, Ret, "GetCAProperty");
		}
               
        // if it's not a valid CRL to query for, skip it
        if (varPropertyValue.lVal != CA_DISP_VALID)
            continue;

        // Now we know there's supposed to be a CRL here. Make entry in UI no matter what.

        // CRL 
          // get crl and delta crl context handles
          hr = m_pControlPage->m_pCA->GetCRLByKeyIndex(&pCRLContext, TRUE, dwCertIndex);
          _PrintIfError(hr, "GetCRLByKeyIndex (base)");

          // zero means Unknown error
          V_VT(&varCRLStatus) = VT_I4;
          V_I4(&varCRLStatus) = 0;

          hr = pAdmin->GetCAProperty(
             m_pControlPage->m_pCA->m_bstrConfig,
             CR_PROP_BASECRLPUBLISHSTATUS,
             dwCertIndex,
             PROPTYPE_LONG,
             CR_OUT_BINARY,
             &varCRLStatus);
          _PrintIfError(hr, "GetCAProperty (base)");

        ListView_AddCRLItem(
            hwndListCRL,
            iItem,
            dwCertIndex,
            pCRLContext,
            V_I4(&varCRLStatus));


        //don't free, they are used as item data, will free in OnDestroy
        pCRLContext = NULL;

      // Delta
        VariantClear(&varCRLStatus);

        hr = m_pControlPage->m_pCA->GetCRLByKeyIndex(&pDeltaCRLContext, FALSE, dwCertIndex);
        _PrintIfError(hr, "GetCRLByKeyIndex (delta)");

        // zero is status Unknown
        V_VT(&varCRLStatus) = VT_I4;
        V_I4(&varCRLStatus) = 0;

         hr = pAdmin->GetCAProperty(
                m_pControlPage->m_pCA->m_bstrConfig,
                CR_PROP_DELTACRLPUBLISHSTATUS,
                dwCertIndex,
                PROPTYPE_LONG,
                CR_OUT_BINARY,
                &varCRLStatus);
          _PrintIfError(hr, "GetCAProperty (delta)");

            ListView_AddCRLItem(
                hwndListDeltaCRL,
                iItem,
                dwCertIndex,
                pDeltaCRLContext,
                V_I4(&varCRLStatus));

        //don't free, they are used as item data, will free in OnDestroy
        pDeltaCRLContext = NULL;

        iItem++;
	}

        if (0 < iItem)
        {
            //select first one
            ListView_SetItemState(hwndListDeltaCRL, 0,
                LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
            ListView_SetItemState(hwndListCRL, 0,
                LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

        }
        //enable view button
        ::EnableWindow(GetDlgItem(m_hWnd, IDC_CRL_VIEW_BTN_VIEWDELTA), 0 < iItem);
        ::EnableWindow(GetDlgItem(m_hWnd, IDC_CRL_VIEW_BTN_VIEWCRL), 0 < iItem);

    UpdateData(FALSE);
Ret:
    if (NULL != pCRLContext)
    {
        CertFreeCRLContext(pCRLContext);
    }
    if (NULL != pDeltaCRLContext)
    {
        CertFreeCRLContext(pDeltaCRLContext);
    }
	if (pAdmin)
		pAdmin->Release();
	
	VariantClear(&varPropertyValue);
	
	if (hr != S_OK)
		DisplayGenericCertSrvError(m_hWnd, hr);

    return TRUE;
}

DWORD CertAdminViewCRL(CertSvrCA* pCertCA, HWND hwnd, PCCRL_CONTEXT pCRLContext)
{
    DWORD dwErr;

    HCERTSTORE      rghStores[2];

    CRYPTUI_VIEWCRL_STRUCT sViewCRL;
    ZeroMemory(&sViewCRL, sizeof(sViewCRL));

    if (pCRLContext == NULL)
    {
       _PrintError(E_POINTER, "pCRLContext");
       dwErr = S_OK;
       goto Ret;
    }

    // get the backing store
    dwErr = pCertCA->GetRootCertStore(&rghStores[0]);
    _JumpIfError(dwErr, Ret, "GetRootCertStore");

    dwErr = pCertCA->GetCACertStore(&rghStores[1]);
    _JumpIfError(dwErr, Ret, "GetCACertStore");

    sViewCRL.dwSize = sizeof(sViewCRL);
    sViewCRL.hwndParent = hwnd;
    sViewCRL.pCRLContext = pCRLContext;
    sViewCRL.dwFlags = CRYPTUI_WARN_UNTRUSTED_ROOT;
	
	// if we're opening remotely, don't open local stores
    if (! pCertCA->m_pParentMachine->IsLocalMachine())
        sViewCRL.dwFlags |= CRYPTUI_DONT_OPEN_STORES;

    sViewCRL.cStores = 2;
    sViewCRL.rghStores = rghStores;

    if (!CryptUIDlgViewCRL(&sViewCRL))
    {
        dwErr = GetLastError();
		if (dwErr != ERROR_CANCELLED)
			_JumpError(dwErr, Ret, "CryptUIDlgViewCRL");
    }

    dwErr = ERROR_SUCCESS;
Ret:
    return dwErr;
}

void CCRLViewPage::OnViewCRL(BOOL fViewBaseCRL)
{
	DWORD dw;
    PCCRL_CONTEXT pCRLContext;
    HWND hwndList = GetDlgItem(m_hWnd, (fViewBaseCRL ?
                      IDC_CRL_VIEW_LIST_CRL : IDC_CRL_VIEW_LIST_DELTA));

    // get cert # from item data
    int iSel = ListView_GetCurSel(hwndList);
    if (-1 == iSel)
        return;

    // get item data
    pCRLContext = (PCCRL_CONTEXT)ListView_GetItemData(hwndList, iSel);
    if (NULL == pCRLContext)
        return;
	
    dw = CertAdminViewCRL(m_pControlPage->m_pCA, m_hWnd, pCRLContext);
    _PrintIfError(dw, "CertAdminViewCRL");
	
    if ((dw != ERROR_SUCCESS) && (dw != ERROR_CANCELLED))
        DisplayGenericCertSrvError(m_hWnd, dw);

}

void
FreeListViewCRL(HWND hwndList, int iItem)
{
    PCCRL_CONTEXT pCRLContext;

    pCRLContext = (PCCRL_CONTEXT)ListView_GetItemData(hwndList, iItem);
    if (pCRLContext != NULL)	
        CertFreeCRLContext(pCRLContext);
}

void CCRLViewPage::OnDestroy()
{
    int i;
	HWND hwndListCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_CRL);
	HWND hwndListDeltaCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_DELTA);
    int iCRLCount = ListView_GetItemCount(hwndListCRL);
    int iDeltaCRLCount = ListView_GetItemCount(hwndListDeltaCRL);

    //free all crl context
    for (i = 0; i < iCRLCount; ++i)
    {
        FreeListViewCRL(hwndListCRL, i);
    }

    for (i = 0; i < iDeltaCRLCount; ++i)
    {
        FreeListViewCRL(hwndListDeltaCRL, i);
    }

    CAutoDeletePropPage::OnDestroy();
}


///////////////////////////////////////////
// CBackupWizPage1
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage1 property page

CBackupWizPage1::CBackupWizPage1(
    BACKUPWIZ_STATE* pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CBackupWizPage1::~CBackupWizPage1()
{
}

// replacement for DoDataExchange
BOOL CBackupWizPage1::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CBackupWizPage1::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}


BOOL CBackupWizPage1::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    //(GetDlgItem(IDC_TEXT_BIGBOLD))->SetFont(&(GetBigBoldFont()), TRUE);
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));

    return TRUE;
}

BOOL CBackupWizPage1::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);

	return TRUE;
}

///////////////////////////////////////////
// CBackupWizPage2
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage2 property page

CBackupWizPage2::CBackupWizPage2(
    PBACKUPWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_BACKUPWIZPG2);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_BACKUPWIZPG2);
	InitWizard97 (FALSE);
    m_cstrLogsPath = L"";
    m_iKeyCertCheck = BST_UNCHECKED;
    m_iLogsCheck = BST_UNCHECKED;
    m_iIncrementalCheck = BST_UNCHECKED;


    PBYTE pb = NULL;
    DWORD cb, dwType;

    DWORD dwRet;
    HKEY hConfigKey;
    m_fIncrementalAllowed = FALSE;

    variant_t var;
    dwRet = m_pState->pCA->m_pParentMachine->GetRootConfigEntry(
                wszREGDBLASTFULLBACKUP,
                &var);
    if(S_OK==dwRet)
    {
        m_fIncrementalAllowed = TRUE;
    }

//    SetHelp(CERTMMC_HELPFILENAME , g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CBackupWizPage2::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrLogsPath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        m_iKeyCertCheck = (INT)SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_GETCHECK, 0, 0);
        m_iLogsCheck = (INT)SendDlgItemMessage(IDC_CHECK_LOGS, BM_GETCHECK, 0, 0);
        m_iIncrementalCheck = (INT)SendDlgItemMessage(IDC_CHECK_INCREMENTAL, BM_GETCHECK, 0, 0);
    }
    else
    {
        m_cstrLogsPath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_SETCHECK, (WPARAM)m_iKeyCertCheck, 0);
        SendDlgItemMessage(IDC_CHECK_LOGS, BM_SETCHECK, (WPARAM)m_iLogsCheck, 0);
        SendDlgItemMessage(IDC_CHECK_INCREMENTAL, BM_SETCHECK, (WPARAM)m_iIncrementalCheck, 0);

        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_INCREMENTAL), m_fIncrementalAllowed && (m_iLogsCheck == BST_CHECKED) );
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CBackupWizPage2::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_BROWSE_LOGS:
        if (BN_CLICKED == HIWORD(wParam))
            OnBrowse();
        break;
    case IDC_CHECK_LOGS:
        if (BN_CLICKED == HIWORD(wParam))
        {
            m_iLogsCheck = (INT)SendDlgItemMessage(IDC_CHECK_LOGS, BM_GETCHECK, 0, 0);
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_INCREMENTAL), m_fIncrementalAllowed && (m_iLogsCheck == BST_CHECKED) );
        }
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


BOOL CBackupWizPage2::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CBackupWizPage2::OnSetActive()
{
    PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

    // don't allow PFX across machines
    if (! m_pState->pCA->m_pParentMachine->IsLocalMachine())
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_KEYCERT), FALSE);

    // get from state
    m_iKeyCertCheck = (m_pState->fBackupKeyCert) ? BST_CHECKED : BST_UNCHECKED;
    m_iLogsCheck = (m_pState->fBackupLogs) ? BST_CHECKED : BST_UNCHECKED;
    m_iIncrementalCheck = (m_pState->fIncremental) ? BST_CHECKED : BST_UNCHECKED;
    if (m_pState->szLogsPath)
        m_cstrLogsPath = m_pState->szLogsPath;

	return TRUE;
}



void CBackupWizPage2::OnBrowse()
{
    UpdateData(TRUE);

    LPCWSTR pszInitialDir;
    WCHAR  szCurDir[MAX_PATH];

    if (m_cstrLogsPath.IsEmpty())
    {
        if (0 == GetCurrentDirectory(MAX_PATH, szCurDir) )
            pszInitialDir = L"C:\\";
        else
            pszInitialDir = szCurDir;
    }
    else
        pszInitialDir = m_cstrLogsPath;

    WCHAR szFileBuf[MAX_PATH+1]; szFileBuf[0] = L'\0';
    if (!BrowseForDirectory(
            m_hWnd,
            pszInitialDir,
            szFileBuf,
            MAX_PATH,
            NULL,
            FALSE))
        return;

    m_cstrLogsPath = szFileBuf;

    UpdateData(FALSE);
    return;
}


HRESULT CBackupWizPage2::ConvertLogsPathToFullPath()
{
    LPWSTR pwszFullPath = NULL;
    DWORD cFullPath = 0;
    HRESULT hr;

    cFullPath = GetFullPathName(
                    m_cstrLogsPath,
                    0,
                    NULL,
                    NULL);
    if(!cFullPath)
        return HRESULT_FROM_WIN32(GetLastError());

    pwszFullPath = (LPWSTR)LocalAlloc(LMEM_FIXED, cFullPath*sizeof(WCHAR));
    if(!pwszFullPath)
        return E_OUTOFMEMORY;
    cFullPath = GetFullPathName(
                    m_cstrLogsPath,
                    cFullPath,
                    pwszFullPath,
                    NULL);
    if(cFullPath == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Ret;
    }


    m_cstrLogsPath = pwszFullPath;
    hr = S_OK;
Ret:
    if(pwszFullPath)
        LocalFree(pwszFullPath);
    return hr;
}

LRESULT CBackupWizPage2::OnWizardNext()
{
    HRESULT hr;
    UpdateData(TRUE);

    // persist to state structure
    m_pState->fBackupKeyCert = (m_iKeyCertCheck == BST_CHECKED);
    m_pState->fBackupLogs = (m_iLogsCheck == BST_CHECKED);
    m_pState->fIncremental = (m_iIncrementalCheck == BST_CHECKED);

    if (!
        (m_pState->fBackupKeyCert ||
        m_pState->fBackupLogs) )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_REQUIRE_ONE_SELECTION);
        return -1;
    }



    // empty?
    if ( m_cstrLogsPath.IsEmpty() )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_NEED_FILEPATH);
        return -1;
    }

    hr = ConvertLogsPathToFullPath();
    if(S_OK != hr)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return -1;
    }

    // make sure we're a valid directory
    if (!myIsDirectory(m_cstrLogsPath))
    {
        CString cstrTitle, cstrFmt, cstrMsg;
        cstrTitle.FromWindow(m_hWnd);  // use same title as parent has
        cstrFmt.LoadString(IDS_DIR_CREATE);
        cstrMsg.Format(cstrFmt, m_cstrLogsPath);

        if (IDOK != MessageBox(m_hWnd, cstrMsg, cstrTitle, MB_OKCANCEL))
           return -1;

        hr = myCreateNestedDirectories(m_cstrLogsPath);
        _PrintIfError(hr, "myCreateNestedDirectories");
        if (hr != S_OK)
        {
            DisplayGenericCertSrvError(m_hWnd, hr);
            return -1;
        }
    }

    hr = myIsDirWriteable(
        m_cstrLogsPath,
        FALSE);
    _PrintIfError(hr, "myIsDirWriteable");
    if (hr != S_OK)
    {
        DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_DIR_NOT_WRITEABLE);
        return -1;
    }

    // if backing up db, make sure there's no \DataBase folder here
    if (m_pState->fBackupLogs)
    {
        DWORD dwFlags = CDBBACKUP_VERIFYONLY;
        dwFlags |= m_pState->fIncremental ? CDBBACKUP_INCREMENTAL : 0;
        hr = myBackupDB(
            (LPCWSTR)m_pState->pCA->m_strConfig,
            dwFlags,
            m_cstrLogsPath,
    	    NULL);
        _PrintIfError(hr, "myBackupDB");
        if (hr != S_OK)
        {
            DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_CANT_ACCESS_BACKUP_DIR);
            return -1;
        }
    }


    if (m_pState->fBackupKeyCert ||
        m_pState->fBackupLogs)
    {
        // free if exists
        if (m_pState->szLogsPath)
            LocalFree(m_pState->szLogsPath);

        // alloc anew
        m_pState->szLogsPath = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrLogsPath));

        // copy
        if (m_pState->szLogsPath)
            wcscpy(m_pState->szLogsPath, (LPCWSTR)m_cstrLogsPath);
    }


    // skip "get password"?
    if (!m_pState->fBackupKeyCert)
        return IDD_BACKUPWIZ_COMPLETION;

    return 0;
}


///////////////////////////////////////////
// CBackupWizPage3
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage3 property page

CBackupWizPage3::CBackupWizPage3(
    PBACKUPWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_BACKUPWIZPG3);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_BACKUPWIZPG3);
	InitWizard97 (FALSE);
    m_cstrPwd = L"";
    m_cstrPwdVerify = L"";

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CBackupWizPage3::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrPwd.FromWindow(GetDlgItem(m_hWnd, IDC_NEW_PASSWORD));
        m_cstrPwdVerify.FromWindow(GetDlgItem(m_hWnd, IDC_CONFIRM_PASSWORD));
    }
    else
    {
        m_cstrPwd.ToWindow(GetDlgItem(m_hWnd, IDC_NEW_PASSWORD));
        m_cstrPwdVerify.ToWindow(GetDlgItem(m_hWnd, IDC_CONFIRM_PASSWORD));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CBackupWizPage3::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}


BOOL CBackupWizPage3::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CBackupWizPage3::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

	return TRUE;
}

LRESULT CBackupWizPage3::OnWizardNext()
{
    UpdateData(TRUE);
    if (! m_cstrPwd.IsEqual(m_cstrPwdVerify))
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_PASSWORD_NOMATCH);

        m_cstrPwd.Empty();
        m_cstrPwdVerify.Empty();
        UpdateData(FALSE);

        return -1;  // stay here
    }


    // free if exists
    if (m_pState->szPassword)
        LocalFree(m_pState->szPassword);

    // alloc anew
    m_pState->szPassword = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrPwd));

    // copy
    if (m_pState->szPassword)
        wcscpy(m_pState->szPassword, (LPCWSTR)m_cstrPwd);

    return 0;   // advance
}


///////////////////////////////////////////
// CBackupWizPage5
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage5 property page

CBackupWizPage5::CBackupWizPage5(
    PBACKUPWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CBackupWizPage5::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CBackupWizPage5::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}



BOOL CBackupWizPage5::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));


    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_COLUMN lvC = { (LVCF_FMT|LVCF_WIDTH), LVCFMT_LEFT, 0, NULL, 0, 0};

    lvC.cx = 675;
    ListView_InsertColumn(hList, 0, &lvC);

    return TRUE;
}

BOOL CBackupWizPage5::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_FINISH));


    CString cstrDialogMsg;
    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_ITEM sItem; ZeroMemory(&sItem, sizeof(sItem));

    ListView_DeleteAllItems(hList);

    if (m_pState->fBackupKeyCert)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_KEYANDCERT);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }
    if (m_pState->fBackupLogs)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_CALOGS);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }
    if (m_pState->fIncremental)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_INCREMENTAL_BACKUP);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }

	return TRUE;
}


LRESULT CBackupWizPage5::OnWizardBack()
{
    if (!m_pState->fBackupKeyCert)
        return IDD_BACKUPWIZ_SELECT_DATA;

    return 0;
}



///////////////////////////////////////////
// CRestoreWizPage1
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage1 property page
CRestoreWizPage1::CRestoreWizPage1(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CRestoreWizPage1::~CRestoreWizPage1()
{
}

// replacement for DoDataExchange
BOOL CRestoreWizPage1::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CRestoreWizPage1::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}


BOOL CRestoreWizPage1::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));


    return TRUE;
}


BOOL CRestoreWizPage1::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);

	return TRUE;
}

///////////////////////////////////////////
// CRestoreWizPage2
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage2 property page
CRestoreWizPage2::CRestoreWizPage2(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_RESTOREWIZPG2);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_RESTOREWIZPG2);
	InitWizard97 (FALSE);
    m_cstrLogsPath = L"";
    m_iKeyCertCheck = BST_UNCHECKED;
    m_iLogsCheck = BST_UNCHECKED;

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CRestoreWizPage2::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrLogsPath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        m_iKeyCertCheck = (INT)SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_GETCHECK, 0, 0);
        m_iLogsCheck = (INT)SendDlgItemMessage(IDC_CHECK_LOGS, BM_GETCHECK, 0, 0);
    }
    else
    {
        m_cstrLogsPath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_SETCHECK, (WPARAM)m_iKeyCertCheck, 0);
        SendDlgItemMessage(IDC_CHECK_LOGS, BM_SETCHECK, (WPARAM)m_iLogsCheck, 0);
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CRestoreWizPage2::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_BROWSE_LOGS:
        if (BN_CLICKED == HIWORD(wParam))
            OnBrowse();
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}



BOOL CRestoreWizPage2::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CRestoreWizPage2::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

    // get from state
    m_iKeyCertCheck = (m_pState->fRestoreKeyCert) ? BST_CHECKED : BST_UNCHECKED;
    m_iLogsCheck = (m_pState->fRestoreLogs) ? BST_CHECKED : BST_UNCHECKED;
    if (m_pState->szLogsPath)
        m_cstrLogsPath = m_pState->szLogsPath;


	return TRUE;
}

void CRestoreWizPage2::OnBrowse()
{
    UpdateData(TRUE);

    LPCWSTR pszInitialDir;
    WCHAR  szCurDir[MAX_PATH];

    if (m_cstrLogsPath.IsEmpty())
    {
        if (0 == GetCurrentDirectory(MAX_PATH, szCurDir) )
            pszInitialDir = L"C:\\";
        else
            pszInitialDir = szCurDir;
    }
    else
        pszInitialDir = (LPCWSTR)m_cstrLogsPath;

    WCHAR szFileBuf[MAX_PATH+1]; szFileBuf[0] = L'\0';
    if (!BrowseForDirectory(
            m_hWnd,
            pszInitialDir,
            szFileBuf,
            MAX_PATH,
            NULL,
            FALSE))
        return;

    m_cstrLogsPath = szFileBuf;

    UpdateData(FALSE);
    return;
}




LRESULT CRestoreWizPage2::OnWizardNext()
{
    HRESULT hr;
    UpdateData(TRUE);

    // persist to state structure
    m_pState->fRestoreKeyCert = (m_iKeyCertCheck == BST_CHECKED);
    m_pState->fRestoreLogs = (m_iLogsCheck == BST_CHECKED);

    if (!
        (m_pState->fRestoreKeyCert ||
        m_pState->fRestoreLogs) )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_REQUIRE_ONE_SELECTION);
        return -1;
    }


    if ( m_cstrLogsPath.IsEmpty() )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_NEED_FILEPATH);
        return -1;
    }

    if (!myIsDirectory(m_cstrLogsPath))
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_INVALID_DIRECTORY);
        return -1;
    }

    // validate pfx blob
    if (m_pState->fRestoreKeyCert)
    {
        // if pfx not here -- FAIL
        if (myIsDirEmpty(m_cstrLogsPath))
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_DIRECTORY_CONTENTS_UNEXPECTED);
            return -1;
        }
    }

    // validate logs path
    if (m_pState->fRestoreLogs)
    {
        // If CDBBACKUP_VERIFYONLY, only verify the passed directory contains valid files
        // and detect INCREMENTAL
        hr = myRestoreDB(
            (LPCWSTR)m_pState->pCA->m_strConfig,
            CDBBACKUP_VERIFYONLY,
            (LPCWSTR)m_cstrLogsPath,
            NULL,
            NULL,
            NULL,
            NULL);
        _PrintIfError(hr, "myRestoreDB Full Restore");
        if (hr != S_OK)
        {
            hr = myRestoreDB(
                (LPCWSTR)m_pState->pCA->m_strConfig,
                CDBBACKUP_VERIFYONLY | CDBBACKUP_INCREMENTAL,
                (LPCWSTR)m_cstrLogsPath,
                NULL,
                NULL,
                NULL,
                NULL);
            _PrintIfError(hr, "myRestoreDB Incremental Restore");
            if (hr != S_OK)
            {
                DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_DIRECTORY_CONTENTS_UNEXPECTED);
                return -1;
            }

            // if incremental, set struct bool
            m_pState->fIncremental = TRUE;
        }
    }


    if (m_pState->fRestoreKeyCert ||
        m_pState->fRestoreLogs)
    {
        // free if exists
        if (m_pState->szLogsPath)
            LocalFree(m_pState->szLogsPath);

        // alloc anew
        m_pState->szLogsPath = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrLogsPath));

        // copy
        if (m_pState->szLogsPath)
            wcscpy(m_pState->szLogsPath, (LPCWSTR)m_cstrLogsPath);
    }


    // skip get password?
    if (!m_pState->fRestoreKeyCert)
        return IDD_RESTOREWIZ_COMPLETION;

    return 0;
}


///////////////////////////////////////////
// CRestoreWizPage3
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage3 property page
CRestoreWizPage3::CRestoreWizPage3(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_RESTOREWIZPG3);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_RESTOREWIZPG3);
	InitWizard97 (FALSE);
    m_cstrPwd = L"";

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CRestoreWizPage3::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrPwd.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_PASSWORD));
    }
    else
    {
        m_cstrPwd.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_PASSWORD));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CRestoreWizPage3::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}



BOOL CRestoreWizPage3::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CRestoreWizPage3::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

	return TRUE;
}

LRESULT CRestoreWizPage3::OnWizardNext()
{
    UpdateData(TRUE);

    // free if exists
    if (m_pState->szPassword)
        LocalFree(m_pState->szPassword);

    // alloc anew
    m_pState->szPassword = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrPwd));

    // copy
    if (m_pState->szPassword)
        wcscpy(m_pState->szPassword, (LPCWSTR)m_cstrPwd);

    return 0;   // advance
}


///////////////////////////////////////////
// CRestoreWizPage5
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage5 property page
CRestoreWizPage5::CRestoreWizPage5(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg, UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CRestoreWizPage5::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CRestoreWizPage5::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}



BOOL CRestoreWizPage5::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));


    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_COLUMN lvC = { (LVCF_FMT|LVCF_WIDTH), LVCFMT_LEFT, 0, NULL, 0, 0};

    lvC.cx = 675;
    ListView_InsertColumn(hList, 0, &lvC);

    return TRUE;
}

BOOL CRestoreWizPage5::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_FINISH));


    CString cstrDialogMsg;
    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_ITEM sItem; ZeroMemory(&sItem, sizeof(sItem));

    ListView_DeleteAllItems(hList);

    if (m_pState->fRestoreKeyCert)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_KEYANDCERT);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }
    if (m_pState->fRestoreLogs)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_CALOGS);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }

	return TRUE;
}


LRESULT CRestoreWizPage5::OnWizardBack()
{
    if (!m_pState->fRestoreKeyCert)
        return IDD_RESTOREWIZ_SELECT_DATA;

    return 0;
}





////////////////////////////////////////////////////////////////////
// misc UI throwing routines
DWORD CABackupWizard(CertSvrCA* pCertCA, HWND hwnd)
{
    HRESULT             hr;
    BACKUPWIZ_STATE     sBackupState; ZeroMemory(&sBackupState, sizeof(sBackupState));
    sBackupState.pCA = pCertCA;

    InitCommonControls();

    CWizard97PropertySheet cDlg(
			    g_hInstance,
			    IDS_BACKUP_WIZARD,
			    IDB_WIZ,
			    IDB_WIZ_HEAD,
			    TRUE);
    CBackupWizPage1    sPg1(&sBackupState, &cDlg);
    CBackupWizPage2    sPg2(&sBackupState, &cDlg);
    CBackupWizPage3    sPg3(&sBackupState, &cDlg);
    CBackupWizPage5    sPg5(&sBackupState, &cDlg);
    cDlg.AddPage(&sPg1);
    cDlg.AddPage(&sPg2);
    cDlg.AddPage(&sPg3);
    cDlg.AddPage(&sPg5);

    // if not started, start service
    if (!pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        CString cstrMsg, cstrTitle;
        cstrTitle.LoadString(IDS_BACKUP_WIZARD);
        cstrMsg.LoadString(IDS_START_SERVER_WARNING);
        if (IDOK != MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_OKCANCEL))
            return ERROR_CANCELLED;

        hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
        _JumpIfError(hr, Ret, "CertSvrStartStopService");
    }

    // should return value >0 on success
    if (0 >= cDlg.DoWizard(hwnd))
        return ERROR_CANCELLED;

    if (sBackupState.fBackupKeyCert)
    {
        hr = myCertServerExportPFX(
            (LPCWSTR)pCertCA->m_strCommonName,
            sBackupState.szLogsPath,
            sBackupState.szPassword,
            TRUE,
            TRUE, // must export private keys
            NULL);
        if (hr != S_OK)
        {
            CString cstrMsg, cstrTitle;
            cstrTitle.LoadString(IDS_BACKUP_WIZARD);
            cstrMsg.LoadString(IDS_PFX_EXPORT_PRIVKEY_WARNING);
            if (IDOK != MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_ICONWARNING|MB_OKCANCEL))
            {
                hr = ERROR_CANCELLED;
                _JumpError(hr, Ret, "myCertServerExportPFX user cancel");
            }

            hr = myCertServerExportPFX(
                (LPCWSTR)pCertCA->m_strCommonName,
                sBackupState.szLogsPath,
                sBackupState.szPassword,
                TRUE,
                FALSE, // don't require export private keys
                NULL);
            _JumpIfError(hr, Ret, "myCertServerExportPFX");
        }

    }   // sBackupState.fBackupKeyCert


    if (sBackupState.fBackupLogs)
    {
	    DBBACKUPPROGRESS dbp;
	    ZeroMemory(&dbp, sizeof(dbp));

        DWORD dwBackupFlags;
        dwBackupFlags = sBackupState.fIncremental ? CDBBACKUP_INCREMENTAL : 0;

        HANDLE hProgressThread = NULL;
        hProgressThread = StartPercentCompleteDlg(g_hInstance, hwnd, IDS_BACKUP_PROGRESS, &dbp);
        if (hProgressThread == NULL)
        {
            hr = GetLastError();
            _JumpError(hr, Ret, "StartPercentCompleteDlg");
        }

        hr = myBackupDB(
            (LPCWSTR)pCertCA->m_strConfig,
            dwBackupFlags,
            sBackupState.szLogsPath,
    	    &dbp);

        CSASSERT( (S_OK != hr) || (
                                (dbp.dwDBPercentComplete == 100) &&
                                (dbp.dwLogPercentComplete == 100) &&
                                (dbp.dwTruncateLogPercentComplete == 100) )
            );

        if (S_OK != hr)
        {
            dbp.dwDBPercentComplete = 100;
            dbp.dwLogPercentComplete = 100;
            dbp.dwTruncateLogPercentComplete = 100;
        }

        // pause for progress dlg to finish
        EndPercentCompleteDlg(hProgressThread);

        _JumpIfError(hr, Ret, "myBackupDB");
    }

    hr = S_OK;
Ret:
    if (sBackupState.szLogsPath)
        LocalFree(sBackupState.szLogsPath);

    if (sBackupState.szPassword)
        LocalFree(sBackupState.szPassword);

    return hr;
}

DWORD CARestoreWizard(CertSvrCA* pCertCA, HWND hwnd)
{
    HRESULT             hr;
    RESTOREWIZ_STATE    sRestoreState; ZeroMemory(&sRestoreState, sizeof(sRestoreState));
    sRestoreState.pCA = pCertCA;

    InitCommonControls();

    CWizard97PropertySheet cDlg(
			    g_hInstance,
			    IDS_RESTORE_WIZARD,
			    IDB_WIZ,
			    IDB_WIZ_HEAD,
			    TRUE);
    CRestoreWizPage1    sPg1(&sRestoreState, &cDlg);
    CRestoreWizPage2    sPg2(&sRestoreState, &cDlg);
    CRestoreWizPage3    sPg3(&sRestoreState, &cDlg);
    CRestoreWizPage5    sPg5(&sRestoreState, &cDlg);
    cDlg.AddPage(&sPg1);
    cDlg.AddPage(&sPg2);
    cDlg.AddPage(&sPg3);
    cDlg.AddPage(&sPg5);

    // if not halted, stop service
    if (pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        CString cstrMsg, cstrTitle;
        cstrTitle.LoadString(IDS_RESTORE_WIZARD);
        cstrMsg.LoadString(IDS_STOP_SERVER_WARNING);
        if (IDOK != MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_OKCANCEL))
            return ERROR_CANCELLED;

        hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, FALSE);
        _JumpIfError(hr, Ret, "CertSvrStartStopService");
    }


    // should return value >0 on success
    if (0 >= cDlg.DoWizard(hwnd))
        return ERROR_CANCELLED;

    if (sRestoreState.fRestoreKeyCert)
    {
        hr = myCertServerImportPFX(
            sRestoreState.szLogsPath,
            sRestoreState.szPassword,
            TRUE,
            NULL,
            NULL,
            NULL);
        _JumpIfError(hr, Ret, "myCertServerImportPFX");

        if (!sRestoreState.fRestoreLogs)
        {
             // if we're not restoring db, restart svc now
             hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
             _JumpIfError(hr, Ret, "CertSvrStartStopService");
        }
    }

    if (sRestoreState.fRestoreLogs)
    {
        DBBACKUPPROGRESS dbp;
        ZeroMemory(&dbp, sizeof(dbp));

        DWORD dwFlags = CDBBACKUP_OVERWRITE;
        dwFlags |= sRestoreState.fIncremental ? CDBBACKUP_INCREMENTAL : 0;


        HANDLE hProgressThread = NULL;
        hProgressThread = StartPercentCompleteDlg(g_hInstance, hwnd, IDS_RESTORE_PROGRESS, &dbp);
        if (hProgressThread == NULL)
        {
            hr = GetLastError();
            _JumpError(hr, Ret, "StartPercentCompleteDlg");
        }

        hr = myRestoreDB(
            (LPCWSTR)pCertCA->m_strConfig,
            dwFlags,
            sRestoreState.szLogsPath,
            NULL,
            NULL,
            NULL,
            &dbp);

        CSASSERT( (S_OK != hr) || (
                                (dbp.dwDBPercentComplete == 100) &&
                                (dbp.dwLogPercentComplete == 100) &&
                                (dbp.dwTruncateLogPercentComplete == 100) )
            );

        if (S_OK != hr)
        {
            dbp.dwDBPercentComplete = 100;
            dbp.dwLogPercentComplete = 100;
            dbp.dwTruncateLogPercentComplete = 100;
        }

        // pause for progress dlg to finish
        EndPercentCompleteDlg(hProgressThread);

        _JumpIfError(hr, Ret, "myRestoreDB");

        {
            CString cstrMsg, cstrTitle;
            cstrTitle.LoadString(IDS_RESTORE_WIZARD);
            cstrMsg.LoadString(IDS_INCRRESTORE_RESTART_SERVER_WARNING);
            if (IDYES == MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_ICONWARNING|MB_YESNO))
            {
                // start svc to complete db restore
                hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
                _PrintIfError(hr, "CertSvrStartStopService Restore");

                if (hr != S_OK)
                {
                    // remove "restore pending" mark
                    myRestoreDB(
                        pCertCA->m_strConfig,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

                    goto Ret;
                }
            }
        }

    }

    hr = S_OK;
Ret:
    if (sRestoreState.szLogsPath)
        LocalFree(sRestoreState.szLogsPath);

    if (sRestoreState.szPassword)
        LocalFree(sRestoreState.szPassword);

    return hr;
}


DWORD CARequestInstallHierarchyWizard(CertSvrCA* pCertCA, HWND hwnd, BOOL fRenewal, BOOL fAttemptRestart)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwFlags = CSRF_INSTALLCACERT;
    BOOL fServiceWasRunning = FALSE;

    // stop/start msg
    if (pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        fServiceWasRunning = TRUE;
        // service must be stopped to complete hierarchy
        CString cstrMsg, cstrTitle;
        cstrMsg.LoadString(IDS_STOP_SERVER_WARNING);
        cstrTitle.LoadString(IDS_INSTALL_HIERARCHY_TITLE);
        if (IDYES != MessageBox(hwnd, cstrMsg, cstrTitle, MB_YESNO))
            return ERROR_CANCELLED;

        // stop
        dwErr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, FALSE);
        _JumpIfError(dwErr, Ret, "CertSvrStartStopService");
    }

    if (fRenewal)
    {
        BOOL fReuseKeys = FALSE;
        dwErr = (DWORD)DialogBoxParam(
                g_hInstance,
                MAKEINTRESOURCE(IDD_RENEW_REUSEKEYS),
                hwnd,
                dlgProcRenewReuseKeys,
                (LPARAM)&fReuseKeys);

        // translate ok/cancel into error codes
        if (dwErr == IDOK)
            dwErr = ERROR_SUCCESS;
        else if (dwErr == IDCANCEL)
            dwErr = ERROR_CANCELLED;

        _JumpIfError(dwErr, Ret, "dlgProcRenewalReuseKeys");

	dwFlags = CSRF_RENEWCACERT | CSRF_OVERWRITE;
        if (!fReuseKeys)
	    dwFlags |= CSRF_NEWKEYS;
    }

    // do actual install
    dwErr = CertServerRequestCACertificateAndComplete(
                g_hInstance,			// hInstance
                hwnd,				// hwnd
                dwFlags,	                // Flags
                pCertCA->m_strCommonName,	// pwszCAName
                NULL,				// pwszParentMachine
                NULL,				// pwszParentCA
		NULL,				// pwszCAChainFile
                NULL);				// pwszRequestFile
    _JumpIfError(dwErr, Ret, "CertServerRequestCACertificateAndComplete");

Ret:
    // start svc
    if ((fAttemptRestart) && fServiceWasRunning)
    {
        DWORD dwErr2;
        dwErr2 = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
        if (dwErr == S_OK)
        {
           dwErr = dwErr2;
           _PrintIfError(dwErr2, "CertSvrStartStopService");
        }
    }

    return dwErr;
}


typedef struct _PRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM
{
    BOOL fCurrentCRLValid; // IN
    BOOL fDeltaCRLEnabled; // IN
    BOOL fPublishBaseCRL;  // OUT
} PRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM, *PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM;


DWORD PublishCRLWizard(CertSvrCA* pCertCA, HWND hwnd)
{
    DWORD dwErr = ERROR_SUCCESS;
    ICertAdmin2* pAdmin = NULL;  // free this
    PCCRL_CONTEXT   pCRLCtxt = NULL;    // free this

    DATE dateGMT = 0.0;
    BSTR bstrConfig;
    PBYTE pbTmp = NULL;    // free this
    DWORD dwCRLFlags;
    variant_t var;

    // UNDONE: might need to check validity of DELTA crl as well as base
    PRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM sParam = {FALSE, FALSE, FALSE};

    // grab DELTA period count to see if deltas are enabled
    dwErr = pCertCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTAPERIODCOUNT,
            &var);
    _JumpIfError(dwErr, Ret, "GetConfigEntry");

    CSASSERT(V_VT(&var)==VT_I4);
    sParam.fDeltaCRLEnabled = ( -1 != (V_I4(&var)) ) && (0 != (V_I4(&var))); //0, -1 mean disabled

    // now check validity and determine whether to display warning
    // UNDONE: check validity of delta crls?
    dwErr = pCertCA->GetCurrentCRL(&pCRLCtxt, TRUE);
    _PrintIfError(dwErr, "GetCurrentCRL");

    if ((dwErr == S_OK) && (NULL != pCRLCtxt))
    {
        // check validity of outstanding CRL
        dwErr = CertVerifyCRLTimeValidity(
            NULL,
            pCRLCtxt->pCrlInfo);
        // 0 -> current CRL already exists
        if (dwErr == 0)
            sParam.fCurrentCRLValid = TRUE;
    }
    else
    {
        // assume this is funky overwrite case
        sParam.fCurrentCRLValid = TRUE;
    }

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_PUBLISHCRL),
            hwnd,
            dlgProcRevocationPublishType,
            (LPARAM)&sParam);

    // translate ok/cancel into error codes
    if (dwErr == IDOK)
        dwErr = ERROR_SUCCESS;
    else if (dwErr == IDCANCEL)
        dwErr = ERROR_CANCELLED;
    _JumpIfError(dwErr, Ret, "dlgProcRevocationPublishType");


    // publish Delta CRLs if ( !sParam.fPublishBaseCRL )
    dwErr = pCertCA->m_pParentMachine->GetAdmin2(&pAdmin);
    _JumpIfError(dwErr, Ret, "GetAdmin");

    // now publish CRL valid for normal period (dateGMT=0.0 defaults to regular period length)
    dwCRLFlags = 0;
    if (sParam.fDeltaCRLEnabled)
        dwCRLFlags |= CA_CRL_DELTA;
    if (sParam.fPublishBaseCRL)
        dwCRLFlags |= CA_CRL_BASE;

    {
        CWaitCursor hourglass;

        dwErr = pAdmin->PublishCRLs(pCertCA->m_bstrConfig, dateGMT, dwCRLFlags);
        _JumpIfError(dwErr, Ret, "PublishCRLs");
    }

Ret:
    if (pAdmin)
        pAdmin->Release();

    if (pCRLCtxt)
        CertFreeCRLContext(pCRLCtxt);

    return dwErr;
}



DWORD CertAdminRevokeCert(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lReasonCode, LPWSTR szCertSerNum)
{
    DWORD dwErr;
    BSTR bstrSerNum = NULL;
    DATE dateNow = 0.0;     // now

    if (pAdmin == NULL)
        return ERROR_INVALID_PARAMETER;


    bstrSerNum = SysAllocString(szCertSerNum);
    _JumpIfOutOfMemory(dwErr, Ret, bstrSerNum);

    dwErr = pAdmin->RevokeCertificate(
            pCertCA->m_bstrConfig,
            bstrSerNum,
            lReasonCode,
            dateNow);
    _JumpIfError(dwErr, Ret, "RevokeCertificate");

Ret:
    if (bstrSerNum)
        SysFreeString(bstrSerNum);

    return dwErr;
}


DWORD CertAdminResubmitRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID)
{
    DWORD dwErr;
    LONG lDisposition;

    dwErr = pAdmin->ResubmitRequest(
            pCertCA->m_bstrConfig,
            lRequestID,
            &lDisposition);
    _JumpIfError(dwErr, Ret, "ResubmitRequest");

Ret:
    return dwErr;
}

DWORD CertAdminDenyRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID)
{
    DWORD dwErr;
    LONG lDisposition;

    dwErr = pAdmin->DenyRequest(
            pCertCA->m_bstrConfig,
            lRequestID);
    _JumpIfError(dwErr, Ret, "DenyRequest");

Ret:
    return dwErr;
}


typedef struct _QUERY_COLUMN_HEADINGS
{
    UINT    iRscID;
    DWORD   cbColWidth;
} QUERY_COLUMN_HEADINGS;

QUERY_COLUMN_HEADINGS g_colHeadings[] =
{
    {   IDS_COLUMNCHOOSER_FIELDNAME,  90        },
    {   IDS_COLUMNCHOOSER_OPERATOR,   55        },
    {   IDS_COLUMNCHOOSER_VALUE,      150       },
};


void RefreshListView(HWND hwndList, QUERY_RESTRICTION* pRestrict)
{
    HRESULT hr;
    ListView_DeleteAllItems(hwndList);		

    LVITEM sNewItem;
    ZeroMemory(&sNewItem, sizeof(sNewItem));

    int iSubItem;

    // while there are restrictions
    while(pRestrict)
    {
        iSubItem = 0;
        ListView_InsertItem(hwndList, &sNewItem);

        LPCWSTR szLocalizedCol;
        hr = myGetColumnDisplayName(
                pRestrict->szField,
                &szLocalizedCol);
        _PrintIfError(hr, "myGetColumnDisplayName");
        if (S_OK == hr)
		{

			ListView_SetItemText(hwndList, sNewItem.iItem, iSubItem++, (LPWSTR)szLocalizedCol);
			ListView_SetItemText(hwndList, sNewItem.iItem, iSubItem++, (LPWSTR)OperationToStr(pRestrict->iOperation));

			VARIANT vtString;
			VariantInit(&vtString);

			if (MakeDisplayStrFromDBVariant(&pRestrict->varValue, &vtString))
			{
				ListView_SetItemText(hwndList, sNewItem.iItem, iSubItem++, vtString.bstrVal);
				VariantClear(&vtString);
			}

	        sNewItem.iItem++;
		}

        // fwd to next elt
        pRestrict = pRestrict->pNext;
    }

    return;
}


#define     MAX_FIELD_SIZE  128

typedef struct _PRIVATE_DLGPROC_QUERY_LPARAM
{
    // this is the restriction, modify in-place
    PQUERY_RESTRICTION*         ppRestrict;

    // CFolder for read-only data
//    CFolder*                    pFolder;
    CComponentDataImpl*         pCompData;

} PRIVATE_DLGPROC_QUERY_LPARAM, *PPRIVATE_DLGPROC_QUERY_LPARAM;

//////////////////////////////////////////////////////////////////
// New Query Dialog
INT_PTR CALLBACK dlgProcQuery(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    HRESULT hr;
    PQUERY_RESTRICTION* ppRestrict = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember PRIVATE_DLGPROC_QUERY_LPARAM
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
            ppRestrict = ((PRIVATE_DLGPROC_QUERY_LPARAM*)lParam)->ppRestrict;

            HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);

            // insert possible operators
            for (int i=0; i<ARRAYLEN(g_colHeadings); i++)
            {
                CString cstrTmp;
                cstrTmp.LoadString(g_colHeadings[i].iRscID);
                ListView_NewColumn(hwndList, i, g_colHeadings[i].cbColWidth, (LPWSTR)(LPCWSTR)cstrTmp);
            }

            // don't show deletion buttons if no items to delete
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), (*ppRestrict!=NULL));
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), (*ppRestrict!=NULL));

            RefreshListView(hwndList, *ppRestrict);

            return 1;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_DEFINE_QUERY);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_DEFINE_QUERY);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_DELETE_RESTRICTION:
            {
                ppRestrict = (PQUERY_RESTRICTION*) ((PRIVATE_DLGPROC_QUERY_LPARAM*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->ppRestrict;
                PQUERY_RESTRICTION pPrevRestriction = NULL, pRestriction = ppRestrict[0];
                LRESULT iSel;

                HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);
                int iItems = ListView_GetItemCount(hwndList);

                // find selected item
                for(iSel=0; iSel<(LRESULT)iItems; iSel++)
                {
                    UINT ui = ListView_GetItemState(hwndList, iSel, LVIS_SELECTED);
                    if (ui == LVIS_SELECTED)
                        break;
                }

                // no selected item
                if (iSel == iItems)
                    break;

                // walk to it in the list
                for(LRESULT lr=0; lr<iSel; lr++)
                {
                    // walked off end of list
                    if (NULL == pRestriction)
                        break;

                    // step fwd in list
                    pPrevRestriction = pRestriction;
                    pRestriction = pRestriction->pNext;
                }

                // if item exists, remove from list & free it
                if (pRestriction)
                {
                    if (pPrevRestriction)
                    {
                        // ppRestrict is still valid, this wasn't the head elt
                        pPrevRestriction->pNext = pRestriction->pNext;
                    }
                    else
                    {
                        // reset NEXT as the head elt
                        *ppRestrict = pRestriction->pNext;
                    }
                    FreeQueryRestriction(pRestriction);

                    // don't show deletion buttons if no items to delete
                    ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), (*ppRestrict!=NULL));
                    ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), (*ppRestrict!=NULL));

                    RefreshListView(hwndList, *ppRestrict);
                }

            }
            break;
        case IDC_RESET_BUTTON:
            {
                ppRestrict = (PQUERY_RESTRICTION*) ((PRIVATE_DLGPROC_QUERY_LPARAM*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->ppRestrict;
                FreeQueryRestrictionList(*ppRestrict);
                *ppRestrict = NULL;

                ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), FALSE);
                ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), FALSE);

                HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);
                RefreshListView(hwndList, *ppRestrict);
            }
            break;
        case IDC_ADD_RESTRICTION:
            {
                LPARAM mylParam = GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	            ppRestrict = (PQUERY_RESTRICTION*) ((PRIVATE_DLGPROC_QUERY_LPARAM*)mylParam)->ppRestrict;

				if (IDOK == DialogBoxParam(
						g_hInstance,
						MAKEINTRESOURCE(IDD_NEW_RESTRICTION),
						hwndDlg,
						dlgProcAddRestriction,
						mylParam))
				{
                                       // show deletion buttons if items to delete
                                       ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), (*ppRestrict!=NULL));
                                       ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), (*ppRestrict!=NULL));

					HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);
					RefreshListView(hwndList, *ppRestrict);
				}
            }
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


HRESULT SetTimePickerNoSeconds(HWND hwndPicker)
{
    HRESULT hr = S_OK;

    //
    // Setup the time picker controls to use a short time format with no seconds.
    //
    WCHAR   szTimeFormat[MAX_PATH]  = {0};
    LPTSTR  pszTimeFormat           = szTimeFormat;

    WCHAR   szTimeSep[MAX_PATH]     = {0};
    int     cchTimeSep;

    WCHAR   szShortTimeFormat[MAX_PATH];
    LPWSTR  pszShortTimeFormat = szShortTimeFormat;

    if(0 == GetLocaleInfo( LOCALE_USER_DEFAULT,
                       LOCALE_STIMEFORMAT,
                       szTimeFormat,
                       ARRAYLEN(szTimeFormat)))
    {
        hr = GetLastError();
        _JumpError(hr, Ret, "GetLocaleInfo");
    }

    cchTimeSep = GetLocaleInfo( LOCALE_USER_DEFAULT,
                   LOCALE_STIME,
                   szTimeSep,
                   ARRAYLEN(szTimeSep));
    if (0 == cchTimeSep)
    {
        hr = GetLastError();
        _JumpError(hr, Ret, "GetLocaleInfo");
    }
    cchTimeSep--; // number of chars not including NULL

    //
    // Remove the seconds format string and preceeding separator.
    //
    while (*pszTimeFormat)
    {
        if ((*pszTimeFormat != L's') && (*pszTimeFormat != L'S'))
        {
            *pszShortTimeFormat++ = *pszTimeFormat;
        }
        else
        {
            // NULL terminate here so we can strcmp
            *pszShortTimeFormat = L'\0';

            LPWSTR p = pszShortTimeFormat;

            // trim preceeding off

            // rewind one char
            p--;
            if (p >= szShortTimeFormat)  // we didn't rewind too far
            {
                if (*p == L' ')
                    pszShortTimeFormat = p;   // skip space
                else
                {
                    p -= (cchTimeSep-1);        // p already backstepped one char
                    if (0 == lstrcmp(p, szTimeSep))
                        pszShortTimeFormat = p;    // skip szTimeSep
                }
            }
        }

        pszTimeFormat++;
    }

    // zero-terminate
    *pszShortTimeFormat = L'\0';

    //
    // If we have retrived a valid time format string then use it,
    // else use the default format string implemented by common control.
    //
    DateTime_SetFormat(hwndPicker, szShortTimeFormat);

Ret:
    return hr;
}

INT_PTR CALLBACK dlgProcAddRestriction(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    typedef struct _DROPDOWN_FIELD_PARAM
    {
        DWORD dwPropType;
        DWORD dwIndexed;
        LPWSTR szUnlocalized;
    } DROPDOWN_FIELD_PARAM, *PDROPDOWN_FIELD_PARAM;

    HRESULT hr;
    PQUERY_RESTRICTION* ppRestrict = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember PQUERY_RESTRICTION
            ppRestrict = ((PRIVATE_DLGPROC_QUERY_LPARAM*)lParam)->ppRestrict;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)ppRestrict);

            // Not a huge failure,  worst case:
            // we don't call DateTime_SetFormat and the user gets a seconds picker
            SetTimePickerNoSeconds(GetDlgItem(hwndDlg, IDC_TIMEPICKER_NEWQUERY));

            {
                // insert all column names
                CComponentDataImpl* pCompData = ((PRIVATE_DLGPROC_QUERY_LPARAM*)lParam)->pCompData;
                HWND hFieldDropdown = GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_FIELD);
                for(DWORD i=0; i<pCompData->GetSchemaEntries(); i++)
                {
                    LPCWSTR pszLocal;
                    LPCWSTR szColName=NULL;
                    LONG lType, lIndexed;
                    if (S_OK == pCompData->GetDBSchemaEntry(i, &szColName, &lType, (BOOL*)&lIndexed))
                    {
                        // skip filter types we can't parse
                        if (PROPTYPE_BINARY == lType)
                            continue;

                        hr = myGetColumnDisplayName(
                            szColName,
                            &pszLocal);
                        _PrintIfError(hr, "myGetColumnDisplayName");
                        if (S_OK != hr)
                            continue;

                        INT nItemIndex = (INT)SendMessage(hFieldDropdown, CB_ADDSTRING, 0, (LPARAM)pszLocal);

                        // prepare the data parameter
                        PDROPDOWN_FIELD_PARAM pField = (PDROPDOWN_FIELD_PARAM)new BYTE[sizeof(DROPDOWN_FIELD_PARAM) + WSZ_BYTECOUNT(szColName)];
                        if (pField != NULL)
                        {
                            pField->dwPropType = lType;
                            pField->dwIndexed = lIndexed;
                            pField->szUnlocalized = (LPWSTR)((BYTE*)pField + sizeof(DROPDOWN_FIELD_PARAM));
                            wcscpy(pField->szUnlocalized, szColName);

                            SendMessage(hFieldDropdown, CB_SETITEMDATA, (WPARAM)nItemIndex, (LPARAM) pField);
                        }
                    }
                }

                // set a default selection
                SendMessage(hFieldDropdown, CB_SETCURSEL, 0, 0);
                SendMessage(hwndDlg, WM_COMMAND, MAKEWPARAM(IDC_EDIT_NEWQUERY_FIELD, LBN_SELCHANGE), (LPARAM)hFieldDropdown);

                HWND hOperationDropdown = GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_OPERATION);
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L"<");
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L"<=");
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L">=");
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L">");

                INT iDefSel = (INT)SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L"=");
                SendMessage(hOperationDropdown, CB_SETCURSEL, iDefSel, 0);
            }

            return 1;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_NEW_RESTRICTION);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_NEW_RESTRICTION);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_EDIT_NEWQUERY_FIELD:
            {
                if (HIWORD(wParam) == LBN_SELCHANGE)
                {
                    // On selection change, ask for the right format
                    int nItemIndex;
                    nItemIndex = (INT)SendMessage((HWND)lParam,
                        CB_GETCURSEL,
                        0,
                        0);

                    DROPDOWN_FIELD_PARAM* pField = NULL;
                    pField = (PDROPDOWN_FIELD_PARAM) SendMessage(
                            (HWND)lParam,
                            CB_GETITEMDATA,
                            (WPARAM)nItemIndex,
                            0);
                    if (CB_ERR == (DWORD_PTR)pField)
                        break;  // get out of here

                    BOOL fShowPickers = (pField->dwPropType == PROPTYPE_DATE);

                    // swap entry mode to/from datetime pickers
                    ShowWindow(GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_VALUE), fShowPickers ? SW_HIDE : SW_SHOW);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DATEPICKER_NEWQUERY), fShowPickers ? SW_SHOW : SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_TIMEPICKER_NEWQUERY), fShowPickers ? SW_SHOW : SW_HIDE);
                }
            }
            break;
        case IDOK:
            {
                ppRestrict = (PQUERY_RESTRICTION*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);


                WCHAR szFieldName[MAX_FIELD_SIZE+1];
                WCHAR szValue[MAX_FIELD_SIZE+1];
                WCHAR szOp[10];

                GetDlgItemText(hwndDlg, IDC_EDIT_NEWQUERY_VALUE, szValue, MAX_FIELD_SIZE);
                GetDlgItemText(hwndDlg, IDC_EDIT_NEWQUERY_OPERATION, szOp, ARRAYLEN(szOp)-1);
                GetDlgItemText(hwndDlg, IDC_EDIT_NEWQUERY_FIELD, szFieldName, MAX_FIELD_SIZE);


                DROPDOWN_FIELD_PARAM* pField = NULL;

                VARIANT vt;
                VariantInit(&vt);

                // parsing code
                {
                    HWND hFieldDropdown = GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_FIELD);
		    BOOL fValidDigitString;

                    INT nItemIndex = (INT)SendMessage(hFieldDropdown,
                        CB_GETCURSEL,
                        0,
                        0);

                    pField = (PDROPDOWN_FIELD_PARAM)SendMessage(
                        hFieldDropdown,
                        CB_GETITEMDATA,
                        (WPARAM)nItemIndex,
                        0);

                    if ((NULL == pField) || (CB_ERR == (DWORD_PTR)pField))
                        break;

                    switch(pField->dwPropType)
                    {
                    case PROPTYPE_LONG:
                        vt.vt = VT_I4;
                        vt.lVal = myWtoI(szValue, &fValidDigitString);
                        break;
                    case PROPTYPE_STRING:
                        vt.vt = VT_BSTR;
                        vt.bstrVal = _wcslwr(szValue);
                        break;
                    case PROPTYPE_DATE:
                        {
                            SYSTEMTIME stDate, stTime;
                            hr = DateTime_GetSystemtime(GetDlgItem(hwndDlg, IDC_DATEPICKER_NEWQUERY), &stDate);
                            _PrintIfError(hr, "DateTime_GetSystemtime");
                            if (hr != S_OK)
                                break;

                            hr = DateTime_GetSystemtime(GetDlgItem(hwndDlg, IDC_TIMEPICKER_NEWQUERY), &stTime);
                            _PrintIfError(hr, "DateTime_GetSystemtime");
                            if (hr != S_OK)
                                break;

                            // merge the two structures
                            stTime.wYear = stDate.wYear;
                            stTime.wMonth = stDate.wMonth;
                            stTime.wDayOfWeek = stDate.wDayOfWeek;
                            stTime.wDay = stDate.wDay;

                            // convert to GMT
                            hr = mySystemTimeToGMTSystemTime(&stTime);
                            _PrintIfError(hr, "mySystemTimeToGMTSystemTime");
                            if (hr != S_OK)
                                break;

                            stTime.wSecond = 0;
                            stTime.wMilliseconds = 0;

                            // inject into variant
                            if (!SystemTimeToVariantTime(&stTime, &vt.date))
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                                _PrintError(hr, "SystemTimeToVariantTime");
                                break;
                            }
                            vt.vt = VT_DATE;
                        }
                        break;
                    case PROPTYPE_BINARY:
                        {
                            CString cstrMsg, cstrTitle;
                            cstrMsg.LoadString(IDS_FILTER_NOT_SUPPORTED);
                            cstrTitle.LoadString(IDS_MSG_TITLE);
                            MessageBoxW(hwndDlg, cstrMsg, cstrTitle, MB_OK);
                        }
                        break;
                    default:
                        break;
                    }
                }

                // if we didn't get column
                if (VT_EMPTY == vt.vt)
                    break;


                // copy into new struct
                QUERY_RESTRICTION* pNewRestrict = NewQueryRestriction(
                        pField->szUnlocalized, // UnlocalizeColName(szFieldName),
                        StrToOperation(szOp),
                        &vt);

                if (pNewRestrict)
                {
                    // add restriction only if not already present
                    if(!QueryRestrictionFound(pNewRestrict, *ppRestrict))
                    {
                        // don't call VarClear -- it'll try to SysFree the non-bstr!
                        VariantInit(&vt);

                        // insert into list
                        ListInsertAtEnd((void**)ppRestrict, pNewRestrict);

                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)ppRestrict);
                    }
                    else
                    {
                        FreeQueryRestriction(pNewRestrict);
                    }
                }
            }
        case IDCANCEL:
            // cleanup
            {
                INT cItems = (INT)::SendDlgItemMessage(hwndDlg, IDC_EDIT_NEWQUERY_FIELD, CB_GETCOUNT, 0, 0);
                while(cItems--)
                {
                    PBYTE pb = (PBYTE)::SendDlgItemMessage(hwndDlg, IDC_EDIT_NEWQUERY_FIELD, CB_GETITEMDATA, (WPARAM)cItems, 0);
                    delete [] pb;
                }
            }

            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


typedef struct _CHOOSEMODULE_MODULEDEF
{
    LPOLESTR pszprogidModule;
    CLSID clsidModule;
} CHOOSEMODULE_MODULEDEF, *PCHOOSEMODULE_MODULEDEF;


void FreeChooseModuleDef(PCHOOSEMODULE_MODULEDEF psModuleDef)
{
    if (psModuleDef)
    {
        if (psModuleDef->pszprogidModule)
        {
            CoTaskMemFree(psModuleDef->pszprogidModule);
        }

        LocalFree(psModuleDef);
    }
}


INT_PTR CALLBACK dlgProcChooseModule(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    BOOL fReturn = FALSE;
    HRESULT hr;
    PPRIVATE_DLGPROC_MODULESELECT_LPARAM pParam = NULL;

    HKEY hRemoteMachine = NULL;


    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            pParam = (PRIVATE_DLGPROC_MODULESELECT_LPARAM*)lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)pParam);

            ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_RESETCONTENT, 0, 0);

            CString cstrTitle;
            if (pParam->fIsPolicyModuleSelection)
                cstrTitle.LoadString(IDS_CHOOSEMODULE_POLICY_TITLE);
            else
                cstrTitle.LoadString(IDS_CHOOSEMODULE_EXIT_TITLE);
            ::SetWindowText(hwndDlg, (LPCWSTR)cstrTitle);

            // grab current default, watch for it to float by during enum
            DWORD   dwCurrentSelection = 0;

            LPWSTR pszKeyName = NULL;
            DISPATCHINTERFACE di;
            BOOL fMustRelease = FALSE;
            PCHOOSEMODULE_MODULEDEF psModuleDef = NULL;

            if (! pParam->pCA->m_pParentMachine->IsLocalMachine())
            {
                hr = RegConnectRegistry(
                    pParam->pCA->m_pParentMachine->m_strMachineName,
                    HKEY_CLASSES_ROOT,
                    &hRemoteMachine);
                _PrintIfError(hr, "RegConnectRegistry");
                if (S_OK != hr)
                    break;
            }


            for (DWORD dwIndex=0; ; /*dwIndex++*/)
            {
                HKEY  hkeyEachMod = NULL;
                LPWSTR pszTermination;
                DWORD cb, dwType;
                PBYTE pb=NULL;

                DWORD cDispatch = 0;

                if (NULL != pszKeyName)
                {
                    LocalFree(pszKeyName);
                    pszKeyName = NULL;
                }

                if (fMustRelease)
                {
                    ManageModule_Release(&di);
                    fMustRelease = FALSE;
                }

                FreeChooseModuleDef(psModuleDef);

                psModuleDef = (PCHOOSEMODULE_MODULEDEF)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(CHOOSEMODULE_MODULEDEF));
                if (NULL == psModuleDef)
                {
                    hr = E_OUTOFMEMORY;
                    _PrintError(hr, "LocalAlloc");
                    break;
                }

                pszKeyName = RegEnumKeyContaining(
                    (hRemoteMachine != NULL) ? hRemoteMachine : HKEY_CLASSES_ROOT,
                    pParam->fIsPolicyModuleSelection? wszCERTPOLICYMODULE_POSTFIX : wszCERTEXITMODULE_POSTFIX,
                    &dwIndex);
                if (NULL == pszKeyName)
                {
                    hr = GetLastError();
                    _PrintError(hr, "RegEnumKeyContaining");
                    break;
                }

                // make sure it _ends_ with the specified string
                DWORD chSubStrShouldStartAt = (wcslen(pszKeyName) -
                    wcslen(pParam->fIsPolicyModuleSelection ? wszCERTPOLICYMODULE_POSTFIX : wszCERTEXITMODULE_POSTFIX) );

                if (0 != wcscmp(
                    &pszKeyName[chSubStrShouldStartAt],
                    pParam->fIsPolicyModuleSelection?
                        wszCERTPOLICYMODULE_POSTFIX : wszCERTEXITMODULE_POSTFIX))
                    continue;

                psModuleDef->pszprogidModule = (LPOLESTR)CoTaskMemAlloc(WSZ_BYTECOUNT(pszKeyName));
                if (NULL == psModuleDef->pszprogidModule)
                {
                    hr = E_OUTOFMEMORY;
                    _PrintError(hr, "CoTaskMemAlloc");
                    break;
                }
                wcscpy(psModuleDef->pszprogidModule, pszKeyName);

                hr = CLSIDFromProgID(psModuleDef->pszprogidModule, &psModuleDef->clsidModule);
                _PrintIfError(hr, "CLSIDFromProgID");
                if (S_OK != hr)
                    continue;   // module clsid not found? ouch!
                
                if(pParam->fIsPolicyModuleSelection)
                {
                    hr = GetPolicyManageDispatch(
                        psModuleDef->pszprogidModule,
                        psModuleDef->clsidModule,
                        &di);
                    _PrintIfErrorStr(hr, "GetPolicyManageDispatch", psModuleDef->pszprogidModule);
                }
                else
                {
                    hr = GetExitManageDispatch(
                        psModuleDef->pszprogidModule,
                        psModuleDef->clsidModule,
                        &di);
                    _PrintIfErrorStr(hr, "GetExitManageDispatch", psModuleDef->pszprogidModule);
                }
                if (hr != S_OK)
                    continue;

                fMustRelease = TRUE;

                BSTR bstrName = NULL;
                BSTR bstrStorageLoc = NULL;
                LPWSTR szFullStoragePath = NULL;

//                ASSERT( pParam->pCA->m_pParentMachine->IsLocalMachine());

                // get the storage path
                CString cstrStoragePath;

                cstrStoragePath = wszREGKEYCONFIGPATH_BS;
                cstrStoragePath += pParam->pCA->m_strSanitizedName;
                cstrStoragePath += TEXT("\\");
                cstrStoragePath += pParam->fIsPolicyModuleSelection?
                                    wszREGKEYPOLICYMODULES:
                                    wszREGKEYEXITMODULES;
                cstrStoragePath += TEXT("\\");
                cstrStoragePath += psModuleDef->pszprogidModule;

                bstrStorageLoc = SysAllocString(cstrStoragePath);
                if (bstrStorageLoc == NULL)
                {
                    _PrintError(E_OUTOFMEMORY, "SysAllocString");
                    continue;
                }

                BSTR bstrPropertyName = SysAllocString(wszCMM_PROP_NAME);
                if (bstrPropertyName == NULL)
                {
                    _PrintError(E_OUTOFMEMORY, "SysAllocString");
                    continue;
                }

                // get name property
                hr = ManageModule_GetProperty(&di, pParam->pCA->m_bstrConfig, bstrStorageLoc, bstrPropertyName, 0, PROPTYPE_STRING, &bstrName);
                _PrintIfError(hr, "ManageModule_GetProperty");
                if(S_OK==hr)
                {
                    myRegisterMemAlloc(bstrName, -1, CSM_SYSALLOC);
                }

                if (bstrStorageLoc)
                {
                    SysFreeString(bstrStorageLoc);
                    bstrStorageLoc = NULL;
                }
                if (bstrPropertyName)
                {
                    SysFreeString(bstrPropertyName);
                    bstrPropertyName = NULL;
                }

                if (hr != S_OK)
                {
                    // Bug #236267: module instantiated but GetProperty returns error
                    // notify user and continue
                    CString cstrMsg, cstrFmt;
                    cstrFmt.LoadString(IDS_ICMM_GETNAMEPROPERTY_FAILED);
                    cstrMsg.Format(cstrFmt, psModuleDef->pszprogidModule);

                    DisplayCertSrvErrorWithContext(hwndDlg, hr, (LPCWSTR)cstrMsg);

                    if (bstrName)
                        SysFreeString(bstrName);

                    continue;
                }

                // No error (but no name)
                if (bstrName == NULL)
                    continue;

                // add to listbox
                INT idxInsertion;
                idxInsertion = (INT)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_ADDSTRING, 0, (LPARAM)bstrName);

                SysFreeString(bstrName);
                bstrName = NULL;

                // add module defn as item data
                ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_SETITEMDATA, idxInsertion, (LPARAM)psModuleDef);

                if (0 == memcmp(&psModuleDef->clsidModule, pParam->pclsidModule, sizeof(CLSID)))
                    dwCurrentSelection = idxInsertion;

                psModuleDef = NULL; // dlg owns memory
            }

            FreeChooseModuleDef(psModuleDef);

            if (NULL != pszKeyName)
                LocalFree(pszKeyName);

            if (fMustRelease)
            {
                ManageModule_Release(&di);
            }

            ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_SETCURSEL, (WPARAM)dwCurrentSelection, 0);

            // no other work to be done
            fReturn = TRUE;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CHOOSE_MODULE);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CHOOSE_MODULE);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                pParam = (PPRIVATE_DLGPROC_MODULESELECT_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                // detect selection, chg registry settings
                DWORD dwSel = (DWORD)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETCURSEL, 0, 0);
                if (LB_ERR != dwSel)
                {
                    PCHOOSEMODULE_MODULEDEF psModuleDef = NULL;
                    psModuleDef = (PCHOOSEMODULE_MODULEDEF)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETITEMDATA, (WPARAM)dwSel, 0);

                    // we own memory now, delete this guy
                    ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_DELETESTRING, (WPARAM)dwSel, 0);

                    // if (moduledef) OR (exit module "no exit module" selection)
                    if ((psModuleDef) || (!pParam->fIsPolicyModuleSelection))
                    {
                        // free what was passed in
                        if (*pParam->ppszProgIDModule)
                        {
                            CoTaskMemFree(*pParam->ppszProgIDModule);
                        }

                        if (psModuleDef)
                        {
                            *pParam->ppszProgIDModule = psModuleDef->pszprogidModule;
                            CopyMemory(pParam->pclsidModule, &psModuleDef->clsidModule, sizeof(CLSID));

                            // all other memory is owned by pParam
                            LocalFree(psModuleDef);
                        }
                        else
                        {
                            *pParam->ppszProgIDModule = NULL;
                            ZeroMemory(pParam->pclsidModule, sizeof(CLSID));
                        }
                    } // no moduledef found; error!
                }
            }
            // fall through for cleanup
        case IDCANCEL:
            {
                PCHOOSEMODULE_MODULEDEF psModuleDef = NULL;

                // listbox cleanup
                INT cItems = (INT)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETCOUNT, 0, 0);
                while(cItems--)
                {
                    psModuleDef = (PCHOOSEMODULE_MODULEDEF)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETITEMDATA, (WPARAM)cItems, 0);
                    FreeChooseModuleDef(psModuleDef);
                }
            }

            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }

    if (NULL != hRemoteMachine)
        RegCloseKey(hRemoteMachine);

    return fReturn;
}



DWORD ModifyQueryFilter(HWND hwnd, CertViewRowEnum* pRowEnum, CComponentDataImpl* pCompData)
{
    // copy m_pRestrictions to pRestrictionHead
    DWORD dwErr = ERROR_SUCCESS;

    PRIVATE_DLGPROC_QUERY_LPARAM    sParam;

    PQUERY_RESTRICTION pRestrictionHead = NULL, pTmpRestriction, pCurRestriction;
    PQUERY_RESTRICTION pFolderRestrictions = pRowEnum->GetQueryRestrictions();
    if (pFolderRestrictions)
    {
        pRestrictionHead = NewQueryRestriction(
                pFolderRestrictions->szField,
                pFolderRestrictions->iOperation,
                &pFolderRestrictions->varValue);
        _JumpIfOutOfMemory(dwErr, Ret, pRestrictionHead);

        pCurRestriction = pRestrictionHead;
        pFolderRestrictions = pFolderRestrictions->pNext;
    }
    while(pFolderRestrictions)
    {
        pTmpRestriction = NewQueryRestriction(
                pFolderRestrictions->szField,
                pFolderRestrictions->iOperation,
                &pFolderRestrictions->varValue);
        _JumpIfOutOfMemory(dwErr, Ret, pTmpRestriction);

        pCurRestriction->pNext = pTmpRestriction;
        pCurRestriction = pCurRestriction->pNext;
        pFolderRestrictions = pFolderRestrictions->pNext;
    }

    InitCommonControls();   // dialog uses comctl32

    sParam.ppRestrict = &pRestrictionHead;
    sParam.pCompData = pCompData;


    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_DEFINE_QUERY),
            hwnd,
            dlgProcQuery,
            (LPARAM)&sParam);
    if (dwErr == IDOK)
    {
        // copy pRestrictionHead back to GetCA()->m_pRestrictions on OK
        pRowEnum->SetQueryRestrictions(pRestrictionHead);

        // trigger active flag
        pRowEnum->SetQueryRestrictionsActive(pRestrictionHead != NULL);
    }
    else
    {
        FreeQueryRestrictionList(pRestrictionHead);
    }
    // translate ok/cancel into error codes
    if (dwErr == IDOK)
        dwErr = ERROR_SUCCESS;
    else if (dwErr == IDCANCEL)
        dwErr = ERROR_CANCELLED;

    _PrintIfError(dwErr, "dlgProcQuery");

Ret:
    return dwErr;
}


BOOL SwapSelectedListboxItem(HWND hFrom, HWND hTo, LPWSTR szItem, DWORD chItem)
{
    // find selected item in from list
    INT nIndex = (INT)SendMessage(hFrom, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return FALSE;

    // dblchk text buf long enough
#if DBG
    INT nChars = (INT)SendMessage(hFrom, LB_GETTEXTLEN, (WPARAM)nIndex, 0);
    if (nChars == LB_ERR)
        return FALSE;
    CSASSERT( (nChars +1) <= (int)chItem);
#endif

    // retrieve text
    if(LB_ERR == SendMessage(hFrom, LB_GETTEXT, (WPARAM)nIndex, (LPARAM)szItem))
        goto Ret;

    // add to target
    if(LB_ERR == SendMessage(hTo, LB_ADDSTRING, 0, (LPARAM)szItem))
        goto Ret;

    // remove from old
    if(LB_ERR == SendMessage(hFrom, LB_DELETESTRING, (WPARAM)nIndex, 0))
        goto Ret;

Ret:

    return TRUE;
}

//////////////////////////////////////////////////////////////////
// Base/Delta CRL publish chooser
INT_PTR CALLBACK dlgProcRevocationPublishType(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

            // only show warning if current CRL still valid
            PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM psParam = (PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM)lParam;
            ShowWindow(GetDlgItem(hwndDlg, IDC_VALID_LASTPUBLISHED), psParam->fCurrentCRLValid ? SW_SHOW : SW_HIDE);

            // select the 1st element
            HWND hRadioBase = GetDlgItem(hwndDlg, IDC_RADIO_NEWBASE);
            SendMessage(hRadioBase, BM_SETCHECK, TRUE, 0); // Yes by default

            if (!psParam->fDeltaCRLEnabled)
{
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_NEWDELTA), FALSE);
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELTA_EXPLANATION), FALSE);
}

            return 1;
        }
        break;
    case WM_HELP:
    {
        // UNDONE
        //OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_CONTEXTMENU:
    {
        // UNDONE
        //OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM psParam = (PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                HWND hRadioBase = GetDlgItem(hwndDlg, IDC_RADIO_NEWBASE);
                psParam->fPublishBaseCRL = (BOOL)SendMessage(hRadioBase, BM_GETCHECK, 0, 0);

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}

//////////////////////////////////////////////////////////////////
// Revocation Reason Chooser
INT_PTR CALLBACK dlgProcRevocationReason(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

	        HWND hCombo = GetDlgItem(hwndDlg, IDC_COMBO_REASON);

// from WINCRYPT.H
//          CRL_REASON_UNSPECIFIED              0
//          CRL_REASON_KEY_COMPROMISE           1
//          CRL_REASON_CA_COMPROMISE            2
//          CRL_REASON_AFFILIATION_CHANGED      3
//          CRL_REASON_SUPERSEDED               4
//          CRL_REASON_CESSATION_OF_OPERATION   5
//          CRL_REASON_CERTIFICATE_HOLD         6

            INT itemidx;
            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_Unspecified);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_UNSPECIFIED);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_KeyCompromise);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_KEY_COMPROMISE);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_CaCompromise);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_CA_COMPROMISE);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_Affiliation);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_AFFILIATION_CHANGED);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_Superseded);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_SUPERSEDED);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_Cessatation);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_CESSATION_OF_OPERATION);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_cResources.m_szRevokeReason_CertHold);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_CERTIFICATE_HOLD);


            // select the 1st element
            SendMessage(hCombo, CB_SETCURSEL, 0, 0);

            return 1;
        }
        break;
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                LONG* plRevocationReason = (LONG*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	            HWND hCombo = GetDlgItem(hwndDlg, IDC_COMBO_REASON);
                *plRevocationReason = (LONG)SendMessage(hCombo, CB_GETCURSEL, 0, 0);

                if (*plRevocationReason == CB_ERR)
                    *plRevocationReason = CRL_REASON_UNSPECIFIED;

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


DWORD GetUserConfirmRevocationReason(LONG* plReasonCode, HWND hwnd)
{
    DWORD dwErr;
    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_REVOCATION_DIALOG),
            hwnd,
            dlgProcRevocationReason,
            (LPARAM)plReasonCode);

    // translate ok/cancel into error codes
    if (dwErr == IDOK)
        dwErr = ERROR_SUCCESS;
    else if (dwErr == IDCANCEL)
        dwErr = ERROR_CANCELLED;

    _PrintIfError(dwErr, "dlgProcRevocationReason");

//Ret:
    return dwErr;
}


//////////////////////////////////////////////////////////////////
// Renewal: Reuse Keys Chooser
INT_PTR CALLBACK dlgProcRenewReuseKeys(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
// self-explanitory page, no help needed
//            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

            HWND hReuse = GetDlgItem(hwndDlg, IDC_RADIO_REUSEKEY);
            SendMessage(hReuse, BM_SETCHECK, TRUE, 0); // Yes by default

            return 1;
        }
        break;
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                BOOL* pfReuseKeys = (BOOL*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                HWND hReuse = GetDlgItem(hwndDlg, IDC_RADIO_REUSEKEY);
                *pfReuseKeys = (BOOL)SendMessage(hReuse, BM_GETCHECK, 0, 0);

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


typedef struct _CERTMMC_BINARYCOLCHOOSER{
    CComponentDataImpl* pComp;
    LPCWSTR wszCol;
    BOOL fSaveOnly;
} CERTMMC_BINARYCOLCHOOSER, *PCERTMMC_BINARYCOLCHOOSER;

//////////////////////////////////////////////////////////////////
// Binary Dump: Column Chooser
INT_PTR CALLBACK dlgProcBinaryColChooser(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
// self-explanitory page, no help needed
//            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam); // PCERTMMC_BINARYCOLCHOOSER

    PCERTMMC_BINARYCOLCHOOSER pData = (PCERTMMC_BINARYCOLCHOOSER)lParam;
    HWND hColumnCombo = GetDlgItem(hwndDlg, IDC_COMBO_BINARY_COLUMN_CHOICE);
    BOOL fInsertedOne = FALSE;   // must insert one or bail

    // insert all known binary columns in this view
    for(int i=0; ;i++)
    {
        LRESULT lr;
        HRESULT hr;
        LPCWSTR szCol, szLocalizedCol;
        LONG lType;

        hr = pData->pComp->GetDBSchemaEntry(i,&szCol, &lType, NULL);
        if (hr != S_OK)
           break;

        if (lType != PROPTYPE_BINARY)
            continue;

        // Q: see if this is included in the current view?

        // convert to localized name
        hr = myGetColumnDisplayName(szCol, &szLocalizedCol);
        if (hr != S_OK)
            continue;

        // add loc name to combobox with szCol as data ptr
        lr = SendMessage(hColumnCombo, CB_ADDSTRING, 0, (LPARAM)szLocalizedCol);
        if ((lr != CB_ERR) && (lr != CB_ERRSPACE))
        {
             SendMessage(hColumnCombo, CB_SETITEMDATA, lr, (LPARAM)szCol);
             fInsertedOne = TRUE;
        }
    }

            if (!fInsertedOne)
                EndDialog(hwndDlg, IDOK); // bail here
            else
                SendMessage(hColumnCombo, CB_SETCURSEL, 0, 0);

			// by default: view
			SendDlgItemMessage(hwndDlg, IDC_RADIO_BINARY_VIEW, BM_SETCHECK, BST_CHECKED, 0);

            return 1;
        }
        break;
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                PCERTMMC_BINARYCOLCHOOSER pData = (PCERTMMC_BINARYCOLCHOOSER)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                HWND hColumnCombo = GetDlgItem(hwndDlg, IDC_COMBO_BINARY_COLUMN_CHOICE);
                LRESULT lr;


                lr = SendMessage(hColumnCombo, CB_GETCURSEL, 0, 0);
                if (lr != CB_ERR)
                {
                    pData->wszCol = (LPCWSTR)SendMessage(hColumnCombo, CB_GETITEMDATA, lr, 0);
                    if (pData->wszCol == (LPCWSTR)CB_ERR)
                         pData->wszCol = NULL;

					// if view unchecked, save only
					pData->fSaveOnly = (BST_UNCHECKED == SendDlgItemMessage(hwndDlg, IDC_RADIO_BINARY_VIEW, BM_GETCHECK, 0, 0));

                    //pData->fSaveOnly = (BOOL)SendMessage(GetDlgItem(hwndDlg, IDC_CHECK_BINARY_SAVETOFILE), BM_GETCHECK, 0, 0);
                }

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}



/////////////////////////////////////////////////////////////////////////////////////
// View Attributes and extensions associated with a request

DWORD ViewRowAttributesExtensions(HWND hwnd, IEnumCERTVIEWATTRIBUTE* pAttr, IEnumCERTVIEWEXTENSION* pExtn, LPCWSTR szReqID)
{
    DWORD dwErr = S_OK;
    HPROPSHEETPAGE hPages[2];
    CString cstrCaption, cstrCaptionTemplate;
    CViewAttrib *psPg1;
    CViewExtn *psPg2;
    InitCommonControls();

    // page 1 initialization
    psPg1 = new CViewAttrib();   // autodeleted
    if (psPg1 == NULL)
    {
        dwErr = E_OUTOFMEMORY;
        goto error;
    }
    psPg1->m_pAttr = pAttr;

    hPages[0] = CreatePropertySheetPage(&psPg1->m_psp);
    if (hPages[0] == NULL)
    {
        dwErr = GetLastError();
        goto error;
    }

    // page 2 initialization
    psPg2 = new CViewExtn();     // autodeleted
    if (psPg2 == NULL)
    {
        dwErr = E_OUTOFMEMORY;
        goto error;
    }
    psPg2->m_pExtn = pExtn;

    hPages[1] = CreatePropertySheetPage(&psPg2->m_psp);
    if (hPages[1] == NULL)
    {
        dwErr = GetLastError();
        goto error;
    }

    cstrCaptionTemplate.LoadString(IDS_CERT_PROP_CAPTION);
    cstrCaption.Format(cstrCaptionTemplate, szReqID);

    PROPSHEETHEADER sPsh;
    ZeroMemory(&sPsh, sizeof(sPsh));
    sPsh.dwSize = sizeof(sPsh);
    sPsh.dwFlags = PSH_DEFAULT | PSH_PROPTITLE | PSH_NOAPPLYNOW ;
    sPsh.hwndParent = hwnd;
    sPsh.hInstance = g_hInstance;
    sPsh.nPages = ARRAYLEN(hPages);
    sPsh.phpage = hPages;
    sPsh.pszCaption = (LPCWSTR)cstrCaption;

    dwErr = (DWORD)PropertySheet(&sPsh);
    if (dwErr == -1)
    {
        // error
        dwErr = GetLastError();
        goto error;
    }
    if (dwErr == 0)
    {
        // cancel
        dwErr = (DWORD)ERROR_CANCELLED;
        goto error;
    }

    dwErr = S_OK;
error:

    return dwErr;
}

DWORD ChooseBinaryColumnToDump(IN HWND hwnd, IN CComponentDataImpl* pComp, OUT LPCWSTR* pcwszColumn, OUT BOOL* pfSaveToFileOnly)
{
    DWORD dwErr;
    int i;
    if ((NULL == pcwszColumn) || (NULL == pfSaveToFileOnly))
        return E_POINTER;


    CERTMMC_BINARYCOLCHOOSER sParam = {0};
    sParam.pComp = pComp;

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_BINARY_COLUMN),
            hwnd,
            dlgProcBinaryColChooser,
            (LPARAM)&sParam);

        // translate ok/cancel into error codes
        if (dwErr == IDOK)
            dwErr = ERROR_SUCCESS;
        else if (dwErr == IDCANCEL)
            dwErr = ERROR_CANCELLED;

        _JumpIfError(dwErr, Ret, "dlgProcBinaryColChooser");


    // copy out params, even if null
    *pcwszColumn = sParam.wszCol;
    *pfSaveToFileOnly = sParam.fSaveOnly;

Ret:
    return dwErr;
}


DWORD ViewRowRequestASN(HWND hwnd, LPCWSTR szTempFileName, PBYTE pbRequest, DWORD cbRequest, IN BOOL fSaveToFileOnly)
{
#define P_WAIT 0
#define P_NOWAIT 1

    DWORD dwErr = S_OK;
    WCHAR szTmpPath[MAX_PATH], szReqFile[MAX_PATH], szTmpFile[MAX_PATH];
    WCHAR szCmdLine[MAX_PATH], szSysDir[MAX_PATH];
    LPWSTR pszReqFile = szReqFile;

    STARTUPINFO sStartup;
    ZeroMemory(&sStartup, sizeof(sStartup));
    PROCESS_INFORMATION sProcess;
    ZeroMemory(&sProcess, sizeof(sProcess));
    sStartup.cb = sizeof(sStartup);

    HANDLE hFile = NULL;
    DWORD cbWritten;

      SECURITY_ATTRIBUTES sa;


      // Set up the security attributes struct.
      sa.nLength= sizeof(SECURITY_ATTRIBUTES);
      sa.lpSecurityDescriptor = NULL;
      sa.bInheritHandle = TRUE;


    if (fSaveToFileOnly)
    {
	// Put up a file dialog to prompt the user for Cert file
	// 0 == hr means dialog was cancelled, we cheat because S_OK == 0

        dwErr = myGetSaveFileName(
                 hwnd,
				 g_hInstance,				// hInstance
                 IDS_BINARYFILE_OUTPUT_TITLE,
                 IDS_BINARYFILE_OUTPUT_FILTER,
                 0,				//no def ext
                 OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
				 szTempFileName,				// default file
                 &pszReqFile);
        _JumpIfError(dwErr, error, "myGetSaveFileName");

        if (NULL == pszReqFile)
        {
            // cancelled:
	    // see public\sdk\inc\cderr.h for real CommDlgExtendedError errors

	    dwErr = CommDlgExtendedError();
	    _JumpError(dwErr, error, "myGetSaveFileName");
        }
    }
    else
    {
		if (0 == GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
		{
			dwErr = GetLastError();
			goto error;
		}

		if (0 == GetTempPath(ARRAYSIZE(szTmpPath), szTmpPath))
		{
			dwErr = GetLastError();
			goto error;
		}

		// gen one unique filename
		if (0 == GetTempFileName(
			  szTmpPath,
			  L"TMP",
			  0,
			  szReqFile))	// binary goo
		{
			dwErr = GetLastError();
			goto error;
		}

		// c:\temp\foo.tmp
		wcscpy(szTmpFile, szTmpPath);
		wcscat(szTmpFile, szTempFileName);

                // this file should never exist
	        DeleteFile(szTmpFile);
    }

dwErr = EncodeToFileW(
pszReqFile,
pbRequest,
cbRequest,
CRYPT_STRING_BINARY|DECF_FORCEOVERWRITE);
_JumpIfError(dwErr, error, "EncodeToFile");

    if (fSaveToFileOnly)
    {
       // done saving, bail!
       dwErr = S_OK;
       goto error;
    }


    // open up the output file
    hFile = CreateFile(
         szTmpFile,
         GENERIC_ALL,
         FILE_SHARE_WRITE|FILE_SHARE_READ,
         &sa, // must make inheritable for other process to write to
         OPEN_ALWAYS,
         FILE_ATTRIBUTE_TEMPORARY,
         NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        goto error;
    }

    // set as output
    sStartup.dwFlags = STARTF_USESTDHANDLES;
    sStartup.hStdInput = GetStdHandle(STD_INPUT_HANDLE); 
    sStartup.hStdError = GetStdHandle(STD_ERROR_HANDLE); 
    sStartup.hStdOutput = hFile;


    // exec "certutil -dump szReqFile szTempFile"
    wsprintf(szCmdLine, L"%s\\certutil.exe -dump \"%s\"", szSysDir, szReqFile);
    wcscat(szSysDir, L"\\certutil.exe");

    if (!CreateProcess(
      szSysDir, // exe
      szCmdLine, // full cmd line
      NULL,
      NULL,
      TRUE, // use hStdOut
      CREATE_NO_WINDOW,
      NULL,
      NULL,
      &sStartup,
      &sProcess))
    {
        dwErr = GetLastError();
        _JumpError(dwErr, error, "EncodeToFile");
    }

    // wait up to 2 sec for certutil to finish
    if (WAIT_OBJECT_0 != WaitForSingleObject(sProcess.hProcess, INFINITE))
    {
        dwErr = ERROR_TIMEOUT;
        _JumpError(dwErr, error, "EncodeToFile");
    }

    CloseHandle(sProcess.hProcess);
    CloseHandle(hFile);
    hFile=NULL;

    // exec "notepad tmpfil2"
    if (-1 == _wspawnlp(P_NOWAIT, L"notepad.exe", L"notepad.exe", szTmpFile, NULL))
        dwErr = errno;

    // give notepad 2 sec to open before we delete his szTmpFile out from under him
    // use waitforinputidle?
    Sleep(2000);

    // delete the binary file
    DeleteFile(szReqFile);

    // delete the tmp file
    DeleteFile(szTmpFile);

    dwErr = S_OK;
error:
    if (hFile != NULL)
        CloseHandle(hFile);

    // originally points to []
    if ((pszReqFile != NULL) && (pszReqFile != szReqFile))
        LocalFree(pszReqFile);

    return dwErr;
}


///////////////////////////////////////////
// CViewAttrib
/////////////////////////////////////////////////////////////////////////////
// CViewAttrib property page
CViewAttrib::CViewAttrib(UINT uIDD)
    : CAutoDeletePropPage(uIDD)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_ATTR_PROPPAGE);
}

// replacement for DoDataExchange
BOOL CViewAttrib::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CViewAttrib::OnCommand(WPARAM wParam, LPARAM lParam)
{
//    switch(LOWORD(wParam))
    {
//    default:
//        return FALSE;
//        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CViewAttrib message handlers
BOOL CViewAttrib::OnInitDialog()
{
    HRESULT hr;
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();


    IEnumCERTVIEWATTRIBUTE* pAttr = m_pAttr;
    BSTR bstrName = NULL, bstrValue = NULL;
    LPWSTR pszName = NULL;

    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_ATTR);
    CString cstrTmp;

    int iItem =0, iSubItem;

    cstrTmp.LoadString(IDS_LISTCOL_TAG);
    ListView_NewColumn(hwndList, 0, 150, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_VALUE);
    ListView_NewColumn(hwndList, 1, 250, (LPWSTR)(LPCWSTR)cstrTmp);

    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

    while(TRUE)
    {
        LONG lIndex = 0;

        // set up for next loop
        hr = pAttr->Next(&lIndex);
        if (hr == S_FALSE)
            break;
        _JumpIfError(hr, initerror, "pAttr->Next");

        hr = pAttr->GetName(&bstrName);
        _JumpIfError(hr, initerror, "pAttr->GetName");

        hr = pAttr->GetValue(&bstrValue);
        _JumpIfError(hr, initerror, "pAttr->GetValue");

        // have all info, populate row
        ListView_NewItem(hwndList, iItem, (LPWSTR)bstrName);
        iSubItem = 1;
        ListView_SetItemText(hwndList, iItem++, iSubItem, (LPWSTR)bstrValue);

        // not necessary to free in the loop
    }

    hr = S_OK;

initerror:

    if (pszName)
        LocalFree(pszName);

    if (bstrName)
        SysFreeString(bstrName);

    if (bstrValue)
        SysFreeString(bstrValue);

    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        DestroyWindow(m_hWnd);
    }

    return TRUE;
}


///////////////////////////////////////////
// CViewExtn
/////////////////////////////////////////////////////////////////////////////
// CViewExtn property page
CViewExtn::CViewExtn(UINT uIDD)
    : CAutoDeletePropPage(uIDD)
{

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_EXTN_PROPPAGE);

}

CViewExtn::~CViewExtn()
{
    int i;
    for (i=0; i<m_carrExtnValues.GetUpperBound(); i++)
        delete m_carrExtnValues.GetAt(i);
    m_carrExtnValues.Init();
}

// replacement for DoDataExchange
BOOL CViewExtn::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

BOOL CViewExtn::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_LIST_EXTN:
        if (pnmh->code == LVN_ITEMCHANGED)
            OnReselectItem();
        break;
    }
    return FALSE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CViewExtn::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

void CViewExtn::OnReselectItem()
{
    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_EXTN);

    int iSel, iItems = ListView_GetItemCount(hwndList);

    // find selected item
    for(iSel=0; iSel<(LRESULT)iItems; iSel++)
    {
        UINT ui = ListView_GetItemState(hwndList, iSel, LVIS_SELECTED);
        if (ui == LVIS_SELECTED)
            break;
    }

    // selected item
    if (iSel != iItems)
    {
        CSASSERT(m_carrExtnValues.GetUpperBound() >= iSel);
        if (m_carrExtnValues.GetUpperBound() >= iSel)
        {
            CString* pcstr = m_carrExtnValues.GetAt(iSel);
            CSASSERT(pcstr);
            if (pcstr != NULL)
                SetDlgItemText(m_hWnd, IDC_EDIT_EXTN, *pcstr);
        }
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
// CViewExtn message handlers
BOOL CViewExtn::OnInitDialog()
{
    HRESULT hr = S_OK;
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();


    IEnumCERTVIEWEXTENSION* pExtn = m_pExtn;
    BSTR bstrName = NULL, bstrValue = NULL;
    LPWSTR pszName = NULL;
    LPWSTR pszFormattedExtn = NULL;
    VARIANT varExtn;
    VariantInit(&varExtn);

    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_EXTN);

    CString cstrTmp;

    int iItem = 0, iSubItem;

    cstrTmp.LoadString(IDS_LISTCOL_TAG);
    ListView_NewColumn(hwndList, 0, 150, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_ORGIN);
    ListView_NewColumn(hwndList, 1, 70, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_CRITICAL);
    ListView_NewColumn(hwndList, 2, 70, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_ENABLED);
    ListView_NewColumn(hwndList, 3, 70, (LPWSTR)(LPCWSTR)cstrTmp);

    //set whole row selection
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

    while(TRUE)
    {
        CString cstrOrigin;
        CString cstrCritical;
        CString cstrEnabled;
        CString* pcstr;
        LONG lIndex = 0, lExtFlags;

        // set up for next loop
        hr = pExtn->Next(&lIndex);
        if (hr == S_FALSE)
            break;
        _JumpIfError(hr, initerror, "pExtn->Next");

        hr = pExtn->GetName(&bstrName);
        _JumpIfError(hr, initerror, "pExtn->GetName");

        if (pszName)
            LocalFree(pszName);
        pszName = NULL;
        hr = myOIDToName(bstrName, &pszName);
        _PrintIfError(hr, "myOIDToName");

        hr = pExtn->GetFlags(&lExtFlags);
        _JumpIfError(hr, initerror, "pExtn->GetFlags");

        switch ( lExtFlags & EXTENSION_ORIGIN_MASK )
        {
            case EXTENSION_ORIGIN_REQUEST:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_REQUEST);
                break;
            case EXTENSION_ORIGIN_POLICY:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_POLICY);
                break;
            case EXTENSION_ORIGIN_ADMIN:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_ADMIN);
                break;
            case EXTENSION_ORIGIN_SERVER:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_SERVER);
                break;
            case EXTENSION_ORIGIN_RENEWALCERT:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_RENEWAL);
                break;
            case EXTENSION_ORIGIN_IMPORTEDCERT:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_IMPORTED_CERT);
                break;
            case EXTENSION_ORIGIN_PKCS7:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_PKCS7);
                break;
            default:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_UNKNOWN);
                DBGPRINT((DBG_SS_CERTMMC, "Unknown extension orgin: 0x%x\n", (lExtFlags & EXTENSION_ORIGIN_MASK)));
                break;
        }

        // possible to be both crit & disabled
        if ( (lExtFlags & EXTENSION_CRITICAL_FLAG) != 0)
            cstrCritical.LoadString(IDS_YES);
        else
            cstrCritical.LoadString(IDS_NO);

        if ( (lExtFlags & EXTENSION_DISABLE_FLAG) != 0)
            cstrEnabled.LoadString(IDS_NO);
        else
            cstrEnabled.LoadString(IDS_YES);

        hr = pExtn->GetValue(
            PROPTYPE_BINARY,
            CV_OUT_BINARY,
            &varExtn);
        _JumpIfError(hr, initerror, "pExtn->GetValue");

        if (varExtn.vt == VT_BSTR)
        {
            if (pszFormattedExtn)
                LocalFree(pszFormattedExtn);
            pszFormattedExtn = NULL;
            hr = myDumpFormattedObject(
                bstrName,
                (PBYTE)varExtn.bstrVal,
                SysStringByteLen(varExtn.bstrVal),
                &pszFormattedExtn);
            _PrintIfError(hr, "myDumpFormattedObject");
        }

        // have all info, populate row

        // tag name (subitem 0)
        ListView_NewItem(hwndList, iItem, (pszName!=NULL) ? pszName : (LPWSTR)bstrName);
        // origin (subitem 1)
        ListView_SetItemText(hwndList, iItem, 1, (LPWSTR)(LPCWSTR)cstrOrigin);
        // critical flag (subitem 2)
        ListView_SetItemText(hwndList, iItem, 2, (LPWSTR)(LPCWSTR)cstrCritical);
        // enabled flag (subitem 3)
        ListView_SetItemText(hwndList, iItem, 3, (LPWSTR)(LPCWSTR)cstrEnabled);

        // value
        pcstr = new CString;
        if (pcstr != NULL)
        {
           *pcstr = pszFormattedExtn;
           m_carrExtnValues.Add(pcstr);    // arr owns pcstr memory
           pcstr = NULL;
        }
        else
        {
           hr = E_OUTOFMEMORY;
           _JumpError(hr, initerror, "new CString");
        }

        iItem++;

        // not necessary to free in the loop
    }

    hr = S_OK;

initerror:
    VariantClear(&varExtn);

    if (pszName)
        LocalFree(pszName);

    if (bstrName)
        SysFreeString(bstrName);

    if (pszFormattedExtn)
        LocalFree(pszFormattedExtn);

    if (bstrValue)
        SysFreeString(bstrValue);

    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        DestroyWindow(m_hWnd);
    }

    return TRUE;
}


///////////////////////////////////////////
// CViewCertManagers
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsGeneralPage property page
CSvrSettingsCertManagersPage::CSvrSettingsCertManagersPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage), m_fEnabled(FALSE), m_fDirty(FALSE)
{

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE6);

    if(m_strButtonAllow.IsEmpty())
        m_strButtonAllow.LoadString(IDS_BUTTONTEXT_ALLOW);
    if(m_strButtonDeny.IsEmpty())
        m_strButtonDeny.LoadString(IDS_BUTTONTEXT_DENY);
    if(m_strTextAllow.IsEmpty())
        m_strTextAllow.LoadString(IDS_TEXT_ALLOW);
    if(m_strTextDeny.IsEmpty())
        m_strTextDeny.LoadString(IDS_TEXT_DENY);
}

CSvrSettingsCertManagersPage::~CSvrSettingsCertManagersPage()
{
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsCertManagersPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_ADDSUBJECT:
        OnAddSubject();
        break;
    case IDC_REMOVESUBJECT:
        OnRemoveSubject();
        break;
    case IDC_ALLOWDENY:
        OnAllowDeny();
        break;
    case IDC_RADIO_ENABLEOFFICERS:
        OnEnableOfficers(true);
        break;
    case IDC_RADIO_DISABLEOFFICERS:
        OnEnableOfficers(false);
        break;
    case IDC_LIST_CERTMANAGERS:
        switch (HIWORD(wParam))
        {
            case CBN_SELCHANGE:
                // extension selection is changed
                OnOfficerChange();
            break;
        }
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}

void CSvrSettingsCertManagersPage::OnOfficerChange()
{
    DWORD dwOfficerIndex = GetCurrentOfficerIndex();
    if(-1!=dwOfficerIndex)
    {
        FillClientList(GetCurrentOfficerIndex());
    }
    SetAllowDeny();
}

BOOL CSvrSettingsCertManagersPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
   LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;

    switch(idCtrl)
    {
    case IDC_LIST_SUBJECTS:
        if (pnmh->code == LVN_ITEMCHANGED)
        {
            if(pnmlv->uChanged & LVIF_STATE)
            {
                if ((pnmlv->uNewState & LVIS_SELECTED) &&
                    !(pnmlv->uOldState & LVIS_SELECTED))
                {
                    SetAllowDeny();
                }
            }
        }
        break;
    default:
        return CAutoDeletePropPage::OnNotify(idCtrl, pnmh);
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsCertManagersPage message handlers
BOOL CSvrSettingsCertManagersPage::OnInitDialog()
{
    HWND hwndClients  = GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);
    RECT rc;
    LV_COLUMN col;
    GetClientRect(hwndClients, &rc);
    CString strHeader;
    CString strAccess;

    strHeader.LoadString(IDS_LIST_NAME);
    strAccess.LoadString(IDS_LIST_ACCESS);

    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = strHeader.GetBuffer();
    col.iSubItem = 0;
    col.cx = rc.right*3/4;
    ListView_InsertColumn(hwndClients, 0, &col);

    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = strAccess.GetBuffer();
    col.iSubItem = 0;
    col.cx = rc.right*1/4;
    ListView_InsertColumn(hwndClients, 1, &col);

    ListView_SetExtendedListViewStyle(hwndClients, LVS_EX_FULLROWSELECT);

    UpdateData(FALSE);
    return TRUE;
}

BOOL CSvrSettingsCertManagersPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (!fSuckFromDlg)
    {
        GetOfficerRights();
//        FillOfficerList();
//        FillClientList(0);
//        SetAllowDeny();
        EnableControls();
    }
    return TRUE;
}

void CSvrSettingsCertManagersPage::OnDestroy()
{
    CAutoDeletePropPage::OnDestroy();
}


BOOL CSvrSettingsCertManagersPage::OnApply()
{
    if(IsDirty())
    {
        HRESULT hr = SetOfficerRights();
        if (hr != S_OK)
        {
            DisplayGenericCertSrvError(m_hWnd, hr);
            return FALSE;
        }
    }

    UpdateData(FALSE);
    return CAutoDeletePropPage::OnApply();
}

void CSvrSettingsCertManagersPage::OnAddSubject()
{
    PSID pSid;
    HRESULT hr;
    DWORD dwIndex;
    CertSrv::COfficerRights* pOfficer;
    hr = BrowseForSubject(m_hWnd, pSid);
    _JumpIfError(hr, err, "BrowseForSubject");

    if(S_OK==hr)
    {
        HWND hwnd = GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);

        pOfficer = m_OfficerRightsList.GetAt(GetCurrentOfficerIndex());

        dwIndex = pOfficer->Find(pSid);
        if(DWORD_MAX==dwIndex)
        {
            dwIndex = pOfficer->GetCount();
            pOfficer->Add(pSid, TRUE);

            ListView_NewItem(hwnd, dwIndex,
                pOfficer->GetAt(dwIndex)->GetName());
            ListView_SetItemText(hwnd, dwIndex, 1,
                pOfficer->GetAt(dwIndex)->GetPermission()?
                m_strTextAllow.GetBuffer():
                m_strTextDeny.GetBuffer());
            SetAllowDeny();
            SetDirty();
        }

        ::EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVESUBJECT), TRUE);
        ::EnableWindow(GetDlgItem(m_hWnd, IDC_ALLOWDENY),   TRUE);

        ListView_SetItemState(hwnd, dwIndex,
            LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
        SetFocus(hwnd);
    }
    else
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
    }

err:
    if(pSid)
        LocalFree(pSid);
}

void CSvrSettingsCertManagersPage::OnRemoveSubject()
{
    DWORD dwClientIndex = GetCurrentClientIndex();
    DWORD dwOfficerIndex = GetCurrentOfficerIndex();
    HWND hwndListClients = GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);


    m_OfficerRightsList.GetAt(dwOfficerIndex)->
        RemoveAt(dwClientIndex);

    ListView_DeleteItem(hwndListClients, dwClientIndex);

    if(0==m_OfficerRightsList.GetAt(dwOfficerIndex)->GetCount())
    {
        ::EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVESUBJECT), FALSE);
        ::EnableWindow(GetDlgItem(m_hWnd, IDC_ALLOWDENY), FALSE);
        SetFocus(GetDlgItem(m_hWnd, IDC_ADDSUBJECT));
    }
    else
    {
        if(dwClientIndex==
            m_OfficerRightsList.GetAt(dwOfficerIndex)->GetCount())
            dwClientIndex--;
        ListView_SetItemState(hwndListClients, dwClientIndex,
            LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
        SetFocus(hwndListClients);
    }

    SetDirty();
}

void CSvrSettingsCertManagersPage::OnAllowDeny()
{
    DWORD dwCrtClient  = GetCurrentClientIndex();
    DWORD dwCrtOfficer = GetCurrentOfficerIndex();
    CertSrv::CClientPermission *pClient =
        m_OfficerRightsList.GetAt(dwCrtOfficer)->GetAt(dwCrtClient);

    m_OfficerRightsList.GetAt(dwCrtOfficer)->
        SetAt(dwCrtClient, !pClient->GetPermission());

    SetAllowDeny();

    ListView_SetItemText(
        GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS),
        dwCrtClient,
        1,
        pClient->GetPermission()?
        m_strTextAllow.GetBuffer():
        m_strTextDeny.GetBuffer());

    SetDirty();

}

void CSvrSettingsCertManagersPage::OnEnableOfficers(bool fEnable)
{
    // only if switching enable -> disable or the other way
    if(m_fEnabled && !fEnable ||
       !m_fEnabled && fEnable)
    {
        if(fEnable)
        {
            HRESULT hr = BuildVirtualOfficerRights();
            if(S_OK!=hr)
            {
                DisplayGenericCertSrvError(m_hWnd, hr);
                return;
            }
        }
        m_fEnabled = fEnable;
        EnableControls();
        SetDirty();
    }
}

void CSvrSettingsCertManagersPage::EnableControls()
{
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_LIST_CERTMANAGERS), m_fEnabled);
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS),     m_fEnabled);
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_ADDSUBJECT),        m_fEnabled);
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVESUBJECT),     m_fEnabled);
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_ALLOWDENY),         m_fEnabled);


    SendMessage(
        GetDlgItem(m_hWnd, IDC_RADIO_ENABLEOFFICERS),
        BM_SETCHECK,
        m_fEnabled?TRUE:FALSE, 0);

    SendMessage(
        GetDlgItem(m_hWnd, IDC_RADIO_DISABLEOFFICERS),
        BM_SETCHECK,
        m_fEnabled?FALSE:TRUE, 0);

    FillOfficerList();
    FillClientList(0);
    SetAllowDeny();
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsCertManagersPage utilities

HRESULT CSvrSettingsCertManagersPage::BrowseForSubject(HWND hwnd, PSID &rpSid)
{
    HRESULT hr;
    CComPtr<IDsObjectPicker> pObjPicker;
    CComPtr<IDataObject> pdo;
    BOOL fCurrentMachine = m_pControlPage->m_pCA->m_pParentMachine->IsLocalMachine();
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    BOOL bAllocatedStgMedium = FALSE;
    PDS_SELECTION_LIST      pDsSelList = NULL;
    WCHAR *pwszSubject;
    static PCWSTR pwszObjSID = L"ObjectSid";
    SAFEARRAY *saSid = NULL;
    void HUGEP *pArray = NULL;
    const int MAX_SCOPE_INIT_COUNT = 10;
    ULONG scopesDomain[] =
    {
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_TYPE_TARGET_COMPUTER,
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
        DSOP_SCOPE_TYPE_WORKGROUP,
    };

    ULONG scopesStandalone[] =
    {
        DSOP_SCOPE_TYPE_TARGET_COMPUTER,
    };
    bool fStandalone = (S_OK != myDoesDSExist(FALSE));

    ULONG *pScopes = fStandalone?scopesStandalone:scopesDomain;
    int nScopes = (int)(fStandalone?ARRAYSIZE(scopesStandalone):ARRAYSIZE(scopesDomain));

    hr = CoCreateInstance (CLSID_DsObjectPicker,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IDsObjectPicker,
                           (void **) &pObjPicker);
    _JumpIfError(hr, err, "CoCreateInstance(IID_IDsObjectPicker");

    DSOP_SCOPE_INIT_INFO aScopeInit[MAX_SCOPE_INIT_COUNT];
    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * MAX_SCOPE_INIT_COUNT);

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flScope =
            DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
            DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS |
            DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
    aScopeInit[0].flType = pScopes[0];
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_USERS|
        DSOP_FILTER_COMPUTERS|
        DSOP_FILTER_BUILTIN_GROUPS|
        DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE|
        DSOP_FILTER_GLOBAL_GROUPS_SE|
        DSOP_FILTER_UNIVERSAL_GROUPS_SE|
        DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

    aScopeInit[0].FilterFlags.flDownlevel =
        DSOP_DOWNLEVEL_FILTER_USERS |
        DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS |
        DSOP_DOWNLEVEL_FILTER_COMPUTERS |
        DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS |
        DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

    for(int c=1;c<nScopes;c++)
    {
        aScopeInit[c] = aScopeInit[0];
        aScopeInit[c].flType = pScopes[c];
    }
    aScopeInit[0].flScope |= DSOP_SCOPE_FLAG_STARTING_SCOPE;

    DSOP_INIT_INFO  initInfo;
    ZeroMemory(&initInfo, sizeof(initInfo));
    initInfo.cbSize = sizeof(initInfo);
    initInfo.pwzTargetComputer = fCurrentMachine ?
        NULL : (LPCWSTR)m_pControlPage->m_pCA->m_strServer,
    initInfo.cDsScopeInfos = nScopes;
    initInfo.aDsScopeInfos = aScopeInit;
    initInfo.cAttributesToFetch = 1;
    initInfo.apwzAttributeNames = &pwszObjSID;

    hr = pObjPicker->Initialize(&initInfo);
    _JumpIfError(hr, err, "IDsObjectPicker::Initialize");

    hr = pObjPicker->InvokeDialog(hwnd, &pdo);
    _JumpIfError(hr, err, "IDsObjectPicker::InvokeDialog");

    if(S_OK==hr)
    {
        UINT                    cf = 0;
        FORMATETC               formatetc = {
                                            (CLIPFORMAT)cf,
                                            NULL,
                                            DVASPECT_CONTENT,
                                            -1,
                                            TYMED_HGLOBAL
                                            };
        PDS_SELECTION           pDsSelection = NULL;

        cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);
        if (0 == cf)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _JumpIfError(hr, err, "RegisterClipboardFormat");
        }

        //set the clipformat for the formatetc structure
        formatetc.cfFormat = (CLIPFORMAT)cf;

        hr = pdo->GetData (&formatetc, &stgmedium);
        _JumpIfError(hr, err, "IDataObject::GetData");

        bAllocatedStgMedium = TRUE;
        pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);

        if (NULL == pDsSelList)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _JumpIfError(hr, err, "GlobalLock");
        }


        if (!pDsSelList->cItems)    //some item must have been selected
        {
            hr = E_UNEXPECTED;
            _JumpIfError(hr, err, "no items selected in object picker");
        }

        pDsSelection = &(pDsSelList->aDsSelection[0]);

        saSid = V_ARRAY(pDsSelection->pvarFetchedAttributes);
        hr = SafeArrayAccessData(saSid, &pArray);
        _JumpIfError(hr, err, "SafeArrayAccessData");

        CSASSERT(IsValidSid((PSID)pArray));
        rpSid = LocalAlloc(LMEM_FIXED, GetLengthSid((PSID)pArray));
        if(!CopySid(GetLengthSid((PSID)pArray),
            rpSid,
            pArray))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _JumpIfError(hr, err, "GlobalLock");
        }
    }

err:
    if(pArray)
        SafeArrayUnaccessData(saSid);
    if(pDsSelList)
        GlobalUnlock(stgmedium.hGlobal);
    if (bAllocatedStgMedium)
        ReleaseStgMedium (&stgmedium);

    return hr;
}

HRESULT CSvrSettingsCertManagersPage::GetOfficerRights()
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 2;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pICertAdminD);

	if (2 > dwServerVersion)
	{
	    hr = RPC_E_VERSION_MISMATCH;
	    _JumpError(hr, error, "old server");
	}

    __try
    {
        hr = pICertAdminD->GetOfficerRights(
                 pwszAuthority,
                 &m_fEnabled,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetOfficerRights");

    myRegisterMemAlloc(ctbSD.pb, ctbSD.cb, CSM_COTASKALLOC);

    m_OfficerRightsList.Cleanup();

    if(m_fEnabled)
    {
        hr = m_OfficerRightsList.Load(ctbSD.pb);
        _JumpIfError(hr, error, "COfficerRightsList::Init");
    }

error:
    if(pICertAdminD)
    {
        myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    }
    if (NULL != ctbSD.pb)
    {
        CoTaskMemFree(ctbSD.pb);
    }

    return hr;
}

HRESULT CSvrSettingsCertManagersPage::SetOfficerRights()
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 2;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    if(m_fEnabled)
    {
        hr = m_OfficerRightsList.Save(pSD);
        _JumpIfError(hr, error, "COfficerRightsList::Save");

        ctbSD.cb = GetSecurityDescriptorLength(pSD);
        ctbSD.pb = (BYTE*)pSD;
    }
    else
    {
        ZeroMemory(&ctbSD, sizeof(ctbSD));
    }

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pICertAdminD);

	if (2 > dwServerVersion)
	{
	    hr = RPC_E_VERSION_MISMATCH;
	    _JumpError(hr, error, "old server");
	}

    __try
    {
        hr = pICertAdminD->SetOfficerRights(
                 pwszAuthority,
                 m_fEnabled,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetOfficerRights");

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);

    if(pSD)
    {
        LocalFree(pSD);
    }

    return hr;
}

HRESULT CSvrSettingsCertManagersPage::BuildVirtualOfficerRights()
{
    HRESULT hr = S_OK;
    CertSrv::COfficerRightsSD VirtOfficerRightsSD;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 2;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));
    PSECURITY_DESCRIPTOR pVirtOfficerRights;

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pICertAdminD);

	if (2 > dwServerVersion)
	{
	    hr = RPC_E_VERSION_MISMATCH;
	    _JumpError(hr, error, "old server");
	}

    __try
    {
        hr = pICertAdminD->GetCASecurity(
                 pwszAuthority,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetOfficerRights");

    // BuildVirtualOfficerRights should be called only when transitioning
    // from not enabled to enabled, before enabling on the server side
    CSASSERT(!m_fEnabled);

    myRegisterMemAlloc(ctbSD.pb, ctbSD.cb, CSM_COTASKALLOC);

    m_OfficerRightsList.Cleanup();

    hr = VirtOfficerRightsSD.InitializeEmpty();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Initialize");

    hr = VirtOfficerRightsSD.Adjust(ctbSD.pb);
    _JumpIfError(hr, error, "COfficerRightsSD::Adjust");

    pVirtOfficerRights = VirtOfficerRightsSD.Get();
    CSASSERT(pVirtOfficerRights);

    hr = m_OfficerRightsList.Load(pVirtOfficerRights);
    _JumpIfError(hr, error, "COfficerRightsList::Load");

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    if (NULL != ctbSD.pb)
    {
        CoTaskMemFree(ctbSD.pb);
    }
    return hr;
}

void CSvrSettingsCertManagersPage::FillOfficerList()
{
    HWND hwnd= GetDlgItem(m_hWnd, IDC_LIST_CERTMANAGERS);

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    if(m_fEnabled)
    {
        for(DWORD cManagers=0;
            cManagers<m_OfficerRightsList.GetCount();
            cManagers++)
        {
            CSASSERT(m_OfficerRightsList.GetAt(cManagers));

            LRESULT nIndex = SendMessage(hwnd, CB_ADDSTRING, 0,
                (LPARAM)m_OfficerRightsList.GetAt(cManagers)->GetName());
            CSASSERT(nIndex != CB_ERR);
        }

        SendMessage(hwnd, CB_SETCURSEL, 0, 0);
    }
}

void CSvrSettingsCertManagersPage::FillClientList(DWORD dwOfficerIndex)
{
    HWND hwnd= GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);
    CertSrv::COfficerRights *pOfficer = NULL;
    DWORD dwClientCount, cClients;

    ListView_DeleteAllItems(hwnd);

    if(m_fEnabled)
    {
        if(dwOfficerIndex<m_OfficerRightsList.GetCount())
        {
            pOfficer = m_OfficerRightsList.GetAt(dwOfficerIndex);
            CSASSERT(pOfficer);
            dwClientCount = pOfficer->GetCount();
            for(cClients=0;cClients<dwClientCount;cClients++)
            {
                ListView_NewItem(hwnd, cClients,
                    pOfficer->GetAt(cClients)->GetName());

                ListView_SetItemText(hwnd, cClients, 1,
                    pOfficer->GetAt(cClients)->GetPermission()?
                    m_strTextAllow.GetBuffer():
                    m_strTextDeny.GetBuffer());
            }

            ListView_SetItemState(hwnd, 0,
                LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
        }
    }
}

void CSvrSettingsCertManagersPage::SetAllowDeny()
{
    if(m_fEnabled && 0!=m_OfficerRightsList.GetCount())
    {
        DWORD dwIndex = GetCurrentOfficerIndex();
        if(0!=m_OfficerRightsList.GetAt(dwIndex)->GetCount())
        {
            BOOL fPermission = m_OfficerRightsList.GetAt(dwIndex)->
                GetAt(GetCurrentClientIndex())->GetPermission();

            ::EnableWindow(GetDlgItem(m_hWnd, IDC_ALLOWDENY), TRUE);

            SetDlgItemText(
                m_hWnd,
                IDC_ALLOWDENY,
                fPermission?m_strButtonDeny:m_strButtonAllow);
            return;
        }
    }

    ::EnableWindow(GetDlgItem(m_hWnd, IDC_ALLOWDENY), FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsAuditFilterPage property page
CSvrSettingsAuditFilterPage::CSvrSettingsAuditFilterPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage), m_fDirty(FALSE), m_dwFilter(0)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE7);
}

CSvrSettingsAuditFilterPage::~CSvrSettingsAuditFilterPage()
{
}

BOOL CSvrSettingsAuditFilterPage::OnInitDialog()
{
    GetAuditFilter();
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();
    UpdateData(FALSE);
    return TRUE;
}

HRESULT CSvrSettingsAuditFilterPage::GetAuditFilter()
{
    HRESULT hr = S_OK;
    ICertAdminD2* pAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD dwServerVersion = 2;
    LPCWSTR pcwszPriv = SE_SECURITY_NAME;
    HANDLE hToken = EnablePrivileges(&pcwszPriv, 1);

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pAdminD);
    _JumpIfError(hr, Ret, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, Ret, "old server");
    }

	// load certs here
	hr = pAdminD->GetAuditFilter(
		pwszAuthority,
		&m_dwFilter);
	_JumpIfError(hr, Ret, "ICertAdminD2::GetAuditFilter");

Ret:
	if (pAdminD)
    {
		pAdminD->Release();
    }

    ReleasePrivileges(hToken);

    return hr;
}

HRESULT CSvrSettingsAuditFilterPage::SetAuditFilter()
{
    HRESULT hr = S_OK;
    ICertAdminD2* pAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD dwServerVersion = 2;
    bool fPrivilegeEnabled = FALSE;
    LPCWSTR pcwszPriv = SE_SECURITY_NAME;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    hToken = EnablePrivileges(&pcwszPriv, 1);

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pAdminD);
    _JumpIfError(hr, Ret, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, Ret, "old server");
    }

	// load certs here
	hr = pAdminD->SetAuditFilter(
		pwszAuthority,
		m_dwFilter);
	_JumpIfError(hr, Ret, "ICertAdminD2::SetAuditFilter");

Ret:
    if (pAdminD)
    {
		pAdminD->Release();
    }

    ReleasePrivileges(hToken);

    return hr;
}


BOOL CSvrSettingsAuditFilterPage::OnApply()
{
    HRESULT hr = S_OK;
    ICertAdminD2* pAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD dwServerVersion = 2;
    bool fPrivilegeEnabled = FALSE;
    LPCWSTR pcwszPriv = SE_SECURITY_NAME;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    if (TRUE==m_fDirty)
    {
        UpdateData(TRUE);

        hr = SetAuditFilter();
        _JumpIfError(hr, Ret, "myOpenAdminDComConnection");

        m_fDirty = FALSE;
    }

Ret:
    if (S_OK != hr)
    {
		DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}


int CSvrSettingsAuditFilterPage::m_iCheckboxID[] =
{
    // ID order must match bit order in audit flag DWORD, see
    // AUDIT_FILTER_* in include\audit.h
    IDC_AUDIT_STARTSTOP,
    IDC_AUDIT_BACKUPRESTORE,
    IDC_AUDIT_CERTIFICATE,
    IDC_AUDIT_CRL,
    IDC_AUDIT_CASEC,
    IDC_AUDIT_KEYARCHIVAL,
    IDC_AUDIT_CACONFIG
};

BOOL CSvrSettingsAuditFilterPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    int c;
    DWORD dwBit;

    if (fSuckFromDlg)
    {
        m_dwFilter = 0;
        for(c=0, dwBit=1; c<ARRAYLEN(m_iCheckboxID); c++, dwBit<<=1)
        {
            // set corresponding bit in filter DWORD
            m_dwFilter = m_dwFilter |
                ((INT)SendDlgItemMessage(m_iCheckboxID[c], BM_GETCHECK, 0, 0)?dwBit:0);
        }
    }
    else
    {
        for(c=0, dwBit=1; c<ARRAYLEN(m_iCheckboxID); c++, dwBit<<=1)
        {
            // set checkbox corresponding to bit in filter DWORD
            SendDlgItemMessage(m_iCheckboxID[c], BM_SETCHECK,
                (m_dwFilter&dwBit)?BST_CHECKED:BST_UNCHECKED, 0);
        }
    }
    return TRUE;
}

BOOL CSvrSettingsAuditFilterPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int c;
    // walk the checkbox list and set dirty flag
    for(c=0; c<ARRAYLEN(m_iCheckboxID); c++)
    {
        if(LOWORD(wParam)==m_iCheckboxID[c])
        {
            m_fDirty = TRUE;
            SendMessage (GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, 0);
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT GetPolicyManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi)
{
    HRESULT hr;
    DISPATCHINTERFACE di;
    bool fRelease = false;

    hr = Policy_Init(
        DISPSETUP_COMFIRST,
        pcwszProgID,
        &clsidModule,
        &di);
    _JumpIfErrorStr(hr, Ret, "Policy_Init", pcwszProgID);

    fRelease = true;

    hr = Policy2_GetManageModule(
        &di,
        pdi);
    _JumpIfError(hr, Ret, "Policy2_GetManageModule");

Ret:
    if(fRelease)
        Policy_Release(&di);
    return hr;
}

HRESULT GetExitManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi)
{
    HRESULT hr;
    DISPATCHINTERFACE di;
    bool fRelease = false;

    hr = Exit_Init(
        DISPSETUP_COMFIRST,
        pcwszProgID,
        &clsidModule,
        &di);
    _JumpIfErrorStr(hr, Ret, "Policy_Init", pcwszProgID);

    fRelease = true;

    hr = Exit2_GetManageModule(
        &di,
        pdi);
    _JumpIfError(hr, Ret, "Policy2_GetManageModule");

Ret:
    if(fRelease)
        Exit_Release(&di);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\folders.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _FOLDERS_H
#define _FOLDERS_H


/////////////////////
// File Versions
// current version
// removal of m_RowEnum
#define VER_FOLDER_SAVE_STREAM_2        0x2
                  
// B3 version
#define VER_FOLDER_SAVE_STREAM_1        0x1
/////////////////////

/////////////////////
// File Versions
// current version
// removal of column sizes, sort order info, view type
#define VER_CERTVIEWROWENUM_SAVE_STREAM_4 0x4

// this version (written prior through Win2000 B3) includes column sizes
#define VER_CERTVIEWROWENUM_SAVE_STREAM_3 0x3
/////////////////////



// Forward declarations
class CSnapin;
class CFolder;
class CertSvrCA;
class CertSvrMachine;


struct RESULT_DATA
{
    SCOPE_TYPES itemType; 
    CFolder*    pParentFolder;

    DWORD       cStringArray;
    LPWSTR      szStringArray[3];   // name, size, type
};
enum 
{
    RESULTDATA_ARRAYENTRY_NAME =0,
    RESULTDATA_ARRAYENTRY_SIZE,
    RESULTDATA_ARRAYENTRY_TYPE,
};

HRESULT IsColumnShown(MMC_COLUMN_SET_DATA* pCols, ULONG idxCol, BOOL* pfShown);
HRESULT CountShownColumns(MMC_COLUMN_SET_DATA* pCols, ULONG* plCols);

//////////////////////////////////////////////////////////////////////////
// COLUMN TYPE cache
//
// This cache holds data that populated while setting column headings.
// The data applies to the column view, not the database view.
// Caching here allows an easy type-check during a compare() call, etc.

typedef struct _COLUMN_TYPE_CACHE
{
    // volatile members
    int     iViewCol;

} COLUMN_TYPE_CACHE;


class CertViewRowEnum
{
protected: 

    // View Interface
    ICertView*          m_pICertView;
    BOOL                m_fCertViewOpenAttempted;

    // Row Enum
    IEnumCERTVIEWROW*   m_pRowEnum;
    LONG                m_idxRowEnum;
    BOOL                m_fRowEnumOpenAttempted;

    // Query Restrictions
    PQUERY_RESTRICTION  m_pRestrictions;
    BOOL                m_fRestrictionsActive;

    // Column property cache
    COLUMN_TYPE_CACHE*  m_prgColPropCache;
    DWORD               m_dwColumnCount;

    DWORD               m_dwErr;

public:
    CertViewRowEnum();
    virtual ~CertViewRowEnum();

public:
    BOOL                m_fKnowNumResultRows;
    DWORD               m_dwResultRows;


public:
    HRESULT GetLastError() { return m_dwErr; }

    // View Interface
    HRESULT GetView(CertSvrCA* pCA, ICertView** ppView);
    void    ClearCachedCertView()
        {   m_fCertViewOpenAttempted = FALSE;    }

    // Row Enum
    HRESULT GetRowEnum(CertSvrCA* pCA, IEnumCERTVIEWROW**   ppRowEnum);
    HRESULT GetRowMaxIndex(CertSvrCA* pCA, LONG* pidxMax);

    LONG    GetRowEnumPos()   {   return m_idxRowEnum; }
    HRESULT SetRowEnumPos(LONG idxRow);
   
    HRESULT ResetCachedRowEnum();        // back to 0th row
    void    InvalidateCachedRowEnum();   // refresh

    // Query Restrictions
    void SetQueryRestrictions(PQUERY_RESTRICTION pQR)
        {   if (m_pRestrictions) 
                FreeQueryRestrictionList(m_pRestrictions);
            m_pRestrictions = pQR;
        }
    PQUERY_RESTRICTION GetQueryRestrictions()
        {   return m_pRestrictions;  }
    BOOL FAreQueryRestrictionsActive()
        {   return m_fRestrictionsActive; }
    void SetQueryRestrictionsActive(BOOL fRestrict)
        {   m_fRestrictionsActive = fRestrict; }


    HRESULT ResetColumnCount(LONG lCols);
    LONG GetColumnCount()
        {   return m_dwColumnCount; }
    
    // DB Column property cache
    void FreeColumnCacheInfo();
    
    HRESULT GetColumnCacheInfo(
        IN int iIndex, 
        OUT OPTIONAL int* pidxViewCol);

    // sets column width by heading
    HRESULT SetColumnCacheInfo(
        IN int iIndex,
        IN int idxViewCol);

public:
// IPersistStream interface members
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm, BOOL fClearDirty);
    HRESULT GetSizeMax(int *pcbSize);

};


class CFolder 
{
    SCOPE_TYPES  m_itemType;    // Used for debug purposes. This should be the first 
                                // member. The class should not have any virtual fuctions.

    friend class CSnapin;
    friend class CComponentDataImpl;

public:
    CFolder()
    { 
        m_itemType = UNINITIALIZED_ITEM;  
        m_cookie = UNINITIALIZED;       // invalid memory address -- good cookie initializer
        m_enumed = FALSE; 
        m_type = NONE;
        m_pszName = NULL;

        m_pCertCA = NULL;

        ZeroMemory(&m_ScopeItem, sizeof(SCOPEDATAITEM));
    }

    ~CFolder() 
    { 
        if (m_pszName) 
            CoTaskMemFree(m_pszName); 
    }

// Interface
public:
    BOOL IsEnumerated() { return  m_enumed; }
    void Set(BOOL state) { m_enumed = state; }
    void SetCookie(MMC_COOKIE cookie) { m_cookie = cookie; }
    void SetScopeItemInformation(int nImage, int nOpenImage);

    FOLDER_TYPES GetType() { ASSERT(m_type != NONE); return m_type; }
    CertSvrCA* GetCA() { ASSERT(m_pCertCA != NULL); return m_pCertCA; }
    BOOL operator == (const CFolder& rhs) const { return rhs.m_cookie == m_cookie; }
    BOOL operator == (MMC_COOKIE cookie) const { return cookie == m_cookie; }
    LPCWSTR GetName() { return m_pszName; }
    void SetName(LPWSTR pszIn) 
    { 
        UINT len = wcslen(pszIn) + 1;
        LPWSTR psz = (LPWSTR)CoTaskMemAlloc(len * sizeof(WCHAR));
        if (psz != NULL)
        {
            wcscpy(psz, pszIn);
            CoTaskMemFree(m_pszName);
            m_pszName = psz;
        }
    }

// IPersistStream interface members
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm, BOOL fClearDirty);
    HRESULT GetSizeMax(int *pcbSize);

// Implementation
private:
    void SetProperties(
                LPCWSTR szName, 
                SCOPE_TYPES itemType,
                FOLDER_TYPES type, 
                int iChildren = 0);

// Attributes
private:
    SCOPEDATAITEM   m_ScopeItem;
    MMC_COOKIE      m_cookie;
    BOOL            m_enumed;
    FOLDER_TYPES    m_type;
    LPOLESTR        m_pszName;

    CertSvrCA*      m_pCertCA;
};

BOOL IsAllowedStartStop(CFolder* pFolder, CertSvrMachine* pMachine);
HRESULT GetCurrentColumnSchema(
            IN  LPCWSTR             szConfig, 
            OUT CString**           pprgcstrColumns, 
            OUT OPTIONAL LONG**     pprglTypes, 
            OUT OPTIONAL BOOL**     pprgfIndexed, 
            OUT LONG*               plEntries);


#endif  // _FOLDERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------
#include <stdafx.h>
#include <float.h>
#include "certsrv.h"
#include "misc.h"
#include "clibres.h"
#include "setupids.h"
#include "csresstr.h"
#include <comdef.h>
#include <activeds.h>
#include <dsgetdc.h>
#include <lm.h>
#include "urls.h"
#include "csdisp.h"

bool operator==(
    const struct _QUERY_RESTRICTION& lhs,
    const struct _QUERY_RESTRICTION& rhs)
{
    return 
        0==_wcsicmp(lhs.szField, rhs.szField) &&
        lhs.iOperation==rhs.iOperation &&
        variant_t(&lhs.varValue)==variant_t(&rhs.varValue);
}

PQUERY_RESTRICTION QueryRestrictionFound(
    PQUERY_RESTRICTION pQR, 
    PQUERY_RESTRICTION pQRListHead)
{
    while(pQRListHead)
    {
        if(*pQR==*pQRListHead)
            return pQRListHead;
        pQRListHead = pQRListHead->pNext;
    }
    return NULL;
}

// returns (if cstr.IsEmpty()) ? NULL : cstr)
LPCWSTR GetNullMachineName(CString* pcstr)
{
    LPCWSTR     szMachine = (pcstr->IsEmpty()) ? NULL : (LPCWSTR)*pcstr;
    return szMachine;
}

BOOL FIsCurrentMachine(LPCWSTR str)
{
    BOOL fIsCurrentMachine = FALSE;
    LPWSTR szName1 = NULL, szName2 = NULL;
    DWORD dwErr;

    dwErr = myGetComputerNames(&szName1, &szName2);
    _JumpIfError(dwErr, error, "myGetComputerNames");

    if ((str != NULL) && 
        (wcslen(str) > 2) &&
        (str[0] == '\\')  &&
        (str[1] == '\\') )
        str = &str[2];  // skip whackwhack

    // if machine specified as not current machine
    if ( (NULL == str) || 
         (str[0] == '\0') ||
         (0 == lstrcmpi(str, szName1)) ||
         (0 == lstrcmpi(str, szName2)) )
        fIsCurrentMachine = TRUE;

error:

    if (szName1)
        LocalFree(szName1);
    if (szName2)
        LocalFree(szName2);

    return fIsCurrentMachine;
}



/////////////////////////////////////////
// fxns to load/save cstrings to a streams
STDMETHODIMP CStringLoad(CString& cstr, IStream *pStm)
{
    ASSERT(pStm);
    HRESULT hr;

    DWORD cbSize=0;

    // get cbSize (bytes)
    hr = ReadOfSize(pStm, &cbSize, sizeof(cbSize));
    _JumpIfError(hr, Ret, "ReadOfSize cbSize");

    // get string
    hr = ReadOfSize(pStm, cstr.GetBuffer(cbSize/sizeof(WCHAR)), cbSize);
    cstr.ReleaseBuffer();
    _JumpIfError(hr, Ret, "Read cstr.GetBuffer");

Ret:
    return hr;
}

STDMETHODIMP CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);
    HRESULT hr;

    // Write the string (null cstr will return 0 chars, output nullstr "")
    DWORD cbSize = (cstr.GetLength()+1)*sizeof(WCHAR);

    // write size in bytes
    hr = WriteOfSize(pStm, &cbSize, sizeof(cbSize));
    _JumpIfError(hr, error, "WriteOfSize cbSize");


    // write string (null cstr will return 0 chars, output nullstr "")
    hr = WriteOfSize(pStm, (LPWSTR)(LPCWSTR)cstr, cbSize);
    _JumpIfError(hr, error, "Write cstr");

error:
    return hr;
}

STDMETHODIMP CStringGetSizeMax(CString& cstr, int* piSize)
{
    *piSize = sizeof(DWORD);
    *piSize += (cstr.GetLength()+1)* sizeof(WCHAR);

    return S_OK;
}

STDMETHODIMP VariantLoad(VARIANT& var, IStream *pStm)
{
    HRESULT hr;
    VARIANT varTmp;
    DWORD dwSize;

    VariantInit(&varTmp);
    VariantInit(&var);

    // get target variant type
    hr = ReadOfSize(pStm, &var.vt, sizeof(var.vt));
    _JumpIfError(hr, error, "Read type");

    // get cb
    hr = ReadOfSize(pStm, &dwSize, sizeof(DWORD));
    _JumpIfError(hr, error, "Read cb");

    varTmp.vt = VT_BSTR;
    varTmp.bstrVal = SysAllocStringByteLen(NULL, dwSize);
    _JumpIfOutOfMemory(hr, error, varTmp.bstrVal);

    // get pb
    hr = ReadOfSize(pStm, varTmp.bstrVal, dwSize);
    _JumpIfError(hr, error, "Read pb");

    // change type to target type var.vt
    hr = VariantChangeType(&var, &varTmp, 0, var.vt);
    _JumpIfError(hr, error, "VariantChangeType");

error:
    VariantClear(&varTmp);

    return hr;
}

STDMETHODIMP VariantSave(VARIANT& var, IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;
    DWORD dwSize;

    VARIANT varTmp;
    VariantInit(&varTmp);

    // write variant type
    hr = WriteOfSize(pStm, &var.vt, sizeof(var.vt));
    _JumpIfError(hr, error, "Write type");

    // convert to bstr
    hr = VariantChangeType(&varTmp, &var, 0, VT_BSTR);
    _JumpIfError(hr, error, "VariantChangeType");

    // write cb
    dwSize = SysStringByteLen(varTmp.bstrVal);
    hr = WriteOfSize(pStm, &dwSize, sizeof(DWORD));
    _JumpIfError(hr, error, "Write cb");
    
    // write pb
    hr = WriteOfSize(pStm, varTmp.bstrVal, dwSize);
    _JumpIfError(hr, error, "Write pb");

error:
    VariantClear(&varTmp);

    return hr;
}

STDMETHODIMP VariantGetSizeMax(VARIANT& var, int* piSize)
{
    HRESULT hr;

    VARIANT varTmp;
    VariantInit(&varTmp);

    // write var type, cb
    *piSize = sizeof(var.vt) + sizeof(DWORD);

    // write pb len: convert to bstr
    hr = VariantChangeType(&varTmp, &var, 0, VT_BSTR);
    _JumpIfError(hr, error, "VariantChangeType");

    *piSize += SysStringByteLen(varTmp.bstrVal);
    
error:
    VariantClear(&varTmp);

    return hr;
}

DWORD AllocAndReturnConfigValue(HKEY hKey, LPCWSTR szConfigEntry, PBYTE* ppbOut, DWORD* pcbOut, DWORD* pdwType)
{
    DWORD dwRet;

    dwRet = RegQueryValueExW(
            hKey,
            szConfigEntry,
            NULL,
            pdwType,
            NULL,
            pcbOut);
    _JumpIfError(dwRet, Ret, "RegQueryValueExW");

    ASSERT(ppbOut != NULL);
    *ppbOut = new BYTE[*pcbOut];
    _JumpIfOutOfMemory(dwRet, Ret, *ppbOut);
 
    dwRet = RegQueryValueExW(
            hKey,
            szConfigEntry,
            NULL,
            pdwType,
            *ppbOut,
            pcbOut);
    if (dwRet != ERROR_SUCCESS)
    {
        delete [] *ppbOut;
        *ppbOut = NULL;
        _JumpError(dwRet, Ret, "RegQueryValueExW");
    }
Ret:

    return dwRet;
}




//////////////////////////////////////////////////////////////////
// given an error code and a console pointer, will pop error dlg
void DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, UINT iRscContext)
{
    CString cstrContext;
    cstrContext.LoadString(iRscContext);

    DisplayCertSrvErrorWithContext(hwnd, dwErr, (LPCWSTR)cstrContext);
}

void DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, LPCWSTR szContext)
{
    CString cstrTitle, cstrContext, cstrFullText;
    cstrTitle.LoadString(IDS_MSG_TITLE);
    cstrContext = szContext;

    if (dwErr != ERROR_SUCCESS)
    {
	WCHAR const *pwszError = myGetErrorMessageText(dwErr, TRUE);

        cstrFullText = pwszError;

        // Free the buffer
        if (NULL != pwszError)
	{
            LocalFree(const_cast<WCHAR *>(pwszError));
	}

        if (!cstrContext.IsEmpty())
            cstrFullText += L"\n\n";
    }

    if (!cstrContext.IsEmpty())
        cstrFullText += cstrContext;

    ::MessageBoxW(hwnd, cstrFullText, cstrTitle, 
        MB_OK|
        (S_OK!=dwErr?MB_ICONERROR:MB_ICONINFORMATION));
}

void DisplayGenericCertSrvError(HWND hwnd, DWORD dwErr)
{
    DisplayCertSrvErrorWithContext(hwnd, dwErr, (UINT)0);
}

void DisplayGenericCertSrvError(LPCONSOLE pConsole, DWORD dwErr)
{
    ASSERT(pConsole);

    WCHAR const *pwszError = myGetErrorMessageText(dwErr, TRUE);

    // ...
    // Display the string.
    CString cstrTitle;
    cstrTitle.LoadString(IDS_MSG_TITLE);
    pConsole->MessageBoxW(pwszError, cstrTitle, MB_OK, NULL);
    
    // Free the buffer.
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}

enum ENUM_PERIOD DurationEnumFromNonLocalizedString(LPCWSTR szPeriod)
{
    if (0 == wcscmp(wszPERIODYEARS, szPeriod))
        return ENUM_PERIOD_YEARS;
    if (0 == wcscmp(wszPERIODMONTHS, szPeriod))
        return ENUM_PERIOD_MONTHS;
    if (0 == wcscmp(wszPERIODWEEKS, szPeriod))
        return ENUM_PERIOD_WEEKS;
    if (0 == wcscmp(wszPERIODDAYS, szPeriod))
        return ENUM_PERIOD_DAYS;
    if (0 == wcscmp(wszPERIODHOURS, szPeriod))
        return ENUM_PERIOD_HOURS;
    if (0 == wcscmp(wszPERIODMINUTES, szPeriod))
        return ENUM_PERIOD_MINUTES;
    if (0 == wcscmp(wszPERIODSECONDS, szPeriod))
        return ENUM_PERIOD_SECONDS;

    return ENUM_PERIOD_INVALID;
}

BOOL StringFromDurationEnum(int iEnum, CString* pcstr, BOOL fLocalized)
{
    if (NULL == pcstr)
        return FALSE;

    switch (iEnum) 
    {
    case(ENUM_PERIOD_YEARS):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Years;
        else
            *pcstr = wszPERIODYEARS;
        break;
    case(ENUM_PERIOD_MONTHS):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Months;
        else
            *pcstr = wszPERIODMONTHS;
        break;
    case(ENUM_PERIOD_WEEKS):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Weeks;
        else
            *pcstr = wszPERIODWEEKS;
        break;
    case(ENUM_PERIOD_DAYS):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Days;
        else
            *pcstr = wszPERIODDAYS;
        break;
    case(ENUM_PERIOD_HOURS):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Hours;
        else
            *pcstr = wszPERIODHOURS;
        break;
    case(ENUM_PERIOD_MINUTES):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Minutes;
        else
            *pcstr = wszPERIODMINUTES;
        break;
    case(ENUM_PERIOD_SECONDS):
        if (fLocalized)
            *pcstr = g_cResources.m_szPeriod_Seconds;
        else
            *pcstr = wszPERIODSECONDS;
        break;
    }

    if (! (pcstr->IsEmpty()) )
        return TRUE;

    return FALSE;
}

LPCWSTR OperationToStr(int iOperation)
{
    switch(iOperation)
    {
    case CVR_SEEK_EQ:
        return L"=";
    case CVR_SEEK_LT:
        return L"<";
    case CVR_SEEK_LE:
        return L"<=";
    case CVR_SEEK_GE:
        return L">=";
    case CVR_SEEK_GT:
        return L">";
    }
    
    return NULL;
}

int StrToOperation(LPCWSTR  szOperation)
{
    if      (0 == wcscmp(szOperation, L"="))
        return CVR_SEEK_EQ;
    else if (0 == wcscmp(szOperation, L"<"))
        return CVR_SEEK_LT;
    else if (0 == wcscmp(szOperation, L"<="))
        return CVR_SEEK_LE;
    else if (0 == wcscmp(szOperation, L">="))
        return CVR_SEEK_GE;
    else if (0 == wcscmp(szOperation, L">"))
        return CVR_SEEK_GT;

    return 0;
}

// returns localized string time (even for date!)
BOOL MakeDisplayStrFromDBVariant(VARIANT* pvt, VARIANT* pvOut)
{
    HRESULT hr;
    VariantInit(pvOut);
    LPWSTR szLocalTime = NULL;

    ASSERT(pvt);
    ASSERT(pvOut);
    if ((NULL == pvt) || (NULL == pvOut))
        return FALSE;

    if (pvt->vt == VT_DATE)
    {
        hr = myGMTDateToWszLocalTime(
				&pvt->date,
				FALSE,
				&szLocalTime);
        _JumpIfError(hr, error, "myGMTDateToWszLocalTime");
        
        pvOut->bstrVal = ::SysAllocString(szLocalTime);
        _JumpIfOutOfMemory(hr, error, pvOut->bstrVal);

        pvOut->vt = VT_BSTR;
    }
    else
    {
        hr = VariantChangeType(pvOut, pvt, 0, VT_BSTR);
        _JumpIfError(hr, error, "VariantChangeType");
    }

error:
    if (szLocalTime)
        LocalFree(szLocalTime);

    return (pvOut->vt == VT_BSTR);
}


DWORD CryptAlgToStr(CString* pcstrAlgName, LPCWSTR szProv, DWORD dwProvType, DWORD dwAlg)
{
    DWORD dwRet;
    HCRYPTPROV hCrypt = NULL;
    DWORD Flags = CRYPT_FIRST;
    DWORD cb;
    PROV_ENUMALGS Alg;
    
    pcstrAlgName->Empty();

    if (!CryptAcquireContext(
            &hCrypt, 
            NULL,
            szProv, 
            dwProvType,
            CRYPT_VERIFYCONTEXT))
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CryptAcquireContext");
    }

    while (TRUE)
    {
        cb = sizeof(Alg);
        if (!CryptGetProvParam(hCrypt, PP_ENUMALGS, (BYTE *) &Alg, &cb, Flags))
                 break;

        if (Alg.aiAlgid == dwAlg)
        {
            *pcstrAlgName = Alg.szName;
             break;
        }
    	Flags = 0;
    }

    dwRet = ERROR_SUCCESS;
Ret:

    if (hCrypt)
        CryptReleaseContext(hCrypt, 0);

    return dwRet;
}




LPCWSTR FindUnlocalizedColName(LPCWSTR strColumn)
{
    HRESULT hr = S_OK;
    LPCWSTR szTrial = NULL;

    for(DWORD dwIndex=0; (S_OK == hr); dwIndex++)
    {
        hr = myGetColumnName(
            dwIndex,
            FALSE,      // unlocalized
            &szTrial);
        _PrintIfError(hr, "myGetColumnName");
        
        if ((S_OK == hr) && (NULL != szTrial))
        {
            if (0 == wcscmp(strColumn, szTrial))
                return szTrial;
        }
    }
    
    return NULL;
}




// given field, op, variant, copies into data struct
PQUERY_RESTRICTION NewQueryRestriction(LPCWSTR szField, UINT iOp, VARIANT* pvarValue)
{
    DWORD dwLen = sizeof(QUERY_RESTRICTION);
    dwLen += WSZ_BYTECOUNT(szField);

    PQUERY_RESTRICTION pNew = (QUERY_RESTRICTION*)LocalAlloc(LPTR, dwLen);
    if (NULL == pNew)
        return NULL;

    PBYTE pCurWrite = ((PBYTE)pNew) + sizeof(QUERY_RESTRICTION) ;
    pNew->szField = (LPWSTR)pCurWrite;
    wcscpy(pNew->szField, szField);

    pNew->iOperation = iOp;

    // copy data pointed to by pvarValue
    CopyMemory(&pNew->varValue, pvarValue, sizeof(VARIANT));

    // good enough except for string -- alloc for it
    if (VT_BSTR == pvarValue->vt)
    {
        pNew->varValue.bstrVal = SysAllocString(pvarValue->bstrVal);
        if (NULL == pNew->varValue.bstrVal)
        {
            // failed!
            FreeQueryRestriction(pNew);
            pNew = NULL;
        }
    }

    return pNew;
}

void FreeQueryRestriction(PQUERY_RESTRICTION pQR)
{
    VariantClear(&pQR->varValue);
    LocalFree(pQR);
}

void FreeQueryRestrictionList(PQUERY_RESTRICTION pQR)
{
    PQUERY_RESTRICTION pTmp;
    while(pQR)
    {   
        pTmp = pQR->pNext;
        FreeQueryRestriction(pQR);
        pQR = pTmp;
    }
}


void ListInsertAtEnd(void** ppList, void* pElt)
{
    if (pElt != NULL)
    {
    
    // he's always at the end of the list
    ((PELT_PTR)pElt)->pNext = NULL;
    void* pCurPtr = *ppList;

    if (*ppList == NULL)
    {
        *ppList = pElt;
    }
    else
    {
        while( ((PELT_PTR)pCurPtr)->pNext != NULL )
        {
            pCurPtr = ((PELT_PTR)pCurPtr)->pNext;
        }

        ((PELT_PTR)pCurPtr)->pNext = (PELT_PTR) pElt;
    }
    }

    return;
}


// dwIndex should be zero at first, then passed in for each consecutive call
LPWSTR RegEnumKeyContaining(
    HKEY hBaseKey,
    LPCWSTR szContainsString, 
    DWORD* pdwIndex)
{
    HRESULT hr = S_OK;
    LPWSTR szKeyName = NULL;

    LPWSTR szBuf = NULL;
    DWORD cbBuf = 0, cbBufUsed;
    FILETIME ft;
    
    ASSERT(pdwIndex);


    hr = RegQueryInfoKey(
        hBaseKey,
        NULL,
        NULL,   // classes
        NULL,   // reserved
        NULL,   // cSubkeys
        &cbBuf, // maxsubkeylen in chars (not counting null term)
        NULL,   // max class len
        NULL,   // num values
        NULL,   // max value name len
        NULL,   // max value len
        NULL,   // sec descr
        NULL    // last filetime
        );
    _JumpIfError(hr, Ret, "RegQueryInfoKey");

    cbBuf += 1;
    cbBuf *= sizeof(WCHAR);
    szBuf = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf);
    _JumpIfOutOfMemory(hr, Ret, szBuf);


    for (; ; (*pdwIndex)++)
    {
        // tell api how much memory we have (incl NULL char)
        cbBufUsed = cbBuf;

        hr = RegEnumKeyEx(
            hBaseKey, 
            *pdwIndex, 
            szBuf, 
            &cbBufUsed,    // doesn't get updated in small buffer case?!
            NULL, 
            NULL, 
            NULL, 
            &ft);
        _JumpIfError2(hr, Ret, "RegEnumKeyEx", ERROR_NO_MORE_ITEMS);
        
        // we have data, check if it is one we're interested in
        if (NULL != wcsstr(szBuf, szContainsString))
            break;
    }

    // don't point at this one again
    (*pdwIndex)++;
    hr = S_OK;

Ret:
    if (S_OK != hr)
    {
        LocalFree(szBuf);
        szBuf = NULL;
    }

    return ( szBuf );
}



DISPLAYSTRING_EXPANSION g_displayStrings[11] =
{
    { wszFCSAPARM_SERVERDNSNAME,            IDS_TOKEN_SERVERDNSNAME,        IDS_TOKENDESC_SERVERDNSNAME         },       //%1
    { wszFCSAPARM_SERVERSHORTNAME,          IDS_TOKEN_SERVERSHORTNAME,      IDS_TOKENDESC_SERVERSHORTNAME       },     //%2
    { wszFCSAPARM_SANITIZEDCANAME,          IDS_TOKEN_SANITIZEDCANAME,      IDS_TOKENDESC_SANITIZEDCANAME       },     //%3
    { wszFCSAPARM_CERTFILENAMESUFFIX,       IDS_TOKEN_CERTFILENAMESUFFIX,   IDS_TOKENDESC_CERTFILENAMESUFFIX    },  //%4
    { L"",                                  IDS_DESCR_UNKNOWN,              IDS_DESCR_UNKNOWN }, // %5 not available 
    { wszFCSAPARM_CONFIGDN,                 IDS_TOKEN_CONFIGDN,             IDS_TOKENDESC_CONFIGDN              },            //%6
    { wszFCSAPARM_SANITIZEDCANAMEHASH,      IDS_TOKEN_SANITIZEDCANAMEHASH,  IDS_TOKENDESC_SANITIZEDCANAMEHASH   }, //%7
    { wszFCSAPARM_CRLFILENAMESUFFIX,        IDS_TOKEN_CRLFILENAMESUFFIX,    IDS_TOKENDESC_CRLFILENAMESUFFIX     },   //%8
    { wszFCSAPARM_CRLDELTAFILENAMESUFFIX,   IDS_TOKEN_CRLDELTAFILENAMESUFFIX,IDS_TOKENDESC_CRLDELTAFILENAMESUFFIX},  //%9
    { wszFCSAPARM_DSCRLATTRIBUTE,           IDS_TOKEN_DSCRLATTRIBUTE,       IDS_TOKENDESC_DSCRLATTRIBUTE        },      //%10
    { wszFCSAPARM_DSCACERTATTRIBUTE,        IDS_TOKEN_DSCACERTATTRIBUTE,    IDS_TOKENDESC_DSCACERTATTRIBUTE     },   //%11
};



/////////////////////////////////////////
// fxns to load resources automatically
CLocalizedResources g_cResources;

CLocalizedResources::CLocalizedResources()
{
    m_fLoaded = FALSE;
}

BOOL CLocalizedResources::Load()
{
    if (!m_fLoaded)
    {
        HINSTANCE hRsrc = AfxGetResourceHandle();

	myVerifyResourceStrings(g_hInstance);

        // Load strings from resources
        m_ColumnHead_Name.LoadString(IDS_COLUMN_NAME);             
        m_ColumnHead_Size.LoadString(IDS_COLUMN_SIZE);             
        m_ColumnHead_Type.LoadString(IDS_COLUMN_TYPE);             
        m_ColumnHead_Description.LoadString(IDS_COLUMN_DESCRIPTION);

        m_DescrStr_CA.LoadString(IDS_DESCR_CA);
        m_DescrStr_Unknown.LoadString(IDS_DESCR_UNKNOWN);

        m_szFilterApplied.LoadString(IDS_STATUSBAR_FILTER_APPLIED);
        m_szSortedAscendingTemplate.LoadString(IDS_STATUSBAR_SORTEDBY_ASCEND);
        m_szSortedDescendingTemplate.LoadString(IDS_STATUSBAR_SORTEDBY_DESCEND);
        m_szStoppedServerMsg.LoadString(IDS_STOPPED_SERVER_MSG);
        m_szStatusBarErrorFormat.LoadString(IDS_STATUSBAR_ERRORTEMPLATE);

        m_szRevokeReason_Unspecified.LoadString(IDS_CRL_REASON_UNSPECIFIED);
        m_szRevokeReason_KeyCompromise.LoadString(IDS_CRL_REASON_KEY_COMPROMISE);
        m_szRevokeReason_CaCompromise.LoadString(IDS_CRL_REASON_CA_COMPROMISE);
        m_szRevokeReason_Affiliation.LoadString(IDS_CRL_REASON_AFFILIATION_CHANGED);
        m_szRevokeReason_Superseded.LoadString(IDS_CRL_REASON_SUPERSEDED);
        m_szRevokeReason_Cessatation.LoadString(IDS_CRL_REASON_CESSATION_OF_OPERATION);
        m_szRevokeReason_CertHold.LoadString(IDS_CRL_REASON_CERTIFICATE_HOLD);
        m_szRevokeReason_RemoveFromCRL.LoadString(IDS_CRL_REASON_REMOVE_FROM_CRL);

        m_szPeriod_Seconds.LoadString(IDS_PERIOD_SECONDS);
        m_szPeriod_Minutes.LoadString(IDS_PERIOD_MINUTES);
        m_szPeriod_Hours.LoadString(IDS_PERIOD_HOURS);  
        m_szPeriod_Days.LoadString(IDS_PERIOD_DAYS);
        m_szPeriod_Weeks.LoadString(IDS_PERIOD_WEEKS);
        m_szPeriod_Months.LoadString(IDS_PERIOD_MONTHS);
        m_szPeriod_Years.LoadString(IDS_PERIOD_YEARS);

        m_szYes.LoadString(IDS_YES);

        // Load the bitmaps from the dll
        m_bmpSvrMgrToolbar1.LoadBitmap(IDB_TOOLBAR_SVRMGR1);

        // load view strings to struct members, point to struct members
        int i;

        // viewResult items
        for(i=0; ((viewResultItems[i].item.strName != NULL) && (viewResultItems[i].item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, viewResultItems[i].uiString1, viewResultItems[i].szString1, sizeof(viewResultItems[i].szString1));
            viewResultItems[i].item.strName = viewResultItems[i].szString1;

            LoadString(hRsrc, viewResultItems[i].uiString2, viewResultItems[i].szString2, sizeof(viewResultItems[i].szString2));
            viewResultItems[i].item.strStatusBarText = viewResultItems[i].szString2;
        }
        
        // taskResultItemsSingleSel
        for(i=0; ((taskResultItemsSingleSel[i].myitem.item.strName != NULL) && (taskResultItemsSingleSel[i].myitem.item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, taskResultItemsSingleSel[i].myitem.uiString1, taskResultItemsSingleSel[i].myitem.szString1, sizeof(taskResultItemsSingleSel[i].myitem.szString1));
            taskResultItemsSingleSel[i].myitem.item.strName = taskResultItemsSingleSel[i].myitem.szString1;

            LoadString(hRsrc, taskResultItemsSingleSel[i].myitem.uiString2, taskResultItemsSingleSel[i].myitem.szString2, sizeof(taskResultItemsSingleSel[i].myitem.szString2));
            taskResultItemsSingleSel[i].myitem.item.strStatusBarText = taskResultItemsSingleSel[i].myitem.szString2;
        }

        // task start/stop
        for(i=0; ((taskStartStop[i].item.strName != NULL) && (taskStartStop[i].item.strStatusBarText != NULL)); i++) 
        {
            LoadString(hRsrc, taskStartStop[i].uiString1, taskStartStop[i].szString1, sizeof(taskStartStop[i].szString1));
            taskStartStop[i].item.strName = taskStartStop[i].szString1;

            LoadString(hRsrc, taskStartStop[i].uiString2, taskStartStop[i].szString2, sizeof(taskStartStop[i].szString2));
            taskStartStop[i].item.strStatusBarText = taskStartStop[i].szString2;
        }

        // taskitems
        for(i=0; ((taskItems[i].myitem.item.strName != NULL) && (taskItems[i].myitem.item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, taskItems[i].myitem.uiString1, taskItems[i].myitem.szString1, sizeof(taskItems[i].myitem.szString1));
            taskItems[i].myitem.item.strName = taskItems[i].myitem.szString1;

            LoadString(hRsrc, taskItems[i].myitem.uiString2, taskItems[i].myitem.szString2, sizeof(taskItems[i].myitem.szString2));
            taskItems[i].myitem.item.strStatusBarText = taskItems[i].myitem.szString2;
        }

        // topitems
        for(i=0; ((topItems[i].myitem.item.strName != NULL) && (topItems[i].myitem.item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, topItems[i].myitem.uiString1, topItems[i].myitem.szString1, sizeof(topItems[i].myitem.szString1));
            topItems[i].myitem.item.strName = topItems[i].myitem.szString1;

            LoadString(hRsrc, topItems[i].myitem.uiString2, topItems[i].myitem.szString2, sizeof(topItems[i].myitem.szString2));
            topItems[i].myitem.item.strStatusBarText = topItems[i].myitem.szString2;
        }

        for (i=0; ((SvrMgrToolbar1Buttons[i].item.lpButtonText != NULL) && (SvrMgrToolbar1Buttons[i].item.lpTooltipText != NULL)); i++)
        {
            LoadString(hRsrc, SvrMgrToolbar1Buttons[i].uiString1, SvrMgrToolbar1Buttons[i].szString1, sizeof(SvrMgrToolbar1Buttons[i].szString1));
            SvrMgrToolbar1Buttons[i].item.lpButtonText = SvrMgrToolbar1Buttons[i].szString1;

            LoadString(hRsrc, SvrMgrToolbar1Buttons[i].uiString2, SvrMgrToolbar1Buttons[i].szString2, sizeof(SvrMgrToolbar1Buttons[i].szString2));
            SvrMgrToolbar1Buttons[i].item.lpTooltipText = SvrMgrToolbar1Buttons[i].szString2;
        }

	// load replacement tokens
        for (i=0; i<DISPLAYSTRINGS_TOKEN_COUNT; i++)
        {
            g_displayStrings[i].pcstrExpansionString = new CString;
            if (g_displayStrings[i].pcstrExpansionString != NULL)
                g_displayStrings[i].pcstrExpansionString->LoadString(g_displayStrings[i].uTokenID);

            g_displayStrings[i].pcstrExpansionStringDescr = new CString;
            if (g_displayStrings[i].pcstrExpansionStringDescr != NULL)
                g_displayStrings[i].pcstrExpansionStringDescr->LoadString(g_displayStrings[i].uTokenDescrID);
        }

        m_fLoaded = TRUE;
    }

    return m_fLoaded;
}

CLocalizedResources::~CLocalizedResources()
{
    m_fLoaded = FALSE;

    for (int i=0; i<DISPLAYSTRINGS_TOKEN_COUNT; i++)
    {
        if (g_displayStrings[i].pcstrExpansionString)
            delete g_displayStrings[i].pcstrExpansionString;

        if (g_displayStrings[i].pcstrExpansionStringDescr)
            delete g_displayStrings[i].pcstrExpansionStringDescr;
    }

}

HRESULT ReadOfSize(IStream* pStm, void* pbData, ULONG cbData)
{
    HRESULT hr; 
    ULONG nBytesRead;
    hr = pStm->Read(pbData, cbData, &nBytesRead);
    if ((hr == S_OK) && (nBytesRead != cbData))
        hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
    return hr;        
}

HRESULT WriteOfSize(IStream* pStm, void* pbData, ULONG cbData)
{
    HRESULT hr; 
    ULONG nBytesWritten;
    hr = pStm->Write(pbData, cbData, &nBytesWritten);
    if ((hr == S_OK) && (nBytesWritten != cbData))
        hr = HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);
    return hr;        
}


HRESULT
myOIDToName(
    IN WCHAR const *pwszObjId,
    OUT LPWSTR*     pszName)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszName = L"";
    WCHAR const *pwszName1 = L"";
    WCHAR const *pwszName2;
    WCHAR *pwszT = NULL;
    WCHAR rgwchName[64];
    
    if (pszName == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pszName NULL");
    }

    pwszT = (LPWSTR) LocalAlloc(LMEM_FIXED, (1 + 1 + wcslen(pwszObjId)) * sizeof(WCHAR));
    if (NULL == pwszT)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "no memory for skip counts array");
    }
    wcscpy(&pwszT[1], pwszObjId);
    
    *pwszT = L'+';
    pwszName1 = myGetOIDName(pwszT);	// Group OID lookup
    
    *pwszT = L'-';
    pwszName2 = myGetOIDName(pwszT);	// Generic OID lookup
    
    if (0 == lstrcmpi(pwszName1, pwszName2))
    {
        pwszName2 = L"";		// display only one if they're the same
    }
    if (L'\0' == *pwszName1)
    {
        pwszName1 = pwszName2;
        pwszName2 = L"";
    }
    
    if (L'\0' != *pwszName2 &&
        ARRAYSIZE(rgwchName) > wcslen(pwszName1) + wcslen(pwszName2) + 3)
    {
        wcscpy(rgwchName, pwszName1);
        wcscat(rgwchName, L" " wszLPAREN);
        wcscat(rgwchName, pwszName2);
        wcscat(rgwchName, wszRPAREN);
        pwszName1 = rgwchName;
    }

    *pszName = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(pwszName1)+1)*sizeof(WCHAR));
    if (NULL == *pszName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "pszName");
    }
    wcscpy(*pszName, pwszName1);
    
error:
    if (NULL != pwszT)
    {
    	LocalFree(pwszT);
    }

    return hr;
}

#include "csdisp.h"

HRESULT
myDumpFormattedObject(
    IN WCHAR const *pwszObjId,
    IN BYTE const *pbObject,
    IN DWORD cbObject,
    OUT LPWSTR* ppwszFormatted)
{
    HRESULT hr = S_OK;
    char * pszObjId = NULL;
    DWORD cbFormatted;
    WCHAR const *pwszDescriptiveName;

    if (ppwszFormatted == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL param");
    }
    
    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToSz");
    }

    // format the object using the installed formatting function
    if (!CryptFormatObject(
        X509_ASN_ENCODING,
        0,
        CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
        NULL,
        pszObjId,
        pbObject,
        cbObject,
        NULL,
        &cbFormatted))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "CryptFormatObject");
    }
    
    *ppwszFormatted = (WCHAR *) LocalAlloc(LMEM_FIXED, cbFormatted);
    if (NULL == *ppwszFormatted)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    
    if (!CryptFormatObject(
        X509_ASN_ENCODING,
        0,
        CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
        NULL,
        pszObjId,
        pbObject,
        cbObject,
        *ppwszFormatted,
        &cbFormatted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptFormatObject");
    }

    /*
    if (g_fVerbose)
    {
        if (0 == strcmp(szOID_SUBJECT_ALT_NAME, pszObjId) ||
            0 == strcmp(szOID_SUBJECT_ALT_NAME2, pszObjId) ||
            0 == strcmp(szOID_ISSUER_ALT_NAME, pszObjId) ||
            0 == strcmp(szOID_ISSUER_ALT_NAME2, pszObjId))
        {
            DumpAltName(pbObject, cbObject);
        }
    }
    */
error:
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr || CRYPT_E_ASN1_BADTAG == hr)
    {
        // fix up nonfatal errors
        CString cstrUnknown;
        cstrUnknown.LoadString(IDS_UNKNOWN_EXTENSION);
        hr = myDupString((LPCWSTR)cstrUnknown, ppwszFormatted);
        _PrintIfError(hr, "myDupString failure");
    }

    if (pszObjId)
        LocalFree(pszObjId);

    return hr;
}

void 
InplaceStripControlChars(WCHAR* szString)
{
   // remove \r and \n AND \t formatting through end-of-string
   if (NULL != szString)
   {
       while (*szString != L'\0')
       {
          switch(*szString)
          {
              case L'\r':
              case L'\n':
              case L'\t':
              *szString = L' ';
                 break;
          }
          szString++;
       }
   }
}


HANDLE EnablePrivileges(LPCWSTR ppcwszPrivileges[], ULONG cPrivileges)
{
    BOOL                fResult = FALSE;
    HANDLE              hToken = INVALID_HANDLE_VALUE;
    HANDLE              hOriginalThreadToken = INVALID_HANDLE_VALUE;
    PTOKEN_PRIVILEGES   ptp;
    ULONG               nBufferSize;

    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    nBufferSize = sizeof(TOKEN_PRIVILEGES) + (cPrivileges - 1)*sizeof(LUID_AND_ATTRIBUTES);
    ptp = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
    if (!ptp)
        return INVALID_HANDLE_VALUE;
    //
    // Initialize the Privileges Structure
    //
    ptp->PrivilegeCount = cPrivileges;
    for (ULONG i = 0; i < cPrivileges; i++)
    {
        fResult = LookupPrivilegeValue(NULL, ppcwszPrivileges[i], &ptp->Privileges[i].Luid);
        if (!fResult)
            break;
        ptp->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    if(fResult)
    {
        //
        // Open the Token
        //
        hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;
        fResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken);
        if (fResult)
            hOriginalThreadToken = hToken;  // Remember the thread token
        else
            fResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
    }

    if (fResult)
    {
        HANDLE hNewToken;

        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                   // PSECURITY_ATTRIBUTES
                                   SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                                   TokenImpersonation,     // TokenType
                                   &hNewToken);            // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                                            FALSE,      // DisableAllPrivileges
                                            ptp,        // NewState
                                            0,          // BufferLength
                                            NULL,       // PreviousState
                                            NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    // If something failed, don't return a token
    if (!fResult)
        hOriginalThreadToken = INVALID_HANDLE_VALUE;

    // Close the original token if we aren't returning it
    if (hOriginalThreadToken == INVALID_HANDLE_VALUE && hToken != INVALID_HANDLE_VALUE)
        CloseHandle(hToken);

    // If we succeeded, but there was no original thread token,
    // return NULL to indicate we need to do SetThreadToken(NULL, NULL)
    // to release privs.
    if (fResult && hOriginalThreadToken == INVALID_HANDLE_VALUE)
        hOriginalThreadToken = NULL;

    LocalFree(ptp);

    return hOriginalThreadToken;
}


void ReleasePrivileges(HANDLE hToken)
{
    if (INVALID_HANDLE_VALUE != hToken)
    {
        SetThreadToken(NULL, hToken);
        if (hToken)
            CloseHandle(hToken);
    }
}


HRESULT
myGetActiveModule(
    CertSvrCA *pCA,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OPTIONAL OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OPTIONAL OUT CLSID *pclsidModule)
{
    HRESULT hr;
    WCHAR *pwsz;
    variant_t var;
    
    hr = pCA->GetConfigEntry(
            fPolicyModule?wszREGKEYPOLICYMODULES:wszREGKEYEXITMODULES,
            wszREGACTIVE,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);

    if(V_VT(&var)==VT_BSTR)
    {
        pwsz = V_BSTR(&var);
    }
    else if(V_VT(&var)==(VT_ARRAY|VT_BSTR))
    {
        SafeArrayEnum<BSTR> saenum(V_ARRAY(&var));
        hr = saenum.GetAt(Index, pwsz);
        _JumpIfError(hr, error, "GetConfigEntry");
    }
    else
    {
        _JumpError(hr, error, "Bad active entry type");
    }

    if(!pwsz)
    {
        _JumpError(hr, error, "empty entry");
    }

    if (NULL != pclsidModule)
    {
        hr = CLSIDFromProgID(pwsz, pclsidModule);
        _JumpIfError(hr, error, "CLSIDFromProgID");
    }
    
    if (NULL != ppwszProgIdModule)
    {
        *ppwszProgIdModule = (LPOLESTR) CoTaskMemAlloc(
            (wcslen(pwsz) + 1) * sizeof(WCHAR));
        if (NULL == *ppwszProgIdModule)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "CoTaskMemAlloc");
        }
        wcscpy(*ppwszProgIdModule, pwsz);
    }
    hr = S_OK;      // not reset after ERROR_MOD_NOT_FOUND in all cases

error:
    return(hr);
}

HRESULT FindComputerObjectSid(
    LPCWSTR pcwszCAComputerDNSName,
    PSID &pSid)
{
    HRESULT hr = S_OK;
    ADS_SEARCHPREF_INFO asi[1];
    IDirectorySearch *pSearch = NULL;
    LPWSTR pwszAttr = L"objectSid";
    ADS_SEARCH_HANDLE hADS = NULL;
    static LPCWSTR pwszgc = L"GC://";
    static LPCWSTR pwszformat = L"(&(objectClass=computer)(servicePrincipalName=host/%s))";
    LPWSTR pwszSearchFilter = NULL;
    LPWSTR pwszGC = NULL;
    DWORD dwres;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    ADS_SEARCH_COLUMN col;
    
    dwres = DsGetDcName(
                NULL, 
                NULL, 
                NULL, 
                NULL, 
                DS_RETURN_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED, 
                &pdci);
    if(NO_ERROR != dwres)
    {
        hr = myHError(dwres);
        _JumpIfError(hr, error, "DsGetDcName");
    }
    
    pwszGC = (LPWSTR)LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(pwszgc)+wcslen(pdci->DnsForestName)+1));
    _JumpIfAllocFailed(pwszGC, error);

    wcscpy(pwszGC, pwszgc);
    wcscat(pwszGC, pdci->DnsForestName);

    hr = ADsGetObject(pwszGC, IID_IDirectorySearch, (void**)&pSearch);
    _JumpIfError(hr, error, "ADsGetObject(GC:)");

    asi[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    asi[0].vValue.dwType = ADSTYPE_INTEGER;
    asi[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    hr = pSearch->SetSearchPreference(asi, 1);
    _JumpIfError(hr, error, "SetSearchPreference");

    pwszSearchFilter = (LPWSTR)LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(pwszformat)+wcslen(pcwszCAComputerDNSName)+1));

    wsprintf(pwszSearchFilter, pwszformat, pcwszCAComputerDNSName);
    
    hr = pSearch->ExecuteSearch(
            pwszSearchFilter, 
            &pwszAttr,
            1,
            &hADS);
    _JumpIfErrorStr(hr, error, "ExecuteSearch", pwszSearchFilter);

    hr = pSearch->GetFirstRow(hADS);
    _JumpIfError(hr, error, "GetFirstRow");

    hr = pSearch->GetColumn(hADS, pwszAttr, &col);
    _JumpIfErrorStr(hr, error, "GetColumn", pwszAttr);

    CSASSERT(IsValidSid(col.pADsValues[0].OctetString.lpValue));
    CSASSERT(GetLengthSid(col.pADsValues[0].OctetString.lpValue)==
        col.pADsValues[0].OctetString.dwLength);

    pSid = LocalAlloc(LMEM_FIXED, col.pADsValues[0].OctetString.dwLength);
    _JumpIfAllocFailed(pSid, error);

    CopySid(col.pADsValues[0].OctetString.dwLength,
            pSid, 
            col.pADsValues[0].OctetString.lpValue);

error:

    if(pdci)
        NetApiBufferFree(pdci);

    if(pSearch)
    {
        pSearch->FreeColumn(&col);

        if(hADS)
            pSearch->CloseSearchHandle(hADS);
        pSearch->Release();
    }
    LOCAL_FREE(pwszSearchFilter);
    LOCAL_FREE(pwszGC);
    return hr;
}



HRESULT IsUserDomainAdministrator(BOOL* pfIsAdministrator)
{
	HRESULT	hr = S_OK;

	*pfIsAdministrator = FALSE;

		PSID						psidAdministrators;
		SID_IDENTIFIER_AUTHORITY	siaNtAuthority = SECURITY_NT_AUTHORITY;

		BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
				0, 0, 0, 0, 0, 0, &psidAdministrators);
		if ( bResult )
		{
			bResult = CheckTokenMembership (0, psidAdministrators,
					pfIsAdministrator);
			ASSERT (bResult);
			if ( !bResult )
			{
				hr = myHLastError ();
                                _PrintError(hr, "CheckTokenMembership");
			}
			FreeSid (psidAdministrators);
		}
		else
		{
			hr = myHLastError ();
                        _PrintError(hr, "AllocateAndInitializeSid");
		}
	return hr;
}


BOOL RestartService(HWND hWnd, CertSvrMachine* pMachine)
{
        // notify user we can't apply immediately
        CString cstrText;
        cstrText.LoadString(IDS_CONFIRM_SERVICE_RESTART);

        if (IDYES == ::MessageBox(hWnd, (LPCWSTR)cstrText, (LPCWSTR)g_cResources.m_DescrStr_CA, MB_YESNO | MB_ICONWARNING ))
        {
            DWORD dwErr;

            // stop the service
            if (pMachine->IsCertSvrServiceRunning())
                pMachine->CertSvrStartStopService(hWnd, FALSE);

            // start the serviec
            dwErr = pMachine->CertSvrStartStopService(hWnd, TRUE);
            if (S_OK != dwErr)
                DisplayGenericCertSrvError(hWnd, dwErr);

            return TRUE;
        }

    return FALSE; // didn't restart
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\krapage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       krapage.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "genpage.h"

#include "csmmchlp.h"
#include "cslistvw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//defines
//dwFlags in KRA_NODE
#define KRA_FROM_CACHE    0x00000001
#define KRA_MARK_ADDED    0x00000002

static const int nImageValidCert = 3;
static const int nImageInvalidCert = 2;
//macros

//local globals

CString CSvrSettingsKRAPage::m_strDispositions[7];


//add a new into the link list
HRESULT
AddNewKRANode(
    IN CERT_CONTEXT const   *pCert,
    IN DWORD dwDisposition,
    IN DWORD                 dwFlags,
    IN OUT KRA_NODE        **ppKRAList,
    OUT OPTIONAL KRA_NODE  **ppKRA)
{
    CSASSERT(NULL != ppKRAList);

    HRESULT hr;
    KRA_NODE *pKRANode = NULL;
    KRA_NODE *pKRA = *ppKRAList;

    pKRANode = (KRA_NODE*)LocalAlloc(LMEM_FIXED, sizeof(KRA_NODE));
    if (NULL == pKRANode)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Out of memory");
    }

    //assign node data and put it at the end
    pKRANode->pCert = pCert;
    pKRANode->dwFlags = dwFlags;
    pKRANode->next = NULL;
    pKRANode->dwDisposition = dwDisposition;

    if (NULL == pKRA)
    {
        //empty list, 1st one
        *ppKRAList = pKRANode;
    }
    else
    {
        //always add to the end
        while (NULL != pKRA->next)
        {
            pKRA = pKRA->next;
        }
        //add
        pKRA->next = pKRANode;
    }

    if (NULL != ppKRA)
    {
        //optional return
        *ppKRA = pKRANode;
    }

    hr = S_OK;
error:
    return hr;
}

void
FreeKRANode(
    KRA_NODE *pKRA)
{
    if (NULL != pKRA->pCert)
    {
        CertFreeCertificateContext(pKRA->pCert);
        pKRA->pCert = NULL;
    }
    LocalFree(pKRA);
}

void
FreeKRAList(
    KRA_NODE  *pKRAList)
{
    KRA_NODE  *pKRA = pKRAList; //point to list
    KRA_NODE  *pKRATemp;

    while (NULL != pKRA)
    {
        pKRATemp= pKRA;  //save it for free
        // update for the loop
        pKRA= pKRA->next;
        FreeKRANode(pKRATemp);
    }
}

//remove a kra node from the link list
void
RemoveKRANode(
    IN OUT KRA_NODE  **ppKRAList,
    IN KRA_NODE      *pKRA)
{
    CSASSERT(NULL != ppKRAList && NULL != *ppKRAList && NULL != pKRA);

    KRA_NODE *pKRACurrent = *ppKRAList;
    KRA_NODE *pKRALast = NULL;

    //find the node
    while (NULL != pKRACurrent && pKRACurrent != pKRA)
    {
        pKRALast = pKRACurrent; //remember last one
        pKRACurrent = pKRACurrent->next;
    }
    CSASSERT(NULL != pKRACurrent); //node must be in the list

    if (NULL != pKRACurrent->next)
    {
        if (NULL == pKRALast)
        {
            //means the node is the begining
            CSASSERT(pKRA == *ppKRAList);
            *ppKRAList = pKRA->next; //make next as begining
        }
        else
        {
            //make next pointer of the last node to the next
            pKRALast->next = pKRACurrent->next;
        }
    }
    else
    {
        if (NULL == pKRALast)
        {
            //this is the only node
            *ppKRAList = NULL; //empty list
        }
        else
        {
            //the node is the end, make last as the end
            pKRALast->next = NULL;
        }
    }

    //now, remove the current node
    FreeKRANode(pKRACurrent);
}    

BOOL
DoesKRACertExist(
    IN KRA_NODE             *pKRAList,
    IN CERT_CONTEXT const   *pKRACert)
{
    BOOL fExists = FALSE;

    while (NULL != pKRAList)
    {
        if(pKRAList->pCert)
        {
            fExists = CertCompareCertificate(
                            X509_ASN_ENCODING,
                            pKRAList->pCert->pCertInfo,
                            pKRACert->pCertInfo);
            if (fExists)
            {
                //done
                break;
            }
        }
        pKRAList = pKRAList->next;
    }
    return fExists;
}

DWORD
GetKRACount(
    IN KRA_NODE const *pKRAList)
{
    DWORD count = 0;

    while(NULL != pKRAList)
    {
        pKRAList = pKRAList->next;
        ++count;
    }
    return count;
}

LPCWSTR CSvrSettingsKRAPage::MapDispositionToString(DWORD dwDisp)
{
    if(dwDisp>ARRAYSIZE(m_strDispositions))
        dwDisp = KRA_DISP_INVALID;
    return CSvrSettingsKRAPage::m_strDispositions[dwDisp];
}

void CSvrSettingsKRAPage::LoadKRADispositions()
{
    DWORD cKRA = GetKRACount(m_pKRAList);
    variant_t var;
    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_KRA);
    LVITEM lvitem;
    ICertAdmin2 *pAdmin = NULL;

    // Don't use a cached admin interface, we need latest KRA cert
    // state from the server, not a cached result
    m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
    if(!pAdmin)
        return;

    lvitem.mask = LVIF_IMAGE;
    lvitem.iSubItem = 0;
        
    for(DWORD cCrtKRA=0;cCrtKRA<cKRA;cCrtKRA++)
    {
        V_I4(&var) = KRA_DISP_INVALID;
        pAdmin->GetCAProperty(
            m_pCA->m_bstrConfig,
            CR_PROP_KRACERTSTATE,
            cCrtKRA,
            PROPTYPE_LONG,
            0,
            &var);

        ListView_SetItemText(
            hwndList, 
            cCrtKRA, 
            3,
            (LPWSTR)MapDispositionToString(V_I4(&var)));

        lvitem.iImage = V_I4(&var)==KRA_DISP_VALID?
                        nImageValidCert:nImageInvalidCert;
        lvitem.iItem = cCrtKRA;
        ListView_SetItem(
            hwndList, 
            &lvitem);
    }

    if(pAdmin)
        pAdmin->Release();
}

HRESULT
CSvrSettingsKRAPage::LoadKRAList(ICertAdmin2 *pAdmin)
{
    HRESULT hr;
    KRA_NODE  *pKRAList = NULL;
    DWORD     i;
    const CERT_CONTEXT *pCertContext;
    LPCWSTR pwszSanitizedCAName = m_pCA->m_strSanitizedName;
    KRA_NODE **ppKRAList = &m_pKRAList;
    variant_t var;

    hr = pAdmin->GetCAProperty(
                m_pCA->m_bstrConfig,
                CR_PROP_KRACERTCOUNT,
                0,
                PROPTYPE_LONG,
                0,
                &var);
    _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERTCOUNT");

    CSASSERT(V_VT(&var)==VT_I4);
    m_dwKRACount = V_I4(&var);

    for (i = 0; i < m_dwKRACount; ++i)
    {
        variant_t varCert;
        variant_t varDisp;

        pCertContext = NULL;

        hr = pAdmin->GetCAProperty(
                    m_pCA->m_bstrConfig,
                    CR_PROP_KRACERT,
                    i,
                    PROPTYPE_BINARY,
                    CR_OUT_BINARY,
                    &varCert);
        if(S_OK==hr)
        {
            CSASSERT(V_VT(&varCert)==VT_BSTR);
            CSASSERT(V_BSTR(&varCert));

            pCertContext = CertCreateCertificateContext(
                X509_ASN_ENCODING,
                (BYTE*)V_BSTR(&varCert),
                SysStringByteLen(V_BSTR(&varCert)));
            if(!pCertContext)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                _JumpError(hr, error, "CertCreateCertificateContext");
            }
        }
        
        V_I4(&varDisp) = KRA_DISP_INVALID;
        pAdmin->GetCAProperty(
            m_pCA->m_bstrConfig,
            CR_PROP_KRACERTSTATE,
            i,
            PROPTYPE_LONG,
            0,
            &varDisp);
        
        hr = AddNewKRANode(
                pCertContext, V_I4(&varDisp), KRA_FROM_CACHE, &pKRAList, NULL);
        _JumpIfError(hr, error, "AddNewKRANode");
    }

    *ppKRAList = pKRAList;
    pKRAList = NULL;

    hr = pAdmin->GetCAProperty(
                m_pCA->m_bstrConfig,
                CR_PROP_KRACERTUSEDCOUNT,
                0,
                PROPTYPE_LONG,
                0,
                &var);
    _JumpIfError(hr, error, "GetCAProperty wszREGKRACERTCOUNT");

    CSASSERT(VT_I4==V_VT(&var));
    m_dwKRAUsedCount = V_I4(&var);

    m_fArchiveKey = m_dwKRAUsedCount?TRUE:FALSE;

    hr = S_OK;
error:
    if (NULL != pKRAList)
    {
        FreeKRAList(pKRAList);
    }
    return hr;
}

HRESULT
CSvrSettingsKRAPage::SaveKRAList(ICertAdmin2 *pAdmin)
{
    HRESULT hr;
    HCERTSTORE hCAStore = NULL;
    KRA_NODE *pKRA = m_pKRAList; //point to the list
    DWORD     dwIndex = 0;
    DWORD dwNewKRACount;
    variant_t var;
    
    if (m_fKRAUpdate)
    {
        while (NULL != pKRA)
        {
            if(pKRA->pCert)
            {
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = NULL;
    
            hr = EncodeCertString(
                    pKRA->pCert->pbCertEncoded, 
                    pKRA->pCert->cbCertEncoded,
                    CV_OUT_BINARY, 
                    &(V_BSTR(&var)));
            _JumpIfError(hr, error, "EncodeCertString");
    
            hr = pAdmin->SetCAProperty(
                        m_pCA->m_bstrConfig,
                        CR_PROP_KRACERT,
                        dwIndex,
                        PROPTYPE_BINARY,
                        &var);
            _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERT");

            var.Clear();
            }

            ++dwIndex;
            pKRA = pKRA->next;
        }

        dwNewKRACount = dwIndex;

        // Update total cert count only if the new list is smaller than the old
        // list, otherwise SetCAProperty calls above already extended the list
        if(dwNewKRACount<m_dwKRACount)
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = dwNewKRACount;

            hr = pAdmin->SetCAProperty(
                        m_pCA->m_bstrConfig,
                        CR_PROP_KRACERTCOUNT,
                        0,
                        PROPTYPE_LONG,
                        &var);
            _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERTCOUNT");
        }
        
        m_dwKRACount = dwNewKRACount;
    }

    if (m_fCountUpdate)
    {
        V_VT(&var) = VT_I4;
        V_I4(&var) = m_dwKRAUsedCount;

        hr = pAdmin->SetCAProperty(
                    m_pCA->m_bstrConfig,
                    CR_PROP_KRACERTUSEDCOUNT,
                    0,
                    PROPTYPE_LONG,
                    &var);
        _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERTUSEDCOUNT");
    }

    hr = S_OK;

error:
    var.Clear();
    return hr;
}

HRESULT
KRACertGetName(
    IN CERT_CONTEXT const *pCert,
    IN DWORD               dwFlags,  //dwFlags in CertGetNameString
    OUT WCHAR            **ppwszName)
{
    HRESULT hr;
    DWORD   dwTypeParam;
    DWORD   cch = 0;
    WCHAR  *pwszName = NULL;
    LPCWSTR pcwszEmpty = L"";

    CSASSERT(NULL != ppwszName);

    cch = 0;
    while (TRUE)
    {
        if(pCert)
        {
            cch = CertGetNameString(
                    pCert,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    dwFlags,  //subject or issuer
                    &dwTypeParam,
                    pwszName,
                    cch);
        }
        else
        {
            if(!pwszName)
                cch = sizeof(WCHAR)*(wcslen(pcwszEmpty)+1);
            else
                wcscpy(pwszName, pcwszEmpty);
        }
        if (0 == cch)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertGetNameString");
        }
        if (NULL != pwszName)
        {
            //done
            break;
        }
        pwszName = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwszName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }
    *ppwszName = pwszName;
    pwszName = NULL;

    hr = S_OK;
error:
    if (NULL != pwszName)
    {
        LocalFree(pwszName);
    }
    return hr;
}

void
ListView_AddKRAItem(
    HWND      hwndListKRA,
    int       iItem,
    KRA_NODE *pKRA)
{
    HRESULT  hr;
    WCHAR   *pwszSubject = NULL;
    WCHAR   *pwszIssuer = NULL;

    CSASSERT(NULL != pKRA);

    //get subject name
    hr = KRACertGetName(pKRA->pCert, 0x0, &pwszSubject);

    if (S_OK != hr)
    {
        CSASSERT(NULL == pwszSubject);
        _PrintError(hr, "Invalid KRA cert");
    }

    //create a new item, 1st column, subject name, item data point to KRA
    ListView_NewItem(hwndListKRA, iItem, pwszSubject, (LPARAM)pKRA, 
        pKRA->dwDisposition==KRA_DISP_VALID?nImageValidCert:nImageInvalidCert);

    if(pKRA->pCert)
    {
        //get issuer name
        hr = KRACertGetName(pKRA->pCert, CERT_NAME_ISSUER_FLAG, &pwszIssuer);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszIssuer);
            _PrintError(hr, "KRACertGetName(issuer)");
        }

        //2nd column, issuer name
        ListView_SetItemText(hwndListKRA, iItem, 1, pwszIssuer); 

        //3rd column, expiration date
        ListView_SetItemFiletime(hwndListKRA, iItem, 2,
                                 &pKRA->pCert->pCertInfo->NotAfter);
    }

    //4th column, status
    ListView_SetItemText(hwndListKRA, iItem, 3, 
        (LPWSTR)CSvrSettingsKRAPage::MapDispositionToString(
            pKRA->dwDisposition)); 


    if (NULL != pwszSubject)
    {
        LocalFree(pwszSubject);
    }
    if (NULL != pwszIssuer)
    {
        LocalFree(pwszIssuer);
    }
}

////
// Settings: KRA page
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsKRAPage property page

CSvrSettingsKRAPage::CSvrSettingsKRAPage(
    CertSvrCA               *pCA,
    CSvrSettingsGeneralPage *pControlPage,
    UINT                     uIDD) 
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage), m_pCA(pCA)
{
    m_fArchiveKey = FALSE;
    m_fCountUpdate = FALSE;
    m_fKRAUpdate = FALSE;
    m_pKRAList = NULL;
    m_dwKRAUsedCount = 0;
    m_dwKRACount = 0;

    for(DWORD cStr=0;cStr<ARRAYSIZE(m_strDispositions);cStr++)
    {
        // IDS_DISPOSITION_* order must match KRA_DISP_*
        if(m_strDispositions[cStr].IsEmpty())
            m_strDispositions[cStr].LoadString(IDS_DISPOSITION_EXPIRED+cStr);
    }
    
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE_CHOOSE_KRA);
}

CSvrSettingsKRAPage::~CSvrSettingsKRAPage()
{
    if (NULL != m_pKRAList)
    {
        FreeKRAList(m_pKRAList);
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsKRAPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_dwKRAUsedCount = GetDlgItemInt(
            m_hWnd, IDC_KRA_EDITCOUNT, NULL, FALSE);
    }
    else
    {
        SetDlgItemInt(m_hWnd, IDC_KRA_EDITCOUNT, m_dwKRAUsedCount, FALSE);
    }
    return TRUE;
}

void CSvrSettingsKRAPage::EnableKRAEdit(BOOL fEnabled)
{
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_EDITCOUNT), fEnabled);
}

void CSvrSettingsKRAPage::EnableKRAListView(BOOL fEnabled)
{
    // when disabling the list, deselect any item
    if(!fEnabled)
    {
        ListView_SetItemState(GetDlgItem(m_hWnd, IDC_LIST_KRA), 
        -1, 0, LVIS_SELECTED);
    }
    // when enabling the list, select first item
    else
    {
        ListView_SetItemState(GetDlgItem(m_hWnd, IDC_LIST_KRA), 
        0, LVIS_SELECTED, LVIS_SELECTED);
    }

    ::EnableWindow(GetDlgItem(m_hWnd, IDC_LIST_KRA), fEnabled);

}

bool CSvrSettingsKRAPage::IsCurrentItemValidCert()
{
    HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);
    // get kra index # from the current selection
    int iSel = ListView_GetCurSel(hwndListKRA);
    if (-1 == iSel)
    {
        return false;
    }

    // get item data
    KRA_NODE* pKRA = (KRA_NODE*)ListView_GetItemData(hwndListKRA, iSel);

    if(pKRA)
        return pKRA->pCert?true:false;
    else
        return false;
}

void CSvrSettingsKRAPage::EnableKRARemoveViewListButtons(BOOL fEnabled)
{
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_REMOVE), fEnabled);

    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_VIEW), fEnabled && 
        IsCurrentItemValidCert());
}

void CSvrSettingsKRAPage::EnableKRAAddListButton(BOOL fEnabled)
{
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_ADD), fEnabled);
}


void CSvrSettingsKRAPage::EnableKRARadioButtons(BOOL fMoreThanZero)
{
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_ENABLE), fMoreThanZero);
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_DISABLE), fMoreThanZero);
}

void
CSvrSettingsKRAPage::OnAddKRA()
{
    HRESULT hr;
    CERT_CONTEXT const *pKRACert = NULL;  //don't free
    KRA_NODE           *pKRA = NULL;  //don't free
	HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    hr = myGetKRACertificateFromPicker(
                g_hInstance,
                hwndListKRA,
                IDS_KRA_ADD_TITLE,
                IDS_KRA_ADD_SUBTITLE,
                NULL,
                m_pCA->FIsUsingDS(),
		FALSE,		// fSilent
                &pKRACert);
    if ((S_OK == hr) && (pKRACert == NULL))
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    if (S_OK != hr)
    {
        CSASSERT(NULL == pKRACert);
        _PrintError(hr, "myGetKRACertificateFromPicker");
        return;
    }

    if (!DoesKRACertExist(m_pKRAList, pKRACert))
    {
        hr = AddNewKRANode(
                    pKRACert,
                    KRA_DISP_NOTLOADED,
                    KRA_MARK_ADDED,
                    &m_pKRAList,
                    &pKRA);
        if (S_OK == hr)
        {
            //add to the kra to the end of the list
            int iItem = ListView_GetItemCount(hwndListKRA);
            ListView_AddKRAItem(hwndListKRA, iItem, pKRA);
            ListView_SetItemState(hwndListKRA, iItem, LVIS_SELECTED, LVIS_SELECTED);
            if (0 == iItem)
            {
                //first item, buttons must have been disabled
                EnableKRARemoveViewListButtons(TRUE);
                EnableKRARadioButtons(TRUE);
                EnableKRAListView(TRUE);
                SendMessage(GetDlgItem(m_hWnd, IDC_KRA_ENABLE),
                                BM_CLICK, (WPARAM)0, (LPARAM)0);
            }
            SetModified(TRUE);
            m_fDirty = TRUE;
            m_fKRAUpdate = TRUE;
        }
        else
        {
            //pop up???
            _PrintError(hr, "AddNewKRANode");
        }
    }
    else
    {
        //UNDONE, ideally, pass m_pKRAList to picker to filter them out
        _PrintError(S_OK, "KRA cert from the picker already in the list");
    }
}

void 
CSvrSettingsKRAPage::OnRemoveKRA()
{
    KRA_NODE *pKRA;
    int       cItem;
	HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    //get the selected KRA
    int iSel = ListView_GetCurSel(hwndListKRA);
    if (-1 == iSel)
    {
        return;
    }
    
    //get current count
    cItem = ListView_GetItemCount(hwndListKRA);

    pKRA = (KRA_NODE*)ListView_GetItemData(hwndListKRA, iSel);
    CSASSERT(NULL != pKRA);
    //remove it from the link list
    RemoveKRANode(&m_pKRAList, pKRA);

    //remove it from UI
    if (ListView_DeleteItem(hwndListKRA, iSel))
    {
        //determine which item is selected
        if (iSel == cItem - 1)
        {
            //the item removed was the last, modify the index
            --iSel;
        }
        if (NULL != m_pKRAList)
        {
            ListView_SetItemState(hwndListKRA, iSel, LVIS_SELECTED, LVIS_SELECTED);
        }
        else
        {
            CSASSERT(1 == cItem);
            //should check disable radio
            SendMessage(GetDlgItem(m_hWnd, IDC_KRA_DISABLE),
                            BM_CLICK, (WPARAM)0, (LPARAM)0);
        }
        SetModified(TRUE);
        m_fKRAUpdate = TRUE;
    }
    else
    {
        _PrintError(E_UNEXPECTED, "ListView_DeleteItem");
    }
}

void 
CSvrSettingsKRAPage::OnViewKRA()
{
    HRESULT hr;
    HCERTSTORE rghStores[2];
    DWORD      cStores = 0;
    HCERTSTORE hCAStore;
    HCERTSTORE hRootStore;
    KRA_NODE  *pKRA;
	HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    CRYPTUI_VIEWCERTIFICATE_STRUCTW sViewCert;
    ZeroMemory(&sViewCert, sizeof(sViewCert));

    // get kra index # from the current selection
    int iSel = ListView_GetCurSel(hwndListKRA);
    if (-1 == iSel)
    {
        return;
    }

    // get item data
    pKRA = (KRA_NODE*)ListView_GetItemData(hwndListKRA, iSel);
    CSASSERT(NULL != pKRA);

    // get CA stores
    hr = m_pCA->GetRootCertStore(&hRootStore);
    if (S_OK == hr)
    {
        rghStores[cStores] = hRootStore;
        ++cStores;
    }
    else
    {
        _PrintError(hr, "GetRootCertStore");
    }

    hr = m_pCA->GetCACertStore(&hCAStore);
    if (S_OK == hr)
    {
        rghStores[cStores] = hCAStore;
        ++cStores;
    }
    else
    {
        _PrintError(hr, "GetCACertStore");
    }

    sViewCert.pCertContext = pKRA->pCert;
    sViewCert.hwndParent = m_hWnd;
    sViewCert.dwSize = sizeof(sViewCert);
    sViewCert.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING |
                        CRYPTUI_WARN_UNTRUSTED_ROOT |
                        CRYPTUI_DISABLE_ADDTOSTORE;

    // if we're opening remotely, don't open local stores
    if (! m_pCA->m_pParentMachine->IsLocalMachine())
        sViewCert.dwFlags |= CRYPTUI_DONT_OPEN_STORES;

    if (0 < cStores)
    {
        sViewCert.rghStores = rghStores;
        sViewCert.cStores = cStores;

        if (!CryptUIDlgViewCertificateW(&sViewCert, NULL))
        {
            hr = myHLastError();
            if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
            {
                _PrintError(hr, "CryptUIDlgViewCertificateW");
            }
        }
    }
    else
    {
        DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_KRA_CANNOT_OPEN_STORE);
    }
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsKRAPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL  fRet = TRUE;
    DWORD dwNewVal;

    switch(LOWORD(wParam))
    {
        case IDC_KRA_ADD:
            OnAddKRA();
        break;
        case IDC_KRA_REMOVE:
            OnRemoveKRA();
        break;
        case IDC_KRA_VIEW:
            OnViewKRA();
        break;

        case IDC_KRA_DISABLE:
            if ((BN_CLICKED == HIWORD(wParam)) && (m_dwKRAUsedCount != 0)) // if click to change state
            {
                SetModified(TRUE);
                m_fArchiveKey = FALSE;
                m_fCountUpdate = TRUE;
                m_dwKRAUsedCount = 0;
                EnableKRAListView(FALSE);
                EnableKRARemoveViewListButtons(FALSE);
                EnableKRAAddListButton(FALSE);
                EnableKRAEdit(FALSE);
                UpdateData(FALSE);
            }
        break;

        case IDC_KRA_ENABLE:
            if ((BN_CLICKED == HIWORD(wParam)) && (m_dwKRAUsedCount == 0)) // if click to change state
            {
                SetModified(TRUE);
                m_fArchiveKey = TRUE;
                m_fCountUpdate = TRUE;
                m_dwKRAUsedCount = 1;
                EnableKRAListView(TRUE);
                EnableKRARemoveViewListButtons(GetKRACount(m_pKRAList));
                EnableKRAAddListButton(TRUE);
                EnableKRAEdit(TRUE);
                UpdateData(FALSE);
            }
        break;

        case IDC_KRA_EDITCOUNT:
            dwNewVal = GetDlgItemInt(
                m_hWnd, IDC_KRA_EDITCOUNT, NULL, FALSE);

            switch(HIWORD(wParam))
            {
            case EN_CHANGE:
                if(dwNewVal != m_dwKRAUsedCount)
                {
                    SetModified(TRUE);
                    m_fCountUpdate = TRUE;
                }
            break;
            
            default:
                fRet = FALSE;
            break;
            }
        break;

        case IDC_LIST_KRA:
            switch(HIWORD(wParam))
            {
                
            case LBN_SELCHANGE:
                int selected = ListView_GetCurSel(
                    GetDlgItem(m_hWnd, IDC_LIST_KRA));
                EnableKRARemoveViewListButtons(selected!=-1);
                break;
            }
        break;

        default:
            fRet = FALSE;
        break;
    }
    return fRet;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsKRAPage radio controls handlers
void CSvrSettingsKRAPage::UpdateKRARadioControls()
{
    int iRadio = IDC_KRA_ENABLE;
    if (0 == m_dwKRAUsedCount)
    {
        iRadio = IDC_KRA_DISABLE;
    }

    SendMessage(GetDlgItem(m_hWnd, iRadio), BM_CLICK, (WPARAM)0, (LPARAM)0);
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsKRAPage message handlers
BOOL CSvrSettingsKRAPage::OnInitDialog()
{
    HRESULT hr;
    HWND    hwndListKRA;
    int     iItem;
    CString cstrItemName;
    KRA_NODE *pKRA;
    variant_t var;
    ICertAdmin2 *pAdmin = NULL;
    HIMAGELIST hImageList = NULL;
    CWaitCursor WaitCursor;

    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    hr = m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
    _JumpIfError(hr, error, "GetAdmin2");

    // set edit max char limit
    SendDlgItemMessage(
        IDC_KRA_EDITCOUNT,
        EM_SETLIMITTEXT,
        (WPARAM)4,
        (LPARAM)0);

    // init listview
	hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    //make listviews whole row selection
    ListView_SetExtendedListViewStyle(hwndListKRA, LVS_EX_FULLROWSELECT);

    hImageList = ImageList_LoadBitmap(
                    g_hInstance, 
                    MAKEINTRESOURCE(IDB_16x16), 
                    16, 
                    1, 
                    RGB(255, 0, 255));
    ListView_SetImageList(hwndListKRA, hImageList, LVSIL_SMALL);

    //set kra list as default focus
    SetFocus(hwndListKRA);

    //add multiple columns
    //column 0
    cstrItemName.LoadString(IDS_LISTCOL_SUBJECT);
    ListView_NewColumn(hwndListKRA, 0, 90, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 1
    cstrItemName.LoadString(IDS_LISTCOL_ISSUER);
    ListView_NewColumn(hwndListKRA, 1, 90, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 2
    cstrItemName.LoadString(IDS_LISTCOL_EXPIRATION_DATE);
    ListView_NewColumn(hwndListKRA, 2, 90, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 3
    cstrItemName.LoadString(IDS_LISTCOL_STATUS);
    ListView_NewColumn(hwndListKRA, 3, 65, (LPWSTR)(LPCWSTR)cstrItemName);
    
    CSASSERT(NULL == m_pKRAList);

    //load all KRA certs
    hr = LoadKRAList(pAdmin);
    if (S_OK != hr)
    {
        CSASSERT(NULL == m_pKRAList);
        _JumpError(hr, error, "LoadKRAList");
    }

    //list KRA certs in UI
    pKRA = m_pKRAList;
    iItem = 0;
    while (NULL != pKRA)
    {
        ListView_AddKRAItem(hwndListKRA, iItem, pKRA);
        ++iItem;
        pKRA = pKRA->next;
    }
   
    //enable view/remove buttons
    EnableKRARemoveViewListButtons(m_fArchiveKey && 0 < iItem);

    //enable add button
    EnableKRAAddListButton(m_fArchiveKey);

    EnableKRARadioButtons(TRUE);

    if (m_fArchiveKey && 0 < iItem)
    {
        //select first one
        ListView_SetItemState(hwndListKRA, 0, LVIS_SELECTED, LVIS_SELECTED);
    }

    EnableKRAEdit(m_dwKRAUsedCount);

    UpdateKRARadioControls();

    UpdateData(FALSE);

    EnableKRAListView(m_dwKRAUsedCount);

error:
	if(pAdmin)
        pAdmin->Release();

    if (hr != S_OK)
    {
		DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return TRUE;
}


void CSvrSettingsKRAPage::OnDestroy() 
{
    // Note - This needs to be called only once.  
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}



BOOL CSvrSettingsKRAPage::OnApply() 
{
    HRESULT hr = S_OK;
    ICertAdmin2 *pAdmin = NULL;
    HWND hwndEdit = GetDlgItem(m_hWnd, IDC_KRA_EDITCOUNT);
    DWORD dwNewVal = GetDlgItemInt(
                m_hWnd, IDC_KRA_EDITCOUNT, NULL, FALSE);


    // If key archival is enabled, you must have at least one
    // KRA defined and the number of used KRAs must be between
    // 1 and total number of KRAs defined
    if(m_fArchiveKey)
    {
        if(0==GetKRACount(m_pKRAList))
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_KRA_NOKRADEFINED);
            SetFocus(GetDlgItem(m_hWnd, IDC_KRA_ADD));//focus on add button
            return FALSE;
        }
    
        if(dwNewVal < 1 || dwNewVal > GetKRACount(m_pKRAList))
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_KRA_COUNT_TOO_BIG);
            SetFocus(hwndEdit); // focus on edit box
            SendMessage(hwndEdit, EM_SETSEL, 0, -1); // select all text
            return FALSE;
        }
    }

    UpdateData(TRUE);

    if (m_fKRAUpdate || m_fCountUpdate)
    {
        hr = m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
        _JumpIfError(hr, error, "GetAdmin");

        // update reg hash list
        hr = SaveKRAList(pAdmin);
        _JumpIfError(hr, error, "SaveKRAList");

        m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_KRA);
        m_pControlPage->TryServiceRestart(SERVERSETTINGS_PROPPAGE_KRA);

        LoadKRADispositions();

        m_fKRAUpdate = FALSE;
        m_fCountUpdate = FALSE;
    }
	
error:
    if(pAdmin)
        pAdmin->Release();

    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}

BOOL CSvrSettingsKRAPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;
    switch(idCtrl)
    {
        //handle double click on list items
        case IDC_LIST_KRA:
            switch(pnmh->code)
            {
                case NM_DBLCLK:
                    OnViewKRA();
                break;
                case LVN_ITEMCHANGED:
                    EnableKRARemoveViewListButtons(pnmlv->uNewState & LVIS_SELECTED);
                break;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\genpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       genpage.h
//
//--------------------------------------------------------------------------

// genpage.h : header file
//

#define SERVERSETTINGS_PROPPAGE_GENERAL 0x1
#define SERVERSETTINGS_PROPPAGE_POLICY  0x2
#define SERVERSETTINGS_PROPPAGE_EXIT    0x4
#define SERVERSETTINGS_PROPPAGE_STORAGE 0x8
#define SERVERSETTINGS_PROPPAGE_KRA     0x10

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage dialog
#include "chooser.h"
#include "csw97ppg.h"
#include "urls.h"
#include "officer.h"


//////////////////////////////
// hand-hewn pages
class CSvrSettingsGeneralPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE1 };

// Construction
public:
	CSvrSettingsGeneralPage(CertSvrCA* pCA, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsGeneralPage();

// Dialog Data
    CString m_cstrCAName;
    CString m_cstrOrg;
    CString m_cstrDescription;
    CString m_cstrProvName;
    CString m_cstrHashAlg;


// Overrides
    public:
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
	void OnDestroy();
	void OnEditChange();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	void OnViewCert(HWND hwnd);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

public:
    
    void NeedServiceRestart(WORD wPage) { m_fRestartServer = TRUE; m_wRestart |= wPage; }
    void TryServiceRestart(WORD wPage);

    void SetAllocedSecurityInfo(LPSECURITYINFO pToBeReleased) {m_pReleaseMe = pToBeReleased; }

    LONG_PTR        m_hConsoleHandle; // Handle given to the snap-in by the console
    CertSvrCA*  m_pCA;

private:
    BOOL    m_bUpdate;
    BOOL    m_fRestartServer;
    WORD    m_wRestart;

	BOOL	m_fWin2kCA;

    LPSECURITYINFO m_pReleaseMe;
    ICertAdmin2 *m_pAdmin;
};

class CSvrSettingsPolicyPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE2 };

// Construction
public:
	CSvrSettingsPolicyPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsPolicyPage();

// Dialog Data
    CString m_cstrModuleName;
    CString m_cstrModuleDescr;
    CString m_cstrModuleVersion;
    CString m_cstrModuleCopyright;

    BOOL   m_fLoadedActiveModule;

    LPOLESTR m_pszprogidPolicyModule;
    CLSID  m_clsidPolicyModule;

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
	void OnDestroy();
    void OnSetActiveModule();
    void OnConfigureModule();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    HRESULT GetCurrentModuleProperties();

public:
    CSvrSettingsGeneralPage* m_pControlPage;

private:
    BOOL    m_bUpdate;

};

// everything you could want to describe a policy/exit module
typedef struct _COM_CERTSRV_MODULEDEFN
{
    LPOLESTR    szModuleProgID;
    CLSID       clsidModule;
} COM_CERTSRV_MODULEDEFN, *PCOM_CERTSRV_MODULEDEFN;

class CSvrSettingsExitPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE3 };

// Construction
public:
	CSvrSettingsExitPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsExitPage();

// Dialog Data
    CString m_cstrModuleName;
    CString m_cstrModuleDescr;
    CString m_cstrModuleVersion;
    CString m_cstrModuleCopyright;

    BOOL   m_fLoadedActiveModule;
    int    m_iSelected;


    CArray<COM_CERTSRV_MODULEDEFN, COM_CERTSRV_MODULEDEFN> m_arrExitModules;

// Overrides
    public:
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    void OnDestroy();

    BOOL UpdateSelectedModule();

    void OnAddActiveModule();
    void OnRemoveActiveModule();

    void OnConfigureModule();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);


    HRESULT InitializeExitLB();
public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    BOOL m_bUpdate;
};

typedef struct _EXTENSIONWIZ_DATA
{
    int          idExtensionName;  //resource id of extension name
    int          idExtensionExplain;//resource id of extension explaination
    WCHAR       *wszRegName;       //value name in registry
    DWORD        dwFlagsMask;      //flag mask of compatible bits
    CSURLTEMPLATENODE *pURLList;   //list of url templates
} EXTENSIONWIZ_DATA;

class CSvrSettingsExtensionPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE4 };

// Construction
public:
	CSvrSettingsExtensionPage(
        CertSvrCA                *pCA,
        CSvrSettingsGeneralPage *pControlPage,
        UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsExtensionPage();

// Dialog Data

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Implementation
protected:
	void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    void UpdateURLFlags(
             IN EXTENSIONWIZ_DATA *pExt,
             IN OPTIONAL CSURLTEMPLATENODE *pURLNode);
    void UpdateURLFlagControl(
             IN int                idCtrl,
             IN DWORD              dwFlag,
             IN EXTENSIONWIZ_DATA *pExt,
             IN CSURLTEMPLATENODE *pURLNode);
    void OnExtensionChange();
    void OnURLChange();
    void OnFlagChange(DWORD dwFlag);
    BOOL OnURLRemove();
    BOOL OnURLAdd();
    CSURLTEMPLATENODE *GetCurrentURL(LRESULT *pnIndex);
    EXTENSIONWIZ_DATA *GetCurrentExtension();

    BOOL    m_bUpdate;
    EXTENSIONWIZ_DATA *m_pExtData;  // point to array of extensions
    CertSvrCA*  m_pCA;
};


class CSvrSettingsStoragePage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE5 };

// Construction
public:
	CSvrSettingsStoragePage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsStoragePage();

// Dialog Data
    CString m_cstrDatabasePath;
    CString m_cstrLogPath;
    CString m_cstrSharedFolder;


// Overrides
	public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    BOOL    m_bUpdate;
};


typedef struct _KRA_NODE
{
    CERT_CONTEXT const *pCert;
    DWORD dwDisposition;
    DWORD               dwFlags;
    struct _KRA_NODE   *next;
} KRA_NODE;

class CSvrSettingsKRAPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE_CHOOSE_KRA };

// Construction
public:
	CSvrSettingsKRAPage(
        CertSvrCA                *pCA,
        CSvrSettingsGeneralPage*  pControlPage,
        UINT                      uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsKRAPage();

// Dialog Data

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    static LPCWSTR MapDispositionToString(DWORD dwDisp);

// Implementation
protected:
	void OnDestroy();
    void OnAddKRA();
    void OnRemoveKRA();
    void OnViewKRA();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void EnableKRARemoveViewListButtons(BOOL fEnabled);
    void EnableKRAAddListButton(BOOL fEnabled);
    void EnableKRARadioButtons(BOOL fMoreThanZero);
    void EnableKRAListView(BOOL fEnabled);
    void EnableKRAEdit(BOOL fEnabled);
    void UpdateKRARadioControls();
    void LoadKRADispositions();
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    HRESULT SaveKRAList(ICertAdmin2 *pAdmin);
    HRESULT LoadKRAList(ICertAdmin2 *pAdmin);
    bool IsCurrentItemValidCert();

public:
    CSvrSettingsGeneralPage* m_pControlPage;

private:
    BOOL        m_fDirty;
    BOOL        m_fArchiveKey;
    BOOL        m_fCountUpdate;
    BOOL        m_fKRAUpdate;
    KRA_NODE   *m_pKRAList; //list of KRAs
    CertSvrCA  *m_pCA;
    DWORD       m_dwKRAUsedCount;
    DWORD       m_dwKRACount;

    static CString m_strDispositions[];
};


/////////////////////////////////////////
// CCRLPropPage
class CCRLPropPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CRL_PROPPAGE };

// Construction
public:
	CCRLPropPage(CertSvrCA* pCA, UINT uIDD = IID_DEFAULT);
	virtual ~CCRLPropPage();

// Dialog Data
    CString   m_cstrPublishPeriodCount;
    CComboBox m_cboxPublishPeriodString;
    CString   m_cstrLastCRLPublish;
//    int       m_iNoAutoPublish;

    CString   m_cstrDeltaPublishPeriodCount;
    CComboBox m_cboxDeltaPublishPeriodString;
    CString   m_cstrDeltaLastCRLPublish;
    int       m_iDeltaPublish;


// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
	void OnDestroy();
	void OnEditChange();
    void OnCheckBoxChange(BOOL fDisableBaseCRL);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void GetDeltaNextPublish();

public:
    LONG_PTR        m_hConsoleHandle; // Handle given to the snap-in by the console
    CertSvrCA*  m_pCA;

private:
    BOOL    m_bUpdate;
};


/////////////////////////////////////////
// CCRLViewPage
class CCRLViewPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CRL_VIEWPAGE };

// Construction
public:
	CCRLViewPage(CCRLPropPage* pControlPage, UINT uIDD = IID_DEFAULT);

	virtual ~CCRLViewPage();

// Dialog Data


// Overrides

public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    void OnViewCRL(BOOL fViewBaseCRL);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void OnDestroy();
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

public:
    CCRLPropPage* m_pControlPage;

};


typedef struct _BACKUPWIZ_STATE
{
    CertSvrCA* pCA;

    BOOL    fBackupKeyCert;
    BOOL    fBackupLogs;
    BOOL    fIncremental;

    LPWSTR  szLogsPath;

    LPWSTR  szPassword;
} BACKUPWIZ_STATE, *PBACKUPWIZ_STATE;


/////////////////////////////////////////
// CBackupWizPage
class CBackupWizPage1 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_WELCOME };

// Construction
public:
    CBackupWizPage1(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);
    ~CBackupWizPage1();

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PBACKUPWIZ_STATE m_pState;

    CWizard97PropertySheet* m_pParentSheet;
};
/////////////////////////////////////////
// CBackupWizPage2
class CBackupWizPage2 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_SELECT_DATA};

// Construction
public:
	CBackupWizPage2(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrLogsPath;
    int m_iKeyCertCheck;
    int m_iLogsCheck;
    int m_iIncrementalCheck;
    BOOL m_fIncrementalAllowed;

// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    void OnBrowse();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    HRESULT ConvertLogsPathToFullPath();

public:
    PBACKUPWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CBackupWizPage3
class CBackupWizPage3 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_SELECT_PASSWORD};

// Construction
public:
	CBackupWizPage3(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrPwd;
    CString m_cstrPwdVerify;


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PBACKUPWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CBackupWizPage5
class CBackupWizPage5 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_COMPLETION };

// Construction
public:
	CBackupWizPage5(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PBACKUPWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};



typedef struct _RESTOREWIZ_STATE
{
    CertSvrCA* pCA;

    BOOL    fRestoreKeyCert;
    LPWSTR  szKeyCertPath;

    LPWSTR  szConfigPath;

    BOOL    fRestoreLogs;
    LPWSTR  szLogsPath;

    LPWSTR  szPassword;

    BOOL    fIncremental;

} RESTOREWIZ_STATE, *PRESTOREWIZ_STATE;


/////////////////////////////////////////
// CRestoreWizPage
class CRestoreWizPage1 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_WELCOME };

// Construction
public:
    CRestoreWizPage1(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);
    ~CRestoreWizPage1();

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;

    CWizard97PropertySheet* m_pParentSheet;
};
/////////////////////////////////////////
// CRestoreWizPage2
class CRestoreWizPage2 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_SELECT_DATA};

// Construction
public:
	CRestoreWizPage2(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrLogsPath;
    int m_iKeyCertCheck;
    int m_iLogsCheck;


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    void OnBrowse();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CRestoreWizPage3
class CRestoreWizPage3 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_SELECT_PASSWORD};

// Construction
public:
	CRestoreWizPage3(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrPwd;


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CRestoreWizPage5
class CRestoreWizPage5 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_COMPLETION };

// Construction
public:
	CRestoreWizPage5(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};


/////////////////////////////////////////
// CViewAttrib 
class CViewAttrib : public CAutoDeletePropPage
{
    enum { IID_DEFAULT = IDD_ATTR_PROPPAGE };

public:
    CViewAttrib(UINT uIDD = IID_DEFAULT);

// Dialog Data

// Overrides
    public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:

            IEnumCERTVIEWATTRIBUTE* m_pAttr;
};

/////////////////////////////////////////
// CViewExtn 
class CViewExtn : public CAutoDeletePropPage
{
    enum { IID_DEFAULT = IDD_EXTN_PROPPAGE };

public:
    CViewExtn(UINT uIDD = IID_DEFAULT);
    ~CViewExtn();


// Dialog Data

// Overrides
    public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    void OnReselectItem();

public:
            IEnumCERTVIEWEXTENSION* m_pExtn;

    CArray<CString*, CString*> m_carrExtnValues;
};

/////////////////////////////////////////
// CSvrSettingsCertManagersPage
class CSvrSettingsCertManagersPage : public CAutoDeletePropPage
{
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE6 };

public:
	CSvrSettingsCertManagersPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
    ~CSvrSettingsCertManagersPage();


// Dialog Data

// Overrides
    public:
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
	void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void OnAddSubject();
    void OnRemoveSubject();
    void OnOfficerListSelChange(DWORD dwIndexSelected);
    void OnAllowDeny();
    void OnEnableOfficers(bool fEnable);
    void OnOfficerChange();
    void SetDirty()
    {
        SendMessage (GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, 0);
        m_fDirty = TRUE;
    }
    void ClearDirty() { m_fDirty = FALSE; }
    BOOL IsDirty() { return m_fDirty; }

    HRESULT BrowseForSubject(HWND hwnd, PSID &rpSid);
    HRESULT GetOfficerRights();
    HRESULT SetOfficerRights();
    HRESULT BuildVirtualOfficerRights();
    void FillOfficerList();
    void FillClientList(DWORD dwOfficerIndex);
    void SetAllowDeny();
    void EnableControls();

    DWORD GetCurrentOfficerIndex()
    {
        LRESULT lSel = SendMessage(
            GetDlgItem(m_hWnd, IDC_LIST_CERTMANAGERS), 
            CB_GETCURSEL,
            0, 
            0);
        return (CB_ERR == lSel) ? 0 : (DWORD)lSel;
    }

    DWORD GetCurrentClientIndex()
    {
        LRESULT lSel = ListView_GetNextItem(
            GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS), -1, LVNI_SELECTED);

        return (-1==lSel) ? 0 : (DWORD)lSel;
    }

    CSvrSettingsGeneralPage* m_pControlPage;
    CertSrv::COfficerRightsList m_OfficerRightsList;
    BOOL m_fEnabled;
    BOOL m_fDirty;
    static CString m_strButtonAllow;
    static CString m_strButtonDeny;
    static CString m_strTextAllow; 
    static CString m_strTextDeny;

};

/////////////////////////////////////////
// CSvrSettingsAuditFilterPage
class CSvrSettingsAuditFilterPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE7 };

// Construction
public:
	CSvrSettingsAuditFilterPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsAuditFilterPage();

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    HRESULT GetAuditFilter();
    HRESULT SetAuditFilter();

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    BOOL    m_fDirty;
    DWORD   m_dwFilter;

    static int m_iCheckboxID[];
};


// Wizard pages
DWORD PublishCRLWizard(CertSvrCA* pCertCA, HWND hwnd);

DWORD CertAdminRevokeCert(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lReason, LPWSTR szCertSerNum);
DWORD CertAdminResubmitRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID);
DWORD CertAdminDenyRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID);

DWORD CABackupWizard(CertSvrCA* pCertCA, HWND hwnd);
DWORD CARestoreWizard(CertSvrCA* pCertCA, HWND hwnd);
DWORD CARequestInstallHierarchyWizard(CertSvrCA* pCertCA, HWND hwnd, BOOL fRenewal, BOOL fAttemptRestart);

// misc dialogs
DWORD ModifyQueryFilter(HWND hwnd, CertViewRowEnum* pRowEnum, CComponentDataImpl* pCompData);
DWORD GetUserConfirmRevocationReason(LONG* plReasonCode, HWND hwnd);

DWORD ViewRowAttributesExtensions(HWND hwnd, IEnumCERTVIEWATTRIBUTE* pAttr, IEnumCERTVIEWEXTENSION* pExtn, LPCWSTR szReqID);
DWORD ViewRowRequestASN(HWND hwnd, LPCWSTR szTempFileName, PBYTE pbReq, DWORD cbReq, IN BOOL fSaveToFile);

DWORD ChooseBinaryColumnToDump(IN HWND hwnd, IN CComponentDataImpl* pComp, OUT LPCWSTR* pcwszColumn, OUT BOOL* pfSaveToFileOnly);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\misc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       misc.h
//
//--------------------------------------------------------------------------

#ifndef _MISC_H_
#define _MISC_H_

#define _JumpIfOutOfMemory(hr, label, pMem) \
    { \
        if (NULL == (pMem)) \
        { \
            (hr) = E_OUTOFMEMORY; \
            _JumpError((hr), label, "Out of Memory"); \
        } \
    }

__inline
void FREE_DATA(void* pData)
{
    if (pData)
        GlobalFree(pData);
}

// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )

// fwds
class CertSvrCA;
class CertSvrMachine;



BOOL            FixupFilterString(LPWSTR szFilter);

LPCWSTR         GetNullMachineName(CString* pcstr);
BOOL            FIsCurrentMachine(LPCWSTR);



STDMETHODIMP    CStringLoad(CString& cstr, IStream *pStm);
STDMETHODIMP    CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty);
STDMETHODIMP    CStringGetSizeMax(CString& cstr, int* piSize);

STDMETHODIMP    VariantLoad(VARIANT& var, IStream *pStm);
STDMETHODIMP    VariantSave(VARIANT& var, IStream *pStm, BOOL fClearDirty);
STDMETHODIMP    VariantGetSizeMax(VARIANT& var, int* piSize);

DWORD           AllocAndReturnConfigValue(HKEY hKey, LPCWSTR szConfigEntry, PBYTE* ppbOut, DWORD* pcbOut, DWORD* pdwType);

void            DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, UINT iRscContext);
void            DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, LPCWSTR szContext);
void            DisplayGenericCertSrvError(HWND hwnd, DWORD dwErr);
void            DisplayGenericCertSrvError(LPCONSOLE pConsole, DWORD dwErr);

DWORD           CryptAlgToStr(CString* pcstrAlgName, LPCWSTR szProv, DWORD dwProvType, DWORD dwAlg);

enum ENUM_PERIOD DurationEnumFromNonLocalizedString(LPCWSTR szPeriod);
BOOL StringFromDurationEnum(int iEnum, CString* pcstr, BOOL fLocalized);

LPCWSTR         OperationToStr(int iOperation);
int             StrToOperation(LPCWSTR  szOperation);

// Column name localization
LPCWSTR         FindUnlocalizedColName(LPCWSTR strColumn);  // returns ptr to rsc

// returns localized string 
BOOL MakeDisplayStrFromDBVariant(VARIANT* pvt, VARIANT* pvOut);

typedef struct _QUERY_RESTRICTION
{
    _QUERY_RESTRICTION* pNext;

    LPWSTR  szField;
    UINT    iOperation;
    
    VARIANT varValue;

    friend bool operator==(
        const struct _QUERY_RESTRICTION& lhs,
        const struct _QUERY_RESTRICTION& rhs);

} QUERY_RESTRICTION, *PQUERY_RESTRICTION;


PQUERY_RESTRICTION  NewQueryRestriction(LPCWSTR szField, UINT iOp, VARIANT* pvarValue);
void                FreeQueryRestriction(PQUERY_RESTRICTION pQR);
void                FreeQueryRestrictionList(PQUERY_RESTRICTION pQR);

PQUERY_RESTRICTION QueryRestrictionFound(
    PQUERY_RESTRICTION pQR, 
    PQUERY_RESTRICTION pQRListHead);

void ListInsertAtEnd(void** ppList, void* pElt);

LPWSTR RegEnumKeyContaining(
    HKEY hBaseKey,
    LPCWSTR szContainsString, 
    DWORD* pdwIndex);

HRESULT
myGetActiveModule(
    CertSvrCA *pCA,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OPTIONAL OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OPTIONAL OUT CLSID *pclsidModule);

/////////////////////////////////////////
// fxns to load resources automatically
class CLocalizedResources
{
public:
    CLocalizedResources();
    ~CLocalizedResources();
    BOOL    Load();

public:
    BOOL        m_fLoaded;
    CBitmap     m_bmpSvrMgrToolbar1; // Imagelist for the STOP/START toolbar

    CString     m_ColumnHead_Name;
    CString     m_ColumnHead_Size;
    CString     m_ColumnHead_Type;
    CString     m_ColumnHead_Description;

    CString     m_DescrStr_CA;
    CString     m_DescrStr_Unknown;

    CString     m_szFilterApplied;
    CString     m_szSortedAscendingTemplate;
    CString     m_szSortedDescendingTemplate;
    CString     m_szStoppedServerMsg;
    CString     m_szStatusBarErrorFormat;

    CString     m_szRevokeReason_Unspecified;
    CString     m_szRevokeReason_KeyCompromise;
    CString     m_szRevokeReason_CaCompromise;
    CString     m_szRevokeReason_Affiliation;
    CString     m_szRevokeReason_Superseded;
    CString     m_szRevokeReason_Cessatation;
    CString     m_szRevokeReason_CertHold;
    CString     m_szRevokeReason_RemoveFromCRL;

    CString     m_szPeriod_Seconds;
    CString     m_szPeriod_Minutes;
    CString     m_szPeriod_Hours;
    CString     m_szPeriod_Days;
    CString     m_szPeriod_Weeks;
    CString     m_szPeriod_Months;
    CString     m_szPeriod_Years;

    CString     m_szYes;
};

extern CLocalizedResources g_cResources;



BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);


HRESULT ReadOfSize(IStream* pStm, void* pbData, ULONG cbData);
HRESULT WriteOfSize(IStream* pStm, void* pbData, ULONG cbData);

HRESULT myOIDToName(
    IN WCHAR const *pwszObjId, 
    OUT LPWSTR* pszName);

HRESULT myDumpFormattedObject(
    IN WCHAR const *pszObjId, 
    IN BYTE const *pbObject,
    IN DWORD cbObject,
    OUT LPWSTR* pwszFormatted);


void InplaceStripControlChars(WCHAR* szString);

HANDLE EnablePrivileges(LPCWSTR ppcwszPrivileges[], ULONG cPrivileges);
void ReleasePrivileges(HANDLE hToken);

HRESULT IsUserDomainAdministrator(BOOL* pfIsAdministrator);

BOOL RestartService(HWND hWnd, CertSvrMachine* pMachine);

//
// defined in casec.cpp
//
extern "C"
HRESULT
CreateCASecurityInfo(  CertSvrCA *pCA,
                        LPSECURITYINFO *ppObjSI);

_COM_SMARTPTR_TYPEDEF(ICertAdmin2, IID_ICertAdmin2);

HRESULT FindComputerObjectSid(
    LPCWSTR pcwszCAComputerDNSName,
    PSID &pSid);

#endif _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\officer.cpp ===
//+--------------------------------------------------------------------------
// File:        officer.cpp
// Contents:    officer rights implementation
//---------------------------------------------------------------------------
#include <stdafx.h>
#include "officer.h"
#include "certsd.h"

using namespace CertSrv;

static const DEFAULT_USERNAME_SIZE = 256;

CClientPermission::CClientPermission(BOOL fAllow, PSID pSid) :
    m_fAllow(fAllow),
    m_Sid(pSid)
{}

HRESULT COfficerRights::Add(PSID pSid, BOOL fAllow)
{
    HRESULT hr = S_OK;
    CClientPermission* pClient = new CClientPermission(fAllow, pSid);

    if(!CClientPermission::IsInitialized(pClient) ||
       !m_List.AddTail(pClient))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "");
    }

error:
    if(S_OK!=hr)
        delete pClient;
    return hr;
}

HRESULT COfficerRights::Init(PACCESS_ALLOWED_CALLBACK_ACE pAce)
{
    HRESULT hr = S_OK;
    
    // no object reuse
    CSASSERT(!m_pSid);
    CSASSERT(m_List.IsEmpty());

    CSASSERT(IsValidSid((PSID)(&pAce->SidStart)));
    m_pSid = new CSid((PSID)(&pAce->SidStart));
    if(!m_pSid)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new CSid");
    }

    hr = AddSidList(pAce);
    _JumpIfError(hr, error, "COfficerRights::AddSidList");

error:
    if(S_OK!=hr)
    {
        Cleanup();
    }
    return hr;
}

HRESULT COfficerRights::AddSidList(PACCESS_ALLOWED_CALLBACK_ACE pAce)
{
    HRESULT hr = S_OK;
    PSID pSid;
    DWORD cSids;
    PSID_LIST pSidList = (PSID_LIST) (((BYTE*)&pAce->SidStart)+
                    GetLengthSid(&pAce->SidStart));

    CSASSERT(EqualSid((PSID)&pAce->SidStart, GetSid()));
    
    for(pSid=(PSID)&pSidList->SidListStart, cSids=0; 
        cSids<pSidList->dwSidCount;
        cSids++, pSid = (PSID)(((BYTE*)pSid)+GetLengthSid(pSid)))
    {
        hr = Add(pSid, ACCESS_ALLOWED_CALLBACK_ACE_TYPE==pAce->Header.AceType);
        _JumpIfError(hr, error, "COfficerRights::Add");
    }

error:
    return hr;
}

COfficerRightsList::~COfficerRightsList()
{ 
    Cleanup();
}


HRESULT COfficerRightsList::Load(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    PACL pAcl; // no free
    ACL_SIZE_INFORMATION AclInfo;
    PACCESS_ALLOWED_CALLBACK_ACE pAce;
    DWORD cAce;
    COfficerRights *pOfficerRights = NULL;
    DWORD cList;
    COfficerRights* pExistingOfficer;
        
    CSASSERT(IsValidSecurityDescriptor(pSD));

    hr = myGetSecurityDescriptorDacl(pSD, &pAcl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    if(!GetAclInformation(pAcl,
                          &AclInfo,
                          sizeof(AclInfo),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    m_dwCountList = 0;

    m_List = (COfficerRights **)LocalAlloc(LMEM_FIXED, 
                sizeof(COfficerRights*)*AclInfo.AceCount);
    if(!m_List)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(m_List, sizeof(COfficerRights*)*AclInfo.AceCount);

    for(cAce=0; cAce<AclInfo.AceCount; cAce++)
    {
        pExistingOfficer = NULL;

        if(!GetAce(pAcl, cAce, (PVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        CSASSERT(
            ACCESS_ALLOWED_CALLBACK_ACE_TYPE == pAce->Header.AceType ||
            ACCESS_DENIED_CALLBACK_ACE_TYPE  == pAce->Header.AceType);

        // Detect if another object already exists for this officer; if so, we
        // will add the client list to it instead of creating a new object
        // Assuming denied aces always come before allow aces, we can limit
        // the search to allow type
        if(ACCESS_ALLOWED_CALLBACK_ACE_TYPE==pAce->Header.AceType)
        {
            for(cList=0; cList<m_dwCountList; cList++)
            {
                if(EqualSid(m_List[cList]->GetSid(), 
                            (PSID)&pAce->SidStart))
                {
                    pExistingOfficer = m_List[cList];
                    break;
                }
            }
        }

        if(pExistingOfficer)
        {
            // add SID list stored in this ace to existing officer object
            hr = pExistingOfficer->AddSidList(pAce);
            _JumpIfError(hr, error, "COfficerRights::AddSidList");
        }
        else
        {
            // create new officer object
            pOfficerRights = new COfficerRights;
            if(!pOfficerRights)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "new COfficerRights");
            }

            hr = pOfficerRights->Init(pAce);
            _JumpIfError(hr, error, "COfficerRights::Init");

            m_List[m_dwCountList] = pOfficerRights;
            pOfficerRights = NULL;
            m_dwCountList++;
        }
    }

error:
    if(S_OK!=hr && m_List)
    {
        if(m_List)
        {
            LocalFree(m_List);
            m_List = NULL;
        }
        if(pOfficerRights)
        {
            delete pOfficerRights;
        }
    }
    return hr;
}

HRESULT COfficerRightsList::Save(PSECURITY_DESCRIPTOR &rpSD)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD = NULL, pSDSelfRelative = NULL;
    DWORD dwSelfRelativeSize = 0;
    PSID pSidBuiltinAdministrators = NULL;
    PACL pAcl = NULL;

    rpSD = NULL;
    
    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED,
                                      SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!pSD)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
#ifdef _DEBUG
    ZeroMemory(pSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
#endif 

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    hr = GetBuiltinAdministratorsSID(&pSidBuiltinAdministrators);
    _JumpIfError(hr, error, "GetBuiltinAdministratorsSID");
    
    if(!SetSecurityDescriptorOwner(
        pSD,
        pSidBuiltinAdministrators,
        FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    hr = BuildAcl(pAcl);
    _JumpIfError(hr, error, "BuildAcl");

    if(!SetSecurityDescriptorDacl(
        pSD,
        TRUE, // DACL present
        pAcl,
        FALSE)) // DACL defaulted
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    CSASSERT(IsValidSecurityDescriptor(pSD));

    MakeSelfRelativeSD(pSD, NULL, &dwSelfRelativeSize);
    if(ERROR_INSUFFICIENT_BUFFER!=GetLastError())
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    pSDSelfRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSelfRelativeSize);
    if(!pSDSelfRelative)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSelfRelativeSize))
    {
        hr = myHLastError();
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

    rpSD = pSDSelfRelative;

error:
    if(pAcl)
    {
        LocalFree(pAcl);
    }
    if(pSD)
    {
        LocalFree(pSD);
    }
    if(pSidBuiltinAdministrators)
    {
        LocalFree(pSidBuiltinAdministrators);
    }
    return hr;
}

HRESULT COfficerRightsList::BuildAcl(PACL &rpAcl)
{
    HRESULT hr = S_OK;
    DWORD dwAclSize = sizeof(ACL);
    DWORD cRights;
    PACL pAcl = NULL;

    rpAcl = NULL;

    // calculate total acl size by adding the space required
    // for the ACEs resulting from each COfficerRights
    for(cRights=0;cRights<m_dwCountList;cRights++)
    {
        dwAclSize += m_List[cRights]->GetAceSize(FALSE);
        dwAclSize += m_List[cRights]->GetAceSize(TRUE);
    }

    pAcl = (PACL)LocalAlloc(LMEM_FIXED, dwAclSize);
    if(!pAcl)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
#ifdef _DEBUG
    ZeroMemory(pAcl, dwAclSize);
#endif

    if(!InitializeAcl(pAcl, dwAclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // add deny aces first
    for(cRights=0;cRights<m_dwCountList;cRights++)
    {
        hr = m_List[cRights]->AddAce(pAcl, FALSE);
        _JumpIfError(hr, error, "COfficerRights::AddAce");
    }

    // then add allow aces
    for(cRights=0;cRights<m_dwCountList;cRights++)
    {
        hr = m_List[cRights]->AddAce(pAcl, TRUE);
        _JumpIfError(hr, error, "COfficerRights::AddAce");
    }
    
    CSASSERT(IsValidAcl(pAcl));

    rpAcl = pAcl;

error:

    if(S_OK!=hr)
    {
        if(pAcl)
        {
            LocalFree(pAcl);
        }
    }
    return hr;
}

DWORD COfficerRights::GetAceSize(BOOL fAllow)
{
    DWORD dwAceSize = sizeof(ACCESS_ALLOWED_CALLBACK_ACE);
    dwAceSize += GetLengthSid(m_pSid->GetSid());
    BOOL fFound = FALSE;

    TPtrListEnum<CClientPermission> CPEnum(m_List);
    CClientPermission *pCP;

    for(pCP=CPEnum.Next();pCP;pCP=CPEnum.Next())
    {
        if(pCP->GetPermission()==fAllow)
        {
            dwAceSize += GetLengthSid(pCP->GetSid());
            fFound = TRUE;
        }
    }

    return fFound?dwAceSize:0;
}

HRESULT COfficerRights::AddAce(PACL pAcl, BOOL fAllow)
{
    HRESULT hr = S_OK;
    PACCESS_ALLOWED_CALLBACK_ACE pAce = NULL;
    DWORD dwAceSize = GetAceSize(fAllow);
    DWORD dwSidSize = GetLengthSid(m_pSid->GetSid());
    DWORD dwClientSidSize;
    PSID_LIST pSidList;
    PSID pClientSid;
    TPtrListEnum<CClientPermission> CPEnum(m_List);
    CClientPermission *pCP;
    BOOL fFound = FALSE;
    DWORD dwSidCount = 0;

    if(dwAceSize)
    {
        pAce = (PACCESS_ALLOWED_CALLBACK_ACE) LocalAlloc(LMEM_FIXED, dwAceSize);
        if(!pAce)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

    #ifdef _DEBUG
            ZeroMemory(pAce, dwAceSize);
    #endif 

        pAce->Header.AceType = fAllow?ACCESS_ALLOWED_CALLBACK_ACE_TYPE:
                                      ACCESS_DENIED_CALLBACK_ACE_TYPE;
        pAce->Header.AceFlags= 0;
        pAce->Header.AceSize = (USHORT)dwAceSize;
        pAce->Mask = DELETE;

        CopySid(dwSidSize,
            (PSID)&pAce->SidStart,
            m_pSid->GetSid());
        pSidList = (PSID_LIST)(((BYTE*)&pAce->SidStart)+dwSidSize);
        pSidList->dwSidCount = m_List.GetCount();
        pClientSid = (PSID)&pSidList->SidListStart;
        for(pCP=CPEnum.Next(); pCP; pCP=CPEnum.Next())
        {
            if(pCP->GetPermission()==fAllow)
            {
                dwClientSidSize = GetLengthSid(pCP->GetSid());
                CopySid(dwClientSidSize,
                    pClientSid,
                    pCP->GetSid());
                pClientSid = (((BYTE*)pClientSid)+dwClientSidSize);
                fFound = TRUE;
                dwSidCount++;
            }
        }
        pSidList->dwSidCount = dwSidCount;
        
        CSASSERT(pClientSid==((BYTE*)pAce)+dwAceSize);

        if(fFound)
        {
            if(!::AddAce(
                pAcl,
                ACL_REVISION,
                MAXDWORD,
                pAce,
                dwAceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "AddAce");
            }
        }
    }

error:
    if(pAce)
    {
        LocalFree(pAce);
    }
    return hr;
}

void COfficerRightsList::Dump()
{
    DBGPRINT((DBG_SS_INFO, "Officers: %d\n", m_dwCountList));
    wprintf(L"Officers: %d\n", m_dwCountList);
    for(DWORD dwCount=0;dwCount<m_dwCountList;dwCount++)
    {
        COfficerRights *pOR = GetAt(dwCount);
        wprintf(L"Officer %s, %d clients\n", pOR->GetName(), pOR->GetCount());
        for(DWORD c=0;c<pOR->GetCount();c++)
        {
            CClientPermission *pCli = pOR->GetAt(c);
            wprintf(L"\tClient %s, %s\n", pCli->GetName(), pCli->GetPermission()?L"allow":L"deny");
        }
    }
}

// Searches the list for an object with this SID; if found returns
// object index, if not found, returns DWORD_MAX
DWORD COfficerRights::Find(PSID pSid)
{
    CClientPermission perm(TRUE, pSid);
    return m_List.FindIndex(perm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\officer.h ===
//+--------------------------------------------------------------------------
// File:        officer.h
// Contents:    officer rights classes
//---------------------------------------------------------------------------
#include "sid.h"
#include "tptrlist.h"

namespace CertSrv
{

class CClientPermission
{
public:
    CClientPermission(BOOL fAllow, PSID pSid);
    ~CClientPermission() {}

    static BOOL IsInitialized(CClientPermission* pObj) 
    { 
        return  NULL != pObj &&
                NULL != ((PSID)pObj->m_Sid);
    }
    void SetPermission(BOOL fAllow) { m_fAllow = fAllow;}
    BOOL GetPermission() { return m_fAllow; }
    LPCWSTR GetName() { return m_Sid.GetName(); }
    PSID GetSid() { return m_Sid.GetSid(); }
    friend class COfficerRights;
    BOOL operator==(const CClientPermission& rhs)
    {
        return EqualSid(GetSid(), 
            (const_cast<CClientPermission&>(rhs)).GetSid());
    }

protected:
    BOOL m_fAllow;
    CSid m_Sid;
};

class COfficerRights
{
public:
    COfficerRights() : m_pSid(NULL), m_List() {}
   ~COfficerRights() { delete m_pSid; }

    HRESULT Init(PACCESS_ALLOWED_CALLBACK_ACE pAce);
    HRESULT Add(PSID pSID, BOOL fAllow);
    HRESULT RemoveAt(DWORD dwIndex)
    { 
        return m_List.RemoveAt(dwIndex)?S_OK:E_INVALIDARG; 
    }
    HRESULT SetAt(DWORD dwIndex, BOOL fAllow)
    { 
        CClientPermission *pClient = m_List.GetAt(dwIndex);
        if(!pClient)
            return E_INVALIDARG;
        pClient->SetPermission(fAllow);
        return S_OK;
    }
    CClientPermission* GetAt(DWORD dwIndex) 
    {
        return m_List.GetAt(dwIndex);
    }

    DWORD Find(PSID pSid);
    DWORD GetCount() { return m_List.GetCount(); }
    LPCWSTR GetName() { return m_pSid->GetName(); };
    PSID GetSid() { return m_pSid->GetSid(); }

    friend class COfficerRightsList;
    
protected:

    DWORD GetAceSize(BOOL fAllow);
    HRESULT AddAce(PACL pAcl, BOOL fAllow);
    HRESULT AddSidList(PACCESS_ALLOWED_CALLBACK_ACE pAce);

    void Cleanup() 
    {
        if (m_pSid)
        {
           delete m_pSid; 
           m_pSid=NULL; 
        }
        m_List.Cleanup();
    }
    // following bools are used to decide if this COfficerRights has to
    // be represented as one or two aces (allow/deny) in the ACL
    CSid* m_pSid; // use pointer instead of member object because
                  // we don't know the sid at construct time
    TPtrList<CClientPermission> m_List;
};

class COfficerRightsList
{
public:
    COfficerRightsList() : m_List(NULL), m_dwCountList(0) {}
   ~COfficerRightsList();

    HRESULT Load(PSECURITY_DESCRIPTOR pSD);
    HRESULT Save(PSECURITY_DESCRIPTOR &rpSD);
    COfficerRights* GetAt(DWORD dwIndex) 
    {
        if(dwIndex>=m_dwCountList)
            return NULL;
        return m_List[dwIndex];
    }

    DWORD GetCount() { return m_dwCountList;}

    void Dump();
    void Cleanup()
    {
        if (m_List != NULL)
        {
            for(DWORD dwCount=0;dwCount<m_dwCountList;dwCount++)
            {
                if (m_List[dwCount] != NULL) 
                    delete m_List[dwCount];
            }

            LocalFree(m_List); 
            m_List = NULL;
        }
        m_dwCountList = 0;
    }

protected:

    HRESULT BuildAcl(PACL &rpAcl);
    COfficerRights **m_List;
    DWORD m_dwCountList;
};

}; // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_COLUMN_NAME                 2
#define IDS_SIZE                        3
#define IDS_COLUMN_SIZE                 3
#define IDOK2                           3
#define IDS_TYPE                        4
#define IDS_COLUMN_TYPE                 4
#define IDS_NODENAME                    5
#define IDS_SNAPIN_DESC2                5
#define IDS_STRING6                     6
#define IDS_DESCRIPTION                 6
#define IDS_VERSION                     7
#define IDS_COMPANY                     8
#define IDS_SCOPE_MYCOMPUTER            9
#define IDS_SCOPE_MYCOMPUTER_OVERRIDE   10
#define IDS_LOCALMACHINE                11
#define IDS_NODENAME_PREFIX             12
#define IDS_NODENAME_FORMAT             12
#define IDS_COLUMN_OTHER                13
#define IDS_COLUMN_DESCRIPTION          14
#define IDS_DESCR_CA                    15
#define IDS_DESCR_UNKNOWN               16
#define IDS_CERTS_REVOKED               17
#define IDS_CERTS_ISSUED                18
#define IDS_CERTS_PENDING               19
#define IDS_STATUSBAR_FILTER_APPLIED    20
#define IDS_STOPPED_SERVER_MSG          21
#define IDS_COLUMN_INCLUSION_ERROR      22
#define IDC_DUMP_ASN                    23
#define IDS_CONFIRM_CRL_PUBLISH         24
#define IDS_CRL_TITLE                   25
#define IDS_CONFIRM_REVOKE_CERT         26
#define IDS_REVOKE_CERT_TITLE           27
#define IDS_FILTER_NOT_SUPPORTED        28
#define IDS_FILTER_NOT_SUPPORTED2       29
#define IDS_CONFIRM_SERVICE_RESTART     29
#define IDS_COLUMNCHOOSER_FIELDNAME     30
#define IDS_COLUMNCHOOSER_OPERATOR      31
#define IDS_COLUMNCHOOSER_VALUE         32
#define IDS_COLUMNCHOOSER_ANDOR         33
#define IDS_AND                         34
#define IDS_CERTS_FAILED                35
#define IDS_CONFIRM_DENY_REQUEST        36
#define IDS_DENY_REQUEST_TITLE          37
#define IDS_PASSWORD_NOMATCH            38
#define IDS_PASSWORD_DIALOG             39
#define IDS_WARN_FILE_EXISTS            40
#define IDS_INSTALL_HIERARCHY_TITLE     40
#define IDS_SAVE_DIALOG_TITLE           41
#define IDS_COMPLETE_HIERARCHY_INSTALL_MSG 42
#define IDS_MODULE_INSTALL_TITLE        43
#define IDS_FILEDLG_DLL_FILTER          44
#define IDS_CHOOSEMODULE_POLICY_TITLE   45
#define IDS_CHOOSEMODULE_EXIT_TITLE     46
#define IDS_CANT_ACCESS_BACKUP_DIR      47
#define IDS_STATUSBAR_SORTEDBY_ASCEND   48
#define IDS_STATUSBAR_SORTEDBY_DESCEND  49
#define IDS_CA_REDISCOVER               50
#define IDS_STARTING_SVC                51
#define IDS_STOPPING_SVC                52
#define IDS_BACKUP_PROGRESS             53
#define IDS_INCREMENTAL_BACKUP          54
#define IDS_WIZ97TITLE_BACKUPWIZPG1     55
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG1  56
#define IDS_WIZ97TITLE_BACKUPWIZPG2     57
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG2  58
#define IDS_WIZ97TITLE_BACKUPWIZPG3     59
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG3  60
#define IDS_WIZ97TITLE_BACKUPWIZPG4     61
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG4  62
#define IDS_BACKUP_WIZARD               63
#define IDS_WIZ97TITLE_BACKUPWIZPG5     64
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG5  65
#define IDS_TASKMENU_UNREVOKECERT       66
#define IDS_FILEDLG_PKCS12_FILTER       67
#define IDS_INCRRESTORE_RESTART_SERVER_WARNING 68
#define IDS_FILEDLG_PKCS12_DEFAULTEXTENSION 69
#define IDS_RESTORE_WIZARD              70
#define IDS_REQUIRE_ONE_SELECTION       71
#define IDS_MSG_DIRECTORY_TITLE         72
#define IDS_INVALID_DIRECTORY           73
#define IDS_WIZ97TITLE_RESTOREWIZPG1    74
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG1 75
#define IDS_WIZ97TITLE_RESTOREWIZPG2    76
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG2 77
#define IDS_WIZ97TITLE_RESTOREWIZPG3    78
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG3 79
#define IDS_WIZ97TITLE_RESTOREWIZPG4    80
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG4 81
#define IDS_ERR_RESTORE_OUT_OF_ORDER    82
#define IDS_DIR_CREATE                  83
#define IDS_SERVER_UNAVAILABLE          84
#define IDS_RESTORE_PROGRESS            85
#define IDS_POLICYMODULE_NOT_REGISTERED 86
#define IDS_EXITMODULE_NOT_REGISTERED   87
#define IDS_RETARGET_SNAPIN             88
#define IDS_STATUSBAR_RETARGET_SNAPIN   89
#define IDS_TASKMENU_STATUSBAR_UNREVOKECERT 90
#define IDS_STATUSBAR_ERRORTEMPLATE     91
#define IDS_ROLLOVER_REUSEKEYS          92
#define IDS_PFX_EXPORT_PRIVKEY_WARNING  93
#define IDS_RENEWAL_PROGRESS            94
#define IDS_CONFIRM_REMOVE_URL          95
#define IDS_CONFIRM_REMOVE_TITLE        96
#define IDD_RESTOREWIZ_COMPLETION       101
#define IDI_APPICON                     102
#define IDD_RENEW_REUSEKEYS             105
#define IDD_RESTOREWIZ_WELCOME          107
#define IDD_RESTOREWIZ_SELECT_DATA      108
#define IDD_RESTOREWIZ_SELECT_PASSWORD  109
#define IDS_CERTMMC_SNAPINNAME          110
#define IDS_CERTMMC_SNAPINNAMESTRING    111
#define IDS_UNREVOKE_FAILED             112
#define IDS_TOKEN_SERVERDNSNAME         130
#define IDS_TOKEN_SERVERSHORTNAME       131
#define IDS_TOKEN_SANITIZEDCANAME       132
#define IDS_TOKEN_CERTFILENAMESUFFIX    133
#define IDS_TOKEN_CONFIGDN              135
#define IDS_TOKEN_SANITIZEDCANAMEHASH   136
#define IDS_TOKEN_CRLFILENAMESUFFIX     137
#define IDS_TOKEN_CRLDELTAFILENAMESUFFIX 138
#define IDS_TOKEN_DSCRLATTRIBUTE        139
#define IDS_TOKEN_DSCACERTATTRIBUTE     140
#define IDS_CRL_REASON_UNSPECIFIED      150
#define IDS_CRL_REASON_KEY_COMPROMISE   151
#define IDS_CRL_REASON_CA_COMPROMISE    152
#define IDS_CRL_REASON_AFFILIATION_CHANGED 153
#define IDS_CRL_REASON_SUPERSEDED       154
#define IDS_CRL_REASON_CESSATION_OF_OPERATION 155
#define IDS_CRL_REASON_CERTIFICATE_HOLD 156
#define IDS_POSSIBLEERROR_NO_POLICY_MODULE 157
#define IDS_KEYANDCERT                  158
#define IDS_CALOGS                      160
#define IDS_STOP_SERVER_WARNING         161
#define IDS_START_SERVER_WARNING        162
#define IDS_TASKMENU_ROLLOVER           163
#define IDS_TASKMENU_STATUSBAR_ROLLOVER 164
#define IDS_CRL_REASON_REMOVE_FROM_CRL  165
#define IDS_TASKMENU_DUMPASN            166
#define IDS_TASKMENU_STATUSBAR_DUMPASN  167
#define IDS_TOKENDESC_SERVERDNSNAME     180
#define IDS_TOKENDESC_SERVERSHORTNAME   181
#define IDS_TOKENDESC_SANITIZEDCANAME   182
#define IDS_TOKENDESC_CERTFILENAMESUFFIX 183
#define IDS_TOKENDESC_CONFIGDN          185
#define IDS_TOKENDESC_SANITIZEDCANAMEHASH 186
#define IDS_TOKENDESC_CRLFILENAMESUFFIX 187
#define IDS_TOKENDESC_CRLDELTAFILENAMESUFFIX 188
#define IDS_TOKENDESC_DSCRLATTRIBUTE    189
#define IDS_TOKENDESC_DSCACERTATTRIBUTE 190
#define IDS_CA_CERT_LISTBOX_EXPIRED     191
#define IDS_CA_CERT_LISTBOX_REVOKED     192

#define IDI_PRIVKEY                     232
#define IDD_VIEW_ATTREXT                234
#define IDD_CRL_VIEWPAGE                237
#define IDC_DISABLE_PUBLISH             267
#define IDC_DISABLE_DELTAPUBLISH        268
#define IDC_ENABLE_DELTAPUBLISH         268
#define IDC_CHECK_INCREMENTAL           269
#define IDC_DATEPICKER_NEWQUERY         270
#define IDC_TIMEPICKER_NEWQUERY         271
#define IDC_CHOOSER_MACHINE_OVERRIDE    271
#define IDC_EXIT_LIST                   272
#define IDC_LIST_EXTN                   273
#define IDC_LIST_ATTR                   274
#define IDC_RADIO_NEWBASE               275
#define IDC_RADIO_NEWDELTA              276
#define IDC_VALID_LASTPUBLISHED         277
#define IDC_CRL_VIEW_LIST_CRL           278
#define IDC_LIST_CERTS                  279
#define IDC_EXT_EXPLAIN                 280
#define IDC_LIST_KRA                    280
#define IDC_SERVERPUBLISH               281
#define IDC_KRA_ENABLE                  281
#define IDC_ADDTOCERTOCSP               282
#define IDC_KRA_ALL                     282
#define IDC_AUDIT_STARTSTOP             282
#define IDC_AUDIT_BACKUPRESTORE         283
#define IDC_KRA_DISABLE                 283
#define IDC_CHECK_BINARY_SAVETOFILE     283
#define IDC_AUDIT_CERTIFICATE           284
#define IDC_RADIO_BINARY_VIEW           284
#define IDC_AUDIT_CRL                   285
#define IDC_RADIO_BINARY_SAVE           285
#define IDC_DELTA_EXPLANATION           285
#define IDC_AUDIT_CACERT                286
#define IDC_AUDIT_CASEC                 287
#define IDC_SPIN2                       287
#define IDC_AUDIT_KEYARCHIVAL           288
#define IDC_COMBO2                      288
#define IDC_AUDIT_CACONFIG              289
#define IDC_BUTTON_INSERTVAR            290
#define IDB_WIZ_HEAD                    321
#define IDB_WIZ                         322
#define IDB_CHECKLIST                   325
#define IDD_REVOCATION_DIALOG           326
#define IDD_NEW_RESTRICTION             328
#define IDD_BROWSEDIRECTORY             330
#define IDC_ACTIVE_MODULE               352
#define IDC_VERSION                     353
#define IDC_COPYRIGHT                   354
#define IDC_MODULENAME                  355
#define IDC_MODULE_LIST                 356
#define IDC_CHECK_SAVE_KEY              357
#define IDC_TEXT_BIGBOLD                358
#define IDC_BACKUP_KEYFILE              360
#define IDC_BACKUP_DBFILE               361
#define IDC_CONFIGURE                   362
#define IDC_BUTTON_UP                   363
#define IDC_COMBO_REASON                364
#define IDC_START_SERVICE_WARNING       365
#define IDS_PERIOD_YEARS                600
#define IDS_PERIOD_MONTHS               601
#define IDD_CRLWIZ_WELCOME              601
#define IDS_PERIOD_WEEKS                602
#define IDD_CRLWIZ_PUBLICATION_LOCATION 602
#define IDS_PERIOD_DAYS                 603
#define IDS_PERIOD_HOURS                604
#define IDS_PERIOD_MINUTES              605
#define IDS_PERIOD_SECONDS              606
#define IDD_GENERAL                     607
#define IDD_CRLWIZ_COMPLETION           607
#define IDD_EXTENSION_PAGE              608
#define IDD_CRLWIZ_VALIDITY_LENGTH      608
#define IDD_CERTSRV_PROPPAGE1           609
#define IDD_CERTSRV_PROPPAGE            610
#define IDD_CERTSRV_PROPPAGE2           610
#define IDS_POSITIVE_NUMBER             611
#define IDD_CERTSRV_PROPPAGE4           612
#define IDS_NO_EXIT_MODULE              612
#define IDD_CERTSRV_PROPPAGE5           613
#define IDD_CERTSRV_PROPPAGE3           614
#define IDD_CRL_PROPPAGE                615
#define IDC_CHOOSER_STATIC              616
#define IDD_ADDURL                      617
#define IDC_EDITURL                     618
#define IDS_VIEWMENU_ALL_RECORDS        650
#define IDS_VIEWMENU_STATUSBAR_ALL_RECORDS 651
#define IDS_VIEWMENU_FILTER             652
#define IDS_VIEWMENU_STATUSBAR_FILTER   653
#define IDS_EMPTY                       654
#define IDS_VIEWMENU_COLUMNS            655
#define IDS_VIEWMENU_STATUSBAR_COLUMNS  656
#define IDS_TASKMENU_STARTSERVICE       657
#define IDS_TASKMENU_STATUSBAR_STARTSERVICE 658
#define IDS_TASKMENU_STOPSERVICE        659
#define IDS_TASKMENU_STATUSBAR_STOPSERVICE 660
#define IDS_TASKMENU_PUBLISHCRL         661
#define IDS_TASKMENU_STATUSBAR_PUBLISHCRL 662
#define IDS_TASKMENU_VIEWCRL            663
#define IDS_TASKMENU_STATUSBAR_VIEWCRL  664
#define IDS_TASKMENU_REVOKECERT         665
#define IDS_TASKMENU_STATUSBAR_REVOKECERT 666
#define IDS_TASKMENU_RESUBMIT           667
#define IDS_TASKMENU_STATUSBAR_RESUBMIT 668
#define IDS_TASKMENU_DENYREQUEST        669
#define IDS_TASKMENU_STATUSBAR_DENYREQUEST 670
#define IDS_TASKMENU_BACKUP             671
#define IDS_TASKMENU_STATUSBAR_BACKUP   672
#define IDS_NEED_FILEPATH               673
#define IDS_BACKUPWIZ_TITLE             674
#define IDS_TOPMENU_OPEN                674
#define IDS_TASKMENU_RESTORE            675
#define IDS_TASKMENU_STATUSBAR_RESTORE  676
#define IDS_TASKMENU_INSTALL_CA         677
#define IDS_TASKMENU_STATUSBAR_INSTALL_CA 678
#define IDS_TOPMENU_STATUSBAR_OPEN      679
#define IDS_ERR_RESTORE_OVER_EXISTING_DATABASE 680
#define IDS_DIR_NOT_WRITEABLE           681
#define IDS_DIRECTORY_CONTENTS_UNEXPECTED 682
#define IDS_MUST_CHOOSE_MACHINE         683
#define IDC_NEW_FOLDER                  701
#define IDB_16x16                       702
#define IDC_EXT_STATIC                  702
#define IDC_ORGANIZATION                702
#define IDB_32x32                       703
#define IDC_EXT_TEXT                    703
#define IDC_ORGUNIT                     703
#define IDI_COMPUTER                    704
#define IDC_LOCALITY                    704
#define IDI_FOLDER                      705
#define IDC_CERTSRV_PROPPAGE_TAB1       705
#define IDC_STATE                       705
#define IDC_COUNTRY                     706
#define IDB_TOOLBAR1                    707
#define IDC_DESCRIPTION                 707
#define IDB_TOOLBAR2                    708
#define IDC_CANAME                      708
#define IDI_CERT                        709
#define IDC_COUNTRY2                    709
#define IDB_SMALLBMP                    710
#define IDC_COUNTRY3                    710
#define IDB_LARGE                       711
#define IDC_COUNTRY4                    711
#define IDC_CA_HIERARCHY                711
#define IDC_BUTTON_INSTALLCERT          712
#define FILEEX_MENU                     713
#define IDC_BUTTON_VIEWCERT             713
#define IDC_BUTTON_BACKUP               713
#define FOLDEREX_MENU                   714
#define IDC_RADIO_REUSEKEY              714
#define IDC_RADIO_NEWKEY                715
#define IDC_EDIT1                       716
#define IDC_EDIT_SHAREDFOLDER           716
#define IDC_EDIT_NEWQUERY_VALUE         716
#define IDC_RADIO_QUEUEVIEW             716
#define IDC_EDIT_EXTN                   716
#define IDC_EDIT_DELTACRLPERIODCOUNT    716
#define IDC_KRA_EDITCOUNT               716
#define IDC_EDIT_VARIABLEDESCRIPTION    716
#define IDC_BUTTON1                     717
#define IDC_ADD_MODULE                  717
#define IDC_RADIO_MANUALVIEW            717
#define IDC_ADD_RESTRICTION             717
#define IDC_URL_ADD                     717
#define IDC_CRL_VIEW_BTN_VIEWCRL        717
#define IDC_BUTTON4                     718
#define IDB_COMPUTER_LARGE              718
#define IDC_REMOVE_MODULE               718
#define IDI_NOICON                      718
#define IDC_INSTALL_MODULE              718
#define IDC_BUTTON_DN                   718
#define IDC_DELETE_RESTRICTION          718
#define IDC_EDIT_DELTASIZE              718
#define IDC_URL_REMOVE                  718
#define IDB_COMPUTER_SMALL              719
#define IDC_EDIT_CRLPERIODCOUNT         719
#define IDD_DEFINE_QUERY                719
#define IDC_BACKUP_CONFIGFILE           719
#define IDB_TOOLBAR_SVRMGR1             720
#define IDC_CRL_VIEW_BTN_VIEWDELTA      720
#define IDD_CERTSRV_PROPPAGE6           721
#define IDD_BACKUPWIZ_WELCOME           722
#define IDC_EDIT_UNITS                  723
#define IDD_BACKUPWIZ_SELECT_PASSWORD   723
#define IDC_CHECK1                      724
#define IDD_BACKUPWIZ_PUBLICATION_LOCATION 724
#define IDC_COMBO1                      725
#define IDD_BACKUPWIZ_COMPLETION        725
#define IDC_CHECK_SAVE_CONFIG           725
#define IDC_DELTA_COMBO                 725
#define IDC_EXT_SELECT                  725
#define IDC_COMBO_BINARY_COLUMN_CHOICE  725
#define IDC_COMBO_VARIABLE              725
#define IDC_CHECK2                      726
#define IDC_EDIT_NEWQUERY_OPERATION     726
#define IDD_CHOOSE_MODULE               726
#define IDC_CHECK_SAVE_DB               726
#define IDC_ADDTOCERTCDP                726
#define IDC_EDIT_NEWQUERY_ANDOR         727
#define IDD_BACKUPWIZ_SELECT_DATA       727
#define IDC_ADDTOFRESHESTCRL            727
#define IDC_COMBO_CRLPERIODSTRING       728
#define IDD_CHOOSE_COLUMNS_NEW          728
#define IDC_ADDTOCRLCDP                 728
#define IDC_CHECK3                      729
#define IDC_COMBO_DELTACRLPERIODSTRING  729
#define IDC_EDIT_LASTUPDATE             730
#define IDC_CSP_NAME                    731
#define IDC_EDIT_DELTALASTUPDATE        731
#define IDC_HASHALG                     732
#define IDC_EDIT_DATABASE_LOC           733
#define IDC_EDIT_LOG_LOC                734
#define IDC_QUERY_LIST                  737
#define IDC_EDIT_NEWQUERY_FIELD         739
#define IDC_RESET_BUTTON                740
#define IDC_LIST_AVAILABLE              742
#define IDC_LIST_SELECTED               743
#define IDC_KRA_ADD                     744
#define IDC_KRA_REMOVE                  745
#define IDC_KRA_VIEW                    746
#define IDC_RADIO_LOGVIEW               746
#define IDC_EDIT_KRAUSEDCOUNT           747
#define IDC_RADIO_FAILEDLOGVIEW         747
#define IDC_LIST_AVAILABLE_LABEL        748
#define IDC_LIST_SELECTED_LABEL         749
#define IDC_VIEW_CRL                    750
#define IDC_VIEW_CERT                   751
#define IDC_VIEW_DELTACRL               751
#define IDC_EDIT_BACKUP_PATH            752
#define IDC_NEW_PASSWORD                753
#define IDC_VIEW_CERT2                  753
#define IDC_CONFIRM_PASSWORD            754
#define IDC_BROWSE                      755
#define IDS_TASKMENU_REQUEST_CA         756
#define IDS_TASKMENU_STATUSBAR_REQUEST_CA 757
#define IDS_ICMM_GETNAMEPROPERTY_FAILED 758
#define IDD_CHOOSER_CHOOSE_MACHINE      759
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 761
#define IDD_ATTR_PROPPAGE               761
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 762
#define IDD_EXTN_PROPPAGE               762
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 763
#define IDD_CHOOSE_PUBLISHCRL           763
#define IDC_CHOOSER_EDIT_MACHINE_NAME   764
#define IDD_CERTSRV_PROPPAGE_CHOOSE_KRA 764
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 765
#define IDD_CERTSRV_PROPPAGE7           765
#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME 766
#define IDD_CHOOSE_BINARY_COLUMN        766
#define IDS_CHOOSER_INVALID_COMPUTERNAME 767
#define IDS_EXT_CDP                     768
#define IDS_EXT_AIA                     769
#define IDS_EXT_CDP_EXPLAIN             770
#define IDS_EXT_AIA_EXPLAIN             771
#define IDS_INVALID_PREFIX              772
#define IDS_INVALID_TOKEN               773
#define IDS_INVALID_ENCODING            774
#define IDS_EMPTY_URL                   775
#define IDD_CERTMANAGERS_PROPPAGE       776
#define IDC_ADDSUBJECT                  777
#define IDC_REMOVESUBJECT               778
#define IDS_SAME_URL_EXIST              779
#define IDC_LIST_SUBJECTS               781
#define IDC_LIST_CERTMANAGERS           782
#define IDS_VIEW_CERT_DENY_ERROR        783
#define IDS_VIEW_CERT_NOT_RUNNING       784
#define IDS_KRA_ADD_TITLE               785
#define IDS_KRA_ADD_SUBTITLE            786
#define IDC_ALLOWDENY                   787
#define IDS_TASKMENU_SUBMITREQUEST      791
#define IDS_TASKMENU_STATUSBAR_SUBMITREQUEST 792
#define IDC_RADIO_ENABLEOFFICERS        793
#define IDC_RADIO_DISABLEOFFICERS       794
#define IDC_CHECK_KEYCERT               1005
#define IDC_EDIT_KEYCERT                1006
#define IDC_EDIT_PASSWORD               1006
#define IDC_BROWSE_KEYCERT              1007
#define IDC_LIST2                       1009
#define IDC_COMPLETION_LIST             1009
#define IDC_CRL_VIEW_LIST_DELTA         1009
#define IDC_EDIT_CONFIG                 1012
#define IDC_BROWSE_CONFIG               1013
#define IDC_CHECK_LOGS                  1014
#define IDC_EDIT_LOGS                   1015
#define IDC_BROWSE_LOGS                 1016
#define IDC_URL_LIST                    1017
#define IDS_INH_ALL                     1250
#define IDS_INH_CONTAINER               1251
#define IDS_INH_OBJECT                  1252
#define IDS_INH_NONE                    1253
#define IDS_LARGEFONTNAME               2000
#define IDS_SMALLFONTNAME               2001
#define IDS_SMALLFONTSIZE               2002
#define IDS_FONTSIZE                    2003
#define IDS_LARGEFONTSIZE               2004
#define IDS_STARTMENU_CERTMMC_LINKNAME  2005
#define IDS_STARTMENU_CERTMMC_DESCRIPTION 2006
#define IDS_LISTCOL_TAG                 2007
#define IDS_LISTCOL_VALUE               2008
#define IDS_TASKMENU_VIEWATTREXT        2009
#define IDS_TASKMENU_STATUSBAR_VIEWATTREXT 2010
#define IDS_LISTCOL_FLAGS               2011
#define IDS_LISTCOL_ORGIN               2011
#define IDS_UNKNOWN_EXTENSION           2012
#define IDS_CERT_PROP_CAPTION           2013
#define IDS_LISTCOL_CRITICAL            2014
#define IDS_LISTCOL_ENABLED             2015
#define IDS_CRL_LISTCOL_INDEX           2016
#define IDS_LISTCOL_EFFECTIVE_DATE      2017
#define IDS_LISTCOL_EXPIRATION_DATE     2018
#define IDS_LISTCOL_PUBLISH_STATUS      2019
#define IDS_YES                         2020
#define IDS_NO                          2021
#define IDS_EXT_ORIGIN_REQUEST          2022
#define IDS_EXT_ORIGIN_POLICY           2023
#define IDS_EXT_ORIGIN_ADMIN            2024
#define IDS_EXT_ORIGIN_SERVER           2025
#define IDS_EXT_ORIGIN_RENEWAL          2026
#define IDS_EXT_ORIGIN_IMPORTED_CERT    2027
#define IDS_EXT_ORIGIN_PKCS7            2028
#define IDS_EXT_ORIGIN_UNKNOWN          2029
#define IDS_LISTCOL_SUBJECT             2030
#define IDS_LISTCOL_ISSUER              2031
#define IDS_CA_CERT_LISTBOX             2032
#define IDS_LIST_NAME                   2033
#define IDS_BINARYFILE_OUTPUT_TITLE     2034
#define IDS_BINARYFILE_OUTPUT_FILTER    2035
#define IDS_KRA_COUNT_TOO_BIG           2036
#define IDS_KRA_NOKRADEFINED            2037
#define IDS_BUTTONTEXT_ALLOW            2038
#define IDS_BUTTONTEXT_DENY             2039
#define IDS_LIST_ACCESS                 2040
#define IDS_TEXT_ALLOW                  2041
#define IDS_TEXT_DENY                   2042
#define IDS_LISTCOL_STATUS              2043
#define IDS_DISPOSITION_EXPIRED         2044
#define IDS_DISPOSITION_NOTFOUND        2045
#define IDS_DISPOSITION_REVOKED         2046
#define IDS_DISPOSITION_VALID           2047
#define IDS_DISPOSITION_INVALID         2048
#define IDS_DISPOSITION_UNTRUSTED       2049
#define IDS_DISPOSITION_NOTLOADED       2050
#define IDS_CRLPUBLISHSTATUS_OK         2051
#define IDS_CRLPUBLISHSTATUS_FAILED     2052
#define IDS_CRLPUBLISHSTATUS_UNKNOWN    2053
#define IDS_KRA_CANNOT_OPEN_STORE       2054
#define IDS_OLD_CA                      2055
#define IDS_CERTS_IMPORTED              2056
#define IDS_W2K_UPGRADE_DETECTED_TITLE  2057
#define IDS_CONFIRM_W2K_SECURITY_UPGRADE  2058
#define IDS_BLOCK_W2K_SECURITY_UPGRADE 2059
#define IDS_W2K_SECURITY_UPGRADE_DESCR 2060

#define IDC_TEXT_BOLD                   65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        240
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         290
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

#define __DIR__		"certmmc"

#include <windows.h>
#include <objbase.h>
#include <coguid.h>
#include <aclui.h>

#include <wincrypt.h>

#include <setupapi.h>
#include "ocmanage.h"

#include <atlbase.h>
#include <comdef.h>
//using namespace ATL;

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const CLSID CLSID_Extension; // In-Proc server GUID
extern const CLSID CLSID_About; 

extern HINSTANCE g_hInstance;

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))



#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>

// include debug allocator tracking, etc
#include "certlib.h"

// Thomlinson Foundation Classes
#include "tfc.h"

#include <certsrv.h>
#include <certdb.h>
#include <initcert.h>

// most common private includes
#include "uuids.h"
#include "misc.h"
#include "folders.h"
#include "certwrap.h"
#include "compdata.h"
#include "CSnapin.h"
#include "DataObj.h"

inline void __stdcall _com_issue_error(long) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\urls.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       urls.cpp
//
//--------------------------------------------------------------------------
#include <stdafx.h>

#include "urls.h"



BOOL
IsValidToken(
    IN WCHAR const *pwszToken,
    OUT DWORD      *pdwTokenLen)
{
    BOOL fRet = FALSE;
    DWORD i;
    DWORD len;

    CSASSERT(NULL != pwszToken &&
             L'%' == pwszToken[0] &&
             NULL != pdwTokenLen);

    //init
    *pdwTokenLen = 0;

    //find out how long the token is
    len = wcslen(pwszToken);
    *pdwTokenLen = 1; //skip % escape
    while (iswdigit(pwszToken[*pdwTokenLen]) && *pdwTokenLen < len)
    {
        ++(*pdwTokenLen);
    }

    for (i = 0; i < DISPLAYSTRINGS_TOKEN_COUNT; ++i)
    {
        if (*pdwTokenLen == wcslen(g_displayStrings[i].szContractedToken) &&
            0 == wcsncmp(pwszToken,
                         g_displayStrings[i].szContractedToken, 
                         *pdwTokenLen))
        {
            //found match
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

HRESULT ValidateTokens(
    IN WCHAR const *pwszURL,
    OUT DWORD* pchBadBegin,
    OUT DWORD* pchBadEnd)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszFound = pwszURL;
    DWORD  dwTokenLen;

    *pchBadBegin = -1;
    *pchBadEnd = -1;

    // look for escape token open marker
    while(NULL != (pwszFound = wcschr(pwszFound, L'%')))
    {
        if (!IsValidToken(pwszFound, &dwTokenLen))
        {
            *pchBadBegin =
                SAFE_SUBTRACT_POINTERS(pwszFound, pwszURL) + 1; //skip %
            *pchBadEnd = *pchBadBegin + dwTokenLen - 1;
            hr = S_FALSE;
            break;
        }
        pwszFound += dwTokenLen;
    }
    
    return hr;
}


typedef struct _URL_TYPE_FORMATS
{
    ENUM_URL_TYPE      UrlType;
    WCHAR const       *pwszFormat;
} URL_TYPE_FORMATS;

URL_TYPE_FORMATS const g_URLFormatTable[] =
{
    { URL_TYPE_HTTP,     L"http:"},
    { URL_TYPE_FILE,     L"file:"},
    { URL_TYPE_LDAP,     L"ldap:"},
    { URL_TYPE_FTP,      L"ftp:"},
    { URL_TYPE_UNKNOWN,  NULL},
};

URL_TYPE_FORMATS const *GetURLFormatTableEntry(
    ENUM_URL_TYPE  UrlType)
{
    DWORD i;
    URL_TYPE_FORMATS const *pFormatEntry = g_URLFormatTable;

    while (NULL != pFormatEntry->pwszFormat)
    {
        if (UrlType == pFormatEntry->UrlType)
        {
            return pFormatEntry;
        }
        ++pFormatEntry;
    }
    return NULL;
}

ENUM_URL_TYPE
DetermineURLType(
    ENUM_URL_TYPE *pAllowedUrls,
    DWORD          cAllowedUrls,
    WCHAR         *pwszURL)
{
    DWORD i;
    DWORD dwFlag;
    URL_TYPE_FORMATS const *pFormatEntry = NULL;

    for (i = 0; i < cAllowedUrls; ++i)
    {
        pFormatEntry = GetURLFormatTableEntry(pAllowedUrls[i]);
        if (NULL != pFormatEntry)
        {
            //compare if match format
            if (0 == _wcsnicmp(pwszURL, pFormatEntry->pwszFormat,
                               wcslen(pFormatEntry->pwszFormat)))
            {
                //match, done
                return pAllowedUrls[i];
            }
        }
    }

    //got here, no format match, try local path
    if (myIsFullPath(pwszURL, &dwFlag))
    {
        //it is a valid path
        if (UNC_PATH == dwFlag)
        {
            return URL_TYPE_UNC;
        }
        else
        {
            CSASSERT(LOCAL_PATH == dwFlag);
            return URL_TYPE_LOCAL;
        }
    }

    return URL_TYPE_UNKNOWN;
}

typedef struct _URL_ENABLE_MASK
{
    ENUM_URL_TYPE   UrlType;
    DWORD           dwEnableMask;
} URL_ENABLE_MASK;

URL_ENABLE_MASK g_UrlEnableMaskTable[] =
{
    {URL_TYPE_HTTP,                        CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCRLCDP|CSURL_ADDTOCERTOCSP},
    {URL_TYPE_FILE,    CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCRLCDP|CSURL_ADDTOCERTOCSP},
    {URL_TYPE_LDAP,    CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCRLCDP|CSURL_ADDTOCERTOCSP},
    {URL_TYPE_FTP,     CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCRLCDP|CSURL_ADDTOCERTOCSP},
    {URL_TYPE_LOCAL,   CSURL_SERVERPUBLISH                                                                                },
    {URL_TYPE_UNC,     CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCRLCDP|CSURL_ADDTOCERTOCSP},
};

DWORD
DetermineURLEnableMask(
    IN ENUM_URL_TYPE   UrlType)
{
    DWORD  i;
    DWORD  dwMask = 0x0;

    for (i = 0; i < ARRAYSIZE(g_UrlEnableMaskTable); ++i)
    {
        if (UrlType == g_UrlEnableMaskTable[i].UrlType)
        {
            dwMask = g_UrlEnableMaskTable[i].dwEnableMask;
            break;
        }
    }
    return dwMask;
}



HRESULT 
ExpandDisplayString(
     IN LPCWSTR szContractedString,
     OUT LPWSTR* ppszDisplayString)
{
    HRESULT hr;
    DWORD dwChars;
    int i, iescapedStrings;

    
    LPCWSTR args[ARRAYSIZE(g_displayStrings)];
    for (i=0; i<ARRAYSIZE(g_displayStrings); i++)
    {
        args[i] = *g_displayStrings[i].pcstrExpansionString;
    }

    dwChars = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
        szContractedString,
        0, //msgid
        0, //langid
        (LPWSTR)ppszDisplayString,
        1,  // minimum chars to alloc
        (va_list *)args);

    if (dwChars == 0)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }

    hr = S_OK;
Ret:

    return hr;
}

HRESULT
ContractDisplayString(
     IN LPCWSTR szDisplayString,
     OUT LPWSTR* ppContractedString)
{
    HRESULT hr;
    int i;

    *ppContractedString = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szDisplayString)+1) * sizeof(WCHAR));
    if (*ppContractedString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    wcscpy(*ppContractedString, szDisplayString);

    for (i=0; i<ARRAYSIZE(g_displayStrings); i++)
    {
        DWORD chContractedToken, chExpansionString;

        LPWSTR pszFound = wcsstr(*ppContractedString, *g_displayStrings[i].pcstrExpansionString);
        while(pszFound)
        {
            // calc commonly used values
            chContractedToken = wcslen(g_displayStrings[i].szContractedToken);
            chExpansionString = wcslen(*g_displayStrings[i].pcstrExpansionString);

            // replace with token
            CopyMemory(pszFound, g_displayStrings[i].szContractedToken, chContractedToken*sizeof(WCHAR));

            // slide rest of string left
            MoveMemory(
                &pszFound[chContractedToken],         // destination
                &pszFound[chExpansionString],         // source
                (wcslen(&pszFound[chExpansionString])+1) *sizeof(WCHAR) );

            // step Found over insertion
            pszFound += chContractedToken;

            // find any other ocurrences after this one
            pszFound = wcsstr(pszFound, *g_displayStrings[i].pcstrExpansionString);
        }
    }

    hr = S_OK;
Ret:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\urls.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       urls.h
//
//--------------------------------------------------------------------------
#ifndef __CERTMMC_URLS_H__
#define __CERTMMC_URLS_H__


typedef struct _DISPLAYSTRING_EXPANSION
{
   LPCWSTR szContractedToken;
   UINT uTokenID;
   UINT uTokenDescrID;
   CString* pcstrExpansionString;
   CString* pcstrExpansionStringDescr;
} DISPLAYSTRING_EXPANSION, *PDISPLAYSTRING_EXPANSION;

extern DISPLAYSTRING_EXPANSION g_displayStrings[11];
#define DISPLAYSTRINGS_TOKEN_COUNT   ARRAYSIZE(g_displayStrings)

typedef enum
{
    URL_TYPE_UNKNOWN = 0,
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
    URL_TYPE_LOCAL,
    URL_TYPE_UNC,
} ENUM_URL_TYPE;

typedef struct _CSURLTEMPLATENODE
{
    CSURLTEMPLATE              URLTemplate;
    DWORD                      EnableMask;
    struct _CSURLTEMPLATENODE *pNext;
} CSURLTEMPLATENODE;

typedef struct _ADDURL_DIALOGARGS
{
    ENUM_URL_TYPE       *rgAllowedURLs;
    DWORD                cAllowedURLs;
    LPWSTR              *ppszNewURL;
    CSURLTEMPLATENODE   *pURLList;
} ADDURL_DIALOGARGS, *PADDURL_DIALOGARGS;

ENUM_URL_TYPE
DetermineURLType(
    ENUM_URL_TYPE *pAllowedUrls,
    DWORD          cAllowedUrls,
    WCHAR         *pwszURL);

HRESULT ValidateTokens(
                    IN WCHAR const *pwszURL,
                    OUT DWORD* pchBadBegin,
                    OUT DWORD* pchBadEnd);

DWORD
DetermineURLEnableMask(
    IN ENUM_URL_TYPE   UrlType);


HRESULT 
ExpandDisplayString(
     IN LPCWSTR szContractedString,
     OUT LPWSTR* ppszDisplayString);

HRESULT
ContractDisplayString(
     IN LPCWSTR szDisplayString,
     OUT LPWSTR* ppContractedString);


#endif //__CERTMMC_URLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\snapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "misc.h"


CComModule  _Module;
HINSTANCE   g_hInstance = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Snapin, CComponentDataPrimaryImpl)
    OBJECT_ENTRY(CLSID_About, CSnapinAboutImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void CreateRegEntries();
void RemoveRegEntries();

void CreateProgramGroupLink();
void RemoveProgramGroupLink();

// #define CERTMMC_DEBUG_REGSVR

BOOL WINAPI DllMain(  
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD dwReason,     // reason for calling function
    LPVOID lpvReserved)
{
    switch (dwReason)
    {
    case  DLL_PROCESS_ATTACH:
    {
        g_hInstance = hinstDLL;
        _Module.Init(ObjectMap, hinstDLL);

        DisableThreadLibraryCalls(hinstDLL);

        csiLogOpen("+certmmc.log");

        break;
    }
    case DLL_PROCESS_DETACH:
    {
        // last call process should do this
        myFreeColumnDisplayNames();   

        _Module.Term();

        csiLogClose();

        DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);
        break;
    }

    default:
        break;
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CreateRegEntries();
    CreateProgramGroupLink();

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    RemoveRegEntries();
    RemoveProgramGroupLink();

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Register/UnRegister nodetypes, etc

typedef struct _REGVALUE
{
    DWORD        dwFlags;
    WCHAR const *pwszKeyName;     // NULL implies place value under CA name key
    WCHAR const *pwszValueName;
    WCHAR const *pwszValueString; // NULL implies use REG_DWORD value (dwValue)
    DWORD        dwValue;
} REGVALUE;

// Flags
#define CERTMMC_REG_DELKEY 1    // delete this key on removal

// Values Under "HKLM" from base to leaves
REGVALUE g_arvCA[] =
{
  // main snapin uuid
#define IREG_SNAPINNAME		0
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1, NULL, NULL, 0},
#define IREG_SNAPINNAMESTRING	1
  { 0,                  wszREGKEYMGMTSNAPINUUID1, wszSNAPINNAMESTRING, NULL, 0},
#define IREG_SNAPINNAMESTRINGINDIRECT	2
  { 0,                  wszREGKEYMGMTSNAPINUUID1, wszSNAPINNAMESTRINGINDIRECT, NULL, 0},

  { 0,                  wszREGKEYMGMTSNAPINUUID1, wszSNAPINABOUT, wszSNAPINNODETYPE_ABOUT, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_STANDALONE, NULL, NULL, 0}
  ,
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_1, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_2, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_3, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_4, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_5, NULL, NULL, 0},

  // register each snapin nodetype
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_1, NULL, wszREGCERTSNAPIN_NODETYPES_1, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_2, NULL, wszREGCERTSNAPIN_NODETYPES_2, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_3, NULL, wszREGCERTSNAPIN_NODETYPES_3, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_4, NULL, wszREGCERTSNAPIN_NODETYPES_4, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_5, NULL, wszREGCERTSNAPIN_NODETYPES_5, 0},

  { 0,                  NULL, NULL, NULL, 0 }
};


HRESULT
InitRegEntries(
    OPTIONAL IN OUT CString *pcstrName,
    OPTIONAL IN OUT CString *pcstrNameString,
    OPTIONAL IN OUT CString *pcstrNameStringIndirect)
{
    HRESULT hr = S_OK;
    WCHAR const *pwsz;

    pwsz = NULL;
    if (NULL != pcstrName)
    {
	pcstrName->LoadString(IDS_CERTMMC_SNAPINNAME);
	if (pcstrName->IsEmpty())
	{
	    hr = myHLastError();
	    _PrintError(hr, "LoadString");
	}
	else
	{
	    pwsz = (LPCWSTR) *pcstrName;
	}
    }
    g_arvCA[IREG_SNAPINNAME].pwszValueString = pwsz;

    pwsz = NULL;
    if (NULL != pcstrNameString)
    {
	pcstrNameString->LoadString(IDS_CERTMMC_SNAPINNAMESTRING);
	if (pcstrNameString->IsEmpty())
	{
	    hr = myHLastError();
	    _PrintError(hr, "LoadString");
	}
	else
	{
	    pwsz = (LPCWSTR) *pcstrNameString;
	}
    }
    g_arvCA[IREG_SNAPINNAMESTRING].pwszValueString = pwsz;


    pwsz = NULL;
    if (NULL != pcstrNameStringIndirect)
    {
	pcstrNameStringIndirect->Format(wszSNAPINNAMESTRINGINDIRECT_TEMPLATE, L"CertMMC.dll", IDS_CERTMMC_SNAPINNAMESTRING);
	if (pcstrNameStringIndirect->IsEmpty())
	{
	    hr = myHLastError();
	    _PrintError(hr, "LoadString");
	}
	else
	{
	    pwsz = (LPCWSTR) *pcstrNameStringIndirect;
	}
    }
    g_arvCA[IREG_SNAPINNAMESTRINGINDIRECT].pwszValueString = pwsz;


//error:
    return(hr);
}


void CreateRegEntries()
{
    DWORD err;
    HKEY hKeyThisValue = NULL;
    REGVALUE const *prv;
    CString cstrName;
    CString cstrNameString;
    CString cstrNameStringIndirect;

    InitRegEntries(&cstrName, &cstrNameString, &cstrNameStringIndirect);

    // run until not creating key or value
    for (   prv=g_arvCA; 
            !(NULL == prv->pwszValueName && NULL == prv->pwszKeyName);
            prv++ )
    {
        DWORD dwDisposition;
        ASSERT(NULL != prv->pwszKeyName);
        if (NULL == prv->pwszKeyName)
             continue;

#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegCreateKeyEx: %s\n", prv->pwszKeyName);
            OutputDebugString((LPCWSTR)cstr);
#endif

        err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
             prv->pwszKeyName,
             0,
             NULL,
             REG_OPTION_NON_VOLATILE,
             KEY_ALL_ACCESS,
             NULL,
             &hKeyThisValue,
             &dwDisposition);
        if (err != ERROR_SUCCESS)
            goto error;
        

        // for now, don't set any value if unnamed, unvalued string
        // UNDONE: can't set unnamed dword!

        if (NULL != prv->pwszValueName || NULL != prv->pwszValueString)
        {
            if (NULL != prv->pwszValueString)
            {
#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegSetValueEx: %s : %s\n", prv->pwszValueName, prv->pwszValueString);
            OutputDebugString((LPCWSTR)cstr);
#endif
                err = RegSetValueEx(
                        hKeyThisValue,
                        prv->pwszValueName,
                        0,
                        REG_SZ,
                        (const BYTE *) prv->pwszValueString,
                        WSZ_BYTECOUNT(prv->pwszValueString));
            }
            else
            {
#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegSetValueEx: %s : %ul\n", prv->pwszValueName, prv->dwValue);
            OutputDebugString((LPCWSTR)cstr);
#endif
                err = RegSetValueEx(
                        hKeyThisValue,
                        prv->pwszValueName,
                        0,
                        REG_DWORD,
                        (const BYTE *) &prv->dwValue,
                        sizeof(prv->dwValue));

            }
            if (err != ERROR_SUCCESS)
                goto error;
        }

        if (NULL != hKeyThisValue)
        {
            RegCloseKey(hKeyThisValue);
            hKeyThisValue = NULL;
        }
    }

error:            
    if (hKeyThisValue)
        RegCloseKey(hKeyThisValue);

    InitRegEntries(NULL, NULL, NULL);
    return;
}

void RemoveRegEntries()
{
    DWORD err;
    REGVALUE const *prv;

    // walk backwards through array until hit array start
    for (   prv= (&g_arvCA[ARRAYLEN(g_arvCA)]) - 2;     // goto zero-based end AND skip {NULL}
            prv >= g_arvCA;                             // until we walk past beginning
            prv-- )                                     // walk backwards
    {
        if (prv->dwFlags & CERTMMC_REG_DELKEY) 
        {
            ASSERT(prv->pwszKeyName != NULL);
#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegDeleteKey: %s\n", prv->pwszKeyName);
            OutputDebugString((LPCWSTR)cstr);
#endif

            RegDeleteKey(
                HKEY_LOCAL_MACHINE,
                prv->pwszKeyName);
        }
    }

//error:            

    return;
}

#include <shlobj.h>         // CSIDL_ #defines
#include <userenv.h>
#include <userenvp.h>   // CreateLinkFile API

typedef struct _PROGRAMENTRY
{
    UINT        uiLinkName;
    UINT        uiDescription;
    DWORD       csidl;          // special folder index
    WCHAR const *pwszExeName;
    WCHAR const *pwszArgs;
} PROGRAMENTRY;

PROGRAMENTRY const g_aProgramEntry[] = {
    {
        IDS_STARTMENU_CERTMMC_LINKNAME,         // uiLinkName
        IDS_STARTMENU_CERTMMC_DESCRIPTION,      // uiDescription
        CSIDL_COMMON_ADMINTOOLS,                // "All Users\Start Menu\Programs\Administrative Tools"
        L"certsrv.msc",                          // pwszExeName
        L" /s",                                 // pwszArgs
    },
};

#define CPROGRAMENTRY   ARRAYSIZE(g_aProgramEntry)


BOOL FFileExists(LPCWSTR szFile)
{
    WIN32_FILE_ATTRIBUTE_DATA data;

    return(
    GetFileAttributesEx(szFile, GetFileExInfoStandard, &data) &&
    !(FILE_ATTRIBUTE_DIRECTORY & data.dwFileAttributes) 
          );
}

void CreateProgramGroupLink()
{
    HRESULT hr = S_OK;
    PROGRAMENTRY const *ppe;

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        CString cstrLinkName, cstrDescr, cstrPath;
        LPWSTR pszTmp;

        if (NULL == (pszTmp = cstrPath.GetBuffer(MAX_PATH)))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "GetBuffer");
        }
        
        GetSystemDirectory(pszTmp, MAX_PATH);
        cstrPath += L"\\";
        cstrPath += ppe->pwszExeName;

        // don't create link for file that doesn't exist
        if (!FFileExists(cstrPath))
            continue;

        cstrPath += ppe->pwszArgs;

        cstrLinkName.LoadString(ppe->uiLinkName);
        if (cstrLinkName.IsEmpty())
        {
            hr = myHLastError();
            _JumpError(hr, error, "LoadString");
        }

        cstrDescr.LoadString(ppe->uiDescription);
        if (cstrDescr.IsEmpty())
        {
            hr = myHLastError();
            _JumpError(hr, error, "LoadString");
        }

        if (!CreateLinkFile(
                ppe->csidl,     // CSIDL_*
                NULL,           // IN LPCSTR lpSubDirectory
                (LPCWSTR)cstrLinkName,  // IN LPCSTR lpFileName
                (LPCWSTR)cstrPath,      // IN LPCSTR lpCommandLine
                NULL,       // IN LPCSTR lpIconPath
                0,          // IN INT    iIconIndex
                NULL,       // IN LPCSTR lpWorkingDirectory
                0,          // IN WORD   wHotKey
                SW_SHOWNORMAL,  // IN INT    iShowCmd
                (LPCWSTR)cstrDescr))        // IN LPCSTR lpDescription
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "CreateLinkFile", (LPCWSTR)cstrLinkName);
        }
    }

error:
    _PrintIfError(hr, "CreateProgramGroupLink");    

    return;
}

void RemoveProgramGroupLink()
{
    HRESULT hr = S_OK;
    PROGRAMENTRY const *ppe;

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        CString cstrLinkName;
        cstrLinkName.LoadString(ppe->uiLinkName);
        if (cstrLinkName.IsEmpty())
        {
            hr = myHLastError();
            _PrintError(hr, "LoadString");
            continue;
        }

        if (!DeleteLinkFile(
            ppe->csidl,     // CSIDL_*
            NULL,               // IN LPCSTR lpSubDirectory
            (LPCWSTR)cstrLinkName,      // IN LPCSTR lpFileName
            FALSE))         // IN BOOL fDeleteSubDirectory
        {
            hr = myHLastError();
            _PrintError2(hr, "DeleteLinkFile", hr);
        }
    }

//error:
    _PrintIfError2(hr, "RemoveProgramGroupLink", hr);    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_SNAPIN_DESC),
    RESSTR(IDS_NAME),
    RESSTR(IDS_COLUMN_NAME),
    RESSTR(IDS_SIZE),
    RESSTR(IDS_COLUMN_SIZE),
    RESSTR(IDS_TYPE),
    RESSTR(IDS_COLUMN_TYPE),
    RESSTR(IDS_NODENAME),
    RESSTR(IDS_SNAPIN_DESC2),
    RESSTR(IDS_STRING6),
    RESSTR(IDS_DESCRIPTION),
    RESSTR(IDS_VERSION),
    RESSTR(IDS_COMPANY),
    RESSTR(IDS_SCOPE_MYCOMPUTER),
    RESSTR(IDS_SCOPE_MYCOMPUTER_OVERRIDE),
    RESSTR(IDS_LOCALMACHINE),
    RESSTR(IDS_NODENAME_PREFIX),
    RESSTR(IDS_NODENAME_FORMAT),
    RESSTR(IDS_COLUMN_OTHER),
    RESSTR(IDS_COLUMN_DESCRIPTION),
    RESSTR(IDS_DESCR_CA),
    RESSTR(IDS_DESCR_UNKNOWN),
    RESSTR(IDS_CERTS_REVOKED),
    RESSTR(IDS_CERTS_ISSUED),
    RESSTR(IDS_CERTS_PENDING),
    RESSTR(IDS_STATUSBAR_FILTER_APPLIED),
    RESSTR(IDS_STOPPED_SERVER_MSG),
    RESSTR(IDS_COLUMN_INCLUSION_ERROR),
    RESSTR(IDS_CONFIRM_CRL_PUBLISH),
    RESSTR(IDS_CRL_TITLE),
    RESSTR(IDS_CONFIRM_REVOKE_CERT),
    RESSTR(IDS_REVOKE_CERT_TITLE),
    RESSTR(IDS_FILTER_NOT_SUPPORTED),
    RESSTR(IDS_FILTER_NOT_SUPPORTED2),
    RESSTR(IDS_CONFIRM_SERVICE_RESTART),
    RESSTR(IDS_COLUMNCHOOSER_FIELDNAME),
    RESSTR(IDS_COLUMNCHOOSER_OPERATOR),
    RESSTR(IDS_COLUMNCHOOSER_VALUE),
    RESSTR(IDS_COLUMNCHOOSER_ANDOR),
    RESSTR(IDS_AND),
    RESSTR(IDS_CERTS_FAILED),
    RESSTR(IDS_CONFIRM_DENY_REQUEST),
    RESSTR(IDS_DENY_REQUEST_TITLE),
    RESSTR(IDS_PASSWORD_NOMATCH),
    RESSTR(IDS_PASSWORD_DIALOG),
    RESSTR(IDS_WARN_FILE_EXISTS),
    RESSTR(IDS_INSTALL_HIERARCHY_TITLE),
    RESSTR(IDS_SAVE_DIALOG_TITLE),
    RESSTR(IDS_COMPLETE_HIERARCHY_INSTALL_MSG),
    RESSTR(IDS_MODULE_INSTALL_TITLE),
    RESSTR(IDS_FILEDLG_DLL_FILTER),
    RESSTR(IDS_CHOOSEMODULE_POLICY_TITLE),
    RESSTR(IDS_CHOOSEMODULE_EXIT_TITLE),
    RESSTR(IDS_CANT_ACCESS_BACKUP_DIR),
    RESSTR(IDS_STATUSBAR_SORTEDBY_ASCEND),
    RESSTR(IDS_STATUSBAR_SORTEDBY_DESCEND),
    RESSTR(IDS_CA_REDISCOVER),
    RESSTR(IDS_STARTING_SVC),
    RESSTR(IDS_STOPPING_SVC),
    RESSTR(IDS_BACKUP_PROGRESS),
    RESSTR(IDS_INCREMENTAL_BACKUP),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG1),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG1),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG2),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG2),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG3),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG3),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG4),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG4),
    RESSTR(IDS_BACKUP_WIZARD),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG5),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG5),
    RESSTR(IDS_TASKMENU_UNREVOKECERT),
    RESSTR(IDS_FILEDLG_PKCS12_FILTER),
    RESSTR(IDS_INCRRESTORE_RESTART_SERVER_WARNING),
    RESSTR(IDS_FILEDLG_PKCS12_DEFAULTEXTENSION),
    RESSTR(IDS_RESTORE_WIZARD),
    RESSTR(IDS_REQUIRE_ONE_SELECTION),
    RESSTR(IDS_MSG_DIRECTORY_TITLE),
    RESSTR(IDS_INVALID_DIRECTORY),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG1),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG1),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG2),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG2),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG3),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG3),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG4),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG4),
    RESSTR(IDS_ERR_RESTORE_OUT_OF_ORDER),
    RESSTR(IDS_DIR_CREATE),
    RESSTR(IDS_SERVER_UNAVAILABLE),
    RESSTR(IDS_RESTORE_PROGRESS),
    RESSTR(IDS_POLICYMODULE_NOT_REGISTERED),
    RESSTR(IDS_EXITMODULE_NOT_REGISTERED),
    RESSTR(IDS_RETARGET_SNAPIN),
    RESSTR(IDS_STATUSBAR_RETARGET_SNAPIN),
    RESSTR(IDS_TASKMENU_STATUSBAR_UNREVOKECERT),
    RESSTR(IDS_STATUSBAR_ERRORTEMPLATE),
    RESSTR(IDS_ROLLOVER_REUSEKEYS),
    RESSTR(IDS_PFX_EXPORT_PRIVKEY_WARNING),
    RESSTR(IDS_RENEWAL_PROGRESS),
    RESSTR(IDS_CONFIRM_REMOVE_URL),
    RESSTR(IDS_CONFIRM_REMOVE_TITLE),
    RESSTR(IDS_CERTMMC_SNAPINNAME),
    RESSTR(IDS_CERTMMC_SNAPINNAMESTRING),
    RESSTR(IDS_UNREVOKE_FAILED),
    RESSTR(IDS_TOKEN_SERVERDNSNAME),
    RESSTR(IDS_TOKEN_SERVERSHORTNAME),
    RESSTR(IDS_TOKEN_SANITIZEDCANAME),
    RESSTR(IDS_TOKEN_CERTFILENAMESUFFIX),
    RESSTR(IDS_TOKEN_CONFIGDN),
    RESSTR(IDS_TOKEN_SANITIZEDCANAMEHASH),
    RESSTR(IDS_TOKEN_CRLFILENAMESUFFIX),
    RESSTR(IDS_TOKEN_CRLDELTAFILENAMESUFFIX),
    RESSTR(IDS_TOKEN_DSCRLATTRIBUTE),
    RESSTR(IDS_TOKEN_DSCACERTATTRIBUTE),
    RESSTR(IDS_CRL_REASON_UNSPECIFIED),
    RESSTR(IDS_CRL_REASON_KEY_COMPROMISE),
    RESSTR(IDS_CRL_REASON_CA_COMPROMISE),
    RESSTR(IDS_CRL_REASON_AFFILIATION_CHANGED),
    RESSTR(IDS_CRL_REASON_SUPERSEDED),
    RESSTR(IDS_CRL_REASON_CESSATION_OF_OPERATION),
    RESSTR(IDS_CRL_REASON_CERTIFICATE_HOLD),
    RESSTR(IDS_POSSIBLEERROR_NO_POLICY_MODULE),
    RESSTR(IDS_KEYANDCERT),
    RESSTR(IDS_CALOGS),
    RESSTR(IDS_STOP_SERVER_WARNING),
    RESSTR(IDS_START_SERVER_WARNING),
    RESSTR(IDS_TASKMENU_ROLLOVER),
    RESSTR(IDS_TASKMENU_STATUSBAR_ROLLOVER),
    RESSTR(IDS_CRL_REASON_REMOVE_FROM_CRL),
    RESSTR(IDS_TASKMENU_DUMPASN),
    RESSTR(IDS_TASKMENU_STATUSBAR_DUMPASN),
    RESSTR(IDS_TOKENDESC_SERVERDNSNAME),
    RESSTR(IDS_TOKENDESC_SERVERSHORTNAME),
    RESSTR(IDS_TOKENDESC_SANITIZEDCANAME),
    RESSTR(IDS_TOKENDESC_CERTFILENAMESUFFIX),
    RESSTR(IDS_TOKENDESC_CONFIGDN),
    RESSTR(IDS_TOKENDESC_SANITIZEDCANAMEHASH),
    RESSTR(IDS_TOKENDESC_CRLFILENAMESUFFIX),
    RESSTR(IDS_TOKENDESC_CRLDELTAFILENAMESUFFIX),
    RESSTR(IDS_TOKENDESC_DSCRLATTRIBUTE),
    RESSTR(IDS_TOKENDESC_DSCACERTATTRIBUTE),
    RESSTR(IDS_CA_CERT_LISTBOX_EXPIRED),
    RESSTR(IDS_CA_CERT_LISTBOX_REVOKED),
    RESSTR(IDS_PERIOD_YEARS),
    RESSTR(IDS_PERIOD_MONTHS),
    RESSTR(IDS_PERIOD_WEEKS),
    RESSTR(IDS_PERIOD_DAYS),
    RESSTR(IDS_PERIOD_HOURS),
    RESSTR(IDS_PERIOD_MINUTES),
    RESSTR(IDS_PERIOD_SECONDS),
    RESSTR(IDS_POSITIVE_NUMBER),
    RESSTR(IDS_NO_EXIT_MODULE),
    RESSTR(IDS_VIEWMENU_ALL_RECORDS),
    RESSTR(IDS_VIEWMENU_STATUSBAR_ALL_RECORDS),
    RESSTR(IDS_VIEWMENU_FILTER),
    RESSTR(IDS_VIEWMENU_STATUSBAR_FILTER),
    RESSTR(IDS_EMPTY),
    RESSTR(IDS_VIEWMENU_COLUMNS),
    RESSTR(IDS_VIEWMENU_STATUSBAR_COLUMNS),
    RESSTR(IDS_TASKMENU_STARTSERVICE),
    RESSTR(IDS_TASKMENU_STATUSBAR_STARTSERVICE),
    RESSTR(IDS_TASKMENU_STOPSERVICE),
    RESSTR(IDS_TASKMENU_STATUSBAR_STOPSERVICE),
    RESSTR(IDS_TASKMENU_PUBLISHCRL),
    RESSTR(IDS_TASKMENU_STATUSBAR_PUBLISHCRL),
    RESSTR(IDS_TASKMENU_VIEWCRL),
    RESSTR(IDS_TASKMENU_STATUSBAR_VIEWCRL),
    RESSTR(IDS_TASKMENU_REVOKECERT),
    RESSTR(IDS_TASKMENU_STATUSBAR_REVOKECERT),
    RESSTR(IDS_TASKMENU_RESUBMIT),
    RESSTR(IDS_TASKMENU_STATUSBAR_RESUBMIT),
    RESSTR(IDS_TASKMENU_DENYREQUEST),
    RESSTR(IDS_TASKMENU_STATUSBAR_DENYREQUEST),
    RESSTR(IDS_TASKMENU_BACKUP),
    RESSTR(IDS_TASKMENU_STATUSBAR_BACKUP),
    RESSTR(IDS_NEED_FILEPATH),
    RESSTR(IDS_BACKUPWIZ_TITLE),
    RESSTR(IDS_TOPMENU_OPEN),
    RESSTR(IDS_TASKMENU_RESTORE),
    RESSTR(IDS_TASKMENU_STATUSBAR_RESTORE),
    RESSTR(IDS_TASKMENU_INSTALL_CA),
    RESSTR(IDS_TASKMENU_STATUSBAR_INSTALL_CA),
    RESSTR(IDS_TOPMENU_STATUSBAR_OPEN),
    RESSTR(IDS_ERR_RESTORE_OVER_EXISTING_DATABASE),
    RESSTR(IDS_DIR_NOT_WRITEABLE),
    RESSTR(IDS_DIRECTORY_CONTENTS_UNEXPECTED),
    RESSTR(IDS_MUST_CHOOSE_MACHINE),
    RESSTR(IDS_TASKMENU_REQUEST_CA),
    RESSTR(IDS_TASKMENU_STATUSBAR_REQUEST_CA),
    RESSTR(IDS_ICMM_GETNAMEPROPERTY_FAILED),
    RESSTR(IDS_CHOOSER_INVALID_COMPUTERNAME),
    RESSTR(IDS_EXT_CDP),
    RESSTR(IDS_EXT_AIA),
    RESSTR(IDS_EXT_CDP_EXPLAIN),
    RESSTR(IDS_EXT_AIA_EXPLAIN),
    RESSTR(IDS_INVALID_PREFIX),
    RESSTR(IDS_INVALID_TOKEN),
    RESSTR(IDS_INVALID_ENCODING),
    RESSTR(IDS_EMPTY_URL),
    RESSTR(IDS_SAME_URL_EXIST),
    RESSTR(IDS_VIEW_CERT_DENY_ERROR),
    RESSTR(IDS_VIEW_CERT_NOT_RUNNING),
    RESSTR(IDS_KRA_ADD_TITLE),
    RESSTR(IDS_KRA_ADD_SUBTITLE),
    RESSTR(IDS_TASKMENU_SUBMITREQUEST),
    RESSTR(IDS_TASKMENU_STATUSBAR_SUBMITREQUEST),
    RESSTR(IDS_INH_ALL),
    RESSTR(IDS_INH_CONTAINER),
    RESSTR(IDS_INH_OBJECT),
    RESSTR(IDS_INH_NONE),
    RESSTR(IDS_LARGEFONTNAME),
    RESSTR(IDS_SMALLFONTNAME),
    RESSTR(IDS_SMALLFONTSIZE),
    RESSTR(IDS_FONTSIZE),
    RESSTR(IDS_LARGEFONTSIZE),
    RESSTR(IDS_STARTMENU_CERTMMC_LINKNAME),
    RESSTR(IDS_STARTMENU_CERTMMC_DESCRIPTION),
    RESSTR(IDS_LISTCOL_TAG),
    RESSTR(IDS_LISTCOL_VALUE),
    RESSTR(IDS_TASKMENU_VIEWATTREXT),
    RESSTR(IDS_TASKMENU_STATUSBAR_VIEWATTREXT),
    RESSTR(IDS_LISTCOL_FLAGS),
    RESSTR(IDS_LISTCOL_ORGIN),
    RESSTR(IDS_UNKNOWN_EXTENSION),
    RESSTR(IDS_CERT_PROP_CAPTION),
    RESSTR(IDS_LISTCOL_CRITICAL),
    RESSTR(IDS_LISTCOL_ENABLED),
    RESSTR(IDS_CRL_LISTCOL_INDEX),
    RESSTR(IDS_LISTCOL_EFFECTIVE_DATE),
    RESSTR(IDS_LISTCOL_EXPIRATION_DATE),
    RESSTR(IDS_LISTCOL_PUBLISH_STATUS),
    RESSTR(IDS_YES),
    RESSTR(IDS_NO),
    RESSTR(IDS_EXT_ORIGIN_REQUEST),
    RESSTR(IDS_EXT_ORIGIN_POLICY),
    RESSTR(IDS_EXT_ORIGIN_ADMIN),
    RESSTR(IDS_EXT_ORIGIN_SERVER),
    RESSTR(IDS_EXT_ORIGIN_RENEWAL),
    RESSTR(IDS_EXT_ORIGIN_IMPORTED_CERT),
    RESSTR(IDS_EXT_ORIGIN_PKCS7),
    RESSTR(IDS_EXT_ORIGIN_UNKNOWN),
    RESSTR(IDS_LISTCOL_SUBJECT),
    RESSTR(IDS_LISTCOL_ISSUER),
    RESSTR(IDS_CA_CERT_LISTBOX),
    RESSTR(IDS_LIST_NAME),
    RESSTR(IDS_BINARYFILE_OUTPUT_TITLE),
    RESSTR(IDS_BINARYFILE_OUTPUT_FILTER),
    RESSTR(IDS_KRA_COUNT_TOO_BIG),
    RESSTR(IDS_KRA_NOKRADEFINED),
    RESSTR(IDS_BUTTONTEXT_ALLOW),
    RESSTR(IDS_BUTTONTEXT_DENY),
    RESSTR(IDS_LIST_ACCESS),
    RESSTR(IDS_TEXT_ALLOW),
    RESSTR(IDS_TEXT_DENY),
    RESSTR(IDS_LISTCOL_STATUS),
    RESSTR(IDS_DISPOSITION_EXPIRED),
    RESSTR(IDS_DISPOSITION_NOTFOUND),
    RESSTR(IDS_DISPOSITION_REVOKED),
    RESSTR(IDS_DISPOSITION_VALID),
    RESSTR(IDS_DISPOSITION_INVALID),
    RESSTR(IDS_DISPOSITION_UNTRUSTED),
    RESSTR(IDS_DISPOSITION_NOTLOADED),
    RESSTR(IDS_CRLPUBLISHSTATUS_OK),
    RESSTR(IDS_CRLPUBLISHSTATUS_FAILED),
    RESSTR(IDS_CRLPUBLISHSTATUS_UNKNOWN),
    RESSTR(IDS_KRA_CANNOT_OPEN_STORE),
    RESSTR(IDS_OLD_CA),
    RESSTR(IDS_CERTS_IMPORTED),
    RESSTR(IDS_W2K_UPGRADE_DETECTED_TITLE),
    RESSTR(IDS_CONFIRM_W2K_SECURITY_UPGRADE),
    RESSTR(IDS_BLOCK_W2K_SECURITY_UPGRADE),
    RESSTR(IDS_W2K_SECURITY_UPGRADE_DESCR),
    RESSTR(IDS_CAHIER_CERTFILE_FILTER),
    RESSTR(IDS_CAHIER_INSTALL_TITLE),
    RESSTR(IDS_ILOG_MISSING_PROVIDER),
    RESSTR(IDS_ERR_INCOMPLETECHAIN),
    RESSTR(IDS_ERR_INVALIDCHAIN),
    RESSTR(IDS_ERR_RETRIEVE_PENDING),
    RESSTR(IDS_ILOG_GETCANAME),
    RESSTR(IDS_ILOG_SELECTCA),
    RESSTR(IDS_ILOG_SAVECERTANDKEYS),
    RESSTR(IDS_ILOG_RETRIEVECERT),
    RESSTR(IDS_ILOG_FINISHSUSPENDEDSETUP),
    RESSTR(IDS_ERR_NOTCACERT),
    RESSTR(IDS_ILOG_SETUPCOMPLETE),
    RESSTR(IDS_ILOG_RETRIEVEPENDING),
    RESSTR(IDS_ILOG_KEYINDEX),
    RESSTR(IDS_ILOG_LOADOLDCERT),
    RESSTR(IDS_ILOG_CLONECERT),
    RESSTR(IDS_ILOG_BUILDREQUEST),
    RESSTR(IDS_ILOG_RENEWOLDKEY),
    RESSTR(IDS_ILOG_INSTALLCERT),
    RESSTR(IDS_ILOG_RENEWNEWKEY),
    RESSTR(IDS_ILOG_BUILDCERT),
    RESSTR(IDS_ILOG_SAVECHAINANDKEYS),
    RESSTR(IDS_REQUEST_HELPTEXT),
    RESSTR(IDS_ILOG_CREATECDP),
    RESSTR(IDS_ILOG_CREATENTAUTHTRUST),
    RESSTR(IDS_ILOG_CREATEROOTTRUST),
    RESSTR(IDS_ILOG_PUBLISHCA),
    RESSTR(IDS_ILOG_SUBMITREQUEST),
    RESSTR(IDS_ERR_BADCSP),
    RESSTR(IDS_ERR_BAD_CA_CERT_7F),
    RESSTR(IDS_ERR_RENEWEDCERTCAVERSION),
    RESSTR(IDS_ERR_UNTRUSTEDROOT),
    RESSTR(IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE),
    RESSTR(IDS_ERR_CERTCREATECERTIFICATECONTEXT),
    RESSTR(IDS_ILOG_SETSECURITY),
    RESSTR(IDS_ERR_CREATEFILE),
    RESSTR(IDS_ERR_DELETEKEY),
    RESSTR(IDS_ERR_ENCODEKEYATTR),
    RESSTR(IDS_ERR_ENCODETOBESIGNED),
    RESSTR(IDS_ERR_ENV_NOT_SET),
    RESSTR(IDS_ERR_FULL_TOKEN),
    RESSTR(IDS_ERR_GENKEYFAIL),
    RESSTR(IDS_ERR_GETCOMPUTERNAME),
    RESSTR(IDS_ERR_KEYSECURITY),
    RESSTR(IDS_ERR_MYDECODENAME),
    RESSTR(IDS_ERR_NOT_ENTERPRISE_USER),
    RESSTR(IDS_ERR_NOT_MATCH_NAME),
    RESSTR(IDS_ILOG_GENERATEKEYS),
    RESSTR(IDS_ERR_REPEATWIZPREFIX),
    RESSTR(IDS_ERR_REQUEST_DENIED),
    RESSTR(IDS_ERR_REQUEST_ERROR),
    RESSTR(IDS_ERR_REQUEST_INCOMPLETE),
    RESSTR(IDS_ERR_REQUEST_OUTOFBAND),
    RESSTR(IDS_ERR_REQUEST_PENDING),
    RESSTR(IDS_ERR_REQUEST_REVOKED),
    RESSTR(IDS_ERR_SETKEYPROVIDER),
    RESSTR(IDS_ERR_SUBMIT_REQUEST),
    RESSTR(IDS_ERR_SUBMIT_REQUEST_FAIL),
    RESSTR(IDS_CAHIER_INSTALL_MISIINGCERT_TITLE),
    RESSTR(IDS_ERR_WRITEDERTOFILE),
    RESSTR(IDS_ERR_WRITEFILE),
    RESSTR(IDS_ILOG_SETKEYSECURITY),
    RESSTR(IDS_MSG_PARENTCA_CONFIG),
    RESSTR(IDS_MSG_REQUEST_ID),
    RESSTR(IDS_MSG_TITLE),
    RESSTR(IDS_ILOG_SETADMINONLYFOLDERSECURITY),
    RESSTR(IDS_ERR_NO_KEY_ACCESS),
    RESSTR(IDS_CA_PICKER_TITLE),
    RESSTR(IDS_CA_PICKER_PROMPT),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certprxy\csprxy.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csprxy.h
//
// Contents:    CertPrxy includes
//
//---------------------------------------------------------------------------

extern "C"
BOOL WINAPI
CertPrxyDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

STDAPI
CertPrxyDllCanUnloadNow(void);

STDAPI
CertPrxyDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

STDAPI
CertPrxyDllRegisterServer(void);

STDAPI
CertPrxyDllUnregisterServer(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\uuids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uuids.h
//
//--------------------------------------------------------------------------

const LONG UNINITIALIZED = -1;


enum SCOPE_TYPES
{
    UNINITIALIZED_ITEM  = 0,

    SCOPE_LEVEL_ITEM    = 111,
    RESULT_ITEM         = 222,
    CA_LEVEL_ITEM       = 333,
};

// Sample folder types
enum FOLDER_TYPES
{
    // certsvr machine node
    MACHINE_INSTANCE = 0x8000,

    // certsvr root node
    SERVER_INSTANCE = 0x8007,
    
    // server instance sub-folders
    SERVERFUNC_CRL_PUBLICATION = 0x8100,
    SERVERFUNC_ISSUED_CERTIFICATES = 0x8101,
    SERVERFUNC_PENDING_CERTIFICATES = 0x8102,
    SERVERFUNC_FAILED_CERTIFICATES = 0x8103,
    SERVERFUNC_ALIEN_CERTIFICATES = 0x8104,
    SERVERFUNC_ALL_FOLDERS = 0x81ff,

    NONE = 0xFFFF
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
#ifdef _DEBUG
        OutputDebugString(L"CERTMMC: Release called on NULL interface ptr\n"); 
#endif
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const CLSID CLSID_About; 

///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeMachineInstance;
extern const WCHAR*  cszNodeTypeMachineInstance;

extern const GUID cNodeTypeServerInstance;
extern const WCHAR* cszNodeTypeServerInstance;

extern const GUID cNodeTypeCRLPublication;
extern const WCHAR* cszNodeTypeCRLPublication;

// nodetype for Issued Certs
extern const GUID cNodeTypeIssuedCerts;
extern const WCHAR* cszNodeTypeIssuedCerts;

// nodetype for Pending Certs
extern const GUID cNodeTypePendingCerts;
extern const WCHAR* cszNodeTypePendingCerts;

// nodetype for Failed Certs
extern const GUID cNodeTypeFailedCerts;
extern const WCHAR* cszNodeTypeFailedCerts;

// nodetype for Alien Certs
extern const GUID cNodeTypeAlienCerts;
extern const WCHAR* cszNodeTypeAlienCerts;


// Dynamically created objects.
extern const GUID cNodeTypeDynamic;
extern const wchar_t*  cszNodeTypeDynamic;


//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem;
extern const wchar_t*  cszObjectTypeResultItem;


//
//
//////////////////////////////////////////////////////////////////////////////


extern const WCHAR* SNAPIN_INTERNAL;

// Published context information for extensions to extend
extern const WCHAR* SNAPIN_CA_INSTALL_TYPE;
extern const WCHAR* SNAPIN_CA_COMMON_NAME;
extern const WCHAR* SNAPIN_CA_MACHINE_NAME;
extern const WCHAR* SNAPIN_CA_SANITIZED_NAME;

struct INTERNAL 
{
    INTERNAL() 
    {
        m_type = CCT_UNINITIALIZED; 
        m_cookie = -1;
        ZeroMemory(&m_clsid, sizeof(CLSID));
    };

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;         // What context is the data object.
    MMC_COOKIE          m_cookie;       // What object the cookie represents
    CString             m_string;       // 
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs) 
    { 
        if (&rhs == this)
            return *this;

        // Deep copy the information
        m_type = rhs.m_type; 
        m_cookie = rhs.m_cookie; 
        m_string = rhs.m_string;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    } 

    BOOL operator==(const INTERNAL& rhs) 
    {
        return rhs.m_string == m_string;
    }
};

// Debug instance counter
#ifdef _DEBUG
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "CertMMC: Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certmmc\uuids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uuids.cpp
//
//--------------------------------------------------------------------------

#include <stdafx.h>

const CLSID CLSID_Snapin = /*de751566-4cc6-11d1-8ca0-00c04fc297eb*/ \
{0xde751566,0x4cc6,0x11d1,{0x8c,0xa0,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};

const CLSID CLSID_About = /*4653e860-4cc7-11d1-8ca0-00c04fc297eb*/ \
{0x4653e860,0x4cc7,0x11d1,{0x8c,0xa0,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};

///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// NodeType GUID in numeric & string formats.

// nodetype for each machine instance
const GUID cNodeTypeMachineInstance = 
{0x89b31b94,0x4cc7,0x11d1,{0x8c, 0xa0, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}};
const WCHAR*  cszNodeTypeMachineInstance = L"{89b31b94-4cc7-11d1-8ca0-00c04fc297eb}";

// nodetype for each server instance
const GUID cNodeTypeServerInstance = 
{0x5d972ee4,0x7576,0x11d1,{0x8c, 0xbe, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}};
const WCHAR*  cszNodeTypeServerInstance = L"{5d972ee4-7576-11d1-8cbe-00c04fc297eb}";

// nodetype for CRL Publication
const GUID cNodeTypeCRLPublication = 
{0x5946e36c,0x757c,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypeCRLPublication = L"{5946E36C-757C-11d1-8CBE-00C04FC297EB}";

// nodetype for Issued Certs
const GUID cNodeTypeIssuedCerts = 
{0x783e4e5f,0x757c,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypeIssuedCerts = L"{783E4E5F-757C-11d1-8CBE-00C04FC297EB}";

// nodetype for Pending Certs
const GUID cNodeTypePendingCerts = 
{0x783e4e63,0x757c,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypePendingCerts = L"{783E4E63-757C-11d1-8CBE-00C04FC297EB}";

// nodetype for Failed Certs
const GUID cNodeTypeFailedCerts =
{0x1edac98a,0xaf06,0x11d1,{0x8c,0xd4,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypeFailedCerts = L"{1EDAC98A-AF06-11D1-8CD4-00C04FC297EB}";

// nodetype for Alien Certs
const GUID cNodeTypeAlienCerts =
{0x0A0DAF12,0xD9B8,0x42F3,{0xAF, 0x1C, 0x61, 0xD1, 0x6E, 0x0A, 0x89, 0x27}};
const WCHAR* cszNodeTypeAlienCerts = L"{0A0DAF12-D9B8-42F3-AF1C-61D16E0A8927}";

// Dynamicaly created objects.
extern const GUID cNodeTypeDynamic = 
{0x0ac69b7a,0xafce,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
extern const WCHAR*  cszNodeTypeDynamic = L"{0ac69b7a-afce-11d0-a79b-00c04fd8d565}";



//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem = 
{0x00c86e52,0xaf90,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
extern const WCHAR*  cszObjectTypeResultItem = L"{00c86e52-af90-11d0-a79b-00c04fd8d565}";



//
//
//////////////////////////////////////////////////////////////////////////////

const WCHAR* SNAPIN_INTERNAL = L"SNAPIN_INTERNAL";

// Published formats
const WCHAR* SNAPIN_CA_INSTALL_TYPE = L"SNAPIN_CA_INSTALL_TYPE";
const WCHAR* SNAPIN_CA_COMMON_NAME = L"SNAPIN_CA_COMMON_NAME";
const WCHAR* SNAPIN_CA_MACHINE_NAME = L"SNAPIN_CA_MACHINE_NAME";
const WCHAR* SNAPIN_CA_SANITIZED_NAME = L"SNAPIN_CA_SANITIZED_NAME";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certreq\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDD_ENCODING				101

#define IDI_APP					201
#define IDI_PRODUCT				202

#define IDC_DECODERADIO				303
#define IDC_ENCODERADIO				304
#define IDC_NOBASE64RADIO			305

#define IDS_USAGE_DESCRIPTION			500
#define IDS_REQUEST_FILTER2			501
#define IDS_FORMATSTR_CERTRETRIEVED		502
#define IDS_REQUEST_OUTFILE_TITLE		503
#define IDS_REQUEST_CERT_ERROR			504
#define IDS_APP_NAME				505
#define IDS_WINDOW_NAME				506
#define IDS_ERROR_NO_REQUESTID			507
#define IDS_USAGE_GENERAL			508
#define IDS_ERROR_STRCONVERSION			509
                                        
#define IDS_DISPOSITION_INCOMPLETE		520
#define IDS_DISPOSITION_ERROR			521
#define IDS_DISPOSITION_DENIED			522
#define IDS_DISPOSITION_ISSUED			523
#define IDS_DISPOSITION_ISSUED_OOB		524
#define IDS_DISPOSITION_UNDER_SUBMISSION	525
#define IDS_DISPOSITION_REVOKED			526
#define IDS_DISPOSITION_UNKNOWN			527
                                        
#define IDS_FORMATSTR_CERTNOTISSUED		540
#define IDS_FORMATSTR_CERTPENDING		541
#define IDS_CERTREQ_TITLE			542
#define IDS_FORMATSTR_DECODE_ERR		543
#define IDS_FORMATSTR_ERRCONFIG			544
#define IDS_USAGE_OPTIONS_DESCRIPTION		545
#define IDS_ERROR_NO_FILENAME			546
//#define IDS_UNUSED				547
#define IDS_NOMORE_CAS				548
#define IDS_GETERACERT_TITLE			549
#define IDS_GETERACERT_SUBTITLE			550

#define IDS_INF_OPEN_TITLE			551
#define IDS_INF_FILE_FILTER			552
#define IDS_INF_FILE_DEFEXT			553
#define IDS_OVERWRITE_FILE			554
#define IDS_RESPONSE_FILE_FILTER		555
#define IDS_RESPONSE_FILE_DEFEXT		556
#define IDS_REQUEST_OR_CERT_FILE_FILTER		557
#define IDS_FORMATSTR_REQUESTID			558
#define IDS_GETRENEWALCERT_TITLE		559
#define IDS_GETRENEWALCERT_SUBTITLE		560
#define IDS_GETSIGNINGCERT_TITLE		561
#define IDS_GETSIGNINGCERT_SUBTITLE		562

#define IDS_USAGE_VERB_DEFAULT			563
#define IDS_USAGE_OPTIONS_DEFAULT		564
#define IDS_USAGE_VERB_RETRIEVE			565
#define IDS_USAGE_OPTIONS_RETRIEVE		566
#define IDS_USAGE_VERB_POLICY			567
#define IDS_USAGE_OPTIONS_POLICY		568
#define IDS_USAGE_VERB_SIGN			569
#define IDS_USAGE_OPTIONS_SIGN			570
#define IDS_USAGE_VERB_NEW			571
#define IDS_USAGE_OPTIONS_NEW			572
#define IDS_USAGE_VERB_ACCEPT			573
#define IDS_USAGE_OPTIONS_ACCEPT		574

#define IDS_USAGE_OPTION_ANY			575
#define IDS_USAGE_OPTION_ATTRIB			576
#define IDS_USAGE_OPTION_BINARY			577
#define IDS_USAGE_OPTION_CERT			578
#define IDS_USAGE_OPTION_CONFIG			579
#define IDS_USAGE_OPTION_CRL			580
#define IDS_USAGE_OPTION_F			581
#define IDS_USAGE_OPTION_Q			582
#define IDS_USAGE_OPTION_RPC			583
#define IDS_USAGE_OPTION_VERBOSE		584
#define IDS_USAGE_OPTION_QUESTION		585

#define IDS_USAGE_OPTION_V1			586
#define IDS_USAGE_OPTION_IDISPATCH		587
                                        
#define IDC_STATIC				-1
                                        
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE		547
#define _APS_NEXT_COMMAND_VALUE			40001
#define _APS_NEXT_CONTROL_VALUE			1006
#define _APS_NEXT_SYMED_VALUE			101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certreq\certreq.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certreq.cpp
//
//  Contents:   Cert Store API Tests: Create and Add a chain of certificates
//              and CRLs to the store.
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    07-Mar-96   philh   created
//		10-Oct-96   jerryk  modified
//
//--------------------------------------------------------------------------

#define __DIR__		"certreq"

#define CMSG_SIGNER_ENCODE_INFO_HAS_CMS_FIELDS
#define CMSG_SIGNED_ENCODE_INFO_HAS_CMS_FIELDS
#include <windows.h>
#include <stdlib.h>
#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include <tchar.h>
#include <assert.h>
#include <wincrypt.h>
#include "certlib.h"
#include <certsrv.h>
#include <certca.h>
#include <commdlg.h>
#include <xenroll.h>
#include "resource.h"
#include "csdisp.h"
#include "cscsp.h"
#include "csprop.h"
#include "clibres.h"
#include "csresstr.h"

#define CR_IN_CERT	CR_IN_FORMATMASK

#define wprintf	myConsolePrintf

#define WM_DOCERTREQDIALOGS		WM_USER+0

HINSTANCE g_hInstance;

typedef struct _IDSUSAGE {
    DWORD idsVerb;
    DWORD idsOptions;
    WCHAR const *pwszVerb;
} IDSUSAGE;

#define cmdNONE			MAXDWORD

IDSUSAGE g_aidsUsage[] = {
#define cmdSUBMITREQUEST	0
    { IDS_USAGE_VERB_DEFAULT, IDS_USAGE_OPTIONS_DEFAULT, L"Submit" },

#define cmdRETRIEVEPENDING	1
    { IDS_USAGE_VERB_RETRIEVE, IDS_USAGE_OPTIONS_RETRIEVE, L"Retrieve" },

#define cmdNEWREQUEST		2
    { IDS_USAGE_VERB_NEW, IDS_USAGE_OPTIONS_NEW, L"New" },

#define cmdACCEPTRESPONSE	3
    { IDS_USAGE_VERB_ACCEPT, IDS_USAGE_OPTIONS_ACCEPT, L"Accept" },

#define cmdQUALIFIEDREQUEST	4
    { IDS_USAGE_VERB_POLICY, IDS_USAGE_OPTIONS_POLICY, L"Policy" },

#define cmdSIGNREQUEST		5
    { IDS_USAGE_VERB_SIGN, IDS_USAGE_OPTIONS_SIGN, L"Sign" },
};


WCHAR *g_apwszOptionStrings[] = {
    L"any",		// %1
    L"attrib",		// %2
    L"binary",		// %3
    L"cert",		// %4
    L"config",		// %5
    L"crl",		// %6
    L"f",		// %7
    L"q",		// %8
    L"rpc",		// %9
    L"v",		// %10
    L"?",		// %11
    L"v1",		// %12
    L"idispatch",	// %13
};



DWORD g_dwCommand = cmdNONE;

BOOL g_fAny = FALSE;
BOOL g_fRPC = FALSE;
BOOL g_fIDispatch = FALSE;
BOOL g_fForce = FALSE;
BOOL g_fQuiet = FALSE;
BOOL g_fV1Interface = FALSE;
BOOL g_fFullUsage = FALSE;
BOOL g_fVerbose = FALSE;
BOOL g_idError = 0;
LONG g_dwOutFormat = CV_OUT_BASE64REQUESTHEADER;
DWORD g_dwUIFlag = CC_UIPICKCONFIG;
DWORD g_dwCRLIn = 0;
DWORD g_dwCRLOut = 0;

WCHAR *g_pwszErrorString = NULL;
WCHAR *g_pwszConfig = NULL;
WCHAR *g_pwszCertCN = NULL;
WCHAR const g_wszNewLine[] = L"\n";
CHAR const *g_pszObjIdHash = szOID_OIWSEC_sha1;

#define wszINFSECTION_NEWREQUEST	L"NewRequest"
#define wszINFKEY_SUBJECT		L"Subject"
#define wszINFKEY_PRIVATEKEYARCHIVE	L"PrivateKeyArchive"
#define wszINFKEY_KEYSPEC		L"KeySpec"
#define wszINFKEY_KEYLENGTH		L"KeyLength"
#define wszINFKEY_RENEWALCERT		L"RenewalCert"
#define wszINFKEY_SMIME			L"SMIME"
#define wszINFKEY_EXPORTABLE		L"Exportable"
#define wszINFKEY_USERPROTECTED		L"UserProtected"
#define wszINFKEY_KEYCONTAINER		L"KeyContainer"
#define wszINFKEY_HASHALGID		L"HashAlgId"
#define wszINFKEY_HASHALGORITHM		L"HashAlgorithm"
#define wszINFKEY_MACHINEKEYSET		L"MachineKeySet"
#define wszINFKEY_SILENT		L"Silent"
#define wszINFKEY_PROVIDERNAME		L"ProviderName"
#define wszINFKEY_PROVIDERTYPE		L"ProviderType"
#define wszINFKEY_USEEXISTINHKEYSET	L"UseExistingKeySet"
#define wszINFKEY_REQUESTERNAME		wszPROPREQUESTERNAME
#define wszINFKEY_REQUESTTYPE		L"RequestType"

#define wszINFVALUE_REQUESTTYPE_PKCS101	L"PKCS10-"
#define wszINFVALUE_REQUESTTYPE_PKCS10	L"PKCS10"
#define wszINFVALUE_REQUESTTYPE_PKCS7	L"PKCS7"
#define wszINFVALUE_REQUESTTYPE_CMC	L"CMC"


typedef struct _INFUSAGE
{
    WCHAR const *pwszKey;
} INFUSAGE;

WCHAR const *g_apwszInfKeyNewRequest[] = {
    wszINFKEY_SUBJECT		L" = \"CN=..,OU=...,DC=...\"",
    wszINFKEY_PRIVATEKEYARCHIVE	L" = TRUE",
    wszINFKEY_KEYSPEC		L" = 1",
    wszINFKEY_KEYLENGTH		L" = 1024",
    wszINFKEY_RENEWALCERT	L" = CertId",
    wszINFKEY_SMIME		L" = TRUE",
    wszINFKEY_EXPORTABLE	L" = TRUE",
    wszINFKEY_USERPROTECTED	L" = TRUE",
    wszINFKEY_KEYCONTAINER	L" = \"...\"",
#if 0
    wszINFKEY_HASHALGID		L" = ???",
    wszINFKEY_HASHALGORITHM	L" = ???",
#endif
    wszINFKEY_MACHINEKEYSET	L" = TRUE",
    wszINFKEY_SILENT		L" = TRUE",
    wszINFKEY_PROVIDERNAME	L" = \"" MS_ENHANCED_PROV_W  L"\"",
    wszINFKEY_PROVIDERTYPE	L" = 1",
    wszINFKEY_USEEXISTINHKEYSET	L" = TRUE",
    wszINFKEY_REQUESTERNAME	L" = DOMAIN\\User",
    wszINFKEY_REQUESTTYPE	L" = " wszINFVALUE_REQUESTTYPE_PKCS7,
};


//  Save eror string: "foo.inf" or "foo.inf(key = "value", "value")"

HRESULT
SetErrorStringInf(
    IN WCHAR const *pwszString,
    OPTIONAL IN INFVALUES *pInfValues)
{
    HRESULT hr;
    
    if (NULL == g_pwszErrorString && NULL != pwszString)
    {
	DWORD cwc = wcslen(pwszString);
	DWORD i;
	
	if (NULL != pInfValues && NULL != pInfValues->pwszKey)
	{
	    cwc += 1 + wcslen(pInfValues->pwszKey) + 2 + 1;

	    for (i = 0; i < pInfValues->cValues; i++)
	    {
		if (NULL == pInfValues->rgpwszValues[i])
		{
		    break;
		}
		if (0 != i)
		{
		    cwc++;
		}
		cwc += 2 + wcslen(pInfValues->rgpwszValues[i]) + 1;
	    }
	}
	g_pwszErrorString = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    (cwc + 1) * sizeof(WCHAR));
	if (NULL == g_pwszErrorString)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(g_pwszErrorString, pwszString);

	if (NULL != pInfValues && NULL != pInfValues->pwszKey)
	{
	    wcscat(g_pwszErrorString, wszLPAREN);
	    wcscat(g_pwszErrorString, pInfValues->pwszKey);
	    wcscat(g_pwszErrorString, L" =");

	    for (i = 0; i < pInfValues->cValues; i++)
	    {
		if (NULL == pInfValues->rgpwszValues[i])
		{
		    break;
		}
		if (0 != i)
		{
		    wcscat(g_pwszErrorString, L",");
		}
		wcscat(g_pwszErrorString, L" \"");
		wcscat(g_pwszErrorString, pInfValues->rgpwszValues[i]);
		wcscat(g_pwszErrorString, L"\"");
	    }
	    wcscat(g_pwszErrorString, wszRPAREN);
	}
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
SetErrorString(
    IN WCHAR const *pwszString)
{
    SetErrorStringInf(pwszString, NULL);
}


HRESULT
DisplayResourceString(
    IN DWORD idsMsg,
    OPTIONAL IN WCHAR const * const *papwszString,
    OPTIONAL OUT WCHAR **ppwszFormatted)
{
    HRESULT hr;
    WCHAR *pwszRaw = NULL;
    WCHAR *pwszFormatted = NULL;

    if (NULL != ppwszFormatted)
    {
	*ppwszFormatted = NULL;
    }
    hr = myLoadRCString(g_hInstance, idsMsg, &pwszRaw);
    _JumpIfError(hr, error, "myLoadRCString");

    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_STRING |
			FORMAT_MESSAGE_ARGUMENT_ARRAY,
		    (VOID *) pwszRaw,
		    0,              // dwMessageID
		    0,              // dwLanguageID
		    (LPWSTR) &pwszFormatted,
		    0,
		    (va_list *) papwszString))
    {
	hr = myHLastError();
	wprintf(pwszRaw);
	_JumpError(hr, error, "FormatMessage");
    }
    if (NULL != ppwszFormatted)
    {
	*ppwszFormatted = pwszFormatted;
	pwszFormatted = NULL;
    }
    else
    {
	wprintf(pwszFormatted);
    }

error:
    if (NULL != pwszRaw)
    {
	LocalFree(pwszRaw);
    }
    if (NULL != pwszFormatted)
    {
	LocalFree(pwszFormatted);
    }
    return(hr);
}


DWORD g_aidsOptions[] =
{
    IDS_USAGE_OPTION_ANY,
    IDS_USAGE_OPTION_ATTRIB,
    IDS_USAGE_OPTION_BINARY,
    IDS_USAGE_OPTION_CERT,
    IDS_USAGE_OPTION_CONFIG,
    IDS_USAGE_OPTION_CRL,
    IDS_USAGE_OPTION_F,
    IDS_USAGE_OPTION_Q,
    IDS_USAGE_OPTION_RPC,
    IDS_USAGE_OPTION_VERBOSE,
    IDS_USAGE_OPTION_QUESTION,
};


DWORD g_aidsOptionsFull[] =
{
    IDS_USAGE_OPTION_V1,
    IDS_USAGE_OPTION_IDISPATCH,
};


// Option description formatting:
// Resource string contains "%2 <Arg>\nDescription\nMore description\n"
// To format:
//     insert "  -" in front of the first line and skip the newline,
//     insert space to pad out to N-2 columns and "- " before the second line,
//     insert space to pad out to N columns before all additional lines.

#define cwcINDENT 28   // ----+
                       //     |
/*                            v
    -Optiom <Arg>           - Description\n
                              More description\n
*/


VOID
DisplayOptionList(
    IN DWORD cOpt,
    IN DWORD *aidsOpt)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < cOpt; i++)
    {
	WCHAR *pwszFormatted = NULL;
	WCHAR const *pwszPrefix;
	WCHAR *pwsz;
	DWORD j;
	DWORD iLine;
	DWORD cwc0;

	DisplayResourceString(aidsOpt[i], g_apwszOptionStrings, &pwszFormatted);
	if (NULL == pwszFormatted)
	{
	    continue;
	}

	pwsz = pwszFormatted;
	iLine = 0;
	while (L'\0' != *pwsz)
	{
	    WCHAR const *pwszNewLine = L"\n";
	    DWORD cwcPad;

	    j = wcscspn(pwsz, L"\r\n");

	    switch (iLine)
	    {
		WCHAR wc;

		case 0:
		    cwcPad = 2;
		    pwszPrefix = L"-";
		    wc = pwsz[j];
		    pwsz[j] = L'\0';
		    cwc0 = cwcPad +
				wcslen(pwszPrefix) +
				myGetDisplayLength(pwsz);
		    pwsz[j] = wc;
		    pwszNewLine = L"";
		    break;

		case 1:
		    cwcPad = 1;
		    if (cwcINDENT > 2 + cwc0)
		    {
			cwcPad = cwcINDENT - (2 + cwc0);
		    }
		    pwszPrefix = L"- ";
		    break;

		default:
		    cwcPad = cwcINDENT;
		    pwszPrefix = L"";
		    break;
	    }
	    wprintf(
		L"%*ws%ws%.*ws%ws",
		cwcPad,
		L"",
		pwszPrefix,
		j,
		pwsz,
		pwszNewLine);

	    pwsz += j;
	    if (L'\r' == *pwsz)
	    {
		pwsz++;
	    }
	    if (L'\n' == *pwsz)
	    {
		pwsz++;
	    }
	    iLine++;
	}
	LocalFree(pwszFormatted);
    }
}


VOID
Usage(
    IN BOOL fError)
{
    HRESULT hr;
    WCHAR *pwszUsage = NULL;
    IDSUSAGE *pidsUsage;
    IDSUSAGE *pidsUsageEnd;
    BOOL fShowOptions;

    DisplayResourceString(IDS_USAGE_GENERAL, NULL, NULL);
    wprintf(L"\n");
    switch (g_dwCommand)
    {
	case cmdSUBMITREQUEST:
	case cmdRETRIEVEPENDING:
	case cmdNEWREQUEST:
	case cmdACCEPTRESPONSE:
	case cmdQUALIFIEDREQUEST:
	case cmdSIGNREQUEST:
	    pidsUsage = &g_aidsUsage[g_dwCommand];
	    pidsUsageEnd = &pidsUsage[1];
	    fShowOptions = TRUE;
	    break;

	case cmdNONE:
	default:
	    pidsUsage = g_aidsUsage;
	    pidsUsageEnd = &g_aidsUsage[ARRAYSIZE(g_aidsUsage)];
	    fShowOptions = g_fVerbose;
	    break;
    }
    if (fError)
    {
	fShowOptions = FALSE;
    }
    for ( ; pidsUsage < pidsUsageEnd; pidsUsage++)
    {
	DisplayResourceString(pidsUsage->idsVerb, &pidsUsage->pwszVerb, NULL);
	if (fShowOptions)
	{
	    DisplayResourceString(pidsUsage->idsOptions, g_apwszOptionStrings, NULL);
	}
	wprintf(L"\n");
    }
    if (fShowOptions)
    {
	DisplayResourceString(IDS_USAGE_OPTIONS_DESCRIPTION, NULL, NULL);
	DisplayOptionList(ARRAYSIZE(g_aidsOptions), g_aidsOptions);
	if (g_fFullUsage)
	{
	    DisplayOptionList(ARRAYSIZE(g_aidsOptionsFull), g_aidsOptionsFull);
	}
	wprintf(L"\n");
	DisplayResourceString(IDS_USAGE_DESCRIPTION, g_apwszOptionStrings, NULL);
    }
    if (!fError)
    {
	if ((cmdNEWREQUEST == g_dwCommand ||
	    (cmdNONE == g_dwCommand && g_fVerbose)))
	{
	    DWORD i;
	    
	    wprintf(L"[%ws]\n", wszINFSECTION_NEWREQUEST);
	    for (i = 0; i < ARRAYSIZE(g_apwszInfKeyNewRequest); i++)
	    {
		wprintf(L"    %ws\n", g_apwszInfKeyNewRequest[i]);
	    }
	}
    }
    exit(0);
}


VOID
AppendAttributeString(
    IN OUT WCHAR *pwszOut,
    IN WCHAR const *pwszIn)
{
    pwszOut += wcslen(pwszOut);
    while (L'\0' != *pwszIn)
    {
	switch (*pwszIn)
	{
	    case L';':
		*pwszOut = L'\n';
		break;

	    case L'\\':
		if (L'n' == pwszIn[1])
		{
		    *pwszOut = L'\n';
		    pwszIn++;
		    break;
		}
		if (L'r' == pwszIn[1])
		{
		    *pwszOut = L'\r';
		    pwszIn++;
		    break;
		}
		// else FALLTHROUGH

	    default:
		*pwszOut = *pwszIn;
		break;
	}
	pwszOut++;
	pwszIn++;
    }
    *pwszOut = L'\0';
}


HRESULT
crCombineAttributes(
    IN WCHAR const *pwszAttributesAdd,
    IN OUT WCHAR **ppwszAttributesExisting)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszAttributesExisting = *ppwszAttributesExisting;
    WCHAR *pwsz;
    
    cwc = wcslen(pwszAttributesAdd) + 1;
    if (NULL != pwszAttributesExisting)
    {
	cwc += wcslen(pwszAttributesExisting) + 1;
    }
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    
    pwsz[0] = L'\0';
    if (NULL != pwszAttributesExisting)
    {
	AppendAttributeString(pwsz, pwszAttributesExisting);
	AppendAttributeString(pwsz, L"\\n");
	LocalFree(pwszAttributesExisting);
    }
    AppendAttributeString(pwsz, pwszAttributesAdd);
    *ppwszAttributesExisting = pwsz;
    hr = S_OK;

error:
    return(hr);
}


VOID
crMissingFileArg()
{
    HRESULT hr;
    WCHAR *pwszMsg = NULL;

    hr = myLoadRCString(g_hInstance, IDS_ERROR_NO_FILENAME, &pwszMsg);
    _JumpIfError(hr, error, "myLoadRCString");

    CSASSERT(NULL != pwszMsg);
    wprintf(pwszMsg);
    wprintf(g_wszNewLine);

error:
    if (NULL != pwszMsg)
    {
	LocalFree(pwszMsg);
    }
}


HRESULT
crGetOpenFileName(
    IN HWND hWndOwner,
    IN UINT idsOpenTitle,
    IN UINT idsFileFilter,
    IN UINT idsFileDefExt,
    OUT WCHAR **ppwszOFN)
{
    HRESULT hr;
    
    if (g_fQuiet)
    {
	crMissingFileArg();
	Usage(TRUE);
    }

    // Put up a file dialog to prompt the user for Inf File
    // 0 == hr means dialog was cancelled, we cheat because S_OK == 0

    hr = myGetOpenFileName(
		hWndOwner,
		NULL,				// hInstance
		idsOpenTitle,
		idsFileFilter,
		idsFileDefExt,
		OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
		NULL,				// no default file
		ppwszOFN);
    _JumpIfError(hr, error, "myGetOpenFileName");

    if (NULL == *ppwszOFN)
    {
	// cancelled:
	// see public\sdk\inc\cderr.h for real CommDlgExtendedError errors

	hr = myHError(CommDlgExtendedError());
	if (S_OK == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	}
	_JumpError(hr, error, "myGetOpenFileName");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
crOverwriteFileAllowed(
    IN HWND hWndOwner,
    IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    int rc = IDCANCEL;
    WCHAR *pwszTitle = NULL;
    WCHAR *pwszMessage = NULL;
    WCHAR *pwsz = NULL;

    if (!g_fForce && myDoesFileExist(pwszfnOut))
    {
	if (!g_fQuiet)
	{
	    DWORD cwc;

	    hr = myLoadRCString(g_hInstance, IDS_CERTREQ_TITLE, &pwszTitle);
	    _JumpIfError(hr, error, "myLoadRCString");

	    hr = myLoadRCString(g_hInstance, IDS_OVERWRITE_FILE, &pwszMessage);
	    _JumpIfError(hr, error, "myLoadRCString");

	    cwc = wcslen(pwszMessage) + 2 + wcslen(pwszfnOut);
	    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (1 + cwc) * sizeof(WCHAR));
	    if (NULL == pwsz)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwsz, pwszMessage);
	    wcscat(pwsz, L"\r\n");
	    wcscat(pwsz, pwszfnOut);

	    rc = MessageBox(
		    hWndOwner,
		    pwsz,
		    pwszTitle,
		    MB_OKCANCEL |
			MB_DEFBUTTON2 |
			MB_ICONWARNING |
			MB_SETFOREGROUND);
	}
	if (IDOK != rc)
	{
	    SetErrorString(pwszfnOut);
	    hr = g_fQuiet?
		    HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) :
		    HRESULT_FROM_WIN32(ERROR_CANCELLED);
	    _JumpErrorStr(hr, error, "File Exists", pwszfnOut);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszMessage)
    {
        LocalFree(pwszMessage);
    }
    return(hr);
}


HRESULT
WriteCertificateOrRequest(
    IN HWND hWndOwner,
    OPTIONAL IN DISPATCHINTERFACE *pdiRequest,
    OPTIONAL IN BYTE const *pbOut,
    IN DWORD cbOut,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    WCHAR *pwszOFN = NULL;
    BSTR strCert = NULL;
    CHAR *pszCert = NULL;
    DWORD decFlags = CRYPT_STRING_BINARY;
    WCHAR const *pwszTitle;
    WCHAR const *pwszMessage;
    BOOL fCheckFileOverwriteOK = TRUE; // careful not to overwrite without prompting user

    if (NULL == pwszfnOut)
    {
	if (g_fQuiet)
	{
	    crMissingFileArg();
	    Usage(TRUE);
	}

	// Put up a file dialog to prompt the user for Cert file
	// 0 == hr means dialog was cancelled, we cheat because S_OK == 0

        hr = myGetSaveFileName(
                 hWndOwner,
		 NULL,				// hInstance
                 IDS_REQUEST_OUTFILE_TITLE,
                 IDS_REQUEST_FILTER2,
                 0,				//no def ext
                 OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
		 NULL,				// no default file
                 &pwszOFN);
        _JumpIfError(hr, error, "myGetSaveFileName");

        fCheckFileOverwriteOK = FALSE; // OFN_OVERWRITEPROMPT should have prompted if necessary

        if (NULL == pwszOFN)
        {
            // cancelled:
	    // see public\sdk\inc\cderr.h for real CommDlgExtendedError errors

	    hr = myHError(CommDlgExtendedError());
	    _JumpError(hr, error, "myGetSaveFileName");
        }
	pwszfnOut = pwszOFN;

	hr = myIsDirWriteable(pwszfnOut, TRUE);
	if (S_OK != hr)
	{
	    SetErrorString(pwszfnOut);
	    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnOut);
	}
    }

    if (NULL == pbOut)
    {
	hr = Request_GetCertificate(pdiRequest, Flags, &strCert);
	_JumpIfError(hr, error, "Request_GetCertificate");

	if (CR_OUT_BINARY == (CR_OUT_ENCODEMASK & Flags))
	{
	    cbOut = SysStringByteLen(strCert);
	    pbOut = (BYTE const *) strCert;
	}
	else
	{
	    if (!ConvertWszToSz(&pszCert, strCert, -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "ConvertWszToSz(cert)");
	    }
	    cbOut = strlen(pszCert);
	    pbOut = (BYTE const *) pszCert;
	}
    }
    else
    {
	decFlags = CR_OUT_ENCODEMASK & Flags;
	CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
	CSASSERT(CR_OUT_BINARY == CRYPT_STRING_BINARY);
    }

    if (fCheckFileOverwriteOK)
    {
        hr = crOverwriteFileAllowed(hWndOwner, pwszfnOut);
        _JumpIfError(hr, error, "crOverwriteFileAllowed");
    }

    hr = EncodeToFileW(
		pwszfnOut,
		pbOut,
		cbOut,
		DECF_FORCEOVERWRITE | decFlags);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnOut);
	_JumpErrorStr(hr, error, "EncodeToFileW", pwszfnOut);
    }

error:
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    if (NULL != pszCert)
    {
	LocalFree(pszCert);
    }
    if (NULL != pwszOFN)
    {
	LocalFree(pwszOFN);
    }
    return(hr);
}


HRESULT
GetLong(
    WCHAR const *pwszIn,
    LONG *pLong)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR const *pwsz;
    LONG l;

    pwsz = pwszIn;
    if (NULL == pwsz)
    {
	_JumpError(hr, error, "NULL parm");
    }
    if (L'\0' == *pwsz)
    {
	_JumpError(hr, error, "empty string");
    }
    if (L'0' == *pwsz && (L'x' == pwsz[1] || L'X' == pwsz[1]))
    {
	l = 0;
	pwsz += 2;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswxdigit(*pwsz))
	    {
		_JumpErrorStr(hr, error, "Non-hex digit", pwszIn);
	    }
	    if (0xf0000000 & l)
	    {
		_JumpErrorStr(hr, error, "overflow", pwszIn);
	    }
	    l <<= 4;
	    if (iswdigit(*pwsz))
	    {
		l |= *pwsz - L'0';
	    }
	    else if (L'A' <= *pwsz && L'F' >= *pwsz)
	    {
		l |= *pwsz - L'A' + 10;
	    }
	    else
	    {
		l |= *pwsz - L'a' + 10;
	    }
	}
	*pLong = l;
    }
    else
    {
	LARGE_INTEGER li;
	
	li.QuadPart = 0;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswdigit(*pwsz))
	    {
		_JumpErrorStr2(hr, error, "Non-decimal digit", pwszIn, hr);
	    }
	    li.QuadPart *= 10;
	    li.QuadPart += *pwsz - L'0';
	    if (0 != li.HighPart || 0 > (LONG) li.LowPart)
	    {
		_JumpErrorStr2(hr, error, "overflow", pwszIn, hr);
	    }
	}
	*pLong = li.LowPart;
    }
    hr = S_OK;
    //wprintf(L"GetLong(%ws) --> %x (%d)\n", pwszIn, *pLong, *pLong);

error:
    return(hr);
}


HRESULT
CheckRequestType(
    IN WCHAR const *pwszfnReq,
    OUT BYTE **ppbReq,
    OUT DWORD *pcbReq,
    OUT LONG *pFlags,
    OUT BOOL *pfSigned)
{
    HRESULT hr;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    DWORD cb;
    LONG EncodingType;
    LONG RequestType;
    BYTE *pbDecoded = NULL;
    HCRYPTMSG hMsg = NULL;
    char *pszInnerContentObjId = NULL;
    CERT_SIGNED_CONTENT_INFO *pcsci = NULL;
    DWORD cbcsci;
    DWORD dwMsgType;
    DWORD cSigner;
    DWORD cRecipient;

    *ppbReq = NULL;
    *pcbReq = NULL;
    *pFlags = 0;
    *pfSigned = FALSE;

    EncodingType = CR_IN_BASE64HEADER;
    hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BASE64HEADER);
    if (S_OK != hr)
    {
	//_PrintError(hr, "DecodeFileW(CRYPT_STRING_BASE64HEADER)");
	CSASSERT(NULL == pbReq);

	EncodingType = CR_IN_BASE64;
	hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BASE64);
	if (S_OK != hr)
	{
	    //_PrintError(hr, "DecodeFileW(CRYPT_STRING_BASE64)");
	    CSASSERT(NULL == pbReq);

	    EncodingType = CR_IN_BINARY;
	    hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BINARY);
	    if (S_OK != hr)
	    {
		SetErrorString(pwszfnReq);
		_JumpErrorStr(hr, error, "DecodeFileW", pwszfnReq);
	    }
	}
    }
    CSASSERT(NULL != pbReq);

    RequestType = CR_IN_PKCS10;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbReq,
		    cbReq,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cb))
    {
	//_PrintError(myHLastError(), "myDecodeObject(PKCS10)");
	CSASSERT(NULL == pbDecoded);

	RequestType = CR_IN_CERT;
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT_TO_BE_SIGNED,
			pbReq,
			cbReq,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cb))
	{
	    //_PrintError(myHLastError(), "myDecodeObject(Cert)");
	    CSASSERT(NULL == pbDecoded);

	    RequestType = CR_IN_KEYGEN;
	    if (!myDecodeKeyGenRequest(
				pbReq,
				cbReq,
				CERTLIB_USE_LOCALALLOC,
				(CERT_KEYGEN_REQUEST_INFO **) &pbDecoded,
				&cb))
	    {
		//_PrintError(myHLastError(), "myDecodeKeyGenRequest");
		CSASSERT(NULL == pbDecoded);

		RequestType = CR_IN_PKCS7; // PKCS 7 renewal request?
		hr = myDecodePKCS7(
				pbReq,
				cbReq,
				NULL,		// ppbContents
				NULL,		// pcbContents
				&dwMsgType,
				&pszInnerContentObjId,
				&cSigner,
				&cRecipient,
				NULL,		// phStore
				&hMsg);
		_JumpIfError(hr, error, "myDecodePKCS7");

		if (NULL != pszInnerContentObjId &&
		    0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA))
		{
		    RequestType = CR_IN_CMC;
		}
		if (0 < cSigner)
		{
		    *pfSigned = TRUE;
		}
	    }
	}
    }
    if (CR_IN_CERT == RequestType ||
	CR_IN_PKCS10 == RequestType ||
	CR_IN_KEYGEN == RequestType)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT,
			pbReq,
			cbReq,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pcsci,
			&cbcsci))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "myDecodeObject", CRYPT_E_ASN1_BADTAG);
	}
	else
	{
	    *pfSigned = TRUE;		// has a signature
	}
    }
    *ppbReq = pbReq;
    pbReq = NULL;
    *pcbReq = cbReq;
    *pFlags = EncodingType | RequestType;
    
error:
    if (NULL != pcsci)
    {
	LocalFree(pcsci);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (NULL != pbReq)
    {
        LocalFree(pbReq);
    }
    return(hr);
}


WCHAR *
wszDisposition(
    DWORD disposition)
{
    HRESULT hr;
    UINT iRsc = 0;
    WCHAR *pwszDisposition = NULL;

    switch (disposition)
    {
	case CR_DISP_INCOMPLETE:	 
	    iRsc = IDS_DISPOSITION_INCOMPLETE; 
	    break;

	case CR_DISP_ERROR:		 
	    iRsc = IDS_DISPOSITION_ERROR;
	    break;

	case CR_DISP_DENIED:
	    iRsc = IDS_DISPOSITION_DENIED;
	    break;

	case CR_DISP_ISSUED:
	    iRsc = IDS_DISPOSITION_ISSUED;
	    break;

	case CR_DISP_ISSUED_OUT_OF_BAND:
	    iRsc = IDS_DISPOSITION_ISSUED_OOB;
	    break;

	case CR_DISP_UNDER_SUBMISSION:
	    iRsc = IDS_DISPOSITION_UNDER_SUBMISSION;
	    break;

	case CR_DISP_REVOKED:
	    iRsc = IDS_DISPOSITION_REVOKED;
	    break;

	default:
	    iRsc = IDS_DISPOSITION_UNKNOWN;
	    break;
    }

    hr = myLoadRCString(g_hInstance, iRsc, &pwszDisposition);
    _PrintIfError(hr, "myLoadRCString");

    return(pwszDisposition);
}


VOID
DumpProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN WCHAR const *pwszPropId,
    IN LONG PropIndex,
    IN LONG PropType,
    OPTIONAL OUT LONG *pCount)
{
    HRESULT hr;
    LONG Flags;
    VOID *pvOut;
    BSTR str = NULL;
    LONG val;
    DATE date;
    WCHAR wszInfo[128];

    if (NULL != pCount)
    {
	*pCount = 0;
    }
    Flags = CV_OUT_BINARY;
    switch (PropType)
    {
	case PROPTYPE_BINARY:
	    Flags = CV_OUT_BASE64HEADER;
	    pvOut = &str;
	    break;

	case PROPTYPE_STRING:
	    pvOut = &str;
	    break;

	case PROPTYPE_DATE:
	    pvOut = &date;
	    break;

	case PROPTYPE_LONG:
	    pvOut = &val;
	    break;
    }
    wsprintf(wszInfo, L"%ws[%u] %u", pwszPropId, PropIndex, PropType);
    hr = Request2_GetFullResponseProperty(
				pdiRequest,
				PropId,
				PropIndex,
				PropType,
				Flags,
				pvOut);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	wprintf(L"%ws: CERTSRV_E_PROPERTY_EMPTY\n", wszInfo);
    }
    _JumpIfErrorStr2(
		hr,
		error,
		"Request2_GetFullResponseProperty",
		wszInfo,
		CERTSRV_E_PROPERTY_EMPTY);

    wprintf(L"%ws:", wszInfo);

    switch (PropType)
    {
	case PROPTYPE_BINARY:
	    wprintf(L"\n%ws\n", str);
	    break;

	case PROPTYPE_STRING:
	    wprintf(L" \"%ws\"\n", str);
	    break;

	case PROPTYPE_DATE:
	    wprintf(L" %f\n", date);
	    break;

	case PROPTYPE_LONG:
	    wprintf(L" 0x%x(%u)\n", val, val);
	    if (NULL != pCount)
	    {
		*pCount = val;
	    }
	    break;
    }

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
}


VOID
DumpIndexedProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN WCHAR const *pwszPropId,
    IN LONG PropType,
    LONG Count)
{
    LONG PropIndex;

    for (PropIndex = 0; PropIndex < Count; PropIndex++)
    {
	DumpProperty(pdiRequest, PropId, pwszPropId, PropIndex, PropType, NULL);
    }
}


typedef struct _FRPROP
{
    LONG PropId;
    WCHAR *pwszPropId;
    LONG PropType;
} FRPROP;


#define _PROPARG(pt)		(pt), L#pt

FRPROP s_afrp[] =
{
    { _PROPARG(FR_PROP_BODYPARTSTRING),         PROPTYPE_STRING },
    { _PROPARG(FR_PROP_STATUS),                 PROPTYPE_LONG },
    { _PROPARG(FR_PROP_STATUSSTRING),           PROPTYPE_STRING },
    { _PROPARG(FR_PROP_OTHERINFOCHOICE),        PROPTYPE_LONG },
    { _PROPARG(FR_PROP_FAILINFO),               PROPTYPE_LONG },
    { _PROPARG(FR_PROP_PENDINFOTOKEN),          PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_PENDINFOTIME),           PROPTYPE_DATE },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATEHASH),  PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ENCRYPTEDKEYHASH),       PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATE),      PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATECHAIN), PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATECRLCHAIN), PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ENCRYPTEDKEYHASH),	PROPTYPE_BINARY },
};


VOID
DumpFullResponseProperties(
    IN DISPATCHINTERFACE *pdiRequest)
{
    LONG cResponse = 0;
    DWORD i;
    
    DumpProperty(
	    pdiRequest,
	    _PROPARG(FR_PROP_FULLRESPONSE),
	    0,
	    PROPTYPE_BINARY,
	    NULL);

    DumpProperty(
	    pdiRequest,
	    _PROPARG(FR_PROP_FULLRESPONSENOPKCS7),
	    0,
	    PROPTYPE_BINARY,
	    NULL);

    DumpProperty(
	    pdiRequest,
	    _PROPARG(FR_PROP_STATUSINFOCOUNT),
	    0,
	    PROPTYPE_LONG,
	    &cResponse);

    for (i = 0; i < ARRAYSIZE(s_afrp); i++)
    {
	DumpIndexedProperty(
		    pdiRequest,
		    s_afrp[i].PropId,
		    s_afrp[i].pwszPropId,
		    s_afrp[i].PropType,
		    cResponse);
    }
}


HRESULT
SaveFullResponse(
    IN HWND hWndOwner,
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszfnFullResponse)
{
    HRESULT hr;
    BSTR strFullResponse = NULL;

    hr = Request2_GetFullResponseProperty(
				pdiRequest,
				FR_PROP_FULLRESPONSENOPKCS7,
				0,		// PropIndex
				PROPTYPE_BINARY,
				CV_OUT_BINARY,
				&strFullResponse);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "Request2_GetFullResponseProperty");
    }
    if (S_OK == hr)
    {
        hr = WriteCertificateOrRequest(
			    hWndOwner,
			    pdiRequest,
			    (BYTE const *) strFullResponse,
			    SysStringByteLen(strFullResponse),
			    g_dwOutFormat,
			    pwszfnFullResponse);
        _JumpIfError(hr, error, "WriteCertificateOrRequest");
    }
    hr = S_OK;
    goto error;

error:
    if (NULL != strFullResponse)
    {
	SysFreeString(strFullResponse);
    }
    return(hr);
}


HRESULT
CallServerAndStoreCert(
    IN HWND hWndOwner,
    IN WCHAR const *pwszConfig,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszfnReq,
    OPTIONAL IN WCHAR const *pwszfnCert,
    OPTIONAL IN WCHAR const *pwszfnCertChain,
    OPTIONAL IN WCHAR const *pwszfnFullResponse)
{
    HRESULT hr;
    HRESULT hr2;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    LONG dwFlags;
    BOOL fSigned;
    BSTR strRequest = NULL;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;
    BSTR strMessage = NULL;
    WCHAR const *pwszMessage;
    CERTSERVERENROLL csEnroll;
    CERTSERVERENROLL *pcsEnroll = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszAuthority = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    char const *pszMethod;
    WCHAR *pwszMsg = NULL;
    WCHAR *pwszDispMsg = NULL;
    WCHAR *pwszConfigPlusSerial = NULL;
    BOOL fV1 = g_fV1Interface;

    // If submitting a new request:


    if (NULL != pwszfnReq)
    {
	// Read the request from a file, convert it to binary, and return
	// dwFlags to indicate the orignal encoding and the detected format.

	hr = CheckRequestType(pwszfnReq, &pbReq, &cbReq, &dwFlags, &fSigned);
	_JumpIfError(hr, error, "CheckRequestType");

	if (!fSigned || CR_IN_CERT == (CR_IN_FORMATMASK & dwFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    SetErrorString(pwszfnReq);
	    _JumpError(hr, error, "not a signed request");
	}
    }

    if (1 < g_fRPC)
    {
	hr = mySplitConfigString(pwszConfig, &pwszServer, &pwszAuthority);
	_JumpIfError(hr, error, "mySplitConfigString");

	if (NULL != pwszfnReq)
	{
	    // Since CertServerSubmitRequest can only handle binary requests,
	    // pass the request in binary form, and set dwFlags to so indicate.

	    dwFlags = CR_IN_BINARY | (~CR_IN_ENCODEMASK & dwFlags);

	    pszMethod = "CertServerSubmitRequest";
	    hr = CertServerSubmitRequest(
				    dwFlags | g_dwCRLIn,
				    pbReq,
				    cbReq,
				    pwszAttributes,
				    pwszServer,
				    pwszAuthority,
				    &pcsEnroll);
	    _JumpIfError(hr, error, "CertServerSubmitRequest");
	}
	else
	{
	    pszMethod = "CertServerRetrievePending";
	    hr = CertServerRetrievePending(
				    RequestId,
				    pwszSerialNumber,
				    pwszServer,
				    pwszAuthority,
				    &pcsEnroll);
	    _JumpIfError(hr, error, "CertServerRetrievePending");
	}
	CSASSERT(NULL != pcsEnroll);
	pwszMessage = pcsEnroll->pwszDispositionMessage;
    }
    else
    {
	ZeroMemory(&csEnroll, sizeof(csEnroll));
    
	hr = Request_Init(g_fIDispatch, &diRequest);
	if (S_OK != hr)
	{
	    _PrintError(hr, "Request_Init");
	    if (E_ACCESSDENIED == hr)	// try for a clearer error message
	    {
		hr = CO_E_REMOTE_COMMUNICATION_FAILURE;
	    }
	    _JumpError(hr, error, "Request_Init");
	}
	fMustRelease = TRUE;

	if (NULL != pwszfnReq)
	{
	    assert(NULL != pbReq && 0 != cbReq);

	    // We could always pass the binary ASN.1 encoded request, since
	    // we've already decoded it above, but in the interest of fully
	    // exercising the ICertRequest interface, we choose to submit the
	    // request in its original form.

	    if (CR_IN_BINARY == (CR_IN_ENCODEMASK & dwFlags))
	    {
		// Convert the binary ASN.1 blob into a BSTR blob.

		if (!ConvertWszToBstr(&strRequest, (WCHAR const *) pbReq, cbReq))
		{
		    if (S_OK == myLoadRCString(
					g_hInstance,
					IDS_ERROR_STRCONVERSION,
					&pwszMsg))
		    {
			CSASSERT(NULL != pwszMsg);
			wprintf(pwszMsg);
			wprintf(g_wszNewLine);
		    }
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
	    }
	    else // !CR_IN_BINARY
	    {
		// Since ICertRequest::Submit can handle any encoding type,
		// re-read the ansi base64 request from the file without
		// decoding it to binary, then convert the ansi base64 text
		// into a Unicode base64 text BSTR.
		// Free the request's binary image first.

		LocalFree(pbReq);
		pbReq = NULL;

		hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BINARY);
		if (S_OK != hr)
		{
		    if (S_OK == myLoadRCString(
					g_hInstance,
					IDS_FORMATSTR_DECODE_ERR,
					&pwszMsg))
		    {
			CSASSERT(NULL != pwszMsg);
			wprintf(pwszMsg, myHResultToString(awchr, hr));
			wprintf(g_wszNewLine);
		    }
		    goto error;
		}
		if (!ConvertSzToBstr(&strRequest, (CHAR const *) pbReq, cbReq))
		{
		    if (S_OK == myLoadRCString(
					g_hInstance,
					IDS_ERROR_STRCONVERSION,
					&pwszMsg))
		    {
			CSASSERT(NULL != pwszMsg);
			wprintf(pwszMsg);
		    }
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertSzToBstr");
		}
	    }
	    pszMethod = "ICertRequest::Submit";
	    if (g_fRPC)
	    {
		pszMethod = "ICertRequest::Submit+RPC";
		dwFlags |= CR_IN_RPC;
	    }
	    if (g_fAny)
	    {
		dwFlags = CR_IN_ENCODEANY | 
			  CR_IN_FORMATANY |
			  (~(CR_IN_ENCODEMASK | CR_IN_FORMATMASK) & dwFlags);
	    }
	    hr = Request_Submit(
			    &diRequest,
			    dwFlags | g_dwCRLIn,
			    strRequest,
			    SysStringByteLen(strRequest),
			    pwszAttributes,
			    pwszConfig,
			    (LONG *) &csEnroll.Disposition);
	}
	else
	{
	    if (!fV1)
	    {
		pszMethod = "ICertRequest2::GetIssuedCertificate";
		hr = Request2_GetIssuedCertificate(
					&diRequest,
					pwszConfig,
					RequestId,
					pwszSerialNumber,
					(LONG *) &csEnroll.Disposition);
		if (E_NOTIMPL == hr)
		{
		    fV1 = TRUE;
		}
	    }
	    if (fV1)
	    {
		if (NULL != pwszSerialNumber)
		{
		    CSASSERT(0 == RequestId);
		    pwszConfigPlusSerial = (WCHAR *) LocalAlloc(
						LMEM_FIXED,
						(wcslen(pwszConfig) +
						    1 +
						    wcslen(pwszSerialNumber) +
						    1) * sizeof(WCHAR));
		    if (NULL == pwszConfigPlusSerial)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }
		    wcscpy(pwszConfigPlusSerial, pwszConfig);
		    wcscat(pwszConfigPlusSerial, L"\\");
		    wcscat(pwszConfigPlusSerial, pwszSerialNumber);
		    pwszConfig = pwszConfigPlusSerial;
		}
		pszMethod = "ICertRequest::RetrievePending";
		hr = Request_RetrievePending(
					&diRequest,
					RequestId,
					pwszConfig,
					(LONG *) &csEnroll.Disposition);
	    }
	}

	hr2 = Request_GetLastStatus(&diRequest, &csEnroll.hrLastStatus);
	if (S_OK != hr2)
	{
	    _PrintError(hr2, "Request_GetLastStatus");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	    _JumpError(hr, error, "Request_GetLastStatus");
	}
	
	if (S_OK != hr)
	{
	    _PrintError(hr, pszMethod);
	    if (E_ACCESSDENIED == hr)	// try for a clearer error message
	    {
		hr = CO_E_REMOTE_COMMUNICATION_FAILURE;
	    }
	    _JumpError(hr, error, pszMethod);
	}

	if (fMustRelease && !fV1)
	{
	    if (g_fVerbose)
	    {
		DumpFullResponseProperties(&diRequest);
	    }
	    if (NULL != pwszfnFullResponse)
	    {
		hr = SaveFullResponse(
				hWndOwner,
				&diRequest,
				pwszfnFullResponse);
		_JumpIfError(hr, error, "SaveFullResponse");
	    }
	}
	
	hr = Request_GetDispositionMessage(&diRequest, &strMessage);
	_JumpIfError(hr, error, "Request_GetDispositionMessage");

	hr = Request_GetRequestId(&diRequest, (LONG *) &csEnroll.RequestId);
	_JumpIfError(hr, error, "Request_GetRequestId");

	pcsEnroll = &csEnroll;
	pwszMessage = strMessage;
    }

    CSASSERT(NULL != pcsEnroll);
    if (NULL == pwszMessage)
    {
	pwszMessage = L"";
    }
    if (0 != pcsEnroll->RequestId)
    {
        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_REQUESTID,
			    &pwszMsg))
        {
            CSASSERT(NULL != pwszMsg);
            wprintf(pwszMsg, pcsEnroll->RequestId);
            wprintf(g_wszNewLine);
	    LocalFree(pwszMsg);
	    pwszMsg = NULL;
        }
    }
    
    if (CR_DISP_UNDER_SUBMISSION == pcsEnroll->Disposition)
    {
        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_CERTPENDING,
			    &pwszMsg))
        {
            CSASSERT(NULL != pwszMsg);
            wprintf(
                pwszMsg,
	        pwszMessage,
                pcsEnroll->hrLastStatus);
            wprintf(g_wszNewLine);
        }
    }
    else if (CR_DISP_ISSUED == pcsEnroll->Disposition ||
	     CR_DISP_REVOKED == pcsEnroll->Disposition)
    {
        pwszDispMsg = wszDisposition(pcsEnroll->Disposition);

	DBGPRINT((
	    DBG_SS_CERTREQ, 
            "%hs(%ws) --> %ws\n",
	    pszMethod,
            NULL != pwszDispMsg ? pwszDispMsg : L"",
            pwszMessage));

        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_CERTRETRIEVED,
			    &pwszMsg))
        {
            wprintf(
                pwszMsg,
                NULL != pwszDispMsg ? pwszDispMsg : L"",
	        pwszMessage);
            wprintf(g_wszNewLine);
        }
        
        hr = WriteCertificateOrRequest(
			    hWndOwner,
			    &diRequest,
			    pcsEnroll->pbCert,
			    pcsEnroll->cbCert,
			    g_dwOutFormat,
			    pwszfnCert);
        _JumpIfError(hr, error, "WriteCertificateOrRequest");
        
        if (NULL != pwszfnCertChain)
        {
            hr = WriteCertificateOrRequest(
			    hWndOwner,
			    &diRequest,
			    pcsEnroll->pbCertChain,
			    pcsEnroll->cbCertChain,
			    CR_OUT_CHAIN | g_dwCRLOut | g_dwOutFormat,
			    pwszfnCertChain);
            _JumpIfError(hr, error, "WriteCertificateOrRequest(chain)");
        }
    }
    else
    {
	WCHAR const *pwszError = NULL;
	
	if (S_OK != pcsEnroll->hrLastStatus)
	{
	    pwszError = myGetErrorMessageText(pcsEnroll->hrLastStatus, TRUE);
	}
	SetErrorString(pwszMessage);

        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_CERTNOTISSUED,
			    &pwszMsg))
        {
            pwszDispMsg = wszDisposition(pcsEnroll->Disposition);

            wprintf(
                pwszMsg,
                NULL != pwszDispMsg ? pwszDispMsg : L"",
	        pwszMessage);
	    if (NULL != pwszError && NULL == wcsstr(pwszMessage, pwszError))
	    {
                wprintf(L" %ws", pwszError);
	    }
            wprintf(g_wszNewLine);
        }
	if (NULL != pwszError)
	{
	    LocalFree(const_cast<WCHAR *>(pwszError));
	}

	hr = pcsEnroll->hrLastStatus;
        _PrintIfError(hr, "Denied(LastStatus)");
        goto error;
    }

error:
    if (NULL != pwszMsg)
    {
	LocalFree(pwszMsg);
    }
    if (NULL != pwszDispMsg)
    {
	LocalFree(pwszDispMsg);
    }
    if (NULL != pwszConfigPlusSerial)
    {
	LocalFree(pwszConfigPlusSerial);
    }
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszAuthority)
    {
	LocalFree(pwszAuthority);
    }
    if (NULL != pcsEnroll && &csEnroll != pcsEnroll)
    {
	CertServerFreeMemory(pcsEnroll);
    }
    if (NULL != strMessage)
    {
    	SysFreeString(strMessage);
    }
    if (fMustRelease)
    {
    	Request_Release(&diRequest);
    }
    if (NULL != strRequest)
    {
    	SysFreeString(strRequest);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    return(hr);
}


HRESULT
crGetConfig(
    IN OUT BSTR *pstrConfig)
{
    HRESULT hr;
    WCHAR awchr[cwcHRESULTSTRING];
    
    hr = ConfigGetConfig(g_fIDispatch, g_dwUIFlag, pstrConfig);
    if (S_OK != hr)
    {
	WCHAR *pwszMsg = NULL;

	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
	    g_idError = IDS_NOMORE_CAS;
	}
	if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_ERRCONFIG,
			    &pwszMsg))
	{
	    CSASSERT(NULL != pwszMsg);
	    wprintf(
		pwszMsg,
		myHResultToString(awchr, hr));
	    wprintf(g_wszNewLine);
	    LocalFree(pwszMsg);
	}
	goto error;
    }
    hr = S_OK;

error:
    return(hr);
}

HRESULT
SubmitRequest(
    IN HWND hWndOwner,
    IN LONG RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnReq,
    OPTIONAL IN WCHAR const *pwszfnCert,
    OPTIONAL IN WCHAR const *pwszfnCertChain,
    OPTIONAL IN WCHAR const *pwszfnFullResponse)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    WCHAR *pwszConfig;
    BSTR strConfig = NULL;
    
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    pwszConfig = g_pwszConfig;
    if (NULL == pwszConfig)
    {
	hr = crGetConfig(&strConfig);
        _JumpIfError(hr, error, "crGetConfig");

	pwszConfig = strConfig;
    }

    // If submitting a new request:

    hr = CallServerAndStoreCert(
			hWndOwner,
			pwszConfig,
			RequestId,
			pwszSerialNumber,
			pwszAttributes,
			pwszfnReq,
			pwszfnCert,
			pwszfnCertChain,
			pwszfnFullResponse);
    _JumpIfError(hr, error, "CallServerAndStoreCert");
    
error:
    if (NULL != strConfig)
    {
    	SysFreeString(strConfig);
    }
    if (fCoInit)
    {
    	CoUninitialize();
    }
    return(hr);
}


FNMYINFGETEXTENSION *g_apfnGetExtension[] = {
    myInfGetPolicyConstraintsExtension,
    myInfGetPolicyMappingExtension,
    myInfGetPolicyStatementExtension,
    myInfGetApplicationPolicyConstraintsExtension,
    myInfGetApplicationPolicyMappingExtension,
    myInfGetApplicationPolicyStatementExtension,
    myInfGetNameConstraintsExtension,
    myInfGetEnhancedKeyUsageExtension,
    myInfGetBasicConstraints2CAExtension,
    myInfGetCrossCertDistributionPointsExtension,
};
#define CINFEXT	ARRAYSIZE(g_apfnGetExtension)


HRESULT
DumpRequestAttributeBlobs(
    IN DWORD cAttribute,
    IN CRYPT_ATTR_BLOB const *paAttribute)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pNamePair = NULL;
    DWORD cb;
    
    if (g_fVerbose)
    {
	for (i = 0; i < cAttribute; i++)
	{
	    if (NULL != paAttribute[i].pbData)
	    {
		if (NULL != pNamePair)
		{
		    LocalFree(pNamePair);
		    pNamePair = NULL;
		}
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				//X509_ENROLLMENT_NAME_VALUE_PAIR,
				szOID_ENROLLMENT_NAME_VALUE_PAIR,
				paAttribute[i].pbData,
				paAttribute[i].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNamePair,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		wprintf(
		    L"%u: %ws = %ws\n",
		    i,
		    pNamePair->pwszName,
		    pNamePair->pwszValue);
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pNamePair)
    {
	LocalFree(pNamePair);
    }
    return(hr);
}


VOID
FreeExtensions(
    IN BOOL fFreeObjIds,
    IN DWORD cExt,
    IN OUT CERT_EXTENSION *rgExt)
{
    IN DWORD i;
    
    if (NULL != rgExt)
    {
	for (i = 0; i < cExt; i++)
	{
	    if (fFreeObjIds && NULL != rgExt[i].pszObjId)
	    {
		LocalFree(rgExt[i].pszObjId);
	    }
	    if (NULL != rgExt[i].Value.pbData)
	    {
		LocalFree(rgExt[i].Value.pbData);
	    }
	}
	LocalFree(rgExt);
    }
}


VOID
FreeAttributes(
    IN DWORD cAttributes,
    IN OUT CRYPT_ATTRIBUTES *rgAttributes)
{
    DWORD i;
    DWORD j;
    
    if (NULL != rgAttributes)
    {
	for (i = 0; i < cAttributes; i++)
	{
	    CRYPT_ATTRIBUTE *pAttribute = rgAttributes[i].rgAttr;

	    if (NULL != pAttribute)
	    {
		if (NULL != pAttribute->rgValue)
		{
		    for (j = 0; j < pAttribute->cValue; j++)
		    {
			CRYPT_ATTR_BLOB *pValue = &pAttribute->rgValue[j];

			if (NULL != pValue->pbData)
			{
			    LocalFree(pValue->pbData);
			}
		    }
		    LocalFree(pAttribute->rgValue);
		}
		LocalFree(pAttribute);
	    }
	}
	LocalFree(rgAttributes);
    }
}


HRESULT
ParseInfFile(
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL OUT INFVALUES **prgInfValues,
    OPTIONAL OUT DWORD *pcInfValues,
    OUT CRYPT_ATTR_BLOB **ppaAttribute,
    OUT DWORD *pcAttribute,
    OUT CERT_EXTENSION **ppExt,
    OUT DWORD *pcExt,
    OUT WCHAR **ppwszTemplateNameInf)
{
    HRESULT hr;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    DWORD i;
    INFVALUES *rgInfValues = NULL;
    DWORD cInfValues;
    DWORD cExt = 0;
    DWORD cAttribute = 0;
    CRYPT_ATTR_BLOB *paAttribute = NULL;
    CERT_EXTENSION aext[CINFEXT];
    FNMYINFGETEXTENSION **ppfnGetExtension;
    CERT_EXTENSION *rgExt = NULL;

    if (NULL != prgInfValues)
    {
	*prgInfValues = NULL;
    }
    if (NULL != pcInfValues)
    {
	*pcInfValues = 0;
    }
    *ppaAttribute = NULL;
    *pcAttribute = 0;
    *ppExt = NULL;
    *pcExt = 0;
    *ppwszTemplateNameInf = NULL;

    ZeroMemory(&aext, sizeof(aext));

    hr = myInfOpenFile(pwszfnPolicy, &hInf, &ErrorLine);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "myInfOpenFile");
    }

    if (NULL != prgInfValues && NULL != pcInfValues)
    {
	hr = myInfGetSectionValues(
			hInf,
			wszINFSECTION_NEWREQUEST,
			&cInfValues,
			&rgInfValues);
	if (S_OK != hr)
	{
	    SetErrorString(pwszfnPolicy);
	    _JumpError(hr, error, "myInfGetSectionValues");
	}
    }
    for (ppfnGetExtension = g_apfnGetExtension;
	 ppfnGetExtension < &g_apfnGetExtension[CINFEXT];
	 ppfnGetExtension++)
    {
	hr = (**ppfnGetExtension)(hInf, &aext[cExt]);
	CSASSERT((NULL == aext[cExt].Value.pbData) ^ (S_OK == hr));
	if (S_OK != hr)
	{
	    char achIndex[64];

	    sprintf(
		achIndex,
		"*ppfnGetExtension[%u]",
		SAFE_SUBTRACT_POINTERS(ppfnGetExtension, g_apfnGetExtension));
	
	    if (S_FALSE == hr || (HRESULT) ERROR_LINE_NOT_FOUND == hr)
	    {
		_PrintError2(hr, achIndex, hr);
		continue;
	    }
	    _JumpIfError(hr, error, achIndex);
	}
	cExt++;
    }

    hr = myInfGetRequestAttributes(
			hInf,
			&cAttribute,
			&paAttribute,
			ppwszTemplateNameInf);
    _PrintIfError(hr, "myInfGetRequestAttributes");

    DumpRequestAttributeBlobs(cAttribute, paAttribute);

    if (0 != cExt)
    {
	rgExt = (CERT_EXTENSION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cExt * sizeof(**ppExt));
	if (NULL == rgExt)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(&rgExt[0], &aext[0], cExt * sizeof(rgExt[0]));
	for (i = 0; i < cExt; i++)
	{
	    rgExt[i].pszObjId = NULL;
	}
	for (i = 0; i < cExt; i++)
	{
	    hr = myDupStringA(aext[i].pszObjId, &rgExt[i].pszObjId);
	    _JumpIfError(hr, error, "myDupStringA");

	    if (g_fVerbose)
	    {
		wprintf(
		    L"%u: %hs(%ws) %ws cb=%x pb=%x\n",
		    i,
		    rgExt[i].pszObjId,
		    myGetOIDNameA(rgExt[i].pszObjId),
		    rgExt[i].fCritical? L"critical" : L"non-critical",
		    rgExt[i].Value.cbData,
		    rgExt[i].Value.pbData);
	    }
	}
	*pcExt = cExt;
	*ppExt = rgExt;
	rgExt = NULL;
    }
    if (NULL != prgInfValues && NULL != pcInfValues)
    {
	*prgInfValues = rgInfValues;
	rgInfValues = NULL;
	*pcInfValues = cInfValues;
    }
    *ppaAttribute = paAttribute;
    *pcAttribute = cAttribute;
    paAttribute = NULL;
    hr = S_OK;

error:
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    if (S_OK != hr)
    {
	for (i = 0; i < ARRAYSIZE(aext); i++)
	{
	    if (NULL != aext[i].Value.pbData)
	    {
		LocalFree(aext[i].Value.pbData);
	    }
	}
	if (NULL != *ppwszTemplateNameInf)
	{
	    LocalFree(*ppwszTemplateNameInf);
	    *ppwszTemplateNameInf = NULL;
	}
	if (NULL != rgExt)
	{
	    FreeExtensions(TRUE, cExt, rgExt);
	}
    }
    if (NULL != paAttribute)
    {
	myInfFreeRequestAttributes(cAttribute, paAttribute);
    }
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    return(hr);
}


HRESULT
DeleteMsgCerts(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    BYTE *pbCert = NULL;

    CSASSERT(NULL == pCert);
    while (TRUE)
    {
	BOOL fFirst = FALSE;
	DWORD cCert;
	DWORD cb;
	DWORD i;
	
	cb = sizeof(cCert);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_CERT_COUNT_PARAM,
			0,
			&cCert,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetParam(Cert count)");
	}
	for (i = 0; i < cCert; i++)
	{
	    CSASSERT(NULL == pbCert);
	    hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_CERT_PARAM,
			    i,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pbCert,
			    &cb);
	    _JumpIfError(hr, error, "myCryptMsgGetParam");

	    CSASSERT(NULL == pCert);
	    pCert = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbCert,
					cb);
	    if (NULL == pCert)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertCreateCertificateContext");
	    }

	    hr = myIsFirstSigner(&pCert->pCertInfo->Subject, &fFirst);
	    _JumpIfError(hr, error, "myIsFirstSigner");

	    LocalFree(pbCert);
	    pbCert = NULL;
	    
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;

	    if (!fFirst)
	    {
		if (!CryptMsgControl(
				hMsg,
				0,			// dwFlags
				CMSG_CTRL_DEL_CERT,
				&i))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgControl(delCert)");
		}
		break;
	    }
	}
	if (i == cCert)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
DeleteMsgCRLs(
    IN HCRYPTMSG hMsg)
{
    HRESULT hr;

    while (TRUE)
    {
	DWORD cCRL;
	DWORD cb;
	DWORD i;

	cb = sizeof(cCRL);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_CRL_COUNT_PARAM,
			0,
			&cCRL,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetParam(CRL count)");
	}
	for (i = 0; i < cCRL; i++)
	{
	    if (!CryptMsgControl(
			    hMsg,
			    0,			// dwFlags
			    CMSG_CTRL_DEL_CRL,
			    &i))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgControl(delCRL)");
	    }
	    break;
	}
	if (i == cCRL)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
AddMsgCert(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore,
    IN CERT_CONTEXT const *pCertAdd)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;

    while (TRUE)
    {
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	if (pCertAdd->cbCertEncoded == pCert->cbCertEncoded &&
	    0 == memcmp(
		    pCertAdd->pbCertEncoded,
		    pCert->pbCertEncoded,
		    pCert->cbCertEncoded))
	{
	    break;
	}
    }
    if (NULL == pCert)
    {
	CERT_BLOB Blob;

	Blob.pbData = pCertAdd->pbCertEncoded;
	Blob.cbData = pCertAdd->cbCertEncoded;
	
	if (!CryptMsgControl(
			hMsg,
			0,			// dwFlags
			CMSG_CTRL_ADD_CERT,
			&Blob))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(addCert)");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
AddMsgCRL(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore,
    IN CRL_CONTEXT const *pCRLAdd)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRL = NULL;

    while (TRUE)
    {
	pCRL = CertEnumCRLsInStore(hStore, pCRL);
	if (NULL == pCRL)
	{
	    break;
	}
	if (pCRLAdd->cbCrlEncoded == pCRL->cbCrlEncoded &&
	    0 == memcmp(
		    pCRLAdd->pbCrlEncoded,
		    pCRL->pbCrlEncoded,
		    pCRL->cbCrlEncoded))
	{
	    break;
	}
    }
    if (NULL == pCRL)
    {
	CERT_BLOB Blob;

	Blob.pbData = pCRLAdd->pbCrlEncoded;
	Blob.cbData = pCRLAdd->cbCrlEncoded;
	
	if (!CryptMsgControl(
			hMsg,
			0,			// dwFlags
			CMSG_CTRL_ADD_CRL,
			&Blob))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(addCRL)");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    return(hr);
}


HRESULT
AddMsgCertsAndCRLs(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore,
    IN CERT_CHAIN_CONTEXT const *pChainContext,
    IN BOOL fIncludeCRLs)
{
    HRESULT hr;
    DWORD cElement;
    CERT_CHAIN_ELEMENT **ppElement;
    DWORD i;

    CSASSERT(NULL != pChainContext);
    if (NULL == pChainContext ||
	0 == pChainContext->cChain ||
	0 == pChainContext->rgpChain[0]->cElement)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "no chain");
    }
    cElement = pChainContext->rgpChain[0]->cElement;
    ppElement = pChainContext->rgpChain[0]->rgpElement;

    for (i = 0; i < cElement; ppElement++, i++)
    {
	hr = AddMsgCert(hMsg, hStore, (*ppElement)->pCertContext);
	_JumpIfError(hr, error, "AddMsgCert");

	if (fIncludeCRLs)
	{
	    CERT_REVOCATION_INFO *pRevocationInfo;
	    
	    pRevocationInfo = (*ppElement)->pRevocationInfo;

	    if (NULL != pRevocationInfo &&
		CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		    pRevocationInfo->cbSize &&
		NULL != pRevocationInfo->pCrlInfo)
	    {
		CERT_REVOCATION_CRL_INFO *pCrlInfo;

		pCrlInfo = pRevocationInfo->pCrlInfo;
		if (NULL != pCrlInfo)
		{
		    if (NULL != pCrlInfo->pBaseCrlContext)
		    {
			hr = AddMsgCRL(
				    hMsg,
				    hStore,
				    pCrlInfo->pBaseCrlContext);
			_JumpIfError(hr, error, "AddMsgCRL");
		    }
		    if (NULL != pCrlInfo->pDeltaCrlContext)
		    {
			hr = AddMsgCRL(
				    hMsg,
				    hStore,
				    pCrlInfo->pDeltaCrlContext);
			_JumpIfError(hr, error, "AddMsgCRL");
		    }
		}
	    }
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
AddOrDeleteMsgCertsAndCRLs(
    IN BYTE const *pbPKCS7,
    IN DWORD cbPKCS7,
    IN HCRYPTMSG hMsg,
    IN BOOL fDelete,	// else add Certs and CRLs
    OPTIONAL IN CERT_CHAIN_CONTEXT const *pChainContext,
    IN BOOL fIncludeCRLs)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobPKCS7;
    HCERTSTORE hStore = NULL;
    DWORD i;

    blobPKCS7.pbData = const_cast<BYTE *>(pbPKCS7);
    blobPKCS7.cbData = cbPKCS7;

    hStore = CertOpenStore(
			CERT_STORE_PROV_PKCS7,
			PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			NULL,			// hCryptProv
			0,			// dwFlags
			&blobPKCS7);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    if (fDelete)
    {
	CSASSERT(NULL == pChainContext);

	hr = DeleteMsgCerts(hMsg, hStore);
	_JumpIfError(hr, error, "DeleteMsgCerts");

	hr = DeleteMsgCRLs(hMsg);
	_JumpIfError(hr, error, "DeleteMsgCRLs");
    }
    else
    {
	CSASSERT(NULL != pChainContext);

	hr = AddMsgCertsAndCRLs(hMsg, hStore, pChainContext, fIncludeCRLs);
	_JumpIfError(hr, error, "AddMsgCertsAndCRLs");
    }
    hr = S_OK;

error:
    if (NULL != hStore)
    {
        CertCloseStore(hStore, 0);
    }
    return(hr);
}


HRESULT
SignCMCContent(
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    IN char const *pszInnerContentObjId,
    IN BYTE const *pbPKCS7Old,
    IN DWORD cbPKCS7Old,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbPKCS7New,
    OUT DWORD *pcbPKCS7New)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    BOOL fCallerFreeProv;
    DWORD cb;
    HCRYPTMSG hMsg = NULL;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CRYPT_ATTRIBUTE AttributeRequestClient;
    CRYPT_ATTR_BLOB BlobRequestClient;
    CERT_BLOB SignerCertBlob;
    DWORD cSigner;
    DWORD dwContentParamType;
    DWORD i;
    CERT_CONTEXT const *pCert = NULL;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    DWORD iElement;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    DWORD cFirstSigner;
    BOOL fFirst;
    CERT_REQUEST_INFO *pRequest = NULL;

    BlobRequestClient.pbData = NULL;

    // decode existing PKCS 7 wrapper, and add or delete signatures

    hMsg = CryptMsgOpenToDecode(
		    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		    0,					// dwFlags
		    0,					// dwMsgType
		    //CMSG_SIGNED,
		    NULL,				// hCryptProv
		    NULL,				// pRecipientInfo
		    NULL);				// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    // Update the message with the old PKCS 7 signed message

    if (!CryptMsgUpdate(hMsg, pbPKCS7Old, cbPKCS7Old, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    cb = sizeof(cSigner);
    if (!CryptMsgGetParam(
		    hMsg,
		    CMSG_SIGNER_COUNT_PARAM,
		    0,
		    &cSigner,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgGetParam(signer count)");
    }

    cFirstSigner = 0;
    if (NULL != pCertSigner)
    {
	CERT_CHAIN_PARA ChainParams;

	ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));
	SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);

	hr = myEncodeRequestClientAttributeFromClientId(
					    XECI_CERTREQ,
					    &BlobRequestClient.pbData,
					    &BlobRequestClient.cbData);
	_JumpIfError(hr, error, "myEncodeRequestClientAttributeFromClientId");

	AttributeRequestClient.pszObjId = szOID_REQUEST_CLIENT_INFO;
	AttributeRequestClient.cValue = 1;
	AttributeRequestClient.rgValue = &BlobRequestClient;

	// Search for and load the cryptographic provider and private key. 

	hr = myLoadPrivateKey(
			&pCertSigner->pCertInfo->SubjectPublicKeyInfo,
			CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
			&hProv,
			&dwKeySpec,
			&fCallerFreeProv);
	_JumpIfError(hr, error, "myLoadPrivateKey");

	// Get the cert chain

	ZeroMemory(&ChainParams, sizeof(ChainParams));
	ChainParams.cbSize = sizeof(ChainParams);
	ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	//ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
	//ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

	if (!CertGetCertificateChain(
				NULL,		// hChainEngine
				pCertSigner,	// pCertContext
				NULL,		// pTime
				NULL,		// hAdditionalStore
				&ChainParams,	// pChainPara
				CERT_CHAIN_REVOCATION_CHECK_END_CERT |
				    CERT_CHAIN_REVOCATION_CHECK_CHAIN,
				NULL,		// pvReserved
				&pChainContext))	// ppChainContext
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateChain");
	}

	// Initialize the CMSG_SIGNER_ENCODE_INFO structure.
	// Note: handles only a single signer.

	SignerCertBlob.cbData = pCertSigner->cbCertEncoded;
	SignerCertBlob.pbData = pCertSigner->pbCertEncoded;
	SignerEncodeInfo.pCertInfo = pCertSigner->pCertInfo;

	SignerEncodeInfo.hCryptProv = hProv;
	SignerEncodeInfo.dwKeySpec = dwKeySpec;
	SignerEncodeInfo.HashAlgorithm.pszObjId = const_cast<CHAR *>(g_pszObjIdHash);
	//SignerEncodeInfo.pvHashAuxInfo = NULL;
	SignerEncodeInfo.cAuthAttr = 1;
	SignerEncodeInfo.rgAuthAttr = &AttributeRequestClient;

	// fail if any existing signing cert matches the new signing cert.
	
	for (i = 0; i < cSigner; i++)
	{
	    if (NULL != pcsi)
	    {
		LocalFree(pcsi);
		pcsi = NULL;
	    }
	    hr = myCryptMsgGetParam(
				hMsg,
				CMSG_CMS_SIGNER_INFO_PARAM,
				i,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcsi,
				&cb);
	    _JumpIfError(hr, error, "myCryptMsgGetParam");

	    if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
		(NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
		 0 == strcmp(
			szOID_PKIX_NO_SIGNATURE,
			pcsi->HashEncryptionAlgorithm.pszObjId)))
	    {
		CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

		ZeroMemory(&cvse, sizeof(cvse));
		cvse.cbSize = sizeof(cvse);
		cvse.dwSignerIndex = i;

		if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice)
		{
		    if (NULL == pRequest)
		    {
			hr = myGetInnerPKCS10(
					hMsg,
					pszInnerContentObjId,
					&pRequest);
			_JumpIfError(hr, error, "myGetInnerPKCS10");
		    }
		    cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
		    cvse.pvSigner = &pRequest->SubjectPublicKeyInfo;
		}
		else
		{
		    cvse.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
		}

		if (!CryptMsgControl(
				hMsg,
				0,		// dwFlags
				CMSG_CTRL_VERIFY_SIGNATURE_EX,
				&cvse))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgControl(VerifySig)");
		}
		cFirstSigner++;
	    }
	    else
	    {
		iElement = i;

		if (!CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,		// cSignerStore
				    NULL,		// rghSignerStore
				    CMSG_USE_SIGNER_INDEX_FLAG,
				    &pCert,
				    &iElement))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
		}
		if (pCertSigner->cbCertEncoded == pCert->cbCertEncoded &&
		    0 == memcmp(
			    pCertSigner->pbCertEncoded,
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded))
		{
		    hr = CRYPT_E_EXISTS;
		    _JumpError(hr, error, "duplicate signing cert");
		}
		hr = myIsFirstSigner(&pCert->pCertInfo->Subject, &fFirst);
		_JumpIfError(hr, error, "myIsFirstSigner");

		if (fFirst)
		{
		    cFirstSigner++;
		}
		CertFreeCertificateContext(pCert);
		pCert = NULL;
	    }
	}
	if (!CryptMsgControl(
			hMsg,
			0,			// dwFlags
			CMSG_CTRL_ADD_SIGNER,
			&SignerEncodeInfo))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(addSigner)");
	}
    }
    else
    {
	// delete all existing signers -- except the first signer

	while (TRUE)
	{
	    BOOL fDeleteSigner = FALSE;
	    
	    for (i = 0; i < cSigner; i++)
	    {
		if (NULL != pcsi)
		{
		    LocalFree(pcsi);
		    pcsi = NULL;
		}
		hr = myCryptMsgGetParam(
				    hMsg,
				    CMSG_CMS_SIGNER_INFO_PARAM,
				    i,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pcsi,
				    &cb);
		_JumpIfError(hr, error, "myCryptMsgGetParam");

		if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
		    (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
		     0 == strcmp(
			    szOID_PKIX_NO_SIGNATURE,
			    pcsi->HashEncryptionAlgorithm.pszObjId)))
		{
		    cFirstSigner++;
		    continue;
		}
		iElement = i;

		if (!CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,			// cSignerStore
				    NULL,		// rghSignerStore
				    CMSG_USE_SIGNER_INDEX_FLAG |
					CMSG_SIGNER_ONLY_FLAG,
				    &pCert,
				    &iElement))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
		}

		hr = myIsFirstSigner(&pCert->pCertInfo->Subject, &fFirst);
		_JumpIfError(hr, error, "myIsFirstSigner");

		CertFreeCertificateContext(pCert);
		pCert = NULL;

		if (!fFirst)
		{
		    fDeleteSigner = TRUE;
		    break;
		}
		cFirstSigner++;
	    }
	    if (!fDeleteSigner)
	    {
		break;
	    }
	    if (!CryptMsgControl(
			    hMsg,
			    0,			// dwFlags
			    CMSG_CTRL_DEL_SIGNER,
			    &iElement))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgControl(delSigner)");
	    }
	    cb = sizeof(cSigner);
	    if (!CryptMsgGetParam(
			    hMsg,
			    CMSG_SIGNER_COUNT_PARAM,
			    0,
			    &cSigner,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgGetParam(signer count)");
	    }
	}
    }
    if (1 != cFirstSigner)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cFirstSigner");
    }

    // Add or delete signing cert chain certs and CRLs in the message.

    hr = AddOrDeleteMsgCertsAndCRLs(
			    pbPKCS7Old,
			    cbPKCS7Old,
			    hMsg,
			    NULL == pChainContext,	// fDelete
			    pChainContext,
			    fIncludeCRLs);
    _JumpIfError(hr, error, "AddOrDeleteMsgCertsAndCRLs");

    // Get the signed message.  Force reencoding with the changed signatures.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_ENCODED_MESSAGE,
		    0,
                    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppbPKCS7New,
		    pcbPKCS7New);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    if (NULL != pRequest)
    {
	LocalFree(pRequest);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != BlobRequestClient.pbData)
    {
	LocalFree(BlobRequestClient.pbData);
    }
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
ConvertCertToPKCS10Request(
    IN OUT BYTE **ppbReq,
    IN OUT DWORD *pcbReq)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    BYTE *pbReqUnsigned = NULL;
    DWORD cbReqUnsigned;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    CERT_REQUEST_INFO Request;
    CRYPT_ATTR_BLOB ExtBlob;
    CRYPT_ATTR_BLOB VersionBlob;
    CERT_EXTENSIONS Extensions;
    CRYPT_ATTRIBUTE aAttrib[2];
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    BOOL fCallerFreeProv;
    CERT_EXTENSION *pExt;
    CERT_EXTENSION *pExtKeyId;
    CERT_EXTENSION ExtKeyId;
    CHAR *pszObjId = NULL;

    ZeroMemory(&ExtKeyId, sizeof(ExtKeyId));

    // Certificate extensions to strip out of the request:

    static char const * const apszObjIdFilter[] = {
	szOID_CERTSRV_CA_VERSION,
	szOID_AUTHORITY_INFO_ACCESS,
	szOID_CRL_DIST_POINTS,
	szOID_AUTHORITY_KEY_IDENTIFIER2,
	szOID_CERTSRV_PREVIOUS_CERT_HASH,
	szOID_ENROLL_CERTTYPE_EXTENSION,
	szOID_CERTIFICATE_TEMPLATE,
    };

    ExtBlob.pbData = NULL;
    VersionBlob.pbData = NULL;
    Extensions.rgExtension = NULL;

    pCert = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				*ppbReq,
				*pcbReq);
    if (NULL == pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    ZeroMemory(&Request, sizeof(Request));
    Request.dwVersion = CERT_REQUEST_V1;
    Request.Subject = pCert->pCertInfo->Subject;
    Request.SubjectPublicKeyInfo = pCert->pCertInfo->SubjectPublicKeyInfo;

    Extensions.cExtension = 0;
    Extensions.rgExtension = (CERT_EXTENSION *) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(Extensions.rgExtension[0]) *
					(1 + pCert->pCertInfo->cExtension));
    if (NULL == Extensions.rgExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pExtKeyId = NULL;
    if (0 < pCert->pCertInfo->cExtension)
    {
	DWORD i;
	DWORD j;

	pExt = pCert->pCertInfo->rgExtension;
	for (i = 0; i < pCert->pCertInfo->cExtension; i++)
	{
	    if (0 == strcmp(szOID_SUBJECT_KEY_IDENTIFIER, pExt->pszObjId))
	    {
		pExtKeyId = pExt;
	    }
	    for (j = 0; ; j++)
	    {
		if (j >= ARRAYSIZE(apszObjIdFilter))
		{
		    Extensions.rgExtension[Extensions.cExtension] =
			pCert->pCertInfo->rgExtension[i];
		    Extensions.cExtension++;
		    break;
		}
		if (0 == strcmp(apszObjIdFilter[j], pExt->pszObjId))
		{
		    break;		// skip this extension
		}
	    }
	    pExt++;
	}
    }
    if (NULL == pExtKeyId)
    {
	BYTE abHash[CBMAX_CRYPT_HASH_LEN];
	CRYPT_DATA_BLOB Blob;

	Blob.pbData = abHash;
	Blob.cbData = sizeof(abHash);
	if (!CryptHashPublicKeyInfo(
			    NULL,		// hCryptProv
			    CALG_SHA1,
			    0,		// dwFlags,
			    X509_ASN_ENCODING,
			    &Request.SubjectPublicKeyInfo,
			    Blob.pbData,
			    &Blob.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashPublicKeyInfo");
	}
	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &Blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &ExtKeyId.Value.pbData,
		    &ExtKeyId.Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	ExtKeyId.pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
	pExtKeyId = &Extensions.rgExtension[Extensions.cExtension];
	*pExtKeyId = ExtKeyId;
	Extensions.cExtension++;
    }

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_EXTENSIONS,
		&Extensions,
		0,
		CERTLIB_USE_LOCALALLOC,
		&ExtBlob.pbData,
		&ExtBlob.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    // get the OS Version

    hr = myBuildOSVersionAttribute(&VersionBlob.pbData, &VersionBlob.cbData);
    _JumpIfError(hr, error, "myBuildOSVersionAttribute");

    Request.cAttribute = 0;
    Request.rgAttribute = aAttrib;
    if (NULL != ExtBlob.pbData)
    {
	aAttrib[Request.cAttribute].pszObjId = szOID_RSA_certExtensions;
	aAttrib[Request.cAttribute].cValue = 1;
	aAttrib[Request.cAttribute].rgValue = &ExtBlob;
	Request.cAttribute++;
    }

    aAttrib[Request.cAttribute].pszObjId = szOID_OS_VERSION;
    aAttrib[Request.cAttribute].cValue = 1;
    aAttrib[Request.cAttribute].rgValue = &VersionBlob;
    Request.cAttribute++;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
                    X509_CERT_REQUEST_TO_BE_SIGNED,
		    &Request,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbReqUnsigned,
		    &cbReqUnsigned))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    // Search for and load the cryptographic provider and private key. 

    hr = myLoadPrivateKey(
		    &pCert->pCertInfo->SubjectPublicKeyInfo,
		    CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
		    &hProv,
		    &dwKeySpec,
		    &fCallerFreeProv);
    if (S_OK != hr)
    {
	_PrintError(hr, "myLoadPrivateKey");
	CSASSERT(NULL == hProv);

	// private key is unavailable -- sign the PKCS10 with a NULL signature.

	hr = myDupStringA(g_pszObjIdHash, &pszObjId);
	_JumpIfError(hr, error, "myDupStringA");
    }
    else
    {
	if (AT_SIGNATURE != dwKeySpec)
	{
	    hr = NTE_BAD_KEY_STATE;
	    DBGPRINT((DBG_SS_CERTREQ, "dwKeySpec = %u\n", dwKeySpec));
	    _JumpError(hr, error, "dwKeySpec");
	}

	// The private key is available -- use it to sign the PKCS10.

	hr = myGetSigningOID(hProv, NULL, 0, CALG_SHA1, &pszObjId);
	_JumpIfError(hr, error, "myGetSigningOID");
    }

    // Sign the request and encode the signed info.

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszObjId,
			pbReqUnsigned,
			cbReqUnsigned,
			CERTLIB_USE_LOCALALLOC,
			&pbReq,
			&cbReq);
    _JumpIfError(hr, error, "myEncodeSignedContent");

    LocalFree(*ppbReq);
    *ppbReq = pbReq;
    *pcbReq = cbReq;
    pbReq = NULL;
    hr = S_OK;

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != Extensions.rgExtension)
    {
        LocalFree(Extensions.rgExtension);
    }
    if (NULL != ExtKeyId.Value.pbData)
    {
        LocalFree(ExtKeyId.Value.pbData);
    }
    if (NULL != ExtBlob.pbData)
    {
        LocalFree(ExtBlob.pbData);
    }
    if (NULL != VersionBlob.pbData)
    {
        LocalFree(VersionBlob.pbData);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    if (NULL != pbReqUnsigned)
    {
	LocalFree(pbReqUnsigned);
    }
    return(hr);
}


HRESULT
GetPKCS10PrivateKey(
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv,
    OUT BYTE **ppbKeyId,
    OUT DWORD *pcbKeyId)
{
    HRESULT hr;
    CERT_REQUEST_INFO *pRequest = NULL;
    HCRYPTPROV hProv = NULL;
    CERT_EXTENSIONS *pExtensions = NULL;
    CRYPT_ATTRIBUTE *pAttr;
    BYTE *pbKeyId = NULL;
    DWORD cbKeyId;
    DWORD dwKeySpec;
    DWORD cb;
    DWORD i;

    *phProv = NULL;
    *pdwKeySpec = 0;
    *ppbKeyId = NULL;
    *pcbKeyId = 0;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
                    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbReq,
		    cbReq,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pRequest,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    // Search for and load the cryptographic provider and private key. 

    hr = myLoadPrivateKey(
		    &pRequest->SubjectPublicKeyInfo,
		    CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
		    &hProv,
		    &dwKeySpec,
		    pfCallerFreeProv);
    _JumpIfError(hr, error, "myLoadPrivateKey");

    if (AT_SIGNATURE != dwKeySpec)
    {
	hr = NTE_BAD_KEY_STATE;
	DBGPRINT((DBG_SS_CERTREQ, "dwKeySpec = %u\n", dwKeySpec));
	_JumpError(hr, error, "dwKeySpec");
    }

    // Fetch or construct the KeyId hash

    pAttr = pRequest->rgAttribute;
    for (i = 0; i < pRequest->cAttribute && NULL != pbKeyId; i++, pAttr++)
    {
	DWORD j;

	if (0 == strcmp(szOID_RSA_certExtensions, pAttr->pszObjId) ||
	    0 == strcmp(szOID_CERT_EXTENSIONS, pAttr->pszObjId))
	{
	    for (j = 0; j < pAttr->cValue; j++)
	    {
		DWORD k;
		CERT_EXTENSION *pExt;

		if (NULL != pExtensions)
		{
		    LocalFree(pExtensions);
		    pExtensions = NULL;
		}
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_EXTENSIONS,
				pAttr->rgValue[j].pbData,
				pAttr->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pExtensions,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}

		pExt = pExtensions->rgExtension;
		for (k = 0; k < pExtensions->cExtension; k++, pExt++)
		{
		    if (0 == strcmp(
				pExt->pszObjId,
				szOID_SUBJECT_KEY_IDENTIFIER))
		    {
			if (!myDecodeObject(
				    X509_ASN_ENCODING,
				    X509_OCTET_STRING,
				    pExt->Value.pbData,
				    pExt->Value.cbData,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pbKeyId,
				    &cbKeyId))
			{
			    hr = myHLastError();
			    _JumpError(hr, error, "myDecodeObject");
			}
			break;
		    }
		}
	    }
	}
    }
    if (NULL == pbKeyId)
    {
	BYTE abHash[CBMAX_CRYPT_HASH_LEN];

	cbKeyId = sizeof(abHash);
	if (!CryptHashPublicKeyInfo(
			    NULL,		// hCryptProv
			    CALG_SHA1,
			    0,		// dwFlags,
			    X509_ASN_ENCODING,
			    &pRequest->SubjectPublicKeyInfo,
			    abHash,
			    &cbKeyId))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashPublicKeyInfo");
	}
	pbKeyId = (BYTE *) LocalAlloc(LMEM_FIXED, cbKeyId);
	if (NULL == pbKeyId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pbKeyId, abHash, cbKeyId);
    }
    *phProv = hProv;
    hProv = NULL;
    *ppbKeyId = pbKeyId;
    pbKeyId = NULL;
    *pcbKeyId = cbKeyId;
    *pdwKeySpec = dwKeySpec;
    hr = S_OK;

error:
    if (NULL != hProv && *pfCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pExtensions)
    {
        LocalFree(pExtensions);
    }
    if (NULL != pbKeyId)
    {
        LocalFree(pbKeyId);
    }
    return(hr);
}


HRESULT
BuildNameValuePairs(
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN OUT DWORD *pcValue,
    OPTIONAL OUT CRYPT_ATTR_BLOB *pValue,
    OPTIONAL OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    DWORD cValue = 0;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    WCHAR *pwszTemplateName = NULL;

    if (NULL != ppwszTemplateName)
    {
	*ppwszTemplateName = NULL;
    }
    if (NULL == pwszAttributes)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }
    hr = myDupString(pwszAttributes, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszBuf = pwszDup;

    while (TRUE)
    {
	hr = myParseNextAttribute(&pwszBuf, FALSE, &pwszName, &pwszValue);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "myParseNextAttribute");

	DBGPRINT((DBG_SS_CERTREQI, "'%ws' = '%ws'\n", pwszName, pwszValue));
	if (NULL != pValue)
	{
	    CRYPT_ENROLLMENT_NAME_VALUE_PAIR NamePair;

	    CSASSERT(cValue < *pcValue);
	    NamePair.pwszName = const_cast<WCHAR *>(pwszName);
	    NamePair.pwszValue = const_cast<WCHAR *>(pwszValue);

	    if (NULL != ppwszTemplateName &&
		0 == lstrcmpi(wszPROPCERTTEMPLATE, pwszName))
	    {
		if (NULL != pwszTemplateName)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "Duplicate cert template");
		}
		hr = myDupString(pwszValue, &pwszTemplateName);
		_JumpIfError(hr, error, "myDupString");
	    }

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    //X509_ENROLLMENT_NAME_VALUE_PAIR,
			    szOID_ENROLLMENT_NAME_VALUE_PAIR,
			    &NamePair,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pValue[cValue].pbData,
			    &pValue[cValue].cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	}
	cValue++;
    }
    if (NULL != ppwszTemplateName)
    {
	*ppwszTemplateName = pwszTemplateName;
	pwszTemplateName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    *pcValue = cValue;
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
PickCertAndSignRequest(
    IN HWND hWndOwner,
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    IN BOOL fSkipSignerDeletion,
    OUT BYTE **ppbPKCS7Out,
    OUT DWORD *pcbPKCS7Out)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertSigner = NULL;

    if (NULL == g_pwszCertCN || 0 != lstrcmp(L"-", g_pwszCertCN))
    {
	if (!g_fQuiet || NULL != g_pwszCertCN)
	{
	    hr = myGetERACertificateFromPicker(
		    g_hInstance,
		    NULL,		// hwndParent
		    IDS_GETERACERT_TITLE,
		    IDS_GETERACERT_SUBTITLE,
		    (L'\0' == g_pwszCertCN || 0 == lstrcmp(L"*", g_pwszCertCN))?
			NULL : g_pwszCertCN,	// pwszCommonName
		    g_fQuiet,
		    &pCertSigner);
	    _JumpIfError(hr, error, "myGetERACertificateFromPicker");
	}

	// pCertSigner is NULL if the user cancelled out of the cert picker U/I.
	// NULL pCertSigner means delete existing signatures.

	if (NULL == pCertSigner)
	{
	    if (fSkipSignerDeletion)
	    {
		hr = S_FALSE;
		_JumpError2(hr, error, "no signer selected", S_FALSE);
	    }
	    if (g_fQuiet || NULL != g_pwszCertCN)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no matching signer CN");
	    }
	}
    }

    hr = SignCMCContent(
		    pCertSigner,
		    szOID_CT_PKI_DATA,
		    pbReq,
		    cbReq,
		    0 != (CR_OUT_CRLS & g_dwCRLOut),
		    ppbPKCS7Out,
		    pcbPKCS7Out);
    _JumpIfError(hr, error, "SignCMCContent");

error:
    if (NULL != pCertSigner)
    {
	CertFreeCertificateContext(pCertSigner);
    }
    return(hr);
}


HRESULT
SignQualifiedRequest(
    IN HWND hWndOwner,
    IN WCHAR const *pwszfnReq,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    BYTE *pbPKCS7Out = NULL;
    DWORD cbPKCS7Out;
    LONG dwFlags;
    BOOL fSigned;
    
    // Read the request from a file, convert it to binary, and return
    // dwFlags to indicate the orignal encoding and the detected format.

    hr = CheckRequestType(pwszfnReq, &pbReq, &cbReq, &dwFlags, &fSigned);
    _JumpIfError(hr, error, "CheckRequestType");

    if (CR_IN_CMC != (CR_IN_FORMATMASK & dwFlags))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	SetErrorString(pwszfnReq);
	_JumpError(hr, error, "not a CMC request");
    }

    hr = PickCertAndSignRequest(
			    hWndOwner,
			    pbReq,
			    cbReq,
			    FALSE,
			    &pbPKCS7Out,
			    &cbPKCS7Out);
    _JumpIfError(hr, error, "PickCertAndSignRequest");

    hr = WriteCertificateOrRequest(
			hWndOwner,
    			NULL,		// pdiRequest
			pbPKCS7Out,
			cbPKCS7Out,
			g_dwOutFormat,
			pwszfnOut);
    _JumpIfError(hr, error, "WriteCertificateOrRequest");

error:
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    if (NULL != pbPKCS7Out)
    {
	LocalFree(pbPKCS7Out);
    }
    return(hr);
}


HRESULT
ParseRequestInfo(
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL OUT INFVALUES **prgInfValues,
    OPTIONAL OUT DWORD *pcInfValues,
    OUT CRYPT_ATTRIBUTES **prgAttributes,
    OUT DWORD *pcAttributes,
    OUT CERT_EXTENSION **prgExt,
    OUT DWORD *pcExt)
{
    HRESULT hr;
    CERT_EXTENSION *rgExtT;
    CERT_EXTENSION *rgExt = NULL;
    DWORD cExt;
    CRYPT_ATTR_BLOB *argValue[2] = { NULL, NULL };
    DWORD acValue[2];
    DWORD i;
    DWORD j;
    CRYPT_ATTRIBUTES *rgAttributes = NULL;
    DWORD cAttributes = 0;
    WCHAR *pwszTemplateNameInf = NULL;
    WCHAR *pwszTemplateName = NULL;
    HCERTTYPE hCertType = NULL;
    CERT_EXTENSIONS *pExtensions = NULL;
    
    if (NULL != prgInfValues)
    {
	*prgInfValues = NULL;
    }
    if (NULL != pcInfValues)
    {
	*pcInfValues = 0;
    }
    *prgAttributes = NULL;
    *pcAttributes = 0;
    *prgExt = NULL;
    *pcExt = 0;

    hr = ParseInfFile(
		pwszfnPolicy,
		prgInfValues,
		pcInfValues,
		&argValue[0],
		&acValue[0],
		&rgExt,
		&cExt,
		&pwszTemplateNameInf);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "ParseInfFile");
    }
    if (0 != acValue[0])
    {
	cAttributes++;
    }

    // Count the command line request attributes
    
    hr = BuildNameValuePairs(pwszAttributes, &acValue[1], NULL, NULL);
    _JumpIfError(hr, error, "BuildNameValuePairs");

    if (0 != acValue[1])
    {
	cAttributes++;

	argValue[1] = (CRYPT_ATTR_BLOB *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					acValue[1] * sizeof(argValue[1][0]));
	if (NULL == argValue[1])
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = BuildNameValuePairs(
			pwszAttributes,
			&acValue[1],
			argValue[1],
			&pwszTemplateName);
	_JumpIfError(hr, error, "BuildNameValuePairs");
    }

    if (0 != cAttributes)
    {
	rgAttributes  = (CRYPT_ATTRIBUTES *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cAttributes * sizeof(rgAttributes[0]));
	if (NULL == rgAttributes)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = j = 0; i < cAttributes; i++, j++)
	{
	    CRYPT_ATTRIBUTE *rgAttr;

	    rgAttr = (CRYPT_ATTRIBUTE *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(rgAttributes[i].rgAttr[0]));
	    if (NULL == rgAttr)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    while (0 == acValue[j])
	    {
		j++;
	    }
	    rgAttributes[i].cAttr = 1;
	    rgAttributes[i].rgAttr = rgAttr;
	    
	    rgAttr[0].pszObjId = szOID_ENROLLMENT_NAME_VALUE_PAIR;
	    rgAttr[0].cValue = acValue[j];
	    rgAttr[0].rgValue = argValue[j];
	    argValue[j] = NULL;
	}
    }

    if (NULL != pwszTemplateName || NULL != pwszTemplateNameInf)
    {
	WCHAR const *pwsz;
	
	pwsz = pwszTemplateNameInf;
	if (NULL == pwsz)
	{
	    pwsz = pwszTemplateName;
	    CSASSERT(NULL != pwsz);
	}
	else if (NULL != pwszTemplateName &&
		 0 != lstrcmpi(pwszTemplateName, pwszTemplateNameInf))
	{
	    hr = CERTSRV_E_TEMPLATE_CONFLICT;
	    SetErrorString(wszPROPCERTTEMPLATE);
	    _JumpError(hr, error, "Template name conflict");
	}

	// Include the specified cert template's extensions

	hr = CAFindCertTypeByName(
		    pwsz,
		    NULL,
		    CT_FIND_LOCAL_SYSTEM |
			CT_ENUM_MACHINE_TYPES |
			CT_ENUM_USER_TYPES,
		    &hCertType);
	if (S_OK != hr)
	{
	    hr = CAFindCertTypeByName(
			pwsz,
			NULL,
			CT_FIND_LOCAL_SYSTEM |
			    CT_ENUM_MACHINE_TYPES |
			    CT_ENUM_USER_TYPES |
			    CT_FIND_BY_OID,
			&hCertType);
	    _PrintIfErrorStr(hr, "CAFindCertTypeByName", pwsz);
	}
	if (S_OK == hr)
	{
	    hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
	    _PrintIfError(hr, "CAGetCertTypeExtensions");
	}
	if (S_OK == hr && NULL != pExtensions && 0 != pExtensions->cExtension)
	{
	    CERT_EXTENSION *pExtSrc;
	    CERT_EXTENSION *pExtSrcEnd;
	    CERT_EXTENSION *pExtDst;

	    rgExtT = (CERT_EXTENSION *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			(pExtensions->cExtension + cExt) * sizeof(rgExtT[0]));
	    if (NULL == rgExtT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    if (NULL != rgExt)
	    {
		CopyMemory(&rgExtT[0], &rgExt[0], cExt * sizeof(rgExtT[0]));
		LocalFree(rgExt);
	    }
	    rgExt = rgExtT;

	    pExtSrc = pExtensions->rgExtension;
	    pExtSrcEnd = &pExtSrc[pExtensions->cExtension];
	    pExtDst = &rgExt[cExt];
	    for ( ; pExtSrc < pExtSrcEnd; pExtSrc++, pExtDst++)
	    {
		pExtDst->fCritical = pExtSrc->fCritical;
		pExtDst->Value.cbData = pExtSrc->Value.cbData;

		hr = myDupStringA(pExtSrc->pszObjId, &pExtDst->pszObjId);
		_JumpIfError(hr, error, "myDupStringA");

		pExtDst->Value.pbData = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pExtSrc->Value.cbData);
		if (NULL == pExtDst->Value.pbData)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		CopyMemory(
			pExtDst->Value.pbData,
			pExtSrc->Value.pbData,
			pExtSrc->Value.cbData);
	    }
	    cExt += pExtensions->cExtension;
	}
	else
	{
	    CHAR const *pszObjId;

	    // Grow extension array to make room for the cert type extension

	    rgExtT = (CERT_EXTENSION *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    (cExt + 1) * sizeof(rgExtT[0]));
	    if (NULL == rgExtT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    if (0 != cExt)
	    {
		CSASSERT(NULL != rgExt);
		CopyMemory(&rgExtT[1], rgExt, cExt * sizeof(rgExt[0]));
		LocalFree(rgExt);
	    }
	    rgExt = rgExtT;
	    cExt++;

	    hr = myBuildCertTypeExtension(pwsz, &rgExt[0]);
	    _JumpIfError(hr, error, "myBuildCertTypeExtension");

	    pszObjId = rgExt[0].pszObjId;
	    rgExt[0].pszObjId = NULL;

	    hr = myDupStringA(pszObjId, &rgExt[0].pszObjId);
	    _JumpIfError(hr, error, "myDupStringA");
	}
    }

    *prgAttributes = rgAttributes;
    rgAttributes = NULL;
    *pcAttributes = cAttributes;

    *prgExt = rgExt;
    rgExt = NULL;
    *pcExt = cExt;

    hr = S_OK;

error:
    if (S_OK != hr && NULL != prgInfValues)
    {
	myInfFreeSectionValues(*pcInfValues, *prgInfValues);
	*prgInfValues = NULL;
	*pcInfValues = 0;
    }
    if (NULL != rgAttributes)
    {
	FreeAttributes(cAttributes, rgAttributes);
    }
    for (i = 0; i < ARRAYSIZE(argValue); i++)
    {
	if (NULL != argValue[i])
	{
	    myInfFreeRequestAttributes(acValue[i], argValue[i]);
	}
    }
    if (NULL != rgExt)
    {
	FreeExtensions(TRUE, cExt, rgExt);
    }
    if (NULL != pwszTemplateNameInf)
    {
	LocalFree(pwszTemplateNameInf);
    }
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != hCertType)
    {
        if (NULL != pExtensions)
        {
            CAFreeCertTypeExtensions(hCertType, pExtensions);
        }
        CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
CreateQualifiedRequest(
    IN HWND hWndOwner,
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnReq,
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszfnPKCS10)
{
    HRESULT hr;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    BYTE *pbKeyId = NULL;
    DWORD cbKeyId = 0;
    BYTE *pbReqCMCFirstSigned = NULL;
    DWORD cbReqCMCFirstSigned;
    BYTE *pbReqCMCOut = NULL;
    DWORD cbReqCMCOut;
    LONG dwFlags;
    BOOL fNestedCMCRequest = FALSE;
    BOOL fSigned;
    CRYPT_ATTRIBUTES *rgAttributes = NULL;
    DWORD cAttributes;
    CERT_EXTENSION *rgExt = NULL;
    DWORD cExt;
    DWORD i;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec = 0;
    BOOL fCallerFreeProv;
    
    cAttributes = 0;

    // Read the request from a file, convert it to binary, and return
    // dwFlags to indicate the orignal encoding and the detected format.

    hr = CheckRequestType(pwszfnReq, &pbReq, &cbReq, &dwFlags, &fSigned);
    _JumpIfError(hr, error, "CheckRequestType");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    switch (CR_IN_FORMATMASK & dwFlags)
    {
	case CR_IN_CMC:
	    fNestedCMCRequest = TRUE;
	    break;

	case CR_IN_CERT:
	    hr = ConvertCertToPKCS10Request(&pbReq, &cbReq);
	    _JumpIfError(hr, error, "ConvertCertToPKCS10Request");

	    dwFlags = CR_IN_PKCS10 | (~CR_IN_FORMATMASK & dwFlags);
	    break;

	case CR_IN_PKCS10:
	    break;

	default:
	    _JumpError(hr, error, "not a CMC or PKCS10 request");
    }
    if (CR_IN_PKCS10 == (CR_IN_FORMATMASK & dwFlags))
    {
	if (NULL != pwszfnPKCS10)
	{
	    hr = crOverwriteFileAllowed(hWndOwner, pwszfnPKCS10);
	    _JumpIfError(hr, error, "crOverwriteFileAllowed");

	    hr = EncodeToFileW(
			pwszfnPKCS10,
			pbReq,
			cbReq,
			DECF_FORCEOVERWRITE | g_dwOutFormat);
	    if (S_OK != hr)
	    {
		SetErrorString(pwszfnPKCS10);
		_JumpErrorStr(hr, error, "EncodeToFileW", pwszfnPKCS10);
	    }
	}

	hr = GetPKCS10PrivateKey(
			pbReq,
			cbReq,
			&hProv,
			&dwKeySpec,
			&fCallerFreeProv,
			&pbKeyId,
			&cbKeyId);
	_PrintIfError(hr, "GetPKCS10PrivateKey");
    }

    hr = ParseRequestInfo(
		pwszAttributes,
		pwszfnPolicy,
		NULL,		// prgInfValues
		NULL,		// pcInfValues
		&rgAttributes,
		&cAttributes,
		&rgExt,
		&cExt);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "ParseRequestInfo");
    }

    hr = BuildCMCRequest(
		    XECI_CERTREQ,
		    fNestedCMCRequest,
		    pbReq,
		    cbReq,
		    rgExt,
		    cExt,
		    rgAttributes,
		    cAttributes,
		    NULL,		// rgAttributeUnauth
		    0,			// cAttributeUnauth
		    pbKeyId,
		    cbKeyId,
		    hProv,
		    dwKeySpec,
		    NULL == hProv? NULL : g_pszObjIdHash,
		    NULL,		// pCertSigner
		    NULL,		// hProvSigner
		    0,			// dwKeySpecSigner
		    NULL,		// pszObjIdHashSigner
		    &pbReqCMCFirstSigned,
		    &cbReqCMCFirstSigned);
    _JumpIfError(hr, error, "BuildCMCRequest");

    hr = PickCertAndSignRequest(
			    hWndOwner,
			    pbReqCMCFirstSigned,
			    cbReqCMCFirstSigned,
			    TRUE,
			    &pbReqCMCOut,
			    &cbReqCMCOut);
    if (S_OK != hr)
    {
	_PrintError2(hr, "PickCertAndSignRequest", S_FALSE);
	if (S_FALSE != hr)
	{
	    goto error;
	}

	// The user cancelled out of the cert picker U/I, so just save the
	// unsigned request.

	pbReqCMCOut = pbReqCMCFirstSigned;
	cbReqCMCOut = cbReqCMCFirstSigned;
    }

    hr = WriteCertificateOrRequest(
			hWndOwner,
    			NULL,		// pdiRequest
			pbReqCMCOut,
			cbReqCMCOut,
			g_dwOutFormat,
			pwszfnOut);
    _JumpIfError(hr, error, "WriteCertificateOrRequest");

error:
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != rgExt)
    {
	FreeExtensions(TRUE, cExt, rgExt);
    }
    if (NULL != rgAttributes)
    {
	FreeAttributes(cAttributes, rgAttributes);
    }
    if (NULL != pbReqCMCOut && pbReqCMCFirstSigned != pbReqCMCOut)
    {
	LocalFree(pbReqCMCOut);
    }
    if (NULL != pbReqCMCFirstSigned)
    {
	LocalFree(pbReqCMCFirstSigned);
    }
    if (NULL != pbKeyId)
    {
	LocalFree(pbKeyId);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    return(hr);
}


HRESULT
GetCAXchgCert(
    IN WCHAR const *pwszValue,
    OUT CERT_CONTEXT const **ppccXchg)
{
    HRESULT hr;
    BOOL fEnabled;
    BSTR strConfig = NULL;
    BSTR strCert = NULL;
    WCHAR const *pwszConfig;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;

    *ppccXchg = NULL;

    hr = myInfParseBooleanValue(pwszValue, &fEnabled);
    _JumpIfError(hr, error, "myInfParseBooleanValue");

    if (fEnabled)
    {
	pwszConfig = g_pwszConfig;
	if (NULL == pwszConfig)
	{
	    hr = crGetConfig(&strConfig);
	    _JumpIfError(hr, error, "crGetConfig");

	    pwszConfig = strConfig;
	}

	hr = Request_Init(g_fIDispatch, &diRequest);
	if (S_OK != hr)
	{
	    _PrintError(hr, "Request_Init");
	    if (E_ACCESSDENIED == hr)	// try for a clearer error message
	    {
		hr = CO_E_REMOTE_COMMUNICATION_FAILURE;
	    }
	    _JumpError(hr, error, "Request_Init");
	}
	fMustRelease = TRUE;

	hr = Request2_GetCAProperty(
			&diRequest,
			pwszConfig,
			CR_PROP_CAXCHGCERT,
			0,			// Index
			PROPTYPE_BINARY,
			CV_OUT_BINARY,
			(VOID *) &strCert);
	_JumpIfError(hr, error, "Request2_GetCAProperty");

	*ppccXchg = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    (BYTE const *) strCert,
				    SysStringByteLen(strCert));
	if (NULL == *ppccXchg)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}

    }
    hr = S_OK;

error:
    if (NULL != strConfig)
    {
    	SysFreeString(strConfig);
    }
    if (NULL != strCert)
    {
    	SysFreeString(strCert);
    }
    if (fMustRelease)
    {
    	Request_Release(&diRequest);
    }
    return(hr);
}


HRESULT
GetRenewalCert(
    IN WCHAR const *pwszValue,
    OUT CERT_CONTEXT const **ppccRenewal)
{
    HRESULT hr;
    BOOL fEnabled;
    BSTR strConfig = NULL;
    BSTR strCert = NULL;
    WCHAR const *pwszConfig;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;

    *ppccRenewal = NULL;

    hr = myGetCertificateFromPicker(
		    g_hInstance,
		    NULL,		// hwndParent
		    IDS_GETRENEWALCERT_TITLE,
		    IDS_GETRENEWALCERT_SUBTITLE,
		    CUCS_MYSTORE |
			CUCS_MACHINESTORE | CUCS_USERSTORE |
			CUCS_DSSTORE |
			CUCS_PRIVATEKEYREQUIRED |
			(g_fVerbose? CUCS_ARCHIVED : 0) |
			(g_fQuiet? CUCS_SILENT : 0),
		    (L'\0' == pwszValue || 0 == lstrcmp(L"*", pwszValue))?
			NULL : pwszValue, // pwszCommonName
		    0,			// cStore
		    NULL,		// rghStore
		    0,			// cpszObjId
		    NULL,		// apszObjId
		    ppccRenewal);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

error:
    if (NULL != strConfig)
    {
    	SysFreeString(strConfig);
    }
    if (NULL != strCert)
    {
    	SysFreeString(strCert);
    }
    if (fMustRelease)
    {
    	Request_Release(&diRequest);
    }
    return(hr);
}


HRESULT
CreateNewRequest(
    IN HWND hWndOwner,
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    IEnroll4 *pEnroll = NULL;
    CRYPT_DATA_BLOB blobRequest;
    WCHAR *pwszObjId = NULL;
    DWORD cInfValues;
    INFVALUES *rgInfValues = NULL;
    CRYPT_ATTRIBUTES *rgAttributes = NULL;
    DWORD cAttributes;
    CERT_EXTENSION *rgExtT;
    CERT_EXTENSION *rgExt = NULL;
    CERT_CONTEXT const *pccXchg = NULL;
    CERT_CONTEXT const *pccRenewal = NULL;
    CERT_CONTEXT const *pccSigner = NULL;
    CERT_NAME_BLOB NameBlob;
    WCHAR *pwszDN = NULL;
    DWORD cExt = 0;
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD RequestTypeFlags;
    BOOL fReqestTypeSet;
    
    blobRequest.pbData = NULL;
    NameBlob.pbData = NULL;
    cAttributes = 0;

    hr = ParseRequestInfo(
		pwszAttributes,
		pwszfnPolicy,
		&rgInfValues,
		&cInfValues,
		&rgAttributes,
		&cAttributes,
		&rgExt,
		&cExt);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "ParseRequestInfo");
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                       CLSID_CEnroll,
                       NULL,               // pUnkOuter
                       CLSCTX_INPROC_SERVER,
                       IID_IEnroll4,
                       (VOID **) &pEnroll);
    _JumpIfError(hr, error, "CoCreateInstance");

    for (i = 0; i < cAttributes; i++)
    {
	CRYPT_ATTRIBUTES *pAttributes = &rgAttributes[i];

	for (j = 0; j < pAttributes->cAttr; j++)
	{
	    CRYPT_ATTRIBUTE *pAttr = &pAttributes->rgAttr[j];

	    if (NULL != pwszObjId)
	    {
		LocalFree(pwszObjId);
		pwszObjId = NULL;
	    }
	    if (!ConvertSzToWsz(&pwszObjId, pAttr->pszObjId, -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "ConvertSzToWsz");
	    }
	    for (k = 0; k < pAttr->cValue; k++)
	    {
		hr = pEnroll->addAttributeToRequestWStr(
					    0,		// Flags
					    pwszObjId,
					    &pAttr->rgValue[k]);
		_JumpIfError(hr, error, "addAttributeToRequestWStr");
	    }
	}
    }
    for (i = 0; i < cExt; i++)
    {
	CERT_EXTENSION *pExt = &rgExt[i];

	if (NULL != pwszObjId)
	{
	    LocalFree(pwszObjId);
	    pwszObjId = NULL;
	}
	if (!ConvertSzToWsz(&pwszObjId, pExt->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}
	hr = pEnroll->addExtensionToRequestWStr(
					pExt->fCritical,
					pwszObjId,
					&pExt->Value);
	_JumpIfError(hr, error, "addExtensionToRequestWStr");
    }

    fReqestTypeSet = FALSE;
    for (i = 0; i < cInfValues; i++)
    {
	INFVALUES *pInfValues = &rgInfValues[i];
	WCHAR const *pwszInfValue;
	LONG lFlagsT;
	BOOL fT;
	BOOL fValid;

	if (1 != pInfValues->cValues)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    SetErrorStringInf(pwszfnPolicy, pInfValues);
	    _JumpError(hr, error, "Wrong value count");
	}

	pwszInfValue = pInfValues->rgpwszValues[0];
	if (NULL == pwszDN &&
	    0 == lstrcmpi(wszINFKEY_SUBJECT, pInfValues->pwszKey))
	{
	    // Reverse the name for XEnroll!?

	    hr = myCertStrToName(
		    X509_ASN_ENCODING,
		    pwszInfValue,	 // pszX500
		    0,			 // CERT_NAME_STR_REVERSE_FLAG,
		    NULL,		 // pvReserved
		    &NameBlob.pbData,
		    &NameBlob.cbData,
		    NULL);		 // ppszError
	    _JumpIfError(hr, error, "myCertStrToName");

	    hr = myCertNameToStr(
			X509_ASN_ENCODING,
			&NameBlob,
			CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			&pwszDN);
	    _JumpIfError(hr, error, "myCertNameToStr");
	}
	else
	if (NULL == pccXchg &&
	    0 == lstrcmpi(wszINFKEY_PRIVATEKEYARCHIVE, pInfValues->pwszKey))
	{
	    hr = GetCAXchgCert(pwszInfValue, &pccXchg);
	    _JumpIfError(hr, error, "GetCAXchgCert");
	}
	else
	if (NULL == pccRenewal &&
	    0 == lstrcmpi(wszINFKEY_RENEWALCERT, pInfValues->pwszKey))
	{
	    hr = GetRenewalCert(pwszInfValue, &pccRenewal);
	    _JumpIfError(hr, error, "GetRenewalCert");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_KEYSPEC, pInfValues->pwszKey))
	{
	    DWORD dwKeySpec;
	    
	    dwKeySpec = myWtoI(pwszInfValue, &fValid);
	    if (!fValid ||
		(AT_SIGNATURE != dwKeySpec && AT_KEYEXCHANGE != dwKeySpec))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad KeySpec value");
	    }
	    hr = pEnroll->put_KeySpec(dwKeySpec);
	    _JumpIfError(hr, error, "put_KeySpec");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_KEYLENGTH, pInfValues->pwszKey))
	{
	    DWORD dwKeyLength;
	    
	    dwKeyLength = myWtoI(pwszInfValue, &fValid);
	    if (!fValid || 0 == dwKeyLength || 64 * 1024 <= dwKeyLength)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad KeyLength value");
	    }
	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~KEY_LENGTH_MASK;
	    lFlagsT |= dwKeyLength << 16;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_EXPORTABLE, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_EXPORTABLE;
	    lFlagsT |= fT? CRYPT_EXPORTABLE : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_USERPROTECTED, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_USER_PROTECTED;
	    lFlagsT |= fT? CRYPT_USER_PROTECTED : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_KEYCONTAINER, pInfValues->pwszKey))
	{
	    hr = pEnroll->put_ContainerNameWStr(
					const_cast<WCHAR *>(pwszInfValue));
	    _JumpIfError(hr, error, "put_ContainerNameWStr");
	}
#if 0
	else
	if (0 == lstrcmpi(wszINFKEY_HASHALGID, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_EXPORTABLE;
	    lFlagsT |= fT? CRYPT_EXPORTABLE : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_HASHALGORITHM, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_EXPORTABLE;
	    lFlagsT |= fT? CRYPT_EXPORTABLE : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
#endif
	else
	if (0 == lstrcmpi(wszINFKEY_MACHINEKEYSET, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_ProviderFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_ProviderFlags");

	    lFlagsT &= ~CRYPT_MACHINE_KEYSET;
	    lFlagsT |= fT? CRYPT_MACHINE_KEYSET : 0;

	    hr = pEnroll->put_ProviderFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_ProviderFlags");

	    hr = pEnroll->get_MyStoreFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_MyStoreFlags");

	    lFlagsT &= ~(CERT_SYSTEM_STORE_CURRENT_USER |
			 CERT_SYSTEM_STORE_LOCAL_MACHINE);
	    lFlagsT |= fT? CERT_SYSTEM_STORE_LOCAL_MACHINE :
			   CERT_SYSTEM_STORE_CURRENT_USER;

	    hr = pEnroll->put_MyStoreFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_MyStoreFlags");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_SILENT, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_ProviderFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_ProviderFlags");

	    lFlagsT &= ~CRYPT_SILENT;
	    lFlagsT |= fT? CRYPT_SILENT : 0;

	    hr = pEnroll->put_ProviderFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_ProviderFlags");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_PROVIDERNAME, pInfValues->pwszKey))
	{
	    hr = pEnroll->put_ProviderNameWStr(
					const_cast<WCHAR *>(pwszInfValue));
	    _JumpIfError(hr, error, "put_ProviderNameWStr");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_PROVIDERTYPE, pInfValues->pwszKey))
	{
	    lFlagsT = myWtoI(pwszInfValue, &fValid);
	    if (!fValid)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad ProviderType value");
	    }
	    hr = pEnroll->put_ProviderType(lFlagsT);
	    _JumpIfError(hr, error, "put_ProviderType");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_USEEXISTINHKEYSET, pInfValues->pwszKey))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->put_UseExistingKeySet(lFlagsT);
	    _JumpIfError(hr, error, "put_UseExistingKeySet");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_SMIME, pInfValues->pwszKey))
	{
	    BOOL fSMIME;
	    
	    hr = myInfParseBooleanValue(pwszInfValue, &fSMIME);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->put_EnableSMIMECapabilities(fSMIME);
	    _JumpIfError(hr, error, "put_EnableSMIMECapabilities");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_REQUESTERNAME, pInfValues->pwszKey))
	{
	    hr = pEnroll->AddNameValuePairToSignatureWStr(
					wszINFKEY_REQUESTERNAME,
					const_cast<WCHAR *>(pwszInfValue));
	    _JumpIfError(hr, error, "AddNameValuePairToSignatureWStr");
	}
	else
	if (0 == lstrcmpi(wszINFKEY_REQUESTTYPE, pInfValues->pwszKey))
	{
	    if (0 == lstrcmpi(wszINFVALUE_REQUESTTYPE_PKCS101, pwszInfValue))
	    {
		RequestTypeFlags = XECR_PKCS10_V1_5;
	    }
	    else
	    if (0 == lstrcmpi(wszINFVALUE_REQUESTTYPE_PKCS10, pwszInfValue))
	    {
		RequestTypeFlags = XECR_PKCS10_V2_0;
	    }
	    else
	    if (0 == lstrcmpi(wszINFVALUE_REQUESTTYPE_PKCS7, pwszInfValue))
	    {
		RequestTypeFlags = XECR_PKCS7;
	    }
	    else
	    if (0 == lstrcmpi(wszINFVALUE_REQUESTTYPE_CMC, pwszInfValue))
	    {
		RequestTypeFlags = XECR_CMC;
	    }
	    else
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpErrorStr(hr, error, "Bad RequestType value", pwszInfValue);
	    }
	    fReqestTypeSet = TRUE;
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    SetErrorStringInf(pwszfnPolicy, pInfValues);
	    _JumpErrorStr(hr, error, "bad Inf key", pInfValues->pwszKey);
	}
    }

    if (NULL != g_pwszCertCN)
    {
	if (!g_fQuiet || NULL != g_pwszCertCN)
	{
	    hr = myGetCertificateFromPicker(
		    g_hInstance,
		    NULL,		// hwndParent
		    IDS_GETSIGNINGCERT_TITLE,
		    IDS_GETSIGNINGCERT_SUBTITLE,
		    CUCS_MYSTORE |
			CUCS_PRIVATEKEYREQUIRED |
			(g_fQuiet? CUCS_SILENT : 0),
		    (L'\0' == g_pwszCertCN || 0 == lstrcmp(L"*", g_pwszCertCN))?
			NULL : g_pwszCertCN,	// pwszCommonName
		    0,				// cStore
		    NULL,			// rghStore
		    0,				// cpszObjId
		    NULL,			// apszObjId
		    &pccSigner);
	    _JumpIfError(hr, error, "myGetCertificateFromPicker");
	}

	// pccSigner is NULL if the user cancelled out of the cert picker U/I.

	if (NULL == pccSigner)
	{
	    if (g_fQuiet || NULL != g_pwszCertCN)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no matching signer CN");
	    }
	}
	hr = pEnroll->SetSignerCertificate(pccSigner);
	_JumpIfError(hr, error, "SetSignerCertificate");
    }
    if (NULL != pccXchg)
    {
	LONG lGenKeyFlags;

	hr = pEnroll->SetPrivateKeyArchiveCertificate(pccXchg);
	_JumpIfError(hr, error, "SetPrivateKeyArchiveCertificate");

        hr = pEnroll->get_GenKeyFlags(&lGenKeyFlags);
	_JumpIfError(hr, error, "getGenKeyFlags");

	if (0 == (CRYPT_EXPORTABLE & lGenKeyFlags))
	{
	    hr = pEnroll->put_GenKeyFlags(CRYPT_EXPORTABLE | lGenKeyFlags);
	    _JumpIfError(hr, error, "putGenKeyFlags");
	}
    }
    if (NULL != pccRenewal)
    {
	hr = pEnroll->put_RenewalCertificate(pccRenewal);
	_JumpIfError(hr, error, "put_RenewalCertificate");
    }
    if (!fReqestTypeSet)
    {
	RequestTypeFlags = XECR_PKCS10_V2_0;
	if (NULL != pccXchg)
	{
	    RequestTypeFlags = XECR_CMC;
	}
	else if (NULL != pccRenewal)
	{
	    RequestTypeFlags = XECR_PKCS7;
	}
    }
    hr = pEnroll->createRequestWStr(
			RequestTypeFlags,
			pwszDN,
			NULL,
			&blobRequest);
    _JumpIfError(hr, error, "createRequestWStr");

    myRegisterMemAlloc(blobRequest.pbData, blobRequest.cbData, CSM_LOCALALLOC);

    hr = WriteCertificateOrRequest(
			hWndOwner,
    			NULL,		// pdiRequest
			blobRequest.pbData,
			blobRequest.cbData,
			g_dwOutFormat,
			pwszfnOut);
    _JumpIfError(hr, error, "WriteCertificateOrRequest");

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    if (NULL != NameBlob.pbData)
    {
	LocalFree(NameBlob.pbData);
    }
    if (NULL != pccXchg)
    {
	CertFreeCertificateContext(pccXchg);
    }
    if (NULL != pccRenewal)
    {
	CertFreeCertificateContext(pccRenewal);
    }
    if (NULL != pccSigner)
    {
	CertFreeCertificateContext(pccSigner);
    }
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    if (NULL != rgAttributes)
    {
	FreeAttributes(cAttributes, rgAttributes);
    }
    if (NULL != rgExt)
    {
	FreeExtensions(TRUE, cExt, rgExt);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    if (NULL != blobRequest.pbData)
    {
	LocalFree(blobRequest.pbData);
    }
    if (NULL != pEnroll)
    {
	pEnroll->Release();
    }
    if (fCoInit)
    {
    	CoUninitialize();
    }
    return(hr);
}


HRESULT
MakePKCS7FromCert(
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    OUT BYTE **ppbChain,
    OUT DWORD *pcbChain)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CRYPT_SIGN_MESSAGE_PARA csmp;
    CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm = { szOID_OIWSEC_sha1, 0, 0 };

    *ppbChain = NULL;
    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    // init csmp for empty signature

    ZeroMemory(&csmp, sizeof(csmp));
    csmp.cbSize = sizeof(csmp);
    csmp.dwMsgEncodingType = PKCS_7_ASN_ENCODING;
    //csmp.pSigningCert = NULL;
    csmp.HashAlgorithm = DigestAlgorithm;
    csmp.cMsgCert = 1;
    csmp.rgpMsgCert = &pcc;
    //csmp.cMsgCrl = 0;
    //csmp.rgpMsgCrl = NULL;

    if (!myCryptSignMessage(
			&csmp,
			pbCert,		// pbToBeSigned
			cbCert,		// cbToBeSigned
			CERTLIB_USE_LOCALALLOC,
			ppbChain,
			pcbChain))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignMessage");
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
AcceptResponse(
    IN HWND hWndOwner,
    IN WCHAR const *pwszfnIn)
{
    HRESULT hr;
    WCHAR *pwszMsg = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    CRYPT_DATA_BLOB blobIn;
    CRYPT_DATA_BLOB blobCert7;
    char *pszInnerContentObjId = NULL;
    DWORD dwType;
    DWORD dwMsgType;
    BYTE *pbDecoded;
    DWORD cb;
    BOOL fCoInit = FALSE;
    IEnroll4 *pEnroll = NULL;

    blobIn.pbData = NULL;
    blobCert7.pbData = NULL;
    hr = DecodeFileW(
		pwszfnIn,
		&blobIn.pbData,
		&blobIn.cbData,
		CRYPT_STRING_BASE64_ANY);
    if (S_OK != hr)
    {
	if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_DECODE_ERR,
			    &pwszMsg))
	{
	    CSASSERT(NULL != pwszMsg);
	    wprintf(pwszMsg, myHResultToString(awchr, hr));
	    wprintf(g_wszNewLine);
	}
	goto error;
    }

    dwType = CR_IN_CERT;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    blobIn.pbData,
		    blobIn.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cb))
    {
	//_PrintError(myHLastError(), "myDecodeObject(Cert)");
	CSASSERT(NULL == pbDecoded);

	dwType = CR_IN_PKCS7; // PKCS 7 renewal request?
	hr = myDecodePKCS7(
			blobIn.pbData,
			blobIn.cbData,
			NULL,		// ppbContents
			NULL,		// pcbContents
			NULL,		// pdwMsgType
			&pszInnerContentObjId,
			NULL,		// pcSigner
			NULL,		// pcRecipient
			NULL,		// phStore
			NULL);		// phMsg
	_JumpIfError(hr, error, "myDecodePKCS7");

	if (NULL != pszInnerContentObjId &&
	    0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_RESPONSE))
	{
	    dwType = CR_IN_CMC;
	}
    }
    if (CR_IN_CERT == dwType)
    {
	hr = MakePKCS7FromCert(
			blobIn.pbData,
			blobIn.cbData,
			&blobCert7.pbData,
			&blobCert7.cbData);
	_JumpIfError(hr, error, "MakePKCS7FromCert");
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                       CLSID_CEnroll,
                       NULL,               // pUnkOuter
                       CLSCTX_INPROC_SERVER,
                       IID_IEnroll4,
                       (VOID **) &pEnroll);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (CR_IN_CMC == dwType)
    {
	hr = pEnroll->acceptResponseBlob(&blobIn);
	_JumpIfError(hr, error, "acceptResponseBlob");
    }
    else
    {
	hr = pEnroll->acceptPKCS7Blob(
			    NULL != blobCert7.pbData? &blobCert7 : &blobIn);
	_JumpIfError(hr, error, "acceptPKCS7Blob");
    }

error:
    if (NULL != pwszMsg)
    {
	LocalFree(pwszMsg);
    }
    if (NULL != blobIn.pbData)
    {
	LocalFree(blobIn.pbData);
    }
    if (NULL != blobCert7.pbData)
    {
	LocalFree(blobCert7.pbData);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pEnroll)
    {
	pEnroll->Release();
    }
    if (fCoInit)
    {
    	CoUninitialize();
    }
    return(hr);
}


HRESULT
ArgvMain(
    int argc,
    WCHAR *argv[],
    HWND hWndOwner)
{
    HRESULT hr;
    WCHAR *pwszOFN = NULL;
    WCHAR *pwszOFN2 = NULL;
    WCHAR const *pwszfnIn;
    WCHAR const *pwszfnOut;
    WCHAR const *pwszfnPKCS10;
    WCHAR const *pwszfnCertChain;
    WCHAR const *pwszfnFullResponse;
    WCHAR const *pwszfnPolicy;
    LONG RequestId;
    WCHAR *pwszAttributes = NULL;
    WCHAR const *pwszSerialNumber = NULL;
    DWORD cCommand = 0;
    int cArgMax = 0;
    WCHAR *rgpwszArg[4];
    UINT idsFileFilter;
    UINT idsFileDefExt;

    myVerifyResourceStrings(g_hInstance);
    while (1 < argc && (L'-' == argv[1][0] || L'/' == argv[1][0]))
    {
	if (0 == lstrcmpi(&argv[1][1], L"config"))
	{
	    if (2 >= argc)
	    {
		_PrintError(E_INVALIDARG, "missing -config arg");
		Usage(TRUE);
	    }
	    if (0 == wcscmp(argv[2], L"-") || 0 == wcscmp(argv[2], L"*"))
	    {
		g_dwUIFlag = CC_LOCALACTIVECONFIG;
	    }
	    else
	    {
		g_pwszConfig = argv[2];
	    }
	    argc--;
	    argv++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"any"))
	{
	    g_fAny = TRUE;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"crl"))
	{
	    g_dwCRLIn = CR_IN_CRLS;
	    g_dwCRLOut = CR_OUT_CRLS;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"rpc"))
	{
	    g_fRPC++;
	    if (0 == lstrcmp(&argv[1][1], L"RPC"))
	    {
		g_fRPC++;
	    }
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"binary"))
	{
	    g_dwOutFormat = CR_OUT_BINARY;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"idispatch"))
	{
	    g_fIDispatch = TRUE;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"submit"))
	{
	    g_dwCommand = cmdSUBMITREQUEST;
	    cArgMax = 4;
	    cCommand++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"retrieve"))
	{
	    g_dwCommand = cmdRETRIEVEPENDING;
	    cArgMax = 4;
	    cCommand++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"policy"))
	{
	    g_dwCommand = cmdQUALIFIEDREQUEST;
	    cArgMax = 4;
	    cCommand++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"new"))
	{
	    g_dwCommand = cmdNEWREQUEST;
	    cArgMax = 2;
	    cCommand++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"accept"))
	{
	    g_dwCommand = cmdACCEPTRESPONSE;
	    cArgMax = 1;
	    cCommand++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"sign"))
	{
	    g_dwCommand = cmdSIGNREQUEST;
	    cArgMax = 2;
	    cCommand++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"v1"))
	{
	    g_fV1Interface = TRUE;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"v"))
	{
	    g_fVerbose = TRUE;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"f"))
	{
	    g_fForce++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"q"))
	{
	    g_fQuiet = TRUE;
	    g_dwUIFlag = CC_LOCALACTIVECONFIG;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"?") ||
	    0 == lstrcmpi(&argv[1][1], L"usage"))
	{
	    g_fFullUsage = 0 == lstrcmp(&argv[1][1], L"uSAGE");
	    Usage(FALSE);
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"attrib"))
	{
	    if (2 >= argc)
	    {
		_PrintError(E_INVALIDARG, "missing -attrib arg");
		Usage(TRUE);
	    }
	    hr = crCombineAttributes(argv[2], &pwszAttributes);
	    _JumpIfError(hr, error, "crCombineAttributes");

	    argc--;
	    argv++;
	}
	else
	if (0 == lstrcmpi(&argv[1][1], L"cert"))
	{
	    if (2 >= argc)
	    {
		_PrintError(E_INVALIDARG, "missing -cert arg");
		Usage(TRUE);
	    }
	    g_pwszCertCN = argv[2];
	    argc--;
	    argv++;
	}
	else
	{
	    _PrintError(E_INVALIDARG, "Unknown arg");
	    Usage(TRUE);
	}
	argc--;
	argv++;
    }

    if (1 < cCommand)
    {
	_PrintError(E_INVALIDARG, "multiple commands");
	Usage(TRUE);
    }
    if (cmdNONE == g_dwCommand)
    {
	g_dwCommand = cmdSUBMITREQUEST;
	cArgMax = 4;
    }
    if (NULL != pwszAttributes &&
	(cmdRETRIEVEPENDING == g_dwCommand &&
	 cmdSUBMITREQUEST == g_dwCommand))
    {
	_PrintError(E_INVALIDARG, "unexpected -attrib arg");
	Usage(TRUE);
    }
    if (NULL != g_pwszCertCN &&
	cmdSIGNREQUEST != g_dwCommand &&
	cmdQUALIFIEDREQUEST != g_dwCommand &&
	cmdNEWREQUEST != g_dwCommand)
    {
	_PrintError(E_INVALIDARG, "unexpected -cert arg");
	Usage(TRUE);
    }

    if (1 + cArgMax < argc)
    {
	_PrintError(E_INVALIDARG, "Extra args");
	Usage(TRUE);
    }

    CSASSERT(ARRAYSIZE(rgpwszArg) >= cArgMax);
    ZeroMemory(rgpwszArg, sizeof(rgpwszArg));

    if (1 < argc)
    {
	rgpwszArg[0] = argv[1];
	if (2 < argc)
	{
	    rgpwszArg[1] = argv[2];
	    if (3 < argc)
	    {
		rgpwszArg[2] = argv[3];
		if (4 < argc)
		{
		    rgpwszArg[3] = argv[4];
		}
	    }
	}
    }

    // cmdSUBMITREQUEST:
    //	[RequestFile [CertFile [CertChainFile [FullResponseFile]]]]
    //
    // cmdRETRIEVEPENDING:
    //	[RequestId [CertFile [CertChainFile [FullResponseFile]]]]
    //
    // cmdNEWREQUEST
    //	[PolicyFile [RequestFileOut]]
    //
    // cmdACCEPTRESPONSE
    //	[CertFile | CertChainFile | FullResponseFile]
    //
    // cmdQUALIFIEDREQUEST (accept RequestFile and PolicyFile in either order)
    //	[RequestFile [PolicyFile [RequestFileOut [PKCS10FileOut]]]
    //
    // cmdSIGNREQUEST:
    //	[RequestFile [RequestFileOut]]
    //

    pwszfnIn = NULL;
    pwszfnOut = NULL;
    pwszfnPKCS10 = NULL;
    pwszfnCertChain = NULL;
    pwszfnFullResponse = NULL;
    pwszfnPolicy = NULL;

    pwszfnIn = rgpwszArg[0];
    idsFileFilter = IDS_REQUEST_FILE_FILTER;
    idsFileDefExt = IDS_REQUEST_FILE_DEFEXT;

    switch (g_dwCommand)
    {
	case cmdRETRIEVEPENDING:
	    idsFileFilter = 0;	// disable file open dialog
	    // FALLTHROUGH
	case cmdSUBMITREQUEST:
	    pwszfnOut = rgpwszArg[1];
	    pwszfnCertChain = rgpwszArg[2];
	    pwszfnFullResponse = rgpwszArg[3];
	    break;

	case cmdNEWREQUEST:
	    pwszfnIn = NULL;
	    pwszfnPolicy = rgpwszArg[0];
	    pwszfnOut = rgpwszArg[1];
	    CSASSERT(NULL == rgpwszArg[2]);
	    idsFileFilter = 0;	// disable file open dialog
	    break;

	case cmdACCEPTRESPONSE:
	    CSASSERT(NULL == rgpwszArg[1]);
	    idsFileFilter = IDS_RESPONSE_FILE_FILTER;
	    idsFileDefExt = IDS_RESPONSE_FILE_DEFEXT;
	    break;

	case cmdQUALIFIEDREQUEST:
	    pwszfnPolicy = rgpwszArg[1];
	    pwszfnOut = rgpwszArg[2];
	    pwszfnPKCS10 = rgpwszArg[3];
	    idsFileFilter = IDS_REQUEST_OR_CERT_FILE_FILTER;
	    break;

	default:
	    CSASSERT(cmdSIGNREQUEST == g_dwCommand);
	    pwszfnOut = rgpwszArg[1];
	    CSASSERT(NULL == rgpwszArg[2]);
	    CSASSERT(NULL == rgpwszArg[3]);
	    break;
    }

    if (cmdRETRIEVEPENDING == g_dwCommand)
    {
	if (NULL == pwszfnIn)
	{
            WCHAR *pwszMsg = NULL;
            hr = myLoadRCString(
			    g_hInstance,
			    IDS_ERROR_NO_REQUESTID,
			    &pwszMsg);
            if (S_OK == hr)
            {
                CSASSERT(NULL != pwszMsg);
                wprintf(pwszMsg);
                wprintf(g_wszNewLine);
                LocalFree(pwszMsg);
            }
	    _PrintError(E_INVALIDARG, "missing RequestId");
	    Usage(TRUE);
	}
	hr = GetLong(pwszfnIn, &RequestId);
	if (S_OK != hr || 0 == RequestId)
	{
	    RequestId = 0;
	    pwszSerialNumber = pwszfnIn;
	}
	pwszfnIn = NULL;
    }
    else
    if (NULL != pwszfnIn && cmdQUALIFIEDREQUEST == g_dwCommand)
    {
	BYTE *pbReq;
	DWORD cbReq;
	LONG dwFlags;
	BOOL fSigned;

	// accept RequestFile and PolicyFile in either order:
	
	hr = CheckRequestType(pwszfnIn, &pbReq, &cbReq, &dwFlags, &fSigned);
	if (S_OK != hr)
	{
	    WCHAR const *pwsz = pwszfnPolicy;

	    pwszfnPolicy = pwszfnIn;
	    pwszfnIn = pwsz;
	}
	else
	{
	    LocalFree(pbReq);
	}
    }
    if (NULL == pwszfnIn && 0 != idsFileFilter)
    {
	// Put up a file open dialog to get Response, Request or cert file

        hr = crGetOpenFileName(
			hWndOwner,
			IDS_REQUEST_OPEN_TITLE,
			idsFileFilter,
			idsFileDefExt,
			&pwszOFN);
	_JumpIfError(hr, error, "crGetOpenFileName");

	pwszfnIn = pwszOFN;
    }

    if (NULL != pwszfnIn)
    {
	if (!myDoesFileExist(pwszfnIn))
	{
	    SetErrorString(pwszfnIn);
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpErrorStr(hr, error, "myDoesFileExist", pwszfnIn);
	}
    }
    if (NULL != pwszfnOut)
    {
	hr = myIsDirWriteable(pwszfnOut, TRUE);
	if (S_OK != hr)
	{
	    SetErrorString(pwszfnOut);
	    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnOut);
	}
    }

    switch (g_dwCommand)
    {
	case cmdRETRIEVEPENDING:
	case cmdSUBMITREQUEST:
	    if (CV_OUT_BASE64REQUESTHEADER == g_dwOutFormat)
	    {
		g_dwOutFormat = CV_OUT_BASE64HEADER;
	    }
	    if (NULL != pwszfnCertChain)
	    {
		hr = myIsDirWriteable(pwszfnCertChain, TRUE);
		if (S_OK != hr)
		{
		    SetErrorString(pwszfnCertChain);
		    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnCertChain);
		}
	    }
	    if (NULL != pwszfnFullResponse)
	    {
		hr = myIsDirWriteable(pwszfnFullResponse, TRUE);
		if (S_OK != hr)
		{
		    SetErrorString(pwszfnFullResponse);
		    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnFullResponse);
		}
	    }
	    hr = SubmitRequest(
			    hWndOwner,
			    RequestId,
			    pwszSerialNumber,
			    pwszAttributes,
			    pwszfnIn,
			    pwszfnOut,
			    pwszfnCertChain,
			    pwszfnFullResponse);
	    _JumpIfError(hr, error, "SubmitRequest");

	    break;

	case cmdACCEPTRESPONSE:
	    hr = AcceptResponse(hWndOwner, pwszfnIn);
	    _JumpIfError(hr, error, "AcceptResponse");

	    break;
	
	case cmdNEWREQUEST:
	case cmdQUALIFIEDREQUEST:
	    if (NULL != pwszfnPKCS10)
	    {
		hr = myIsDirWriteable(pwszfnPKCS10, TRUE);
		if (S_OK != hr)
		{
		    SetErrorString(pwszfnPKCS10);
		    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnPKCS10);
		}
	    }
	    if (NULL == pwszfnPolicy)
	    {
		// Put up a file dialog to prompt the user for Inf File

		hr = crGetOpenFileName(
				hWndOwner,
				IDS_INF_OPEN_TITLE,
				IDS_INF_FILE_FILTER,
				IDS_INF_FILE_DEFEXT,
				&pwszOFN2);
		_JumpIfError(hr, error, "crGetOpenFileName");

		pwszfnPolicy = pwszOFN2;
	    }
	    CSASSERT(NULL != pwszfnPolicy);
	    if (!myDoesFileExist(pwszfnPolicy))
	    {
		SetErrorString(pwszfnPolicy);
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpErrorStr(hr, error, "myDoesFileExist", pwszfnPolicy);
	    }
	    if (cmdNEWREQUEST == g_dwCommand)
	    {
		hr = CreateNewRequest(
				hWndOwner,
				pwszAttributes,
				pwszfnPolicy,
				pwszfnOut);
		_JumpIfError(hr, error, "CreateNewRequest");
	    }
	    else
	    {
		hr = CreateQualifiedRequest(
					hWndOwner,
					pwszAttributes,
					pwszfnIn,
					pwszfnPolicy,
					pwszfnOut,
					pwszfnPKCS10);
		_JumpIfError(hr, error, "CreateQualifiedRequest");
	    }
	    break;

	default:
	    CSASSERT(cmdSIGNREQUEST == g_dwCommand);
	    if (NULL != pwszfnFullResponse)
	    {
		Usage(TRUE);
	    }
	    hr = SignQualifiedRequest(hWndOwner, pwszfnIn, pwszfnOut);
	    _JumpIfError(hr, error, "SignQualifiedRequest");

	    break;
    }

error:
    if (NULL != pwszAttributes)
    {
        LocalFree(pwszAttributes);
    }
    if (NULL != pwszOFN)
    {
        LocalFree(pwszOFN);
    }
    if (NULL != pwszOFN2)
    {
        LocalFree(pwszOFN2);
    }
    return(hr);
}


//**************************************************************************
//  FUNCTION:	CertReqPreMain
//  NOTES:	Based on vich's MkRootMain function; takes an LPSTR command
//		line and chews it up into argc/argv form so that it can be
//		passed on to a traditional C style main.
//**************************************************************************

#define ISBLANK(wc)	(L' ' == (wc) || L'\t' == (wc))

HRESULT 
CertReqPreMain(
    LPTSTR pszCmdLine,
    HWND hWndOwner)
{
    WCHAR *pbuf;
    LPTSTR apszArg[20];
    int cArg = 0;
    LPTSTR p;
    WCHAR *pchQuote;
    HRESULT hr;

    pbuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pbuf)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    p = pbuf;

    apszArg[cArg++] = TEXT("CertReq");
    while (*pszCmdLine != TEXT('\0'))
    {
	while (ISBLANK(*pszCmdLine))
	{
	    pszCmdLine++;
	}
	if (*pszCmdLine != TEXT('\0'))
	{
	    apszArg[cArg++] = p;
	    if (sizeof(apszArg)/sizeof(apszArg[0]) <= cArg)
	    {
		hr = E_INVALIDARG;
		_JumpIfError(hr, error, "Too many args");
	    }

	    pchQuote = NULL;
	    while (*pszCmdLine != L'\0')
	    {
		if (NULL != pchQuote)
		{
		    if (*pszCmdLine == *pchQuote)
		    {
			pszCmdLine++;
			pchQuote = NULL;
			continue;
		    }
		}
		else
		{
		    if (ISBLANK(*pszCmdLine))
		    {
			break;
		    }
		    if (L'"' == *pszCmdLine)
		    {
			pchQuote = pszCmdLine++;
			continue;
		    }
		}
		*p++ = *pszCmdLine++;
	    }

	    *p++ = TEXT('\0');
	    if (*pszCmdLine != TEXT('\0'))
	    {
		pszCmdLine++;	// skip whitespace or quote character
	    }
	}
    }
    apszArg[cArg] = NULL;

    hr = ArgvMain(cArg, apszArg, hWndOwner);
    _JumpIfError(hr, error, "ArgvMain");

error:
    if (NULL != pbuf)
    {
    	LocalFree(pbuf);
    }
    return(hr);
}


VOID
CertReqErrorDisplay(
    IN HRESULT hr,
    IN HWND hWnd)
{
    WCHAR *pwszTitle = NULL;
    WCHAR *pwszMessage = NULL;
    WCHAR const *pwszError = NULL;
    WCHAR *pwszInfError = NULL;
    WCHAR *pwszCombinedError = NULL;
    WCHAR const *pwsz;

    myLoadRCString(g_hInstance, IDS_CERTREQ_TITLE, &pwszTitle);
    if (g_idError)
    {
	myLoadRCString(g_hInstance, g_idError, &pwszMessage);
    }
    pwszError = myGetErrorMessageText(hr, TRUE);

    // Eliminate redundant error message text.  If the client and server
    // localized error message text differ, both will still be displayed.

    if (NULL != pwszError && NULL != g_pwszErrorString)
    {
	if (NULL != wcsstr(g_pwszErrorString, pwszError))
	{
	    LocalFree(const_cast<WCHAR *>(pwszError));
	    pwszError = NULL;
	}
    }
    pwszInfError = myInfGetError();

    pwsz = NULL;
    if (NULL != pwszMessage ||
	NULL != pwszError ||
	NULL != g_pwszErrorString ||
	NULL != pwszInfError)
    {
	DWORD cwc = 1;

	if (NULL != pwszMessage)
	{
	    cwc += wcslen(pwszMessage) + 1;
	}
	if (NULL != pwszError)
	{
	    cwc += wcslen(pwszError) + 1;
	}
	if (NULL != g_pwszErrorString)
	{
	    cwc += wcslen(g_pwszErrorString) + 1;
	}
	if (NULL != pwszInfError)
	{
	    cwc += wcslen(pwszInfError) + 1;
	}

	pwszCombinedError = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				cwc * sizeof(WCHAR));
	if (NULL != pwszCombinedError)
	{
	    *pwszCombinedError = L'\0';
	    if (NULL != pwszMessage)
	    {
		wcscat(pwszCombinedError, pwszMessage);
	    }
	    if (NULL != pwszError)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, pwszError);
	    }
	    if (NULL != g_pwszErrorString)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, g_pwszErrorString);
	    }
	    if (NULL != pwszInfError)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, pwszInfError);
	    }
	    pwsz = pwszCombinedError;
	}
    }
    if (NULL == pwsz)
    {
	pwsz = pwszError;
	if (NULL == pwsz)
	{
	    pwsz = g_pwszErrorString;
	    if (NULL == pwsz)
	    {
		pwsz = L"";
	    }
	}
    }

    if (!g_fQuiet)
    {
	MessageBox(
		hWnd,
		pwsz,
		pwszTitle,
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    wprintf(L"%ws: %ws\n",
	NULL != pwszTitle? pwszTitle : L"",
	NULL != pwsz? pwsz : L"");

    if (NULL != pwszCombinedError)
    {
	LocalFree(pwszCombinedError);
    }
    if (NULL != pwszInfError)
    {
	LocalFree(pwszInfError);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    if (NULL != pwszMessage)
    {
	LocalFree(pwszMessage);
    }
    if (NULL != pwszTitle)
    {
	LocalFree(pwszTitle);
    }
}


//**************************************************************************
//  FUNCTION:	MainWndProc(...)
//  ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    int	cwc;
    WCHAR *pwszCmdLine = NULL;
    HRESULT hr;
    LRESULT lr = 0;

    switch(msg)
    {
        case WM_CREATE:
        case WM_SIZE:
	    break;

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_DOCERTREQDIALOGS:
	    pwszCmdLine = (WCHAR*)lParam;
	    hr = CertReqPreMain(pwszCmdLine, hWnd);
	    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
	    {
		CertReqErrorDisplay(hr, hWnd);
	    }
	    PostQuitMessage(hr);
	    break;
	    
	default:
	    lr = DefWindowProc(hWnd, msg, wParam, lParam);
	    break;
    }
    return(lr);
}


//+------------------------------------------------------------------------
//
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[pwszCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//
//  History:	12/07/96	JerryK	Added this Comment
//
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    HRESULT hr;
    MSG		msg;
    WNDCLASS	wcApp;
    HWND	hWndMain;

    WCHAR *pwszAppName = NULL;
    WCHAR *pwszWindowName = NULL;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");

    hr = myLoadRCString(hInstance, IDS_APP_NAME, &pwszAppName);
    _PrintIfError(hr, "myLoadRCString(IDS_APP_NAME)");

    hr = myLoadRCString(hInstance, IDS_WINDOW_NAME, &pwszWindowName);
    _PrintIfError(hr, "myLoadRCString(IDS_WINDOW_NAME)");

    // Save the current instance
    g_hInstance = hInstance;

    // Set up the application's window class
    wcApp.style 	= 0;
    wcApp.lpfnWndProc 	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL,IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL,IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= pwszAppName;

    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(
			pwszAppName,
			pwszWindowName,
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			NULL,
			NULL,
			hInstance,
			NULL);
    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain,nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain,WM_DOCERTREQDIALOGS,0,(LPARAM)pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg,NULL,0,0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    if (NULL != g_pwszErrorString)
    {
        LocalFree(g_pwszErrorString);
    }
    if (NULL != pwszAppName)
    {
        LocalFree(pwszAppName);
    }
    if (NULL != pwszWindowName)
    {
        LocalFree(pwszWindowName);
    }
    myInfClearError();
    myFreeResourceStrings("certreq.exe");
    myFreeColumnDisplayNames();
    myRegisterMemDump();
    return((int)msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\admin.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.cpp
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <accctrl.h>

#include "csdisp.h"
#include "csprop.h"
#include "cscom.h"
#include "certlog.h"
#include "certsrvd.h"
#include "admin.h"
#include "resource.h"
#include "dbtable.h"
#include "elog.h"

#define __dwFILE__	__dwFILE_CERTSRV_ADMIN_CPP__

// Global variables
long g_cAdminComponents = 0;     // Count of active components
long g_cAdminServerLocks = 0;    // Count of locks
DWORD g_dwAdminRegister = 0;
IClassFactory* g_pIAdminFactory = NULL;

extern HWND g_hwndMain;

#ifdef DBG_CERTSRV_DEBUG_PRINT
DWORD s_ssAdmin = DBG_SS_CERTSRVI;
#endif

using namespace CertSrv;

// Admin component
// begin implementing cert admin services


HRESULT
AdminGetIndexedCRL(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD CertIndex,		// -1: current CA cert
    /* [in] */ DWORD Flags,		// CA_CRL_*
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCRL)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRL = NULL;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    pctbCRL->pb = NULL;
    pctbCRL->cb = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	switch (Flags)
	{
	    case CA_CRL_BASE:
	    case CA_CRL_DELTA:
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Flags");
	}

	// get the requested CRL:

	hr = CRLGetCRL(CertIndex, CA_CRL_DELTA == Flags, &pCRL, NULL);
	_LeaveIfError(hr, "CRLGetCRL");

	pctbCRL->cb = pCRL->cbCrlEncoded;
	pctbCRL->pb = (BYTE *) MIDL_user_allocate(pCRL->cbCrlEncoded);
	if (NULL == pctbCRL->pb)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "MIDL_user_allocate");
	}
	CopyMemory(pctbCRL->pb, pCRL->pbCrlEncoded, pCRL->cbCrlEncoded);

	myRegisterMemFree(pctbCRL->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pCRL)
    {
        CertFreeCRLContext(pCRL);
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetCRL(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCRL)
{
    HRESULT hr;

    // Just get current base CRL:

    hr = AdminGetIndexedCRL(pwszAuthority, MAXDWORD, CA_CRL_BASE, pctbCRL);
    _JumpIfError(hr, error, "AdminGetIndexedCRL");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetArchivedKey(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbArchivedKey)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_GETARCHIVEDKEY, g_dwAuditFilter);
    DWORD State = 0;

    pctbArchivedKey->pb = NULL;
    pctbArchivedKey->cb = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = PKCSGetArchivedKey(
			    dwRequestId,
			    &pctbArchivedKey->pb,
			    &pctbArchivedKey->cb);
	_LeaveIfError(hr, "PKCSGetArchivedKey");

	myRegisterMemFree(pctbArchivedKey->pb, CSM_COTASKALLOC);

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetCAProperty(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

	hr = CheckAuthorityName(pwszAuthority);
	_JumpIfError(hr, error, "No authority name");

    __try
    {
        CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			    CA_ACCESS_ALLREADROLES,
			    audit.m_gcNoAuditSuccess |
                audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        hr = RequestGetCAProperty(
			    PropId,
			    PropIndex,
			    PropType,
			    pctbPropertyValue);
        _LeaveIfError(hr, "RequestGetCAProperty");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}

STDMETHODIMP
CCertAdminD::SetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetCAProperty(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = RequestSetCAProperty(
			pwszAuthority,
			PropId,
			PropIndex,
			PropType,
			pctbPropertyValue);
    _JumpIfError(hr, error, "RequestSetCAProperty");

error:
    return(hr);
}

STDMETHODIMP
CCertAdminD::GetCAPropertyInfo(
    IN  wchar_t const *pwszAuthority,
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetCAPropertyInfo(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			    CA_ACCESS_ALLREADROLES,
			    audit.m_gcNoAuditSuccess |
                audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        hr = RequestGetCAPropertyInfo(
			        pcProperty,
			        pctbPropInfo);
        _LeaveIfError(hr, "RequestGetCAPropertyInfo");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::PublishCRL(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ FILETIME NextUpdate)
{
    HRESULT hr;

    // CA_CRL_BASE implies CA_CRL_DELTA when delta CRLs are enabled.

    hr = PublishCRLs(pwszAuthority, NextUpdate, CA_CRL_BASE);
    _JumpError(hr, error, "PublishCRLs");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::PublishCRLs(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ FILETIME NextUpdate,
    /* [in] */ DWORD Flags)		// CA_CRL_*
{
    HRESULT hr;
    BOOL fRetry = FALSE;
    BOOL fForceRepublishCRL;
    BOOL fShadowDelta = FALSE;
    WCHAR *pwszUserName = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_PUBLISHCRL, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::PublishCRL(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	HRESULT hrPublish;

        hr = audit.AddData(NextUpdate); // %1 next update
        _LeaveIfError(hr, "AddData");

        hr = audit.AddData(
		    (CA_CRL_BASE & Flags)? true : false); // %2 publish base
        _LeaveIfError(hr, "AddData");

        hr = audit.AddData(
		    (CA_CRL_DELTA & Flags)? true : false); // %3 publish delta
        _LeaveIfError(hr, "AddData");

        hr = audit.AccessCheck(
			CA_ACCESS_ADMIN,
			audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

	switch (~CA_CRL_REPUBLISH & Flags)
	{
	    case CA_CRL_BASE:
		break;

	    case CA_CRL_DELTA:
		if (g_fDeltaCRLPublishDisabled)
		{
		    fShadowDelta = TRUE;
		}
		break;

	    case CA_CRL_BASE | CA_CRL_DELTA:
		if (g_fDeltaCRLPublishDisabled)
		{
		    hr = E_INVALIDARG;
		    _LeaveError(hr, "Delta CRLs disabled");
		}
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Flags");
	}

	fForceRepublishCRL = (CA_CRL_REPUBLISH & Flags)? TRUE : FALSE;

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = CRLPublishCRLs(
		!fForceRepublishCRL,	// fRebuildCRL
		fForceRepublishCRL,	// fForceRepublish
		pwszUserName,
		CA_CRL_DELTA == (~CA_CRL_REPUBLISH & Flags),	// fDeltaOnly
		fShadowDelta,
		NextUpdate,
		&fRetry,
		&hrPublish);
	_LeaveIfError(hr, "CRLPublishCRLs");

	hr = hrPublish;
	_LeaveIfError(hr, "CRLPublishCRLs(hrPublish)");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetExtension(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszExtensionName,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD dwFlags,
    /* [ref][in] */ CERTTRANSBLOB __RPC_FAR *pctbValue)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETEXTENSION, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetExtension(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 Request ID
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(pwszExtensionName); // %2 name
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(dwType); // %3 type
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(dwFlags); // %4 flags
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(pctbValue->pb, pctbValue->cb); // %5 data
	_LeaveIfError(hr, "AddData");

	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, dwRequestId, NULL, &prow);
	_LeaveIfError(hr, "OpenRow");

	hr = CoreValidateRequestId(prow, DB_DISP_PENDING);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreValidateRequestId");
	}

	hr = PropSetExtension(
			    prow,
			    PROPCALLER_ADMIN | (PROPTYPE_MASK & dwType),
			    pwszExtensionName,
			    EXTENSION_ORIGIN_ADMIN |
				(EXTENSION_POLICY_MASK & dwFlags),
			    pctbValue->cb,
			    pctbValue->pb);
	_LeaveIfError(hr, "PropSetExtension");

	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetAttributes(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAttributes)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETATTRIBUTES, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetAttributes(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(pwszAttributes); // %2 attributes
	_LeaveIfError(hr, "AddData");
	
	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, dwRequestId, NULL, &prow);
	_LeaveIfError(hr, "OpenRow");

	hr = CoreValidateRequestId(prow, DB_DISP_PENDING);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreValidateRequestId");
	}

	if (NULL == pwszAttributes)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "pwszAttributes NULL");
	}
	hr = PKCSParseAttributes(
			    prow,
			    pwszAttributes,
			    FALSE,
			    PROPTABLE_CERTIFICATE,
			    NULL);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "PKCSParseAttributes");
	}
	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::DenyRequest(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId)
{
    HRESULT hr;
    DWORD Disposition;
    WCHAR *pwszUserName = NULL;
    CERTSRV_COM_CONTEXT ComContext;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_RESULT_CONTEXT Result;
    CAuditEvent audit(SE_AUDITID_CERTSRV_DENYREQUEST, g_dwAuditFilter);
    DWORD State = 0;

    ZeroMemory(&ComContext, sizeof(ComContext));

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::DenyRequest(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No Authority Name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegisterComContext");

    ZeroMemory(&Result, sizeof(Result));
    Result.pdwRequestId = &dwRequestId;
    Result.pdwDisposition = &Disposition;

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "AddData");
	
	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = CoreProcessRequest(
			    CR_IN_DENY,		// dwFlags
			    pwszUserName,
			    0,			// cbRequest
			    NULL,		// pbRequest
			    NULL,		// pwszAttributes
			    NULL,		// pwszSerialNumber
			    dwComContextIndex,
			    dwRequestId,
			    &Result);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreProcessRequest");
	}
	if (FAILED(Disposition))
	{
	    hr = (HRESULT) Disposition;
	    _LeaveError(hr, "CoreProcessRequest(Disposition)");
	}
	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (MAXDWORD != dwComContextIndex)
    {
        UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ResubmitRequest(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition)
{
    HRESULT hr;
    WCHAR *pwszUserName = NULL;
    CERTSRV_COM_CONTEXT ComContext;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_RESULT_CONTEXT Result;
    CAuditEvent audit(SE_AUDITID_CERTSRV_RESUBMITREQUEST, g_dwAuditFilter);
    DWORD State = 0;

    ZeroMemory(&ComContext, sizeof(ComContext));

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ResubmitRequest(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegisterComContext");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "AddData");
	
	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	ComContext.fInRequestGroup = MAXDWORD;	// mark value invalid

	ZeroMemory(&Result, sizeof(Result));
	Result.pdwRequestId = &dwRequestId;
	Result.pdwDisposition = pdwDisposition;
	hr = CoreProcessRequest(
			    CR_IN_RESUBMIT,	// dwFlags
			    pwszUserName,	// pwszUserName
			    0,			// cbRequest
			    NULL,		// pbRequest
			    NULL,		// pwszAttributes
			    NULL,		// pwszSerialNumber
			    dwComContextIndex,
			    dwRequestId,
			    &Result);

	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreProcessRequest");
	}

    hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != ComContext.hAccessToken)
    {
        __try
        {
            CloseHandle(ComContext.hAccessToken);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
            _PrintError(hr, "Exception");
        }
    }
    if (MAXDWORD != dwComContextIndex)
    {
	UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumViewColumn(
    /* [ref][in] */ wchar_t const *pwszAuthority,
    /* [in] */  DWORD  iColumn,
    /* [in] */  DWORD  cColumn,
    /* [out] */ DWORD *pcColumn,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbColumnInfo)   // CoTaskMem*
{
    HRESULT hr;

    hr = EnumViewColumnTable(
		    pwszAuthority,
		    CVRC_TABLE_REQCERT,
		    iColumn,
		    cColumn,
		    pcColumn,
		    pctbColumnInfo);   // CoTaskMem*
    _JumpIfError(hr, error, "EnumViewColumnTable");

error:
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumViewColumnTable(
    /* [ref][in] */ wchar_t const *pwszAuthority,
    /* [in] */  DWORD  iTable,
    /* [in] */  DWORD  iColumn,
    /* [in] */  DWORD  cColumn,
    /* [out] */ DWORD *pcColumn,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbColumnInfo)   // CoTaskMem*
{
    HRESULT hr;
    LONG iColumnCurrent;
    CERTDBCOLUMN *rgColumn = NULL;
    CERTDBCOLUMN *pColumn;
    CERTDBCOLUMN *pColumnEnd;
    CERTTRANSDBCOLUMN *rgtColumnOut = NULL;
    CERTTRANSDBCOLUMN *ptColumn;
    DWORD cColumnFetched;
    DWORD cb;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::EnumViewColumnTable(tid=%d, this=%x, icol=%d, ccol=%d)\n",
	GetCurrentThreadId(),
	this,
	iColumn,
	cColumn));

    pctbColumnInfo->cb = 0;
    pctbColumnInfo->pb = NULL;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	if (NULL == m_pEnumCol || iTable != m_iTableEnum)
	{
	    if (NULL != m_pEnumCol)
	    {
		m_pEnumCol->Release();
		m_pEnumCol = NULL;
	    }
	    hr = g_pCertDB->EnumCertDBColumn(iTable, &m_pEnumCol);
	    _LeaveIfError(hr, "EnumCertDBColumn");

	    m_iTableEnum = iTable;
	}

	rgColumn = (CERTDBCOLUMN *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    cColumn * sizeof(rgColumn[0]));
	if (NULL == rgColumn)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "Alloc rgColumn");
	}

	hr = m_pEnumCol->Skip(0, &iColumnCurrent);
	_LeaveIfError(hr, "Skip");


	if (iColumnCurrent != (LONG) iColumn)
	{
	    hr = m_pEnumCol->Skip(
			    (LONG) iColumn - iColumnCurrent,
			    &iColumnCurrent);
	    _LeaveIfError(hr, "Skip");

	    CSASSERT((LONG) iColumn == iColumnCurrent);
	}

	hr = m_pEnumCol->Next(cColumn, rgColumn, &cColumnFetched);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "Next");
	}

	DBGPRINT((
		DBG_SS_CERTSRVI,
		"EnumViewColumnTable: cColumnFetched=%d\n",
		cColumnFetched));

	cb = cColumnFetched * sizeof(rgtColumnOut[0]);
	pColumnEnd = &rgColumn[cColumnFetched];
	for (pColumn = rgColumn; pColumn < pColumnEnd; pColumn++)
	{
	    cb += DWORDROUND((wcslen(pColumn->pwszName) + 1) * sizeof(WCHAR));
	    cb += DWORDROUND((wcslen(pColumn->pwszDisplayName) + 1) * sizeof(WCHAR));
	}

	rgtColumnOut = (CERTTRANSDBCOLUMN *) MIDL_user_allocate(cb);
	if (NULL == rgtColumnOut)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "MIDL_user_allocate rgtColumnOut");
	}
	ZeroMemory(rgtColumnOut, cb);
	pctbColumnInfo->cb = cb;

	cb = cColumnFetched * sizeof(rgtColumnOut[0]);
	pColumnEnd = &rgColumn[cColumnFetched];
	ptColumn = rgtColumnOut;
	for (pColumn = rgColumn; pColumn < pColumnEnd; ptColumn++, pColumn++)
	{
	    DWORD cbT;

	    ptColumn->Type = pColumn->Type;
	    ptColumn->Index = pColumn->Index;
	    ptColumn->cbMax = pColumn->cbMax;
	
	    DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "EnumViewColumnTable: ielt=%d idx=%x \"%ws\"\n",
		    iColumn + (ptColumn - rgtColumnOut),
		    ptColumn->Index,
		    pColumn->pwszName));

	    cbT = (wcslen(pColumn->pwszName) + 1) * sizeof(WCHAR);
	    CopyMemory(Add2Ptr(rgtColumnOut, cb), pColumn->pwszName, cbT);
	    ptColumn->obwszName = cb;
	    cb += DWORDROUND(cbT);

	    cbT = (wcslen(pColumn->pwszDisplayName) + 1) * sizeof(WCHAR);
	    CopyMemory(Add2Ptr(rgtColumnOut, cb), pColumn->pwszDisplayName, cbT);
	    ptColumn->obwszDisplayName = cb;
	    cb += DWORDROUND(cbT);
	}
	CSASSERT(cb == pctbColumnInfo->cb);

	pctbColumnInfo->pb = (BYTE *) rgtColumnOut;
	rgtColumnOut = NULL;
	*pcColumn = cColumnFetched;

	myRegisterMemFree(pctbColumnInfo->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != rgColumn)
    {
	pColumnEnd = &rgColumn[cColumn];
	for (pColumn = rgColumn; pColumn < pColumnEnd; pColumn++)
	{
	    if (NULL != pColumn->pwszName)
	    {
		CoTaskMemFree(pColumn->pwszName);
	    }
	    if (NULL != pColumn->pwszDisplayName)
	    {
		CoTaskMemFree(pColumn->pwszDisplayName);
	    }
	}
	LocalFree(rgColumn);
    }
    if (NULL != rgtColumnOut)
    {
	MIDL_user_free(rgtColumnOut);
    }
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "EnumViewColumnTable: icol=%d, ccol=%d, ccolout=%d, hr=%x\n",
	    iColumn,
	    cColumn,
	    *pcColumn,
	    hr));

    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::GetViewDefaultColumnSet(
    IN  wchar_t const *pwszAuthority,
    IN  DWORD          iColumnSetDefault,
    OUT DWORD         *pcColumn,
    OUT CERTTRANSBLOB *ptbColumnInfo)   // CoTaskMem*
{
    HRESULT hr;
    DWORD ccol;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetViewDefaultColumnSet(tid=%d, this=%x, icolset=%d)\n",
	GetCurrentThreadId(),
	this,
	iColumnSetDefault));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	hr = g_pCertDB->GetDefaultColumnSet(iColumnSetDefault, 0, &ccol, NULL);
	_LeaveIfError(hr, "GetDefaultColumnSet");

	ptbColumnInfo->cb = ccol * sizeof(DWORD);
	ptbColumnInfo->pb = (BYTE *) MIDL_user_allocate(ptbColumnInfo->cb);
	if (NULL == ptbColumnInfo->pb)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "MIDL_user_allocate");
	}
	myRegisterMemFree(ptbColumnInfo->pb, CSM_MIDLUSERALLOC);

	hr = g_pCertDB->GetDefaultColumnSet(
					iColumnSetDefault,
					ccol,
					pcColumn,
					(DWORD *) ptbColumnInfo->pb);
	_LeaveIfError(hr, "GetDefaultColumnSet");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    DBGPRINT((
	    S_OK == hr? DBG_SS_CERTSRVI : DBG_SS_CERTSRV,
	    "GetViewDefaultColumnSet: icolset=%d, ccolout=%d, hr=%x\n",
	    iColumnSetDefault,
	    *pcColumn,
	    hr));
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_EnumAttributes(
    IN ICertDBRow     *prow,
    IN CERTDBNAME     *adbn,
    IN DWORD           celt,
    OUT CERTTRANSBLOB *pctbOut) // CoTaskMem*
{
    HRESULT hr;
    DWORD i;
    DWORD cb;
    DWORD cbT;
    CERTTRANSDBATTRIBUTE *pteltOut;
    BYTE *pbOut;
    BYTE *pbOutEnd;
    DWORD State = 0;

    CSASSERT(NULL == pctbOut->pb);

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cb = sizeof(*pteltOut) * celt;
    for (i = 0; i < celt; i++)
    {
	cb += (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	cb = DWORDROUND(cb);

	cbT = 0;
	hr = prow->GetProperty(
			    adbn[i].pwszName,
			    PROPTYPE_STRING |
				PROPCALLER_ADMIN |
				PROPTABLE_ATTRIBUTE,
			    &cbT,
			    NULL);
	_JumpIfError(hr, error, "GetProperty(NULL)");

	cb += DWORDROUND(cbT);
    }

    pctbOut->pb = (BYTE *) MIDL_user_allocate(cb);
    if (NULL == pctbOut->pb)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "MIDL_user_allocate out data");
    }
    pctbOut->cb = cb;

    pteltOut = (CERTTRANSDBATTRIBUTE *) pctbOut->pb;
    pbOut = (BYTE *) &pteltOut[celt];
    pbOutEnd = &pctbOut->pb[pctbOut->cb];

    for (i = 0; i < celt; i++)
    {
	cbT = (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	CopyMemory(pbOut, adbn[i].pwszName, cbT);
	pteltOut->obwszName = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT);

	cbT = SAFE_SUBTRACT_POINTERS(pbOutEnd, pbOut);
	hr = prow->GetProperty(
			    adbn[i].pwszName,
			    PROPTYPE_STRING |
				PROPCALLER_ADMIN |
				PROPTABLE_ATTRIBUTE,
			    &cbT,
			    pbOut);
	_JumpIfError(hr, error, "GetProperty(pbOut)");

	CSASSERT(wcslen((WCHAR const *) pbOut) * sizeof(WCHAR) == cbT);
	pteltOut->obwszValue = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT + sizeof(WCHAR));
	pteltOut++;
    }
    CSASSERT(pbOut == pbOutEnd);
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pctbOut->pb)
    {
	MIDL_user_free(pctbOut->pb);
	pctbOut->pb = NULL;
    }
    CertSrvExitServer(State);
    return(hr);
}


HRESULT
CCertAdminD::_EnumExtensions(
    IN ICertDBRow     *prow,
    IN CERTDBNAME     *adbn,
    IN DWORD           celt,
    OUT CERTTRANSBLOB *pctbOut) // CoTaskMem*
{
    HRESULT hr;
    DWORD i;
    DWORD cb;
    DWORD cbT;
    DWORD ExtFlags;
    CERTTRANSDBEXTENSION *pteltOut;
    BYTE *pbOut;
    BYTE *pbOutEnd;
    DWORD State = 0;

    CSASSERT(NULL == pctbOut->pb);

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cb = sizeof(*pteltOut) * celt;
    for (i = 0; i < celt; i++)
    {
	cb += (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	cb = DWORDROUND(cb);

	cbT = 0;
	hr = prow->GetExtension(
			    adbn[i].pwszName,
			    &ExtFlags,
			    &cbT,
			    NULL);
	_JumpIfError(hr, error, "GetExtension(NULL)");

	cb += DWORDROUND(cbT);
    }

    pctbOut->pb = (BYTE *) MIDL_user_allocate(cb);
    if (NULL == pctbOut->pb)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "MIDL_user_allocate out data");
    }
    pctbOut->cb = cb;

    pteltOut = (CERTTRANSDBEXTENSION *) pctbOut->pb;
    pbOut = (BYTE *) &pteltOut[celt];
    pbOutEnd = &pctbOut->pb[pctbOut->cb];

    for (i = 0; i < celt; i++)
    {
	cbT = (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	CopyMemory(pbOut, adbn[i].pwszName, cbT);
	pteltOut->obwszName = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT);

	cbT = SAFE_SUBTRACT_POINTERS(pbOutEnd, pbOut);
	hr = prow->GetExtension(
			    adbn[i].pwszName,
			    (DWORD *) &pteltOut->ExtFlags,
			    &cbT,
			    pbOut);
	_JumpIfError(hr, error, "GetExtension(pbOut)");

	pteltOut->cbValue = cbT;
	pteltOut->obValue = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT);
	pteltOut++;
    }
    CSASSERT(pbOut == pbOutEnd);
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pctbOut->pb)
    {
	MIDL_user_free(pctbOut->pb);
	pctbOut->pb = NULL;
    }
    CertSrvExitServer(State);
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumAttributesOrExtensions(
    IN          wchar_t const *pwszAuthority,
    IN          DWORD          RowId,
    IN          DWORD          Flags,
    OPTIONAL IN wchar_t const *pwszLast,
    IN          DWORD          celt,
    OUT         DWORD         *pceltFetched,
    OUT         CERTTRANSBLOB *pctbOut) // CoTaskMem*
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    IEnumCERTDBNAME *penum = NULL;
    DWORD EnumFlags;
    CERTDBNAME *adbn = NULL;
    DWORD celtFetched;
    DWORD i;
    DWORD j;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::EnumAttributesOrExtensions(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    DBGPRINT((
	DBG_SS_CERTSRVI,
	"EnumAttributesOrExtensions(row=%d, flags=0x%x, last=%ws, celt=%d)\n",
	RowId,
	Flags,
	pwszLast,
	celt));
    __try
    {
	pctbOut->pb = NULL;
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	if (0 >= RowId)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "RowId");
	}
	switch (Flags)
	{
	    case CDBENUM_ATTRIBUTES:
		EnumFlags = CIE_TABLE_ATTRIBUTES;
		break;

	    case CDBENUM_EXTENSIONS:
		EnumFlags = CIE_TABLE_EXTENSIONS;
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Flags");
	}

	hr = g_pCertDB->OpenRow(
			    PROPOPEN_READONLY | PROPTABLE_REQCERT,
			    RowId,
			    NULL,
			    &prow);
	_LeaveIfError(hr, "OpenRow(RowId)");

	hr = prow->EnumCertDBName(EnumFlags, &penum);
	_LeaveIfError(hr, "EnumCertDBName");

	adbn = (CERTDBNAME *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(adbn[0]) * celt);
	if (NULL == adbn)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "Alloc string pointers");
	}

	// If specified, skip entries up to and including the last key.

	if (NULL != pwszLast)
	{
	    int r;

	    do
	    {
		hr = penum->Next(1, &adbn[0], &celtFetched);
		if (S_FALSE == hr)
		{
		    hr = E_INVALIDARG;
		    _PrintError(hr, "pwszLast missing");
		}
		_LeaveIfError(hr, "Next");

		r = lstrcmpi(pwszLast, adbn[0].pwszName);
		LocalFree(adbn[0].pwszName);
		adbn[0].pwszName = NULL;
	    } while (0 != r);
	}

	hr = penum->Next(celt, adbn, &celtFetched);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "Next");
	}

	if (CIE_TABLE_ATTRIBUTES == EnumFlags)
	{
	    hr = _EnumAttributes(prow, adbn, celtFetched, pctbOut);
	    _LeaveIfError(hr, "_EnumAttributes");
	}
	else
	{
	    hr = _EnumExtensions(prow, adbn, celtFetched, pctbOut);
	    _LeaveIfError(hr, "_EnumExtensions");
	}

	myRegisterMemFree(pctbOut->pb, CSM_MIDLUSERALLOC);

	*pceltFetched = celtFetched;
	hr = S_OK;
	if (celt > celtFetched)
	{
	    hr = S_FALSE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != adbn)
    {
	for (i = 0; i < celt; i++)
	{
	    if (NULL != adbn[i].pwszName)
	    {
		MIDL_user_free(adbn[i].pwszName);
	    }
	}
	LocalFree(adbn);
    }
    if (NULL != penum)
    {
	penum->Release();
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "EnumAttributesOrExtensions: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::OpenView(
    IN wchar_t const             *pwszAuthority,
    IN DWORD                      ccvr,
    IN CERTVIEWRESTRICTION const *acvr,
    IN DWORD                      ccolOut,
    IN DWORD const               *acolOut,
    IN DWORD                      ielt,
    IN DWORD                      celt,
    OUT DWORD                    *pceltFetched,
    OUT CERTTRANSBLOB            *pctbResultRows)   // CoTaskMem*
{
    HRESULT hr;
    IEnumCERTDBRESULTROW *pview = NULL;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::OpenView(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    DBGPRINT((
	DBG_SS_CERTSRVI,
	"================================================================\n"));
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "OpenView(ccvr=%d, ccolOut=%d, celt=%d)\n",
	    ccvr,
	    ccolOut,
	    celt));

    __try
    {
	pctbResultRows->pb = NULL;
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			    CA_ACCESS_ALLREADROLES,
			    audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	if (NULL != m_pView)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "Has View");
	}

	hr = g_pCertDB->OpenView(
                        ccvr,
                        acvr,
                        ccolOut,
                        acolOut,
                        CDBOPENVIEW_WORKERTHREAD,
                        &pview);
	_LeaveIfError(hr, "OpenView");

	hr = _EnumViewNext(pview, ielt, celt, pceltFetched, pctbResultRows);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "_EnumViewNext");
	}

	m_pView = pview;
	pview = NULL;
	myRegisterMemFree(pctbResultRows->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pview)
    {
	pview->Release();
    }
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "OpenView: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumView(
    IN  wchar_t const *pwszAuthority,
    IN  DWORD          ielt,
    IN  DWORD          celt,
    OUT DWORD         *pceltFetched,
    OUT CERTTRANSBLOB *pctbResultRows)  // CoTaskMem*
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::EnumView(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    DBGPRINT((DBG_SS_CERTSRVI, "EnumView(ielt=%d, celt=%d)\n", ielt, celt));

    __try
    {
	if (NULL == m_pView)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "No View");
	}

	hr = _EnumViewNext(
			m_pView,
			ielt,
			celt,
			pceltFetched,
			pctbResultRows);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "_EnumViewNext");
	}
	myRegisterMemFree(pctbResultRows->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "EnumView: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_EnumViewNext(
    IN  IEnumCERTDBRESULTROW *pview,
    IN  DWORD                 ielt,
    IN  DWORD                 celt,
    OUT DWORD                *pceltFetched,
    OUT CERTTRANSBLOB        *pctbResultRows)   // CoTaskMem
{
    HRESULT hr;
    BOOL fNoMore = FALSE;
    BOOL fFetched = FALSE;
    DWORD cb;
    DWORD cbT;
    DWORD cColTotal;
    CERTDBRESULTROW *aelt = NULL;
    CERTDBRESULTROW *pelt;
    CERTDBRESULTROW *peltEnd;
    CERTDBRESULTCOLUMN *pcol;
    CERTDBRESULTCOLUMN *pcolEnd;
    CERTTRANSDBRESULTROW *pteltOut;
    CERTTRANSDBRESULTCOLUMN *ptcolOut;
    BYTE *pbOut;
    DWORD ieltLast;
    DWORD State = 0;

    if(1<InterlockedIncrement(&m_cNext))
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "Calls from multiple threads on the same view object");
    }

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    DBGPRINT((DBG_SS_CERTSRVI, "_EnumViewNext(ielt=%d celt=%d)\n", ielt, celt));

    aelt = (CERTDBRESULTROW *) LocalAlloc(LMEM_FIXED, celt * sizeof(aelt[0]));
    if (NULL == aelt)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Alloc result rows");
    }

    hr = pview->Skip(0, (LONG *) &ieltLast);
    _JumpIfError(hr, error, "Skip");

    if (ielt != ieltLast + 1)
    {
	DBGPRINT((
	    DBG_SS_CERTSRVI, "_EnumViewNext! ieltLast=%d cskip=%d\n",
	    ieltLast,
	    ielt - ieltLast));
	hr = pview->Skip(ielt - (ieltLast + 1), (LONG *) &ieltLast);
	_JumpIfError(hr, error, "Skip");

	DBGPRINT((
	    DBG_SS_CERTSRVI, "_EnumViewNext! ielt after skip=%d\n",
	    ieltLast));
    }

    hr = pview->Next(celt, aelt, pceltFetched);
    if (S_FALSE == hr)
    {
	fNoMore = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "Next");
    }
    fFetched = TRUE;

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "_EnumViewNext! celtFetched=%d\n",
	    *pceltFetched));

    cb = *pceltFetched * sizeof(*pteltOut);
    if (fNoMore)
    {
	cb += sizeof(*pteltOut);
    }
    cColTotal = 0;

    peltEnd = &aelt[*pceltFetched];
    for (pelt = aelt; pelt < peltEnd; pelt++)
    {
	cColTotal += pelt->ccol;
	cb += pelt->ccol * sizeof(*ptcolOut);

	pcolEnd = &pelt->acol[pelt->ccol];
	for (pcol = pelt->acol; pcol < pcolEnd; pcol++)
	{
	    CSASSERT(DWORDROUND(cb) == cb);
	    if (NULL != pcol->pbValue)
	    {
		if ((DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY) ==
		     pcol->Index)
		{
		    cb += sizeof(DWORD);
		}
		else
		{
		    cb += DWORDROUND(pcol->cbValue);
		}
	    }
	}
    }

    pctbResultRows->pb = (BYTE *) MIDL_user_allocate(cb);
    if (NULL == pctbResultRows->pb)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "MIDL_user_allocate result rows");
    }
    pctbResultRows->cb = cb;
    ZeroMemory(pctbResultRows->pb, pctbResultRows->cb);

    pbOut = pctbResultRows->pb;

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "_EnumViewNext! Result Row data cb=0x%x @%x\n",
	    pctbResultRows->cb,
	    pctbResultRows->pb));

    for (pelt = aelt; pelt < peltEnd; pelt++)
    {
	pteltOut = (CERTTRANSDBRESULTROW *) pbOut;
	pbOut += sizeof(*pteltOut);
	ptcolOut = (CERTTRANSDBRESULTCOLUMN *) pbOut;
	pbOut += pelt->ccol * sizeof(*ptcolOut);

	pteltOut->rowid = pelt->rowid;
	pteltOut->ccol = pelt->ccol;

	pcolEnd = &pelt->acol[pelt->ccol];
	for (pcol = pelt->acol; pcol < pcolEnd; pcol++, ptcolOut++)
	{
	    ptcolOut->Type = pcol->Type;
	    ptcolOut->Index = pcol->Index;

	    if (NULL != pcol->pbValue)
	    {
		if ((DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY) ==
		     ptcolOut->Index)
		{
		    cbT = sizeof(BYTE);
		    CSASSERT(0 == *(DWORD *) pbOut);
		}
		else
		{
		    cbT = pcol->cbValue;
		    CopyMemory(pbOut, pcol->pbValue, cbT);
		}
		ptcolOut->cbValue = cbT;
		ptcolOut->obValue = SAFE_SUBTRACT_POINTERS(pbOut, (BYTE *) pteltOut);
		pbOut += DWORDROUND(cbT);
	    }
	}
	pteltOut->cbrow = SAFE_SUBTRACT_POINTERS(pbOut, (BYTE *) pteltOut);
    }

    // if past the end or at end of rowset, write an extra record containimg
    // the maximum element count.

    if (fNoMore)
    {
	pteltOut = (CERTTRANSDBRESULTROW *) pbOut;
	pbOut += sizeof(*pteltOut);
	pteltOut->rowid = pelt->rowid;
	pteltOut->ccol = pelt->ccol;
	pteltOut->cbrow = SAFE_SUBTRACT_POINTERS(pbOut, (BYTE *) pteltOut);
	CSASSERT(pteltOut->rowid == ~pteltOut->ccol);
	DBGPRINT((
		DBG_SS_CERTSRVI,
		"_EnumViewNext! celtMax=%d\n",
		pteltOut->rowid));
    }

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "_EnumViewNext! pbOut=%x/%x\n",
	    pbOut,
	    &pctbResultRows->pb[pctbResultRows->cb]));

    CSASSERT(&pctbResultRows->pb[pctbResultRows->cb] == pbOut);

    if (fNoMore)
    {
	hr = S_FALSE;
    }

error:
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "_EnumViewNext: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    if (fFetched)
    {
	HRESULT hr2;

	hr2 = pview->ReleaseResultRow(*pceltFetched, aelt);
	_PrintIfError(hr2, "ReleaseResultRow");
    }
    if (NULL != aelt)
    {
	LocalFree(aelt);
    }

    CertSrvExitServer(State);
    InterlockedDecrement(&m_cNext);
    return(hr);
}


STDMETHODIMP
CCertAdminD::CloseView(
    IN wchar_t const *pwszAuthority)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::CloseView(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	if (NULL == m_pView)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "No View");
	}

	m_pView->Release();
	m_pView = NULL;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::RevokeCertificate(
    /* [unique][in] */ USHORT const __RPC_FAR *pwszAuthority,
    /* [in, string, unique] */ USHORT const __RPC_FAR *pwszSerialNumber,
    /* [in] */ DWORD Reason,
    /* [in] */ FILETIME FileTime)
{
    HRESULT hr;
    DWORD ReqId;
    DWORD cbProp;
    DWORD Disposition;
    DWORD OldReason;
    ICertDBRow *prow = NULL;
    WCHAR const *pwszDisposition = NULL;
    WCHAR const *pwszDispT;
    BOOL fUnRevoke = FALSE;
    BOOL fRevokeOnHold = FALSE;
    WCHAR *pwszUserName = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_REVOKECERT, g_dwAuditFilter);
    LPWSTR pwszRequesterName = NULL;
    DWORD State = 0;
    BOOL fCommitted = FALSE;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::RevokeCertificate(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(pwszSerialNumber); // %1 serial no.
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AddData(Reason); // %2 reason
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	switch (Reason)
	{
	    case MAXDWORD:
		fUnRevoke = TRUE;
		break;

	    case CRL_REASON_CERTIFICATE_HOLD:
		fRevokeOnHold = TRUE;
		break;

	    case CRL_REASON_UNSPECIFIED:
	    case CRL_REASON_KEY_COMPROMISE:
	    case CRL_REASON_CA_COMPROMISE:
	    case CRL_REASON_AFFILIATION_CHANGED:
	    case CRL_REASON_SUPERSEDED:
	    case CRL_REASON_CESSATION_OF_OPERATION:
	    case CRL_REASON_REMOVE_FROM_CRL:
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Reason parameter");
	}

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, pwszSerialNumber, &prow);
	if (S_OK != hr)
	{
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		hr = E_INVALIDARG;		// Invalid Serial Number
	    }
	    _LeaveErrorStr(hr, "OpenRow", pwszSerialNumber);
	}

	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequesterName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pwszRequesterName);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _LeaveIfErrorStr(hr, "PKCSGetProperty", g_wszPropRequesterName);
	}

	hr = CheckOfficerRights(pwszRequesterName, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	cbProp = sizeof(Disposition);
	hr = prow->GetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cbProp,
			(BYTE *) &Disposition);
	_LeaveIfError(hr, "GetProperty");

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	switch (Disposition)
	{
	    HRESULT hr2;

	    case DB_DISP_CA_CERT:
		if (!IsRootCA(g_CAType))
		{
		    _LeaveError(hr, "non-root CA");
		}
		// FALLTHROUGH

	    case DB_DISP_ISSUED:
	    case DB_DISP_REVOKED:
		cbProp = sizeof(OldReason);
		hr2 = prow->GetProperty(
			g_wszPropRequestRevokedReason,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cbProp,
			(BYTE *) &OldReason);

		// Converted MDB databases have UNrevoked rows' RevokedReason
		// column set to zero (CRL_REASON_UNSPECIFIED).

		if (S_OK != hr2 ||
		    (DB_DISP_ISSUED == Disposition &&
		     CRL_REASON_UNSPECIFIED == OldReason))
		{
		    OldReason = MAXDWORD;
		}
		if (fRevokeOnHold &&
		    MAXDWORD != OldReason &&
		    CRL_REASON_CERTIFICATE_HOLD != OldReason)
		{
		    _LeaveError(hr, "already revoked: not on hold");
		}
		if (fUnRevoke && CRL_REASON_CERTIFICATE_HOLD != OldReason)
		{
		    _LeaveError(hr, "unrevoke: not on hold");
		}
		break;

	    default:
		_LeaveError(hr, "invalid disposition");
	}

	hr = PropSetRequestTimeProperty(prow, g_wszPropRequestRevokedWhen);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "PropSetRequestTimeProperty");
	}

	hr = prow->SetProperty(
			g_wszPropRequestRevokedEffectiveWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(FileTime),
			(BYTE const *) &FileTime);
	_LeaveIfError(hr, "SetProperty");

	hr = prow->SetProperty(
			g_wszPropRequestRevokedReason,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(Reason),
			(BYTE const *) &Reason);
	_LeaveIfError(hr, "SetProperty");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	pwszDispT = fUnRevoke? g_pwszUnrevokedBy : g_pwszRevokedBy;
	pwszDisposition = CoreBuildDispositionString(
					    pwszDispT,
					    pwszUserName,
					    NULL,
					    NULL,
					    S_OK,
					    FALSE);
	if (NULL == pwszDisposition)
	{
	    pwszDisposition = pwszDispT;
	}

	hr = prow->SetProperty(
			g_wszPropRequestDispositionMessage,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			MAXDWORD,
			(BYTE const *) pwszDisposition);
	_LeaveIfError(hr, "SetProperty");

	if (DB_DISP_CA_CERT != Disposition)
	{
	    Disposition = fUnRevoke? DB_DISP_ISSUED : DB_DISP_REVOKED;
	    hr = prow->SetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(Disposition),
			(BYTE const *) &Disposition);
	    _LeaveIfError(hr, "SetProperty");
	}

	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

	prow->GetRowId(&ReqId);
	ExitNotify(EXITEVENT_CERTREVOKED, ReqId, MAXDWORD);
	CoreLogRequestStatus(
			prow,
			MSG_DN_CERT_REVOKED,
			hr,
			pwszDisposition);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pwszRequesterName)
    {
        LocalFree(pwszRequesterName);
    }
    if (NULL != pwszDisposition && pwszDisposition != g_pwszRevokedBy)
    {
	LocalFree(const_cast<WCHAR *>(pwszDisposition));
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::IsValidCertificate(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszSerialNumber,
    /* [out] */ LONG __RPC_FAR *pRevocationReason,
    /* [out] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::IsValidCertificate(tid=%d, this=%x, serial=%ws)\n",
	GetCurrentThreadId(),
	this,
	pwszSerialNumber));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	CAuditEvent audit(0, g_dwAuditFilter);

	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = PKCSIsRevoked(
		    0,
		    pwszSerialNumber,
		    pRevocationReason,
		    pDisposition);
	_LeaveIfError(hr, "PKCSIsRevoked");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::IsValidCertificate(serial=%ws) --> %x, Reason=%u Disposition=%u\n",
	pwszSerialNumber,
	hr,
	*pRevocationReason,
	*pDisposition));

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ServerControl(
    IN  wchar_t const *pwszAuthority,
    IN  DWORD          dwControlFlags,
    OUT CERTTRANSBLOB *pctbOut)
{
    HRESULT hr;
    BOOL fBackupAccess = FALSE;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SHUTDOWN, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ServerControl(tid=%d, this=%x, Flags=0x%x)\n",
	GetCurrentThreadId(),
	this,
	dwControlFlags));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    switch (dwControlFlags)
    {
	case CSCONTROL_SUSPEND:
	case CSCONTROL_RESTART:
	    fBackupAccess = TRUE;
	    break;

	case CSCONTROL_SHUTDOWN:
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad control flags");
    }

    __try
    {
        hr = audit.AccessCheck(
                fBackupAccess?CA_ACCESS_OPERATOR:CA_ACCESS_ADMIN,
                audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(
            hr,
            fBackupAccess?
            "CAuditEvent::AccessCheck backup":
            "CAuditEvent::AccessCheck admin");

	switch (dwControlFlags)
	{
	    case CSCONTROL_SHUTDOWN:
		myRegisterMemFree(this, CSM_NEW | CSM_GLOBALDESTRUCTOR);

		hr = CertSrvLockServer(&State);
		_JumpIfError(hr, error, "CertSrvLockServer");

		// have message loop run shutdown code
		SendMessage(g_hwndMain, WM_STOPSERVER, 0, 0);

		// post, don't wait for shutdown
		PostMessage(g_hwndMain, WM_SYNC_CLOSING_THREADS, 0, 0);
		break;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ADMIN,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");


	myRegisterMemDump();
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::Ping(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::Ping2(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::Ping2(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetServerState(
    IN  WCHAR const *pwszAuthority,
    OUT DWORD       *pdwState)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetServerState(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	*pdwState = 0;
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

    *pdwState = 1;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupPrepare(
    IN WCHAR const  *pwszAuthority,
    IN unsigned long grbitJet,
    IN unsigned long dwBackupFlags,
    IN WCHAR const  *pwszBackupAnnotation,
    IN DWORD         dwClientIdentifier)
{
    HRESULT hr;
    CertSrv::CAuditEvent audit(SE_AUDITID_CERTSRV_BACKUPSTART,g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupPrepare(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	hr = audit.AddData(dwBackupFlags); //%1 backup type
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AccessCheck(
		CA_ACCESS_OPERATOR,
		audit.m_gcAuditSuccessOrFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	if (NULL != m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "Has Backup");
	}
	hr = g_pCertDB->OpenBackup(grbitJet, &m_pBackup);
	_LeaveIfError(hr, "OpenBackup");

	m_grbitBackup = grbitJet;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupEnd()
{
    HRESULT hr;
    CertSrv::CAuditEvent audit(SE_AUDITID_CERTSRV_BACKUPEND,g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupEnd(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = audit.AccessCheck(
		CA_ACCESS_OPERATOR,
		audit.m_gcAuditSuccessOrFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "No backup");
	}
	m_pBackup->Release();
	m_pBackup = NULL;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_GetDynamicFileList(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD iCert;
    DWORD iDelta;
    DWORD iDeltaMax;
    DWORD cwc;
    DWORD cwcRemain;
    DWORD cwcTotal;
    WCHAR const * const *papwszSrc;
    WCHAR const * const *ppwsz;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cwcRemain = *pcwcList;
    cwcTotal = 0;
    iDeltaMax = g_fDeltaCRLPublishDisabled? 0 : 1;

    for (iCert = 0; iCert < g_cCACerts; iCert++)
    {
	for (iDelta = 0; iDelta <= iDeltaMax; iDelta++)
	{
	    hr2 = PKCSGetCRLList(0 != iDelta, iCert, &papwszSrc);
	    if (S_OK != hr2)
	    {
		_PrintError2(hr2, "PKCSGetCRLList", hr2);
		continue;
	    }
	    for (ppwsz = papwszSrc; NULL != *ppwsz; ppwsz++)
	    {
		WCHAR const *pwsz = *ppwsz;

		// Just return local full path files:

		if (iswalpha(pwsz[0]) && L':' == pwsz[1] && L'\\' == pwsz[2])
		{
		    cwc = wcslen(pwsz) + 1;
		    if (NULL != pwszzList)
		    {
			DWORD cwcT;

			cwcT = min(cwc, cwcRemain);
			CopyMemory(pwszzList, *ppwsz, cwcT * sizeof(WCHAR));
			pwszzList += cwcT;
			if (cwc > cwcT)
			{
			    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
			    pwszzList = NULL;
			}
			cwcRemain -= cwcT;
		    }
		    cwcTotal += cwc;
		}
	    }
	}
    }

    // append an extra trailing L'\0'

    if (NULL != pwszzList)
    {
	if (1 <= cwcRemain)
	{
	    *pwszzList = L'\0';
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
    }
    cwcTotal++;

    *pcwcList = cwcTotal;
    _JumpIfError(hr, error, "Buffer Overflow");

error:
    CertSrvExitServer(State);
    return(hr);
}


typedef struct _DBTAG
{
    WCHAR const *pwszPath;
    WCHAR wcFileType;
} DBTAG;


DBTAG g_adbtag[] = {
    { g_wszDatabase,  CSBFT_CERTSERVER_DATABASE },
    { g_wszLogDir,    CSBFT_LOG_DIR },
    { g_wszSystemDir, CSBFT_CHECKPOINT_DIR },
};


CSBFT
BftClassify(
    IN WCHAR const *pwszFileName)
{
    WCHAR *pwszPath = NULL;
    WCHAR const *pwszExt;
    WCHAR *pwsz;
    DWORD i;
    CSBFT bft;

    // Do the easy cases first.

    pwszExt = wcsrchr(pwszFileName, L'.');
    if (NULL != pwszExt)
    {
	if (0 == lstrcmpi(pwszExt, L".pat"))
	{
	    bft = CSBFT_PATCH_FILE;
	    goto done;
	}
	if (0 == lstrcmpi(pwszExt, L".log"))
	{
	    bft = CSBFT_LOG;
	    goto done;
	}
	if (0 == lstrcmpi(pwszExt, L".edb"))
	{
	    // It's a database.  Find out which database it is.

	    for (i = 0; i < ARRAYSIZE(g_adbtag); i++)
	    {
		bft = g_adbtag[i].wcFileType;
		if ((bft & CSBFT_DATABASE_DIRECTORY) &&
		    0 == lstrcmpi(g_adbtag[i].pwszPath, pwszFileName))
		{
		    goto done;
		}
	    }
	}
    }

    // Ok, I give up.  We don't know anything about this file at all;
    // try to figure out what we can tell the caller about it.

    pwszPath = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(pwszFileName) + 1) * sizeof(WCHAR));
    if (NULL != pwszPath)
    {
	wcscpy(pwszPath, pwszFileName);
	pwsz = wcsrchr(pwszPath, L'\\');
	if (NULL != pwsz)
	{
	    *pwsz = L'\0';	// truncate to directory path
	}
	for (i = 0; i < ARRAYSIZE(g_adbtag); i++)
	{
	    bft = g_adbtag[i].wcFileType;
	    if (bft & CSBFT_DIRECTORY)
	    {
		// If this file's directory matches the directory we're
		// looking at, we know where it needs to go on the restore.

		if (0 == lstrcmpi(g_adbtag[i].pwszPath, pwszPath))
		{
		    goto done;
		}
	    }
	}
    }
    bft = CSBFT_UNKNOWN;

done:
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    return(bft);
}


HRESULT
CCertAdminD::_GetDatabaseLocations(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr = S_OK;
    DWORD cwc;
    DWORD cwcRemain;
    WCHAR *pwcRemain;
    DWORD i;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cwcRemain = *pcwcList;
    pwcRemain = pwszzList;

    cwc = 1;
    for (i = 0; i < ARRAYSIZE(g_adbtag); i++)
    {
	DWORD cwcT;

	cwcT = wcslen(g_adbtag[i].pwszPath) + 1;
	cwc += 1 + cwcT;
	if (NULL != pwcRemain && 0 < cwcRemain)
	{
	    *pwcRemain++ = g_adbtag[i].wcFileType;
	    cwcRemain--;
	    if (cwcT > cwcRemain)
	    {
		cwcT = cwcRemain;
	    }
	    CopyMemory(pwcRemain, g_adbtag[i].pwszPath, cwcT * sizeof(WCHAR));
	    pwcRemain += cwcT;
	    cwcRemain -= cwcT;
	}
    }
    if (NULL != pwcRemain)
    {
	if (0 < cwcRemain)
	{
	    *pwcRemain = L'\0';
	}
	if (cwc > *pcwcList)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
    }
    *pcwcList = cwc;
    _JumpIfError(hr, error, "Buffer Overflow");

error:
    CertSrvExitServer(State);
    return(hr);
}


STDMETHODIMP
CCertAdminD::RestoreGetDatabaseLocations(
    OUT WCHAR **ppwszDatabaseLocations,
    OUT LONG   *pcwcPaths)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::RestoreGetDatabaseLocations(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(MAXDWORD, ppwszDatabaseLocations, pcwcPaths);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszDatabaseLocations, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Convert UNC path to local full path, as in:
//	\\server\c$\foo... --> c:\foo...
// Note the server name need not match the current server name.

HRESULT
ConvertUNCToLocalPath(
    IN WCHAR const *pwszPath,
    OUT WCHAR **ppwszPathLocal)		// LocalAlloc
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    WCHAR const *pwc;

    *ppwszPathLocal = NULL;

    if (L'\\' != pwszPath[0] || L'\\' != pwszPath[1])
    {
	_JumpError(hr, error, "not a UNC path");
    }
    pwc = wcschr(&pwszPath[2], L'\\');
    if (NULL == pwc || !iswalpha(pwc[1]) || L'$' != pwc[2] || L'\\' != pwc[3])
    {
	_JumpError(hr, error, "bad-UNC path");
    }
    pwc++;

    *ppwszPathLocal = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(wcslen(pwc) + 1) * sizeof(WCHAR));
    if (NULL == *ppwszPathLocal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszPathLocal, pwc);

    CSASSERT(L'$' == (*ppwszPathLocal)[1]);
    (*ppwszPathLocal)[1] = L':';

    hr = S_OK;

error:
    return(hr);
}


// Convert local possibly annotated full paths to possibly annotated UNC, as:
//	[CSBFT_*]c:\foo... --> [CSBFT_*]\\server\c$\foo...

HRESULT
ConvertLocalPathsToMungedUNC(
    IN WCHAR const *pwszzFiles,
    IN BOOL fAnnotated,			// TRUE if already annotated
    IN WCHAR wcFileType,		// else Annotation WCHAR (if not L'\0')
    OUT DWORD *pcwc,
    OUT WCHAR **ppwszzFilesUNC)		// MIDL_user_allocate
{
    HRESULT hr;
    DWORD cwc;
    WCHAR const *pwsz;
    WCHAR *pwszDst;
    DWORD cfiles = 0;
    WCHAR *pwszzFilesUNC = NULL;

    *pcwc = 0;
    for (pwsz = pwszzFiles; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	if (fAnnotated)
	{
	    pwsz++;
	}
	if (!iswalpha(pwsz[0]) || L':' != pwsz[1] || L'\\' != pwsz[2])
	{
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "non-local path");
	}
	cfiles++;
    }
    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszzFiles) + 1;
    cwc += cfiles * (2 + wcslen(g_pwszServerName) + 1);
    if (!fAnnotated && 0 != wcFileType)
    {
	cwc += cfiles;			// Add munged CSBFT_* character
    }

    pwszzFilesUNC = (WCHAR *) MIDL_user_allocate(cwc * sizeof(WCHAR));
    if (NULL == pwszzFilesUNC)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "MIDL_user_allocate pwszzFiles");
    }

    pwszDst = pwszzFilesUNC;
    for (pwsz = pwszzFiles; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	if (fAnnotated)
	{
	    *pwszDst++ = *pwsz++;		// "CSBFT"
	}
	else
	if (0 != wcFileType)
	{
	    *pwszDst++ = BftClassify(pwsz);	// "CSBFT"
	}
	wcscpy(pwszDst, L"\\\\");		// "[CSBFT]\\"
	wcscat(pwszDst, g_pwszServerName);	// "[CSBFT]\\server"
	pwszDst += wcslen(pwszDst);
	*pwszDst++ = L'\\';			// "[CSBFT]\\server\"
	*pwszDst++ = *pwsz++;			// "[CSBFT]\\server\c"
	*pwszDst++ = L'$';			// "[CSBFT]\\server\c$"
	pwsz++;					// skip colon

	wcscpy(pwszDst, pwsz);			// "[CSBFT]\\server\c$\foo..."
	pwszDst += wcslen(pwszDst) + 1;
    }
    *pwszDst = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwszDst, pwszzFilesUNC) + 1 == cwc);

    *pcwc = cwc;
    *ppwszzFilesUNC = pwszzFilesUNC;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertAdminD::_BackupGetFileList(
    IN  DWORD   dwFileType,
    OUT WCHAR **ppwszzFiles,    // CoTaskMem*
    OUT LONG   *pcwcFiles)
{
    HRESULT hr;
    WCHAR *pwszzFiles = NULL;
    WCHAR *pwszzFilesUNC = NULL;
    DWORD cwcFiles = 0;
    DWORD cwc;
    BOOL fAnnotated = FALSE;
    DWORD State = 0;

    *ppwszzFiles = NULL;
    *pcwcFiles = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    if (NULL == m_pBackup && MAXDWORD != dwFileType && 0 != dwFileType)
    {
	hr = E_UNEXPECTED;
	_JumpIfError(hr, error, "No backup");
    }
    while (TRUE)
    {
	cwc = cwcFiles;
	if (CSBFT_CERTSERVER_DATABASE == dwFileType)
	{
	    hr = m_pBackup->GetDBFileList(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "GetDBFileList");
	}
	else if (CSBFT_LOG == dwFileType)
	{
	    hr = m_pBackup->GetLogFileList(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "GetLogFileList");
	}
	else if (MAXDWORD == dwFileType)
	{
	    hr = _GetDatabaseLocations(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "_GetDatabaseLocations");

	    fAnnotated = TRUE;
	}
	else if (0 == dwFileType)
	{
	    hr = _GetDynamicFileList(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "_GetDynamicFileList");
	}
	else
	{
	    CSASSERT(!"bad FileListtype");
	}

	if (NULL != pwszzFiles)
	{
	    break;
	}
	pwszzFiles = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszzFiles)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc pwszzFiles");
	}
	cwcFiles = cwc;
    }
    hr = ConvertLocalPathsToMungedUNC(
			pwszzFiles,
			fAnnotated,
			(WCHAR) dwFileType,
			&cwc,
			&pwszzFilesUNC);
    _JumpIfError(hr, error, "ConvertLocalPathsToMungedUNC");

    *ppwszzFiles = pwszzFilesUNC;
    *pcwcFiles = cwc;
    pwszzFilesUNC = NULL;

error:
    if (NULL != pwszzFilesUNC)
    {
	MIDL_user_free(pwszzFilesUNC);
    }
    if (NULL != pwszzFiles)
    {
	LocalFree(pwszzFiles);
    }
    CertSrvExitServer(State);
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupGetAttachmentInformation(
    OUT WCHAR **ppwszzDBFiles,
    OUT LONG   *pcwcDBFiles)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupGetAttachmentInformation(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(
			    CSBFT_CERTSERVER_DATABASE,
			    ppwszzDBFiles,
			    pcwcDBFiles);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszzDBFiles, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupGetBackupLogs(
    OUT WCHAR **ppwszzLogFiles,
    OUT LONG   *pcwcLogFiles)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupGetBackupLogs(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(CSBFT_LOG, ppwszzLogFiles, pcwcLogFiles);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszzLogFiles, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupGetDynamicFiles(
    OUT WCHAR **ppwszzFiles,
    OUT LONG   *pcwcFiles)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupGetDynamicFiles(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(0, ppwszzFiles, pcwcFiles);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszzFiles, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupOpenFile(
    IN  WCHAR const    *pwszPath,
    OUT unsigned hyper *pliLength)
{
    HRESULT hr;
    WCHAR *pwszPathLocal = NULL;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupOpenFile(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	hr = ConvertUNCToLocalPath(pwszPath, &pwszPathLocal);
	_LeaveIfError(hr, "ConvertUNCToLocalPath");

	hr = m_pBackup->OpenFile(pwszPathLocal, (ULARGE_INTEGER *) pliLength);
	_LeaveIfError(hr, "OpenFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    if (NULL != pwszPathLocal)
    {
	LocalFree(pwszPathLocal);
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupReadFile(
    OUT BYTE *pbBuffer,
    IN  LONG  cbBuffer,
    OUT LONG *pcbRead)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupReadFile(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	*pcbRead = cbBuffer;

	hr = m_pBackup->ReadFile((DWORD *) pcbRead, pbBuffer);
	_LeaveIfError(hr, "ReadFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupCloseFile()
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupCloseFile(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	hr = m_pBackup->CloseFile();
	_LeaveIfError(hr, "CloseFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupTruncateLogs()
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupTruncateLogs(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	WCHAR *apwsz[1];

	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	hr = m_pBackup->TruncateLog();
	_LeaveIfError(hr, "TruncateLog");

	apwsz[0] = wszREGDBLASTINCREMENTALBACKUP;
	hr = CertSrvSetRegistryFileTimeValue(
				    TRUE,
				    (JET_bitBackupIncremental & m_grbitBackup)?
					wszREGDBLASTINCREMENTALBACKUP :
					wszREGDBLASTFULLBACKUP,
				    (DWORD)((JET_bitBackupIncremental & m_grbitBackup)?
					0 : ARRAYSIZE(apwsz)),
				    apwsz);
	_PrintIfError(hr, "CertSrvSetRegistryFileTimeValue");
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ImportCertificate(
    IN wchar_t const *pwszAuthority,
    IN CERTTRANSBLOB *pctbCertificate,
    IN LONG Flags,
    OUT LONG *pRequestId)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CERT_CONTEXT const *pCert = NULL;
    WCHAR *pwszUserName = NULL;
    BOOL fAllowed = FALSE;
    CACTX *pCAContext;
    CAuditEvent audit(SE_AUDITID_CERTSRV_IMPORTCERT, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;
    DWORD Disposition;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ImportCertificate(tid=%d, this=%x, cb=%x)\n",
	GetCurrentThreadId(),
	this,
	pctbCertificate->cb));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    if (~(ICF_ALLOWFOREIGN | CR_IN_ENCODEMASK) & Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }
    if ((ICF_ALLOWFOREIGN & Flags) &&
	0 == (KRAF_ENABLEFOREIGN & g_KRAFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Foreign disabled");
    }
    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.AddData(
			pctbCertificate->pb,
			pctbCertificate->cb); // %1 Certificate
        _LeaveIfError(hr, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)0); // %2 dummy request ID, if access check fails
                                      // and a deny event is generated, we need the
                                      // right number of audit arguments
        _LeaveIfError(hr, "CAuditEvent::AddData");

        hr = audit.AccessCheck(
            CA_ACCESS_OFFICER,
            audit.m_gcNoAuditSuccess);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        pCert = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pctbCertificate->pb,
					pctbCertificate->cb);
        if (NULL == pCert)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _LeaveError(hr, "CertCreateCertificateContext");
        }

        // Be sure we issued this certificate before adding it to the database.

	Disposition = DB_DISP_ISSUED;
        hr = PKCSVerifyIssuedCertificate(pCert, &pCAContext);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "PKCSVerifyIssuedCertificate", NTE_BAD_SIGNATURE);
	    if (0 == (ICF_ALLOWFOREIGN & Flags))
	    {
		_LeaveError2(
			hr,
			"PKCSVerifyIssuedCertificate",
			NTE_BAD_SIGNATURE);
	    }
	    Disposition = DB_DISP_FOREIGN;
	    pCAContext = NULL;
	}

	cbHash = sizeof(abHash);
	if (!CertGetCertificateContextProperty(
					pCert,
					CERT_SHA1_HASH_PROP_ID,
					abHash,
					&cbHash))
	{
	    hr = myHLastError();
	    _LeaveError(hr, "CertGetCertificateContextProperty");
	}

	hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
	_LeaveIfError(hr, "MultiByteIntegerToBstr");

	hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY |
			    PROPOPEN_CERTHASH |
			    PROPTABLE_REQCERT,
			0,		// RequestId
			strHash,
			&prow);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _LeaveIfErrorStr(hr, "OpenRow", strHash);

	    fCommitted = TRUE;	// open for read-only: skip rollback
	    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
	    _LeaveErrorStr2(
			hr,
			"Cert exists",
			strHash,
			HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
	}

        // okay, we've got valid data. Time to write to the Database.

        hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
        _LeaveIfError(hr, "OpenRow");

        // set request id
        hr = prow->GetRowId((DWORD *) pRequestId);
        _LeaveIfError(hr, "GetRowId");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = prow->SetProperty(
                g_wszPropRequesterName,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                MAXDWORD,
                (BYTE const *) pwszUserName);
	_LeaveIfError(hr, "SetProperty(requester)");

	hr = prow->SetProperty(
                g_wszPropCallerName,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                MAXDWORD,
                (BYTE const *) pwszUserName);
	_LeaveIfError(hr, "SetProperty(caller)");

	hr = PKCSParseImportedCertificate(
				    Disposition,
				    prow,
				    pCAContext,
				    pCert);
	_LeaveIfError(hr, "PKCSParseImportedCertificate");

	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

    audit.DeleteLastData(); // remove dummy request ID added above
    hr = audit.AddData((DWORD) *pRequestId); // %2 request ID
    _LeaveIfError(hr, "CAuditEvent::AddData");

    hr = audit.CachedGenerateAudit();
    _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ImportKey(
    IN wchar_t const *pwszAuthority,
    IN DWORD RequestId,
    IN wchar_t const *pwszCertHash,
    IN DWORD Flags,
    IN CERTTRANSBLOB *pctbKey)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_IMPORTKEY, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    CERT_CONTEXT const *pCert = NULL;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ImportKey(tid=%d, this=%x, cb=%x)\n",
	GetCurrentThreadId(),
	this,
	pctbKey->cb));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    if (~(IKF_OVERWRITE | CR_IN_ENCODEMASK) & Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }

    __try
    {
	CRYPT_ATTR_BLOB BlobEncrypted;
	DWORD cb;

        hr = audit.AddData(RequestId); // %1 request ID
        _LeaveIfError(hr, "AddData");

        hr = audit.AccessCheck(
                CA_ACCESS_OFFICER,
                audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	if (MAXDWORD == RequestId)
	{
	    RequestId = 0;
	}
	if (0 == RequestId && NULL == pwszCertHash)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "pwszCertHash NULL");
	}

	hr = g_pCertDB->OpenRow(
			PROPTABLE_REQCERT |
			    (NULL != pwszCertHash? PROPOPEN_CERTHASH : 0),
			RequestId,
			pwszCertHash,
			&prow);
	_LeaveIfErrorStr(hr, "OpenRow", pwszCertHash);

	BlobEncrypted.cbData = pctbKey->cb;
	BlobEncrypted.pbData = pctbKey->pb;

	cb = 0;
	hr = prow->GetProperty(
			    g_wszPropRequestRawArchivedKey,
			    PROPTYPE_BINARY |
				PROPCALLER_SERVER |
				PROPTABLE_REQUEST,
			    &cb,
			    NULL);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _LeaveIfErrorStr(hr, "OpenRow", pwszCertHash);
	}
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbCert,
		    (BYTE **) &pbCert);
	_LeaveIfError(hr, "PKCSGetProperty(cert)");

        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
        if (NULL == pCert)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _LeaveError(hr, "CertCreateCertificateContext");
        }

	hr = PKCSArchivePrivateKey(
				prow,
				CERT_V1 == pCert->pCertInfo->dwVersion,
				(IKF_OVERWRITE & Flags)? TRUE : FALSE,
				&BlobEncrypted,
				NULL);
	_LeaveIfError2(
		hr,
		"PKCSArchivePrivateKey",
		HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));

        hr = prow->CommitTransaction(TRUE);
        _LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

        hr = audit.CachedGenerateAudit();
        _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetCASecurity(
    IN WCHAR const    *pwszAuthority,
    OUT CERTTRANSBLOB *pctbSD)   // CoTaskMem*
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    // init
    pctbSD->pb = NULL;
    pctbSD->cb = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetCASecurity(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	// get current SD:
	hr = g_CASD.LockGet(&pSD); // no free
	_LeaveIfError(hr, "CProtectedSecurityDescriptor::LockGet");

	pctbSD->cb = GetSecurityDescriptorLength(pSD);
	pctbSD->pb = (BYTE *) MIDL_user_allocate(pctbSD->cb);
	if (NULL == pctbSD->pb)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "MIDL_user_allocate");
	}
	myRegisterMemFree(pctbSD->pb, CSM_MIDLUSERALLOC);
	CopyMemory(pctbSD->pb, pSD, pctbSD->cb);

	hr = g_CASD.Unlock();
	_LeaveIfError(hr, "CProtectedSecurityDescriptor::Unlock");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return hr;
}


STDMETHODIMP
CCertAdminD::SetCASecurity(
    IN WCHAR const   *pwszAuthority,
    IN CERTTRANSBLOB *pctbSD)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) pctbSD->pb;
    LPWSTR pwszSD = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETSECURITY, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
        s_ssAdmin,
        "CCertAdminD::SetCASecurity(tid=%d, this=%x)\n",
        GetCurrentThreadId(),
        this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
    hr = audit.AddData(pctbSD->pb, pctbSD->cb); // %1 dump permissions as blob, we
                                          // don't want to parse the blob unless
                                          // access check succeeds
    _LeaveIfError(hr, "CAuditEvent::AddData");

    hr = audit.AccessCheck(
        CA_ACCESS_ADMIN,
        audit.m_gcNoAuditSuccess);
    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

    hr = CCertificateAuthoritySD::ConvertToString(pSD, pwszSD);
    _LeaveIfError(hr, "CAuditEvent::ConvertToString");

    audit.DeleteLastData(); // remove permissions blob to add a human friendly SD dump
    hr = audit.AddData(pwszSD);
    _LeaveIfError(hr, "CAuditEvent::AddData");

    hr = g_CASD.Set(pSD, g_fUseDS?true:false);
    _LeaveIfError(hr, "CProtectedSecurityDescriptor::Set");

    if (g_OfficerRightsSD.IsEnabled())
    {
        // adjust officer rights to match new CA SD; persistently save it
        hr = g_OfficerRightsSD.Adjust(pSD);
        _LeaveIfError(hr, "CProtectedSecurityDescriptor::Adjust");

        hr = g_OfficerRightsSD.Save();
        _LeaveIfError(hr, "CProtectedSecurityDescriptor::Save");
    }

    hr = g_CASD.Save();
    _LeaveIfError(hr, "CProtectedSecurityDescriptor::Save");

    hr = audit.CachedGenerateAudit();
    _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE) == hr)
    {
        LogEventString(
            EVENTLOG_ERROR_TYPE,
            MSG_E_CANNOT_WRITE_TO_DS,
            g_wszCommonName);
    }
    else
    {
        if(S_OK != hr)
        {
            LogEventHResult(
                EVENTLOG_ERROR_TYPE,
                MSG_E_CANNOT_SET_PERMISSIONS,
                hr);
        }
    }

    LOCAL_FREE(pwszSD);
    CertSrvExitServer(State);
    return hr;
}

// Constructor
CCertAdminD::CCertAdminD() : m_cRef(1), m_cNext(0)
{
    InterlockedIncrement(&g_cAdminComponents);
    m_pEnumCol = NULL;
    m_pView = NULL;
    m_pBackup = NULL;
}


// Destructor
CCertAdminD::~CCertAdminD()
{
    InterlockedDecrement(&g_cAdminComponents);
    if (NULL != m_pEnumCol)
    {
	m_pEnumCol->Release();
	m_pEnumCol = NULL;
    }
    if (NULL != m_pView)
    {
	m_pView->Release();
	m_pView = NULL;
    }
    if (NULL != m_pBackup)
    {
	m_pBackup->Release();
	m_pBackup = NULL;
    }
}


// IUnknown implementation
STDMETHODIMP
CCertAdminD::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertAdminD *>(this);
    }
    else if (iid == IID_ICertAdminD)
    {
	*ppv = static_cast<ICertAdminD *>(this);
    }
    else if (iid == IID_ICertAdminD2)
    {
	*ppv = static_cast<ICertAdminD2 *>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CCertAdminD::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertAdminD::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}



CAdminFactory::~CAdminFactory()
{
    if (m_cRef != 0)
    {
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CAdminFactory has %d instances left over\n",
	    m_cRef));
    }
}

// Class factory IUnknown implementation
STDMETHODIMP
CAdminFactory::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
	*ppv = static_cast<IClassFactory*>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CAdminFactory::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CAdminFactory::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
	return(0);
    }
    return(cRef);
}


// IClassFactory implementation
STDMETHODIMP
CAdminFactory::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    CCertAdminD *pA;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
	hr = CLASS_E_NOAGGREGATION;
	_JumpError(hr, error, "pUnknownOuter");
    }

    // Create component.

    pA = new CCertAdminD;
    if (pA == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "out of memory");
    }

    // Get the requested interface.

    hr = pA->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)

    pA->Release();

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// LockServer
STDMETHODIMP
CAdminFactory::LockServer(
    BOOL bLock)
{
    if (bLock)
    {
	InterlockedIncrement(&g_cAdminServerLocks);
    }
    else
    {
	InterlockedDecrement(&g_cAdminServerLocks);
    }
    return(S_OK);
}


STDMETHODIMP
CAdminFactory::CanUnloadNow()
{
    if (g_cAdminComponents || g_cAdminServerLocks)
    {
        return(S_FALSE);
    }
    return(S_OK);
}


STDMETHODIMP
CAdminFactory::StartFactory()
{
    HRESULT hr;

    g_pIAdminFactory = new CAdminFactory();
    if (NULL == g_pIAdminFactory)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "alloc CAdminFactory");
    }

    hr = CoRegisterClassObject(
                      CLSID_CCertAdminD,
                      static_cast<IUnknown *>(g_pIAdminFactory),
                      CLSCTX_LOCAL_SERVER,
                      REGCLS_MULTIPLEUSE,
                      &g_dwAdminRegister);
    _JumpIfError(hr, error, "CoRegisterClassObject");

error:
    if (S_OK != hr)
    {
	CAdminFactory::StopFactory();
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
CAdminFactory::StopFactory()
{
    HRESULT hr;

    if (0 != g_dwAdminRegister)
    {
        hr = CoRevokeClassObject(g_dwAdminRegister);
	_PrintIfError(hr, "CoRevokeClassObject");
        g_dwAdminRegister = 0;
    }
    if (NULL != g_pIAdminFactory)
    {
        g_pIAdminFactory->Release();
        g_pIAdminFactory = NULL;
    }
}


STDMETHODIMP
CCertAdminD::GetAuditFilter(
    IN wchar_t const *pwszAuthority,
    OUT DWORD        *pdwFilter)
{
    HRESULT hr;
    DWORD State = 0;
    CAuditEvent audit(0, g_dwAuditFilter);

    *pdwFilter = 0;

    if (!g_fAdvancedServer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "g_fAdvancedServer");
    }

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.AccessCheck(
		        CA_ACCESS_ALLREADROLES,
		        audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        *pdwFilter = g_dwAuditFilter;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetAuditFilter(
    IN wchar_t const *pwszAuthority,
    IN DWORD          dwFilter)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETAUDITFILTER, g_dwAuditFilter);
    DWORD State = 0;

    if (!g_fAdvancedServer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "g_fAdvancedServer");
    }

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.AddData(dwFilter); // %1 filter
        _LeaveIfError(hr, "AddParam");

        hr = audit.AccessCheck(
            CA_ACCESS_AUDITOR,
            audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        // save the audit filter using a dummy audit object
        {
            CAuditEvent dummyaudit(0, dwFilter);

            hr = dummyaudit.SaveFilter(g_wszSanitizedName);
            _LeaveIfError(hr, "CAuditEvent::SaveFilter");
        }
        g_dwAuditFilter = dwFilter;

        // we can't catch service start/stop events generated
        // by SCM, so we need to update the SACL on the service
        
        hr = UpdateServiceSacl(g_dwAuditFilter&AUDIT_FILTER_STARTSTOP);
        _LeaveIfError(hr, "UpdateServiceSacl");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetOfficerRights(
    IN  wchar_t const *pwszAuthority,
    OUT BOOL *pfEnabled,
    OUT CERTTRANSBLOB *pctbSD)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    pctbSD->pb = NULL;
    pctbSD->cb = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetOfficerRights(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    if (!g_fAdvancedServer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "g_fAdvancedServer");
    }

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
        hr = audit.AccessCheck(
		        CA_ACCESS_ALLREADROLES,
		        audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        *pfEnabled = g_OfficerRightsSD.IsEnabled();

        // return the security descriptor only if the feature is enabled

        if (g_OfficerRightsSD.IsEnabled())
        {
            // get current SD:
            hr = g_OfficerRightsSD.LockGet(&pSD); // no free
            _LeaveIfError(hr, "CProtectedSecurityDescriptor::LockGet");

	    pctbSD->cb = GetSecurityDescriptorLength(pSD);
	    pctbSD->pb = (BYTE *) MIDL_user_allocate(pctbSD->cb);
	    if (NULL == pctbSD->pb)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "MIDL_user_allocate");
	    }
	    myRegisterMemFree(pctbSD->pb, CSM_MIDLUSERALLOC);
	    CopyMemory(pctbSD->pb, pSD, pctbSD->cb);

            hr = g_OfficerRightsSD.Unlock();
            _LeaveIfError(hr, "CProtectedSecurityDescriptor::Unlock");
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return hr;

}


STDMETHODIMP
CCertAdminD::SetOfficerRights(
    IN wchar_t const *pwszAuthority,
    IN BOOL fEnable,
    IN CERTTRANSBLOB *pctbSD)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pNewOfficerSD = (PSECURITY_DESCRIPTOR) pctbSD->pb;
    PSECURITY_DESCRIPTOR pCASD = NULL;
    LPWSTR pwszSD = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETOFFICERRIGHTS, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetOfficerRights(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    if (!g_fAdvancedServer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "g_fAdvancedServer");
    }
    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {

    hr = audit.AddData(fEnable?true:false); // %1 Enable restrictions?
    _LeaveIfError(hr, "CAuditEvent::AddData");

    if(fEnable)
    {
        hr = audit.AddData(pctbSD->pb, pctbSD->cb); // %2 new permissions; add as 
                                                    // blob, we don't convert to string
                                                    // unless access check passes
        _LeaveIfError(hr, "CAuditEvent::AddData");
    }
    else
    {
        hr = audit.AddData(L"");    // %2 no permissions if disabling 
                                    // the officer restrictions
        _LeaveIfError(hr, "CAuditEvent::AddData");
    }

    hr = audit.AccessCheck(
            CA_ACCESS_ADMIN,
            audit.m_gcNoAuditSuccess);
    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

	g_OfficerRightsSD.SetEnable(fEnable);

	// ignore new security descriptor if asked to turn officer rights off

	if (fEnable)
	{
	    hr = g_CASD.LockGet(&pCASD); // no free
	    _LeaveIfError(hr, "CProtectedSecurityDescriptor::LockGet");

	    // adjust new officer rights based on the CA SD and set the
	    // officer rights SD to the new SD

	    hr = g_OfficerRightsSD.Merge(pNewOfficerSD, pCASD);
	    _LeaveIfError(hr, "COfficerRightsSD::Merge");

	    hr = g_CASD.Unlock();
	    _LeaveIfError(hr, "CProtectedSecurityDescriptor::Unlock");
	}

	// persistent save to registry

	hr = g_OfficerRightsSD.Save();
	_LeaveIfError(hr, "CProtectedSecurityDescriptor::Save");

    if(fEnable)
    {
        hr = COfficerRightsSD::ConvertToString(pNewOfficerSD, pwszSD);
        _LeaveIfError(hr, "COfficerRightsSD::ConvertToString");
        audit.DeleteLastData(); // remove permissions blob
        hr = audit.AddData(pwszSD); // %2 add human-friend permissions string
        _LeaveIfError(hr, "CAuditEvent::AddData");
    }

    hr = audit.CachedGenerateAudit();
    _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    LOCAL_FREE(pwszSD);
    CertSrvExitServer(State);
    return hr;
}


STDMETHODIMP
CCertAdminD::GetConfigEntry(
    wchar_t const *pwszAuthority,
    wchar_t const *pwszNodePath,
    wchar_t const *pwszEntry,
    VARIANT *pVariant)
{
    HRESULT hr;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetConfigEntry(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); // allow empty/null name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = g_ConfigStorage.GetEntry(
			EmptyString(pwszAuthority)?
			    NULL : g_wszSanitizedName, // allow empty/null name
			pwszNodePath,
			pwszEntry,
			pVariant);
	_LeaveIfError2(
		hr,
		"CConfigStorage::GetConfigEntry",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	myRegisterMemFree(pVariant, CSM_VARIANT);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return hr;
}


STDMETHODIMP
CCertAdminD::SetConfigEntry(
    wchar_t const *pwszAuthority,
    wchar_t const *pwszNodePath,
    wchar_t const *pwszEntry,
    VARIANT *pVariant)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETCONFIGENTRY, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetConfigEntry(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); // allow empty/null name
    _JumpIfError(hr, error, "CheckAuthorityName");

    hr = audit.AddData(pwszNodePath); // %1 node
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(pwszEntry); // %2 entry
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(L""); // %3 empty data, we don't process the variant
                             // unless the access check passes
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    __try
    {
	hr = audit.AccessCheck(
		CA_ACCESS_ADMIN,
		audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = g_ConfigStorage.SetEntry(
		    EmptyString(pwszAuthority)?
			NULL : g_wszSanitizedName, // allow empty/null name
		    pwszNodePath,
		    pwszEntry,
		    pVariant);
	_LeaveIfError(hr, "CConfigStorage::SetConfigEntry");

	// postpone adding the actual data to allow set entry to validate it
	
	audit.DeleteLastData();
	hr = audit.AddData(
		    pVariant, // %3 value
		    true); // true means convert % chars found in strings to %% (bug# 326248)
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return hr;
}


STDMETHODIMP
CCertAdminD::GetMyRoles(
    IN wchar_t const *pwszAuthority,
    OUT LONG         *pdwRoles)
{
    HRESULT hr;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD dwRoles = 0;
    DWORD State = 0;

    *pdwRoles = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.GetMyRoles(&dwRoles);
        _LeaveIfError(hr, "CAuditEvent::GetMyRoles");

        *pdwRoles = dwRoles;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return(hr);
}


HRESULT
adminDeleteRow(
    IN DWORD dwRowId,
    IN DWORD dwPropTable)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BOOL fCommitted = FALSE;

    hr = g_pCertDB->OpenRow(
			PROPOPEN_DELETE | dwPropTable,
			dwRowId,
			NULL,
			&prow);
    _JumpIfError2(hr, error, "OpenRow", CERTSRV_E_PROPERTY_EMPTY);

    hr = prow->Delete();
    _JumpIfError(hr, error, "Delete");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    return(hr);
}


HRESULT
adminDeleteByRowId(
    IN DWORD dwRowId,
    IN DWORD dwPropTable,
    OUT LONG *pcDeleted)
{
    HRESULT hr;
    LONG cDeleted = 0;
    LONG cDeletedExt = 0;
    LONG cDeletedAttr = 0;

    *pcDeleted = 0;

    if (PROPTABLE_REQCERT == dwPropTable)
    {
	hr = adminDeleteByRowId(dwRowId, PROPTABLE_EXTENSION, &cDeletedExt);
	_JumpIfError(hr, error, "adminDeleteByRowId(ext)");

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "adminDeleteByRowId(Rowid=%u) deleted %u extension rows\n",
	    dwRowId,
	    cDeletedExt));

	hr = adminDeleteByRowId(dwRowId, PROPTABLE_ATTRIBUTE, &cDeletedAttr);
	_JumpIfError(hr, error, "adminDeleteByRowId(attrib)");

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "adminDeleteByRowId(Rowid=%u) deleted %u attribute rows\n",
	    dwRowId,
	    cDeletedAttr));
    }
    while (TRUE)
    {
	hr = adminDeleteRow(dwRowId, dwPropTable);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "adminDeleteByRowId");

	cDeleted++;
    }
    if (0 == cDeleted && 0 != (cDeletedExt + cDeletedAttr))
    {
	cDeleted++;
    }
    hr = S_OK;

error:
    *pcDeleted += cDeleted;
    return(hr);
}


#define ICOLDEL_DATE		0
#define ICOLDEL_DISPOSITION	1

HRESULT
adminDeleteRowsFromQuery(
    IN DWORD dwPropTable,
    IN DWORD DateColumn,
    IN DWORD DispositionColumn,
    IN BOOL fRequest,
    IN FILETIME const *pft,
    OUT LONG *pcDeleted)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[1];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD celtFetched;
    DWORD i;
    BOOL fEnd;
    CERTDBRESULTROW aResult[10];
    BOOL fResultActive = FALSE;
    DWORD acol[2];
    DWORD ccol;
    DWORD cDeleted = 0;

    *pcDeleted = 0;

    // Set up restrictions as follows:

    pcvr = acvr;

    // DateColumn < *pft

    pcvr->ColumnIndex = DateColumn;
    pcvr->SeekOperator = CVR_SEEK_LT;
    pcvr->SortOrder = CVR_SORT_ASCEND;
    pcvr->pbValue = (BYTE *) pft;
    pcvr->cbValue = sizeof(*pft);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    ccol = 0;
    acol[ccol++] = DateColumn;
    if (0 != DispositionColumn)
    {
	acol[ccol++] = DispositionColumn;
    }

    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ccol,
			acol,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    fEnd = FALSE;
    while (!fEnd)
    {
	hr = pView->Next(ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    fEnd = TRUE;
	    if (0 == celtFetched)
	    {
		break;
	    }
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "Next");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) >= celtFetched);

	for (i = 0; i < celtFetched; i++)
	{
	    BOOL fDelete = TRUE;
	
	    CERTDBRESULTROW *pResult = &aResult[i];

	    CSASSERT(ccol == pResult->ccol);

	    if (0 != DispositionColumn)
	    {
		DWORD Disposition;

		CSASSERT(NULL != pResult->acol[ICOLDEL_DISPOSITION].pbValue);
		CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLDEL_DISPOSITION].Type));
		CSASSERT(sizeof(Disposition) == pResult->acol[ICOLDEL_DISPOSITION].cbValue);
		Disposition = *(DWORD *) pResult->acol[ICOLDEL_DISPOSITION].pbValue;

		if (fRequest)
		{
		    // Delete only pending and failed requests

		    if (DB_DISP_PENDING != Disposition &&
			DB_DISP_LOG_FAILED_MIN > Disposition)
		    {
			fDelete = FALSE;
		    }
		}
		else
		{
		    // Delete only issued and revoked certs

		    if (DB_DISP_LOG_MIN > Disposition ||
			DB_DISP_LOG_FAILED_MIN <= Disposition)
		    {
			fDelete = FALSE;
		    }
		}
	    }

	    CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLDEL_DATE].Type));

	    // If the date column is missing, delete the row.

#ifdef DBG_CERTSRV_DEBUG_PRINT
	    if (NULL != pResult->acol[ICOLDEL_DATE].pbValue &&
		sizeof(FILETIME) == pResult->acol[ICOLDEL_DATE].cbValue)
	    {
		WCHAR *pwszTime = NULL;

		myGMTFileTimeToWszLocalTime(
			    (FILETIME *) pResult->acol[ICOLDEL_DATE].pbValue,
			    TRUE,
			    &pwszTime);

		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "adminDeleteRowsFromQuery(%ws)\n",
		    pwszTime));
		if (NULL != pwszTime)
		{
		    LocalFree(pwszTime);
		}
	    }
#endif // DBG_CERTSRV_DEBUG_PRINT

	    if (fDelete)
	    {
		LONG cDelT;
		
		hr = adminDeleteByRowId(pResult->rowid, dwPropTable, &cDelT);
		_JumpIfError(hr, error, "adminDeleteByRowId");

		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "adminDeleteByRowId(Rowid=%u) deleted %u Query rows\n",
		    pResult->rowid,
		    cDelT));

		cDeleted += cDelT;
	    }
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    hr = S_OK;

error:
    *pcDeleted = cDeleted;
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOLDEL_DATE
#undef ICOLDEL_DISPOSITION


STDMETHODIMP
CCertAdminD::DeleteRow(
    IN wchar_t const *pwszAuthority,
    IN DWORD          dwFlags,		// CDR_*
    IN FILETIME       FileTime,
    IN DWORD          dwTable,		// CVRC_TABLE_*
    IN DWORD          dwRowId,
    OUT LONG         *pcDeleted)
{
    HRESULT hr;
    DWORD dwPropTable;
    CAuditEvent audit(SE_AUDITID_CERTSRV_DELETEROW, g_dwAuditFilter);
    DWORD DateColumn;
    DWORD DispositionColumn;
    BOOL fRequest;
    DWORD State = 0;

    *pcDeleted = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {

    hr = audit.AddData(dwTable); // %1 table ID
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    if (0 == dwRowId)
    {
        hr = audit.AddData(FileTime); // %2 filter (time)
        _JumpIfError(hr, error, "CAuditEvent::AddData");
	
        hr = audit.AddData((DWORD)0); // %3 rows deleted
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        // bulk deletion -- must be local admin	
	
        hr = audit.AccessCheck(
                CA_ACCESS_LOCALADMIN,
                audit.m_gcNoAuditSuccess);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}
	else
	{
        hr = audit.AddData(dwRowId); // %2 filter (request ID)
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)0); // %3 rows deleted
        _JumpIfError(hr, error, "CAuditEvent::AddData");

	    // individual deletion -- CA admin suffices

	    hr = audit.AccessCheck(
                CA_ACCESS_ADMIN,
                audit.m_gcNoAuditSuccess);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	hr = E_INVALIDARG;
	if ((0 == FileTime.dwLowDateTime && 0 == FileTime.dwHighDateTime) ^
	    (0 != dwRowId))
	{
	    _LeaveError(hr, "row OR date required");
	}
	DateColumn = 0;
	DispositionColumn = 0;
	fRequest = FALSE;
	switch (dwTable)
	{
	    case CVRC_TABLE_REQCERT:
		dwPropTable = PROPTABLE_REQCERT;
		switch (dwFlags)
		{
		    case CDR_EXPIRED:
			DateColumn = DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE;
			DispositionColumn = DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION;
			break;

		    case CDR_REQUEST_LAST_CHANGED:
			DateColumn = DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN;
			DispositionColumn = DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION;
			fRequest = TRUE;
			break;

		    case 0:
			break;

		    default:
			_LeaveError(hr, "dwFlags");
			break;
		}
		break;

	    case CVRC_TABLE_EXTENSIONS:
		if (0 == dwRowId)
		{
		    _LeaveError(hr, "no date field in Extension table");
		}
		if (0 != dwFlags)
		{
		    _LeaveError(hr, "dwFlags");
		}
		dwPropTable = PROPTABLE_EXTENSION;
		break;

	    case CVRC_TABLE_ATTRIBUTES:
		if (0 == dwRowId)
		{
		    _LeaveError(hr, "no date field in Request Attribute table");
		}
		if (0 != dwFlags)
		{
		    _LeaveError(hr, "dwFlags");
		}
		dwPropTable = PROPTABLE_ATTRIBUTE;
		break;

	    case CVRC_TABLE_CRL:
		dwPropTable = PROPTABLE_CRL;
		switch (dwFlags)
		{
		    case CDR_EXPIRED:
			DateColumn = DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE;
			break;

		    case 0:
			break;

		    default:
			_LeaveError(hr, "dwFlags");
			break;
		}
		DateColumn = DTI_CRLTABLE | DTL_NEXTUPDATEDATE;
		break;

	    default:
		_LeaveError(hr, "dwTable");
	}
	if (0 != dwRowId)
	{
	    hr = adminDeleteByRowId(dwRowId, dwPropTable, pcDeleted);
	    _LeaveIfError(hr, "adminDeleteByRowId");

	    DBGPRINT((
		DBG_SS_CERTSRV,
		"adminDeleteByRowId(Rowid=%u) deleted %u rows\n",
		dwRowId,
		*pcDeleted));
	}
	else
	{
	    CSASSERT(0 != DateColumn);

	    hr = adminDeleteRowsFromQuery(
				    dwPropTable,
				    DateColumn,
				    DispositionColumn,
				    fRequest,
				    &FileTime,
				    pcDeleted);
	    _LeaveIfError(hr, "adminDeleteRowsFromQuery");
	}

	audit.DeleteLastData();
    hr = audit.AddData((DWORD)*pcDeleted); // %3 rows deleted
	_JumpIfError(hr, error, "CAuditEvent::AddData");

	hr = audit.CachedGenerateAudit();
	_JumpIfError(hr, error, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\callback.cpp ===
//+--------------------------------------------------------------------------
// File:        callback.cpp
// Contents:    access check callback
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include "csext.h"
#include "certsd.h"
#include <winldap.h>
#include <limits.h>
#include "csprop.h"
#include "sid.h"
#include <authzi.h>

namespace CertSrv
{

HRESULT GetAccountSid(
    IN LPWSTR pwszName,
    PSID *ppSid)
{
    HRESULT hr = S_OK;
    DWORD cbSid = 0;
    DWORD cbDomainName = 0;
    SID_NAME_USE use;
    LPWSTR pwszDomainName = NULL;
    
    *ppSid = NULL;

    if(!pwszName || L'\0'== pwszName[0])
    {
        hr = GetEveryoneSID(ppSid);
        _JumpIfError(hr, error, "GetEveryoneSID");
    }
    else
    {

        LookupAccountName(
                NULL,
                pwszName,
                NULL,
                &cbSid,
                NULL,
                &cbDomainName,
                &use);
    
        if(ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            hr = myHError(GetLastError()); 
            _JumpError(hr, error, "LookupAccountName");
        }

        *ppSid = (PSID)LocalAlloc(LMEM_FIXED, cbSid);
        if(!*ppSid)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        pwszDomainName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
            cbDomainName*sizeof(WCHAR));
        if(!pwszDomainName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if(!LookupAccountName(
                NULL,
                pwszName,
                *ppSid,
                &cbSid,
                pwszDomainName,
                &cbDomainName,
                &use))
        {
            hr = myHError(GetLastError()); 
            _JumpError(hr, error, "LookupAccountName");
        }
    }

    hr = S_OK;

error:
    if(S_OK!=hr)
    {
        if(*ppSid)
        {
            LocalFree(*ppSid);
        }
        if(pwszDomainName)
        {
            LocalFree(pwszDomainName);
        }
    }
    return hr;
}

BOOL
CallbackAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable)
{
    HRESULT hr = S_OK;
    LPWSTR pwszSamName = (LPWSTR)pArgs;// requester name is passed in to
                                        // AuthzAccessCheck in NT4 style form
                                        // "DomainNetbiosName\RequesterSAMName"
    PSID pSid = NULL, pClientSid = NULL, pCallerSid = NULL;
    PSID pEveryoneSid = NULL;
    PTOKEN_GROUPS pGroups = NULL;
    ACCESS_ALLOWED_CALLBACK_ACE* pCallbackAce = 
        (ACCESS_ALLOWED_CALLBACK_ACE*)pAce;
    PSID_LIST pSidList = (PSID_LIST) (((BYTE*)&pCallbackAce->SidStart)+
        GetLengthSid(&pCallbackAce->SidStart));
    DWORD cSids, cClientSids;

    CSASSERT(
        ACCESS_ALLOWED_CALLBACK_ACE_TYPE == pAce->AceType ||
        ACCESS_DENIED_CALLBACK_ACE_TYPE  == pAce->AceType);

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

    SetLastError(ERROR_SUCCESS);

    // get the SID for the requester
    hr = GetAccountSid(pwszSamName, &pCallerSid);

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

    if(HRESULT_FROM_WIN32(ERROR_NONE_MAPPED)==hr)
    {
        // if name cannot be resolved, default to Everyone
        DWORD dwSize = sizeof(TOKEN_GROUPS);
        pGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, sizeof(TOKEN_GROUPS));
        if(!pGroups)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        
        hr = GetEveryoneSID(&pEveryoneSid);
        _JumpIfError(hr, error, "GetEveryoneSID");

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

        pGroups->GroupCount=1;
        pGroups->Groups[0].Sid = pEveryoneSid;
        pGroups->Groups[0].Attributes = 0;
    }
    else
    {
        _JumpIfError(hr, error, "GetAccountSid");

        // get the list of groups this SID is member of
        hr = GetMembership(g_AuthzCertSrvRM, pCallerSid, &pGroups);
        _JumpIfError(hr, error, "GetMembership");
    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));
    }

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

    // traverse the SID list stored in the ACE and compare with the
    // client's membership
    for(pSid=(PSID)&pSidList->SidListStart, cSids=0; cSids<pSidList->dwSidCount;
        cSids++, pSid = (PSID)(((BYTE*)pSid)+GetLengthSid(pSid)))
    {
        CSASSERT(IsValidSid(pSid));

        // group membership doesn't include the user itself, so 
        // compare with the user first
        if(pCallerSid && EqualSid(pSid, pCallerSid))
        {
            *pbAceApplicable = TRUE;
            goto error;
        }

        for(cClientSids=0; cClientSids<pGroups->GroupCount; cClientSids++)
        {
            pClientSid = pGroups->Groups[cClientSids].Sid;
            CSASSERT(IsValidSid(pClientSid));
            if(EqualSid(pSid, pClientSid))
            {
                *pbAceApplicable = TRUE;
                goto error;
            }
        }
    }

    *pbAceApplicable = FALSE;

error:

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));
    
    if(pEveryoneSid)
    {
        LocalFree(pEveryoneSid);
    }
    if(pCallerSid)
    {
        LocalFree(pCallerSid);
    }
    if(pGroups)
    {
        LocalFree(pGroups);
    }
    if(S_OK==hr)
    {
        return TRUE;
    }
    else
    {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

}


HRESULT GetMembership(
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzRM,
    IN PSID pSid,
    PTOKEN_GROUPS *ppGroups)
{
    HRESULT hr = S_OK;
    static LUID luid = {0