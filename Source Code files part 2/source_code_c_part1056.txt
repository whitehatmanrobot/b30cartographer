VIOLATION;
        }

        if ( !NT_SUCCESS(IoCheckDesiredAccess(
                          &deleteAccess,
                          lfcb->GrantedAccess )) ) {

            //
            // The client cannot delete this file, so close all the
            // RFCBs and return an error.
            //

            SrvCloseRfcbsOnLfcb( lfcb );

            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );

            return STATUS_ACCESS_DENIED;
        }

        //
        // Delete the file with NtSetInformationFile.
        //

        fileHandle = lfcb->FileHandle;

        fileDispositionInformation.DeleteFile = TRUE;

        status = NtSetInformationFile(
                     fileHandle,
                     &ioStatusBlock,
                     &fileDispositionInformation,
                     sizeof(FILE_DISPOSITION_INFORMATION),
                     FileDispositionInformation
                     );

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbDelete: NtSetInformationFile (disposition) "
                    "returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

            SrvCloseRfcbsOnLfcb( lfcb );

            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );

            return status;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "SrvSmbDelete: %wZ successfully deleted.\n", FullFileName ));
        }

        //
        // Close the RFCBs on the MFCB.  Since this is a compatability
        // or FCB open, there is only a single LFCB for the MFCB.  This
        // will result in the LFCB's file handle being closed, so there
        // is no need to call NtClose here.
        //

        SrvCloseRfcbsOnLfcb( lfcb );

        RELEASE_LOCK( &nonpagedMfcb->Lock );
        SrvDereferenceMfcb( mfcb );

    }

    return STATUS_SUCCESS;

} // DoDelete


SMB_PROCESSOR_RETURN_TYPE
SrvSmbRename (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Rename SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_RENAME;
    SrvWmiStartContext(WorkContext);
    //
    // This SMB must be processed in a blocking thread.
    //

    WorkContext->FspRestartRoutine = BlockingRename;
    SrvQueueWorkToBlockingThread( WorkContext );
    SrvWmiEndContext(WorkContext);
    return SmbStatusInProgress;

} // SrvSmbRename


VOID SRVFASTCALL
BlockingRename (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine processes the Rename SMB.

Arguments:

    WorkContext - work context block

Return Value:

    None.

--*/

{
    PREQ_RENAME request;
    PREQ_NTRENAME ntrequest;
    PUCHAR RenameBuffer;
    PRESP_RENAME response;

    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING sourceName;
    UNICODE_STRING targetName;

    USHORT smbFlags;
    USHORT ByteCount;
    PCHAR target;
    PCHAR lastPositionInBuffer;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;
    BOOLEAN isNtRename;
    BOOLEAN isDfs;
    PSRV_DIRECTORY_INFORMATION directoryInformation;
    ULONG renameRetries;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_RENAME;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Rename file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Rename file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    response = (PRESP_RENAME)WorkContext->ResponseParameters;

    request = (PREQ_RENAME)WorkContext->RequestParameters;
    ntrequest = (PREQ_NTRENAME)WorkContext->RequestParameters;
    isNtRename =
        (BOOLEAN)(WorkContext->RequestHeader->Command == SMB_COM_NT_RENAME);

    if (isNtRename) {
        RenameBuffer = ntrequest->Buffer;
        ByteCount = SmbGetUshort(&ntrequest->ByteCount);
    } else {
        RenameBuffer = request->Buffer;
        ByteCount = SmbGetUshort(&request->ByteCount);
    }

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: Invalid UID or TID\n" ));
        }
        goto error_exit;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        goto error_exit;
    }

    //
    // Get the share block from the tree connect block.  This does not need
    // to be a referenced pointer because we have referenced the tree
    // connect, and it has the share referenced.
    //

    share = treeConnect->Share;

    //
    // Set up the path name for the file we will search for.  The +1
    // accounts for the ASCII token of the SMB protocol.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    isDfs = SMB_CONTAINS_DFS_NAME( WorkContext );
    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(RenameBuffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &sourceName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: illegal path name: %s\n",
                        (PSZ)RenameBuffer + 1 ));
        }

        goto error_exit;
    }

    if( !sourceName.Length ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: No source name\n" ));
        }
        status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto error_exit;
    }

    //
    // Get a pointer to the new pathname of the file.  This is in the
    // buffer field of the request SMB after the source name.  The
    // target is delimited by the SMB_FORMAT_ASCII.
    //
    // While doing this, make sure that we do not walk off the end of the
    // SMB buffer if the client did not include the SMB_FORMAT_ASCII
    // token.
    //

    lastPositionInBuffer = (PCHAR)RenameBuffer + ByteCount;

    if( !isUnicode ) {
        for ( target = (PCHAR)RenameBuffer + 1;
              (target < lastPositionInBuffer) && (*target != SMB_FORMAT_ASCII);
              target++ ) {
            ;
        }
    } else {
        PWCHAR p = (PWCHAR)(RenameBuffer + 1);

        //
        // Skip the Original filename part. The name is null-terminated
        // (see rdr\utils.c RdrCopyNetworkPath())
        //

        //
        // Ensure p is suitably aligned
        //
        p = ALIGN_SMB_WSTR(p);

        //
        // Skip over the source filename
        //
        for( p = ALIGN_SMB_WSTR(p);
             p < (PWCHAR)lastPositionInBuffer && *p != UNICODE_NULL;
             p++ ) {
            ;
        }

        //
        // Search for SMB_FORMAT_ASCII which preceeds the target name
        //
        //
        for ( target = (PUCHAR)(p + 1);
              target < lastPositionInBuffer && *target != SMB_FORMAT_ASCII;
              target++ ) {
            ;
        }
    }

    //
    // If there was no SMB_FORMAT_ASCII in the passed buffer, fail.
    //

    if ( (target >= lastPositionInBuffer) || (*target != SMB_FORMAT_ASCII) ) {

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &sourceName );
        }

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    //
    // If the SMB was originally marked as containing Dfs names, then the
    // call to SrvCanonicalizePathName for the source path has cleared that
    // flag. So, re-mark the SMB as containing Dfs names before calling
    // SrvCanonicalizePathName on the target path.
    //

    if (isDfs) {
        SMB_MARK_AS_DFS_NAME( WorkContext );
    }

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            target + 1,
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &targetName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: illegal path name: %s\n", target + 1 ));
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &sourceName );
        }

        goto error_exit;
    }

    if( !targetName.Length ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: No target name\n" ));
        }

        if( !isUnicode ) {
            RtlFreeUnicodeString( &sourceName );
        }

        status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto error_exit;
    }

    //
    // Ensure this client's RFCB cache is empty.  This covers the case
    //  where a client has open files in a directory we are trying
    //  to rename.
    //
    SrvCloseCachedRfcbsOnConnection( WorkContext->Connection );

    if ( !FsRtlDoesNameContainWildCards( &sourceName ) ) {
        USHORT InformationLevel = SMB_NT_RENAME_RENAME_FILE;
        ULONG ClusterCount = 0;

        if (isNtRename) {
             InformationLevel = SmbGetUshort(&ntrequest->InformationLevel);
             ClusterCount = SmbGetUlong(&ntrequest->ClusterCount);
        }

        smbFlags = 0;

        //
        // Use SrvMoveFile to rename the file.  The SmbOpenFunction is
        // set to indicate that existing files may not be overwritten,
        // and we may create new files.  Also, the target may not be
        // a directory; if it already exists as a directory, fail.
        //

        renameRetries = SrvSharingViolationRetryCount;

start_retry1:

        status = SrvMoveFile(
                     WorkContext,
                     WorkContext->TreeConnect->Share,
                     SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL,
                     &smbFlags,
                     SmbGetUshort( &request->SearchAttributes ),
                     TRUE,
                     InformationLevel,
                     ClusterCount,
                     &sourceName,
                     &targetName
                     );

        if ( (status == STATUS_SHARING_VIOLATION) &&
             (renameRetries-- > 0) ) {

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            goto start_retry1;

        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &targetName );
            RtlFreeUnicodeString( &sourceName );
        }

        if ( !NT_SUCCESS(status) ) {
            goto error_exit;
        }

    } else if (isNtRename) {             // Wild cards not allowed!
        status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto error_exit;
    } else {

        BOOLEAN firstCall = TRUE;
        UNICODE_STRING subdirInfo;
        CLONG bufferLength;
        BOOLEAN filterLongNames;

        //
        // We need the full path name of each file that is returned by
        // SrvQueryDirectoryFile, so we need to find the part of the
        // passed filename that contains subdirectory information (e.g.
        // for a\b\c\*.*, we want a string that indicates a\b\c).
        //

        subdirInfo.Buffer = sourceName.Buffer;
        subdirInfo.Length = SrvGetSubdirectoryLength( &sourceName );
        subdirInfo.MaximumLength = subdirInfo.Length;

        //
        // SrvQueryDirectoryFile requires a buffer from nonpaged pool.
        // Since this routine does not use the buffer field of the
        // request SMB after the pathname, use this.  The buffer must be
        // quadword-aligned.
        //

        directoryInformation =
            (PSRV_DIRECTORY_INFORMATION)((ULONG_PTR)((PCHAR)RenameBuffer + ByteCount + 7) & ~7);

        bufferLength = WorkContext->RequestBuffer->BufferLength -
                       PTR_DIFF(directoryInformation,
                                WorkContext->RequestBuffer->Buffer);

        smbFlags = 0;

        //
        // Determine whether long filenames (non-8.3) should be filtered out
        // or processed.
        //

        if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                                        SMB_FLAGS2_KNOWS_LONG_NAMES) != 0 ) {
            filterLongNames = FALSE;
        } else {
            filterLongNames = TRUE;
        }

        //
        // Call SrvQueryDirectoryFile to get file(s) to rename, renaming as
        // we get each file.
        //
        // *** We ask for FileBothDirectoryInformation so that we will
        //     pick up long names on NTFS that have short name
        //     equivalents.  Without this, DOS clients will not be able
        //     to rename long names on NTFS volumes.
        //

        while ( ( status = SrvQueryDirectoryFile(
                               WorkContext,
                               firstCall,
                               filterLongNames,
                               FALSE,
                               FileBothDirectoryInformation,
                               0,
                               &sourceName,
                               NULL,
                               SmbGetUshort( &request->SearchAttributes ),
                               directoryInformation,
                               bufferLength
                               ) ) != STATUS_NO_MORE_FILES ) {

            PFILE_BOTH_DIR_INFORMATION bothDirInfo;
            UNICODE_STRING sourceFileName;
            UNICODE_STRING sourcePathName;

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "BlockingRename: SrvQueryDirectoryFile failed: %X\n",
                                status ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &targetName );
                    RtlFreeUnicodeString( &sourceName );
                }

                goto error_exit1;
            }

            bothDirInfo =
                (PFILE_BOTH_DIR_INFORMATION)directoryInformation->CurrentEntry;

            //
            // Note that we use the standard name to do the delete, even
            // though we may have matched on the NTFS short name.  The
            // client doesn't care which name we use to do the delete.
            //

            sourceFileName.Length = (SHORT)bothDirInfo->FileNameLength;
            sourceFileName.MaximumLength = sourceFileName.Length;
            sourceFileName.Buffer = bothDirInfo->FileName;

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "SrvQueryDirectoryFile--name %wZ, length = %ld, "
                            "status = %X\n",
                            &sourceFileName,
                            sourceFileName.Length,
                            status ));
            }

            firstCall = FALSE;

            //
            // Set up the full source name string.
            //

            SrvAllocateAndBuildPathName(
                &subdirInfo,
                &sourceFileName,
                NULL,
                &sourcePathName
                );

            if ( sourcePathName.Buffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "BlockingRename: SrvAllocateAndBuildPathName failed: "
                                  "%X\n", status ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &targetName );
                    RtlFreeUnicodeString( &sourceName );
                }

                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto error_exit1;
            }

            //
            // Use SrvMoveFile to copy or rename the file.  The
            // SmbOpenFunction is set to indicate that existing files
            // may not be overwritten, and we may create new files.
            //
            // *** SrvQueryDirectoryFile has already filtered based on
            //     the search attributes, so tell SrvMoveFile that files
            //     with the system and hidden bits are OK.  This will
            //     prevent the call to NtQueryDirectoryFile performed in
            //     SrvCheckSearchAttributesForHandle.
            //

            renameRetries = SrvSharingViolationRetryCount;

start_retry2:

            status = SrvMoveFile(
                         WorkContext,
                         WorkContext->TreeConnect->Share,
                         SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL,
                         &smbFlags,
                         (USHORT)(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN),
                         TRUE,
                         SMB_NT_RENAME_RENAME_FILE,
                         0,
                         &sourcePathName,
                         &targetName
                         );

            if ( (status == STATUS_SHARING_VIOLATION) &&
                 (renameRetries-- > 0) ) {

                (VOID) KeDelayExecutionThread(
                                        KernelMode,
                                        FALSE,
                                        &SrvSharingViolationDelay
                                        );

                goto start_retry2;

            }

            FREE_HEAP( sourcePathName.Buffer );

            if ( !NT_SUCCESS(status) ) {

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &targetName );
                    RtlFreeUnicodeString( &sourceName );
                }

                goto error_exit1;
            }
        }

        //
        // Clean up now that the search is done.
        //

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &targetName );
            RtlFreeUnicodeString( &sourceName );
        }

        SrvCloseQueryDirectory( directoryInformation );

        //
        // If no files were found, return an error to the client.
        //

        if ( firstCall ) {
            status = STATUS_NO_SUCH_FILE;
            goto error_exit;
        }
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_RENAME,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "BlockingRename complete.\n" ));
    goto normal_exit;

error_exit1:

    SrvCloseQueryDirectory( directoryInformation );

error_exit:

    SrvSetSmbError( WorkContext, status );

normal_exit:

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingRename


SMB_PROCESSOR_RETURN_TYPE
SrvSmbMove (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Move SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_MOVE;
    SrvWmiStartContext(WorkContext);

    //
    // This SMB must be processed in a blocking thread.
    //

    WorkContext->FspRestartRoutine = BlockingMove;
    SrvQueueWorkToBlockingThread( WorkContext );
    SrvWmiEndContext(WorkContext);
    return SmbStatusInProgress;

} // SrvSmbMove


VOID SRVFASTCALL
BlockingMove (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine processes the Move SMB.

Arguments:

    WorkContext - work context block

Return Value:

    None.

--*/

{
    PREQ_MOVE request;
    PRESP_MOVE response;

    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING sourceName;
    UNICODE_STRING sourceFileName;
    UNICODE_STRING sourcePathName;
    UNICODE_STRING targetName;

    PSRV_DIRECTORY_INFORMATION directoryInformation;

    USHORT tid2;
    USHORT smbFlags;
    PCHAR lastPositionInBuffer;
    PCHAR target;
    BOOLEAN isRenameOperation;
    BOOLEAN isUnicode = TRUE;
    BOOLEAN isDfs;
    USHORT smbOpenFunction;
    USHORT errorPathNameLength = 0;
    USHORT count = 0;

    PTREE_CONNECT sourceTreeConnect, targetTreeConnect;
    PSESSION session;
    PSHARE share;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_MOVE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Move/Copy request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Move/Copy request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_MOVE)WorkContext->RequestParameters;
    response = (PRESP_MOVE)WorkContext->ResponseParameters;

    //
    // Set pointers to NULL so that we know how to clean up on exit.
    //

    directoryInformation = NULL;
    targetTreeConnect = NULL;
    sourceName.Buffer = NULL;
    targetName.Buffer = NULL;
    sourcePathName.Buffer = NULL;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &sourceTreeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: Invalid UID or TID\n" ));
        }
        goto exit;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        goto exit;
    }

    //
    // Get the share block from the tree connect block.  This does not need
    // to be a referenced pointer because we have referenced the tree
    // connect, and it has the share referenced.
    //

    share = sourceTreeConnect->Share;

    //
    // Get the target tree connect.  The TID for this is in the Tid2
    // field of the request SMB.  Because SrvVerifyTid sets the
    // TreeConnect field of the WorkContext block, set it back after
    // calling the routine.  Remember to dereference this pointer before
    // exiting this routine, as it will not be automatically
    // dereferenced because it is not in the WorkContext block.
    //
    // If Tid2 is -1 (0xFFFF), then the TID specified in the SMB header
    // is used.
    //

    tid2 = SmbGetUshort( &request->Tid2 );
    if ( tid2 == (USHORT)0xFFFF ) {
        tid2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid );
    }

    WorkContext->TreeConnect = NULL;         // Must be NULL for SrvVerifyTid

    targetTreeConnect = SrvVerifyTid( WorkContext, tid2 );

    WorkContext->TreeConnect = sourceTreeConnect;

    if ( targetTreeConnect == NULL ||
         targetTreeConnect->Share->ShareType != ShareTypeDisk ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: Invalid TID2: 0x%lx\n", tid2 ));
        }

        status = STATUS_SMB_BAD_TID;
        goto exit;
    }

    //
    // Determine whether this is a rename or a copy.
    //

    if ( WorkContext->RequestHeader->Command == SMB_COM_MOVE ) {
        isRenameOperation = TRUE;
    } else {
        isRenameOperation = FALSE;
    }

    //
    // Store the open function.
    //

    smbOpenFunction = SmbGetUshort( &request->OpenFunction );

    //
    // Set up the target pathnames.  We must do the target first, as the
    // SMB rename extended protocol does not use the ASCII tokens, so we
    // will lose the information about the start of the target name when
    // we canonicalize the source name.
    //
    // Instead of using strlen() to find the end of the source string,
    // do it here so that we can make a check to ensure that we don't
    // walk off the end of the SMB buffer and cause an access violation.
    //

    lastPositionInBuffer = (PCHAR)request->Buffer +
                           SmbGetUshort( &request->ByteCount );

    for ( target = (PCHAR)request->Buffer;
          (target < lastPositionInBuffer) && (*target != 0);
          target++ ) {
        ;
    }

    //
    // If there was no zero terminator in the buffer, fail.
    //

    if ( (target == lastPositionInBuffer) || (*target != 0) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "No terminator on first name.\n" ));
        }

        SrvLogInvalidSmb( WorkContext );

        status = STATUS_INVALID_SMB;
        goto exit;

    }

    target++;

    isUnicode = SMB_IS_UNICODE( WorkContext );
    isDfs = SMB_CONTAINS_DFS_NAME( WorkContext );
    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            target,
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &targetName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: illegal path name (target): %wZ\n",
                        &targetName ));
        }

        goto exit;
    }

    //
    // If the SMB was originally marked as containing Dfs names, then the
    // call to SrvCanonicalizePathName for the target path has cleared that
    // flag. So, re-mark the SMB as containing Dfs names before calling
    // SrvCanonicalizePathName on the source path.
    //

    if (isDfs) {
        SMB_MARK_AS_DFS_NAME( WorkContext );
    }

    //
    // Set up the source name.
    //

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            request->Buffer,
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &sourceName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: illegal path name (source): %s\n",
                          request->Buffer ));
        }

        goto exit;
    }

    smbFlags = SmbGetUshort( &request->Flags );

    //
    // Copy interprets ; as *.  If the last character was ; and this was
    // not at the end of a file name with other characters (as in
    // "file;" then convert the ; to *.
    //

    if ( sourceName.Buffer[(sourceName.Length/sizeof(WCHAR))-1] == ';' &&
             ( sourceName.Length == 2 ||
               sourceName.Buffer[(sourceName.Length/sizeof(WCHAR))-2] == '\\' ) ) {

        sourceName.Buffer[(sourceName.Length/sizeof(WCHAR))-1] = '*';
    }

    //
    // Tree copy not implemented.  If this is a single file copy,
    // let it go through.  For now, we make sure that it does not
    // have any wild card characters, we do additional checking
    // inside SrvMoveFile.
    //

    if ( ( (smbFlags & SMB_COPY_TREE) != 0 ) &&
         FsRtlDoesNameContainWildCards(&sourceName) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "Tree copy not implemented.",
            NULL,
            NULL
            );
        status = STATUS_NOT_IMPLEMENTED;
        goto exit;
    }

    if ( !FsRtlDoesNameContainWildCards( &sourceName ) ) {

        //
        // Use SrvMoveFile to copy or move the file.
        //
        // *** These SMBs do not include search attributes, so set
        //     this field equal to zero.  If will not be possible
        //     to move a file that has the system or hidden bits on.

        status = SrvMoveFile(
                     WorkContext,
                     targetTreeConnect->Share,
                     smbOpenFunction,
                     &smbFlags,
                     (USHORT)0,             // SmbSearchAttributes
                     FALSE,
                     (USHORT)(isRenameOperation?
                         SMB_NT_RENAME_RENAME_FILE : SMB_NT_RENAME_MOVE_FILE),
                     0,
                     &sourceName,
                     &targetName
                     );

        if ( !NT_SUCCESS(status) ) {
            goto exit;
        }

        count = 1;

    } else {

        UNICODE_STRING subdirInfo;

        BOOLEAN firstCall = TRUE;
        CLONG bufferLength;
        BOOLEAN filterLongNames;

        //
        // If wildcards were in the original source name, we set the
        // SmbFlags to SMB_TARGET_IS_DIRECTORY to indicate that the
        // target must be a directory--this is always the case when
        // wildcards are used for a rename.  (For a copy, it is legal to
        // specify that the destination is a file and append to that
        // file--then all the source files are concatenated to that one
        // target file.)
        //

        if ( isRenameOperation  ) {
            smbFlags |= SMB_TARGET_IS_DIRECTORY;
        }

        //
        // SrvQueryDirectoryFile requires a buffer from nonpaged pool.
        // Since this routine does not use the buffer field of the
        // request SMB after the pathname, use this.  The buffer must be
        // quadword-aligned.
        //

        directoryInformation =
            (PSRV_DIRECTORY_INFORMATION)( (ULONG_PTR)((PCHAR)request->Buffer +
            SmbGetUshort( &request->ByteCount ) + 7) & ~7 );

        bufferLength = WorkContext->RequestBuffer->BufferLength -
                       PTR_DIFF(directoryInformation,
                                WorkContext->RequestBuffer->Buffer);

        //
        // We need the full path name of each file that is returned by
        // SrvQueryDirectoryFile, so we need to find the part of the
        // passed filename that contains subdirectory information (e.g.
        // for a\b\c\*.*, we want a string that indicates a\b\c).
        //

        subdirInfo.Buffer = sourceName.Buffer;
        subdirInfo.Length = SrvGetSubdirectoryLength( &sourceName );
        subdirInfo.MaximumLength = subdirInfo.Length;

        //
        // Determine whether long filenames (non-8.3) should be filtered out
        // or processed.
        //

        if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                                        SMB_FLAGS2_KNOWS_LONG_NAMES) != 0 ) {
            filterLongNames = FALSE;
        } else {
            filterLongNames = TRUE;
        }

        //
        // As long as SrvQueryDirectoryFile is able to return file names,
        // keep renaming.
        //
        // *** Set search attributes to find archive files, but not
        //     system or hidden files.  This duplicates the LM 2.0
        //     server behavior.
        //
        // *** We ask for FileBothDirectoryInformation so that we will
        //     pick up long names on NTFS that have short name
        //     equivalents.  Without this, DOS clients will not be able
        //     to move long names on NTFS volumes.
        //

        while ( ( status = SrvQueryDirectoryFile(
                               WorkContext,
                               firstCall,
                               filterLongNames,
                               FALSE,
                               FileBothDirectoryInformation,
                               0,
                               &sourceName,
                               NULL,
                               FILE_ATTRIBUTE_ARCHIVE, // SmbSearchAttributes
                               directoryInformation,
                               bufferLength
                               ) ) != STATUS_NO_MORE_FILES ) {

            PFILE_BOTH_DIR_INFORMATION bothDirInfo;

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "BlockingMove: SrvQueryDirectoryFile failed: %X\n",
                                status ));
                }

                goto exit;
            }

            bothDirInfo =
                (PFILE_BOTH_DIR_INFORMATION)directoryInformation->CurrentEntry;

            //
            // If we're filtering long names, and the file has a short
            // name equivalent, then use that name to do the delete.  We
            // do this because we need to return a name to the client if
            // the operation fails, and we don't want to return a long
            // name.  Note that if the file has no short name, and we're
            // filtering, then the standard name must be a valid 8.3
            // name, so it's OK to return to the client.
            //

            if ( filterLongNames && (bothDirInfo->ShortNameLength != 0) ) {
                sourceFileName.Length = (SHORT)bothDirInfo->ShortNameLength;
                sourceFileName.Buffer = bothDirInfo->ShortName;
            } else {
                sourceFileName.Length = (SHORT)bothDirInfo->FileNameLength;
                sourceFileName.Buffer = bothDirInfo->FileName;
            }
            sourceFileName.MaximumLength = sourceFileName.Length;

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "SrvQueryDirectoryFile--name %wZ, length = %ld, "
                            "status = %X\n",
                            &sourceFileName,
                            sourceFileName.Length,
                            status ));
            }

            firstCall = FALSE;

            //
            // Set up the full source name string.
            //

            SrvAllocateAndBuildPathName(
                &subdirInfo,
                &sourceFileName,
                NULL,
                &sourcePathName
                );

            if ( sourcePathName.Buffer == NULL ) {
                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto exit;
            }

            //
            // Use SrvMoveFile to copy or rename the file.
            //

            status = SrvMoveFile(
                         WorkContext,
                         targetTreeConnect->Share,
                         smbOpenFunction,
                         &smbFlags,
                         (USHORT)0,          // SmbSearchAttributes
                         FALSE,
                         (USHORT)(isRenameOperation?
                           SMB_NT_RENAME_RENAME_FILE : SMB_NT_RENAME_MOVE_FILE),
                         0,
                         &sourcePathName,
                         &targetName
                         );

            if ( !NT_SUCCESS(status) ) {
                goto exit;
            }

            count++;

            //
            // Free the buffer that holds that source name.
            //

            FREE_HEAP( sourcePathName.Buffer );
            sourcePathName.Buffer = NULL;

            //
            // If this is a copy operation with wildcards and the target is
            // a file, then all files should be appended to the target.  The
            // target is truncated on the first call to SrvMoveFile if that
            // was specified by the caller.
            //
            // This is done by turning off the truncate bit in the
            // SmbOpenFunction and turning on the append bit.
            //

            if ( !isRenameOperation && directoryInformation->Wildcards &&
                     (smbFlags & SMB_TARGET_IS_FILE) ) {
                smbOpenFunction &= ~SMB_OFUN_OPEN_TRUNCATE;
                smbOpenFunction |= SMB_OFUN_OPEN_APPEND;
            }
        }

        //
        // If no files were found, return an error to the client.
        //

        if ( firstCall ) {
            status = STATUS_NO_SUCH_FILE;
            goto exit;
        }
    }

    //
    // Build the response SMB.
    //

    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_MOVE, 0 );

    status = STATUS_SUCCESS;

exit:

    response->WordCount = 1;
    SmbPutUshort( &response->Count, count );

    if ( directoryInformation != NULL ) {
        SrvCloseQueryDirectory( directoryInformation );
    }

    if ( targetTreeConnect != NULL) {
        SrvDereferenceTreeConnect( targetTreeConnect );
    }

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );

        if ( sourcePathName.Buffer != NULL ) {

            //
            // Put the name of the file where the error occurred in the
            // buffer field of the response SMB.
            //

            RtlCopyMemory(
                response->Buffer,
                sourcePathName.Buffer,
                sourcePathName.Length
                );

            response->Buffer[sourcePathName.Length] = '\0';
            SmbPutUshort( &response->ByteCount, (SHORT)(sourcePathName.Length+1) );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  response,
                                                  RESP_MOVE,
                                                  sourcePathName.Length+1
                                                  );

            FREE_HEAP( sourcePathName.Buffer );

        } else if ( sourceName.Buffer != NULL ) {

            //
            // Put the name of the file where the error occurred in the
            // buffer field of the response SMB.
            //

            RtlCopyMemory(
                response->Buffer,
                sourceName.Buffer,
                sourceName.Length
                );

            response->Buffer[sourceName.Length] = '\0';
            SmbPutUshort( &response->ByteCount, (SHORT)(sourceName.Length+1) );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  response,
                                                  RESP_MOVE,
                                                  sourceName.Length+1
                                                  );
        }
    }

    if ( !isUnicode ) {
        if ( targetName.Buffer != NULL ) {
            RtlFreeUnicodeString( &targetName );
        }
        if ( sourceName.Buffer != NULL ) {
            RtlFreeUnicodeString( &sourceName );
        }
    }

    IF_DEBUG(TRACE2) KdPrint(( "BlockingMove complete.\n" ));
    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingMove


SMB_TRANS_STATUS
SrvSmbNtRename (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the NT rename request.  This request arrives in an NT
    transact SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_NT_RENAME request;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG( FILE_CONTROL1 ) {
        KdPrint(( "SrvSmbNtRename entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_NT_RENAME)transaction->InParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( transaction->ParameterCount < sizeof(REQ_NT_RENAME) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG( FILE_CONTROL1 ) {
            KdPrint(( "SrvSmbNtRename: bad parameter byte count: "
                        "%ld\n", transaction->ParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint((
                "SrvSmbNtRename: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                ));
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //


    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbNtRename complete.\n" ));
    return SmbTransStatusSuccess;

} // SrvSmbNtRename
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbdir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbdir.c

Abstract:

    This module implements directory control SMB processors:

        Create Directory
        Create Directory2
        Delete Directory
        Check Directory

--*/

#include "precomp.h"
#include "smbdir.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbCreateDirectory )
#pragma alloc_text( PAGE, SrvSmbCreateDirectory2 )
#pragma alloc_text( PAGE, SrvSmbDeleteDirectory )
#pragma alloc_text( PAGE, SrvSmbCheckDirectory )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateDirectory (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Create Directory SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_CREATE_DIRECTORY request;
    PRESP_CREATE_DIRECTORY response;

    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING directoryName;
    HANDLE directoryHandle;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE_DIRECTORY;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint2( "Create directory request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Create directory request params at 0x%p, response params%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_CREATE_DIRECTORY)WorkContext->RequestParameters;
    response = (PRESP_CREATE_DIRECTORY)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbCreateDirectory: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto Cleanup;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer because the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbCreateDirectory: illegal path name: %s\n",
                        (PSZ)request->Buffer + 1 );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.  Open relative to the
    // share root directory handle.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &directoryName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
            WorkContext->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Attempt to create the directory.  Since we must specify some desired
    // access, request TRAVERSE_DIRECTORY even though we are going to close
    // the directory just after we create it. The SMB protocol has no way
    // of specifying attributes, so assume a normal file.
    //

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "Creating directory %wZ\n", objectAttributes.ObjectName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                 WorkContext,
                 &directoryHandle,
                 FILE_TRAVERSE,                             // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 0L,                                        // AllocationSize
                 FILE_ATTRIBUTE_NORMAL,                     // FileAttributes
                 0L,                                        // ShareAccess
                 FILE_CREATE,                               // Disposition
                 FILE_DIRECTORY_FILE,                       // CreateOptions
                 NULL,                                      // EaBuffer
                 0L,                                        // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 share
                 );

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    //
    // If the user didn't have this permission, update the
    // statistics database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    //
    // Special error mapping to return correct error.
    //

    if ( status == STATUS_OBJECT_NAME_COLLISION &&
            !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection)) {
        status = STATUS_ACCESS_DENIED;
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvCreateDirectory: SrvIoCreateFile failed, "
                        "status = %X\n", status );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    SRVDBG_CLAIM_HANDLE( directoryHandle, "DIR", 23, 0 );
    SrvStatistics.TotalFilesOpened++;

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "SrvIoCreateFile succeeded, handle = 0x%p\n",
                    directoryHandle );
    }

    //
    // The SMB protocol has no concept of open directories; just close the
    // handle now that we have created the directory.
    //

    SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 36, 0 );
    SrvNtClose( directoryHandle, TRUE );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_CREATE_DIRECTORY,
                                        0
                                        );

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbCreateDirectory complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;
} // SrvSmbCreateDirectory


SMB_TRANS_STATUS
SrvSmbCreateDirectory2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Create Directory2 request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/

{
    PREQ_CREATE_DIRECTORY2 request;
    PRESP_CREATE_DIRECTORY2 response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    PTRANSACTION transaction;
    UNICODE_STRING directoryName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE directoryHandle;

    PFILE_FULL_EA_INFORMATION ntFullEa = NULL;
    ULONG ntFullEaLength = 0;
    USHORT eaErrorOffset = 0;

    PTREE_CONNECT treeConnect;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE_DIRECTORY2;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint1( "Create Directory2 entered; transaction 0x%p\n",
                    transaction );
    }

    request = (PREQ_CREATE_DIRECTORY2)transaction->InParameters;
    response = (PRESP_CREATE_DIRECTORY2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_CREATE_DIRECTORY2)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_CREATE_DIRECTORY2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "SrvSmbCreateDirectory2: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the tree connect block from the transaction block and the share
    // block from the tree connect block.  These don't need to be referenced
    // pointers because they are referenced by the transaction and the
    // tree connect, respectively.
    //

    treeConnect = transaction->TreeConnect;
    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbCreateDirectory2: illegal path name: %ws\n",
                          directoryName.Buffer );
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.  Open relative to the
    // share root directory handle.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &directoryName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
            WorkContext->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // If an FEALIST was passed and it has valid size, convert it to
    // NT style.  SrvOs2FeaListToNt allocates space for the NT full EA
    // list which must be deallocated.  Note that sizeof(FEALIST) includes
    // space for 1 FEA entry.  Without at least much information, the EA
    // code below should be skipped.
    //

    if ( transaction->DataCount > sizeof(FEALIST) &&
         SmbGetUlong( &((PFEALIST)transaction->InData)->cbList ) > sizeof(FEALIST) &&
         SmbGetUlong( &((PFEALIST)transaction->InData)->cbList ) <= transaction->DataCount ) {

        status = SrvOs2FeaListToNt(
                     (PFEALIST)transaction->InData,
                     &ntFullEa,
                     &ntFullEaLength,
                     &eaErrorOffset
                     );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                SrvPrint1( "SrvSmbCreateDirectory2: SrvOs2FeaListToNt failed, "
                            "status = %X\n", status );
            }

            if ( !isUnicode ) {
                RtlFreeUnicodeString( &directoryName );
            }

            SrvSetSmbError2( WorkContext, status, TRUE );
            transaction->SetupCount = 0;
            transaction->ParameterCount = 2;
            SmbPutUshort( &response->EaErrorOffset, eaErrorOffset );
            transaction->DataCount = 0;

            SmbStatus = SmbTransStatusErrorWithData;
            goto Cleanup;
        }
    }

    //
    // Attempt to create the directory.  Since we must specify some desired
    // access, request FILE_TRAVERSE even though we are going to close
    // the directory just after we create it. The SMB protocol has no way
    // of specifying attributes, so assume a normal file.
    //

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "Creating directory %wZ\n", objectAttributes.ObjectName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( ntFullEa ) ) {
        ULONG ntEaErrorOffset = 0;
        status = IoCheckEaBufferValidity( ntFullEa, ntFullEaLength, &ntEaErrorOffset );
        eaErrorOffset = (USHORT)ntEaErrorOffset;
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        status = SrvIoCreateFile(
                     WorkContext,
                     &directoryHandle,
                     FILE_TRAVERSE,                   // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     0L,                              // AllocationSize
                     FILE_ATTRIBUTE_NORMAL,           // FileAttributes
                     0L,                              // ShareAccess
                     FILE_CREATE,                     // Disposition
                     FILE_DIRECTORY_FILE,             // CreateOptions
                     ntFullEa,                        // EaBuffer
                     ntFullEaLength,                  // EaLength
                     CreateFileTypeNone,
                     NULL,                            // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,           // Options
                     share
                     );
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( ARGUMENT_PRESENT( ntFullEa ) ) {
        DEALLOCATE_NONPAGED_POOL( ntFullEa );
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvCreateDirectory2: SrvIoCreateFile failed, "
                        "status = %X\n", status );
        }

        SrvSetSmbError2( WorkContext, status, TRUE );

        transaction->SetupCount = 0;
        transaction->ParameterCount = 2;
        SmbPutUshort( &response->EaErrorOffset, eaErrorOffset );
        transaction->DataCount = 0;

        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "SrvIoCreateFile succeeded, handle = 0x%p\n",
                    directoryHandle );
    }

    //
    // The SMB protocol has no concept of open directories; just close the
    // handle now that we have created the directory.
    //

    SRVDBG_CLAIM_HANDLE( directoryHandle, "DIR", 24, 0 );
    SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 37, 0 );
    SrvNtClose( directoryHandle, TRUE );

    //
    // Build the output parameter and data structures.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 2;
    SmbPutUshort( &response->EaErrorOffset, 0 );
    transaction->DataCount = 0;
    SmbStatus = SmbTransStatusSuccess;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbCreateDirectory2


SMB_PROCESSOR_RETURN_TYPE
SrvSmbDeleteDirectory (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Delete Directory SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_DELETE_DIRECTORY request;
    PRESP_DELETE_DIRECTORY response;

    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING directoryName;
    HANDLE directoryHandle;
    FILE_DISPOSITION_INFORMATION fileDispositionInformation;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_DELETE_DIRECTORY;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint2( "Delete directory request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Delete directory request params at 0x%p, response params at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_DELETE_DIRECTORY)WorkContext->RequestParameters;
    response = (PRESP_DELETE_DIRECTORY)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbDeleteDirectory: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto Cleanup;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer becsue the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbDeleteDirectory: illegal path name: %s\n",
                          (PSZ)request->Buffer + 1 );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // If the client is trying to delete the root of the share, reject
    // the request.
    //

    if ( directoryName.Length < sizeof(WCHAR) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbDeleteDirectory: attempting to delete share root\n" );
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &directoryName );
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.  Open relative to the
    // share root directory handle.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &directoryName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
            WorkContext->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Attempt to open the directory.  We just need DELETE access to delete
    // the directory.
    //

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "Opening directory %wZ\n", &directoryName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                 WorkContext,
                 &directoryHandle,
                 DELETE,                                    // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0L,                                        // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN,                                 // Disposition
                 FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, // CreateOptions
                 NULL,                                      // EaBuffer
                 0L,                                        // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &directoryHandle,
                     DELETE,                                    // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0L,                                        // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,                                 // Disposition
                     FILE_DIRECTORY_FILE,                       // CreateOptions
                     NULL,                                      // EaBuffer
                     0L,                                        // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     share
                     );
    }

    //
    // If the user didn't have this permission, update the
    // statistics database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint2( "SrvDeleteDirectory: SrvIoCreateFile (%s) failed, "
                        "status = %X\n", (PSZ)request->Buffer + 1, status );
        }

        //
        // If returned error is STATUS_NOT_A_DIRECTORY, downlevel clients
        // expect ERROR_ACCESS_DENIED
        //

        if ( (status == STATUS_NOT_A_DIRECTORY) &&
             !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) ) {

            status = STATUS_ACCESS_DENIED;
        }

        SrvSetSmbError( WorkContext, status );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &directoryName );
        }

        goto Cleanup;
    }

    SRVDBG_CLAIM_HANDLE( directoryHandle, "DIR", 25, 0 );

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "SrvIoCreateFile succeeded, handle = 0x%p\n",
                    directoryHandle );
    }

    //
    // Delete the directory with NtSetInformationFile.
    //

    fileDispositionInformation.DeleteFile = TRUE;

    status = NtSetInformationFile(
                 directoryHandle,
                 &ioStatusBlock,
                 &fileDispositionInformation,
                 sizeof(FILE_DISPOSITION_INFORMATION),
                 FileDispositionInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint2( "SrvDeleteDirectory: NtSetInformationFile for directory "
                      "%s returned %X\n", (PSZ)request->Buffer + 1, status );
        }

        SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 38, 0 );
        SrvNtClose( directoryHandle, TRUE );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &directoryName );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;

    } else {

        //
        // Remove this directory name from the cache, since it has been deleted
        //
        SrvRemoveCachedDirectoryName( WorkContext, &directoryName );
    }

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint0( "SrvSmbDeleteDirectory: NtSetInformationFile succeeded.\n" );
    }

    //
    // Close the directory handle so that the directory will be deleted.
    //

    SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 39, 0 );
    SrvNtClose( directoryHandle, TRUE );

    //
    // Close all DOS directory searches on this directory and its
    // subdirectories.
    //

    SrvCloseSearches(
            treeConnect->Connection,
            (PSEARCH_FILTER_ROUTINE)SrvSearchOnDelete,
            (PVOID) &directoryName,
            (PVOID) treeConnect
            );


    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_DELETE_DIRECTORY,
                                        0
                                        );

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbDeleteDirectory complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;

} // SrvSmbDeleteDirectory


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCheckDirectory (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Check Directory SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/
{
    PREQ_CHECK_DIRECTORY request;
    PRESP_CHECK_DIRECTORY response;

    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING directoryName;
    FILE_NETWORK_OPEN_INFORMATION fileInformation;
    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CHECK_DIRECTORY;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint2( "Check directory request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Check directory request params at 0x%p, response params at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_CHECK_DIRECTORY)WorkContext->RequestParameters;
    response = (PRESP_CHECK_DIRECTORY)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbCheckDirectory: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto Cleanup;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer because the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbCheckDirectory: illegal path name: %s\n",
                          (PSZ)request->Buffer + 1 );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // See if we can find this directory in the CachedDirectoryList
    //
    if( SrvIsDirectoryCached( WorkContext, &directoryName ) == FALSE ) {

        //
        // Is not in the cache, must really check.
        //
        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &directoryName,
            (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                WorkContext->Session->UsingUppercasePaths) ?
                OBJ_CASE_INSENSITIVE : 0L,
            NULL,
            NULL
            );

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            status = SrvGetShareRootHandle( share );

            if( NT_SUCCESS( status ) ) {
                ULONG FileOptions = FILE_DIRECTORY_FILE;

                if (SeSinglePrivilegeCheck(
                        SeExports->SeBackupPrivilege,
                        KernelMode)) {
                    FileOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
                }

                //
                // The file name is always relative to the share root
                //
                status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                if( !NT_SUCCESS(status) )
                {
                    goto SnapError;
                }

                //
                // Find out what this thing is
                //

                if( IoFastQueryNetworkAttributes( &objectAttributes,
                                                  FILE_TRAVERSE,
                                                  FileOptions,
                                                  &ioStatusBlock,
                                                  &fileInformation
                                                    ) == FALSE ) {

                    SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                    ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }

                status = ioStatusBlock.Status;

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                    if( !NT_SUCCESS(status) )
                    {
                        goto SnapError;
                    }

                    if( IoFastQueryNetworkAttributes( &objectAttributes,
                                                      FILE_TRAVERSE,
                                                      FILE_DIRECTORY_FILE,
                                                      &ioStatusBlock,
                                                      &fileInformation
                                                        ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    status = ioStatusBlock.Status;
                }

SnapError:

                SrvReleaseShareRootHandle( share );
            }

            REVERT();
        }
    }


    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    if ( NT_SUCCESS(status) ) {

        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_CHECK_DIRECTORY,
                                            0
                                            );
    } else {

        //
        // If the user didn't have this permission, update the
        // statistics database.
        //
        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        if (CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection)) {
            SrvSetSmbError( WorkContext, status );
        } else {
            SrvSetSmbError( WorkContext, STATUS_OBJECT_PATH_NOT_FOUND );
        }
    }

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbCheckDirectory complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;

} // SrvSmbCheckDirectory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbioctl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbctl.c

Abstract:

    This module implements the IoControl and FsControl SMBs.

    Transact2 Ioctl
    Nt Transaction Io Control

Author:

    Manny Weiser (mannyw) 10-Oct-91

Revision History:

--*/

#include "precomp.h"
#include "smbioctl.tmh"
#pragma hdrstop

NTSTATUS
ProcessOs2Ioctl (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Category,
    IN USHORT Function,
    IN PVOID Parameters,
    IN ULONG InputParameterCount,
    IN PULONG OutputParameterCount,
    IN PVOID Data,
    IN ULONG InputDataCount,
    IN ULONG MaxOutputData,
    IN PULONG OutputDataCount
    );

VOID SRVFASTCALL
RestartNtIoctl (
    IN PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbIoctl )
#pragma alloc_text( PAGE, SrvSmbIoctlSecondary )
#pragma alloc_text( PAGE, RestartNtIoctl )
#pragma alloc_text( PAGE, SrvSmbIoctl2 )
#pragma alloc_text( PAGE, SrvSmbFsctl )
#pragma alloc_text( PAGE, ProcessOs2Ioctl )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctl (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a primary Ioctl SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_IOCTL request;
    PRESP_IOCTL response;
    PSMB_HEADER header;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PSESSION session;
    PTREE_CONNECT treeConnect;
    PRFCB rfcb;

    CLONG parameterOffset;
    CLONG parameterCount;       // For input on this buffer
    CLONG maxParameterCount;    // For output
    CLONG totalParameterCount;  // For input
    CLONG parameterSize;        // Max of input and output parameter counts
    CLONG dataOffset;
    CLONG responseDataOffset;
    CLONG dataCount;            // For input on this buffer
    CLONG maxDataCount;         // For output
    CLONG totalDataCount;       // For input
    CLONG dataSize;             // Max of input and output data counts

    CLONG smbLength;
    CLONG numberOfPaddings = 0;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_IOCTL;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_IOCTL)WorkContext->RequestParameters;
    response = (PRESP_IOCTL)WorkContext->ResponseParameters;

    //
    // Since we do I/O from the SMB buffer, verify that the request and
    // response buffers are one and the same.
    //

    ASSERT( (PVOID)request == (PVOID)response );

    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        KdPrint(( "Ioctl (primary) request\n" ));
    }

    //
    // !!! Verify ioctl subcommand early?
    //

    parameterOffset = SmbGetUshort( &request->ParameterOffset );
    parameterCount = SmbGetUshort( &request->ParameterCount );
    maxParameterCount = SmbGetUshort( &request->MaxParameterCount );
    totalParameterCount = SmbGetUshort( &request->TotalParameterCount );
    dataOffset = SmbGetUshort( &request->DataOffset );
    dataCount = SmbGetUshort( &request->DataCount );
    maxDataCount = SmbGetUshort( &request->MaxDataCount );
    totalDataCount = SmbGetUshort( &request->TotalDataCount );

    smbLength = WorkContext->RequestBuffer->DataLength;

    dataSize = MAX( dataCount, maxDataCount );
    parameterSize = MAX( parameterCount, maxParameterCount );

    if ( parameterCount != 0 ) {
        responseDataOffset = parameterOffset + parameterSize;
    } else {

        //
        // Some ioctls requests have  data offset of zero like
        // category 0x53, function 0x60.  If this is the case,
        // calculate the dataoffset by hand.
        //

        if ( dataOffset != 0 ) {
            responseDataOffset = dataOffset;
        } else {
            responseDataOffset = (CLONG) ((PUCHAR) response->Buffer -
                           (PUCHAR) WorkContext->ResponseHeader);
            numberOfPaddings = ( responseDataOffset & 0x01 );
            responseDataOffset = responseDataOffset + numberOfPaddings;
        }
    }

    //
    // Verify the size of the smb buffer:
    //
    // Even though we know that WordCount and ByteCount are valid, it's
    // still possible that the offsets and lengths of the Parameter and
    // Data bytes are invalid.  So we check them now.
    //
    // We need room in the smb buffer for the response.  Ensure that
    // there is enough room.
    //
    // No ioctl secondary is expected.  Ensure that all data and
    // parameters have arrrived.
    //
    // Check that the response will fit in a single buffer.
    //

    if ( ( (parameterOffset + parameterCount) > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( (responseDataOffset + dataCount) >
            WorkContext->ResponseBuffer->BufferLength ) ||

         ( dataCount != totalDataCount ) ||
         ( parameterCount != totalParameterCount ) ||

         ( (parameterOffset > dataOffset) && (dataCount != 0) ) ) {


        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTransaction: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;",
                      parameterOffset, parameterCount ));
            KdPrint(( "dOff=%ld,dCnt=%ld;", dataOffset, dataCount ));
            KdPrint(( "smbLen=%ld", smbLength ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // If a tree connect block has not already been assigned to the
    // current work context, find the tree connect corresponding to the
    // given TID.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbIoctl: Invalid UID or TID\n" ));
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                request->Fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbIoctl: Status %X on FID: 0x%lx\n",
                    request->Fid,
                    status
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Make room in the SMB buffer for return parameters by copying data
    //

    if ( dataOffset != responseDataOffset && dataCount != 0) {
        RtlMoveMemory(
            (PCHAR)header + responseDataOffset,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Process the ioctl.  The response will overwrite the request buffer.
    //

    status = ProcessOs2Ioctl(
                WorkContext,
                request->Category,
                request->Function,
                (PCHAR)WorkContext->RequestHeader + parameterOffset,
                totalParameterCount,
                &maxParameterCount,
                (PCHAR)WorkContext->RequestHeader + responseDataOffset,
                totalDataCount,
                WorkContext->ResponseBuffer->BufferLength -
                    PTR_DIFF(WorkContext->RequestHeader,
                             WorkContext->ResponseBuffer->Buffer) -
                    responseDataOffset,
                &maxDataCount
                );

    //
    // Format and send the response, the parameter and data bytes are
    // already in place.
    //

    if ( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    response->WordCount = 8;
    SmbPutUshort( &response->TotalParameterCount, (USHORT)maxParameterCount );
    SmbPutUshort( &response->TotalDataCount, (USHORT)maxDataCount );
    SmbPutUshort( &response->ParameterCount, (USHORT)maxParameterCount );
    SmbPutUshort( &response->ParameterOffset, (USHORT)parameterOffset );
    SmbPutUshort( &response->ParameterDisplacement, 0);
    SmbPutUshort( &response->DataCount, (USHORT)maxDataCount );
    SmbPutUshort( &response->DataOffset, (USHORT)responseDataOffset );
    SmbPutUshort( &response->DataDisplacement, 0 );

    SmbPutUshort(
        &response->ByteCount,
        (USHORT)(maxDataCount + numberOfPaddings)
        );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_IOCTL,
                                          maxDataCount + numberOfPaddings
                                          );

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbIoctl


SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctlSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a secondary Ioctl SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PAGED_CODE( );

    //
    // This SMB is not supported.
    //

    SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );
    return SmbStatusSendResponse;
}


SMB_TRANS_STATUS
SrvSmbNtIoctl (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Nt Ioctl SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    NTSTATUS status;
    ULONG functionCode;
    USHORT fid;
    BOOLEAN isFsctl;

    PREQ_NT_IO_CONTROL request;

    PTRANSACTION transaction;
    PRFCB rfcb;
    PMDL mdl = NULL;

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_NT_IO_CONTROL)transaction->InSetup;

    functionCode = SmbGetAlignedUlong( &request->FunctionCode );
    fid = SmbGetAlignedUshort( &request->Fid );
    isFsctl = request->IsFsctl;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbNtIoctl: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            return SmbTransStatusErrorWithoutData;

        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // Only allow these fellows against disk files
    //
    if( rfcb->ShareType != ShareTypeDisk ) {
        SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
        SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
        return SmbTransStatusInProgress;
    }

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        (UCHAR)(isFsctl ? IRP_MJ_FILE_SYSTEM_CONTROL : IRP_MJ_DEVICE_CONTROL),
        0,
        functionCode,
        &status
        );

    if ( !NT_SUCCESS( status ) ) {
        SrvStatistics.GrantedAccessErrors++;
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // There are some functions which we cannot allow.  Weed them out here
    //
    switch( functionCode ) {
    case FSCTL_SET_REPARSE_POINT:

        //
        // If there's not enough data, or the structure is internally inconsistent --
        //  fail the request
        //
        status = STATUS_SUCCESS;

        if( transaction->DataCount == 0 ) {
            status = STATUS_INVALID_BUFFER_SIZE;

        } else if ( transaction->DataCount < REPARSE_DATA_BUFFER_HEADER_SIZE ||
            ((PREPARSE_DATA_BUFFER)transaction->InData)->ReparseDataLength >
            transaction->DataCount - FIELD_OFFSET( REPARSE_DATA_BUFFER, GenericReparseBuffer )
        ) {
            status = STATUS_IO_REPARSE_DATA_INVALID;
        }

        if( !NT_SUCCESS( status ) ) {
            SrvSetSmbError( WorkContext, status );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        //
        // Only an administrator is allowed to set generalized reparse points,
        //  otherwise it is too easy to escape the share.  This seems safer
        //  than a path check, and it also allows the administrator to point
        //  the reparse point to wherever s/he desires.
        //
        if( !SrvIsAdmin( WorkContext->Session->UserHandle ) ) {
            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        break;

    case FSCTL_SRV_ENUMERATE_SNAPSHOTS:
        {
            if( SrvProductTypeServer )
            {
                status = SrvSnapEnumerateSnapShots( WorkContext );
                if( !NT_SUCCESS(status) )
                {
                    SrvSetSmbError( WorkContext, status );
                    SrvCompleteExecuteTransaction( WorkContext, (status==STATUS_BUFFER_OVERFLOW)?SmbTransStatusErrorWithData:SmbTransStatusErrorWithoutData );
                }
                else
                {
                    SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusSuccess );
                }
                return SmbTransStatusInProgress;
            }
            else
            {
                status = STATUS_NOT_IMPLEMENTED;
                SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
                return SmbTransStatusInProgress;
            }
        }
        break;

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_MOVE_FILE:
    case FSCTL_MARK_HANDLE:
    case FSCTL_QUERY_RETRIEVAL_POINTERS:
    case FSCTL_PIPE_ASSIGN_EVENT:
    case FSCTL_GET_VOLUME_BITMAP:
    case FSCTL_GET_NTFS_FILE_RECORD:

    // We don't support USN journal calls because they require a volume handle
    case FSCTL_READ_USN_JOURNAL:
    case FSCTL_CREATE_USN_JOURNAL:
    case FSCTL_QUERY_USN_JOURNAL:
    case FSCTL_DELETE_USN_JOURNAL:
        SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
        SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
        return SmbTransStatusInProgress;
    }

    if (functionCode == FSCTL_LMR_SET_LINK_TRACKING_INFORMATION) {

        // This is a FSCTL that is used for link tracking purposes. It is
        // an internal FSCTL issued by the I/O subsystem. Currently this
        // is being handled in the context of a worker thread. We need
        // to ensure that this arm of the code is only executed in the
        // context of a blocking thread.

        // Also note that the incoming structure will always be the 32-bit structure, even
        // from 64-bit machines.  All structures on the wire are 32-bit for backwards compatibility

        KIRQL        oldIrql;
        PRFCB        rfcbTarget = NULL;
        USHORT       TargetFid;
        PVOID        TargetHandle;
        ULONG        TargetInformationLength;
        ULONG        LinkTrackingInformationSize;

        if( transaction->DataCount < sizeof( REMOTE_LINK_TRACKING_INFORMATION32 ) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        TargetHandle = UlongToHandle( SmbGetUlong(
                           (PUCHAR)transaction->InData +
                           FIELD_OFFSET(
                               REMOTE_LINK_TRACKING_INFORMATION32,
                               TargetFileObject)) );

        TargetInformationLength = SmbGetUlong(
                                      (PUCHAR)transaction->InData +
                                      FIELD_OFFSET(
                                          REMOTE_LINK_TRACKING_INFORMATION32,
                                          TargetLinkTrackingInformationLength));

        LinkTrackingInformationSize = FIELD_OFFSET(
                                          FILE_TRACKING_INFORMATION32,
                                          ObjectInformation) +
                                          TargetInformationLength;

        //
        // Make sure the REMOTE_LINK_TRACKING_INFORMATION structure is reasonable
        //
        if( TargetInformationLength > transaction->DataCount ||
            LinkTrackingInformationSize > transaction->DataCount ) {

            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        if (TargetHandle != NULL) {

            TargetFid = (USHORT)TargetHandle;

            //
            // Verify the FID.  This code is lifted from SrvVerifyFid2.
            //

            //
            // Acquire the spin lock that guards the connection's file table.
            //

            ACQUIRE_SPIN_LOCK( &WorkContext->Connection->SpinLock, &oldIrql );

            //
            // See if this is the cached rfcb
            //

            if ( WorkContext->Connection->CachedFid == (ULONG)TargetFid ) {

                rfcbTarget = WorkContext->Connection->CachedRfcb;

            } else {
                USHORT index;
                USHORT sequence;
                PTABLE_HEADER tableHeader;

                //
                // Verify that the FID is in range, is in use, and has the correct
                // sequence number.

                index = FID_INDEX( TargetFid );
                sequence = FID_SEQUENCE( TargetFid );
                tableHeader = &WorkContext->Connection->FileTable;

                if ( (index < (USHORT)tableHeader->TableSize) &&
                     (tableHeader->Table[index].Owner != NULL) &&
                     (tableHeader->Table[index].SequenceNumber == sequence) &&
                     (GET_BLOCK_STATE(tableHeader->Table[index].Owner) == BlockStateActive) ) {

                    rfcbTarget = tableHeader->Table[index].Owner;

                    //
                    // Cache the fid.
                    //

                    WorkContext->Connection->CachedRfcb = rfcbTarget;
                    WorkContext->Connection->CachedFid = (ULONG)TargetFid;

                }
            }

            RELEASE_SPIN_LOCK( &WorkContext->Connection->SpinLock, oldIrql );
        }

        if( rfcbTarget != NULL || TargetHandle == NULL ) {

            PFILE_TRACKING_INFORMATION pTrackingInformation;
            IO_STATUS_BLOCK   ioStatusBlock;

            // Since the data in the InData buffer is unaligned we need to allocate
            // a copy of the data that is aligned and copy the information over
            // before passing it on in the SetInformationCall
            // We also resize the buffer to the native structure on 64 bit (no change occurs on 32 bit)

            pTrackingInformation = ALLOCATE_HEAP( LinkTrackingInformationSize + sizeof(PVOID) - sizeof(ULONG), BlockTypeMisc );

            if (pTrackingInformation != NULL) {
                if (rfcbTarget != NULL) {
                    pTrackingInformation->DestinationFile =
                        rfcbTarget->Lfcb->FileHandle;
                } else {
                    pTrackingInformation->DestinationFile = NULL;
                }

                pTrackingInformation->ObjectInformationLength =
                    TargetInformationLength;

                RtlCopyMemory(
                    pTrackingInformation->ObjectInformation,
                    ((PUCHAR)transaction->InData +
                     FIELD_OFFSET(
                         REMOTE_LINK_TRACKING_INFORMATION,
                         TargetLinkTrackingInformationBuffer)),
                    TargetInformationLength);

                status = NtSetInformationFile(
                             rfcb->Lfcb->FileHandle,
                             &ioStatusBlock,
                             pTrackingInformation,
                             LinkTrackingInformationSize,
                             FileTrackingInformation);

                FREE_HEAP(pTrackingInformation);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

        if (!NT_SUCCESS(status)) {
            SrvSetSmbError( WorkContext, status );
            SrvCompleteExecuteTransaction(
                WorkContext,
                SmbTransStatusErrorWithoutData
                );
        } else {
            transaction->DataCount = 0;
            transaction->ParameterCount = 0;

            SrvCompleteExecuteTransaction(
                WorkContext,
                SmbTransStatusSuccess
                );
        }

        return SmbTransStatusInProgress;

    }

    //
    // Since we are doing ioctls to this file, it doesn't seem like it's
    //  a "normal" file.  We had better not cache its handle after the close.
    //  Specifically, remote setting of the file's compression state is
    //  not reflected to the directory entry until the file is closed.  And
    //  setting a file's compression state is done with an ioctl
    //
    rfcb->IsCacheable = FALSE;

    if (functionCode == FSCTL_SIS_COPYFILE) {

        //
        // This the single-instance store copy FSCTL. We need to modify
        // the file names, which are passed as share-relative names,
        // to be full NT paths.
        //

        PSI_COPYFILE copyFile;
        PSI_COPYFILE newCopyFile;
        ULONG bufferLength;
        PWCHAR source;
        ULONG sourceLength;
        PWCHAR dest;
        ULONG destLength;
        PSHARE share;
        PWCHAR prefix;
        ULONG prefixLength;
        PCHAR p;
        ULONG addSlashToSource;
        ULONG addSlashToDest;

        copyFile = (PSI_COPYFILE)transaction->InData;
        bufferLength = transaction->DataCount;

        if( bufferLength < sizeof( SI_COPYFILE ) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        //
        // Get the share-relative paths.
        //

        source = copyFile->FileNameBuffer;
        sourceLength = copyFile->SourceFileNameLength;
        dest = source + (sourceLength / sizeof(WCHAR));
        destLength = copyFile->DestinationFileNameLength;

        //
        // Verify that the input structure is reasonable.
        //

        if ( (sourceLength > bufferLength || sourceLength == 0 ) ||
             (destLength > bufferLength || destLength == 0 ) ||
             ((FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) + sourceLength + destLength) > bufferLength) ||
             (*(source + (sourceLength/sizeof(WCHAR)-1)) != 0) ||
             (*(dest + (destLength/sizeof(WCHAR)-1)) != 0) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            return SmbTransStatusErrorWithoutData;
        }

        ASSERT( (FSCTL_SIS_COPYFILE & 3) == METHOD_BUFFERED );

        //
        // Get the NT path prefix for the share.
        //

        share = WorkContext->TreeConnect->Share;
        prefix = share->NtPathName.Buffer;
        prefixLength = share->NtPathName.Length;

        //
        // Make sure there is exactly one slash between the share prefix
        // and the paths in the request.
        //

        addSlashToSource = 0;
        addSlashToDest = 0;
        if ( IS_UNICODE_PATH_SEPARATOR(*(prefix + (prefixLength/sizeof(WCHAR)-1))) ) {
            if ( IS_UNICODE_PATH_SEPARATOR(*source) ) {
                source++;
                sourceLength -= sizeof(WCHAR);
            }
            if ( IS_UNICODE_PATH_SEPARATOR(*dest) ) {
                dest++;
                destLength -= sizeof(WCHAR);
            }
        } else {
            if ( !IS_UNICODE_PATH_SEPARATOR(*source) ) {
                addSlashToSource = sizeof(WCHAR);
            }
            if ( !IS_UNICODE_PATH_SEPARATOR(*dest) ) {
                addSlashToDest = sizeof(WCHAR);
            }
        }

        //
        // Allocate space for a new FSCTL command buffer.
        //

        bufferLength = FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) +
                       prefixLength + addSlashToSource + sourceLength +
                       prefixLength + addSlashToSource + destLength;
        newCopyFile = ALLOCATE_HEAP( bufferLength, BlockTypeBuffer );

        if( newCopyFile == NULL ) {
           SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
           return SmbTransStatusErrorWithoutData;
        }

        //
        // Initialize the FSCTL input buffer with the full NT path names.
        //

        newCopyFile->SourceFileNameLength = prefixLength + addSlashToSource + sourceLength;
        newCopyFile->DestinationFileNameLength = prefixLength + addSlashToDest + destLength;
        newCopyFile->Flags = copyFile->Flags;
        p = (PCHAR)newCopyFile->FileNameBuffer;
        RtlCopyMemory( p, prefix, prefixLength );
        p += prefixLength;
        if ( addSlashToSource != 0 ) {
            *(PWCHAR)p = UNICODE_DIR_SEPARATOR_CHAR;
            p += sizeof(WCHAR);
        }
        RtlCopyMemory( p, source, sourceLength );
        p += sourceLength;
        RtlCopyMemory( p, prefix, prefixLength );
        p += prefixLength;
        if ( addSlashToDest != 0 ) {
            *(PWCHAR)p = UNICODE_DIR_SEPARATOR_CHAR;
            p += sizeof(WCHAR);
        }
        RtlCopyMemory( p, dest, destLength );

        //
        // Modify the transaction to point to the new buffer and indicate
        // that the buffer should be freed when the transaction is done.
        // (Note that the original buffer was allocated as part of the
        // transaction block and doesn't need to be freed separately.)
        //

        transaction->InData = (PVOID)newCopyFile;
        transaction->OutData = (PVOID)newCopyFile;
        transaction->DataCount = bufferLength;
        transaction->OutputBufferCopied = TRUE;
        transaction->OutDataAllocated = TRUE;
    }

    switch( functionCode & 3 ) {
    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:

        if( transaction->TotalDataCount ) {
            //
            // Need an mdl
            //
            status = STATUS_SUCCESS;

            mdl = IoAllocateMdl(
                      transaction->InData,
                      transaction->TotalDataCount,
                      FALSE,
                      FALSE,
                      NULL
                      );

            if ( mdl == NULL ) {
                status = STATUS_INSUFF_SERVER_RESOURCES;
            } else {

                //
                // Build the mdl
                //

                try {
                    MmProbeAndLockPages(
                        mdl,
                        KernelMode,
                        IoReadAccess
                        );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    status = GetExceptionCode();
                    IoFreeMdl( mdl );
                    mdl = NULL;
                }
            }

            if( !NT_SUCCESS( status ) ) {
                SrvSetSmbError( WorkContext, status );
                return SmbTransStatusErrorWithoutData;
            }
        }
        break;

    case METHOD_NEITHER:
        //
        // We need to allocate the output buffer for this fsctl, because at
        //  this point both the input and output buffers point to the same
        //  region of memory.  This can't be guaranteed to work for METHOD_NEITHER
        //

        if( transaction->MaxDataCount ) {
            //
            // Let's not let the allocation get out of hand!
            //
            if( transaction->MaxDataCount > SrvMaxFsctlBufferSize ) {
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                return SmbTransStatusErrorWithoutData;
            }

            transaction->OutData = ALLOCATE_HEAP( transaction->MaxDataCount, BlockTypeBuffer );

            if( transaction->OutData == NULL ) {
               SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
               return SmbTransStatusErrorWithoutData;
            }

            RtlZeroMemory( transaction->OutData, transaction->MaxDataCount );
            transaction->OutputBufferCopied = TRUE;
            transaction->OutDataAllocated = TRUE;
        }

        break;
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartNtIoctl;

    //
    // Build the IRP to start the I/O control.
    // Pass this request to the filesystem.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        rfcb->Lfcb->FileObject,
        WorkContext,
        (UCHAR)(isFsctl ? IRP_MJ_FILE_SYSTEM_CONTROL : IRP_MJ_DEVICE_CONTROL),
        functionCode,
        transaction->InData,
        transaction->DataCount,
        transaction->OutData,
        transaction->MaxDataCount,
        mdl,
        NULL        // Completion routine
        );

    (VOID)IoCallDriver(
                IoGetRelatedDeviceObject(rfcb->Lfcb->FileObject ),
                WorkContext->Irp
                );

    //
    // The call was successfully started, return InProgress to the caller
    //

    return SmbTransStatusInProgress;

} // SrvSmbNtIoctl


VOID SRVFASTCALL
RestartNtIoctl (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the completion of an NT Io control SMB.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONG length;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // Free the MDL if one was allocated.
    //

    if ( WorkContext->Irp->MdlAddress != NULL ) {
        MmUnlockPages( WorkContext->Irp->MdlAddress );
        IoFreeMdl( WorkContext->Irp->MdlAddress );
        WorkContext->Irp->MdlAddress = NULL;
    }

    //
    // If the Io Control request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( NT_ERROR(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "RestartNtIoctl:  Io control failed: %X\n",
                        status ));
        }
        SrvSetSmbError( WorkContext, status );

        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );

    } else {

        //
        // Success.  Prepare to generate and send the response.
        //

        transaction = WorkContext->Parameters.Transaction;

        length = MIN( (ULONG)WorkContext->Irp->IoStatus.Information, transaction->MaxDataCount );

        if ( transaction->MaxSetupCount > 0 ) {
            transaction->SetupCount = 1;
            SmbPutUshort( transaction->OutSetup, (USHORT)length );
        }

        transaction->ParameterCount = transaction->MaxParameterCount;
        transaction->DataCount = length;

        if (!NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "RestartNtIoctl:  Io control failed: %X\n",
                            status ));
            }
            SrvSetSmbError2( WorkContext, status, TRUE );

            SrvCompleteExecuteTransaction(
                            WorkContext,
                            SmbTransStatusErrorWithData
                            );
        } else {
            SrvCompleteExecuteTransaction(
                            WorkContext,
                            SmbTransStatusSuccess);
        }

    }

    return;

} // RestartNtIoctl


SMB_TRANS_STATUS
SrvSmbIoctl2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the Ioctl request.  This request arrives in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    PTRANSACTION transaction;
    PRFCB rfcb;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_IOCTL2;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(TRANSACTION2) {
        KdPrint(( "Ioctl2 entered; transaction 0x%p\n",
                    transaction ));
    }

    //request = (PREQ_IOCTL2)transaction->InSetup;

    //
    // Verify the setup count.
    //

    if ( transaction->SetupCount != 4 * sizeof( USHORT ) ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                transaction->InSetup[1],
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbIoctl2: Status %X on FID: 0x%lx\n",
                    transaction->InSetup[1],
                    status
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    transaction->Category = transaction->InSetup[2];
    transaction->Function = transaction->InSetup[3];

    //
    // Perform the Ioctl
    //

    status = ProcessOs2Ioctl(
                 WorkContext,
                 transaction->InSetup[2],
                 transaction->InSetup[3],
                 transaction->InParameters,
                 transaction->ParameterCount,
                 &transaction->MaxParameterCount,
                 transaction->OutData,
                 transaction->DataCount,
                 transaction->MaxDataCount,
                 &transaction->MaxDataCount
                 );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = transaction->MaxParameterCount;
    transaction->DataCount = transaction->MaxDataCount;
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbIoctl2 complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbIoctl2


SMB_TRANS_STATUS
SrvSmbFsctl (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PAGED_CODE( );

    //
    // The OS/2 redirector never sends a remote FS control request.
    // If we get one, simply reply that we cannot handle it.
    //

    return SrvTransactionNotImplemented( WorkContext );

} // SrvSmbFsctl


#define SERIAL_DEVICE           0x1
#define PRINTER_DEVICE          0x5
#define GENERAL_DEVICE          0xB
#define SPOOLER_DEVICE          0x53

//
// Serial device functions supported
//

#define SET_BAUD_RATE          0x41
#define SET_LINE_CONTROL       0x42
#define SET_TRANSMIT_TIMEOUT   0x44
#define SET_BREAK_OFF          0x45
#define SET_MODEM_CONTROL      0x46
#define SET_BREAK_ON           0x4B
#define STOP_TRANSMIT          0x47
#define START_TRANSMIT         0x48
#define SET_DCB_INFORMATION    0x53
#define GET_BAUD_RATE          0x61
#define GET_LINE_CONTROL       0x62
#define GET_COMM_STATUS        0x64
#define GET_LINE_STATUS        0x65
#define GET_MODEM_OUTPUT       0x66
#define GET_MODEM_INPUT        0x67
#define GET_INQUEUE_COUNT      0x68
#define GET_OUTQUEUE_COUNT     0x69
#define GET_COMM_ERROR         0x6D
#define GET_COMM_EVENT         0x72
#define GET_DCB_INFORMATION    0x73

//
// Print device function supported.
//
// *** Note:  The OS/2 server supports 2 additional Ioctl functions.
//            ActivateFont (0x48) and QueryActiveFont (0x69).  Since these
//            were designed only to support IBM proplus printer from OS/2
//            and we can't correctly support these function, we don't.
//

#define GET_PRINTER_ID         0x60
#define GET_PRINTER_STATUS     0x66

#define OS2_STATUS_PRINTER_HAPPY 0x90

typedef struct _SMB_IOCTL_LINECONTROL {
    UCHAR DataBits;
    UCHAR Parity;
    UCHAR StopBits;
    UCHAR TransBreak;
} SMB_IOCTL_LINE_CONTROL, *PSMB_IOCTL_LINE_CONTROL;

typedef struct _SMB_IOCTL_BAUD_RATE {
    USHORT BaudRate;
} SMB_IOCTL_BAUD_RATE, *PSMB_IOCTL_BAUD_RATE;

typedef struct _SMB_IOCTL_DEVICE_CONTROL {
    USHORT WriteTimeout;
    USHORT ReadTimeout;
    UCHAR ControlHandShake;
    UCHAR FlowReplace;
    UCHAR Timeout;
    UCHAR ErrorReplacementChar;
    UCHAR BreakReplacementChar;
    UCHAR XonChar;
    UCHAR XoffChar;
} SMB_IOCTL_DEVICE_CONTROL, *PSMB_IOCTL_DEVICE_CONTROL;

typedef struct _SMB_IOCTL_COMM_ERROR {
    USHORT Error;
} SMB_IOCTL_COMM_ERROR, *PSMB_IOCTL_COMM_ERROR;

typedef struct _SMB_IOCTL_PRINTER_ID {
    USHORT JobId;
    UCHAR Buffer[1]; // server name and share name
} SMB_IOCTL_PRINTER_ID;

typedef SMB_IOCTL_PRINTER_ID SMB_UNALIGNED *PSMB_IOCTL_PRINTER_ID;

NTSTATUS
ProcessOs2Ioctl (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Category,
    IN USHORT Function,
    IN PVOID Parameters,
    IN ULONG InputParameterCount,
    IN OUT PULONG OutputParameterCount,
    IN PVOID Data,
    IN ULONG InputDataCount,
    IN ULONG MaxOutputData,
    IN OUT PULONG OutputDataCount
    )

/*++

Routine Description:

    This function handles an OS/2 ioctl.  It convert the Ioctl SMB data
    into an NT ioctl call, makes the call, and format the returned data
    into Ioctl SMB return data.

Arguments:

    WorkContext
    Category
    Function
    Parameters
    InputParameterCount
    OutputParameterCount
    Data
    InputDataCount
    OutputDataCount

Return Value:

    NTSTATUS

--*/

{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    PCHAR buffer;
    PLFCB lfcb = WorkContext->Rfcb->Lfcb;
    HANDLE Handle = lfcb->FileHandle;

    union NT_PARAMTERS {
        SERIAL_BAUD_RATE BaudRate;
        SERIAL_LINE_CONTROL LineControl;
        SERIAL_TIMEOUTS Timeouts;
        SERIAL_QUEUE_SIZE QueueSize;
        ULONG WaitMask;
        ULONG PurgeMask;
        UCHAR ImmediateChar;
        UCHAR Reserved[3];
        SERIAL_CHARS Chars;
        SERIAL_HANDFLOW Handflow;
        SERIAL_STATUS SerialStatus;
    } ntBuffer;

    union SMB_PARAMETERS {
        PSMB_IOCTL_BAUD_RATE BaudRate;
        PSMB_IOCTL_LINE_CONTROL LineControl;
        PSMB_IOCTL_DEVICE_CONTROL DeviceControl;
        PSMB_IOCTL_COMM_ERROR CommError;
        PSMB_IOCTL_PRINTER_ID PrinterId;
    } smbParameters, smbData;

    PAGED_CODE( );

    InputParameterCount, InputDataCount;

    switch ( Category ) {

    case SERIAL_DEVICE:
        switch ( Function )  {

        case GET_BAUD_RATE:
            if( MaxOutputData < sizeof( SMB_IOCTL_BAUD_RATE ) ) {
                status = STATUS_INVALID_SMB;
                break;
            }

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_BAUD_RATE,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_BAUD_RATE )
                         );

           //
           // Convert the response to OS/2 format.
           //
           // !!! ULONG to USHORT conversion.
           //

           smbData.BaudRate = (PSMB_IOCTL_BAUD_RATE)Data;

           if ( NT_SUCCESS( status ) ) {
               smbData.BaudRate->BaudRate = (USHORT) ntBuffer.BaudRate.BaudRate;

               *OutputParameterCount = 0;
               *OutputDataCount = sizeof( SMB_IOCTL_BAUD_RATE );
           }

           break;

        case SET_BAUD_RATE:

           //
           // Convert the request to NT format.
           //

           smbParameters.BaudRate =
               (PSMB_IOCTL_BAUD_RATE)Parameters;

           ntBuffer.BaudRate.BaudRate = smbParameters.BaudRate->BaudRate;

           status = NtDeviceIoControlFile(
                        Handle,
                        0,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        IOCTL_SERIAL_SET_BAUD_RATE,
                        &ntBuffer,
                        sizeof( SERIAL_BAUD_RATE ),
                        NULL,
                        0
                        );

            *OutputParameterCount = 0;
            *OutputDataCount = 0;

            break;

        case SET_LINE_CONTROL:

            //
            // Convert the request to NT format.
            //

            smbParameters.LineControl =
                (PSMB_IOCTL_LINE_CONTROL)Parameters;

            ntBuffer.LineControl.StopBits = smbParameters.LineControl->StopBits;
            ntBuffer.LineControl.Parity = smbParameters.LineControl->Parity;
            ntBuffer.LineControl.WordLength = smbParameters.LineControl->DataBits;

            // !!! What about TransmitBreak?

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_SET_LINE_CONTROL,
                         &ntBuffer,
                         sizeof( SERIAL_LINE_CONTROL ),
                         NULL,
                         0
                         );

             *OutputParameterCount = 0;
             *OutputDataCount = 0;

             break;

        case GET_LINE_CONTROL:

            if( MaxOutputData < sizeof( SMB_IOCTL_LINE_CONTROL ) ) {
                status = STATUS_INVALID_SMB;
                break;
            }

            smbData.LineControl = (PSMB_IOCTL_LINE_CONTROL)Data;

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_LINE_CONTROL,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_LINE_CONTROL )
                         );

            //
            // Convert the response to OS/2 format.
            //

            if ( NT_SUCCESS( status ) ) {
                smbData.LineControl->DataBits =  ntBuffer.LineControl.WordLength;
                smbData.LineControl->Parity =  ntBuffer.LineControl.Parity;
                smbData.LineControl->StopBits =  ntBuffer.LineControl.StopBits;
                smbData.LineControl->TransBreak = 0; // !!!

                *OutputParameterCount = 0;
                *OutputDataCount = sizeof( SMB_IOCTL_LINE_CONTROL );
            }

            break;

        case GET_DCB_INFORMATION:

            if( MaxOutputData < sizeof( SMB_IOCTL_DEVICE_CONTROL ) ) {
                status = STATUS_INVALID_SMB;
                break;
            }

           smbData.DeviceControl =
                (PSMB_IOCTL_DEVICE_CONTROL)Data;

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_TIMEOUTS,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_TIMEOUTS )
                         );

           //
           // Convert the response to OS/2 format.
           //

           // !!! Verify units are correct

           if ( NT_SUCCESS( status ) ) {
               smbData.DeviceControl->WriteTimeout = (USHORT)ntBuffer.Timeouts.ReadIntervalTimeout; // !!!
               smbData.DeviceControl->ReadTimeout = (USHORT)ntBuffer.Timeouts.ReadIntervalTimeout;
           } else {
               break;
           }

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_TIMEOUTS,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_TIMEOUTS )
                         );

           //
           // Convert the response to OS/2 format.
           //

           if ( NT_SUCCESS( status ) ) {
               smbData.DeviceControl->XonChar = ntBuffer.Chars.XonChar;
               smbData.DeviceControl->XoffChar = ntBuffer.Chars.XoffChar;
               smbData.DeviceControl->ErrorReplacementChar = ntBuffer.Chars.ErrorChar;
               smbData.DeviceControl->BreakReplacementChar = ntBuffer.Chars.BreakChar;
           } else {
               break;
           }

           smbData.DeviceControl->ControlHandShake = 0; // !!!
           smbData.DeviceControl->FlowReplace = 0; // !!!
           smbData.DeviceControl->Timeout = 0; // !!!

           *OutputParameterCount = 0;
           *OutputDataCount = sizeof( SMB_IOCTL_DEVICE_CONTROL );

           break;

        case SET_DCB_INFORMATION:

            //
            // Lie.  Pretend this succeeded.
            //

            status = STATUS_SUCCESS;

            *OutputParameterCount = 0;
            *OutputDataCount = 0;
            break;

        case GET_COMM_ERROR:

            //
            // Pretend that there is no comm error.
            //

            smbData.CommError = (PSMB_IOCTL_COMM_ERROR)Data;

            status = STATUS_SUCCESS;

            if ( NT_SUCCESS( status ) ) {
                smbData.CommError->Error = 0;

                *OutputParameterCount = 0;
                *OutputDataCount = sizeof( SMB_IOCTL_COMM_ERROR );
            }

            break;

        case SET_TRANSMIT_TIMEOUT:
        case SET_BREAK_OFF:
        case SET_MODEM_CONTROL:
        case SET_BREAK_ON:
        case STOP_TRANSMIT:
        case START_TRANSMIT:
        case GET_COMM_STATUS:
        case GET_LINE_STATUS:
        case GET_MODEM_OUTPUT:
        case GET_MODEM_INPUT:
        case GET_INQUEUE_COUNT:
        case GET_OUTQUEUE_COUNT:
        case GET_COMM_EVENT:
            status =  STATUS_NOT_IMPLEMENTED;
            break;

        default:
            status = STATUS_INVALID_PARAMETER;

        }

        break;


    case PRINTER_DEVICE:
        IF_SMB_DEBUG( TRANSACTION2 ) {
            KdPrint(( "ProcessOs2Ioctl: print IOCTL function %lx received.\n",
                       Function ));
        }

        switch ( Function )  {

        case GET_PRINTER_STATUS:

            *OutputParameterCount = 0;
            *OutputDataCount = 0;

            if ( *(PCHAR)Parameters != 0 ) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Always return STATUS_PRINTER_HAPPY
                //

                if( MaxOutputData < sizeof( CHAR ) ) {
                    status = STATUS_INVALID_SMB;
                } else {
                    *(PCHAR)Data = (CHAR)OS2_STATUS_PRINTER_HAPPY;

                    *OutputParameterCount = 0;
                    *OutputDataCount = sizeof( CHAR );
                    status = STATUS_SUCCESS;
                }
                break;
            }

        default:

            *OutputParameterCount = 0;
            *OutputDataCount = 0;
            status = STATUS_NOT_SUPPORTED;
        }

        status = STATUS_SUCCESS;
        *OutputParameterCount = 0;
        *OutputDataCount = 0;
        break;


    case SPOOLER_DEVICE:
        IF_SMB_DEBUG( TRANSACTION2 ) {
            KdPrint(( "ProcessOs2Ioctl: spool IOCTL function %lx received.\n",
                       Function ));
        }

        switch ( Function )  {

        case GET_PRINTER_ID:

            {
                PUNICODE_STRING shareName = &WorkContext->TreeConnect->Share->ShareName;
                OEM_STRING ansiShare;

                if( MaxOutputData < 2 * (LM20_CNLEN + 1) ) {
                    status = STATUS_INVALID_SMB;
                    break;
                }

                smbData.PrinterId = (PSMB_IOCTL_PRINTER_ID) Data;
                smbData.PrinterId->JobId = (USHORT)lfcb->JobId;

                buffer = (PCHAR)smbData.PrinterId->Buffer;

                if ( WorkContext->Connection->Endpoint->TransportAddress.Buffer != NULL ) {
                    RtlCopyMemory(
                            buffer,
                            WorkContext->Connection->Endpoint->TransportAddress.Buffer,
                            MIN(WorkContext->Connection->Endpoint->TransportAddress.Length+1,LM20_CNLEN)
                            );
                } else {
                    *buffer = '\0';
                }

                buffer += LM20_CNLEN;
                *buffer++ = '\0';

                status = RtlUnicodeStringToOemString(
                                    &ansiShare,
                                    shareName,
                                    TRUE
                                    );

                if ( NT_SUCCESS(status) ) {

                    if ( ansiShare.Length >= LM20_NNLEN ) {
                        RtlCopyMemory(
                                buffer,
                                ansiShare.Buffer,
                                LM20_NNLEN
                                );
                    } else {
                        RtlCopyMemory(
                                buffer,
                                ansiShare.Buffer,
                                ansiShare.Length + 1
                                );

                    }

                    RtlFreeAnsiString(&ansiShare);

                } else {

                    *buffer = '\0';

                }

                status = STATUS_SUCCESS;

                buffer += LM20_NNLEN;
                *buffer++ = '\0';

                *OutputParameterCount = 0;

                //
                // data length is equal to the job id +
                // the computer name + the share name + 1
                // I don't know what the last + 1 is for but OS/2
                // sends it.
                //

                *OutputDataCount = sizeof(USHORT) + LM20_CNLEN + 1 +
                                    LM20_NNLEN + 2;


            }

            break;


        default:

            *OutputParameterCount = 0;
            *OutputDataCount = 0;
            status = STATUS_NOT_SUPPORTED;

        }

        break;


    case GENERAL_DEVICE:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    default:

        // for OS/2 1.x compatibility

        status = STATUS_SUCCESS;
        *OutputParameterCount = 0;
        *OutputDataCount = 0;
    }

    IF_SMB_DEBUG( TRANSACTION2 ) {

        KdPrint( (
            "Category %x, Function %x returns %lx\n",
            Category,
            Function,
            status
            ));
    }

    return status;

} // ProcessOs2Ioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbnotfy.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbnotfy.c

Abstract:

    This module contains routine for processing the following SMBs:

        NT Notify Change.

Author:

    Manny Weiser (mannyw) 29-Oct-1991

Revision History:

--*/

#include "precomp.h"
#include "smbnotfy.tmh"
#pragma hdrstop

//
// Forward declarations
//

VOID SRVFASTCALL
RestartNtNotifyChange (
    PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbNtNotifyChange )
#pragma alloc_text( PAGE, RestartNtNotifyChange )
#pragma alloc_text( PAGE, SrvSmbFindNotify )
#pragma alloc_text( PAGE, SrvSmbFindNotifyClose )
#endif


SMB_TRANS_STATUS
SrvSmbNtNotifyChange (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an NT notify change SMB.  This request arrives in an
    NT Transaction SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/

{
    PREQ_NOTIFY_CHANGE request;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;
    USHORT fid;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    request = (PREQ_NOTIFY_CHANGE)transaction->InSetup;

    if( transaction->SetupCount * sizeof( USHORT ) < sizeof( REQ_NOTIFY_CHANGE ) ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &request->Fid );

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint((
                "SrvSmbNtIoctl: Status %X on FID: 0x%lx\n",
                status,
                fid
                ));
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_DIRECTORY_CONTROL,
        IRP_MN_NOTIFY_CHANGE_DIRECTORY,
        0,
        &status
        );

    if ( !NT_SUCCESS( status ) ) {
        SrvStatistics.GrantedAccessErrors++;
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartNtNotifyChange;

    //
    // Build the IRP to start a the I/O control.
    // Pass this request to the filesystem.
    //

    SrvBuildNotifyChangeRequest(
        WorkContext->Irp,
        rfcb->Lfcb->FileObject,
        WorkContext,
        SmbGetUlong( &request->CompletionFilter ),
        transaction->OutParameters,
        transaction->MaxParameterCount,
        request->WatchTree
        );

#if DBG_STUCK

    //
    // Since change notify can take an arbitrary amount of time, do
    //  not include it in the "stuck detection & printout" code in the
    //  scavenger
    //
    WorkContext->IsNotStuck = TRUE;

#endif

    (VOID)IoCallDriver(
                IoGetRelatedDeviceObject( rfcb->Lfcb->FileObject ),
                WorkContext->Irp
                );

    //
    // The call was successfully started, return InProgress to the caller
    //

    return SmbTransStatusInProgress;

}


VOID SRVFASTCALL
RestartNtNotifyChange (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an NT Notify Change SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;
    PIRP irp;
    ULONG length;

    PAGED_CODE( );

    //
    // If we built an MDL for this IRP, free it now.
    //

    irp = WorkContext->Irp;

    if ( irp->MdlAddress != NULL ) {
        MmUnlockPages( irp->MdlAddress );
        IoFreeMdl( irp->MdlAddress );
        irp->MdlAddress = NULL;
    }

    status = irp->IoStatus.Status;

    if ( !NT_SUCCESS( status ) ) {

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );

        return;
    }

    //
    // The Notify change request has completed successfully.  Send the
    // response.
    //

    length = (ULONG)irp->IoStatus.Information;
    transaction = WorkContext->Parameters.Transaction;

    if ( irp->UserBuffer != NULL ) {

        //
        // The file system wanted "neither" I/O for this request.  This
        // means that the file system will have allocated a system
        // buffer for the returned data.  Normally this would be copied
        // back to our user buffer during I/O completion, but we
        // short-circuit I/O completion before the copy happens.  So we
        // have to copy the data ourselves.
        //

        if ( irp->AssociatedIrp.SystemBuffer != NULL ) {
            ASSERT( irp->UserBuffer == transaction->OutParameters );
            RtlCopyMemory( irp->UserBuffer, irp->AssociatedIrp.SystemBuffer, length );
        }
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = length;
    transaction->DataCount = 0;

    //
    // !!! Mask a base notify bug, remove when the bug is fixed.
    //

    if ( status == STATUS_NOTIFY_CLEANUP ) {
        transaction->ParameterCount = 0;
    }

    SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusSuccess );
    return;

} // RestartNtNotifyChange


//
// Since OS/2 chose not to expose the DosFindNotifyFirst/Next/Close APIs,
// OS/2 LAN Man does not officially support these SMBs.  This is true,
// even though the Find Notify SMB is documented as a LAN Man 2.0 SMB
// there is code in both the LM2.0 server and redir to support it.
//
// Therefore the NT server will also not support these SMBs.
//

SMB_TRANS_STATUS
SrvSmbFindNotify (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PAGED_CODE( );
    return SrvTransactionNotImplemented( WorkContext );
}

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindNotifyClose (
    SMB_PROCESSOR_PARAMETERS
    )
{
    PAGED_CODE( );
    return SrvSmbNotImplemented( SMB_PROCESSOR_ARGUMENTS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbmpx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    smbmpx.c

Abstract:

    This module contains routines for processing the following SMBs:

        Read Block Multiplexed
        Write Block Multiplexed

    Note that core and raw mode SMB processors are not contained in this
    module.  Check smbrdwrt.c and smbraw.c instead.  SMB commands that
    pertain exclusively to locking (LockByteRange, UnlockByteRange, and
    LockingAndX) are processed in smblock.c.

Author:

    Chuck Lenzmeier (chuckl) 4-Nov-1993

Revision History:

--*/

#include "precomp.h"
#include "smbmpx.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBMPX

#if 0
BOOLEAN MpxDelay = TRUE;
#endif

//
// Stack overflow threshold.  This is used to determine when we are
// getting close to the end of our stack and need to stop recursing
// in SendCopy/MdlReadMpxFragment.
//

#define STACK_THRESHOLD 0xE00

//
// Forward declarations
//

VOID SRVFASTCALL
RestartReadMpx (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
SendCopyReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SendCopyReadMpxFragment2 (
    IN OUT PWORK_CONTEXT
    );

NTSTATUS
SendMdlReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SendMdlReadMpxFragment2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartMdlReadMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN
CheckForWriteMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartPrepareMpxMdlWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
AddPacketToGlom (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartAfterGlomDelay (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartCompleteGlommingInIndication(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteMpxCompleteRfcbClose (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
WriteMpxMdlWriteComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbReadMpx )
#pragma alloc_text( PAGE, RestartMdlReadMpxComplete )
#pragma alloc_text( PAGE, SrvRestartReceiveWriteMpx )
#pragma alloc_text( PAGE, SrvSmbWriteMpxSecondary )
#pragma alloc_text( PAGE, SendCopyReadMpxFragment2 )
#pragma alloc_text( PAGE, SendMdlReadMpxFragment2 )
#pragma alloc_text( PAGE8FIL, RestartReadMpx )
#pragma alloc_text( PAGE8FIL, SendCopyReadMpxFragment )
#pragma alloc_text( PAGE8FIL, RestartCopyReadMpxComplete )
#pragma alloc_text( PAGE8FIL, SendMdlReadMpxFragment )
#endif
#if 0
NOT PAGEABLE -- SrvSmbWriteMpx
NOT PAGEABLE -- RestartWriteMpx
NOT PAGEABLE -- CheckForWriteMpxComplete
NOT PAGEABLE -- RestartCompleteGlommingInIndication
NOT PAGEABLE -- RestartWriteMpxCompleteRfcbClose
NOT PAGEABLE -- WriteMpxMdlWriteComplete
#endif

#if DBG
VOID
DumpMdlChain(
    IN PMDL mdl
    );
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadMpx (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read Mpx SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PSMB_HEADER header;
    PREQ_READ_MPX request;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    ULONG bufferOffset;
    PCHAR readAddress;
    CLONG readLength;
    ULONG key;
    LARGE_INTEGER offset;
    PMDL mdl;
    PVOID mpxBuffer;
    UCHAR minorFunction;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_MPX;
    SrvWmiStartContext(WorkContext);

    header = WorkContext->RequestHeader;
    request = (PREQ_READ_MPX)WorkContext->RequestParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(MPX1) {
        KdPrint(( "Read Block Multiplexed request; FID 0x%lx, "
                    "count %ld, offset %ld\n",
                    fid, SmbGetUshort( &request->MaxCount ),
                    SmbGetUlong( &request->Offset ) ));
    }

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // address is stored in the WorkContext block, and the RFCB address
    // is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status )) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbReadMpx: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;

    if( lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if( rfcb->MpxReadsOk == FALSE ) {

        if ( !rfcb->ReadAccessGranted ) {
            CHECK_PAGING_IO_ACCESS(
                            WorkContext,
                            rfcb->GrantedAccess,
                            &status );
            if ( !NT_SUCCESS( status ) ) {
                SrvStatistics.GrantedAccessErrors++;
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbReadMpx: Read access not granted.\n"));
                }
                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }
        }

        //
        // If this is not a disk file, tell the client to use core read.
        //

        if ( rfcb->ShareType != ShareTypeDisk ) {
            SrvSetSmbError( WorkContext, STATUS_SMB_USE_STANDARD );
            status    = STATUS_SMB_USE_STANDARD;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        rfcb->MpxReadsOk = TRUE;
    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid | SmbGetAlignedUshort( &header->Pid );

    //
    // See if the direct host IPX smart card can handle this read.  If so,
    //  return immediately, and the card will call our restart routine at
    //  SrvIpxSmartCardReadComplete
    //
    if( rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(( "SrvSmbReadMpx: calling SmartCard Read for context %p\n",
                        WorkContext ));
        }

        WorkContext->Parameters.SmartCardRead.MdlReadComplete = lfcb->MdlReadComplete;
        WorkContext->Parameters.SmartCardRead.DeviceObject = lfcb->DeviceObject;

        if( SrvIpxSmartCard.Read( WorkContext->RequestBuffer->Buffer,
                                  rfcb->PagedRfcb->IpxSmartCardContext,
                                  key,
                                  WorkContext ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "  SrvSmbReadMpx:  SmartCard Read returns TRUE\n" ));
            }

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        IF_DEBUG( SIPX ) {
            KdPrint(( "  SrvSmbReadMpx:  SmartCard Read returns FALSE\n" ));
        }
    }

    //
    // Get the file offset.
    //

    WorkContext->Parameters.ReadMpx.Offset = SmbGetUlong( &request->Offset );
    offset.QuadPart = WorkContext->Parameters.ReadMpx.Offset;

    //
    // Calculate the address in the buffer at which to put the data.
    // This must be rounded up to a dword boundary.  (The -1 below is
    // because sizeof(RESP_READ_MPX) includes one byte of Buffer.)
    //

    bufferOffset = (sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX, Buffer) + 3) & ~3;

    //
    // Calculate how much data we can send back in each fragment.  This
    // is the size of the client's buffer, rounded down to a dword multiple.
    //
    // *** Because we use the SMB buffer's partial MDL to describe the
    //     data fragments that we return, we need to limit the fragment
    //     size to the SMB buffer size.  Normally the client's buffer
    //     size is <= ours, so this shouldn't be a factor.
    //

    WorkContext->Parameters.ReadMpx.FragmentSize =
        (USHORT)((MIN( lfcb->Session->MaxBufferSize,
                       SrvReceiveBufferLength ) - bufferOffset) & ~3);

    //
    // If the SMB buffer is large enough, use it to do the local read.
    //

    readLength = SmbGetUshort( &request->MaxCount );

    if ( //0 &&
         (readLength <= SrvMpxMdlReadSwitchover) ) {

do_copy_read:

        WorkContext->Parameters.ReadMpx.MdlRead = FALSE;
        WorkContext->Parameters.ReadMpx.MpxBuffer = NULL;
        WorkContext->Parameters.ReadMpx.MpxBufferMdl =
                                        WorkContext->ResponseBuffer->Mdl;

        readAddress = (PCHAR)WorkContext->ResponseHeader + bufferOffset;
        WorkContext->Parameters.ReadMpx.NextFragmentAddress = readAddress;

        //
        // Try the fast I/O path first.
        //

        if ( lfcb->FastIoRead != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {                
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        readAddress,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Send the data.
                    //
    
                    WorkContext->bAlreadyTrace = TRUE;
                    RestartReadMpx( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.  Build an MDL describing the read buffer.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            readAddress,
            readLength
            );
        mdl = WorkContext->ResponseBuffer->PartialMdl;
        minorFunction = 0;

    } else {

        //
        // The SMB buffer isn't big enough.  Does the target file system
        // support the cache manager routines?
        //

        if ( //0 &&
             (lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

            WorkContext->Parameters.ReadMpx.MdlRead = TRUE;

            //
            // We can use an MDL read.  Try the fast I/O path first.
            //

            WorkContext->Irp->MdlAddress = NULL;
            WorkContext->Irp->IoStatus.Information = 0;
            WorkContext->Parameters.ReadMpx.ReadLength = readLength;

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            if ( lfcb->MdlRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    key,
                    &WorkContext->Irp->MdlAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) && WorkContext->Irp->MdlAddress != NULL ) {

                //
                // The fast I/O path worked.  Send the data.
                //

                WorkContext->bAlreadyTrace = TRUE;
                RestartReadMpx( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            //
            // The fast I/O path failed.  We need to issue a regular MDL
            // read request.
            //
            // The fast path may have partially succeeded, returning a
            // partial MDL chain.  We need to adjust our read request
            // to account for that.
            //

            offset.QuadPart += WorkContext->Irp->IoStatus.Information;
            readLength -= (ULONG)WorkContext->Irp->IoStatus.Information;

            mdl = WorkContext->Irp->MdlAddress;
            minorFunction = IRP_MN_MDL;

        } else if (readLength > (WorkContext->ResponseBuffer->BufferLength -
                    bufferOffset)) {

            //
            // We have to use a normal "copy" read.  We need to allocate
            // a separate buffer.
            //

            WorkContext->Parameters.ReadMpx.MdlRead = FALSE;

            mpxBuffer = ALLOCATE_NONPAGED_POOL(
                            readLength,
                            BlockTypeDataBuffer
                            );
            if ( mpxBuffer == NULL ) {
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                status    = STATUS_INSUFF_SERVER_RESOURCES;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }
            WorkContext->Parameters.ReadMpx.MpxBuffer = mpxBuffer;
            WorkContext->Parameters.ReadMpx.NextFragmentAddress = mpxBuffer;
            readAddress = mpxBuffer;

            //
            // We also need an MDL to describe the buffer.
            //

            mdl = IoAllocateMdl( mpxBuffer, readLength, FALSE, FALSE, NULL );
            if ( mdl == NULL ) {
                DEALLOCATE_NONPAGED_POOL( mpxBuffer );
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                status    = STATUS_INSUFF_SERVER_RESOURCES;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            WorkContext->Parameters.ReadMpx.MpxBufferMdl = mdl;

            //
            // Build the mdl.
            //

            MmBuildMdlForNonPagedPool( mdl );

            //
            // Try the fast I/O path first.
            //

            if ( lfcb->FastIoRead != NULL ) {

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

                try {
                    if ( lfcb->FastIoRead(
                            lfcb->FileObject,
                            &offset,
                            readLength,
                            TRUE,
                            key,
                            mpxBuffer,
                            &WorkContext->Irp->IoStatus,
                            lfcb->DeviceObject
                            ) ) {
    
                        //
                        // The fast I/O path worked.  Send the data.
                        //
    
                        WorkContext->bAlreadyTrace = TRUE;
                        RestartReadMpx( WorkContext );
                        SmbStatus = SmbStatusInProgress;
                        goto Cleanup;
                    }
                }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    // Fall through to the slow path on an exception
                    NTSTATUS status = GetExceptionCode();
                    IF_DEBUG(ERRORS) {
                        KdPrint(("FastIoRead threw exception %x\n", status ));
                    }
                }

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            }

            //
            // The fast I/O path failed, so we need to use a regular copy
            // I/O request.
            //

            minorFunction = 0;

        } else {

            goto do_copy_read;
        }

    } // read fits in SMB buffer?

    //
    // Build the read request, reusing the receive IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_READ,                    // major function code
            minorFunction,                  // minor function code
            readAddress,                    // buffer address
            readLength,                     // buffer length
            mdl,                            // MDL address
            offset,                         // byte offset
            key                             // lock key
            );

    //
    // Pass the request to the file system.
    //

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = RestartReadMpx;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //
    SmbStatus = SmbStatusInProgress;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbReadMpx


VOID SRVFASTCALL
RestartReadMpx (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a Read MPX SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_MPX response;

    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    LARGE_INTEGER position;
    KIRQL oldIrql;
    USHORT readLength;
    ULONG offset;
    PMDL mdl;
    BOOLEAN mdlRead;
    PIRP irp = WorkContext->Irp;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_MPX;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) KdPrint(( " - RestartReadMpx\n" ));

    //
    // If we just completed an MDL read, we need to remember the address
    // of the first MDL in the returned chain, so that we can give it
    // back to the cache manager when we're done.
    //

    mdlRead = WorkContext->Parameters.ReadMpx.MdlRead;
    if ( mdlRead ) {
        mdl = irp->MdlAddress;
        //KdPrint(( "Read MDL chain:\n" ));
        //DumpMdlChain( mdl );
        WorkContext->Parameters.ReadMpx.FirstMdl = mdl;
    }

    //
    // If the read failed, set an error status in the response header.
    // (If we tried to read entirely beyond the end of file, we return a
    // normal response indicating that nothing was read.)
    //

    status = irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) && (status != STATUS_END_OF_FILE) ) {

        IF_DEBUG(ERRORS) KdPrint(( "Read failed: %X\n", status ));
        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = RestartReadMpx;
            SrvQueueWorkToFsp( WorkContext );
            goto Cleanup;
        }

        SrvSetSmbError( WorkContext, status );
respond:
        if ( mdlRead ) {
            SrvFsdSendResponse2( WorkContext, RestartMdlReadMpxComplete );
        } else {
            WorkContext->ResponseBuffer->DataLength =
                (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                    (PCHAR)WorkContext->ResponseHeader );
            WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;
            SRV_START_SEND_2(
                        WorkContext,
                        RestartCopyReadMpxComplete,
                        NULL,
                        NULL );
        }
        goto Cleanup;
    }

    //
    // Get the amount of data actually read.
    //

    if ( status == STATUS_END_OF_FILE ) {

        //
        // The read started beyond the end of the file.
        //

        readLength = 0;

    } else if ( mdlRead ) {

        //
        // For an MDL read, we have to walk the MDL chain in order to
        // determine how much data was read.  This is because the
        // operation may have happened in multiple steps, with the MDLs
        // being chained together.  For example, part of the read may
        // have been satisfied by the fast path, while the rest was
        // satisfied using an IRP.
        //

        readLength = 0;
        while ( mdl != NULL ) {
            readLength += (USHORT)MmGetMdlByteCount(mdl);
            mdl = mdl->Next;
        }

    } else {

        //
        // Copy read.  The I/O status block has the length.
        //

        readLength = (USHORT)irp->IoStatus.Information;

    }

    //
    // Update the file position.
    //

    offset = WorkContext->Parameters.ReadMpx.Offset;

    WorkContext->Rfcb->CurrentPosition =  offset + readLength;

    //
    // Update statistics.
    //

    UPDATE_READ_STATS( WorkContext, readLength );

    //
    // Special-case 0 bytes read.
    //

    response = (PRESP_READ_MPX)WorkContext->ResponseParameters;
    response->WordCount = 8;
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->Reserved, 0 );

    if ( readLength == 0 ) {

        SmbPutUlong( &response->Offset, offset );
        SmbPutUshort( &response->Count, 0 );
        SmbPutUshort( &response->Remaining, 0 );
        SmbPutUshort( &response->DataLength, 0 );
        SmbPutUshort( &response->DataOffset, 0 );
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_READ_MPX,
                                            0
                                            );
        goto respond;
    }

    //
    // Build the static response header/parameters.
    //

    SmbPutUshort( &response->Count, readLength );
    SmbPutUshort(
        &response->DataOffset,
        (sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX, Buffer) + 3) & ~3
        );

    //
    // We will use two MDLs to describe the packet we're sending -- one
    // for the header and parameters, and another for the data.  So we
    // set the "response length" to not include the data.  This is what
    // SrvStartSend uses to set the first MDL's length.
    //
    // Handling of the second MDL varies depending on whether we did a
    // copy read or an MDL read.
    //

    ASSERT( ((sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer)) & 3) == 3 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_READ_MPX,
                                        1 // pad byte
                                        );
    WorkContext->ResponseBuffer->Mdl->ByteCount =
                    (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                (PCHAR)WorkContext->ResponseHeader );
    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Start sending fragments.
    //

    WorkContext->Parameters.ReadMpx.RemainingLength = readLength;
    ASSERT( WorkContext->ResponseBuffer->Mdl->Next == NULL );
    WorkContext->ResponseBuffer->Mdl->Next =
                                WorkContext->ResponseBuffer->PartialMdl;
    WorkContext->ResponseBuffer->PartialMdl->Next = NULL;

    if ( mdlRead ) {

        WorkContext->Parameters.ReadMpx.CurrentMdl =
                            WorkContext->Parameters.ReadMpx.FirstMdl;
        WorkContext->Parameters.ReadMpx.CurrentMdlOffset = 0;
        (VOID)SendMdlReadMpxFragment( NULL, irp, WorkContext );

    } else {

        (VOID)SendCopyReadMpxFragment( NULL, irp, WorkContext );
    }

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartReadMpx

VOID SRVFASTCALL
SendCopyReadMpxFragment2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Stub to call actual routine.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    (VOID) SendCopyReadMpxFragment( NULL, WorkContext->Irp, WorkContext );

} // SendCopyReadMpxFragment2

NTSTATUS
SendCopyReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Sends a Read Mpx response fragment when copy read was used.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_MPX response;

    USHORT fragmentSize;
    USHORT remainingLength;
    ULONG offset;
    PCHAR fragmentAddress;

    PIO_COMPLETION_ROUTINE sendCompletionRoutine;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Turn off cancel boolean
    //

    Irp->Cancel = FALSE;

    //
    // Get context.
    //

    fragmentSize = WorkContext->Parameters.ReadMpx.FragmentSize;
    remainingLength = WorkContext->Parameters.ReadMpx.RemainingLength;
    offset = WorkContext->Parameters.ReadMpx.Offset;
    fragmentAddress = WorkContext->Parameters.ReadMpx.NextFragmentAddress;

    //
    // If the amount left to send is less than the fragment size, only
    // send the remaining amount.  Update the remaining amount.
    //

    if ( remainingLength < fragmentSize ) {
        fragmentSize = remainingLength;
    }
    ASSERT( fragmentSize != 0 );
    remainingLength -= fragmentSize;

    //
    // Build the response parameters.
    //

    response = (PRESP_READ_MPX)(WorkContext->ResponseHeader + 1);
    SmbPutUshort( &response->Remaining, remainingLength );
    SmbPutUlong( &response->Offset, offset );
    SmbPutUshort( &response->DataLength, fragmentSize );
    ASSERT( ((sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX, Buffer)) & 3) == 3 );
    SmbPutUshort( &response->ByteCount, fragmentSize + 1 ); // account for padding

    //
    // Build a partial MDL describing the data.
    //

    IoBuildPartialMdl(
        WorkContext->Parameters.ReadMpx.MpxBufferMdl,
        WorkContext->ResponseBuffer->PartialMdl,
        fragmentAddress,
        fragmentSize
        );

    //
    // Final preparation for the send depends on whether this is the
    // last fragment.
    //

    if ( remainingLength != 0 ) {

        //
        // Not done.  Update context.  Set up to restart after the send
        // in this routine.  We want do this as an FSD restart routine.
        // But this may recurse, if the send doesn't pend, so we may use
        // up the stack.  If we are running out of stack, restart here
        // in the FSP.
        //

        WorkContext->Parameters.ReadMpx.RemainingLength = remainingLength;
        WorkContext->Parameters.ReadMpx.Offset += fragmentSize;
        WorkContext->Parameters.ReadMpx.NextFragmentAddress += fragmentSize;

        if ( IoGetRemainingStackSize() >= STACK_THRESHOLD ) {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            sendCompletionRoutine = SendCopyReadMpxFragment;
        } else {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            WorkContext->FspRestartRoutine = SendCopyReadMpxFragment2;
            sendCompletionRoutine = SrvQueueWorkToFspAtSendCompletion;
        }

    } else {

        //
        // This is the last fragment.  Restart in the cleanup routine.
        //

        DEBUG WorkContext->FsdRestartRoutine = NULL;
        DEBUG WorkContext->FspRestartRoutine = NULL;
        sendCompletionRoutine = RestartCopyReadMpxComplete;
    }

    //
    // Send the fragment.
    //

    WorkContext->ResponseBuffer->DataLength =  // +1 for pad
        sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer) + 1 + fragmentSize;

    if ( WorkContext->Endpoint->IsConnectionless ) {
        SrvIpxStartSend( WorkContext, sendCompletionRoutine );
    } else {
        SrvStartSend2( WorkContext, sendCompletionRoutine );
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SendCopyReadMpxFragment

VOID SRVFASTCALL
SendMdlReadMpxFragment2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Stub to call actual routine.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    (VOID) SendMdlReadMpxFragment( NULL, WorkContext->Irp, WorkContext );

} // SendMdlReadMpxFragment2

NTSTATUS
SendMdlReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Sends a Read Mpx response fragment when MDL read was used.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_MPX response;
    PIO_COMPLETION_ROUTINE sendCompletionRoutine;

    USHORT fragmentSize;
    USHORT remainingLength;
    ULONG offset;
    PCHAR fragmentAddress;
    PMDL mdl;
    ULONG mdlOffset;
    ULONG partialLength;
    ULONG lengthNeeded;
    PCHAR startVa;
    PCHAR systemVa;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Turn off cancel boolean
    //

    Irp->Cancel = FALSE;

    //
    // Get context.
    //

    fragmentSize = WorkContext->Parameters.ReadMpx.FragmentSize,
    remainingLength = WorkContext->Parameters.ReadMpx.RemainingLength;
    offset = WorkContext->Parameters.ReadMpx.Offset;

    //
    // If the amount left to send is less than the fragment size, only
    // send the remaining amount.  Update the remaining amount.
    //

    if ( remainingLength < fragmentSize ) {
        fragmentSize = remainingLength;
    }
    ASSERT( fragmentSize != 0 );
    remainingLength -= fragmentSize;

    //
    // Build the response parameters.
    //

    response = (PRESP_READ_MPX)(WorkContext->ResponseHeader + 1);
    SmbPutUshort( &response->Remaining, remainingLength );
    SmbPutUlong( &response->Offset, offset );
    SmbPutUshort( &response->DataLength, fragmentSize );
    ASSERT( ((sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer)) & 3) == 3 );
    SmbPutUshort( &response->ByteCount, fragmentSize + 1 ); // account for padding

    //
    // If the current MDL doesn't describe all of the data we need to
    // send, we need to play some games.
    //

    MmPrepareMdlForReuse( WorkContext->ResponseBuffer->PartialMdl );

    mdl = WorkContext->Parameters.ReadMpx.CurrentMdl;
    startVa = MmGetMdlVirtualAddress( mdl );
    mdlOffset = WorkContext->Parameters.ReadMpx.CurrentMdlOffset;
    partialLength = MmGetMdlByteCount(mdl) - mdlOffset;

    if ( partialLength >= fragmentSize ) {

        //
        // The current MDL has all of the data we need to send.  Build
        // a partial MDL describing that data.
        //

        IoBuildPartialMdl(
            mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            startVa + mdlOffset,
            fragmentSize
            );

        //
        // Indicate how much data we're taking out of the current MDL.
        //

        partialLength = fragmentSize;

    } else {

        //
        // The data we need is spread across more than one MDL.  Painful
        // as this seems, we need to copy the data into the standard
        // response buffer.  It's possible that we could play some games
        // with the MDLs and avoid the copy, but it doesn't seem worth it.
        // There is, after all, additional cost in the NDIS driver for
        // chaining MDLs together.
        //
        // *** Note that we still send a second MDL, even though the data
        //     for this send will abut the response parameters.
        //
        // Calculate the address of the buffer.  Build a partial MDL
        // describing it.
        //

        fragmentAddress = (PCHAR)WorkContext->ResponseBuffer->Buffer +
                            sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer) + 1;

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            fragmentAddress,
            fragmentSize
            );
        ASSERT( WorkContext->ResponseBuffer->PartialMdl->Next == NULL );

        //
        // Copy from the current MDL into the buffer.
        //

        systemVa = MmGetSystemAddressForMdl( mdl );
        RtlCopyMemory( fragmentAddress, systemVa + mdlOffset, partialLength );

        //
        // Update the destination address and set the remaining copy
        // amount.
        //

        fragmentAddress += partialLength;
        lengthNeeded = fragmentSize - partialLength;
        ASSERT( lengthNeeded != 0 );

        do {

            //
            // Move to the next MDL.
            //

            mdl = mdl->Next;
            ASSERT( mdl != NULL );

            //
            // Calculate how much we can (and need to) copy out of this
            // MDL, and do the copy.
            //

            startVa = MmGetMdlVirtualAddress( mdl );
            partialLength = MIN( MmGetMdlByteCount(mdl), lengthNeeded );
            systemVa = MmGetSystemAddressForMdl( mdl );
            RtlCopyMemory( fragmentAddress, systemVa, partialLength );

            //
            // Update the destination address and the remaining copy
            // amount.  We may be done.
            //

            fragmentAddress += partialLength;
            lengthNeeded -= partialLength;

        } while ( lengthNeeded != 0 );

        //
        // We just copied from the beginning of the current MDL.
        //

        mdlOffset = 0;

    }

    //
    // Final preparation for the send depends on whether this is the
    // last fragment.
    //

    if ( remainingLength != 0 ) {

        //
        // Not done.  Update the current MDL position.  If we have
        // finished off the current MDL, move to the next one.
        //

        mdlOffset += partialLength;
        if ( mdlOffset >= MmGetMdlByteCount(mdl) ) {
            mdl = mdl->Next;
            ASSERT( mdl != NULL );
            mdlOffset = 0;
        }

        //
        // Update context.  Set up to restart after the send in this
        // routine.  We want do this as an FSD restart routine.  But
        // this may recurse, if the send doesn't pend, so we may use up
        // the stack.  If we are running out of stack, restart here in
        // the FSP.
        //

        WorkContext->Parameters.ReadMpx.CurrentMdl = mdl;
        WorkContext->Parameters.ReadMpx.CurrentMdlOffset = (USHORT)mdlOffset;
        WorkContext->Parameters.ReadMpx.RemainingLength = remainingLength;
        WorkContext->Parameters.ReadMpx.Offset += fragmentSize;

        if ( IoGetRemainingStackSize() >= STACK_THRESHOLD ) {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            sendCompletionRoutine = SendMdlReadMpxFragment;
        } else {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            WorkContext->FspRestartRoutine = SendMdlReadMpxFragment2;
            sendCompletionRoutine = SrvQueueWorkToFspAtSendCompletion;
        }

    } else {

        //
        // This is the last fragment.  Restart in the cleanup routine.
        //

        DEBUG WorkContext->FsdRestartRoutine = NULL;
        WorkContext->FspRestartRoutine = RestartMdlReadMpxComplete;
        sendCompletionRoutine = SrvQueueWorkToFspAtSendCompletion;
    }

    //
    // Send the fragment.
    //

    WorkContext->ResponseBuffer->DataLength =  // +1 for pad
        sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer) + 1 + fragmentSize;

    if ( WorkContext->Endpoint->IsConnectionless ) {
        SrvIpxStartSend( WorkContext, sendCompletionRoutine );
    } else {
        SrvStartSend2( WorkContext, sendCompletionRoutine );
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SendMdlReadMpxFragment


NTSTATUS
RestartCopyReadMpxComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the final completion routine for Read Mpx when copy read is
    used.  It is called after the send of the last fragment completes.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    KIRQL oldIrql;
    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    ASSERT( !WorkContext->Parameters.ReadMpx.MdlRead );

    //
    // If we allocated a separate buffer to do the read, free it and its
    // MDL now.
    //

    if ( WorkContext->Parameters.ReadMpx.MpxBuffer != NULL ) {
        DEALLOCATE_NONPAGED_POOL( WorkContext->Parameters.ReadMpx.MpxBuffer );
        IoFreeMdl( WorkContext->Parameters.ReadMpx.MpxBufferMdl );
    }

    WorkContext->ResponseBuffer->Mdl->Next = NULL;

    //
    // Complete and requeue the work item.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    SrvFsdRestartSmbComplete( WorkContext );
    KeLowerIrql( oldIrql );

    return STATUS_MORE_PROCESSING_REQUIRED;

} // RestartCopyReadMpxComplete


VOID SRVFASTCALL
RestartMdlReadMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the final completion routine for Read Mpx when MDL read is
    used.  It is called after the send of the last fragment completes.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    LARGE_INTEGER offset;

    PAGED_CODE( );

    ASSERT( WorkContext->Parameters.ReadMpx.MdlRead );

    //
    // Give the MDL back to the cache manager.  (If the read failed or
    // returned no data, there will be no MDL.)
    //

    MmPrepareMdlForReuse( WorkContext->ResponseBuffer->PartialMdl );

    if ( WorkContext->Parameters.ReadMpx.FirstMdl != NULL ) {
        //KdPrint(( "Freeing MDL chain:\n" ));
        //DumpMdlChain( WorkContext->Parameters.ReadMpx.FirstMdl );

        if( WorkContext->Rfcb->Lfcb->MdlReadComplete == NULL ||

            WorkContext->Rfcb->Lfcb->MdlReadComplete(
                WorkContext->Rfcb->Lfcb->FileObject,
                WorkContext->Parameters.ReadMpx.FirstMdl,
                WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

            offset.QuadPart = WorkContext->Parameters.ReadMpx.Offset;

            //
            // Fast path didn't work, try an IRP...
            //
            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 WorkContext->Parameters.ReadMpx.FirstMdl,
                                                 IRP_MJ_READ,
                                                 &offset,
                                                 WorkContext->Parameters.ReadMpx.ReadLength
                                               );
            if( !NT_SUCCESS( status ) ) {
                //
                // All we can do is complain now!
                //
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }

        }
    }

    WorkContext->ResponseBuffer->Mdl->Next = NULL;

    //
    // Free the work item by dereferencing it.
    //

    SrvDereferenceWorkItem( WorkContext );
    return;

} // RestartMdlReadMpxComplete

VOID SRVFASTCALL
SrvRestartReceiveWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine replaces the normal restart routine for TDI Receive
    completion when a Write Mpx SMB is received over IPX.  If a receive
    error occurs, or if the SMB is invalid, it cleans up the active
    write mpx state that was set up in SrvIpxServerDatagramHandler.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    SMB_STATUS smbStatus;
    PCONNECTION connection;
    PIRP irp;
    PSMB_HEADER header;
    ULONG length;

    PAGED_CODE( );

    connection = WorkContext->Connection;
    irp = WorkContext->Irp;

    //
    // Save the length of the received message.  Store the length
    // in the work context block for statistics gathering.
    //

    length = (ULONG)irp->IoStatus.Information;
    WorkContext->RequestBuffer->DataLength = length;
    WorkContext->CurrentWorkQueue->stats.BytesReceived += length;

    //
    // Store in the work context block the time at which processing
    // of the request began.  Use the time that the work item was
    // queued to the FSP for this purpose.
    //

    WorkContext->StartTime = WorkContext->Timestamp;

    //
    // Update the server network error count.  If the TDI receive
    // failed or was canceled, don't try to process an SMB.
    //

    status = irp->IoStatus.Status;
    if ( irp->Cancel || !NT_SUCCESS(status) ) {
        IF_DEBUG(NETWORK_ERRORS) {
            KdPrint(( "SrvRestartReceiveWriteMpx: status = %X for IRP %p\n",
                irp->IoStatus.Status, irp ));
        }
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, TRUE );
        if ( NT_SUCCESS(status) ) status = STATUS_CANCELLED;
        goto cleanup;
    }

    SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

    //
    // We (should) have received an SMB.
    //

    SMBTRACE_SRV2(
        WorkContext->ResponseBuffer->Buffer,
        WorkContext->ResponseBuffer->DataLength
        );

    //
    // Initialize the error class and code fields in the header to
    // indicate success.
    //

    header = WorkContext->ResponseHeader;

    SmbPutUlong( &header->ErrorClass, STATUS_SUCCESS );

    //
    // If the connection is closing or the server is shutting down,
    // ignore this SMB.
    //

    if ( (GET_BLOCK_STATE(connection) != BlockStateActive) ||
         SrvFspTransitioning ) {
        goto cleanup;
    }

    //
    // Verify the SMB to make sure that it has a valid header, and that
    // the word count and byte count are within range.
    //

    WorkContext->NextCommand = header->Command;

    if ( !SrvValidateSmb( WorkContext ) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvRestartReceiveWriteMpx: Invalid SMB.\n" ));
            KdPrint(( "  SMB received from %z\n",
                       (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));
        }

        //
        // The SMB is invalid.  We send back an INVALID_SMB status.
        //

        status = STATUS_INVALID_SMB;
        goto cleanup;
    }

    //
    // Clear the flag that indicates the we just sent an oplock break II
    // to none.  This allows subsequent raw reads to be processed.
    //

    //not needed on IPX//connection->BreakIIToNoneJustSent = FALSE;

    //
    // Process the received SMB.  The called routine is responsible
    // for sending any response(s) that are needed and for getting
    // the receive buffer back onto the receive queue as soon as
    // possible.
    //

    smbStatus = SrvSmbWriteMpx( WorkContext );
    ASSERT( smbStatus != SmbStatusMoreCommands );

    if ( smbStatus != SmbStatusInProgress ) {
        //
        // Return the TransportContext
        //
        if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
            TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
        }
        SrvEndSmbProcessing( WorkContext, smbStatus );
    }

    return;

cleanup:

    //
    // We will not be processing this write.  We still need to check
    // for whether this is the last Write Mpx active on the RFCB, and
    // if so, send the response to the write.
    //
    // *** Note that if we are here because we received an invalid
    //     SMB, the completion of the Write Mpx overrides the sending
    //     of an error response.
    //

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
    }

    if ( CheckForWriteMpxComplete( WorkContext ) ) {
        SrvFsdSendResponse( WorkContext );
    } else if ( status == STATUS_INVALID_SMB ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SrvFsdSendResponse( WorkContext );
    } else {
        SrvDereferenceWorkItem( WorkContext );
    }

    return;

} // SrvRestartReceiveWriteMpx


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpx (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write Mpx SMB.

    *** The server currently does not support multiplexed mode reads and
        writes on connection-based transports.  When such requests are
        received, the error "use standard mode" is returned.
        Multiplexed mode turns out not to be the performance win it was
        thought to be (on local nets), so we haven't implemented it,
        except over IPX.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;
    PRESP_WRITE_MPX_DATAGRAM response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    USHORT mid;
    PRFCB rfcb;
    PLFCB lfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    CLONG bufferOffset;
    PCHAR writeAddress;
    USHORT writeLength;
    ULONG key;
    LARGE_INTEGER offset;
    USHORT writeMode;
    BOOLEAN writeThrough;
    KIRQL oldIrql;
    PMDL mdl;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_MPX;
    SrvWmiStartContext(WorkContext);

    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(MPX1) {
        KdPrint(( "Write Block Multipliexed request; FID 0x%lx, "
                    "count %ld, offset %ld\n",
                    fid, SmbGetUshort( &request->Count ),
                    SmbGetUlong( &request->Offset ) ));
    }

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    writeMode = SmbGetUshort( &request->WriteMode );

    if( (writeMode & SMB_WMODE_DATAGRAM) == 0 ||
        !WorkContext->Endpoint->IsConnectionless ) {

        SrvFsdBuildWriteCompleteResponse( WorkContext, STATUS_SMB_USE_STANDARD, 0 );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbWriteMpx: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            goto error;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvFsdBuildWriteCompleteResponse( WorkContext, status, 0 );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    if( !rfcb->MpxWritesOk ) {

        if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbWriteMpx: Write access not granted.\n"));
            }
            status = STATUS_ACCESS_DENIED;
            goto error;
        }

        //
        // If this is not a disk or a print file tell the client to use core write.
        //

        if ( rfcb->ShareType != ShareTypeDisk &&
              rfcb->ShareType != ShareTypePrint ) {

            status = STATUS_SMB_USE_STANDARD;
            goto error;
        }

        rfcb->MpxWritesOk = TRUE;
    }

    rfcb->WrittenTo = TRUE;
#ifdef INCLUDE_SMB_IFMODIFIED
    rfcb->Lfcb->FileUpdated = TRUE;
#endif

    //
    // If this a stale packet, ignore it.  Stale here means that the MID
    // of the packet is not equal to the MID of the current write mux.
    // Such a packet can be received if a duplicate packet from a
    // previous write mux is delivered after a new write mux starts.
    //

    writeMpx = &rfcb->WriteMpx;

    mid = SmbGetAlignedUshort( &header->Mid );

    if ( mid != writeMpx->Mid ) {

        //
        // Set the sequence number to 0 so that we don't send a response
        // unless we have to because the Write Mpx refcount drops to 0.
        //

        SmbPutAlignedUshort( &header->SequenceNumber, 0 );
        goto error;
    }

    //
    // Get the file offset.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    //
    // If we have the transport context, then setup WriteAddress accordingly.
    //

    WorkContext->Parameters.WriteMpx.DataMdl = NULL;

    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {

        writeAddress = (PCHAR)WorkContext->Parameters.WriteMpx.Buffer + bufferOffset;

    } else {

        writeAddress = (PCHAR)header + bufferOffset;

    }

    writeLength =
        (USHORT)(MIN( (CLONG)SmbGetUshort( &request->DataLength ),
                      WorkContext->ResponseBuffer->DataLength - bufferOffset ));

    //
    // Save context for the restart routine.
    //

    WorkContext->Parameters.WriteMpx.WriteLength = writeLength;

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid | SmbGetAlignedUshort( &header->Pid );

    //
    // If this is the first packet of a new MID, set up to glom the
    // packets into one big write.
    //

    lfcb = rfcb->Lfcb;

    if ( WorkContext->Parameters.WriteMpx.FirstPacketOfGlom ) {

        //
        // Try the fast path first.
        //

        WorkContext->Irp->MdlAddress = NULL;
        WorkContext->Irp->IoStatus.Information = 0;

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        ASSERT( lfcb->FileObject->Flags & FO_CACHE_SUPPORTED );

        writeLength = SmbGetUshort( &request->Count );

        writeMpx->StartOffset = offset.LowPart;
        writeMpx->Length = writeLength;

        if ( lfcb->PrepareMdlWrite(
                lfcb->FileObject,
                &offset,
                writeLength,
                key,
                &WorkContext->Irp->MdlAddress,
                &WorkContext->Irp->IoStatus,
                lfcb->DeviceObject
                ) && WorkContext->Irp->MdlAddress != NULL ) {

            //
            // The fast I/O path worked.
            //

            WorkContext->bAlreadyTrace = TRUE;
            RestartPrepareMpxMdlWrite( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

        //
        // The fast I/O path failed.  Build the write request, reusing the
        // receive IRP.
        //
        // The fast path may have partially succeeded, returning a partial
        // MDL chain.  We need to adjust our write request to account for
        // that.
        //

        offset.QuadPart += WorkContext->Irp->IoStatus.Information;

        writeLength -= (USHORT)WorkContext->Irp->IoStatus.Information;

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,                   // input IRP address
                lfcb->FileObject,                   // target file object address
                WorkContext,                        // context
                IRP_MJ_WRITE,                       // major function code
                IRP_MN_MDL,                         // minor function code
                NULL,                               // buffer address (ignored)
                writeLength,                        // buffer length
                WorkContext->Irp->MdlAddress,       // MDL address
                offset,                             // byte offset
                key                                 // lock key
                );

        //
        // Pass the request to the file system.
        //

            WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = RestartPrepareMpxMdlWrite;
        DEBUG WorkContext->FspRestartRoutine = NULL;

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The MDL write has been started.  When it completes, processing
        // resumes at RestartPrepareMpxMdlWrite.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Save context for the restart routine.
    //

    WorkContext->Parameters.WriteMpx.Offset = offset.LowPart;
    WorkContext->Parameters.WriteMpx.Mid = mid;

    if ( writeMpx->GlomPending ) {

        //
        // A glom setup is pending.  Wait for that to complete.
        //

        ACQUIRE_SPIN_LOCK( &rfcb->Connection->SpinLock, &oldIrql );

        if ( writeMpx->GlomPending ) {
            InsertTailList(
                &writeMpx->GlomDelayList,
                &WorkContext->ListEntry
                );
            RELEASE_SPIN_LOCK( &rfcb->Connection->SpinLock, oldIrql );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        RELEASE_SPIN_LOCK( &rfcb->Connection->SpinLock, oldIrql );

    }

    if ( writeMpx->Glomming ) {

        //
        // We're glomming this into one big write.  Add the data from
        // this packet.
        //

        AddPacketToGlom( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }


    //
    // We are not glomming this write, because we missed the first
    // packet of the write.  So we write each block as it arrives.
    //
    // If the file's writethrough mode needs to be changed, do so now.
    //

    writeThrough = (BOOLEAN)((writeMode & SMB_WMODE_WRITE_THROUGH) != 0);

    if ( writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) == 0
        || !writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) != 0 ) {

        SrvSetFileWritethroughMode( lfcb, writeThrough );

    }

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
    
                WorkContext->bAlreadyTrace = TRUE;
                RestartWriteMpx( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //
    // Build an MDL describing the write buffer.  Note that if the file
    // system can complete the write immediately, the MDL isn't really
    // needed, but if the file system must send the request to its FSP,
    // the MDL _is_ needed.
    //
    // *** Note the assumption that the request buffer already has a
    //     valid full MDL from which a partial MDL can be built.
    //

    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {

        mdl = IoAllocateMdl(
                    writeAddress,
                    writeLength,
                    FALSE,
                    FALSE,
                    NULL
                    );

        if ( mdl == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error;
        }

        //
        // Build the mdl.
        //

        MmBuildMdlForNonPagedPool( mdl );

        WorkContext->Parameters.WriteMpx.DataMdl = mdl;

    } else {

        mdl = WorkContext->RequestBuffer->PartialMdl;

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            mdl,
            writeAddress,
            writeLength
            );

    }

    //
    // Build the IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_WRITE,                   // major function code
            0,                              // minor function code
            writeAddress,                   // buffer address
            writeLength,                    // buffer length
            mdl,                            // MDL address
            offset,                         // byte offset
            key                             // lock key
            );

    //
    // Pass the request to the file system.
    //

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = RestartWriteMpx;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // RestartWriteMpx when the write completes.
    //

    SmbStatus = SmbStatusInProgress;
    goto Cleanup;

error:

    //
    // There is an error of some sort.  We still need to check for
    // whether this is the last Write Mpx active on the RFCB, and if so,
    // send the response to the write instead of the error.  If this is
    // not the last active mux request, then we either send an error
    // response (non-datagram write mux or sequenced write mux) or
    // ignore this request (unsequenced datagram).  Note that if this is
    // a non-datagram write mux, then we didn't come in over IPX, and we
    // didn't bump the Write Mpx refcount.
    //

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
    }

    if ( WorkContext->Rfcb && CheckForWriteMpxComplete( WorkContext ) ) {
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if ( SmbGetAlignedUshort(&header->SequenceNumber) != 0 ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
        response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;
        response->WordCount = 2;
        SmbPutUlong( &response->Mask, 0 );
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_WRITE_MPX_DATAGRAM,
                                            0
                                            );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    SmbStatus = SmbStatusNoResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbWriteMpx


VOID SRVFASTCALL
RestartWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file write completion for a Write MPX SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;
    BOOLEAN rfcbClosing;
    PRESP_WRITE_MPX_DATAGRAM response;

    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    PCONNECTION connection;
    KIRQL oldIrql;
    USHORT writeLength;
    LARGE_INTEGER position;
    USHORT sequenceNumber;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    IF_DEBUG(FSD2) KdPrint(( " - RestartWriteMpx\n" ));
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_MPX;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;
    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    rfcb = WorkContext->Rfcb;
    connection = WorkContext->Connection;

    status = WorkContext->Irp->IoStatus.Status;

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
        WorkContext->Parameters.WriteMpx.TransportContext = NULL;
    }

    //
    // Free the data Mdl.
    //

    if ( WorkContext->Parameters.WriteMpx.DataMdl ) {
        IoFreeMdl( WorkContext->Parameters.WriteMpx.DataMdl );
        WorkContext->Parameters.WriteMpx.DataMdl = NULL;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    //
    // If we're entered at dispatch level, and the write failed,
    // or there is a saved error, or the rfcb is closing, then
    // we need to have a worker thread call this routine.
    //

    if ( ((status != STATUS_SUCCESS) ||
          (rfcb->SavedError != STATUS_SUCCESS) ||
          (GET_BLOCK_STATE(rfcb) != BlockStateActive)) &&
         (oldIrql >= DISPATCH_LEVEL) ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        WorkContext->FspRestartRoutine = RestartWriteMpx;
        QUEUE_WORK_TO_FSP( WorkContext );
        KeLowerIrql( oldIrql );
        goto Cleanup;
    }

    //
    // If this write is from a previous mux (meaning that a new one was
    // started while we were doing this write), toss this request.
    //

    writeMpx = &rfcb->WriteMpx;

    if ( WorkContext->Parameters.WriteMpx.Mid != writeMpx->Mid ) {
        goto check_for_mux_end;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // The write failed.  Remember the failure in the RFCB.
        //

        IF_DEBUG(ERRORS) KdPrint(( "Write failed: %X\n", status ));

        if ( rfcb->SavedError == STATUS_SUCCESS ) {
            rfcb->SavedError = status;
        }

    } else {

        //
        // The write succeeded.  Update the information in the write mpx
        // context block.
        //
        // !!! Need to deal with mask shifting by the redir and delayed
        //     packets.
        //

#if 0
        MpxDelay = !MpxDelay;
        if ( MpxDelay ) {
            LARGE_INTEGER interval;
            interval.QuadPart = -10*1000*100;
            KeDelayExecutionThread( KernelMode, FALSE, &interval );
        }
#endif
        writeMpx->Mask |= SmbGetUlong( &request->Mask );

    }

    //
    // Save the count of bytes written, to be used to update the server
    // statistics database.
    //

    writeLength = (USHORT)WorkContext->Irp->IoStatus.Information;
    UPDATE_WRITE_STATS( WorkContext, writeLength );

    IF_SMB_DEBUG(MPX1) {
        KdPrint(( "RestartWriteMpx:  Fid 0x%lx, wrote %ld bytes\n",
                  rfcb->Fid, writeLength ));
    }

    //
    // If this is an unsequenced request, we're done.  We don't respond
    // until we get a sequenced request.
    //

    sequenceNumber = SmbGetAlignedUshort( &header->SequenceNumber );

    if ( sequenceNumber == 0 ) {
        goto check_for_mux_end;
    }

    //
    // This is the last request in this mux sent by the client.  Save
    // the sequence number and update the file position.
    //

    writeMpx->SequenceNumber = sequenceNumber;

    rfcb->CurrentPosition =  WorkContext->Parameters.WriteMpx.Offset + writeLength;


check_for_mux_end:

    //
    // If we have received the sequenced command for this write mux,
    // and this is the last active command, then it's time to send
    // the response.  Otherwise, we are done with this SMB.
    //

    if ( --writeMpx->ReferenceCount != 0 ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        SrvFsdRestartSmbComplete( WorkContext );
        KeLowerIrql( oldIrql );
        goto Cleanup;
    }

    //
    // WriteMpx refcount is 0.
    //

    rfcbClosing = (GET_BLOCK_STATE(rfcb) != BlockStateActive);

    if ( writeMpx->SequenceNumber == 0 ) {

        //
        // If the rfcb is closing, complete the cleanup.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

        if ( rfcbClosing ) {
            RestartWriteMpxCompleteRfcbClose( WorkContext );
        }

        if( oldIrql >= DISPATCH_LEVEL ) {
            SrvFsdRestartSmbComplete( WorkContext );
        } else {
            SrvRestartFsdComplete( WorkContext );
        }

        goto Cleanup;
    }

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // Save the status.
    //

    status = rfcb->SavedError;
    rfcb->SavedError = STATUS_SUCCESS;

    //
    // Now we can release the lock.
    //

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    KeLowerIrql( oldIrql );

    //
    // Complete the rfcb close.
    //

    if ( rfcbClosing ) {

        RestartWriteMpxCompleteRfcbClose( WorkContext );
    }

    //
    // Build the response message.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    //
    // Send the response.
    //

    SrvFsdSendResponse( WorkContext );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartWriteMpx

BOOLEAN
CheckForWriteMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header;
    PRESP_WRITE_MPX_DATAGRAM response;

    NTSTATUS status;
    PRFCB rfcb = WorkContext->Rfcb;
    PWRITE_MPX_CONTEXT writeMpx = &rfcb->WriteMpx;
    PCONNECTION connection = WorkContext->Connection;
    KIRQL oldIrql;

    //
    // If we have not received the sequenced command for this write mux,
    // or this is not the last active command, then return FALSE.
    // Otherwise, it's time to send the response, so build it and return
    // TRUE.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    if ( --writeMpx->ReferenceCount != 0 ) {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        return(FALSE);
    }

    //
    // WriteMpx refcount is 0.
    //

    if ( writeMpx->SequenceNumber == 0 ) {

        //
        // If the rfcb is closing, complete the cleanup.
        //

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            RestartWriteMpxCompleteRfcbClose( WorkContext );
        } else {
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        }
        return FALSE;
    }

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    header = WorkContext->ResponseHeader;
    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // Save the status.
    //

    status = rfcb->SavedError;
    rfcb->SavedError = STATUS_SUCCESS;

    //
    // Now we can release the lock.
    //

    if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        RestartWriteMpxCompleteRfcbClose( WorkContext );

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    }

    //
    // Build the response message.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    return TRUE;

} // CheckForWriteMpxComplete

VOID SRVFASTCALL
RestartPrepareMpxMdlWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;

    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    PCONNECTION connection;
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    USHORT writeLength;
    PCHAR writeAddress;
    KIRQL oldIrql;
    ULONG bytesCopied;
    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PMDL mdl;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_MPX;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;
    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;

    rfcb = WorkContext->Rfcb;
    writeMpx = &rfcb->WriteMpx;
    connection = WorkContext->Connection;

    //
    // If the MDL write preparation succeeded, copy the data from this
    // packet into the cache.  If it failed, toss this packet.
    //

    if( NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

        mdl = WorkContext->Irp->MdlAddress;
#if DBG
        IF_SMB_DEBUG(MPX2) {
            KdPrint(( "RestartPrepareMpxMdlWrite: rfcb %p, input chain:\n", rfcb ));
            DumpMdlChain( mdl );
        }
#endif
        writeMpx->MdlChain = mdl;
        writeMpx->NumberOfRuns = 1;
        writeMpx->RunList[0].Offset = 0;
        writeLength = WorkContext->Parameters.WriteMpx.WriteLength;
        writeMpx->RunList[0].Length = writeLength;

        //
        // If we have the transport context, setup writeAddress accordingly.
        //

        if ( WorkContext->Parameters.WriteMpx.TransportContext ) {

            writeAddress = (PCHAR)WorkContext->Parameters.WriteMpx.Buffer +
                                    SmbGetUshort( &request->DataOffset );
        } else {

            writeAddress = (PCHAR)WorkContext->ResponseHeader +
                                    SmbGetUshort( &request->DataOffset );
        }

        status = TdiCopyBufferToMdl(
                    writeAddress,
                    0,
                    writeLength,
                    mdl,
                    0,
                    &bytesCopied
                    );
        ASSERT( status == STATUS_SUCCESS );
        ASSERT( bytesCopied == writeLength );

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        writeMpx->Glomming = TRUE;

        ASSERT( writeMpx->Mask == 0 );
        writeMpx->Mask = SmbGetUlong( &request->Mask );

        --writeMpx->ReferenceCount;
        ASSERT( writeMpx->SequenceNumber == 0 );

    } else {

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

        if ( rfcb->SavedError == STATUS_SUCCESS ) {
            rfcb->SavedError = WorkContext->Irp->IoStatus.Status;
        }

        --writeMpx->ReferenceCount;
        writeMpx->Glomming = FALSE;
    }

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                  1
                                  );
    }

    writeMpx->GlomPending = FALSE;

    while ( !IsListEmpty( &writeMpx->GlomDelayList ) ) {
        listEntry = RemoveHeadList( &writeMpx->GlomDelayList );
        workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, ListEntry );
        workContext->FspRestartRoutine = AddPacketToGlom;
        QUEUE_WORK_TO_FSP( workContext );
    }

    //
    // If the rfcb is closing and the write mpx ref count == 0,
    // then we must complete the close.
    //

    if ( (GET_BLOCK_STATE(rfcb) != BlockStateActive) &&
         (writeMpx->ReferenceCount == 0) ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        WorkContext->FspRestartRoutine = RestartWriteMpxCompleteRfcbClose;
        QUEUE_WORK_TO_FSP( WorkContext );
        KeLowerIrql( oldIrql );
        goto Cleanup;
    }

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    SrvFsdRestartSmbComplete( WorkContext );
    KeLowerIrql( oldIrql );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartPrepareMpxMdlWrite


VOID SRVFASTCALL
AddPacketToGlom (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;
    PRESP_WRITE_MPX_DATAGRAM response;

    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    PCONNECTION connection;
    ULONG fileOffset;
    USHORT glomOffset;
    CLONG bufferOffset;
    PCHAR writeAddress;
    USHORT writeLength;
    ULONG bytesCopied;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    USHORT sequenceNumber;
    BOOLEAN rfcbClosing;

    PWRITE_MPX_RUN run, nextRun;
    ULONG runIndex, runCount;

    USHORT runOffset;
    USHORT runLength;

    PMDL cacheMdl;
    LARGE_INTEGER cacheOffset;

    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;

    rfcb = WorkContext->Rfcb;
    connection = WorkContext->Connection;
    writeMpx = &rfcb->WriteMpx;
    cacheMdl = writeMpx->MdlChain;

    if( writeMpx->Glomming == FALSE ) {
        //
        // We must have encountered an error in RestartPrepareMpxMdlWrite(), but
        // we call through this routine to ensure we send a response back to the
        // client.
        //
        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto check;
    }

    ASSERT( writeMpx->Glomming );
    ASSERT( !writeMpx->GlomPending );
    ASSERT( WorkContext->Parameters.WriteMpx.Mid == writeMpx->Mid );

    //
    // Get the file offset of this packet's data.
    //

    fileOffset = WorkContext->Parameters.WriteMpx.Offset;

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    //
    // If we have the transport context, setup writeAddress accordingly.
    //

    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        writeAddress = (PCHAR)WorkContext->Parameters.WriteMpx.Buffer +
                       bufferOffset;
    } else {
        writeAddress = (PCHAR)header + bufferOffset;
    }

    writeLength = WorkContext->Parameters.WriteMpx.WriteLength;
    ASSERT( writeLength <= 0xffff );

    //
    // If the data doesn't fall within the bounds of the glommed write,
    // discard the packet.
    //
    // We always know that we've copied at least the first part of the
    // glom.
    //

    ASSERT( writeMpx->NumberOfRuns > 0 );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    if ( fileOffset <= writeMpx->StartOffset ) {
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto discard;
    }

    fileOffset -= writeMpx->StartOffset;
    if ( (fileOffset + writeLength) > writeMpx->Length ) {
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto discard;
    }
    ASSERT( fileOffset <= 0xffff );
    ASSERT( fileOffset + writeLength <= 0xffff );

    glomOffset = (USHORT)fileOffset;

    //
    // Copy the packet data into the glom.
    //

    status = TdiCopyBufferToMdl(
                writeAddress,
                0,
                writeLength,
                cacheMdl,
                glomOffset,
                &bytesCopied
                );
    ASSERT( status == STATUS_SUCCESS );
    ASSERT( bytesCopied == writeLength );

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
    }

    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    //
    // Update the glom run information.  Note that this packet may have
    // been received multiple times, so it may already be marked in the
    // run information.
    //

    if (0) IF_SMB_DEBUG(MPX2) {
        KdPrint(( "rfcb %p, offset %lx, length %lx\n", rfcb, glomOffset, writeLength ));
    }

    runCount = writeMpx->NumberOfRuns;

    for ( runIndex = 1, nextRun = &writeMpx->RunList[1];
          runIndex < runCount;
          runIndex++, nextRun++ ) {
        if ( nextRun->Offset > glomOffset ) {
            break;
        }
    }
    run = nextRun - 1;

    runOffset = run->Offset;
    runLength = run->Length;
    ASSERT( runOffset <= glomOffset );

    if ( (runOffset + runLength) == glomOffset ) {

        //
        // This packet abuts the end of the previous run.  Add the
        // length of this packet to the run length and attempt to
        // coalesce with the next run.
        //

        runLength += writeLength;
        goto coalesce;
    }

    if ( (runOffset + runLength) > glomOffset ) {

        //
        // This packet overlaps the previous run.  If it lies completely
        // within the previous run, ignore it.
        //

        if ( (USHORT)(runOffset + runLength) >= (glomOffset + writeLength) ) {
            goto discard;
        }

        //
        // This packet overlaps and extends the previous run.  Calculate
        // the new run length and attempt to coalesce with the next run.
        //

        runLength = (glomOffset - runOffset + writeLength);
        goto coalesce;
    }

    //
    // This packet's data is disjoint from the previous run.
    //

    if ( runIndex < runCount ) {

        //
        // There is a next run.  Does this packet overlap with that run?
        //

        runOffset = nextRun->Offset;
        runLength = nextRun->Length;

        if ( (glomOffset + writeLength) >= runOffset ) {

            //
            // This packet overlaps the next run.  Calculate the new run
            // length.
            //

            nextRun->Offset = glomOffset;
            nextRun->Length = runOffset - glomOffset + runLength;
            goto check;
        }
    }

    //
    // Either this packet is disjoint from the next run, or there is no
    // next run.  Is there room in the run array for another run?  If
    // not, discard this packet.  (Note that we discard it even though
    // we have already copied the packet data.  That's OK -- it will
    // just be resent.)
    //

    if ( runCount == MAX_GLOM_RUN_COUNT ) {
        goto discard;
    }

    //
    // Add a new run.  Since we know the new run is disjoint from the
    // previous run, we know that the glom is not complete.
    //

    RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
        nextRun + 1,
        nextRun,
        (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
        );
    writeMpx->NumberOfRuns++;
    nextRun->Offset = glomOffset;
    nextRun->Length = writeLength;
    goto check;

coalesce:

    if ( runIndex == runCount ) {
        run->Length = runLength;
    } else if ( (runOffset + runLength) >= nextRun->Offset ) {
        run->Length = nextRun->Length + nextRun->Offset - runOffset;
        writeMpx->NumberOfRuns--;
        RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
            nextRun,
            nextRun + 1,
            (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
            );
    } else {
        run->Length += writeLength;
        ASSERT( (runOffset + run->Length) < nextRun->Offset );
    }

    if ( (writeMpx->NumberOfRuns == 1) &&
         (writeMpx->RunList[0].Length == writeMpx->Length) ) {

        //
        // The glom is complete.
        //

        writeMpx->GlomComplete = TRUE;
    }

check:

    if (0) IF_SMB_DEBUG(MPX2) {
        if( writeMpx->Glomming ) {
            ULONG i;
            PWRITE_MPX_RUN runi;
            for ( i = 0, runi = &writeMpx->RunList[0];
                  i < writeMpx->NumberOfRuns;
                  i++, runi++ ) {
                KdPrint(( "  run %d: offset %lx, length %lx\n", i, runi->Offset, runi->Length ));
            }
        }
    }

    writeMpx->Mask |= SmbGetUlong( &request->Mask );

    //
    // If this is an unsequenced request, we're done.  We don't respond
    // until we get a sequenced request.
    //

    sequenceNumber = SmbGetAlignedUshort( &header->SequenceNumber );

    if ( sequenceNumber == 0 ) {
        goto discard;
    }

    //
    // This is the last request in this mux sent by the client.  Save
    // the sequence number.
    //

    writeMpx->SequenceNumber = sequenceNumber;

discard:

    //
    // If we have received the sequenced command for this write mux,
    // and this is the last active command, then it's time to send
    // the response.  Otherwise, we are done with this SMB.
    //

    if ( --writeMpx->ReferenceCount != 0 ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        SrvFsdRestartSmbComplete( WorkContext );
        KeLowerIrql( oldIrql );
        return;
    }

    //
    // WriteMpx refcount is 0.
    //

    rfcbClosing = (GET_BLOCK_STATE(rfcb) != BlockStateActive);

    if ( writeMpx->SequenceNumber == 0 ) {

        //
        // If the rfcb is closing, complete the cleanup.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

        if ( rfcbClosing ) {
            RestartWriteMpxCompleteRfcbClose( WorkContext );
        }
        SrvRestartFsdComplete( WorkContext );
        return;
    }

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // If the glom is complete, we need to complete the MDL write.  But
    // we can't do that with the lock held, so we need to clear out all
    // information related to the glom first.
    //

    if ( writeMpx->Glomming && writeMpx->GlomComplete ) {

        PWORK_CONTEXT newContext;

        //
        // Save and clear information about the active glom.
        //

        writeMpx->Glomming = FALSE;
        writeMpx->GlomComplete = FALSE;

        cacheOffset.QuadPart = writeMpx->StartOffset;
        writeLength = writeMpx->Length;

        DEBUG writeMpx->MdlChain = NULL;
        DEBUG writeMpx->StartOffset = 0;
        DEBUG writeMpx->Length = 0;

        //
        // Save the status.
        //

        status = rfcb->SavedError;
        rfcb->SavedError = STATUS_SUCCESS;

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

        ALLOCATE_WORK_CONTEXT( WorkContext->CurrentWorkQueue, &newContext );

#if DBG
        IF_SMB_DEBUG(MPX2) {
            KdPrint(( "AddPacketToGlom: rfcb %p, completed chain:\n", rfcb ));
            DumpMdlChain( cacheMdl );
        }
#endif

        if( newContext == NULL ) {

            //
            // Tell the cache manager that we're done with this MDL write.
            //

            if( rfcb->Lfcb->MdlWriteComplete == NULL ||
                rfcb->Lfcb->MdlWriteComplete(
                    rfcb->Lfcb->FileObject,
                    &cacheOffset,
                    cacheMdl,
                    rfcb->Lfcb->DeviceObject ) == FALSE ) {

                status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                     cacheMdl,
                                                     IRP_MJ_WRITE,
                                                     &cacheOffset,
                                                     writeLength
                                                    );

                if( !NT_SUCCESS( status ) ) {
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }

        } else {
            //
            // Send the FsRtlMdlWriteComplete off on its way, and go ahead and send
            //  the response to the client now.
            //
            newContext->Rfcb = WorkContext->Rfcb;
            SrvReferenceRfcb( newContext->Rfcb );

            newContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset = cacheOffset;
            newContext->Parameters.WriteMpxMdlWriteComplete.WriteLength = writeLength;
            newContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl = cacheMdl;
            newContext->FspRestartRoutine = WriteMpxMdlWriteComplete;
            SrvQueueWorkToFsp( newContext );
        }

    } else {

        if( writeMpx->Glomming == FALSE ) {
            status = rfcb->SavedError;
            rfcb->SavedError = STATUS_SUCCESS;
        }

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

    }

    //
    // Complete the rfcb close.
    //

    if ( rfcbClosing ) {

        RestartWriteMpxCompleteRfcbClose( WorkContext );
    }

    //
    // Build the response message.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    //
    // Send the response.
    //

    SrvFsdSendResponse( WorkContext );
    return;

} // AddPacketToGlom

BOOLEAN
AddPacketToGlomInIndication (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PRFCB Rfcb,
    IN PVOID Tsdu,
    IN ULONG BytesAvailable,
    IN ULONG ReceiveDatagramFlags,
    IN PVOID SourceAddress,
    IN PVOID Options
    )

/*++

Routine Description:

    Do Write glomming at indication.

    *** connection spinlock assumed held.  Released on exit ***

Arguments:

Return Value:

    TRUE if the caller has to clean up the connection block.

--*/

{
    PREQ_WRITE_MPX request;
    PRESP_WRITE_MPX_DATAGRAM response;
    PWRITE_MPX_CONTEXT writeMpx = &Rfcb->WriteMpx;

    PCONNECTION connection = WorkContext->Connection;
    ULONG fileOffset;
    USHORT glomOffset;
    CLONG bufferOffset;
    PCHAR writeAddress;
    USHORT writeLength;
    ULONG bytesCopied;
    NTSTATUS status;
    USHORT sequenceNumber;

    PSMB_HEADER header = (PSMB_HEADER)Tsdu;
    PWRITE_MPX_RUN run, nextRun;
    ULONG runIndex, runCount;

    USHORT runOffset;
    USHORT runLength;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // copied from SrvRestartReceive.
    //

    WorkContext->CurrentWorkQueue->stats.BytesReceived += BytesAvailable;
    connection->BreakIIToNoneJustSent = FALSE;
    SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

    //
    // Set up locals.
    //

    request = (PREQ_WRITE_MPX)(header + 1);

    ASSERT( writeMpx->Glomming );
    ASSERT( !writeMpx->GlomPending );
    ASSERT( header->Mid == writeMpx->Mid );

    //
    // Get the file offset of this packet's data.
    //

    fileOffset = SmbGetUlong( &request->Offset );

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    writeAddress = (PCHAR)header + bufferOffset;

    writeLength =
        (USHORT)(MIN( (CLONG)SmbGetUshort( &request->DataLength ),
                      BytesAvailable - bufferOffset ));
    ASSERT( writeLength <= 0xffff );

    //
    // If the data doesn't fall within the bounds of the glommed write,
    // discard the packet.
    //
    // We always know that we've copied at least the first part of the
    // glom.
    //

    ASSERT( writeMpx->NumberOfRuns > 0 );

    if ( fileOffset <= writeMpx->StartOffset ) {
        goto discard;
    }
    fileOffset -= writeMpx->StartOffset;
    if ( (fileOffset + writeLength) > writeMpx->Length ) {
        goto discard;
    }
    ASSERT( fileOffset <= 0xffff );
    ASSERT( fileOffset + writeLength <= 0xffff );
    glomOffset = (USHORT)fileOffset;

    //
    // Copy the packet data into the glom.
    //

    status = TdiCopyBufferToMdl(
                writeAddress,
                0,
                writeLength,
                writeMpx->MdlChain,
                glomOffset,
                &bytesCopied
                );
    ASSERT( status == STATUS_SUCCESS );
    ASSERT( bytesCopied == writeLength );

    //
    // Update the glom run information.  Note that this packet may have
    // been received multiple times, so it may already be marked in the
    // run information.
    //

    if (0) IF_SMB_DEBUG(MPX2) {
        KdPrint(( "rfcb %p, offset %lx, length %lx\n", Rfcb, glomOffset, writeLength ));
    }

    runCount = writeMpx->NumberOfRuns;

    for ( runIndex = 1, nextRun = &writeMpx->RunList[1];
          runIndex < runCount;
          runIndex++, nextRun++ ) {
        if ( nextRun->Offset > glomOffset ) {
            break;
        }
    }
    run = nextRun - 1;

    runOffset = run->Offset;
    runLength = run->Length;
    ASSERT( runOffset <= glomOffset );

    if ( (runOffset + runLength) == glomOffset ) {

        //
        // This packet abuts the end of the previous run.  Add the
        // length of this packet to the run length and attempt to
        // coalesce with the next run.
        //

        runLength += writeLength;
        goto coalesce;
    }

    if ( (runOffset + runLength) > glomOffset ) {

        //
        // This packet overlaps the previous run.  If it lies completely
        // within the previous run, ignore it.
        //

        if ( (USHORT)(runOffset + runLength) >= (glomOffset + writeLength) ) {
            goto discard;
        }

        //
        // This packet overlaps and extends the previous run.  Calculate
        // the new run length and attempt to coalesce with the next run.
        //

        runLength = (glomOffset - runOffset + writeLength);
        goto coalesce;
    }

    //
    // This packet's data is disjoint from the previous run.
    //

    if ( runIndex < runCount ) {

        //
        // There is a next run.  Does this packet overlap with that run?
        //

        runOffset = nextRun->Offset;
        runLength = nextRun->Length;

        if ( (glomOffset + writeLength) >= runOffset ) {

            //
            // This packet overlaps the next run.  Calculate the new run
            // length.
            //

            nextRun->Offset = glomOffset;
            nextRun->Length = runOffset - glomOffset + runLength;
            goto check;
        }
    }

    //
    // Either this packet is disjoint from the next run, or there is no
    // next run.  Is there room in the run array for another run?  If
    // not, discard this packet.  (Note that we discard it even though
    // we have already copied the packet data.  That's OK -- it will
    // just be resent.)
    //

    if ( runCount == MAX_GLOM_RUN_COUNT ) {
        goto discard;
    }

    //
    // Add a new run.  Since we know the new run is disjoint from the
    // previous run, we know that the glom is not complete.
    //

    RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
        nextRun + 1,
        nextRun,
        (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
        );
    writeMpx->NumberOfRuns++;
    nextRun->Offset = glomOffset;
    nextRun->Length = writeLength;
    goto check;

coalesce:

    if ( runIndex == runCount ) {
        run->Length = runLength;
    } else if ( (runOffset + runLength) >= nextRun->Offset ) {
        run->Length = nextRun->Length + nextRun->Offset - runOffset;
        writeMpx->NumberOfRuns--;
        RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
            nextRun,
            nextRun + 1,
            (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
            );
    } else {
        run->Length += writeLength;
        ASSERT( (runOffset + run->Length) < nextRun->Offset );
    }

    if ( (writeMpx->NumberOfRuns == 1) &&
         (writeMpx->RunList[0].Length == writeMpx->Length) ) {

        //
        // The glom is complete.
        //

        writeMpx->GlomComplete = TRUE;
    }

check:

    if (0) IF_SMB_DEBUG(MPX2) {
        ULONG i;
        PWRITE_MPX_RUN runi;
        for ( i = 0, runi = &writeMpx->RunList[0];
              i < writeMpx->NumberOfRuns;
              i++, runi++ ) {
            KdPrint(( "  run %d: offset %lx, length %lx\n", i, runi->Offset, runi->Length ));
        }
    }

    writeMpx->Mask |= SmbGetUlong( &request->Mask );

    //
    // If this is an unsequenced request, we're done.  We don't respond
    // until we get a sequenced request.
    //

    sequenceNumber = SmbGetAlignedUshort( &header->SequenceNumber );

    if ( sequenceNumber == 0 ) {
        goto discard;
    }

    //
    // This is the last request in this mux sent by the client.  Save
    // the sequence number.
    //

    writeMpx->SequenceNumber = sequenceNumber;

discard:

    //
    // If we have received the sequenced command for this write mux,
    // and this is the last active command, then it's time to send
    // the response.  Otherwise, we are done with this SMB.
    //

    if ( (--writeMpx->ReferenceCount != 0) ||
         (writeMpx->SequenceNumber == 0) ) {
        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        return TRUE;
    }

    //
    // Copy the header portion for the response.
    //

    TdiCopyLookaheadData(
        WorkContext->RequestBuffer->Buffer,
        Tsdu,
        sizeof(SMB_HEADER),
        ReceiveDatagramFlags
        );

    // WorkContext->RequestBuffer->DataLength = BytesAvailable;

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // If the glom is complete, we need to complete the MDL write.  But
    // we can't do that with the lock held, so we need to clear out all
    // information related to the glom first.
    //

    if ( writeMpx->GlomComplete ) {

        //
        // The file is active and the TID is valid.  Reference the
        // RFCB.
        //

        Rfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( Rfcb, FALSE );

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

        WorkContext->Rfcb = Rfcb;

        //
        // Build the response message.
        //

        response->WordCount = 2;
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_WRITE_MPX_DATAGRAM,
                                            0
                                            );

        //
        // Send this off to the fsp for final processing.  We need to do
        // this since we cannot call the cache manager at dpc level.
        //

        WorkContext->FspRestartRoutine = RestartCompleteGlommingInIndication;
        SrvQueueWorkToFsp( WorkContext );
        return FALSE;

    } else {

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    }

    //
    // Build the response message.
    //

    ASSERT( status == STATUS_SUCCESS );

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    //
    // Send the response.
    //

    SrvFsdSendResponse( WorkContext );
    return FALSE;

} // AddPacketToGlomInIndication

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpxSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write Mpx Secondary SMB.

    *** The server should never see this SMB, since it returns the "use
        standard read" error to the main Write Mpx SMB, except over IPX,
        which doesn't use Write Mpx Secondary.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Send a response that tells the client that this SMB is not
    // valid.
    //

    INTERNAL_ERROR(
        ERROR_LEVEL_UNEXPECTED,
        "SrvSmbWriteMpxSecondary: unexpected SMB",
        NULL,
        NULL
        );
    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
    return SmbStatusSendResponse;

} // SrvSmbWriteMpxSecondary

VOID SRVFASTCALL
RestartCompleteGlommingInIndication(
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    LARGE_INTEGER cacheOffset;
    KIRQL oldIrql;
    PMDL cacheMdl;
    NTSTATUS status;
    PRFCB rfcb = WorkContext->Rfcb;
    PWRITE_MPX_CONTEXT writeMpx = &rfcb->WriteMpx;
    PCONNECTION connection = WorkContext->Connection;
    ULONG writeLength;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Save the status.
    //

    status = rfcb->SavedError;
    rfcb->SavedError = STATUS_SUCCESS;

    //
    // If the rfcb has closed, then the mdl write was completed.
    //

    if ( GET_BLOCK_STATE(rfcb) == BlockStateActive ) {

        PWORK_CONTEXT newContext;

        writeMpx->GlomComplete = FALSE;
        writeMpx->Glomming = FALSE;
        cacheOffset.QuadPart = writeMpx->StartOffset;
        cacheMdl = writeMpx->MdlChain;
        writeLength = writeMpx->Length;

        DEBUG writeMpx->MdlChain = NULL;
        DEBUG writeMpx->StartOffset = 0;
        DEBUG writeMpx->Length = 0;

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );


        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ALLOCATE_WORK_CONTEXT( WorkContext->CurrentWorkQueue, &newContext );
        KeLowerIrql( oldIrql );

        if( newContext == NULL ) {

            //
            // Tell the cache manager that we're done with this MDL write.
            //

            if( rfcb->Lfcb->MdlWriteComplete == NULL ||
                rfcb->Lfcb->MdlWriteComplete(
                    rfcb->Lfcb->FileObject,
                    &cacheOffset,
                    cacheMdl,
                    rfcb->Lfcb->DeviceObject ) == FALSE ) {

                status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                     cacheMdl,
                                                     IRP_MJ_WRITE,
                                                     &cacheOffset,
                                                     writeLength
                                                    );

                if( !NT_SUCCESS( status ) ) {
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }

        } else {
            //
            // Send the FsRtlMdlWriteComplete off on its way, and go ahead and send
            //  the response to the client now.
            //
            newContext->Rfcb = WorkContext->Rfcb;
            WorkContext->Rfcb = NULL;

            newContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset = cacheOffset;
            newContext->Parameters.WriteMpxMdlWriteComplete.WriteLength = writeLength;
            newContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl = cacheMdl;
            newContext->FspRestartRoutine = WriteMpxMdlWriteComplete;
            SrvQueueWorkToFsp( newContext );
        }

    } else {

        ASSERT( !writeMpx->Glomming );
        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    }

    //
    // Send the response.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    SrvFsdSendResponse( WorkContext );
    return;

} // RestartCompleteGlommingInIndication

VOID SRVFASTCALL
WriteMpxMdlWriteComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    NTSTATUS status;

    if( WorkContext->Rfcb->Lfcb->MdlWriteComplete == NULL ||

        WorkContext->Rfcb->Lfcb->MdlWriteComplete(
            WorkContext->Rfcb->Lfcb->FileObject,
            &WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset,
            WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl,
            WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

        status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                             WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl,
                                             IRP_MJ_WRITE,
                                             &WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset,
                                             WorkContext->Parameters.WriteMpxMdlWriteComplete.WriteLength );

        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
        }
    }

    SrvDereferenceRfcb( WorkContext->Rfcb );
    WorkContext->Rfcb = NULL;
    WorkContext->FspRestartRoutine = SrvRestartReceive;
    ASSERT( WorkContext->BlockHeader.ReferenceCount == 1 );
#if DBG
    WorkContext->BlockHeader.ReferenceCount = 0;
#endif
    RETURN_FREE_WORKITEM( WorkContext );
}


VOID SRVFASTCALL
RestartWriteMpxCompleteRfcbClose (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes the rfcb close after last active writempx is finished.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PCONNECTION connection = WorkContext->Connection;
    PRFCB rfcb = WorkContext->Rfcb;
    PWRITE_MPX_CONTEXT writeMpx = &rfcb->WriteMpx;
    LARGE_INTEGER cacheOffset;
    PMDL mdlChain;
    KIRQL oldIrql;
    ULONG writeLength;
    NTSTATUS status;

    //
    // This rfcb is closing.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    ASSERT ( GET_BLOCK_STATE(rfcb) != BlockStateActive );

    writeMpx = &rfcb->WriteMpx;

    if ( writeMpx->Glomming ) {

         //
         // We need to complete this write mdl
         //

         writeMpx->Glomming = FALSE;
         writeMpx->GlomComplete = FALSE;

         //
         // Save the offset and MDL address.
         //

         cacheOffset.QuadPart = writeMpx->StartOffset;
         mdlChain = writeMpx->MdlChain;
         writeLength = writeMpx->Length;

         DEBUG writeMpx->MdlChain = NULL;
         DEBUG writeMpx->StartOffset = 0;
         DEBUG writeMpx->Length = 0;

         //
         // Now we can release the lock.
         //

         RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

         //
         // Tell the cache manager that we're done with this MDL write.
         //

         if( rfcb->Lfcb->MdlWriteComplete == NULL ||
             rfcb->Lfcb->MdlWriteComplete(
                 writeMpx->FileObject,
                 &cacheOffset,
                 mdlChain,
                 rfcb->Lfcb->DeviceObject ) == FALSE ) {

            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 mdlChain,
                                                 IRP_MJ_WRITE,
                                                 &cacheOffset,
                                                 writeLength );

            if( !NT_SUCCESS( status ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }

    } else {

         //
         // Now we can release the lock.
         //

         RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    }

    //
    // Do the actual close
    //

    SrvCompleteRfcbClose( rfcb );
    return;

} // RestartWriteMpxCompleteRfcbClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbfind.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsrch.c

Abstract:

    This module contains routines for processing the find 2 SMBs:

        Find 2 (First/Next/Rewind)
        Find 2 Close

Author:

    David Treadwell (davidtr)    13-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbfind.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBFIND

VOID SRVFASTCALL
BlockingFindFirst2 (
    IN PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
DoFindFirst2 (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
BlockingFindNext2 (
    IN PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
DoFindNext2 (
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvFind2Loop (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT Flags,
    IN USHORT InformationLevel,
    IN PTRANSACTION Transaction,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize,
    IN USHORT SearchAttributes,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN USHORT MaxCount,
    IN PRESP_FIND_NEXT2 Response,
    OUT PSEARCH Search
    );

VOID
ConvertFileInfo (
    IN PFILE_DIRECTORY_INFORMATION File,
    IN PWCH FileName,
    IN BOOLEAN Directory,
    IN BOOLEAN ClientIsUnicode,
    OUT PSMB_FIND_BUFFER FindBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbFindFirst2 )
#pragma alloc_text( PAGE, BlockingFindFirst2 )
#pragma alloc_text( PAGE, DoFindFirst2 )
#pragma alloc_text( PAGE, SrvSmbFindNext2 )
#pragma alloc_text( PAGE, BlockingFindNext2 )
#pragma alloc_text( PAGE, DoFindNext2 )
#pragma alloc_text( PAGE, SrvFind2Loop )
#pragma alloc_text( PAGE, ConvertFileInfo )
#pragma alloc_text( PAGE, SrvSmbFindClose2 )
#endif


SMB_TRANS_STATUS
SrvSmbFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_FIND_FIRST2 request;
    PTRANSACTION transaction;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_FIRST2;
    SrvWmiStartContext(WorkContext);

    //
    // If the infomation level is QUERY_EAS_FROM_LIST, and we
    // are not in a blocking thread, requeue the request to a blocking
    // thread.
    //
    // We can't process the SMB in a non blocking thread because this
    // info level requires opening the file, which may be oplocked,
    // so the open operation may block.
    //

    transaction = WorkContext->Parameters.Transaction;
    request = (PREQ_FIND_FIRST2)transaction->InParameters;

    if ( transaction->ParameterCount >= sizeof(REQ_FIND_FIRST2) &&
         SmbGetUshort( &request->InformationLevel ) == SMB_INFO_QUERY_EAS_FROM_LIST ) {

        WorkContext->FspRestartRoutine = BlockingFindFirst2;
        SrvQueueWorkToBlockingThread(WorkContext);
        SmbStatus = SmbTransStatusInProgress;
    }
    else {
        SmbStatus = DoFindFirst2(WorkContext);
    }

    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbFindFirst2


VOID SRVFASTCALL
BlockingFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_FIRST2;
    SrvWmiStartContext(WorkContext);

    smbStatus = DoFindFirst2( WorkContext );
    if ( smbStatus != SmbTransStatusInProgress ) {
        SrvCompleteExecuteTransaction( WorkContext, smbStatus );
    }

    SrvWmiEndContext(WorkContext);
    return;

} // BlockingFindFirst2


SMB_TRANS_STATUS
DoFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{

    PREQ_FIND_FIRST2 request;
    PRESP_FIND_FIRST2 response;
    PTRANSACTION transaction;
    PCONNECTION connection;

    NTSTATUS status,TableStatus;
    UNICODE_STRING fileName;
    PTABLE_ENTRY entry = NULL;
    PTABLE_HEADER searchTable;
    SHORT sidIndex = 0;
    USHORT sequence;
    USHORT maxCount;
    USHORT flags;
    USHORT informationLevel;
    BOOLEAN isUnicode;
    PSRV_DIRECTORY_INFORMATION directoryInformation;
    CLONG nonPagedBufferSize;

    PSEARCH search = NULL;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint1( "Find First2 entered; transaction 0x%p\n", transaction );
    }

    request = (PREQ_FIND_FIRST2)transaction->InParameters;
    response = (PRESP_FIND_FIRST2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount < sizeof(REQ_FIND_FIRST2)) ||
         (transaction->MaxParameterCount < sizeof(RESP_FIND_FIRST2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "DoFindFirst2: bad parameter byte counts: "
                      "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Make sure this really is a disk type share
    //
    if( transaction->TreeConnect->Share->ShareType != ShareTypeDisk ) {
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, transaction->TreeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Initialize the string containing the search name specification.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    status =  SrvCanonicalizePathName(
            WorkContext,
            transaction->TreeConnect->Share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            FALSE,
            isUnicode,
            &fileName
            );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Get parameters from the request SMB.
    //

    maxCount = SmbGetUshort( &request->SearchCount );
    flags = SmbGetUshort( &request->Flags );

    //
    // Make sure that the informationLevel is supported.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    switch ( informationLevel ) {

    case SMB_INFO_STANDARD:
    case SMB_INFO_QUERY_EA_SIZE:
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_FIND_FILE_DIRECTORY_INFO:
    case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
    case SMB_FIND_FILE_NAMES_INFO:
    case SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO:
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "DoFindFirst2: Bad info level: %ld\n",
                          informationLevel );
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Allocate a search block on the assumption that a search table
    // entry will be available when needed.
    //

    SrvAllocateSearch( &search, &fileName, FALSE );

    if ( search == NULL ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: unable to allocate search block.\n" );
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        return SmbTransStatusErrorWithoutData;
    }
    search->SearchStorageType = SmbGetUlong(&request->SearchStorageType);

    //
    // Allocate an SID for the search.  The SID is used to locate the
    // search block on FindNexts.  If there are no free entries in the
    // table, attempt to grow the table.  If we are unable to grow the table,
    // attempt to timeout a search block using the shorter timeout period.
    // If this fails, reject the request.
    //

    connection = WorkContext->Connection;
    searchTable = &connection->PagedConnection->SearchTable;

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Before inserting this search block, make sure the session and tree
    // connect is still active.  If this gets inserted after the session
    // is closed, the search might not be cleaned up properly.
    //

    if (GET_BLOCK_STATE(WorkContext->Session) != BlockStateActive) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: Session Closing.\n" );
        }

        RELEASE_LOCK( &connection->Lock );

        FREE_HEAP( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        return SmbTransStatusErrorWithoutData;

    } else if (GET_BLOCK_STATE(WorkContext->TreeConnect) != BlockStateActive) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: Tree Connect Closing.\n" );
        }

        RELEASE_LOCK( &connection->Lock );

        FREE_HEAP( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Set up referenced session and tree connect pointers and increment
    // the count of open files on the session.  This prevents an idle
    // session with an open search from being autodisconnected.
    //

    search->Session = WorkContext->Session;
    SrvReferenceSession( WorkContext->Session );

    search->TreeConnect = WorkContext->TreeConnect;
    SrvReferenceTreeConnect( WorkContext->TreeConnect );

    WorkContext->Session->CurrentSearchOpenCount++;

    if ( searchTable->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             searchTable,
             SrvInitialSearchTableSize,
             SrvMaxSearchTableSize,
             &TableStatus ) == FALSE
         &&
         SrvTimeoutSearches(
             NULL,
             connection,
             TRUE ) == 0
       ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: Connection SearchTable full.\n" );
        }

        //
        // Decrement the counts of open searches.
        //

        WorkContext->Session->CurrentSearchOpenCount--;
        RELEASE_LOCK( &connection->Lock );

        SrvDereferenceTreeConnect( search->TreeConnect );
        SrvDereferenceSession( search->Session );

        FREE_HEAP( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
        {
            SrvLogTableFullError( SRV_TABLE_SEARCH);
            SrvSetSmbError( WorkContext, STATUS_OS2_NO_MORE_SIDS );
        }
        else {
            SrvSetSmbError( WorkContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        return SmbTransStatusErrorWithoutData;
    }

    sidIndex = searchTable->FirstFreeEntry;

    //
    // A free SID was found.  Remove it from the free list and set
    // its owner and sequence number.
    //

    entry = &searchTable->Table[sidIndex];

    searchTable->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( searchTable->LastFreeEntry == sidIndex ) {
        searchTable->LastFreeEntry = -1;
    }

    INCREMENT_SID_SEQUENCE( entry->SequenceNumber );

    //
    // SID = sequence | sidIndex == 0 is illegal.  If this is
    // the current value, increment the sequence.
    //

    if ( entry->SequenceNumber == 0 && sidIndex == 0 ) {
        INCREMENT_SID_SEQUENCE( entry->SequenceNumber );
    }

    sequence = entry->SequenceNumber;

    entry->Owner = search;

    RELEASE_LOCK( &connection->Lock );

    //
    // Fill in other fields of the search block.
    //

    search->SearchAttributes = SmbGetUshort( &request->SearchAttributes );
    search->TableIndex = sidIndex;

    //
    // Store the Flags2 field of the smb in the search block.  This is
    // used as a workaround for an OS/2 client side bug where the
    // findfirst and findnext flags2 bits are inconsistent.
    //

    search->Flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );

    if ( search->Flags2 & SMB_FLAGS2_KNOWS_LONG_NAMES ) {

        search->Flags2 |= SMB_FLAGS2_KNOWS_EAS;

    }

    //
    // A buffer of nonpaged pool is required by SrvQueryDirectoryFile.
    // We need to use the SMB buffer for found file names and information,
    // so allocate a buffer from nonpaged pool.
    //
    // If we don't need to return many files, we don't need to allocate
    // a large buffer.  The buffer size is the configurable size or
    // enough to hold two more then the number of files we need to
    // return.  We get space to hold two extra files in case some
    // files do not meet the search criteria (eg directories).
    //

    if ( maxCount > MAX_FILES_FOR_MED_FIND2 ) {
        nonPagedBufferSize = MAX_SEARCH_BUFFER_SIZE;
    } else if ( maxCount > MAX_FILES_FOR_MIN_FIND2 ) {
        nonPagedBufferSize = MED_SEARCH_BUFFER_SIZE;
    } else {
        nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;
    }

    directoryInformation = ALLOCATE_NONPAGED_POOL(
                               nonPagedBufferSize,
                               BlockTypeDataBuffer
                               );

    if ( directoryInformation == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "DoFindFirst2: could not allocate nonpaged pool.",
            NULL,
            NULL
            );

        SrvCloseSearch( search );
        SrvDereferenceSearch( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        return SmbTransStatusErrorWithoutData;
    }

    directoryInformation->DirectoryHandle = 0;

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                      nonPagedBufferSize, directoryInformation );
    }

    //
    // Call SrvFind2Loop to fill the data section of the transaction with
    // file entries.  It writes into the response parameters section
    // of the SMB information relating to the results of the search.
    // The information is the same as the response parameters for
    // a FindNext2, so that structure is used.  The FindFirst2 parameters
    // are identical to the FindNext2 parameters except for the Sid
    // at the beginning of the FindFirst2 response.
    //

    status = SrvFind2Loop(
                 WorkContext,
                 TRUE,
                 NULL,
                 flags,
                 informationLevel,
                 transaction,
                 directoryInformation,
                 nonPagedBufferSize,
                 search->SearchAttributes,
                 &fileName,
                 maxCount,
                 (PRESP_FIND_NEXT2)( &response->SearchCount ),
                 search
                 );

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &fileName );
    }

    //
    // Map the error, if necessary
    //

    if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
        if ( status == STATUS_NO_SUCH_FILE ) {
            status = STATUS_NO_MORE_FILES;
        }
    }

    if ( !NT_SUCCESS(status) && SmbGetUshort( &response->SearchCount ) == 0 ) {

        //
        // If an error was encountered on a find first, we close the search
        // block.
        //

        search->DirectoryHandle = NULL;

        SrvCloseSearch( search );
        SrvDereferenceSearch( search );

        SrvCloseQueryDirectory( directoryInformation );

        DEALLOCATE_NONPAGED_POOL( directoryInformation );

        SrvSetSmbError2( WorkContext, status, TRUE );
        transaction->SetupCount = 0;
        transaction->ParameterCount = sizeof(RESP_FIND_FIRST2);
        SmbPutUshort( &response->Sid, 0 );

        return SmbTransStatusErrorWithData;
    }

    //
    // If the client told us to close the search after this request, or
    // close at end-of-search, or this no files were found, close the
    // search block and call SrvCloseQueryDirectory.  Otherwise, store
    // information in the search block.
    //

    if ( ( flags & SMB_FIND_CLOSE_AFTER_REQUEST ) != 0 ||
         ( status == STATUS_NO_MORE_FILES &&
             ( flags & SMB_FIND_CLOSE_AT_EOS ) != 0 ) ) {

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "Closing search at %p\n", search );
        }

        search->DirectoryHandle = NULL;

        SrvCloseSearch( search );
        SrvCloseQueryDirectory( directoryInformation );

    } else {

        search->DirectoryHandle = directoryInformation->DirectoryHandle;
        search->Wildcards = directoryInformation->Wildcards;
    }

    //
    // Free the buffer used for the search and dereference our pointer to
    // the search block.
    //

    DEALLOCATE_NONPAGED_POOL( directoryInformation );

    search->InUse = FALSE;
    SrvDereferenceSearch( search );

    //
    // Build the output parameter and data structures.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_FIND_FIRST2);
    SmbPutUshort( &response->Sid, MAKE_SID( sidIndex, sequence ) );

    return SmbTransStatusSuccess;

} // DoFindFirst2


SMB_TRANS_STATUS
SrvSmbFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find Next2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;

    PTRANSACTION transaction;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_NEXT2;
    SrvWmiStartContext(WorkContext);

    //
    // If the infomation level is QUERY_EAS_FROM_LIST, and we
    // are not in a blocking thread, requeue the request to a blocking
    // thread.
    //
    // We can't process the SMB in a non blocking thread because this
    // info level requires opening the file, which may be oplocked,
    // so the open operation may block.
    //

    transaction = WorkContext->Parameters.Transaction;

    if( transaction->ParameterCount >= sizeof(REQ_FIND_NEXT2) ) {

        PREQ_FIND_NEXT2 request = (PREQ_FIND_NEXT2)transaction->InParameters;
        USHORT informationLevel = SmbGetUshort( &request->InformationLevel );

        if ( informationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {

            WorkContext->FspRestartRoutine = BlockingFindNext2;
            SrvQueueWorkToBlockingThread( WorkContext );
            SmbStatus = SmbTransStatusInProgress;
            goto Cleanup;
        }
    }

    SmbStatus = DoFindNext2( WorkContext );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbFindNext2


VOID SRVFASTCALL
BlockingFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find Next2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_NEXT2;
    SrvWmiStartContext(WorkContext);
    smbStatus = DoFindNext2( WorkContext );
    if ( smbStatus != SmbTransStatusInProgress ) {
        SrvCompleteExecuteTransaction( WorkContext, smbStatus );
    }

    SrvWmiEndContext(WorkContext);
    return;

} // BlockingFindNext2


SMB_TRANS_STATUS
DoFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_FIND_NEXT2 request;
    PRESP_FIND_NEXT2 response;
    PTRANSACTION transaction;

    NTSTATUS status;
    USHORT i;
    PCHAR ansiChar;
    PWCH unicodeChar;
    ULONG maxIndex;
    BOOLEAN illegalPath;
    BOOLEAN freeFileName;
    UNICODE_STRING fileName;
    PTABLE_ENTRY entry = NULL;
    USHORT maxCount;
    USHORT informationLevel;
    PSRV_DIRECTORY_INFORMATION directoryInformation;
    CLONG nonPagedBufferSize;
    ULONG resumeFileIndex;
    USHORT flags;
    USHORT sid;

    PSEARCH search = NULL;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint1( "Find Next2 entered; transaction %p\n", transaction );
    }

    request = (PREQ_FIND_NEXT2)transaction->InParameters;
    response = (PRESP_FIND_NEXT2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_FIND_NEXT2)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_FIND_NEXT2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "DoFindNext2: bad parameter byte counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Get parameters from the request SMB.
    //

    maxCount = SmbGetUshort( &request->SearchCount );
    resumeFileIndex = SmbGetUlong( &request->ResumeKey );
    flags = SmbGetUshort( &request->Flags );

    //
    // Make sure that the informationLevel is supported.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    switch ( informationLevel ) {

    case SMB_INFO_STANDARD:
    case SMB_INFO_QUERY_EA_SIZE:
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_FIND_FILE_DIRECTORY_INFO:
    case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
    case SMB_FIND_FILE_NAMES_INFO:
    case SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO:
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "DoFindNext2: Bad info level: %ld\n",
                          informationLevel );
        }

        SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // A buffer of nonpaged pool is required by SrvQueryDirectoryFile.
    // We need to use the SMB buffer for found file names and information,
    // so allocate a buffer from nonpaged pool.
    //
    // If we don't need to return many files, we don't need to allocate
    // a large buffer.  The buffer size is the configurable size or
    // enough to hold two more then the number of files we need to
    // return.  We get space to hold two extra files in case some
    // files do not meet the search criteria (eg directories).
    //

    if ( maxCount > MAX_FILES_FOR_MED_FIND2 ) {
        nonPagedBufferSize = MAX_SEARCH_BUFFER_SIZE;
    } else if ( maxCount > MAX_FILES_FOR_MIN_FIND2 ) {
        nonPagedBufferSize = MED_SEARCH_BUFFER_SIZE;
    } else {
        nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;
    }

    directoryInformation = ALLOCATE_NONPAGED_POOL(
                               nonPagedBufferSize,
                               BlockTypeDataBuffer
                               );

    if ( directoryInformation == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "DoFindFirst2: unable to allocate nonpaged pool.",
            NULL,
            NULL
            );

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        return SmbTransStatusErrorWithoutData;
    }

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                      nonPagedBufferSize, directoryInformation );
    }

    //
    // Get the search block corresponding to this SID.  SrvVerifySid
    // references the search block and fills in fields of
    // directoryInformation so it is ready to be used by
    // SrvQueryDirectoryFile.
    //

    sid = SmbGetUshort( &request->Sid );

    search = SrvVerifySid(
                 WorkContext,
                 SID_INDEX2( sid ),
                 SID_SEQUENCE2( sid ),
                 directoryInformation,
                 nonPagedBufferSize
                 );

    if ( search == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "DoFindNext2: Invalid SID: %lx.\n", sid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        DEALLOCATE_NONPAGED_POOL( directoryInformation );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Initialize the string containing the resume name specification.
    // If the client requested that we resume from the last file returned,
    // use the file name and index stored in the search block.
    //

    if ( ( flags & SMB_FIND_CONTINUE_FROM_LAST ) == 0 ) {

        //
        // Test and use the information passed by the client.  A file
        // name may not be longer than MAXIMUM_FILENAME_LENGTH characters,
        // and it should not contain any directory information.
        //

        illegalPath = FALSE;
        freeFileName = FALSE;

        if ( SMB_IS_UNICODE( WorkContext ) ) {

            fileName.Buffer = ALIGN_SMB_WSTR( (PWCH)request->Buffer );

            maxIndex = (ULONG)((END_OF_REQUEST_SMB( WorkContext ) -
                               (PUCHAR)fileName.Buffer) / sizeof(WCHAR));

            for ( i = 0, unicodeChar = fileName.Buffer;
                  (i < MAXIMUM_FILENAME_LENGTH) && (i < maxIndex);
                  i++, unicodeChar++ ) {

                if ( *unicodeChar == '\0' ) {
                    break;
                }

                if ( IS_UNICODE_PATH_SEPARATOR( *unicodeChar ) ) {
                    IF_DEBUG(SMB_ERRORS) {
                        SrvPrint1( "DoFindNext2: illegal path name: %ws\n",
                                      fileName.Buffer );
                    }
                    illegalPath = TRUE;
                    break;
                }

            }

            fileName.Length = (USHORT) (i * sizeof(WCHAR));
            fileName.MaximumLength = fileName.Length;

        } else {

            ansiChar = (PCHAR)request->Buffer;

            maxIndex = (ULONG)(END_OF_REQUEST_SMB( WorkContext ) - ansiChar);

            for ( i = 0;
                  (i < MAXIMUM_FILENAME_LENGTH) && (i < maxIndex);
                  i++, ansiChar++ ) {

                if ( *ansiChar == '\0' ) {
                    break;
                }

                if ( IS_ANSI_PATH_SEPARATOR( *ansiChar ) ) {
                    IF_DEBUG(SMB_ERRORS) {
                        SrvPrint1( "DoFindNext2: illegal path name: %s\n",
                                      request->Buffer );
                    }
                    illegalPath = TRUE;
                    break;
                }

            }

            if ( !illegalPath ) {

                status = SrvMakeUnicodeString(
                            FALSE,
                            &fileName,
                            request->Buffer,
                            &i
                            );

                if ( !NT_SUCCESS(status) ) {

                    IF_DEBUG(SMB_ERRORS) {
                        SrvPrint0( "DoFindNext2: unable to allocate Unicode string\n" );
                    }

                    search->InUse = FALSE;
                    SrvDereferenceSearch( search );
                    DEALLOCATE_NONPAGED_POOL( directoryInformation );

                    SrvSetSmbError2(
                        WorkContext,
                        STATUS_OBJECT_PATH_SYNTAX_BAD,
                        TRUE
                        );
                    return SmbTransStatusErrorWithoutData;

                }

                freeFileName = TRUE;

            }

        }

        if ( illegalPath ) {

            search->InUse = FALSE;
            SrvDereferenceSearch( search );
            DEALLOCATE_NONPAGED_POOL( directoryInformation );

            SrvSetSmbError( WorkContext, STATUS_OBJECT_PATH_SYNTAX_BAD );
            return SmbTransStatusErrorWithoutData;

        }

    } else {

        //
        // Use the information in the search block.
        //

        fileName = search->LastFileNameReturned;

        freeFileName = FALSE;

        resumeFileIndex = search->LastFileIndexReturned;

    }

    //
    // Call SrvFind2Loop to fill the SMB buffer and set output parameters.
    //
    // !!! The NULL that might get passed for the resume file index is
    //     a real hack.  I doubt it is necessary, but it could prevent
    //     a server crash if we somehow failed to store the resume file
    //     name.

    status = SrvFind2Loop(
                 WorkContext,
                 FALSE,
                 fileName.Buffer != NULL ? &resumeFileIndex : NULL,
                 flags,
                 informationLevel,
                 transaction,
                 directoryInformation,
                 nonPagedBufferSize,
                 search->SearchAttributes,
                 &fileName,
                 maxCount,
                 response,
                 search
                 );

    if ( freeFileName ) {
        RtlFreeUnicodeString( &fileName );
    }

    if ( !NT_SUCCESS(status) && status != STATUS_NO_MORE_FILES ) {

        search->InUse = FALSE;
        SrvDereferenceSearch( search );

        DEALLOCATE_NONPAGED_POOL( directoryInformation );

        transaction->SetupCount = 0;
        transaction->ParameterCount = sizeof(RESP_FIND_NEXT2);

        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    }

    //
    // If the client told us to close the search after this request,
    // or close at end-of-search, close the search block and call
    // SrvCloseQueryDirectory.
    //

    if ( ( flags & SMB_FIND_CLOSE_AFTER_REQUEST ) != 0 ||
         ( status == STATUS_NO_MORE_FILES &&
             ( flags & SMB_FIND_CLOSE_AT_EOS ) != 0 ) ) {

        search->DirectoryHandle = NULL;
        SrvCloseSearch( search );
        SrvCloseQueryDirectory( directoryInformation );
    }

    //
    // Dereference our pointer to the search block and free the buffer.
    //

    DEALLOCATE_NONPAGED_POOL( directoryInformation );

    search->InUse = FALSE;
    SrvDereferenceSearch( search );

    //
    // Build the output parameter and data structures.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_FIND_NEXT2);

    return SmbTransStatusSuccess;

} // DoFindNext2


NTSTATUS
SrvFind2Loop (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT Flags,
    IN USHORT InformationLevel,
    IN PTRANSACTION Transaction,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize,
    IN USHORT SearchAttributes,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN USHORT MaxCount,
    IN PRESP_FIND_NEXT2 Response,
    OUT PSEARCH Search
    )

/*++

Routine Description:

    This routine does the looping necessary to get files and put them
    into an SMB buffer for the Find First2 and Find Next2 transaction
    protocols.

Arguments:

    WorkContext -

    IsFirstCall - TRUE if this is a Find First and this is the first call
        to SrvQueryDirectoryFile.

    ResumeFileIndex - if non-NULL, a pointer to the file index to resume
        from.

    Flags - the Flags field of the request SMB.

    InformationLevel - the InformationLevel field of the request SMB.  The
        validity of this value should be verified by the calling routine.

    Transaction - a pointer to the transaction block to use.

    DirectoryInformation - a pointer to the SRV_DIRECTORY_INFORMATION
        structure to use.

    BufferSize - size of the DirectoryInformation buffer.

    SearchAttributes - the SMB-style attributes to pass to
        SrvQueryDirectoryFile.

    FileName - if non-NULL the file name to resume the search from.

    MaxCount - the maximum number of files to get.

    Response - a pointer to the response field of the SMB.  If this is
        a Find First2, it is a pointer to the SearchCount field of the
        response SMB--Find First2 and Find Next2 response formats are
        identical from this point on.

    Search - a pointer to the search block to use.

Return Value:

    NTSTATUS indicating results.

--*/

{
    NTSTATUS status;

    PCHAR bufferLocation;
    BOOLEAN resumeKeysRequested;
    BOOLEAN allowExtraLongNames;
    BOOLEAN isUnicode;
    USHORT count = 0;
    PCHAR lastEntry;
    CLONG totalBytesWritten;
    OEM_STRING oemString;
    UNICODE_STRING unicodeString;
    UNICODE_STRING lastFileName;
    ULONG lastFileIndex = (ULONG)0xFFFFFFFF;
    HANDLE fileHandle;
    PFILE_GET_EA_INFORMATION ntGetEa;
    ULONG ntGetEaLength;
    USHORT eaErrorOffset = 0;
    BOOLEAN filterLongNames;
    BOOLEAN errorOnFileOpen;
    BOOLEAN findWithBackupIntent;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOLEAN createNullEas;

    PAGED_CODE( );

    //
    // If the client is requesting an NT info level for search information,
    // do not return resume keys outside the actual file entry.  Resume
    // keys (aka FileIndex) are part of every NT info structure.
    //
    // Also, for NT info levels we can return file names longer than 255
    // bytes, because the NT info levels have name length fields that
    // are four bytes wide, whereas the downlevel info levels only have
    // one-byte name length fields.
    //

    if ( InformationLevel == SMB_FIND_FILE_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_NAMES_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO 
       ) {

        resumeKeysRequested = FALSE;
        allowExtraLongNames = TRUE;

    } else {

        resumeKeysRequested =
            (BOOLEAN)((Flags & SMB_FIND_RETURN_RESUME_KEYS) != 0 ? TRUE : FALSE);
        allowExtraLongNames = FALSE;
    }

    //
    // Is this for backup intent?
    //

    if ( (Flags & SMB_FIND_WITH_BACKUP_INTENT) != 0 ) {
        findWithBackupIntent = TRUE;
    } else {
        findWithBackupIntent = FALSE;
    }

    //
    // Is this request in Unicode?
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    //
    // Initialize count of files found.
    //

    SmbPutUshort( &Response->SearchCount, 0 );

    //
    // If this a request to return EAs, convert the OS/2 1.2 EA list
    // to NT format.  This routine allocates space for the NT list
    // which must be deallocated before we exit.
    //

    if ( InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {

        PGEALIST geaList = (PGEALIST)Transaction->InData;

        if (Transaction->DataCount < sizeof(GEALIST) ||
            SmbGetUshort(&geaList->cbList) < sizeof(GEALIST) ||
            SmbGetUshort(&geaList->cbList) > Transaction->DataCount) {

            SmbPutUshort( &Response->SearchCount, 0 );
            SmbPutUshort( &Response->EndOfSearch, 0 );
            SmbPutUshort( &Response->EaErrorOffset, 0 );
            SmbPutUshort( &Response->LastNameOffset, 0 );
            Transaction->DataCount = 0;

            return STATUS_OS2_EA_LIST_INCONSISTENT;
        }

        status = SrvOs2GeaListToNt(
                     geaList,
                     &ntGetEa,
                     &ntGetEaLength,
                     &eaErrorOffset
                     );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                SrvPrint1( "SrvFind2Loop: SrvOs2GeaListToNt failed, "
                          "status = %X\n", status );
            }

            SmbPutUshort( &Response->SearchCount, 0 );
            SmbPutUshort( &Response->EndOfSearch, 0 );
            SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );
            SmbPutUshort( &Response->LastNameOffset, 0 );
            Transaction->DataCount = 0;

            return status;
        }
    }

    //
    // Determine whether long filenames (non-8.3) should be filtered out
    // or returned to the client.
    //
    // There is a bug in the LanMan21 that makes the redir forget that
    // he knows about long names.

    if ( ( ( Search->Flags2 & SMB_FLAGS2_KNOWS_LONG_NAMES ) != 0 ) &&
         !IS_DOS_DIALECT( WorkContext->Connection->SmbDialect ) ) {
        filterLongNames = FALSE;
    } else {
        filterLongNames = TRUE;
    }

    //
    // If the client says he doesn't know about long names and this is
    // a request for any info level other than SMB_INFO_STANDARD, we
    // need to fail the request.
    //

    if ( filterLongNames && InformationLevel != SMB_INFO_STANDARD ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvFind2Loop: client doesn't know long names.\n" );
        }

        SmbPutUshort( &Response->SearchCount, 0 );
        SmbPutUshort( &Response->EndOfSearch, 0 );
        SmbPutUshort( &Response->EaErrorOffset, 0 );
        SmbPutUshort( &Response->LastNameOffset, 0 );
        Transaction->DataCount = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Loop calling SrvQueryDirectoryFile to get files.  We do this until
    // one of the following conditions is met:
    //
    //   1) There are no more files to return.
    //   2) We have obtained as many files as were requested.
    //   3) We have put in as much data as MaxDataCount allows.
    //

    bufferLocation = Transaction->OutData;
    lastEntry = bufferLocation;
    totalBytesWritten = 0;

    do {

        //
        // The ff fields have the same offsets in the three directory
        // information structures:
        //      NextEntryOffset
        //      FileIndex
        //      CreationTime
        //      LastAccessTime
        //      LastWriteTime
        //      ChangeTime
        //      EndOfFile
        //      AllocationSize
        //      FileAttributes
        //      FileNameLength
        //

        PFILE_DIRECTORY_INFORMATION fileBasic;
        PFILE_FULL_DIR_INFORMATION fileFull;
        PFILE_BOTH_DIR_INFORMATION fileBoth;
        PFILE_ID_FULL_DIR_INFORMATION fileIdFull;
        PFILE_ID_BOTH_DIR_INFORMATION fileIdBoth;
        ULONG ntInformationLevel;

        //
        // Make sure these asserts hold.
        //

        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, NextEntryOffset ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, NextEntryOffset ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileIndex ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileIndex ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, CreationTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, CreationTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastAccessTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastAccessTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastWriteTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastWriteTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, ChangeTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, ChangeTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, EndOfFile ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, EndOfFile ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, AllocationSize ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, AllocationSize ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileAttributes ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileAttributes ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileNameLength ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileNameLength ) );

        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, NextEntryOffset ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, NextEntryOffset ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileIndex ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileIndex ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, CreationTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, CreationTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastAccessTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, LastAccessTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastWriteTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, LastWriteTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, ChangeTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, ChangeTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, EndOfFile ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, EndOfFile ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, AllocationSize ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, AllocationSize ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileAttributes ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileAttributes ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileNameLength ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileNameLength ) );

        //
        // Set the info level to be used for the NT call.  If
        // SMB_FIND_FILE_NAMES_INFO is the info level, use
        // FileDirectoryInformation as it returns all the correct
        // information and works with SrvQueryDirectoryFile.
        //

        if ( InformationLevel == SMB_INFO_QUERY_EA_SIZE ||
                InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ) {

            ntInformationLevel = FileFullDirectoryInformation;

        } else if ( InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ||
                InformationLevel == SMB_INFO_STANDARD ) {

            ntInformationLevel = FileBothDirectoryInformation;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO ) {

            ntInformationLevel = FileIdFullDirectoryInformation;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ) {

            ntInformationLevel = FileIdBothDirectoryInformation;

        }        
        else {

            //
            // SMB_INFO_QUERY_EAS_FROM_LIST
            // SMB_FIND_NAMES_INFO
            // SMB_FIND_FILE_DIRECTORY_INFO
            //

            ntInformationLevel = FileDirectoryInformation;
        }

        //
        // Call SrvQueryDirectoryFile to get a file.
        //

        status = SrvQueryDirectoryFile(
                     WorkContext,
                     IsFirstCall,
                     filterLongNames,
                     findWithBackupIntent,
                     ntInformationLevel,
                     Search->SearchStorageType,
                     FileName,
                     ResumeFileIndex,
                     SearchAttributes,
                     DirectoryInformation,
                     BufferSize             // !!! optimizations?
                     );

        //
        // If the client requested EA information, open the file.
        //
        // If the found file is '.' (current directory) or '..' (parent
        // directory) do not open the file.  This is because we do not want
        // to perform any operations on these files at this point (don't
        // return EA size, etc.).
        //

        fileBasic = DirectoryInformation->CurrentEntry;
        fileBoth = (PFILE_BOTH_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileFull = (PFILE_FULL_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileIdBoth = (PFILE_ID_BOTH_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileIdFull = (PFILE_ID_FULL_DIR_INFORMATION)DirectoryInformation->CurrentEntry;

        errorOnFileOpen = FALSE;
        createNullEas = FALSE;

        if ( NT_SUCCESS( status ) &&
             InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST &&

             !( ( fileBasic->FileNameLength == sizeof(WCHAR)   &&
                  fileBasic->FileName[0] == '.' )
                       ||
                ( fileBasic->FileNameLength == 2*sizeof(WCHAR)  &&
                  fileBasic->FileName[0] == '.' &&
                  fileBasic->FileName[1] == '.' ) )
            ) {


            UNICODE_STRING fileName;

            //
            // Set up local variables for the filename to open.
            //

            fileName.Length = (SHORT)fileBasic->FileNameLength;
            fileName.MaximumLength = fileName.Length;
            fileName.Buffer = (PWCH)fileBasic->FileName;

            //
            // Set up the object attributes structure for SrvIoCreateFile.
            //

            SrvInitializeObjectAttributes_U(
                &objectAttributes,
                &fileName,
                (WorkContext->RequestHeader->Flags &
                    SMB_FLAGS_CASE_INSENSITIVE ||
                    WorkContext->Session->UsingUppercasePaths) ?
                    OBJ_CASE_INSENSITIVE : 0L,
                DirectoryInformation->DirectoryHandle,
                NULL
                );

            IF_DEBUG(SEARCH) {
                SrvPrint1( "SrvQueryDirectoryFile: Opening file %wZ\n", &fileName );
            }

            //
            // Attempt to open the file, using the client's security
            // profile to check access.  (We call SrvIoCreateFile, rather than
            // NtOpenFile, in order to get user-mode access checking.)
            //

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         FILE_READ_EA,
                         &objectAttributes,
                         &ioStatusBlock,
                         NULL,                        // AllocationSize
                         0,                           // FileAttributes
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN,                   // Disposition
                         0, // FILE_COMPLETE_IF_OPLOCKED,   // CreateOptions
                         NULL,                        // EaBuffer
                         0,                           // EaLength
                         CreateFileTypeNone,          // File type
                         NULL,                        // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,       // Options
                         NULL
                         );
            if ( NT_SUCCESS(status) ) {
                SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 29, Search );

            } else if( RtlCompareUnicodeString( &fileName, &SrvEaFileName, TRUE ) == 0 ) {
                //
                // They were trying to open up the  EA data file.  We expect this
                //   failure and skip past it.  This file has no EAs
                //
                IF_DEBUG(SEARCH) {
                    SrvPrint1( "SrvQueryDirectoryFile: Skipping file %wZ\n", &fileName );
                }
                status = STATUS_SUCCESS;
                goto skipit;
            }

            //
            // If the user didn't have this permission, update the statistics
            // database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

            //
            // If the file is oplocked, wait for the oplock to break
            // synchronously.
            //

#if 1
            ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );
#else
            if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {
                status = SrvWaitForOplockBreak( WorkContext, fileHandle );
                if ( !NT_SUCCESS(status) ) {
                    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 45, Search );
                    SrvNtClose( fileHandle, TRUE );
                }
            }
#endif

            if ( !NT_SUCCESS(status) ) {
                errorOnFileOpen = TRUE;
                fileHandle = NULL;

                IF_DEBUG(ERRORS) {
                    SrvPrint2( "Find2Loop: SrvIoCreateFile for file %wZ "
                              "failed: %X\n",
                                  &fileName, status );
                }
            } else {
                SrvStatistics.TotalFilesOpened++;
            }

        } else {
skipit:
            createNullEas = TRUE;
            fileHandle = NULL;
        }

        //
        // If SrvQueryDirectoryFile returns an error, break out of the
        // loop.  If the error occurred in opening the file for one of
        // the higher info levels, then we want to return the files we
        // have obtained so far.
        //
        // If the error occurred on the file open *and* we haven't
        // returned any files yet, then we want to return this file
        // along with the code ERROR_EA_ACCESS_DENIED.
        //

        if ( !NT_SUCCESS(status) ) {

            if ( count == 0 && errorOnFileOpen ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint1( "EA access denied on first file of search (%x).\n",
                                   status );
                }

                fileHandle = NULL;
                status = STATUS_OS2_EA_ACCESS_DENIED;
                break;

            } else if ( status == STATUS_NO_MORE_FILES && count == 0 ) {

                SmbPutUshort( &Response->SearchCount, 0 );
                SmbPutUshort( &Response->EndOfSearch, 0 );
                SmbPutUshort( &Response->EaErrorOffset, 0 );
                SmbPutUshort( &Response->LastNameOffset, 0 );
                Transaction->DataCount = 0;

                return status;

            } else {

                break;
            }
        }

        //
        // Since it is no longer the first call to SrvQueryDirectoryFile,
        // reset the isFirstCall local variable.  If necessary, we already
        // rewound the search, so set the ResumeFileIndex to NULL.
        //

        IsFirstCall = FALSE;
        ResumeFileIndex = NULL;

        IF_SMB_DEBUG(SEARCH2) {
            UNICODE_STRING nameString;

            switch (ntInformationLevel) {
            case FileFullDirectoryInformation:
                nameString.Buffer = fileFull->FileName;
                nameString.Length = (USHORT)fileFull->FileNameLength;
                break;
            case FileBothDirectoryInformation:
                nameString.Buffer = fileBoth->FileName;
                nameString.Length = (USHORT)fileBoth->FileNameLength;
                break;
            default:
                nameString.Buffer = fileBasic->FileName;
                nameString.Length = (USHORT)fileBasic->FileNameLength;
                break;
            }
            SrvPrint4( "SrvQueryDirectoryFile(%ld)-- %p, length=%ld, "
                      "status=%X\n", count,
                      &nameString,
                      nameString.Length,
                      status );
        }

        //
        // Downlevel info levels have no provision for file names longer
        // than 8 bits, while the NT info levels return 32 bits.  If the
        // file name is too long, skip it.
        //

        if ( !allowExtraLongNames ) {
            if ( isUnicode ) {
                if ( fileBasic->FileNameLength > 255 ) {
                    continue;
                }
            } else {
                if ( fileBasic->FileNameLength > 255*sizeof(WCHAR) ) {
                    continue;
                }
            }
        }

        //
        // If the client has requested that resume keys (really file
        // indices for the purposes of this protocol), put in the
        // four bytes just before the actual file information.
        //
        // Make sure that we don't write beyond the buffer when we do
        // this.  The fact that the buffer is full will be caught later.
        //

        if ( resumeKeysRequested &&
             ( (CLONG)( (bufferLocation+4) - Transaction->OutData ) <
                Transaction->MaxDataCount ) ) {

            SmbPutUlong( (PSMB_ULONG)bufferLocation, fileBasic->FileIndex );
            bufferLocation += 4;
        }

        //
        // Convert the information from NT style to the SMB protocol format,
        // which is identical to the OS/2 1.2 semantics.  Use an if
        // statement rather than a switch so that a break will cause
        // termination of the do loop.
        //

        if ( InformationLevel == SMB_INFO_STANDARD ) {

            PSMB_FIND_BUFFER findBuffer = (PSMB_FIND_BUFFER)bufferLocation;
            ULONG fileNameLength;
            UNICODE_STRING fileName;

            //
            // Find the file name.  If a short name is present, and the
            // redirector ask for short names only, use it.  Otherwise
            // use the full file name.
            //

            if ( filterLongNames &&
                 fileBoth->ShortNameLength != 0 ) {

                fileName.Buffer = fileBoth->ShortName;
                fileName.Length = fileBoth->ShortNameLength;
                fileName.MaximumLength = fileBoth->ShortNameLength;

            } else {

                fileName.Buffer = fileBoth->FileName;
                fileName.Length = (USHORT)fileBoth->FileNameLength;
                fileName.MaximumLength = (USHORT)fileBoth->FileNameLength;

            }

            //
            // Find the new buffer location.  This is not used until the
            // next pass through the loop, but we do it here in order to
            // check if there is enough space for the current file entry in
            // the buffer.  The +1 is for the zero terminator on the file
            // name.
            //

            if ( isUnicode ) {
                bufferLocation = ALIGN_SMB_WSTR( findBuffer->FileName );
                bufferLocation += fileName.Length + sizeof(WCHAR);
            } else {
                unicodeString.Buffer = fileName.Buffer;
                unicodeString.Length = fileName.Length;
                unicodeString.MaximumLength = unicodeString.Length;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
                bufferLocation = (PCHAR)(findBuffer->FileName + fileNameLength);
            }

            //
            // Make sure that there is enough space in the buffer before
            // writing the filename.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Put information about the file into the SMB buffer.
            //

            ConvertFileInfo(
                fileBasic,
                fileName.Buffer,
                (BOOLEAN)((fileBoth->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0),
                isUnicode,
                findBuffer
                );

            //
            // Put the file name in the buffer, in Unicode or ANSI
            // depending what was negotiated.
            //

            if ( isUnicode ) {

                PWCH buffer = ALIGN_SMB_WSTR( findBuffer->FileName );

                //
                // We need to upper case the name if the client does
                // not understand long names.  This is done for compatibility
                // reasons (FAT upper cases names).
                //

                if ( filterLongNames ) {

                    (VOID)RtlUpcaseUnicodeString(
                                            &fileName,
                                            &fileName,
                                            FALSE
                                            );

                }


                RtlCopyMemory(
                    buffer,
                    fileName.Buffer,
                    fileName.Length
                    );

                ASSERT(fileName.Length <= 255);

                findBuffer->FileNameLength = (UCHAR)fileName.Length;

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PCHAR)findBuffer->FileName;

                //
                // We need to upper case the name if the client does
                // not understand long names.  This is done for compatibility
                // reasons (FAT upper cases names).
                //

                if ( filterLongNames ) {
                    status = RtlUpcaseUnicodeStringToOemString(
                                 &oemString,
                                 &unicodeString,
                                 FALSE
                                 );

                } else {
                    status = RtlUnicodeStringToOemString(
                                 &oemString,
                                 &unicodeString,
                                 FALSE
                                 );

                }

                ASSERT( NT_SUCCESS(status) );

                ASSERT(oemString.Length <= 255);

                findBuffer->FileNameLength = (UCHAR)oemString.Length;
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileName.Buffer;
            lastFileName.Length = (USHORT)fileName.Length;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBoth->FileIndex;

        } else if ( InformationLevel == SMB_INFO_QUERY_EA_SIZE ) {

            PSMB_FIND_BUFFER2 findBuffer = (PSMB_FIND_BUFFER2)bufferLocation;
            ULONG fileNameLength;

            //
            // Find the new buffer location.  This is not used until the
            // next pass through the loop, but we do it here in order to
            // check if there is enough space for the current file entry in
            // the buffer.  The +1 is for the zero terminator on the file
            // name.
            //

            if ( isUnicode ) {
                bufferLocation =
                    (PCHAR)(findBuffer->FileName + fileFull->FileNameLength + 1);
            } else {
                unicodeString.Buffer = fileFull->FileName;
                unicodeString.Length = (USHORT)fileFull->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
                bufferLocation = (PCHAR)(findBuffer->FileName + fileNameLength);
            }

            //
            // Make sure that there is enough space in the buffer before
            // writing the filename.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Put information about the file into the SMB buffer.
            //

            ConvertFileInfo(
                fileBasic,
                fileFull->FileName,
                (BOOLEAN)((fileFull->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0),
                isUnicode,
                (PSMB_FIND_BUFFER)findBuffer
                );

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileFull->FileName,
                    fileFull->FileNameLength
                    );

                ASSERT(fileFull->FileNameLength <= 255);

                findBuffer->FileNameLength = (UCHAR)fileFull->FileNameLength;

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PCHAR)(findBuffer->FileName);
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );

                ASSERT(oemString.Length <= 255);

                findBuffer->FileNameLength = (UCHAR)oemString.Length;
            }

            if ( fileFull->EaSize == 0) {
                SmbPutUlong( &findBuffer->EaSize, 4 );
            } else {
                SmbPutUlong( &findBuffer->EaSize, fileFull->EaSize );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileFull->FileName;
            lastFileName.Length = (USHORT)fileFull->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileFull->FileIndex;

        } else if ( InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {

            PSMB_FIND_BUFFER2 findBuffer = (PSMB_FIND_BUFFER2)bufferLocation;
            PFEALIST feaList;
            PCHAR fileNameInfo;
            ULONG fileNameLength;

            //
            // Find the new buffer location.  This is not used until the
            // next pass through the loop, but we do it here in order to
            // check if there is enough space for the current file entry
            // in the buffer.  The +1 is for the zero terminator on the
            // file name.  A check is made later on to see if the EAs
            // actually fit, and the bufferLocation variable is reset to
            // account for the actual size of the EA.
            //

            if ( isUnicode ) {
                bufferLocation =
                    (PCHAR)(findBuffer->FileName + fileBasic->FileNameLength + 1);
            } else {
                unicodeString.Buffer = fileBasic->FileName;
                unicodeString.Length = (USHORT)fileBasic->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
                bufferLocation =
                    (PCHAR)(findBuffer->FileName + fileNameLength + 1);
            }

            //
            // Make sure that there is enough space in the buffer before
            // writing the filename.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 46, Search );
                SrvNtClose( fileHandle, TRUE );
                fileHandle = NULL;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Put information about the file into the SMB buffer.
            //

            ConvertFileInfo(
                fileBasic,
                fileBasic->FileName,
                (BOOLEAN)((fileBasic->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0),
                isUnicode,
                (PSMB_FIND_BUFFER)findBuffer
                );

            //
            // Get the EAs corresponding to the GEA list passed by the
            // client.
            //

            feaList = (PFEALIST)&findBuffer->EaSize;

            if ( ( fileHandle != NULL ) || createNullEas ) {

                if ( fileHandle != NULL ) {

                    //
                    // Get the file's EAs.  The buffer space available is
                    // the space remaining in the buffer less enough space
                    // to write the file name, name length, and zero
                    // terminator.
                    //

                    status = SrvQueryOs2FeaList(
                                 fileHandle,
                                 NULL,
                                 ntGetEa,
                                 ntGetEaLength,
                                 feaList,
                                 (Transaction->MaxDataCount -
                                     (ULONG)( (PCHAR)feaList - Transaction->OutData ) -
                                     fileBasic->FileNameLength - 2),
                                 &eaErrorOffset
                                 );

                    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 47, Search );
                    SrvNtClose( fileHandle, TRUE );

                } else {

                    //
                    // if file is . or .. or "EA DATA. SF"
                    //

                    status = SrvConstructNullOs2FeaList(
                                 ntGetEa,
                                 feaList,
                                 (Transaction->MaxDataCount -
                                  (ULONG)( (PCHAR)feaList - Transaction->OutData ) -
                                     fileBasic->FileNameLength - 2)
                                 );

                }

                if ( !NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW ) {

                    IF_DEBUG(ERRORS) {
                        SrvPrint1( "SrvQueryOs2FeaList failed, status = %X\n",
                                      status );
                    }

                    //
                    // If this is the first file, return it anyway with
                    // an error code.
                    //

                    if ( status == STATUS_INVALID_EA_NAME ) {
                        SmbPutUshort( &Response->SearchCount, 0 );
                        SmbPutUshort( &Response->EndOfSearch, 0 );
                        SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );
                        SmbPutUshort( &Response->LastNameOffset, 0 );
                        Transaction->DataCount = 0;
                        return status;
                    }

                    if ( count == 0 ) {
                        status = STATUS_OS2_EA_ACCESS_DENIED;
                        SmbPutUlong( &findBuffer->EaSize, 0 );
                    } else {
                        break;
                    }
                }

                //
                // We already checked to see if the information other
                // than EAs would fit in the buffer.  If the EAs didn't
                // fit as well, and this is the first file, then return
                // information on this file but no EAs.  Return
                // STATUS_OS2_EAS_DIDNT_FIT.  The EA size of the file
                // should be in the EaSize field of the output buffer,
                // put there by SrvQueryOs2FeaList.
                //
                // Also do this if we couldn't get at the file's EAs.
                //

                if ( count == 0 &&
                     ( status == STATUS_BUFFER_OVERFLOW ||
                       status == STATUS_OS2_EA_ACCESS_DENIED ) ) {

                    IF_DEBUG(ERRORS) {
                        SrvPrint0( "First file's EAs would not fit.\n" );
                    }

                    count = 1;

                    //
                    // Write the file name information (length and name).
                    //

                    if ( isUnicode ) {

                        RtlCopyMemory(
                            (PVOID) (&findBuffer->FileNameLength + 1),
                            fileBasic->FileName,
                            fileBasic->FileNameLength
                            );

                        findBuffer->FileNameLength = (UCHAR)fileBasic->FileNameLength;
                        bufferLocation = (PCHAR)
                            (findBuffer->FileName + fileBasic->FileNameLength + 1);

                    } else {

                        NTSTATUS rtlStatus;

                        oemString.MaximumLength = (USHORT)fileNameLength;
                        oemString.Buffer =
                                (PUCHAR)(&findBuffer->FileNameLength + 1);
                        rtlStatus = RtlUnicodeStringToOemString(
                                     &oemString,
                                     &unicodeString,
                                     FALSE
                                     );
                        ASSERT( NT_SUCCESS(rtlStatus) );

                        findBuffer->FileNameLength = (UCHAR)oemString.Length;
                        bufferLocation = (PCHAR)
                            (findBuffer->FileName + oemString.Length + 1);
                    }

                    lastEntry = (PCHAR)findBuffer;
                    lastFileName.Buffer = fileBasic->FileName;
                    lastFileName.Length = (USHORT)fileBasic->FileNameLength;
                    lastFileName.MaximumLength = lastFileName.Length;
                    lastFileIndex = fileBasic->FileIndex;

                    if ( status == STATUS_BUFFER_OVERFLOW ) {
                        status = STATUS_OS2_EAS_DIDNT_FIT;
                    }

                    break;
                }

            } else {

                SmbPutUlong( &feaList->cbList, sizeof(feaList->cbList) );

            }

            //
            // Make sure that there is enough buffer space to write the
            // file name and name size.  The +2 is to account for the
            // file name size field and the zero terminator.
            //

            fileNameInfo = (PCHAR)feaList->list +
                               SmbGetUlong( &feaList->cbList ) -
                               sizeof(feaList->cbList);
            if ( isUnicode ) {
                bufferLocation = fileNameInfo + fileBasic->FileNameLength + 2;
            } else {
                bufferLocation = fileNameInfo + fileNameLength + 1;
            }


            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Write the file name information (length and name).
            //

            if ( isUnicode ) {

                RtlCopyMemory(
                    fileNameInfo + 1,
                    fileBasic->FileName,
                    fileBasic->FileNameLength
                    );

            } else {

                NTSTATUS rtlStatus;

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = fileNameInfo + 1;
                rtlStatus = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(rtlStatus) );
            }

            *fileNameInfo++ = (UCHAR)oemString.Length;

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "EA size is %ld\n", SmbGetUlong( &feaList->cbList ) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBasic->FileName;
            lastFileName.Length = (USHORT)fileBasic->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBasic->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_DIRECTORY_INFO ) {

            FILE_DIRECTORY_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBasic->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBasic->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBasic->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                                 FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName ) +
                                 fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileBasic,
                FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBasic->FileName,
                    fileBasic->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBasic->FileName;
            lastFileName.Length = (USHORT)fileBasic->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBasic->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ) {

            FILE_FULL_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileFull->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileFull->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileFull->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET(FILE_FULL_DIR_INFORMATION, FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileFull,
                FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileFull->FileName,
                    fileFull->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileFull->FileName;
            lastFileName.Length = (USHORT)fileFull->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileFull->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ) {

            FILE_BOTH_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBoth->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBoth->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBoth->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileBoth,
                FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBoth->FileName,
                    fileBoth->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBoth->FileName;
            lastFileName.Length = (USHORT)fileBoth->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBoth->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_NAMES_INFO ) {

            PFILE_NAMES_INFORMATION findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBasic->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBasic->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBasic->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET(FILE_NAMES_INFORMATION,FileName) +
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            findBuffer->FileIndex = fileBasic->FileIndex;

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBasic->FileName,
                    fileBasic->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBasic->FileName;
            lastFileName.Length = (USHORT)fileBasic->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBasic->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO ) {

            FILE_ID_FULL_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileIdFull->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileIdFull->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileIdFull->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET(FILE_ID_FULL_DIR_INFORMATION, FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileIdFull,
                FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileIdFull->FileName,
                    fileIdFull->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileIdFull->FileName;
            lastFileName.Length = (USHORT)fileIdFull->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileIdFull->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ) {

            FILE_ID_BOTH_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileIdBoth->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileIdBoth->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileIdBoth->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileIdBoth,
                FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileIdBoth->FileName,
                    fileIdBoth->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileIdBoth->FileName;
            lastFileName.Length = (USHORT)fileIdBoth->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileIdBoth->FileIndex;
        }

        count++;

        if ( status == STATUS_OS2_EA_ACCESS_DENIED ) {
            break;
        }

    } while ( count < MaxCount );

    IF_SMB_DEBUG(SEARCH2) {

        SrvPrint0( "Stopped putting entries in buffer.  Reason:\n" );

        if ( !NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW ) {
            SrvPrint1( "    status = %X\n", status );
        } else if ( count >= MaxCount ) {
            SrvPrint2( "    count = %ld, maxCount = %ld\n", count, MaxCount );
        } else {
            SrvPrint3( "    buffer location = 0x%p, trans->OD = 0x%p, "
                      "trans->MaxOD = 0x%lx\n", bufferLocation,
                          Transaction->OutData, Transaction->MaxDataCount );
        }
    }

    //
    // Deallocate the pool used for the NT get EA list if this was the
    // right information level.
    //

    if ( InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {
        DEALLOCATE_NONPAGED_POOL( ntGetEa );
    }

    //
    // If we have not found any files and an error occurred, or the first
    // file file we found had EAs to large to fit in the buffer, then return
    // the error to the client.  If an error occurred and we have found
    // files, return what we have found.
    //

    if ( count == 0 && !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "Find2 processing error; status = %X\n", status );
        }

        SrvSetSmbError( WorkContext, status );
        return status;

    } else if ( count == 1 &&
                ( status == STATUS_OS2_EAS_DIDNT_FIT ||
                  status == STATUS_OS2_EA_ACCESS_DENIED ) ) {

        PVOID temp;

        temp = WorkContext->ResponseParameters;
        SrvSetSmbError( WorkContext, status );
        WorkContext->ResponseParameters = temp;

        status = STATUS_SUCCESS;

    } else if ( !NT_SUCCESS(status) && status != STATUS_NO_MORE_FILES ) {

        status = STATUS_SUCCESS;
    }

    //
    // If this is a level for the SMB 4.0 protocol (NT), set the
    // NextEntryOffset field of the last entry to zero.
    //

    if ( InformationLevel == SMB_FIND_FILE_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_NAMES_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ) {
    
        ((PFILE_DIRECTORY_INFORMATION)lastEntry)->NextEntryOffset = 0;
    }

    //
    // At the end of the loop, bufferLocation points to the first location
    // AFTER the last entry we wrote, so it may be used to find the total
    // number of data bytes that we intend to return.
    //

    totalBytesWritten = PTR_DIFF(bufferLocation, Transaction->OutData);

    //
    // Free the buffer that holds the last file name if it was in use,
    // then allocate a new one and store the name and index of the last
    // file returned in the search block so that it can resume the search
    // if the client requests.
    //

    if ( Search->LastFileNameReturned.Buffer != NULL ) {
        FREE_HEAP( Search->LastFileNameReturned.Buffer );
    }

    Search->LastFileNameReturned.Buffer =
        ALLOCATE_HEAP_COLD(
            lastFileName.Length,
            BlockTypeDataBuffer
            );

    if ( Search->LastFileNameReturned.Buffer == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFind2Loop: unable to allocate %d bytes from heap.",
            lastFileName.Length,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    Search->LastFileNameReturned.Length = lastFileName.Length;
    Search->LastFileNameReturned.MaximumLength = lastFileName.Length;

    RtlCopyMemory(
        Search->LastFileNameReturned.Buffer,
        lastFileName.Buffer,
        lastFileName.Length
        );

    Search->LastFileIndexReturned = lastFileIndex;

    //
    // Put data in the response SMB.
    //

    SmbPutUshort( &Response->SearchCount, count );
    SmbPutUshort(
        &Response->EndOfSearch,
        (USHORT)(status == STATUS_NO_MORE_FILES)
        );
    SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );
    SmbPutUshort(
        &Response->LastNameOffset,
        (USHORT)(lastEntry - Transaction->OutData)
        );
    Transaction->DataCount = totalBytesWritten;

    return status;

} // SrvFind2Loop


VOID
ConvertFileInfo (
    IN PFILE_DIRECTORY_INFORMATION File,
    IN PWCH FileName,
    IN BOOLEAN Directory,
    IN BOOLEAN ClientIsUnicode,
    OUT PSMB_FIND_BUFFER FindBuffer
    )

/*++

Routine Description:

    This routine does the looping necessary to get files and put them
    into an SMB buffer for the Find First2 and Find Next2 transaction
    protocols.

Arguments:

    File - a pointer to the structure containing the information about
        the file.

    FileName - name of the file.

    Directory - a boolean indicating whether it is a file or directory.
        The existence of this field allows File to point to a
        FILE_FULL_DIR_INFORMATION structure if necessary.

    FileBuffer - where to write the results in OS/2 format.

Return Value:

    None

--*/

{
    SMB_DATE smbDate;
    SMB_TIME smbTime;
    USHORT smbFileAttributes;
    UNICODE_STRING unicodeString;

    PAGED_CODE( );

    //
    // Convert the various times from NT format to SMB format.
    //

    SrvTimeToDosTime( &File->CreationTime, &smbDate, &smbTime );
    SmbPutDate( &FindBuffer->CreationDate, smbDate );
    SmbPutTime( &FindBuffer->CreationTime, smbTime );

    SrvTimeToDosTime( &File->LastAccessTime, &smbDate, &smbTime );
    SmbPutDate( &FindBuffer->LastAccessDate, smbDate );
    SmbPutTime( &FindBuffer->LastAccessTime, smbTime );

    SrvTimeToDosTime( &File->LastWriteTime, &smbDate, &smbTime );
    SmbPutDate( &FindBuffer->LastWriteDate, smbDate );
    SmbPutTime( &FindBuffer->LastWriteTime, smbTime );

    //
    // SMB protocol only allows 32-bit file sizes.  Only return the low
    // 32 bits, and too bad if the file is larger.
    //

    SmbPutUlong( &FindBuffer->DataSize, File->EndOfFile.LowPart );
    SmbPutUlong(
        &FindBuffer->AllocationSize,
        File->AllocationSize.LowPart
        );

    SRV_NT_ATTRIBUTES_TO_SMB(
        File->FileAttributes,
        Directory,
        &smbFileAttributes
        );

    SmbPutUshort( &FindBuffer->Attributes, smbFileAttributes );

    if ( ClientIsUnicode ) {
        FindBuffer->FileNameLength = (UCHAR)(File->FileNameLength);
    } else {
        unicodeString.Buffer = FileName;
        unicodeString.Length = (USHORT)File->FileNameLength;
        unicodeString.MaximumLength = unicodeString.Length;
        FindBuffer->FileNameLength =
            (UCHAR)RtlUnicodeStringToOemSize( &unicodeString );
    }

    return;

} // ConvertFileInfo


SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindClose2 (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Find Close2 SMB.  This SMB is used to
    close a search started by a Find First2 transaction.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PSEARCH search;
    PSESSION session;
    SRV_DIRECTORY_INFORMATION directoryInformation;
    USHORT sid;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PREQ_FIND_CLOSE2 request;
    PRESP_FIND_CLOSE2 response;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_CLOSE2;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint2( "Find Close2 request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Find Close2 request params at 0x%p, response params%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_FIND_CLOSE2)WorkContext->RequestParameters;
    response = (PRESP_FIND_CLOSE2)WorkContext->ResponseParameters;


    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbSearch: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
    }

    //
    // Get the search block corresponding to this SID.  SrvVerifySid
    // references the search block.
    //

    sid = SmbGetUshort( &request->Sid );

    search = SrvVerifySid(
                 WorkContext,
                 SID_INDEX2( sid ),
                 SID_SEQUENCE2( sid ),
                 &directoryInformation,
                 sizeof(SRV_DIRECTORY_INFORMATION)
                 );

    if ( search == NULL ) {

        IF_DEBUG(SMB_ERRORS) SrvPrint0( "SrvSmbFindClose2: Invalid SID.\n" );

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        status    = STATUS_INVALID_HANDLE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Close the query directory and the search, then dereference our
    // pointer to the search block.
    //

    search->DirectoryHandle = NULL;
    SrvCloseSearch( search );
    SrvCloseQueryDirectory( &directoryInformation );
    SrvDereferenceSearch( search );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_FIND_CLOSE2,
                                          0
                                          );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbFindClose2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smblock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smblock.c

Abstract:

    This module contains routines for processing the following SMBs:

        Lock Byte Range
        Unlock Byte Range
        Locking and X

    The SMB commands "Lock and Read" and "Write and Unlock" are
    processed in smbrdwrt.c.

Author:

    Chuck Lenzmeier (chuckl) 26-Apr-1990

Revision History:

    29-Aug-1991 mannyw


--*/

#include "precomp.h"
#include "smblock.tmh"
#pragma hdrstop

#if SRVDBG_PERF
UCHAR LockBypass = 0;
BOOLEAN LockWaitForever = 0;
ULONG LockBypassConst = 0x10000000;
ULONG LockBypassMirror = 0x01000000;
#endif

//
// Forward declarations
//

BOOLEAN
CancelLockRequest (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT TargetFid,
    IN USHORT TargetPid,
    IN LARGE_INTEGER TargetOffset,
    IN LARGE_INTEGER TargetLength
    );

VOID
DoLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN SkipFastPath
    );

STATIC
BOOLEAN
ProcessOplockBreakResponse(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb,
    IN PREQ_LOCKING_ANDX Request
    );

STATIC
VOID SRVFASTCALL
RestartLockByteRange (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
TimeoutLockRequest (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbLockByteRange )
#pragma alloc_text( PAGE, RestartLockByteRange )
#pragma alloc_text( PAGE, ProcessOplockBreakResponse )
#pragma alloc_text( PAGE, SrvSmbUnlockByteRange )
#pragma alloc_text( PAGE, SrvSmbLockingAndX )
#pragma alloc_text( PAGE, DoLockingAndX )
#pragma alloc_text( PAGE, RestartLockingAndX )
#pragma alloc_text( PAGE, SrvAcknowledgeOplockBreak )
#pragma alloc_text( PAGE8FIL, CancelLockRequest )
#pragma alloc_text( PAGE8FIL, TimeoutLockRequest )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockByteRange (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Lock Byte Range SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_LOCK_BYTE_RANGE request;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN failImmediately;

    PRFCB rfcb;
    PLFCB lfcb;
    PSRV_TIMER timer;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_BYTE_RANGE;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_LOCK_BYTE_RANGE)WorkContext->RequestParameters;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    fid = SmbGetUshort( &request->Fid );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbLockByteRange: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // If the session has expired, return that info
    //
    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has lock access to the file via the
    // specified handle.
    //

    if ( rfcb->LockAccessGranted ) {

        //
        // Get the offset and length of the range being locked.  Combine
        // the FID with the caller's PID to form the local lock key.
        //
        // *** The FID must be included in the key in order to account
        //     for the folding of multiple remote compatibility mode
        //     opens into a single local open.
        //

        offset.QuadPart = SmbGetUlong( &request->Offset );
        length.QuadPart = SmbGetUlong( &request->Count );

        key = rfcb->ShiftedFid |
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

        IF_SMB_DEBUG(LOCK1) {
            KdPrint(( "Lock request; FID 0x%lx, count %ld, offset %ld\n",
                        fid, length.LowPart, offset.LowPart ));
        }

        rfcb = WorkContext->Rfcb;
        lfcb = rfcb->Lfcb;

#ifdef SLMDBG
        {
            PRFCB_TRACE entry;
            KIRQL oldIrql;
            ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
            rfcb->OperationCount++;
            entry = &rfcb->Trace[rfcb->NextTrace];
            if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
                rfcb->NextTrace = 0;
                rfcb->TraceWrapped = TRUE;
            }
            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
            entry->Command = WorkContext->NextCommand;
            KeQuerySystemTime( &entry->Time );
            entry->Data.LockUnlock.Offset = offset.LowPart;
            entry->Data.LockUnlock.Length = length.LowPart;
        }
#endif

        IF_SMB_DEBUG(LOCK2) {
            KdPrint(( "SrvSmbLockByteRange: Locking in file 0x%p: (%ld,%ld), key 0x%lx\n",
                        lfcb->FileObject, offset.LowPart, length.LowPart, key ));
        }

#ifdef INCLUDE_SMB_PERSISTENT
        WorkContext->Parameters.Lock.Offset.QuadPart = offset.QuadPart;
        WorkContext->Parameters.Lock.Length.QuadPart = length.QuadPart;
        WorkContext->Parameters.Lock.Exclusive = TRUE;
#endif

        //
        // Try the turbo lock path first.  If the client is retrying the
        // lock that just failed, or if the lock is above the
        // always-wait limit we want FailImmediately to be FALSE, so
        // that the fast path fails if there's a conflict.
        //

        failImmediately = (BOOLEAN)(
            (offset.QuadPart != rfcb->PagedRfcb->LastFailingLockOffset.QuadPart)
            &&
            (offset.QuadPart < SrvLockViolationOffset) );

        if ( lfcb->FastIoLock != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );

            if ( lfcb->FastIoLock(
                    lfcb->FileObject,
                    &offset,
                    &length,
                    IoGetCurrentProcess(),
                    key,
                    failImmediately,
                    TRUE,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The turbo path worked.  Call the restart routine
                // directly.
                //

                WorkContext->Parameters.Lock.Timer = NULL;
                RestartLockByteRange( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );

        }

        //
        // The turbo path failed (or didn't exist).  Start the lock request,
        // reusing the receive IRP.  If the client is retrying the lock that
        // just failed, start a timer for the request.
        //

        timer = NULL;
        if ( !failImmediately ) {
            timer = SrvAllocateTimer( );
            if ( timer == NULL ) {
                failImmediately = TRUE;
            }
        }

        SrvBuildLockRequest(
            WorkContext->Irp,                   // input IRP address
            lfcb->FileObject,                   // target file object address
            WorkContext,                        // context
            offset,                             // byte offset
            length,                             // range length
            key,                                // lock key
            failImmediately,
            TRUE                                // exclusive lock?
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartLockByteRange;

        //
        // Start the timer, if necessary.
        //

        WorkContext->Parameters.Lock.Timer = timer;
        if ( timer != NULL ) {
            SrvSetTimer(
                timer,
                &SrvLockViolationDelayRelative,
                TimeoutLockRequest,
                WorkContext
                );
        }

        //
        // Pass the request to the file system.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The lock request has been started.
        //

        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockByteRange complete\n" ));
        SmbStatus = SmbStatusInProgress;
    } else {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbLockByteRange: Lock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbLockByteRange


SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockingAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Locking and X SMB.  This SMB is used to unlock zero
    or more ranges, then lock zero or more ranges.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_LOCKING_ANDX request;
    PRESP_LOCKING_ANDX response;

    PNTLOCKING_ANDX_RANGE largeRange;
    PLOCKING_ANDX_RANGE smallRange;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    USHORT pid;
    ULONG unlockCount;
    ULONG lockCount;
    ULONG maxPossible;

    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    ULONG lockTimeout;
    BOOLEAN oplockBreakResponse = FALSE;
    BOOLEAN largeFileLock;
#ifdef INCLUDE_SMB_PERSISTENT
    BOOLEAN flushPersistentLocks = FALSE;
#endif

    UCHAR nextCommand;
    USHORT reqAndXOffset;

    PRFCB rfcb;
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;

    PREQ_CLOSE closeRequest;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCKING_AND_X;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;
    response = (PRESP_LOCKING_ANDX)WorkContext->ResponseParameters;

    //
    // Get the FID, which is combined with the PIDs in the various
    // lock/unlock ranges to form the local lock key.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(LOCK1) {
        unlockCount = SmbGetUshort( &request->NumberOfUnlocks );
        lockCount = SmbGetUshort( &request->NumberOfLocks );
        KdPrint(( "Locking and X request; FID 0x%lx, Unlocks: %ld, "
                    "Locks: %ld\n", fid, unlockCount, lockCount ));
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbLockingAndX: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    pagedRfcb = rfcb->PagedRfcb;
    lfcb = rfcb->Lfcb;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

start_lockingAndX:

    //
    // Loop through the unlock ranges.
    //

    largeFileLock =
            (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

    //
    // Ensure the SMB is big enough to hold all of the requests
    //

    unlockCount = SmbGetUshort( &request->NumberOfUnlocks );
    lockCount = SmbGetUshort( &request->NumberOfLocks );

    //
    // Find out how many entries could possibly be in this smb
    //
    maxPossible = (ULONG)(((PCHAR)WorkContext->RequestBuffer->Buffer +
                           WorkContext->RequestBuffer->DataLength) -
                           (PCHAR)request->Buffer);

    if( largeFileLock ) {
        maxPossible /= sizeof( NTLOCKING_ANDX_RANGE );
        largeRange = (PNTLOCKING_ANDX_RANGE)request->Buffer;
    } else {
        maxPossible /= sizeof( LOCKING_ANDX_RANGE );
        smallRange = (PLOCKING_ANDX_RANGE)request->Buffer;
    }

    //
    // If the request holds more than could possibly be in this SMB, return
    //  and error
    //
    if( unlockCount + lockCount > maxPossible ) {
        //
        // They don't all fit!
        //

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvSmbLockingAndX: unlockCount %u, lockCount %u, maxPossible %u\n",
                        unlockCount, lockCount, maxPossible ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If an Unlock is being requested, verify that the client has
    // unlock access to the file via the specified handle.
    //

    if ( unlockCount != 0 ) {
        if  ( rfcb->UnlockAccessGranted ) {

            IO_STATUS_BLOCK iosb;

            do {

                //
                // Form the key for this lock.  Get the offset and length of the
                // range.
                //

                ParseLockData(
                    largeFileLock,
                    smallRange,
                    largeRange,
                    &pid,
                    &offset,
                    &length
                    );

                key = rfcb->ShiftedFid | pid;

                IF_SMB_DEBUG(LOCK2) {
                    KdPrint(( "SrvSmbLockingAndX: Unlocking in file 0x%p: ",
                                lfcb->FileObject ));
                    KdPrint(( "(%lx%08lx, %lx%08lx), ",
                                offset.HighPart, offset.LowPart,
                                length.HighPart, length.LowPart ));
                    KdPrint(( "key 0x%lx\n", key ));
                }

#ifdef SLMDBG
                {
                    PRFCB_TRACE entry;
                    KIRQL oldIrql;

                    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
                    rfcb->OperationCount++;
                    entry = &rfcb->Trace[rfcb->NextTrace];
                    if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
                        rfcb->NextTrace = 0;
                        rfcb->TraceWrapped = TRUE;
                    }
                    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
                    entry->Command = WorkContext->NextCommand;
                    entry->Flags = 1;
                    KeQuerySystemTime( &entry->Time );
                    entry->Data.LockUnlock.Offset = offset.LowPart;
                    entry->Data.LockUnlock.Length = length.LowPart;
                }
#endif

                //
                // Issue the Unlock request.
                //
                // *** Note that we do the Unlock synchronously.  Unlock is a
                //     quick operation, so there's no point in doing it
                //     asynchronously.  In order to do this, we have to let
                //     normal I/O completion happen (so the event is set), which
                //     means that we have to allocate a new IRP (I/O completion
                //     likes to deallocate an IRP).  This is a little wasteful,
                //     since we've got a perfectly good IRP hanging around.
                //     However, we do try to use the turbo path first, so in
                //     most cases we won't actually issue an I/O request.
                //

                //
                // Try the turbo unlock path first.
                //

#if SRVDBG_PERF
                iosb.Status = STATUS_SUCCESS;
                if ( (LockBypass == 3) ||
                     ((LockBypass == 2) && (offset.LowPart >= LockBypassMirror)) ||
                     ((LockBypass == 1) && (offset.LowPart >= LockBypassConst)) ||
#else
                if (
#endif
                     ((lfcb->FastIoUnlockSingle != NULL) &&
                      lfcb->FastIoUnlockSingle(
                                        lfcb->FileObject,
                                        &offset,
                                        &length,
                                        IoGetCurrentProcess(),
                                        key,
                                        &iosb,
                                        lfcb->DeviceObject
                                        )) ) {

                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
                    status = iosb.Status;

                } else {

                    if ( lfcb->FastIoUnlockSingle != NULL ) {

                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksFailed );
                    }

                    status = SrvIssueUnlockSingleRequest(
                            lfcb->FileObject,               // target file object
                            &lfcb->DeviceObject,            // target device object
                            offset,                         // byte offset
                            length,                         // range length
                            key                             // lock key
                            );
                }

                //
                // If the unlock request failed, set an error status in the
                // response header and jump out.
                //

                if ( !NT_SUCCESS(status) ) {

                    IF_DEBUG(SMB_ERRORS) {
                        KdPrint(( "SrvSmbLockingAndX: Unlock failed: %X\n", status ));
                    }
                    SrvSetSmbError( WorkContext, status );

                    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockingAndX complete\n" ));
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                //
                // Update the count of locks on the RFCB.
                //

                InterlockedDecrement( &rfcb->NumberOfLocks );

                //
                // Update both range pointers, only one is meaningful - the
                // other pointer is never referenced.
                //

                ++smallRange;
                ++largeRange;

            } while ( --unlockCount > 0 );

        } else {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbLockByteRange: Unlock access not granted.\n"));
            }
            SrvStatistics.GrantedAccessErrors++;
            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            status    = STATUS_ACCESS_DENIED;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // We've now unlocked all of the specified ranges.  We did the
    // unlocks synchronously, but we're not willing to do that with the
    // lock requests, which can take an indefinite amount of time.
    // Instead, we start the first lock request here and allow the
    // restart routine to handle the remaining lock ranges.
    //

    if ( lockCount != 0 ) {

        if ( rfcb->LockAccessGranted ) {

            if ( !(request->LockType & LOCKING_ANDX_CANCEL_LOCK ) &&
                 !(request->LockType & LOCKING_ANDX_CHANGE_LOCKTYPE) ) {

                BOOLEAN failImmediately;

                //
                // Get the lock timeout.  We will change this later if
                // it's 0 but we want to wait anyway.
                //

                lockTimeout = SmbGetUlong( &request->Timeout );

                //
                // Indicate that no timer has been associated with this
                // request.
                //

                WorkContext->Parameters.Lock.Timer = NULL;

                //
                // There is at least one lock request.  Set up context
                // information.  We use the NumberOfUnlocks field of the
                // request to count how many of the lock requests we've
                // performed.  This field also tells us how many unlocks
                // we have to do if one of the lock attempts fails.  We
                // use the LockRange field of WorkContext->Parameters to
                // point to the current lock range in the request.
                //
                // Short circuit if only one lock request.
                //

                if ( lockCount == 1 ) {

                    BOOLEAN exclusiveLock;

                    //
                    // Does the client want an exclusive lock or a shared lock?
                    //

                    exclusiveLock = (BOOLEAN)( (request->LockType &
                                                LOCKING_ANDX_SHARED_LOCK) == 0 );

                    //
                    // Form the key for the lock.  Get the offset and length
                    // of the range.
                    //

                    ParseLockData(
                        largeFileLock,
                        smallRange,
                        largeRange,
                        &pid,
                        &offset,
                        &length
                        );

                    key = rfcb->ShiftedFid | pid;

                    IF_SMB_DEBUG(LOCK2) {
                        KdPrint(( "SrvSmbLockingAndX: Locking in file 0x%p: ",
                                    lfcb->FileObject ));
                        KdPrint(( "(%lx%08lx, %lx%08lx), ",
                                    offset.HighPart, offset.LowPart,
                                    length.HighPart, length.LowPart ));
                        KdPrint(( "key 0x%lx\n", key ));
                    }

#ifdef SLMDBG
                    {
                        PRFCB_TRACE entry;
                        KIRQL oldIrql;
                        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
                        rfcb->OperationCount++;
                        entry = &rfcb->Trace[rfcb->NextTrace];
                        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
                            rfcb->NextTrace = 0;
                            rfcb->TraceWrapped = TRUE;
                        }
                        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
                        entry->Command = WorkContext->NextCommand;
                        entry->Flags = 0;
                        KeQuerySystemTime( &entry->Time );
                        entry->Data.LockUnlock.Offset = offset.LowPart;
                        entry->Data.LockUnlock.Length = length.LowPart;
                    }
#endif
#ifdef INCLUDE_SMB_PERSISTENT
                    WorkContext->Parameters.Lock.Offset.QuadPart = offset.QuadPart;
                    WorkContext->Parameters.Lock.Length.QuadPart = length.QuadPart;
                    WorkContext->Parameters.Lock.Exclusive = exclusiveLock;
#endif

                    //
                    // Try the turbo lock path first.  Set FailImmediately
                    // based on whether we plan to wait for the lock to
                    // become available.  If the client wants to wait,
                    // or if the client doesn't want to wait but a)
                    // previously tried to get this lock and failed or
                    // b) this lock is above our lock delay limit (in
                    // which cases WE want to wait), then we set
                    // FailImmedately to FALSE.  This will cause the
                    // fast path to fail if the range is not available,
                    // and we will build an IRP to try again.
                    //

                    failImmediately = ((lockTimeout == 0) &&
                        (offset.QuadPart != pagedRfcb->LastFailingLockOffset.QuadPart) &&
                        (offset.QuadPart < SrvLockViolationOffset) );
#if SRVDBG_PERF
                    if ( LockWaitForever ) failImmediately = FALSE;
#endif

#if SRVDBG_PERF
                    WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
                    if ( (LockBypass == 3) ||
                         ((LockBypass == 2) && (offset.LowPart >= LockBypassMirror)) ||
                         ((LockBypass == 1) && (offset.LowPart >= LockBypassConst)) ||
#else
                    if (
#endif
                         ((lfcb->FastIoLock != NULL) &&
                          lfcb->FastIoLock(
                                    lfcb->FileObject,
                                    &offset,
                                    &length,
                                    IoGetCurrentProcess(),
                                    key,
                                    failImmediately,
                                    exclusiveLock,
                                    &WorkContext->Irp->IoStatus,
                                    lfcb->DeviceObject
                                    )) ) {

                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );

                        if ( NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

                            //
                            // The lock request succeeded.  Update the count
                            // of locks on the RFCB.
                            //

                            InterlockedIncrement( &rfcb->NumberOfLocks );

#ifdef INCLUDE_SMB_PERSISTENT
                            if (rfcb->PersistentHandle) {

                                //
                                //  setup to record this lock in the state file
                                //  but don't actually put them to the state
                                //  file until we're done with all of them.
                                //

                                flushPersistentLocks = TRUE;

//                              SrvPersistFileLock( WorkContext, rfcb );

                            }
#endif
                            goto try_next_andx;

                        } else {

                            //
                            // The lock request failed.
                            //

                            SmbPutUshort( &request->NumberOfUnlocks, 0 );
                            WorkContext->Parameters.Lock.LockRange =
                                largeFileLock ? (PVOID)largeRange :
                                                (PVOID)smallRange;
                            RestartLockingAndX( WorkContext );
                            SmbStatus = SmbStatusInProgress;
                            goto Cleanup;
                        }
                    }

                    //
                    // The turbo path failed, or didn't exist.
                    //

                    if ( lfcb->FastIoLock != NULL ) {
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );
                    }

                }

                //
                // Either there is more than one lock request in the SMB,
                // or the fast path failed (which means that we want to
                // try again, with a timeout).
                //

                SmbPutUshort( &request->NumberOfUnlocks, 0 );
                WorkContext->Parameters.Lock.LockRange =
                        largeFileLock ? (PVOID)largeRange : (PVOID)smallRange;

                DoLockingAndX(
                    WorkContext,
                    (BOOLEAN)(lockCount == 1) // skip fast path?
                    );

                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            } else if ( request->LockType & LOCKING_ANDX_CANCEL_LOCK ) {

                //
                // This is a Cancel request.  Try to cancel the first lock
                // range.  We ignore any subsequent ranges that may be
                // present.
                //
                // !!! Is this right?
                //
                // Get the pid, offset, and length of the lock request
                //

                ParseLockData(
                    largeFileLock,
                    smallRange,
                    largeRange,
                    &pid,
                    &offset,
                    &length
                    );

                WorkContext->Parameters.Lock.LockRange = largeFileLock ? (PVOID)largeRange : (PVOID)smallRange;

                IF_SMB_DEBUG(LOCK2) {
                    KdPrint(( "SrvSmbLockingAndX: Locking in file 0x%p: ",
                                lfcb->FileObject ));
                    KdPrint(( "(%lx%08lx, %lx%08lx), ",
                                offset.HighPart, offset.LowPart,
                                length.HighPart, length.LowPart ));
                }

                if ( CancelLockRequest( WorkContext, fid, pid, offset, length ) ) {
                    SrvSetSmbError( WorkContext, STATUS_SUCCESS );
                    status = STATUS_SUCCESS;
                } else {
                    SrvSetSmbError( WorkContext, STATUS_OS2_CANCEL_VIOLATION );
                    status = STATUS_OS2_CANCEL_VIOLATION;
                }

                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            } else if ( request->LockType & LOCKING_ANDX_CHANGE_LOCKTYPE ) {

                //
                // This is a request from a Cruiser client for us to atomically
                // change a lock type from exclusive to shared or vice versa.
                // Since we cannot do this atomically, and would risk losing
                // the lock entirely if we tried this as a two step operation,
                // reject the request.
                //

                SrvSetSmbError( WorkContext, STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED );

                status    = STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

        } else {

            //
            // We can't do locks.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbLockByteRange: Lock access not granted.\n"));
            }
            SrvStatistics.GrantedAccessErrors++;
            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            status    = STATUS_ACCESS_DENIED;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

try_next_andx:

    //
    // Check for the Oplock Release flag.
    //

    nextCommand = request->AndXCommand;
    if ( (request->LockType & LOCKING_ANDX_OPLOCK_RELEASE) != 0 ) {

        oplockBreakResponse = ProcessOplockBreakResponse(
                                                WorkContext,
                                                rfcb,
                                                request
                                                );

        //
        // We have (synchronously) completed processing this SMB.  If this
        // was an oplock break response, with no lock request, and no And X
        // command, do not send a reply.
        //

        if( lockCount == 0 && nextCommand == SMB_COM_NO_ANDX_COMMAND ) {
            if( oplockBreakResponse || unlockCount == 0 ) {
                SmbStatus = SmbStatusNoResponse;
                goto Cleanup;
            }
        }
    }

    //
    //
    // Set up the response, then check for an AndX command.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;
    SmbPutUshort(
        &response->AndXOffset,
        GET_ANDX_OFFSET(
            WorkContext->ResponseHeader,
            WorkContext->ResponseParameters,
            RESP_LOCKING_ANDX,
            0
            )
        );

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    if ( nextCommand == SMB_COM_NO_ANDX_COMMAND ) {

        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockingAndX complete.\n" ));
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Make sure the AndX command is still within the received SMB
    //
    if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset >= END_OF_REQUEST_SMB( WorkContext ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbLockingAndX: Illegal followon offset: %u\n", reqAndXOffset ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if ( nextCommand == SMB_COM_LOCKING_ANDX ) {

        UCHAR wordCount;
        PSMB_USHORT byteCount;
        ULONG availableSpaceForSmb;

        WorkContext->NextCommand = nextCommand;


        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        //
        // Validate the next locking and x chain
        //

        //
        // Get the WordCount and ByteCount values to make sure that there
        // was enough information sent to satisfy the specifications.
        //

        wordCount = *((PUCHAR)WorkContext->RequestParameters);
        byteCount = (PSMB_USHORT)( (PCHAR)WorkContext->RequestParameters +
                    sizeof(UCHAR) + (8 * sizeof(USHORT)) );
        availableSpaceForSmb = (ULONG)(WorkContext->RequestBuffer->DataLength -
                                       ( (PCHAR)WorkContext->ResponseParameters -
                                         (PCHAR)WorkContext->RequestBuffer->Buffer ));


        if ( (wordCount == 8)
            &&
             ((PCHAR)byteCount <= (PCHAR)WorkContext->RequestBuffer->Buffer +
                                WorkContext->RequestBuffer->DataLength -
                                sizeof(USHORT))
            &&
             (8*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                SmbGetUshort( byteCount ) <= availableSpaceForSmb) ) {

            //
            // Update the request/response pointers
            //

            request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;
            response = (PRESP_LOCKING_ANDX)WorkContext->ResponseParameters;
            goto start_lockingAndX;

        } else {

            //
            // Let the regular check fail this.
            //

            SmbStatus = SmbStatusMoreCommands;
            goto Cleanup;
        }
    }

    switch ( nextCommand ) {

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_FLUSH:

        break;

    case SMB_COM_CLOSE:

        //
        // Call SrvRestartChainedClose to get the file time set and the
        // file closed.
        //

        closeRequest = (PREQ_CLOSE)((PUCHAR)WorkContext->RequestHeader + reqAndXOffset);

        //
        // Make sure we stay within the SMB buffer
        //
        if( (PCHAR)closeRequest + FIELD_OFFSET(REQ_CLOSE,ByteCount) <=
            END_OF_REQUEST_SMB( WorkContext ) ) {

            WorkContext->Parameters.LastWriteTime = closeRequest->LastWriteTimeInSeconds;

            SrvRestartChainedClose( WorkContext );

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        /* Falls Through! */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbLockingAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    WorkContext->NextCommand = nextCommand;
    WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                        reqAndXOffset;

    SmbStatus = SmbStatusMoreCommands;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbLockingAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbUnlockByteRange (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Unlock SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_UNLOCK_BYTE_RANGE request;
    PRESP_UNLOCK_BYTE_RANGE response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;

    PRFCB rfcb;
    PLFCB lfcb;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_UNLOCK_BYTE_RANGE;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_UNLOCK_BYTE_RANGE)WorkContext->RequestParameters;
    response = (PRESP_UNLOCK_BYTE_RANGE)WorkContext->ResponseParameters;

    //
    // Get the offset and length of the range being locked.  Combine the
    // FID with the caller's PID to form the local lock key.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );
    length.QuadPart = SmbGetUlong( &request->Count );
    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(LOCK1) {
        KdPrint(( "Unlock request; FID 0x%lx, count %ld, offset %ld\n",
                    fid, length.LowPart, offset.LowPart ));
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbUnlockByteRange: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;

    //
    // Verify that the client has unlock access to the file via the
    // specified handle.
    //

    if ( !rfcb->UnlockAccessGranted) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbLockByteRange: Unlock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        KIRQL oldIrql;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        KeQuerySystemTime( &entry->Time );
        entry->Data.LockUnlock.Offset = offset.LowPart;
        entry->Data.LockUnlock.Length = length.LowPart;
    }
#endif

    //
    // Issue the Unlock request.
    //
    // *** Note that we do the Unlock synchronously.  Unlock is a quick
    //     operation, so there's no point in doing it asynchronously.
    //     In order to do this, we have to let normal I/O completion
    //     happen (so the event is set), which means that we have to
    //     allocate a new IRP (I/O completion likes to deallocate an
    //     IRP).  This is a little wasteful, since we've got a perfectly
    //     good IRP hanging around.  However, we do try to use the turbo
    //     path first, so in most cases we won't actually issue an I/O
    //     request.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    IF_SMB_DEBUG(LOCK2) {
        KdPrint(( "SrvSmbUnlockByteRange: Unlocking in file 0x%p: ",
                   lfcb->FileObject ));
        KdPrint(( "(%lx%08lx,%lx%08lx), ",
                   offset.HighPart, offset.LowPart,
                   length.HighPart, length.LowPart ));
        KdPrint(( "key 0x%lx\n", key ));
    }

    status = SrvIssueUnlockRequest(
                lfcb->FileObject,               // target file object
                &lfcb->DeviceObject,            // target device object
                IRP_MN_UNLOCK_SINGLE,           // unlock operation
                offset,                         // byte offset
                length,                         // range length
                key                             // lock key
                );

    //
    // If the unlock request failed, set an error status in the response
    // header; otherwise, build a normal response message.
    //

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbUnlockByteRange: Unlock failed: %X\n", status ));
        }
        SrvSetSmbError( WorkContext, status );

    } else {

        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        InterlockedDecrement( &rfcb->NumberOfLocks );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_UNLOCK_BYTE_RANGE,
                                            0
                                            );

    }

    //
    // Processing of the SMB is complete.
    //
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbUnlockByteRange complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbUnlockByteRange


BOOLEAN
CancelLockRequest (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT TargetFid,
    IN USHORT TargetPid,
    IN LARGE_INTEGER TargetOffset,
    IN LARGE_INTEGER TargetLength
    )

/*++

Routine Description:

    This function searches for a lock request in progress.  If the request
    is found, the request IRP is cancelled.

Arguments:

    WorkContext - A pointer to the work information for this request.

    TargetFid - The server supplied FID of the file for the original lock
        request

    TargetPid - The server supplied PID of the file for the original lock
        request

    TargetOffset - The offset in the file of the original lock request

    TargetLength - The length of the byte range of the original lock request

Return Value:

    TRUE - The lock request was cancelled.
    FALSE - The lock request could not be cancelled.

--*/

{
    BOOLEAN match;
    USHORT targetTid, targetUid;
    PWORK_CONTEXT workContext;
    PCONNECTION connection;
    PSMB_HEADER header;
    PREQ_LOCKING_ANDX request;
    BOOLEAN success;

    PNTLOCKING_ANDX_RANGE largeRange;
    PLOCKING_ANDX_RANGE smallRange;
    BOOLEAN largeFileLock;
    USHORT pid;
    LARGE_INTEGER offset;
    LARGE_INTEGER length;

    KIRQL oldIrql;

    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;

    UNLOCKABLE_CODE( 8FIL );

    match = FALSE;
    targetTid = WorkContext->RequestHeader->Tid;
    targetUid = WorkContext->RequestHeader->Uid;

    connection = WorkContext->Connection;

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    //
    // Scan the list of SMBs in progress looking for a locking and X SMB
    // that exactly matches the one we are trying to cancel.
    //

    listHead = &WorkContext->Connection->InProgressWorkItemList;
    listEntry = listHead;
    while ( listEntry->Flink != listHead ) {

        listEntry = listEntry->Flink;

        workContext = CONTAINING_RECORD(
                                     listEntry,
                                     WORK_CONTEXT,
                                     InProgressListEntry
                                     );

        header = workContext->RequestHeader;
        request = (PREQ_LOCKING_ANDX) workContext->RequestParameters;

        //
        // Some workitems in the inprogressworkitemlist are added
        // during a receive indication and the requestheader field
        // has not been set yet.  We can probably set it at that time
        // but this seems to be the safest fix.
        //

        if ( header != NULL && request != NULL ) {

            smallRange = WorkContext->Parameters.Lock.LockRange;
            largeRange = WorkContext->Parameters.Lock.LockRange;

            largeFileLock =
                (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

            ParseLockData(
                largeFileLock,
                smallRange,
                largeRange,
                &pid,
                &offset,
                &length
                );

            ACQUIRE_DPC_SPIN_LOCK( &workContext->SpinLock );
            if ( (workContext->BlockHeader.ReferenceCount != 0) &&
                 (workContext->ProcessingCount != 0) &&
                 header->Command == SMB_COM_LOCKING_ANDX &&
                 request->Fid == TargetFid &&
                 SmbGetAlignedUshort( &header->Tid ) == targetTid &&
                 SmbGetAlignedUshort( &header->Uid ) == targetUid &&
                 pid == TargetPid &&
                 offset.QuadPart == TargetOffset.QuadPart &&
                 length.QuadPart == TargetLength.QuadPart ) {

                match = TRUE;
                break;
            }
            RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );

        }
    }

    if ( match ) {

        //
        // Reference the work item, so that it cannot get used to process
        // a new SMB while we are trying to cancel the old one.
        //

        SrvReferenceWorkItem( workContext );
        RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        success = IoCancelIrp( workContext->Irp );
        SrvDereferenceWorkItem( workContext );

    } else {

        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        success = FALSE;
    }

    return success;

} // CancelLockRequest


VOID
DoLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN SkipFastPath
    )

/*++

Routine Description:

    Processes the LockingAndX SMB, using the fast lock path.  As long
    as the fast lock path works, we continue to loop through the locks
    specified in the LockingAndX request.  As soon as the fast path
    fails, however, we jump into the slow IRP-based path.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

    SkipFastPath - Indicates whether this routine should try the fast
        lock path before submitting an IRP.

Return Value:

    None.

--*/

{
    PREQ_LOCKING_ANDX request;

    PLOCKING_ANDX_RANGE smallRange;
    PNTLOCKING_ANDX_RANGE largeRange;

    PRFCB rfcb;
    PLFCB lfcb;
    USHORT pid;
    CLONG lockCount;
    CLONG count;

    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN largeFileLock;

    BOOLEAN failImmediately;
    BOOLEAN exclusiveLock;

    ULONG lockTimeout;
    PSRV_TIMER timer;

    PAGED_CODE( );

    //
    // Get the request parameter pointer.
    //

    request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;

    //
    // Get the file pointer, the count of locks requested, the count of
    // locks already performed, and a pointer to the current lock range.
    //

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    lockCount = SmbGetUshort( &request->NumberOfLocks );
    count = SmbGetUshort( &request->NumberOfUnlocks );

    largeFileLock =
            (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

    //
    // Only one of the two pointers below is actually ever referenced.
    //

    smallRange = WorkContext->Parameters.Lock.LockRange;
    largeRange = WorkContext->Parameters.Lock.LockRange;

    //
    // Does the client want an exclusive lock or a shared lock?
    //

    exclusiveLock = (BOOLEAN)( (request->LockType &
                                LOCKING_ANDX_SHARED_LOCK) == 0 );

    //
    // Loop through the lock requests.  We exit this loop when either
    // we have processed all of the lock ranges or the fast lock path
    // fails.
    //

    ASSERT ( count < lockCount );

    while ( TRUE ) {

        //
        // Form the key for the lock.  Get the offset and length
        // of the range.
        //

        ParseLockData(
            largeFileLock,
            smallRange,
            largeRange,
            &pid,
            &offset,
            &length
            );

        key = rfcb->ShiftedFid | pid;

        IF_SMB_DEBUG(LOCK2) {
            KdPrint(( "DoLockingAndX: Locking in file 0x%p: ",
                        lfcb->FileObject ));
            KdPrint(( "(%lx%08lx, %lx%08lx), ",
                        offset.HighPart, offset.LowPart,
                        length.HighPart, length.LowPart ));
            KdPrint(( "key 0x%lx\n", key ));
        }

#ifdef SLMDBG
        {
            PRFCB_TRACE entry;
            KIRQL oldIrql;
            ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
            rfcb->OperationCount++;
            entry = &rfcb->Trace[rfcb->NextTrace];
            if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
                rfcb->NextTrace = 0;
                rfcb->TraceWrapped = TRUE;
            }
            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
            entry->Command = WorkContext->NextCommand;
            entry->Flags = 0;
            KeQuerySystemTime( &entry->Time );
            entry->Data.LockUnlock.Offset = offset.LowPart;
            entry->Data.LockUnlock.Length = length.LowPart;
        }
#endif

        lockTimeout = SmbGetUlong( &request->Timeout );
        if ( (lockTimeout < SrvLockViolationDelay) &&
             ((offset.QuadPart == rfcb->PagedRfcb->LastFailingLockOffset.QuadPart) ||
              (offset.QuadPart >= SrvLockViolationOffset)) ) {
            lockTimeout = SrvLockViolationDelay;
        }
#if SRVDBG_PERF
        if ( LockWaitForever ) {
            lockTimeout = (ULONG)-1;
        }
#endif
        failImmediately = (BOOLEAN)(lockTimeout == 0);

        if ( SkipFastPath ) {

            SkipFastPath = FALSE;

        } else {

            //
            // Try the turbo lock path first.
            //

#if SRVDBG_PERF
            WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
            if ( (LockBypass == 3) ||
                 ((LockBypass == 2) && (offset.LowPart >= LockBypassMirror)) ||
                 ((LockBypass == 1) && (offset.LowPart >= LockBypassConst)) ||
#else
            if (
#endif
                 ((lfcb->FastIoLock != NULL) &&
                  lfcb->FastIoLock(
                            lfcb->FileObject,
                            &offset,
                            &length,
                            IoGetCurrentProcess(),
                            key,
                            failImmediately,
                            exclusiveLock,
                            &WorkContext->Irp->IoStatus,
                            lfcb->DeviceObject
                            )) ) {

                //
                // The turbo path worked.  If the lock was not obtained,
                // drop into the restart routine to return the error.
                // Otherwise, update pointers and counters and continue.
                //

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );
                if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                    RestartLockingAndX( WorkContext );
                    return;
                }

                //
                // Increment the count of locks on the file.
                //

                InterlockedIncrement( &rfcb->NumberOfLocks );

                //
                // If this isn't the last lock, update context
                // information.  If it is, RestartLockingAndX will do
                // this.
                //

                count++;                          // another lock obtained

                if ( count < lockCount ) {

                    SmbPutUshort( &request->NumberOfUnlocks, (USHORT)count );

                    if (largeFileLock) {
                        largeRange++;   // point to next lock range
                        WorkContext->Parameters.Lock.LockRange = (PVOID)largeRange;
                    } else {
                        smallRange++;   // point to next lock range
                        WorkContext->Parameters.Lock.LockRange = (PVOID)smallRange;
                    }

                } else {

                    //
                    // The fast lock path successfully locked all of the
                    // requested ranges.  Call RestartLockingAndX
                    // directly to complete processing of the SMB.
                    //

                    WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
                    RestartLockingAndX( WorkContext );
                    return;

                }

                continue;

            } else {

                //
                // The turbo path failed, or didn't exist.
                //

                if ( lfcb->FastIoLock ) {
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );
                }

            }

        }

        //
        // The turbo path failed, or was bypassed, or didn't exist.
        // Start the lock request, reusing the receive IRP.
        //
        // If we plan to wait for the range to be available, but not
        // indefinitely, we'll need a timer structure.
        //

        timer = NULL;
        if ( !failImmediately ) {
            ASSERT( lockTimeout != 0 );
            if ( lockTimeout != (ULONG)-1 ) {
                timer = SrvAllocateTimer( );
                if ( timer == NULL ) {
                    failImmediately = TRUE;
                }
            }
        }

        SrvBuildLockRequest(
            WorkContext->Irp,           // input IRP address
            lfcb->FileObject,           // target file object address
            WorkContext,                // context
            offset,                     // byte offset
            length,                     // range length
            key,                        // lock key
            failImmediately,
            exclusiveLock
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartLockingAndX;

        //
        // Start the timer, if necessary.
        //

        if ( timer != NULL ) {
            LARGE_INTEGER TimeOut;

            ASSERT( lockTimeout != 0 );
            ASSERT( !failImmediately );
            WorkContext->Parameters.Lock.Timer = timer;
            TimeOut.QuadPart = Int32x32To64( lockTimeout, -1*10*1000);

            SrvSetTimer( timer, &TimeOut, TimeoutLockRequest, WorkContext );
        }

        //
        // Pass the request to the file system.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The lock request has been started.
        //

        IF_DEBUG(TRACE2) KdPrint(( "DoLockingAndX complete\n" ));
        return;

    } // while ( TRUE )

    // can't get here

} // DoLockingAndX


BOOLEAN
ProcessOplockBreakResponse(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb,
    IN PREQ_LOCKING_ANDX Request
    )

/*++

Routine Description:

    This function searches for a lock request in progress.  If the request
    is found, the request IRP is cancelled.

Arguments:

    WorkContext - A pointer to the work information for this request.
    Rfcb - A pointer to the rfcb containing the file and oplock information.
    Request - The request lockingandx smb.

Return Value:

    TRUE - Valid oplock break response
    FALSE - otherwise.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    if ( Rfcb->OnOplockBreaksInProgressList ) {

        Rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;

        //
        // Remove the Rfcb from the Oplock breaks in progress list, and
        // release the Rfcb reference.
        //

        SrvRemoveEntryList( &SrvOplockBreaksInProgressList, &Rfcb->ListEntry );
        Rfcb->OnOplockBreaksInProgressList = FALSE;
#if DBG
        Rfcb->ListEntry.Flink = Rfcb->ListEntry.Blink = NULL;
#endif
        RELEASE_LOCK( &SrvOplockBreakListLock );

        //
        // Update the session lock sequence number.
        //

        WorkContext->Connection->LatestOplockBreakResponse =
                                           WorkContext->Timestamp;

        SrvAcknowledgeOplockBreak( Rfcb, Request->OplockLevel );
        SrvDereferenceRfcb( Rfcb );

        ExInterlockedAddUlong(
            &WorkContext->Connection->OplockBreaksInProgress,
            (ULONG)-1,
            WorkContext->Connection->EndpointSpinLock
            );

        return(TRUE);

    } else {

        RELEASE_LOCK( &SrvOplockBreakListLock );

    }

    return(FALSE);

} // ProcessOplockBreakResponse


VOID SRVFASTCALL
RestartLockByteRange (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file lock completion for a Lock SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_LOCK_BYTE_RANGE request;
    PRESP_LOCK_BYTE_RANGE response;

    LARGE_INTEGER offset;
    NTSTATUS status = STATUS_SUCCESS;
    PSRV_TIMER timer;
    BOOLEAN iAmBlockingThread = (WorkContext->UsingBlockingThread != 0);

    PAGED_CODE( );
    if (iAmBlockingThread) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_BYTE_RANGE;
        SrvWmiStartContext(WorkContext);
    }

    IF_DEBUG(WORKER1) KdPrint(( " - RestartLockByteRange\n" ));

    //
    // If this request was being timed, cancel the timer.
    //

    timer = WorkContext->Parameters.Lock.Timer;
    if ( timer != NULL ) {
        SrvCancelTimer( timer );
        SrvFreeTimer( timer );
    }

    //
    // Get the request and response parameter pointers.
    //

    response = (PRESP_LOCK_BYTE_RANGE)WorkContext->ResponseParameters;

    status = WorkContext->Irp->IoStatus.Status;

    if ( NT_SUCCESS(status) ) {

        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        InterlockedIncrement(
            &WorkContext->Rfcb->NumberOfLocks
            );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_LOCK_BYTE_RANGE,
                                            0
                                            );

#ifdef INCLUDE_SMB_PERSISTENT
        //
        //  if we need to record the lock in the state file, do so before
        //  before we send back the response.
        //

        if (WorkContext->Rfcb->PersistentHandle) {


        }
#endif
        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );


    } else {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.LockViolations );

        //
        // Store the failing lock offset.
        //

        request = (PREQ_LOCK_BYTE_RANGE)WorkContext->RequestParameters;
        offset.QuadPart = SmbGetUlong( &request->Offset );

        WorkContext->Rfcb->PagedRfcb->LastFailingLockOffset = offset;

        //
        // Send error message back
        //

        if ( status == STATUS_CANCELLED ) {
            status = STATUS_FILE_LOCK_CONFLICT;
        }
        SrvSetSmbError( WorkContext, status );

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    }

    IF_DEBUG(TRACE2) KdPrint(( "RestartLockByteRange complete\n" ));
    if (iAmBlockingThread) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartLockByteRange


VOID SRVFASTCALL
RestartLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file lock completion for a Locking and X SMB.  If more
    lock requests are present in the SMB, it starts the next one.  If
    not, it formats a response and starts the next command in the chain,
    if any.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_LOCKING_ANDX request;
    PRESP_LOCKING_ANDX response;
    PLOCKING_ANDX_RANGE smallRange;
    PNTLOCKING_ANDX_RANGE largeRange;

    NTSTATUS status = STATUS_SUCCESS;
    USHORT pid;
    CLONG lockCount;
    CLONG count;

    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN largeFileLock;

    UCHAR nextCommand;
    USHORT reqAndXOffset;

    PRFCB rfcb;
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;
    PSRV_TIMER timer;

    PREQ_CLOSE closeRequest;
    BOOLEAN iAmBlockingThread =
        (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LOCKING_AND_X);

    PAGED_CODE( );
    if (iAmBlockingThread) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCKING_AND_X;
        SrvWmiStartContext(WorkContext);
    }

    IF_DEBUG(WORKER1) KdPrint(( " - RestartLockingAndX\n" ));

    //
    // If this request was being timed, cancel the timer.
    //

    timer = WorkContext->Parameters.Lock.Timer;
    if ( timer != NULL ) {
        SrvCancelTimer( timer );
        SrvFreeTimer( timer );
        WorkContext->Parameters.Lock.Timer = NULL;
    }

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;
    response = (PRESP_LOCKING_ANDX)WorkContext->ResponseParameters;

    //
    // Get the file pointer, the count of locks requested, the count of
    // locks already performed, and a pointer to the current lock range.
    //

    rfcb = WorkContext->Rfcb;
    pagedRfcb = rfcb->PagedRfcb;
    lfcb = rfcb->Lfcb;

    lockCount = SmbGetUshort( &request->NumberOfLocks );
    count = SmbGetUshort( &request->NumberOfUnlocks );

    largeFileLock =
            (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

    //
    // Only one of the two pointers below is actually ever referenced.
    //

    smallRange = WorkContext->Parameters.Lock.LockRange;
    largeRange = WorkContext->Parameters.Lock.LockRange;

    //
    // If the lock request failed, set an error status in the response
    // header and release any previously obtained locks.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.LockViolations );

        IF_DEBUG(ERRORS) {
            KdPrint(( "RestartLockingAndX: lock failed: %X\n", status ));
        }
        if ( status == STATUS_CANCELLED ) {
            status = STATUS_FILE_LOCK_CONFLICT;
        }
        SrvSetSmbError( WorkContext, status );

        ParseLockData(
            largeFileLock,
            smallRange,
            largeRange,
            &pid,
            &offset,
            &length
            );

        //
        // Store the failing lock offset.
        //

        pagedRfcb->LastFailingLockOffset = offset;

        //
        // Release any previously obtained locks, in reverse order.
        //

        for ( smallRange--, largeRange--;
              count > 0;
              count--, smallRange--, largeRange-- ) {

            //
            // Form the key for this lock.  Get the offset and length of
            // the range.
            //

            ParseLockData(
                largeFileLock,
                smallRange,
                largeRange,
                &pid,
                &offset,
                &length
                );

            key = rfcb->ShiftedFid | pid;

            IF_SMB_DEBUG(LOCK2) {
                KdPrint(( "RestartLockingAndX: Unlocking in file 0x%p: ",
                           lfcb->FileObject ));
                KdPrint(( "(%lx%08lx,%lx%08lx), ",
                           offset.HighPart, offset.LowPart,
                           length.HighPart, length.LowPart ));
                KdPrint(( "key 0x%lx\n", key ));
            }

#ifdef SLMDBG
            {
                PRFCB_TRACE entry;
                KIRQL oldIrql;
                ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
                rfcb->OperationCount++;
                entry = &rfcb->Trace[rfcb->NextTrace];
                if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
                    rfcb->NextTrace = 0;
                    rfcb->TraceWrapped = TRUE;
                }
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
                entry->Command = WorkContext->NextCommand;
                entry->Flags = 1;
                KeQuerySystemTime( &entry->Time );
                entry->Data.LockUnlock.Offset = offset.LowPart;
                entry->Data.LockUnlock.Length = length.LowPart;
            }
#endif

            //
            // Issue the Unlock request.
            //

            status = SrvIssueUnlockRequest(
                        lfcb->FileObject,           // target file object
                        &lfcb->DeviceObject,        // target device object
                        IRP_MN_UNLOCK_SINGLE,       // unlock operation
                        offset,                     // byte offset
                        length,                     // range length
                        key                         // lock key
                        );

            if ( NT_SUCCESS(status) ) {
                InterlockedDecrement( &rfcb->NumberOfLocks );
            } else {
                IF_DEBUG(ERRORS) {
                    KdPrint(( "RestartLockingAndX: Unlock failed: %X\n",
                                status ));
                }
            }

        } // for ( range--; count > 0; count--, range-- )

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    //
    // The lock request succeeded.  Update the count of locks on the
    // RFCB and start the next one, if any.
    //

    InterlockedIncrement( &rfcb->NumberOfLocks );

    count++;                          // another lock obtained
    smallRange++, largeRange++;       // point to next lock range

    if ( count < lockCount ) {

        //
        // There is at least one more lock request.  Save the updated
        // context information.
        //

        SmbPutUshort( &request->NumberOfUnlocks, (USHORT)count );

        if (largeFileLock) {
            WorkContext->Parameters.Lock.LockRange = (PVOID)largeRange;
        } else {
            WorkContext->Parameters.Lock.LockRange = (PVOID)smallRange;
        }

        //
        // Call the lock request processor.  (Note that DoLockingAndX
        // can call this routine (RestartLockingAndX) recursively, but
        // only with !NT_SUCCESS(status), so we won't get back here and
        // won't get stuck.
        //
        // Form the key for the lock.  Get the offset and length of the
        // range.
        //

        DoLockingAndX( WorkContext, FALSE );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    //
    // There are no more lock requests in the SMB.  Check for the Oplock
    // Release flag.
    //

    if ( (request->LockType & LOCKING_ANDX_OPLOCK_RELEASE) != 0 ) {

        (VOID)ProcessOplockBreakResponse( WorkContext, rfcb, request);
    }

    //
    // We have (asynchronously) completed processing this SMB.  Set up
    // the response, then check for an AndX command.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;
    SmbPutUshort(
        &response->AndXOffset,
        GET_ANDX_OFFSET(
            WorkContext->ResponseHeader,
            WorkContext->ResponseParameters,
            RESP_LOCKING_ANDX,
            0
            )
        );

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand == SMB_COM_NO_ANDX_COMMAND ) {

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //
        // Build the response parameters.
        //

        PRESP_CLOSE closeResponse = WorkContext->ResponseParameters;

        closeResponse->WordCount = 0;
        SmbPutUshort( &closeResponse->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            closeResponse,
                                            RESP_CLOSE,
                                            0
                                            );

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    //
    // Make sure the AndX command is still within the received SMB
    //
    if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset >= END_OF_REQUEST_SMB( WorkContext ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "RestartLockingAndX: Illegal followon offset: %u\n", reqAndXOffset ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status = STATUS_INVALID_SMB;
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        goto Cleanup;
    }

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_LOCKING_ANDX:
    case SMB_COM_FLUSH:

        break;

    case SMB_COM_CLOSE:

        //
        // Call SrvRestartChainedClose to get the file time set and the
        // file closed.
        //

        closeRequest = (PREQ_CLOSE)((PUCHAR)WorkContext->RequestHeader + reqAndXOffset);

        if( (PCHAR)closeRequest + FIELD_OFFSET(REQ_CLOSE,ByteCount) <=
            END_OF_REQUEST_SMB( WorkContext ) ) {

            WorkContext->Parameters.LastWriteTime = closeRequest->LastWriteTimeInSeconds;

            SrvRestartChainedClose( WorkContext );
            goto Cleanup;
        }

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "RestartLockingAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status = STATUS_INVALID_SMB;
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    WorkContext->NextCommand = nextCommand;

    WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                        reqAndXOffset;

    SrvProcessSmb( WorkContext );
    IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));

Cleanup:
    if (iAmBlockingThread) {
        SrvWmiEndContext(WorkContext);
    }
    return;
} // RestartLockingAndX


VOID
SrvAcknowledgeOplockBreak (
    IN PRFCB Rfcb,
    IN UCHAR NewOplockLevel
    )

/*++

Routine Description:

    This function is called when a client has sent an oplock break
    acknowledgement.  It acknowledges the oplock break locally.

Arguments:

    Rfcb - A pointer to the RFCB for the file on which the oplock is
           being released.

    NewOplockLevel - The oplock level to break to.

Return Value:

    None.

--*/

{
    PPAGED_RFCB pagedRfcb = Rfcb->PagedRfcb;

    PAGED_CODE( );

    IF_DEBUG( OPLOCK ) {
        KdPrint(( "SrvAcknowledgeOplockBreak:  received oplock break response\n" ));
    }

    //
    // Reference the RFCB to account for the IRP we about to submit.
    // If the RFCB is closing, do not bother to acknowledge the oplock.
    //

    if ( !SrvCheckAndReferenceRfcb( Rfcb ) ) {
        return;
    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        KIRQL oldIrql;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        Rfcb->OperationCount++;
        entry = &Rfcb->Trace[Rfcb->NextTrace];
        if ( ++Rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            Rfcb->NextTrace = 0;
            Rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = SMB_COM_LOCKING_ANDX;
        entry->Flags = 2;
        KeQuerySystemTime( &entry->Time );
    }
#endif

    if ( Rfcb->OplockState == OplockStateNone ) {
        KdPrint(("SrvAcknowledgeOplockBreak:  ACKed break for RFCB %p, but no break sent\n", Rfcb));
        SrvDereferenceRfcb( Rfcb );
        return;
    }

    if ( NewOplockLevel == OPLOCK_BROKEN_TO_II ) {
        Rfcb->OplockState = OplockStateOwnLevelII;
    } else {
        Rfcb->OplockState = OplockStateNone;
    }

    //
    // Set this event to NULL to indicate the completion routine should clean
    // up the irp.
    //

    Rfcb->RetryOplockRequest = NULL;

    //
    // Generate and issue the oplock break IRP.  This will attempt to
    // break the oplock to level 2.
    //
    // *** If the client understands level II oplocks, do a regular
    //     acknowledge.  If not, do a special acknowledge that does
    //     not allow the oplock to change to level II.  This prevents
    //     the situation where the oplock package thinks there's a
    //     level II oplock, but the client(s) don't.  In that situation,
    //     fast I/O (esp. reads) is disabled unnecessarily.
    //

    SrvBuildIoControlRequest(
        Rfcb->Irp,
        Rfcb->Lfcb->FileObject,
        Rfcb,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        (CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, Rfcb->Connection ) ?
            FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
            FSCTL_OPLOCK_BREAK_ACK_NO_2),
        NULL,                        // Main buffer
        0,                           // Input buffer length
        NULL,                        // Auxiliary buffer
        0,                           // Output buffer length
        NULL,                        // MDL
        SrvFsdOplockCompletionRoutine
        );

    (VOID)IoCallDriver(
              Rfcb->Lfcb->DeviceObject,
              Rfcb->Irp
              );

} // SrvAcknowledgeOplockBreak


VOID
TimeoutLockRequest (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSRV_TIMER timer;

    //
    // A lock request has been waiting too long.  Cancel it.
    //

    IoCancelIrp( ((PWORK_CONTEXT)DeferredContext)->Irp );

    //
    // Set the event indicating that the timer routine is done.
    //

    timer = CONTAINING_RECORD( Dpc, SRV_TIMER, Dpc );
    KeSetEvent( &timer->Event, 0, FALSE );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbmisc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbmisc.c

Abstract:

    This module contains routines for processing MISC class SMBs:
        Echo
        Query FS Information
        Set FS Information
        Query Disk Information

Author:

    Chuck Lenzmeier (chuckl) 9-Nov-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "smbmisc.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBMISC

STATIC
ULONG QueryVolumeInformation[] = {
         SMB_QUERY_FS_LABEL_INFO,  // Base level
         FileFsLabelInformation,   // Mapping for base level
         FileFsVolumeInformation,
         FileFsSizeInformation,
         FileFsDeviceInformation,
         FileFsAttributeInformation
};

STATIC
VOID SRVFASTCALL
RestartEcho (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbEcho )
#pragma alloc_text( PAGE, RestartEcho )
#pragma alloc_text( PAGE, SrvSmbQueryFsInformation )
#pragma alloc_text( PAGE, SrvSmbSetFsInformation )
#pragma alloc_text( PAGE, SrvSmbQueryInformationDisk )
#pragma alloc_text( PAGE, SrvSmbSetSecurityDescriptor )
#pragma alloc_text( PAGE, SrvSmbQuerySecurityDescriptor )
#pragma alloc_text( PAGE, SrvSmbQueryQuota )
#pragma alloc_text( PAGE, SrvSmbSetQuota )
#endif
#if 0
NOT PAGEABLE -- SrvSmbNtCancel
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbEcho (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an Echo SMB.  It sends the first echo, if any, specifying
    RestartEcho as the restart routine.  That routine sends the
    remaining echoes.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_ECHO request;
    PRESP_ECHO response;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_ECHO;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_ECHO)WorkContext->RequestParameters;
    response = (PRESP_ECHO)WorkContext->ResponseParameters;

    //
    // If the echo count is 0, there are no echoes to send.
    //

    if ( SmbGetUshort( &request->EchoCount ) == 0 ) {
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    //
    // The echo count is not zero.  Save it in the work context, then
    // send the first echo.
    //
    // *** This code depends on the response buffer being the same as
    //     the request buffer.  It does not copy the echo data from the
    //     request to the response.  It does not update the DataLength
    //     of the response buffer.
    //
    // !!! Need to put in code to verify the requested TID, if any.
    //

    SrvReleaseContext( WorkContext );

    WorkContext->Parameters.RemainingEchoCount =
        (USHORT)(SmbGetUshort( &request->EchoCount ) - 1);

    ASSERT( WorkContext->ResponseHeader == WorkContext->RequestHeader );

    SmbPutUshort( &response->SequenceNumber, 1 );

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Send the echo.  Notice that the smb statistics will be updated
    // here.  Instead of measuring the time to finish all the echos,
    // we just measure the time to respond to the first.  This will
    // save us the trouble of storing the timestamp somewhere.
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvQueueWorkToFspAtSendCompletion,
        NULL,
        RestartEcho
        );

    //
    // The echo has been started.  Tell the main SMB processor not to
    // do anything more with the current SMB.
    //
    SmbStatus = SmbStatusInProgress;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbEcho


VOID SRVFASTCALL
RestartEcho (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for an Echo.  If more echoes are required,
    it sends the next one.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_ECHO;
    SrvWmiStartContext(WorkContext);

    IF_DEBUG(WORKER1) SrvPrint0( " - RestartEcho\n" );

    //
    // Get the connection pointer.  The connection pointer is a
    // referenced pointer.  (The endpoint is valid because the
    // connection references the endpoint.)
    //

    connection = WorkContext->Connection;
    IF_DEBUG(TRACE2) SrvPrint2( "  connection %p, endpoint %p\n",
                                        connection, WorkContext->Endpoint );

    //
    // If the I/O request failed or was canceled, or if the connection
    // is no longer active, clean up.  (The connection is marked as
    // closing when it is disconnected or when the endpoint is closed.)
    //
    // !!! If I/O failure, should we drop the connection?
    //

    if ( WorkContext->Irp->Cancel ||
         !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(connection) != BlockStateActive) ) {

        IF_DEBUG(TRACE2) {
            if ( WorkContext->Irp->Cancel ) {
                SrvPrint0( "  I/O canceled\n" );
            } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                SrvPrint1( "  I/O failed: %X\n",
                            WorkContext->Irp->IoStatus.Status );
            } else {
                SrvPrint0( "  Connection no longer active\n" );
            }
        }

        //
        // Indicate that SMB processing is complete.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartEcho complete\n" );
        goto Cleanup;

    }

    //
    // The request was successful, and the connection is still active.
    // If there are no more echoes to be sent, indicate that SMB
    // processing is complete.
    //

    if ( WorkContext->Parameters.RemainingEchoCount == 0 ) {

        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartEcho complete\n" );
        goto Cleanup;

    }

    --WorkContext->Parameters.RemainingEchoCount;

    //
    // There are more echoes to be sent.  Increment the sequence number
    // in the response SMB, and send another echo.
    //

    SmbPutUshort(
        &((PRESP_ECHO)WorkContext->ResponseParameters)->SequenceNumber,
        (USHORT)(SmbGetUshort(
            &((PRESP_ECHO)WorkContext->ResponseParameters)->SequenceNumber
            ) + 1)
        );

    //
    // Don't do smb statistics a second time.
    //

    WorkContext->StartTime = 0;

    //
    // Send the echo.  (Note that the response bit has already been
    // set.)
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvQueueWorkToFspAtSendCompletion,
        NULL,
        RestartEcho
        );
    IF_DEBUG(TRACE2) SrvPrint0( "RestartEcho complete\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return;

} // RestartEcho


SMB_TRANS_STATUS
SrvSmbQueryFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Query FS Information request.  This request arrives
    in a Transaction2 SMB.  Query FS Information corresponds to the
    OS/2 DosQFSInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    PTRANSACTION transaction;
    USHORT informationLevel;

    USHORT trans2code;
    HANDLE fileHandle;

    FILE_FS_SIZE_INFORMATION fsSizeInfo;
    PFSALLOCATE fsAllocate;

    PFILE_FS_VOLUME_INFORMATION fsVolumeInfo;
    ULONG fsVolumeInfoLength;
    PFSINFO fsInfo;
    ULONG lengthVolumeLabel;
    BOOLEAN isUnicode;
    PREQ_QUERY_FS_INFORMATION request;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_FS_INFORMATION;
    SrvWmiStartContext(WorkContext);

    isUnicode = SMB_IS_UNICODE( WorkContext );
    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(MISC1) {
        SrvPrint1( "Query FS Information entered; transaction 0x%p\n",
                    transaction );
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.  Query FS information has no
    // response parameters.
    //


    if ( (transaction->ParameterCount < sizeof(REQ_QUERY_FS_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "SrvSmbQueryFSInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // See if a non-admin user is trying to access information on an Administrative share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, WorkContext->TreeConnect->Share );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    trans2code = SmbGetAlignedUshort(transaction->InSetup);
    IF_SMB_DEBUG(MISC1) {
        SrvPrint1("SrvSmbQueryFSInformation: Trans2 function = %x\n", trans2code);
    }

    request = (PREQ_QUERY_FS_INFORMATION) transaction->InParameters;

    ASSERT( trans2code == TRANS2_QUERY_FS_INFORMATION );

    informationLevel = SmbGetUshort( &request->InformationLevel );

    //
    // *** The share handle is used to get the allocation
    //     information.  This is a "storage channel," and as a
    //     result could allow people to get information to which
    //     they are not entitled.  For a B2 security rating this may
    //     need to be changed.
    //

    status = SrvGetShareRootHandle( WorkContext->TreeConnect->Share );

    if (!NT_SUCCESS(status)) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvSmbQueryFsInformation: SrvGetShareRootHandle failed %x.\n",
                        status );
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );
    if( !NT_SUCCESS(status)) {

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    IF_SMB_DEBUG(MISC1) {
        SrvPrint0("SrvSmbQueryFSInformation: Using share root handle\n");
    }

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {
        switch ( informationLevel ) {

        case SMB_INFO_ALLOCATION:

            //
            // Return information about the disk.
            //

            fsAllocate = (PFSALLOCATE)transaction->OutData;

            if ( transaction->MaxDataCount < sizeof(FSALLOCATE) ) {
                SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );
                SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                status    = STATUS_BUFFER_OVERFLOW;
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }


            //
            // *** The share handle is used to get the allocation
            //     information.  This is a "storage channel," and as a
            //     result could allow people to get information to which
            //     they are not entitled.  For a B2 security rating this may
            //     need to be changed.
            //

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {
                status = NtQueryVolumeInformationFile(
                             fileHandle,
                             &ioStatusBlock,
                             &fsSizeInfo,
                             sizeof(FILE_FS_SIZE_INFORMATION),
                             FileFsSizeInformation
                             );

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                 fileHandle,
                                 &ioStatusBlock,
                                 &fsSizeInfo,
                                 sizeof(FILE_FS_SIZE_INFORMATION),
                                 FileFsSizeInformation
                                 );
                    }
                }

                REVERT();
            }

            //
            // Release the share root handle
            //

            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvSmbQueryFsInformation: NtQueryVolumeInformationFile "
                        "returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_VOL_INFO_FILE, status );

                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            SmbPutAlignedUlong( &fsAllocate->idFileSystem, 0 );
            SmbPutAlignedUlong(
                &fsAllocate->cSectorUnit,
                fsSizeInfo.SectorsPerAllocationUnit
                );

            //
            // *** If .HighPart is non-zero, there is a problem, as we can
            //     only return 32 bits for the volume size.  In this case,
            //     we return the largest value that will fit.
            //

            SmbPutAlignedUlong(
                &fsAllocate->cUnit,
                fsSizeInfo.TotalAllocationUnits.HighPart == 0 ?
                    fsSizeInfo.TotalAllocationUnits.LowPart :
                    0xffffffff
                );
            SmbPutAlignedUlong(
                &fsAllocate->cUnitAvail,
                fsSizeInfo.AvailableAllocationUnits.HighPart == 0 ?
                    fsSizeInfo.AvailableAllocationUnits.LowPart :
                    0xffffffff
                );

            SmbPutAlignedUshort(
                &fsAllocate->cbSector,
                (USHORT)fsSizeInfo.BytesPerSector );

            transaction->DataCount = sizeof(FSALLOCATE);

            break;

        case SMB_INFO_VOLUME:

            //
            // Query the volume label.
            //

            fsInfo = (PFSINFO)transaction->OutData;

            //
            // The maximum volume label length we are able to return, given
            // the VOLUMELABEL structure (1 byte describes length of label),
            // is 255 characters.  Therefore, allocate a buffer large enough
            // to hold a label that size, and if the label is longer then we
            // will get STATUS_BUFFER_OVERFLOW from NtQueryVolumeInformationFile.
            //

            fsVolumeInfoLength = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel ) +
                                 255 * sizeof(WCHAR);
            fsVolumeInfo = ALLOCATE_HEAP_COLD( fsVolumeInfoLength, BlockTypeDataBuffer );

            if ( fsVolumeInfo == NULL ) {
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                status    = STATUS_INSUFF_SERVER_RESOURCES;
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }


            //
            // Get the label information.
            //

            status = NtQueryVolumeInformationFile(
                         fileHandle,
                         &ioStatusBlock,
                         fsVolumeInfo,
                         fsVolumeInfoLength,
                         FileFsVolumeInformation
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                if( NT_SUCCESS(status) )
                {
                    status = NtQueryVolumeInformationFile(
                             fileHandle,
                             &ioStatusBlock,
                             fsVolumeInfo,
                             fsVolumeInfoLength,
                             FileFsVolumeInformation
                             );
                }
            }

            //
            // Release the share root handle
            //
            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvSmbQueryFSInformation: NtQueryVolumeInformationFile "
                        "returned %X",
                    status,
                    NULL
                    );

                FREE_HEAP( fsVolumeInfo );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_VOL_INFO_FILE, status );

                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            lengthVolumeLabel = fsVolumeInfo->VolumeLabelLength;

            //
            // Make sure that the client can accept enough data.  The volume
            // label length is limited to 13 characters (8 + '.' + 3 + zero
            // terminator) in OS/2, so return STATUS_BUFFER_OVERFLOW if the
            // label is too long.
            //

            if ( !isUnicode &&
                    !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {

                //
                // For a non-NT client, we truncate the volume label in case
                // it is longer than 11+1 characters.
                //

                if ( lengthVolumeLabel > 11 * sizeof(WCHAR) ) {
                    lengthVolumeLabel = 11 * sizeof(WCHAR);
                }

                //
                // Wedge a '.' into the name if it's longer than 8 characters long
                //
                if( lengthVolumeLabel > 8 * sizeof( WCHAR ) ) {

                    LPWSTR p = &fsVolumeInfo->VolumeLabel[11];

                    *p = *(p-1);        // VolumeLabel[11] = VolumeLabel[10]
                    --p;
                    *p = *(p-1);        // VolumeLabel[10] = VolumeLabel[9]
                    --p;
                    *p = *(p-1);        // VolumeLabel[9] = VolumeLabel[8]
                    --p;
                    *p = L'.';          // VolumeLabel[8] = '.'

                }

            }

            if ( (ULONG)transaction->MaxDataCount <
                     ( sizeof(FSINFO) - sizeof(VOLUMELABEL) + sizeof( UCHAR ) +
                       lengthVolumeLabel / (isUnicode ? 1 : sizeof(WCHAR)) ) ) {

                FREE_HEAP( fsVolumeInfo );
                SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                status    = STATUS_BUFFER_OVERFLOW;
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            SmbPutUlong( &fsInfo->ulVsn, fsVolumeInfo->VolumeSerialNumber );

            //
            // Put the label in the SMB in Unicode or OEM, depending on what
            // was negotiated.
            //

            if ( isUnicode ) {

                RtlCopyMemory(
                    fsInfo->vol.szVolLabel,
                    fsVolumeInfo->VolumeLabel,
                    lengthVolumeLabel
                    );

                transaction->DataCount = sizeof(FSINFO) -
                                    sizeof(VOLUMELABEL) + lengthVolumeLabel;

                fsInfo->vol.cch = (UCHAR)lengthVolumeLabel;

            } else {

                ULONG i;
                OEM_STRING oemString;
                UNICODE_STRING unicodeString;

                if ( lengthVolumeLabel != 0 ) {

                    oemString.Buffer = fsInfo->vol.szVolLabel;
                    oemString.MaximumLength = 12;

                    unicodeString.Buffer = (PWCH)fsVolumeInfo->VolumeLabel;
                    unicodeString.Length = (USHORT) lengthVolumeLabel;
                    unicodeString.MaximumLength = (USHORT) lengthVolumeLabel;

                    status = RtlUnicodeStringToOemString(
                                 &oemString,
                                 &unicodeString,
                                 FALSE
                                 );
                    ASSERT( NT_SUCCESS(status) );
                }

                fsInfo->vol.cch = (UCHAR) (lengthVolumeLabel / sizeof(WCHAR));

                //
                // Pad the end of the volume name with zeros to fill 12
                // characters.
                //

                for ( i = fsInfo->vol.cch + 1 ; i < 12; i++ ) {
                    fsInfo->vol.szVolLabel[i] = '\0';
                }

                transaction->DataCount = sizeof(FSINFO);
            }

            IF_SMB_DEBUG(MISC1) {
                SrvPrint2( "volume label length is %d and label is %s\n",
                              fsInfo->vol.cch, fsInfo->vol.szVolLabel );
            }

            FREE_HEAP( fsVolumeInfo );

            break;

        case SMB_QUERY_FS_VOLUME_INFO:
        case SMB_QUERY_FS_DEVICE_INFO:
        case SMB_QUERY_FS_ATTRIBUTE_INFO:

            //
            // These are NT infolevels.  We always return unicode.
            //  Except for the fact that NEXUS on WFW calls through here and is
            //  not unicode (isaache)
            //
            // ASSERT( isUnicode );

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {
                status = NtQueryVolumeInformationFile(
                             fileHandle,
                             &ioStatusBlock,
                             transaction->OutData,
                             transaction->MaxDataCount,
                             MAP_SMB_INFO_TYPE_TO_NT(
                                 QueryVolumeInformation,
                                 informationLevel
                                 )
                             );

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                     fileHandle,
                                     &ioStatusBlock,
                                     transaction->OutData,
                                     transaction->MaxDataCount,
                                     MAP_SMB_INFO_TYPE_TO_NT(
                                         QueryVolumeInformation,
                                         informationLevel
                                         )
                                 );
                    }
                }

                REVERT();
            }

            //
            // Release the share root handle
            //
            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( NT_SUCCESS( status ) ) {
                //
                // We need to return FAT to the client if the host volume is really
                // FAT32
                //
                if( informationLevel == SMB_QUERY_FS_ATTRIBUTE_INFO &&
                    ioStatusBlock.Information > sizeof( FILE_FS_ATTRIBUTE_INFORMATION ) ) {

                    PFILE_FS_ATTRIBUTE_INFORMATION attrInfo =
                        (PFILE_FS_ATTRIBUTE_INFORMATION)(transaction->OutData);

                    if( attrInfo->FileSystemNameLength > 3*sizeof(WCHAR) &&
                        attrInfo->FileSystemName[0] == L'F' &&
                        attrInfo->FileSystemName[1] == L'A' &&
                        attrInfo->FileSystemName[2] == L'T' ) {

                        ioStatusBlock.Information =
                            ioStatusBlock.Information -
                            (attrInfo->FileSystemNameLength - 3*sizeof(WCHAR) );

                        attrInfo->FileSystemNameLength = 3 * sizeof(WCHAR);
                        attrInfo->FileSystemName[3] = UNICODE_NULL;
                    }
                }

                transaction->DataCount = (ULONG)ioStatusBlock.Information;

            } else {
                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            break;

        case SMB_QUERY_FS_SIZE_INFO:

            //
            // These are NT infolevels.  We always return unicode.
            //  Except for the fact that NEXUS on WFW calls through here and is
            //  not unicode (isaache)
            //
            // ASSERT( isUnicode );


            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = NtQueryVolumeInformationFile(
                                 fileHandle,
                                 &ioStatusBlock,
                                 transaction->OutData,
                                 transaction->MaxDataCount,
                                 MAP_SMB_INFO_TYPE_TO_NT(
                                     QueryVolumeInformation,
                                     informationLevel
                                     )
                                 );
                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                         fileHandle,
                                         &ioStatusBlock,
                                         transaction->OutData,
                                         transaction->MaxDataCount,
                                         MAP_SMB_INFO_TYPE_TO_NT(
                                             QueryVolumeInformation,
                                             informationLevel
                                             )
                                         );
                    }
                }

                REVERT();
            }

            //
            // Release the share root handle
            //
            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( NT_SUCCESS( status ) ) {
                transaction->DataCount = (ULONG)ioStatusBlock.Information;
            } else {
                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            break;

        default:

            //
            // An invalid information level was passed.
            //

            SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
            status    = STATUS_OS2_INVALID_LEVEL;
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

    } else {

        informationLevel -= SMB_INFO_PASSTHROUGH;

        status = IoCheckQuerySetVolumeInformation(  informationLevel,
                                                    transaction->MaxDataCount,
                                                    FALSE
                                                 );

        if( NT_SUCCESS( status ) ) {

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = NtQueryVolumeInformationFile(
                                fileHandle,
                                &ioStatusBlock,
                                transaction->OutData,
                                transaction->MaxDataCount,
                                informationLevel
                                );

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                        fileHandle,
                                        &ioStatusBlock,
                                        transaction->OutData,
                                        transaction->MaxDataCount,
                                        informationLevel
                                        );
                    }
                }

                REVERT();
            }
        }

        SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

        if ( NT_SUCCESS( status ) ) {
            transaction->DataCount = (ULONG)ioStatusBlock.Information;
        } else {
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    SmbStatus = SmbTransStatusSuccess;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryFsInformation


SMB_TRANS_STATUS
SrvSmbSetFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set FS Information request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    SMB_TRANS_STATUS transactionStatus = SmbTransStatusInProgress;
    PREQ_SET_FS_INFORMATION request;
    NTSTATUS         status    = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    PTRANSACTION transaction;
    USHORT informationLevel;
    PSESSION      session;
    PTREE_CONNECT treeConnect;
    PRFCB rfcb;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_FS_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(MISC1) {
        SrvPrint1( "Set FS Information entered; transaction 0x%p\n",
                    transaction );
    }

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if( !NT_SUCCESS( status ) ) {
        goto out;
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.  Set FS information has no
    // response parameters.
    //

    request = (PREQ_SET_FS_INFORMATION)transaction->InParameters;

    if ( (transaction->ParameterCount < sizeof(REQ_SET_FS_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG(ERRORS) {
            SrvPrint2( "SrvSmbSetFSInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        status = STATUS_INVALID_SMB;
        SrvLogInvalidSmb( WorkContext );
        goto out;
    }

    //
    // Confirm that the information level is legitimate.
    //
    informationLevel = SmbGetUshort( &request->InformationLevel );

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {
        status = STATUS_NOT_SUPPORTED;
        goto out;
    }

    informationLevel -= SMB_INFO_PASSTHROUGH;

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, WorkContext->TreeConnect->Share );

    if( !NT_SUCCESS( status ) ) {
        goto out;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //
    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {
        IF_DEBUG(ERRORS) {
            SrvPrint2(
                "SrvSmbSetFsInformation: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                );
        }

        goto out;
    }

    status = IoCheckQuerySetVolumeInformation(
                 informationLevel,
                 transaction->DataCount,
                 TRUE
                 );

    if( NT_SUCCESS( status ) ) {

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            status = NtSetVolumeInformationFile(
                         rfcb->Lfcb->FileHandle,
                         &ioStatusBlock,
                         transaction->InData,
                         transaction->DataCount,
                         informationLevel
                         );

            REVERT();
        }
    }

out:
    if ( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        transactionStatus = SmbTransStatusErrorWithoutData;
    } else {
        transactionStatus =  SmbTransStatusSuccess;
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    SrvWmiEndContext(WorkContext);
    return transactionStatus;

} // SrvSmbSetFsInformation


SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformationDisk (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Query Information Disk SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_QUERY_INFORMATION_DISK request;
    PRESP_QUERY_INFORMATION_DISK response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_FS_SIZE_INFORMATION fsSizeInfo;

    PSESSION session;
    PTREE_CONNECT treeConnect;

    USHORT totalUnits, freeUnits;
    ULONG sectorsPerUnit, bytesPerSector;
    LARGE_INTEGER result;
    BOOLEAN highpart;
    ULONG searchword;
    CCHAR highbit, extrabits;

    BOOLEAN isDos;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_INFORMATION_DISK;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(MISC1) {
        SrvPrint2( "Query Information Disk request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Query Information Disk request params at 0x%p, response params%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_QUERY_INFORMATION_DISK)WorkContext->RequestParameters;
    response = (PRESP_QUERY_INFORMATION_DISK)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbQueryInformationDisk: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, treeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    //
    // Get the Share root handle.
    //

    status = SrvGetShareRootHandle( treeConnect->Share );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvSmbQueryInformationDisk: SrvGetShareRootHandle failed %x.\n",
                        status );
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // *** The share handle is used to get the allocation information.
    //     This is a "storage channel," and as a result could allow
    //     people to get information to which they are not entitled.
    //     For a B2 security rating this may need to be changed.
    //

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {

        HANDLE RootHandle;

        status = SrvSnapGetRootHandle( WorkContext, &RootHandle );
        if( NT_SUCCESS(status) )
        {
            status = NtQueryVolumeInformationFile(
                         RootHandle,
                         &ioStatusBlock,
                         &fsSizeInfo,
                         sizeof(FILE_FS_SIZE_INFORMATION),
                         FileFsSizeInformation
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &RootHandle );
                if( NT_SUCCESS(status) )
                {
                    status = NtQueryVolumeInformationFile(
                                 RootHandle,
                                 &ioStatusBlock,
                                 &fsSizeInfo,
                                 sizeof(FILE_FS_SIZE_INFORMATION),
                                 FileFsSizeInformation
                                 );
                }
            }
        }

        REVERT();
    }

    //
    // Release the share root handle
    //

    SrvReleaseShareRootHandle( treeConnect->Share );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbQueryInformationDisk: NtQueryVolumeInformationFile"
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_VOL_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // *** Problem.
    //
    // This SMB only return 16 bits of information for each field, but we
    // may need to return large numbers.  In particular TotalAllocationUnits
    // is commonly > 64K.
    //
    // Fortunately, it turns out the all the client cares about is the total
    // disk size, in bytes, and the free space, in bytes.  So - if one number
    // is too big adjust it and adjust the other numbers so that the totals
    // come out the same.
    //
    // If after all adjustment, the number are still too high, return the
    // largest possible value for TotalUnit or FreeUnits (i.e. 0xFFFF).
    //
    // A caveat here is that some DOS apps (like the command interpreter!)
    // assume that the cluster size (bytes per sector times sectors per
    // cluster) will fit in 16 bits, and will calculate bogus geometry if
    // it doesn't.  So the first thing we do is ensure that the real
    // cluster size is less than 0x10000, if the client is a DOS client.
    // This may make the TotalUnits or FreeUnits counts too big, so we'll
    // have to round them down, but that's life.
    //
    // Since we use shifts to adjust the numbers it is possible to lose
    // 1 bits when we shift a number to the right.  We don't care, we're
    // doing our best to fix a broken protocol.  NT clients will use
    // QueryFSAttribute and will get the correct answer.
    //

    //
    // If this is a DOS client, make the cluster size < 0x10000.
    //

    isDos = IS_DOS_DIALECT( WorkContext->Connection->SmbDialect );

    sectorsPerUnit = fsSizeInfo.SectorsPerAllocationUnit;
    bytesPerSector = fsSizeInfo.BytesPerSector;

    if ( isDos ) {
        while ( (sectorsPerUnit * bytesPerSector) > 0xFFFF ) {
            if ( sectorsPerUnit >= 2 ) {
                sectorsPerUnit /= 2;
            } else {
                bytesPerSector /= 2;
            }
            fsSizeInfo.TotalAllocationUnits.QuadPart *= 2;
            fsSizeInfo.AvailableAllocationUnits.QuadPart *= 2;
        }
    }

    //
    // Calculate how much the total cluster count needs to be shifted in
    // order to fit in a word.
    //

    if ( fsSizeInfo.TotalAllocationUnits.HighPart != 0 ) {
        highpart = TRUE;
        searchword = fsSizeInfo.TotalAllocationUnits.HighPart;
    } else {
        highpart = FALSE;
        searchword = fsSizeInfo.TotalAllocationUnits.LowPart;
    }

    highbit = 0;
    while ( searchword != 0 ) {
        highbit++;
        searchword /= 2;
    }

    if ( highpart ) {
        highbit += 32;
    } else {
        if ( highbit < 16) {
            highbit = 0;
        } else {
            highbit -= 16;
        }
    }

    if ( highbit > 0 ) {

        //
        // Attempt to adjust the other values to absorb the excess bits.
        // If this is a DOS client, don't let the cluster size get
        // bigger than 0xFFFF.
        //

        extrabits = highbit;

        if ( isDos ) {

            while ( (highbit > 0) &&
                    ((sectorsPerUnit*bytesPerSector) < 0x8000) ) {
                sectorsPerUnit *= 2;
                highbit--;
            }

        } else {

            while ( (highbit > 0) && (sectorsPerUnit < 0x8000) ) {
                sectorsPerUnit *= 2;
                highbit--;
            }

            while ( (highbit > 0) && (bytesPerSector < 0x8000) ) {
                bytesPerSector *= 2;
                highbit--;
            }

        }

        //
        // Adjust the total and free unit counts.
        //

        if ( highbit > 0 ) {

            //
            // There is no way to get the information to fit.  Use the
            // maximum possible value.
            //


            totalUnits = 0xFFFF;

        } else {

            result.QuadPart = fsSizeInfo.TotalAllocationUnits.QuadPart >> extrabits;

            ASSERT( result.HighPart == 0 );
            ASSERT( result.LowPart < 0x10000 );

            totalUnits = (USHORT)result.LowPart;

        }

        result.QuadPart =  fsSizeInfo.AvailableAllocationUnits.QuadPart >>
                                            (CCHAR)(extrabits - highbit);

        if ( result.HighPart != 0 || result.LowPart > 0xFFFF ) {
            freeUnits = 0xFFFF;
        } else {
            freeUnits = (USHORT)result.LowPart;
        }

    } else {

        totalUnits = (USHORT)fsSizeInfo.TotalAllocationUnits.LowPart;
        freeUnits = (USHORT)fsSizeInfo.AvailableAllocationUnits.LowPart;

    }

    //
    // Build the response SMB.
    //

    response->WordCount = 5;

    SmbPutUshort( &response->TotalUnits, totalUnits );
    SmbPutUshort( &response->BlocksPerUnit, (USHORT)sectorsPerUnit );
    SmbPutUshort( &response->BlockSize, (USHORT)bytesPerSector );
    SmbPutUshort( &response->FreeUnits, freeUnits );

    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_QUERY_INFORMATION_DISK,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbQueryInformationDisk complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryInformationDisk


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCancel (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an Nt Cancel SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PCONNECTION connection;
    USHORT targetUid, targetPid, targetTid, targetMid;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PSMB_HEADER header;
    BOOLEAN match;
    KIRQL oldIrql;

    PREQ_NT_CANCEL request;
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NT_CANCEL;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_NT_CANCEL)WorkContext->RequestParameters;

    //
    // The word count has already been checked.  Now make sure that
    // the byte count is zero.
    //

    if ( SmbGetUshort( &request->ByteCount) != 0 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbNtCancel: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Check the work in-progress list to see if this work item is
    // cancellable.
    //

    targetUid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid );
    targetPid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    targetTid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid );
    targetMid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Mid );

    match = FALSE;

    connection = WorkContext->Connection;

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    listHead = &connection->InProgressWorkItemList;
    listEntry = listHead;
    while ( listEntry->Flink != listHead ) {

        listEntry = listEntry->Flink;

        workContext = CONTAINING_RECORD(
                                     listEntry,
                                     WORK_CONTEXT,
                                     InProgressListEntry
                                     );

        header = workContext->RequestHeader;

        //
        // Some workitems in the inprogressworkitemlist are added
        // during a receive indication and the requestheader field
        // has not been set yet.  We can probably set it at that time
        // but this seems to be the safest fix.
        //
        // We have to check whether the workitem ref count is zero or
        // not since we dereference it before removing it from the
        // InProgressWorkItemList queue.  This prevents the workitem
        // from being cleaned up twice.
        //
        // We also need to check the processing count of the workitem.
        // Work items being used for actual smb requests will have
        // a processing count of at least 1.  This will prevent us
        // from touching oplock breaks and pending tdi receives.
        //

        ACQUIRE_DPC_SPIN_LOCK( &workContext->SpinLock );
        if ( (workContext->BlockHeader.ReferenceCount != 0) &&
             (workContext->ProcessingCount != 0) &&
             header != NULL &&
             header->Command != SMB_COM_NT_CANCEL &&
             SmbGetAlignedUshort( &header->Mid ) == targetMid &&
             SmbGetAlignedUshort( &header->Pid ) == targetPid &&
             SmbGetAlignedUshort( &header->Tid ) == targetTid &&
             SmbGetAlignedUshort( &header->Uid ) == targetUid ) {

            match = TRUE;
            break;
        }
        RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );

    }

    if ( match ) {

        //
        // Reference the work item, so that it cannot get used to process
        // a new SMB while we are trying to cancel the old one.
        //

        SrvReferenceWorkItem( workContext );
        RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        (VOID)IoCancelIrp( workContext->Irp );
        SrvDereferenceWorkItem( workContext );

    } else {

        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    }

    //
    // Done.  Do not send a response
    //
    SmbStatus = SmbStatusNoResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbNtCancel


SMB_TRANS_STATUS
SrvSmbSetSecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set Security Descriptor request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_SET_SECURITY_DESCRIPTOR request;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;
    SECURITY_INFORMATION securityInformation;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        SrvPrint1( "Set Security Descriptor entered; transaction 0x%p\n",
                    transaction );
    }

    request = (PREQ_SET_SECURITY_DESCRIPTOR)transaction->InParameters;

    //
    // Verify that enough setup bytes were sent.
    //

    if ( transaction->ParameterCount < sizeof(REQ_SET_SECURITY_DESCRIPTOR ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbSetSecurityInformation: bad setup byte count: "
                        "%ld\n",
                        transaction->ParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint2(
                "SrvSmbSetFileInformation: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                );
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    //
    //  First we'll validate that the security descriptor isn't bogus.
    //  This needs to be done here because NtSetSecurityObject has no
    //  idea what the buffer size is.
    //
    if( !RtlValidRelativeSecurityDescriptor( transaction->InData,
                                             transaction->DataCount,
                                             0 )) {
        //
        //  We were passed a bogus security descriptor to set.  Bounce the
        //  request as an invalid SMB.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SECURITY_DESCR );
        return SmbTransStatusErrorWithoutData;
    }

    securityInformation = SmbGetUlong( &request->SecurityInformation );

    //
    // Make sure the caller is allowed to set security information on this object
    //
    status = IoCheckFunctionAccess( rfcb->GrantedAccess,
                                    IRP_MJ_SET_SECURITY,
                                    0,
                                    0,
                                    &securityInformation,
                                    NULL
                                   );

    if( NT_SUCCESS( status ) ) {
        //
        //  Attempt to set the security descriptor.  We need to be in the
        //  the user context to do this, in case the security information
        //  specifies change ownership.
        //

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {
            status = NtSetSecurityObject(
                     rfcb->Lfcb->FileHandle,
                     securityInformation,
                     transaction->InData
                     );

            REVERT();
        }
    }

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // We probably shouldn't cache this file descriptor on close, since
    //  the security setting changed.
    //
    rfcb->IsCacheable = FALSE;

    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    return SmbTransStatusSuccess;

} // SrvSmbSetSecurityDescriptor


SMB_TRANS_STATUS
SrvSmbQuerySecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Query Security Descriptor request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_QUERY_SECURITY_DESCRIPTOR request;
    PRESP_QUERY_SECURITY_DESCRIPTOR response;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;
    ULONG lengthNeeded;
    SECURITY_INFORMATION securityInformation;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        SrvPrint1( "Query Security Descriptor entered; transaction 0x%p\n",
                    transaction );
    }

    request = (PREQ_QUERY_SECURITY_DESCRIPTOR)transaction->InParameters;
    response = (PRESP_QUERY_SECURITY_DESCRIPTOR)transaction->OutParameters;

    //
    // Verify that enough setup bytes were sent.
    //

    if ( transaction->ParameterCount < sizeof(REQ_QUERY_SECURITY_DESCRIPTOR ) ||
         transaction->MaxParameterCount <
             sizeof( RESP_QUERY_SECURITY_DESCRIPTOR ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "SrvSmbQuerySecurityInformation: bad parameter byte or "
                        "return parameter count: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint2(
                "SrvSmbSetFileInformation: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                );
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    securityInformation = SmbGetUlong( &request->SecurityInformation ),

    //
    // Make sure the caller is allowed to query security information on this object
    //
    status = IoCheckFunctionAccess( rfcb->GrantedAccess,
                                    IRP_MJ_QUERY_SECURITY,
                                    0,
                                    0,
                                    &securityInformation,
                                    NULL
                                   );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    //  Attempt to query the security descriptor
    //
    status = NtQuerySecurityObject(
                 rfcb->Lfcb->FileHandle,
                 securityInformation,
                 transaction->OutData,
                 transaction->MaxDataCount,
                 &lengthNeeded
                 );

    SmbPutUlong( &response->LengthNeeded, lengthNeeded );
    transaction->ParameterCount = sizeof( RESP_QUERY_SECURITY_DESCRIPTOR );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        transaction->DataCount = 0;
        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    } else {
        transaction->DataCount =
                RtlLengthSecurityDescriptor( transaction->OutData );
    }

    return SmbTransStatusSuccess;

} // SrvSmbQuerySecurityDescriptor

SMB_TRANS_STATUS
SrvSmbQueryQuota (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an NtQueryQuotaInformationFile request.  This request arrives in an
    Nt Transaction SMB.

--*/
{
    PREQ_NT_QUERY_FS_QUOTA_INFO  request;
    PRESP_NT_QUERY_FS_QUOTA_INFO response;

    NTSTATUS status;
    PTRANSACTION transaction;

    PRFCB  rfcb;
    PVOID  sidList;
    ULONG  sidListLength,startSidLength,startSidOffset;
    PVOID  sidListBuffer = NULL;
    PULONG startSid = NULL;
    ULONG  errorOffset;

    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_NT_QUERY_FS_QUOTA_INFO)transaction->InParameters;
    response = (PRESP_NT_QUERY_FS_QUOTA_INFO)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //
    if ( transaction->ParameterCount < sizeof( *request ) ||
         transaction->MaxParameterCount < sizeof( *response ) ) {

        //
        // Not enough parameter bytes were sent.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    sidListLength  = SmbGetUlong( &request->SidListLength );
    startSidLength = SmbGetUlong( &request->StartSidLength );
    startSidOffset = SmbGetUlong( &request->StartSidOffset );

    //
    // If a Sid List is supplied, make sure it is OK
    //

    if( sidListLength != 0 ) {
        //
        // Length OK?
        //
        if( sidListLength > transaction->DataCount ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SID );
            return SmbTransStatusErrorWithoutData;
        }

        sidListBuffer = transaction->InData;

        //
        // Alignment OK?
        //
        if( (ULONG_PTR)sidListBuffer & (sizeof(ULONG)-1) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SID );
            return SmbTransStatusErrorWithoutData;
        }
        //
        // Content OK?
        //
#if XXX
        status = IopCheckGetQuotaBufferValidity( sidListBuffer, sidListLength, errorOffset );
        if( !NT_SUCCESS( status ) ) {
            SrvSetSmbError( WorkContext, status );
            return SmbTransStatusErrorWithoutData;
        }
#endif
    }

    // The way the transaction buffers are setup the same buffer pointer is used
    // for the incoming data and the outgoing data. This will not work for
    // NtQueryQuotaInformationFile since the underlying driver zeroes the
    // output buffer before processing the input buffer. This presents us with
    // two options ... (1) we can adjust the copying to be staggerred assuming
    // that we can contain both the buffers into the transaction buffer or (2)
    // allocate anew buffer before calling the QueryQuotaInformationFile.
    // The second approach has been implemented since it is well contained.
    // If this turns out to be a performance problem we will revert back to the
    // first option.

    if (sidListLength + startSidLength > 0 &&
        startSidOffset <= transaction->DataCount &&
        startSidLength <= transaction->DataCount &&
        startSidOffset >= sidListLength &&
        startSidOffset + startSidLength <= transaction->DataCount ) {

        sidListBuffer = ALLOCATE_HEAP( startSidOffset + startSidLength, BlockTypeMisc );

        if (sidListBuffer != NULL) {

            RtlCopyMemory(
                sidListBuffer,
                transaction->InData,
                sidListLength);

            if (startSidLength != 0) {
                startSid = (PULONG)((PBYTE)sidListBuffer + startSidOffset);

                RtlCopyMemory(
                    startSid,
                    ((PBYTE)transaction->InData + startSidOffset),
                    startSidLength);

            }
        }
    } else {
        sidListBuffer = NULL;
    }


    iosb.Information = 0;

    //
    // Go ahead and query the quota information!
    //
    status = NtQueryQuotaInformationFile(
                            rfcb->Lfcb->FileHandle,
                            &iosb,
                            transaction->OutData,
                            transaction->MaxDataCount,
                            request->ReturnSingleEntry,
                            sidListBuffer,
                            sidListLength,
                            startSid,
                            request->RestartScan
            );

    if (sidListBuffer != NULL) {
        FREE_HEAP(sidListBuffer);
    }

    //
    // Paranoia
    //
    if( iosb.Information > transaction->MaxDataCount ) {
        iosb.Information = transaction->MaxDataCount;
    }

    transaction->SetupCount = 0;

    SmbPutUlong( &response->Length, (ULONG)iosb.Information );
    transaction->ParameterCount = sizeof( *response );
    transaction->DataCount = (ULONG)iosb.Information;

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    }

    return SmbTransStatusSuccess;

} // SrvSmbQueryQuota


SMB_TRANS_STATUS
SrvSmbSetQuota (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an NtSetQuotaInformationFile request.  This request arrives in an
    Nt Transaction SMB.

--*/
{
    PREQ_NT_SET_FS_QUOTA_INFO request;

    NTSTATUS status;
    PTRANSACTION transaction;

    PRFCB rfcb;
    PVOID buffer,pQuotaInfo=NULL;
    ULONG errorOffset;

    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_NT_SET_FS_QUOTA_INFO)transaction->InParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //
    if ( transaction->ParameterCount < sizeof( *request ) ) {
        //
        // Not enough parameter bytes were sent.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // We do not need to check the buffer for validity, because
    //     IopSetEaOrQuotaInformationFile does this even for kernel mode callers!
    //

    iosb.Information = 0;

    // we have to do allocation here in order to get a QUAD_WORD
    // aligned pointer. This is so because this is a requirement on
    // alpha for the quota buffer

    pQuotaInfo = ALLOCATE_HEAP_COLD( transaction->DataCount, BlockTypeDataBuffer );

    if (pQuotaInfo)
    {
        RtlCopyMemory(
            pQuotaInfo,
            transaction->InData,
            transaction->DataCount
            );

        //
        // Go ahead and set the quota information!
        //
        status = NtSetQuotaInformationFile(
                                rfcb->Lfcb->FileHandle,
                                &iosb,
                                pQuotaInfo,
                                transaction->DataCount
                                );

        if( !NT_SUCCESS( status ) ) {
            SrvSetSmbError( WorkContext, status );
        }

        //
        // Nothing to return to the client except the status
        //
        transaction->SetupCount = 0;
        transaction->ParameterCount = 0;
        transaction->DataCount = 0;

        FREE_HEAP(pQuotaInfo);
    }
    else
    {
        SrvSetSmbError( WorkContext, STATUS_INSUFFICIENT_RESOURCES );
    }
    return SmbTransStatusSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbopen.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbopen.c

Abstract:

    This module contains routines for processing the following SMBs:

        Open
        Open and X
        Create
        Create New
        Create Temporary

    *** The SearchAttributes field in open/create SMBs is always
        ignored.  This duplicates the LM 2.0 server behavior.

Author:

    David Treadwell (davidtr) 23-Nov-1989
    Manny Weiser (mannyw)     15-Apr-1991  (oplock support)

Revision History:

    16-Apr-1991 mannyw



--*/

#include "precomp.h"
#include "smbopen.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBOPEN

//
// in smbtrans.c
//

SMB_STATUS SRVFASTCALL
ExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Local functions
//

VOID
SetEofToMatchAllocation (
    IN HANDLE FileHandle,
    IN ULONG AllocationSize
    );

VOID SRVFASTCALL
RestartOpen (
    PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateOpenResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartOpenAndX (
    PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateOpenAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartOpen2 (
    PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
GenerateOpen2Response (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartNtCreateAndX (
    PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateNtCreateAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartCreateWithSdOrEa (
    PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
GenerateCreateWithSdOrEaResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartSmbCreate(
    IN PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateCreateResponse(
    PWORK_CONTEXT WorkContext,
    NTSTATUS CreateStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbOpen )
#pragma alloc_text( PAGE, RestartOpen )
#pragma alloc_text( PAGE, GenerateOpenResponse )
#pragma alloc_text( PAGE, SrvSmbOpenAndX )
#pragma alloc_text( PAGE, RestartOpenAndX )
#pragma alloc_text( PAGE, GenerateOpenAndXResponse )
#pragma alloc_text( PAGE, SrvSmbOpen2 )
#pragma alloc_text( PAGE, RestartOpen2 )
#pragma alloc_text( PAGE, GenerateOpen2Response )
#pragma alloc_text( PAGE, SrvSmbNtCreateAndX )
#pragma alloc_text( PAGE, RestartNtCreateAndX )
#pragma alloc_text( PAGE, GenerateNtCreateAndXResponse )
#pragma alloc_text( PAGE, SrvSmbCreateWithSdOrEa )
#pragma alloc_text( PAGE, RestartCreateWithSdOrEa )
#pragma alloc_text( PAGE, GenerateCreateWithSdOrEaResponse )
#pragma alloc_text( PAGE, SrvSmbCreate )
#pragma alloc_text( PAGE, SrvSmbCreateTemporary )
#pragma alloc_text( PAGE, SetEofToMatchAllocation )
#pragma alloc_text( PAGE, RestartSmbCreate )
#pragma alloc_text( PAGE, GenerateCreateResponse )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpen (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an Open SMB.  (This is the 'core' Open.)

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_OPEN request;

    NTSTATUS   status    = STATUS_SUCCESS;
    USHORT     access;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Open file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Open file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_OPEN)WorkContext->RequestParameters;

    access = SmbGetUshort( &request->DesiredAccess );

    status = SrvCreateFile(
                 WorkContext,
                 (USHORT)(access & ~SMB_DA_WRITE_THROUGH), // Allow write behind
                 (USHORT)0,                                // SmbFileAttributes
                 SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_FAIL,
                 (ULONG)0,                                 // SmbAllocationSize
                 (PCHAR)(request->Buffer + 1),
                 END_OF_REQUEST_SMB( WorkContext ),
                 NULL,
                 0L,
                 NULL,
                 (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK_NOTIFY_ANY) != 0 ?
                    OplockTypeBatch :
                    (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartOpen
                 );


    if (status == STATUS_OPLOCK_BREAK_IN_PROGRESS) {

        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a response.
        //
        SmbStatus = SmbStatusInProgress;

    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //
        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
    } else {

        // The open has completed.  Generate and send the reply.
        //
        SmbStatus = GenerateOpenResponse( WorkContext, status );
    }
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbOpen


VOID SRVFASTCALL
RestartOpen (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open SMB.  (This is the 'core' Open.)

Arguments:

    WorkContext - A pointer to the work context block for this SMB.

Return Value:

    None.

--*/

{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateOpenResponse(
                    WorkContext,
                    openStatus
                    );

    SrvEndSmbProcessing( WorkContext, smbStatus );
    SrvWmiEndContext(WorkContext);
    return;
} // RestartOpen


SMB_PROCESSOR_RETURN_TYPE
GenerateOpenResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Open SMB.  (This is the 'core' Open.)

Arguments:

    WorkContext -

    Status - The status of the open operation.

Return Value:

    The status of the SMB processing.

--*/

{
    PRESP_OPEN response;
    PREQ_OPEN request;
    NTSTATUS status;

    SRV_FILE_INFORMATION_ABBREVIATED srvFileInformation;
    PRFCB rfcb;
    USHORT access;

    PAGED_CODE( );

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {
        SrvSetSmbError( WorkContext, OpenStatus );
        return SmbStatusSendResponse;
    }

    rfcb = WorkContext->Rfcb;
    response = (PRESP_OPEN)WorkContext->ResponseParameters;
    request = (PREQ_OPEN)WorkContext->RequestParameters;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    //
    // Get the additional information that needs to be returned in the
    // response SMB.  We always open with FILE_READ_ATTRIBUTES, so no
    // access check is required.
    //

    status = SrvQueryInformationFileAbbreviated(
                 rfcb->Lfcb->FileHandle,
                 rfcb->Lfcb->FileObject,
                 &srvFileInformation,
                 FALSE,
                 WorkContext->TreeConnect->Share->ShareType
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "GenerateOpenResponse: SrvQueryInformationFile failed: %X\n",
                        status ));
        }

        SrvCloseRfcb( rfcb );

        SrvSetSmbError( WorkContext, status );
        return SmbStatusSendResponse;
    }

    rfcb->Mfcb->NonpagedMfcb->OpenFileSize = srvFileInformation.DataSize;

    //
    // Give the smart card a chance to get into the act
    //
    if( WorkContext->Endpoint->IsConnectionless && SrvIpxSmartCard.Open != NULL ) {

        PVOID handle;

        IF_DEBUG( SIPX ) {
            KdPrint(( "Trying the smart card for %wZ\n", &rfcb->Mfcb->FileName ));
        }

        if( SrvIpxSmartCard.Open(
            WorkContext->RequestBuffer->Buffer,
            rfcb->Lfcb->FileObject,
            &rfcb->Mfcb->FileName,
            &(WorkContext->ClientAddress->IpxAddress.Address[0].Address[0]),
            rfcb->Lfcb->FileObject->Flags & FO_CACHE_SUPPORTED,
            &handle
            ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "%wZ handled by Smart Card.  Handle %p\n",
                           &rfcb->Mfcb->FileName, handle ));
            }

            rfcb->PagedRfcb->IpxSmartCardContext = handle;
        }
    }

    //
    // Set up fields of response SMB.  Note that we copy the desired
    // access to the granted access in the response.  They must be the
    // same, else the request would have failed.
    //
    // !!! This will not be the case for compatibility mode and FCB opens!
    //

    response->WordCount = 7;
    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUshort( &response->FileAttributes, srvFileInformation.Attributes );
    SmbPutUlong(
        &response->LastWriteTimeInSeconds,
        srvFileInformation.LastWriteTimeInSeconds
        );
    SmbPutUlong( &response->DataSize, srvFileInformation.DataSize.LowPart );
    SmbPutUshort(
        &response->GrantedAccess,
        access );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_OPEN, 0 );

    IF_DEBUG(TRACE2) KdPrint(( "GenerateOpenResponse complete.\n" ));

    return SmbStatusSendResponse;

} // GenerateOpenResponse


SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenAndX (
    SMB_PROCESSOR_PARAMETERS
    )
/*++

Routine Description:

    Processes an OpenAndX SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_OPEN_ANDX request;

    NTSTATUS   status    = STATUS_SUCCESS;
    USHORT     access;
    SMB_STATUS smbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN_AND_X;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Open file and X request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Open file and X request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // If we are not on a blocking thread and we don't have a license
    //  from the license server, shift the request over to the blocking work
    //  queue since acquiring a license is an expensive operation and we don't
    //  want to congest our nonblocking worker threads
    //
    if( WorkContext->UsingBlockingThread == 0 ) {

        PSESSION session;
        PTREE_CONNECT treeConnect;

        status = SrvVerifyUidAndTid(
                    WorkContext,
                    &session,
                    &treeConnect,
                    ShareTypeWild
                    );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbOpenAndX: Invalid UID or TID\n" ));
            }
            smbStatus = GenerateOpenAndXResponse( WorkContext, status );
            goto Cleanup;
        }

        if( session->IsLSNotified == FALSE ) {

            //
            // Insert the work item at the tail of the blocking work queue.
            //
            SrvInsertWorkQueueTail(
                &SrvBlockingWorkQueue,
                (PQUEUEABLE_BLOCK_HEADER)WorkContext
            );

            smbStatus = SmbStatusInProgress;
            goto Cleanup;
        }
    }

    request = (PREQ_OPEN_ANDX)WorkContext->RequestParameters;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    status = SrvCreateFile(
                 WorkContext,
                 access,
                 SmbGetUshort( &request->FileAttributes ),
                 SmbGetUshort( &request->OpenFunction ),
                 SmbGetUlong( &request->AllocationSize ),
                 (PCHAR)request->Buffer,
                 END_OF_REQUEST_SMB( WorkContext ),
                 NULL,
                 0L,
                 NULL,
                 (SmbGetUshort(&request->Flags) & SMB_OPEN_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (SmbGetUshort(&request->Flags) & SMB_OPEN_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartOpenAndX
                 );

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        smbStatus = SmbStatusInProgress;

    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToBlockingThread( WorkContext );
        smbStatus = SmbStatusInProgress;

    } else {

        //
        // The open has completed.  Generate and send the reply.
        //

        smbStatus = GenerateOpenAndXResponse( WorkContext, status );

    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return smbStatus;
} // SrvSmbOpenAndX


VOID SRVFASTCALL
RestartOpenAndX (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open and X SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN_AND_X;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

        if( NT_SUCCESS( openStatus ) ) {
            //
            // It's obvious that the file already existed, because we've
            //  been working on an oplock break.  So set the
            //  IoStatus.Information field correctly.
            //
            WorkContext->Irp->IoStatus.Information = FILE_OPENED;
        }

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateOpenAndXResponse(
                    WorkContext,
                    openStatus
                    );

    if ( smbStatus == SmbStatusMoreCommands ) {

        SrvProcessSmb( WorkContext );

    } else {

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    }
    SrvWmiEndContext(WorkContext);

    return;

} // RestartOpenAndX


SMB_PROCESSOR_RETURN_TYPE
GenerateOpenAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Open and X SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

--*/

{
    PREQ_OPEN_ANDX request;
    PRESP_OPEN_ANDX response;

    SRV_FILE_INFORMATION_ABBREVIATED srvFileInformation;
    BOOLEAN reqAdditionalInformation;
    BOOLEAN reqExtendedResponse;
    PRFCB rfcb;
    PLFCB lfcb;
    PIO_STATUS_BLOCK ioStatusBlock;
    UCHAR nextCommand;
    USHORT reqAndXOffset;
    USHORT access;
    USHORT action = 0;
    OPLOCK_TYPE oplockType;

    NTSTATUS status;

    PAGED_CODE( );

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {
        SrvSetSmbError( WorkContext, OpenStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        return SmbStatusSendResponse;
    }

    request = (PREQ_OPEN_ANDX)WorkContext->RequestParameters;
    response = (PRESP_OPEN_ANDX)WorkContext->ResponseParameters;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use
    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    reqExtendedResponse = (BOOLEAN)( (SmbGetUshort(&request->Flags) &
            SMB_OPEN_EXTENDED_RESPONSE) != 0);

    //
    // Attempt to acquire the oplock.
    //

    if ( WorkContext->TreeConnect->Share->ShareType != ShareTypePrint ) {

        if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPBATCH) != 0 ) {
            oplockType = OplockTypeBatch;
        } else if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPLOCK) != 0 ) {
            oplockType = OplockTypeExclusive;
        } else {
            oplockType = OplockTypeServerBatch;
        }

        if ( SrvRequestOplock( WorkContext, &oplockType, FALSE ) ) {

            //
            // The oplock was granted.  Save in action so that we tell
            // the client he has an oplock and update statistics.
            //

            action = SMB_OACT_OPLOCK;

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );

        } else {

            //
            // The oplock request was denied.  Update statistics.
            //

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );

        }
    }

    //
    // If the file was created, set the EOF location to be the same as
    // the size of the file.  This is necessary for compatibility with
    // OS/2, which only has EOF, not a separate allocation size.
    //
    ioStatusBlock = &WorkContext->Irp->IoStatus;

    if ( (ioStatusBlock->Information == FILE_CREATED) ||
         (ioStatusBlock->Information == FILE_OVERWRITTEN) ) {

        //
        // Extending EOF is only legal if the client has write access
        // to the file.  If the client doesn't have write access, don't
        // extend the file.
        //
        // *** This is an incompatibility with OS/2.

        if ( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {
            SetEofToMatchAllocation(
                lfcb->FileHandle,
                SmbGetUlong( &request->AllocationSize )
                );
        } else {
            SrvStatistics.GrantedAccessErrors++;
        }
    }

    //
    // If the consumer requested additional information, find it now.
    //

    reqAdditionalInformation = (BOOLEAN)( (SmbGetUshort(&request->Flags) &
            SMB_OPEN_QUERY_INFORMATION) != 0);

    if ( reqAdditionalInformation ||
        ( !rfcb->WriteAccessGranted && rfcb->AppendAccessGranted) ) {

        //
        // We always open with at least FILE_READ_ATTRIBUTES, so no
        // access check is needed.
        //

        status = SrvQueryInformationFileAbbreviated(
                     lfcb->FileHandle,
                     lfcb->FileObject,
                     &srvFileInformation,
                     reqExtendedResponse,
                     WorkContext->TreeConnect->Share->ShareType
                     );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbOpenAndX: SrvQueryInformationFile failed: "
                            "%X\n", status ));
            }

            SrvCloseRfcb( rfcb );

            SrvSetSmbError( WorkContext, status );
            return SmbStatusSendResponse;
        }

        rfcb->Mfcb->NonpagedMfcb->OpenFileSize = srvFileInformation.DataSize;
    }

    //
    // Give the smart card a chance to get into the act
    //
    if( WorkContext->Endpoint->IsConnectionless && SrvIpxSmartCard.Open != NULL ) {

        PVOID handle;

        IF_DEBUG( SIPX ) {
            KdPrint(( "Trying the smart card for %wZ\n", &rfcb->Mfcb->FileName ));
        }

        if( SrvIpxSmartCard.Open(
            WorkContext->RequestBuffer->Buffer,
            rfcb->Lfcb->FileObject,
            &rfcb->Mfcb->FileName,
            &(WorkContext->ClientAddress->IpxAddress.Address[0].Address[0]),
            rfcb->Lfcb->FileObject->Flags & FO_CACHE_SUPPORTED,
            &handle
            ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "%wZ handled by Smart Card.  Handle %p\n",
                           &rfcb->Mfcb->FileName, handle ));
            }

            rfcb->PagedRfcb->IpxSmartCardContext = handle;
        }
    }

    //
    // Set up response SMB.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    if (reqExtendedResponse) {
        NTSTATUS ExtendedResponseStatus;

        PRESP_EXTENDED_OPEN_ANDX ExtendedResponse;

        ExtendedResponse = (PRESP_EXTENDED_OPEN_ANDX)response;

        ExtendedResponseStatus = SrvUpdateMaximalAccessRightsInResponse(
                                     WorkContext,
                                     &ExtendedResponse->MaximalAccessRights,
                                     &ExtendedResponse->GuestMaximalAccessRights);

        // Fall back to regular response if there was an error in obtainaing
        // the maximal access rights
        reqExtendedResponse = (ExtendedResponseStatus == STATUS_SUCCESS);
    }

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;

    if (!reqExtendedResponse) {
        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_OPEN_ANDX,
                0
                )
            );

        response->WordCount = 15;
    } else {
        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_EXTENDED_OPEN_ANDX,
                0
                )
            );

        response->WordCount = 19;
    }

    SmbPutUshort( &response->Fid, rfcb->Fid );

    //
    // If the consumer requested additional information, set appropiate
    // fields, else set the fields to zero.
    //

    if ( reqAdditionalInformation ) {

        SmbPutUshort(
            &response->FileAttributes,
            srvFileInformation.Attributes
            );
        SmbPutUlong(
            &response->LastWriteTimeInSeconds,
            srvFileInformation.LastWriteTimeInSeconds
            );
        SmbPutUlong( &response->DataSize, srvFileInformation.DataSize.LowPart );

        access &= SMB_DA_SHARE_MASK;

        if( rfcb->ReadAccessGranted && (rfcb->WriteAccessGranted || rfcb->AppendAccessGranted) ) {
            access |= SMB_DA_ACCESS_READ_WRITE;
        } else if( rfcb->ReadAccessGranted ) {
            access |= SMB_DA_ACCESS_READ;
        } else if( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {
            access |= SMB_DA_ACCESS_WRITE;
        }

        SmbPutUshort( &response->GrantedAccess, access );
        SmbPutUshort( &response->FileType, srvFileInformation.Type );
        SmbPutUshort( &response->DeviceState, srvFileInformation.HandleState );

    } else {

        RtlZeroMemory( (PVOID)&response->FileAttributes, 16 );

    }

    //
    // Bit field mapping of Action:
    //
    //    Lrrr rrrr rrrr rrOO
    //
    // where:
    //
    //    L - Lock (single-user total file lock status)
    //       0 - file opened by another user
    //       1 - file is opened only by this user at the present time
    //
    //    O - Open (action taken on open)
    //       1 - the file existed and was opened
    //       2 - the file did not exist but was created
    //       3 - the file existed and was truncated
    //

    switch ( ioStatusBlock->Information ) {

    case FILE_OPENED:

        action |= SMB_OACT_OPENED;
        break;

    case FILE_CREATED:

        action |= SMB_OACT_CREATED;
        break;

    case FILE_OVERWRITTEN:

        action |= SMB_OACT_TRUNCATED;
        break;

    default:

        IF_DEBUG(ERRORS) {
            KdPrint(( "Unknown Information value in IO status block: 0x%p\n",
                        (PVOID)(ioStatusBlock->Information) ));
        }

    }

    SmbPutUshort( &response->Action, action );

    SmbPutUlong( &response->ServerFid, (ULONG)0 );

    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_IOCTL:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbOpenAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        //
        // Return an error indicating that the followon command was bad.
        // Note that the open is still considered successful, so the
        // file remains open.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbStatusSendResponse;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        return SmbStatusMoreCommands;

    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbOpenAndX complete.\n" ));
    return SmbStatusSendResponse;

} // GenerateOpenAndXResponse


SMB_TRANS_STATUS
SrvSmbOpen2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an Open2 SMB.  This request arrives in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/

{
    PREQ_OPEN2 request;
    PRESP_OPEN2 response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    USHORT access;
    PTRANSACTION transaction;

    ULONG eaErrorOffset = 0;
    USHORT os2EaErrorOffset = 0;
    PFILE_FULL_EA_INFORMATION ntFullEa;
    ULONG ntFullEaBufferLength;
    PFEALIST feaList;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN2;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_OPEN2)transaction->InParameters;
    response = (PRESP_OPEN2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount < sizeof(REQ_OPEN2)) ||
         (transaction->MaxParameterCount < sizeof(RESP_OPEN2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS)
            KdPrint(( "SrvSmbOpen2: bad parameter byte counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError2( WorkContext, STATUS_INVALID_SMB, TRUE );
        status = STATUS_INVALID_SMB;
        goto err_exit;
    }

    //
    // Convert the EA list to NT style.
    //

    eaErrorOffset = 0;
    feaList = (PFEALIST)transaction->InData;

    //
    // Make sure that the value in Fealist->cbList is legitimate and that
    // there is at least sufficient data for a single EA.
    //
    // This code will fail if no EA list is indicated.  Don't know
    // if this is correct, but it was the previous behavior so
    // it's been enforced.
    //

    if ( transaction->DataCount <= sizeof(FEALIST) ||
         SmbGetUlong( &feaList->cbList ) <= sizeof(FEALIST) ||
         SmbGetUlong( &feaList->cbList ) > transaction->DataCount) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "EA list size bad: size =  %ld, data sent was %ld\n",
                          SmbGetUlong( &feaList->cbList ), transaction->DataCount ));
        }
        SrvSetSmbError2( WorkContext, STATUS_OS2_EA_LIST_INCONSISTENT, TRUE );
        status = STATUS_OS2_EA_LIST_INCONSISTENT;
        goto err_exit;
    }

    //
    // Convert the FEALIST to NT style.
    //

    status = SrvOs2FeaListToNt(
                 feaList,
                 &ntFullEa,
                 &ntFullEaBufferLength,
                 &os2EaErrorOffset
                 );

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
        goto err_exit;
    }

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    status = SrvCreateFile(
                 WorkContext,
                 access,
                 SmbGetUshort( &request->FileAttributes ),
                 SmbGetUshort( &request->OpenFunction ),
                 SmbGetUlong( &request->AllocationSize ),
                 (PCHAR)request->Buffer,
                 END_OF_TRANSACTION_PARAMETERS( transaction ),
                 ntFullEa,
                 ntFullEaBufferLength,
                 &eaErrorOffset,
                 (SmbGetUshort(&request->Flags) & SMB_OPEN_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (SmbGetUshort(&request->Flags) & SMB_OPEN_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartOpen2
                 );

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        //
        // Save a pointer to the full ea structure
        //

        WorkContext->Parameters2.Open.NtFullEa = ntFullEa;
        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //
        // We need to free the EA buffer in this case.
        //

        DEALLOCATE_NONPAGED_POOL(ntFullEa);
        WorkContext->FspRestartRoutine = (PRESTART_ROUTINE)ExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    } else {

        //
        // Save a pointer to the full ea structure
        //

        WorkContext->Parameters2.Open.NtFullEa = ntFullEa;
        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        //
        // The open has completed.  Generate and send the reply.
        //

        SmbStatus = GenerateOpen2Response( WorkContext, status );
        goto Cleanup;
    }

err_exit:

    RtlZeroMemory( (PVOID)&response->Fid, 24 );
    SmbPutUshort( &response->EaErrorOffset, os2EaErrorOffset );
    SmbPutUlong( &response->EaLength, 0 );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_OPEN2);
    transaction->DataCount = 0;

    SmbStatus = SmbTransStatusErrorWithData;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbOpen2


VOID SRVFASTCALL
RestartOpen2 (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open2 SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN2;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

        if( NT_SUCCESS( openStatus ) ) {
            //
            // It's obvious that the file already existed, because we've
            //  been working on an oplock break.  So set the
            //  IoStatus.Information field correctly.
            //
            WorkContext->Irp->IoStatus.Information = FILE_OPENED;
        }

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateOpen2Response(
                    WorkContext,
                    openStatus
                    );


    SrvCompleteExecuteTransaction( WorkContext, smbStatus );

    SrvWmiEndContext(WorkContext);
    return;

} // RestartOpen2


SMB_TRANS_STATUS
GenerateOpen2Response (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Open and X SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

--*/

{
    PREQ_OPEN2 request;
    PRESP_OPEN2 response;

    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;
    BOOLEAN reqAdditionalInformation;
    SRV_FILE_INFORMATION_ABBREVIATED srvFileInformation;
    BOOLEAN reqEaLength;
    FILE_EA_INFORMATION fileEaInformation;
    USHORT access;
    USHORT action = 0;
    PTRANSACTION transaction;

    ULONG eaErrorOffset = 0;
    USHORT os2EaErrorOffset = 0;
    PFILE_FULL_EA_INFORMATION ntFullEa;
    PFEALIST feaList;
    OPLOCK_TYPE oplockType;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_OPEN2)transaction->InParameters;
    response = (PRESP_OPEN2)transaction->OutParameters;

    feaList = (PFEALIST)transaction->InData;
    ntFullEa = WorkContext->Parameters2.Open.NtFullEa;
    eaErrorOffset = WorkContext->Parameters2.Open.EaErrorOffset;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {

        SrvSetSmbError( WorkContext, OpenStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS.
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        //
        // If an EA error offset was returned, convert it from an offset
        // into the NT full EA list to an offset in the OS/2 1.2 FEALIST.
        //

        if ( eaErrorOffset != 0 ) {
            os2EaErrorOffset = SrvGetOs2FeaOffsetOfError(
                                   eaErrorOffset,
                                   ntFullEa,
                                   feaList
                                   );
        }


        DEALLOCATE_NONPAGED_POOL( ntFullEa );
        goto err_exit;
    }

    DEALLOCATE_NONPAGED_POOL( ntFullEa );

    //
    // If the file was created, set the EOF location to be the same as
    // the size of the file.  This is necessary for compatibility with
    // OS/2, which only has EOF, not a separate allocation size.
    //

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    if ( (WorkContext->Irp->IoStatus.Information == FILE_CREATED) ||
         (WorkContext->Irp->IoStatus.Information == FILE_OVERWRITTEN) ) {


        //
        // Extending EOF is only legal if the client has write access
        // to the file.  If the client doesn't have write access, don't
        // extend the file.
        //
        // *** This is an incompatibility with OS/2.

        if ( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {
            SetEofToMatchAllocation(
                lfcb->FileHandle,
                SmbGetUlong( &request->AllocationSize )
                );
        } else {
            SrvStatistics.GrantedAccessErrors++;
        }
    }

    //
    // If the consumer requested additional information, find it now.
    //

    reqAdditionalInformation =
        (BOOLEAN)((SmbGetUshort( &request->Flags ) &
            SMB_OPEN_QUERY_INFORMATION) != 0);
    reqEaLength =
        (BOOLEAN)((SmbGetUshort( &request->Flags ) &
            SMB_OPEN_QUERY_EA_LENGTH) != 0);

    if ( reqAdditionalInformation ||
        (!rfcb->WriteAccessGranted && rfcb->AppendAccessGranted) ) {

        //
        // We always open with at least FILE_READ_ATTRIBUTES, so no
        // access check is needed.
        //

        status = SrvQueryInformationFileAbbreviated(
                     lfcb->FileHandle,
                     lfcb->FileObject,
                     &srvFileInformation,
                     FALSE,
                     WorkContext->TreeConnect->Share->ShareType
                     );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbOpen2: SrvQueryInformationFile failed: "
                            "%X\n", status ));
            }

            SrvCloseRfcb( rfcb );

            SrvSetSmbError2( WorkContext, status, TRUE );
            goto err_exit;
        }

        rfcb->Mfcb->NonpagedMfcb->OpenFileSize = srvFileInformation.DataSize;
    }

    if ( reqEaLength ) {

        IO_STATUS_BLOCK eaIoStatusBlock;

        status = NtQueryInformationFile(
                     lfcb->FileHandle,
                     &eaIoStatusBlock,
                     &fileEaInformation,
                     sizeof(FILE_EA_INFORMATION),
                     FileEaInformation
                     );

        if ( NT_SUCCESS(status) ) {
            status = eaIoStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbOpen2: NtQueryInformationFile (file information)"
                    "returned %X",
                status,
                NULL
                );

            SrvCloseRfcb( rfcb );

            SrvSetSmbError2( WorkContext, status, TRUE );
            goto err_exit;
        } else {

            //
            // Adjust the EA size.  If there are no EAs, OS/2 expects
            // EA size = 4.
            //

            if (fileEaInformation.EaSize == 0) {
                fileEaInformation.EaSize = 4;
            }
        }

    } else {

        fileEaInformation.EaSize = 0;
    }

    //
    // Attempt to acquire the oplock.
    //

    if ( WorkContext->TreeConnect->Share->ShareType != ShareTypePrint ) {

        if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPBATCH) != 0 ) {
            oplockType = OplockTypeBatch;
        } else if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPLOCK) != 0 ) {
            oplockType = OplockTypeExclusive;
        } else {
            oplockType = OplockTypeServerBatch;
        }

        if ( SrvRequestOplock( WorkContext, &oplockType, FALSE ) ) {
            action = SMB_OACT_OPLOCK;
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );
        } else {
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );
        }
    }

    //
    // Set up response SMB.
    //

    SmbPutUshort( &response->Fid, rfcb->Fid );

    //
    // If the consumer requested additional information, set appropiate
    // fields, else set the fields to zero.
    //

    if ( reqAdditionalInformation ) {

        SmbPutUshort(
            &response->FileAttributes,
            srvFileInformation.Attributes
            );
        SmbPutUlong( &response->DataSize, srvFileInformation.DataSize.LowPart );
        SmbPutUshort( &response->GrantedAccess, access );
        SmbPutUshort( &response->FileType, srvFileInformation.Type );
        SmbPutUshort( &response->DeviceState, srvFileInformation.HandleState );

    } else {

        RtlZeroMemory( (PVOID)&response->FileAttributes, 16 );

    }

    //
    // Bit field mapping of Action:
    //
    //    Lrrr rrrr rrrr rrOO
    //
    // where:
    //
    //    L - Lock (single-user total file lock status)
    //       0 - file opened by another user
    //       1 - file is opened only by this user at the present time
    //
    //    O - Open (action taken on open)
    //       1 - the file existed and was opened
    //       2 - the file did not exist but was created
    //       3 - the file existed and was truncated
    //

    switch ( WorkContext->Irp->IoStatus.Information ) {

    case FILE_OPENED:

        action |= SMB_OACT_OPENED;
        break;

    case FILE_CREATED:

        action |= SMB_OACT_CREATED;
        break;

    case FILE_OVERWRITTEN:

        action |= SMB_OACT_TRUNCATED;
        break;

    default:

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbOpen2: Unknown Information value in IO status"
                "block: 0x%lx\n",
            WorkContext->Irp->IoStatus.Information,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_IO_CREATE_FILE,
                              (ULONG)WorkContext->Irp->IoStatus.Information );

    }

    SmbPutUshort( &response->Action, action );

    SmbPutUlong( &response->ServerFid, (ULONG)0 );

    SmbPutUshort( &response->EaErrorOffset, 0 );
    SmbPutUlong( &response->EaLength, fileEaInformation.EaSize );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_OPEN2);
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbOpen2 complete.\n" ));
    return SmbTransStatusSuccess;

err_exit:

    RtlZeroMemory( (PVOID)&response->Fid, 24 );
    SmbPutUshort( &response->EaErrorOffset, os2EaErrorOffset );
    SmbPutUlong( &response->EaLength, 0 );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_OPEN2);
    transaction->DataCount = 0;

    return SmbTransStatusErrorWithData;

} // GenerateOpen2Response


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCreateAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an NtCreateAndX SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_NT_CREATE_ANDX request;
#ifdef INCLUDE_SMB_IFMODIFIED
    PREQ_NT_CREATE_IF_MODIFIED_ANDX requestIfModified = NULL;
    BOOLEAN ifModifiedCheck = FALSE;
#endif
    ULONG flags;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    LARGE_INTEGER allocationSize;
    UNICODE_STRING fileName;
    PUCHAR name;
    USHORT nameLength;
    SECURITY_QUALITY_OF_SERVICE qualityOfService;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NT_CREATE_AND_X;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Create file and X request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Create file and X request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_NT_CREATE_ANDX)WorkContext->RequestParameters;

    allocationSize.HighPart = SmbGetUlong( &request->AllocationSize.HighPart );
    allocationSize.LowPart = SmbGetUlong( &request->AllocationSize.LowPart );

    flags = SmbGetUlong( &request->Flags );

#ifdef INCLUDE_SMB_IFMODIFIED

    if (IS_POSTNT5_DIALECT( WorkContext->Connection->SmbDialect )) {

        ifModifiedCheck = ((flags & NT_CREATE_IFMODIFIED_REQUEST) != 0 );

        if (ifModifiedCheck) {

            requestIfModified = (PREQ_NT_CREATE_IF_MODIFIED_ANDX) request;
        }
    }
#endif

    //
    // First verify that the file path name does not extend beyond the
    // end of the SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    //
    //  if this request has IfModifiedSince fields, the request is of a
    //  slightly different format, the Name field is lower.
    //

#ifdef INCLUDE_SMB_IFMODIFIED
    if (requestIfModified != NULL) {
        name = (PUCHAR)requestIfModified->Buffer;
    } else {
        name = (PUCHAR)request->Buffer;
    }
#else
    name = (PUCHAR)request->Buffer;
#endif
    if ( isUnicode ) {
        name = ALIGN_SMB_WSTR( name );
    }

    nameLength = SmbGetUshort( &request->NameLength );
    if ( name + nameLength > ( END_OF_REQUEST_SMB( WorkContext ) + 1 ) ) {
        status    = STATUS_INVALID_SMB;
        SmbStatus = GenerateNtCreateAndXResponse( WorkContext, STATUS_INVALID_SMB );
        goto Cleanup;
    }

    //
    // Convert the file name to a Unicode string.
    //

    status = SrvMakeUnicodeString(
                 isUnicode,
                 &fileName,
                 name,
                 &nameLength
                 );

    if ( !NT_SUCCESS( status ) ) {
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = GenerateNtCreateAndXResponse(
                   WorkContext,
                   STATUS_INSUFF_SERVER_RESOURCES
                   );
        goto Cleanup;
    }

    //
    // *** We always ask for STATIC tracking, not DYNAMIC, because we
    //     don't support dynamic tracking over the net yet.
    //
    // !!! Note that once we support dynamic tracking, we MUST CHANGE
    //     THE NAMED PIPE PROCESSING to not do writes/transceives at DPC
    //     level, because the NPFS needs to call SeCreateClientSecurity
    //     on every write when dynamic tracking is selected!
    //

    qualityOfService.Length = sizeof( qualityOfService );
    qualityOfService.ImpersonationLevel =
        SmbGetUlong( &request->ImpersonationLevel );
    qualityOfService.ContextTrackingMode = FALSE;
    //qualityOfService.ContextTrackingMode = (BOOLEAN)
    //    (request->SecurityFlags & SMB_SECURITY_DYNAMIC_TRACKING);
    qualityOfService.EffectiveOnly = (BOOLEAN)
        (request->SecurityFlags & SMB_SECURITY_EFFECTIVE_ONLY);

    status = SrvNtCreateFile(
                 WorkContext,
                 SmbGetUlong( &request->RootDirectoryFid ),
                 SmbGetUlong( &request->DesiredAccess ),
                 allocationSize,
                 SmbGetUlong( &request->FileAttributes ),
                 SmbGetUlong( &request->ShareAccess ),
                 SmbGetUlong( &request->CreateDisposition ),
                 SmbGetUlong( &request->CreateOptions),
                 NULL,
                 &fileName,
                 NULL,
                 0,
                 NULL,
                 flags,
                 &qualityOfService,
#ifdef INCLUDE_SMB_IFMODIFIED
                 (flags & NT_CREATE_REQUEST_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (flags & NT_CREATE_REQUEST_OPLOCK) != 0 ?
#else
                 (request->Flags & NT_CREATE_REQUEST_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (request->Flags & NT_CREATE_REQUEST_OPLOCK) != 0 ?
#endif
                    OplockTypeExclusive : OplockTypeServerBatch,
                 RestartNtCreateAndX
                 );

    //
    // Free the unicode file name buffer if it has been allocated.
    //

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &fileName );
    }

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        SmbStatus = SmbStatusInProgress;
    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
    } else {

        //
        // The open has completed.  Generate and send the reply.
        //

        SmbStatus = GenerateNtCreateAndXResponse( WorkContext, status );
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbNtCreateAndX


VOID SRVFASTCALL
RestartNtCreateAndX (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Nt Create and X SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NT_CREATE_AND_X;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateNtCreateAndXResponse(
                    WorkContext,
                    openStatus
                    );

    if ( smbStatus == SmbStatusMoreCommands ) {

        SrvProcessSmb( WorkContext );

    } else {

#ifdef INCLUDE_SMB_IFMODIFIED
        SrvEndSmbProcessing( WorkContext, smbStatus );
#else
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
#endif

    }
    SrvWmiEndContext(WorkContext);
    return;

} // RestartNtCreateAndX


SMB_PROCESSOR_RETURN_TYPE
GenerateNtCreateAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Nt Create and X SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

Notes:



--*/

{
    PREQ_NT_CREATE_ANDX request;
    PRESP_NT_CREATE_ANDX response;

#ifdef INCLUDE_SMB_IFMODIFIED
    PREQ_NT_CREATE_IF_MODIFIED_ANDX requestIfModified = NULL;
    BOOLEAN GenerateExtendedResponse2 = FALSE;
    BOOLEAN extendedRequested2 = FALSE;
    BOOLEAN ifModifiedCheck = FALSE;
#ifdef INCLUDE_SMB_PERSISTENT
    BOOLEAN persistentHandle = FALSE;
#endif
    ULONG flags;
    BOOLEAN byteCountSet = FALSE;

    LARGE_INTEGER ourFileRefNumber;
    LARGE_INTEGER ourUsnValue;
#endif

    SMB_PROCESSOR_RETURN_LOCAL rc;
    BOOLEAN GenerateExtendedResponse = FALSE;

    SRV_NT_FILE_INFORMATION srvNtFileInformation;
    PRFCB rfcb;
    PIO_STATUS_BLOCK ioStatusBlock;
    UCHAR nextCommand;
    USHORT reqAndXOffset;
    OPLOCK_TYPE oplockType;
    UCHAR oplockLevel;
    BOOLEAN allowLevelII;
    BOOLEAN extendedRequested;
    ULONG CreateAction = (ULONG)WorkContext->Irp->IoStatus.Information;

    ULONG desiredAccess;

    NTSTATUS status;

    PAGED_CODE( );

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {
        SrvSetSmbError( WorkContext, OpenStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        return SmbStatusSendResponse;
    }

    request = (PREQ_NT_CREATE_ANDX)WorkContext->RequestParameters;
    response = (PRESP_NT_CREATE_ANDX)WorkContext->ResponseParameters;

#ifdef INCLUDE_SMB_IFMODIFIED

    //
    //  these are the USN journal values for this file iff we need them.
    //

    ourFileRefNumber.QuadPart = 0;
    ourUsnValue.QuadPart = 0;

    flags = SmbGetUlong( &request->Flags );

    //
    // Does the client want extended info in the response?
    //
    extendedRequested = ((flags & NT_CREATE_REQUEST_EXTENDED_RESPONSE) != 0 );

    if (IS_POSTNT5_DIALECT( WorkContext->Connection->SmbDialect )) {

        extendedRequested2 = ((flags & NT_CREATE_REQUEST_EXTENDED_RESPONSE2) != 0 );

#ifdef INCLUDE_SMB_PERSISTENT
        persistentHandle = ((flags & NT_CREATE_PERSISTANT_HANDLE) != 0 );
#endif

        ifModifiedCheck = ((flags & NT_CREATE_IFMODIFIED_REQUEST) != 0 );

        if (ifModifiedCheck) {

            requestIfModified = (PREQ_NT_CREATE_IF_MODIFIED_ANDX) request;
        }
    }
#else

    //
    // Does the client want extended info in the response?
    //
    extendedRequested = ((request->Flags & NT_CREATE_REQUEST_EXTENDED_RESPONSE) != 0 );
#endif

    desiredAccess = SmbGetUlong( &request->DesiredAccess );

    rfcb = WorkContext->Rfcb;

    //
    // Attempt to acquire the oplock.
    //

    if ( desiredAccess != DELETE &&
        !(request->CreateOptions & FILE_DIRECTORY_FILE) ) {

        if ( request->Flags & NT_CREATE_REQUEST_OPLOCK ) {
            allowLevelII = CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, WorkContext->Connection );
            if ( request->Flags & NT_CREATE_REQUEST_OPBATCH ) {
                oplockType = OplockTypeBatch;
                oplockLevel = SMB_OPLOCK_LEVEL_BATCH;
            } else {
                oplockType = OplockTypeExclusive;
                oplockLevel = SMB_OPLOCK_LEVEL_EXCLUSIVE;
            }
        } else {
            allowLevelII = FALSE;
            oplockType = OplockTypeServerBatch;
            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
        }

        if( SrvRequestOplock( WorkContext, &oplockType, allowLevelII ) ) {

            //
            // The oplock was granted.  Check to see if it was a level 2.
            //

            if ( oplockType == OplockTypeShareRead ) {
                oplockLevel = SMB_OPLOCK_LEVEL_II;
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );

        } else {

            //
            // The oplock request was denied.
            //

            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );

        }

    } else {

        oplockLevel = SMB_OPLOCK_LEVEL_NONE;

    }

    //
    // If the file was created, set the EOF location to be the same as
    // the size of the file.  This is necessary for compatibility with
    // OS/2, which only has EOF, not a separate allocation size.
    //

    ioStatusBlock = &WorkContext->Irp->IoStatus;

    //
    // We always open with at least FILE_READ_ATTRIBUTES, so no
    // access check is needed.
    //

    status = SrvQueryNtInformationFile(
                 rfcb->Lfcb->FileHandle,
                 rfcb->Lfcb->FileObject,
                 rfcb->ShareType,
                 extendedRequested,
                 &srvNtFileInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbNtCreateAndX: SrvQueryNtInformationFile failed: "
                        "%X\n", status ));
        }

        SrvCloseRfcb( rfcb );

        SrvSetSmbError( WorkContext, status );
        return SmbStatusSendResponse;
    }

    //
    // Save parts of the file info in the MFCB for fast tests on Compressed
    // operations.
    //

    rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart =
                            srvNtFileInformation.NwOpenInfo.EndOfFile.QuadPart;
    rfcb->Mfcb->NonpagedMfcb->OpenFileAttributes =
                            srvNtFileInformation.NwOpenInfo.FileAttributes;

    //
    //  if the client is doing an "IfModifiedSince" open, then we need to check
    //  the following fields out of the request:
    //
    //  CreationTime
    //  LastWriteTime
    //  ChangeTime
    //  EndOfFile
    //  FileAttributes
    //  UsnValue / USN file reference number
    //
    //  if they all match with what is currently set for the file, we close
    //  the file and return STATUS_FILE_CLOSED.
    //

#ifdef INCLUDE_SMB_IFMODIFIED
    if (ifModifiedCheck) {

        LARGE_INTEGER usnValue;
        LARGE_INTEGER fileRefNumber;
        LARGE_INTEGER endOfFile;
        TIME creationTime;
        TIME lastWriteTime;
        TIME changeTime;
        ULONG fileAttributes;
        ULONG ourAttributes;

        endOfFile.HighPart = SmbGetUlong( &requestIfModified->EndOfFile.HighPart );
        endOfFile.LowPart = SmbGetUlong( &requestIfModified->EndOfFile.LowPart );

        creationTime.HighPart = SmbGetUlong( &requestIfModified->CreationTime.HighPart );
        creationTime.LowPart = SmbGetUlong( &requestIfModified->CreationTime.LowPart );

        lastWriteTime.HighPart = SmbGetUlong( &requestIfModified->LastWriteTime.HighPart );
        lastWriteTime.LowPart = SmbGetUlong( &requestIfModified->LastWriteTime.LowPart );

        changeTime.HighPart = SmbGetUlong( &requestIfModified->ChangeTime.HighPart );
        changeTime.LowPart = SmbGetUlong( &requestIfModified->ChangeTime.LowPart );

        usnValue.HighPart = SmbGetUlong( &requestIfModified->UsnValue.HighPart );
        usnValue.LowPart = SmbGetUlong( &requestIfModified->UsnValue.LowPart );

        fileRefNumber.HighPart = SmbGetUlong( &requestIfModified->FileReferenceNumber.HighPart );
        fileRefNumber.LowPart = SmbGetUlong( &requestIfModified->FileReferenceNumber.LowPart );

        //
        //  we ignore the NORMAL and ARCHIVE attributes because the client
        //  doesn't care if the these attributes have changed.
        //

        fileAttributes = SmbGetUlong( &requestIfModified->FileAttributes );
        fileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        fileAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;

        ourAttributes = srvNtFileInformation.NwOpenInfo.FileAttributes;
        ourAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        ourAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;

        if ( usnValue.QuadPart != 0 || fileRefNumber.QuadPart != 0 ) {

            status = SrvIssueQueryUsnInfoRequest( rfcb,
                                                  FALSE,
                                                  &ourUsnValue,
                                                  &ourFileRefNumber );

            if (! NT_SUCCESS(status)) {
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbNtCreateAndX: Query USN info (1) failed: 0x%X for handle %u\n",
                                status, rfcb->Lfcb->FileObject ));
                }
            }
        }

        if (creationTime.QuadPart == srvNtFileInformation.NwOpenInfo.CreationTime.QuadPart &&
            lastWriteTime.QuadPart == srvNtFileInformation.NwOpenInfo.LastWriteTime.QuadPart &&
            changeTime.QuadPart == srvNtFileInformation.NwOpenInfo.ChangeTime.QuadPart &&
            endOfFile.QuadPart == srvNtFileInformation.NwOpenInfo.EndOfFile.QuadPart &&
            usnValue.QuadPart == ourUsnValue.QuadPart &&
            fileRefNumber.QuadPart == ourFileRefNumber.QuadPart &&
            fileAttributes == ourAttributes ) {

            //
            // the client has the current version of this file, so he wants
            // the open to fail.
            //

//          KdPrint(( "SmbNtCreateAndX IfModified worked.  Closing file.\n" ));

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbNtCreateAndX: File doesn't pass IfModifiedSince clause.\n" ));
            }

            SrvCloseRfcb( rfcb );

            SrvSetSmbError( WorkContext, STATUS_FILE_CLOSED );
            return SmbStatusSendResponse;
        }
//      KdPrint(( "SmbNtCreateAndX IfModified ignored, opened the file.\n" ));
    }
#endif

    // If the extended response is required then
    if ( extendedRequested ) {
        NTSTATUS ExtendedResponseStatus;
        PRESP_EXTENDED_NT_CREATE_ANDX pExtendedResponse;

        pExtendedResponse = (PRESP_EXTENDED_NT_CREATE_ANDX)response;

        ExtendedResponseStatus = SrvUpdateMaximalAccessRightsInResponse(
                                     WorkContext,
                                     &pExtendedResponse->MaximalAccessRights,
                                     &pExtendedResponse->GuestMaximalAccessRights);

        GenerateExtendedResponse = (ExtendedResponseStatus == STATUS_SUCCESS);
    }

    //
    // Set up response SMB.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;

    if (GenerateExtendedResponse) {

#ifdef INCLUDE_SMB_IFMODIFIED
        PRESP_EXTENDED_NT_CREATE_ANDX pExtendedResponse;

        pExtendedResponse = (PRESP_EXTENDED_NT_CREATE_ANDX)response;
#endif

        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_EXTENDED_NT_CREATE_ANDX,
                0
                )
            );

        response->WordCount = 42;

#ifdef INCLUDE_SMB_IFMODIFIED
        SmbPutUshort( &pExtendedResponse->ByteCount, 0 );
        byteCountSet = TRUE;

        if (extendedRequested2 && (nextCommand == SMB_COM_NO_ANDX_COMMAND)) {

            IO_STATUS_BLOCK ioStatus;
            PFILE_NAME_INFORMATION fileNameInfo;
            ULONG infoLength;
            PRESP_EXTENDED_NT_CREATE_ANDX2 extendedResponse2;
            ULONG bufLength;

            extendedResponse2 = (PRESP_EXTENDED_NT_CREATE_ANDX2) request;

            if (ourUsnValue.QuadPart == 0 && ourFileRefNumber.QuadPart == 0) {

                status = SrvIssueQueryUsnInfoRequest( rfcb,
                                                      FALSE,
                                                      &ourUsnValue,
                                                      &ourFileRefNumber );

                if (! NT_SUCCESS(status)) {
                    IF_DEBUG(ERRORS) {
                        KdPrint(( "SrvSmbNtCreateAndX: Query USN info (2) failed: 0x%X for handle %u\n",
                                    status, rfcb->Lfcb->FileObject ));
                    }
                }
            }

            //
            //  Put in the short and long file name values here for CSC.  It's
            //  a RESP_EXTENDED_NT_CREATE_ANDX2 response.  These requests
            //  cannot currently be compounded because the file names will
            //  overwrite the next command.
            //
            // get the short name to put in the buffer

            fileNameInfo = (PFILE_NAME_INFORMATION) ALIGN_UP( &extendedResponse2->Buffer[0], ULONG );

            //
            //  the buffer length we can use is all that remains in the
            //  receive buffer.
            //

            ASSERT( WorkContext->RequestBuffer == WorkContext->ResponseBuffer );

            bufLength = min( WorkContext->RequestBuffer->BufferLength,
                             WorkContext->Connection->MaximumSendSize );

            infoLength = (ULONG) ( bufLength -
             ( (PCHAR) fileNameInfo -
               (PCHAR) (WorkContext->RequestBuffer->Buffer) ));

            infoLength -= sizeof(ULONG);    // for alignment issues

            status = NtQueryInformationFile(
                             rfcb->Lfcb->FileHandle,
                             &ioStatus,
                             (PVOID)fileNameInfo,
                             infoLength,
                             FileAlternateNameInformation
                            );

            if (NT_SUCCESS(status)) {

                if (fileNameInfo->FileNameLength <
                        (SMB_SHORT_NAME_LENGTH * sizeof(WCHAR))) {

                    ULONG fileNameLength = fileNameInfo->FileNameLength;

                    RtlZeroMemory( &extendedResponse2->ShortName[0],
                                   sizeof(WCHAR) * SMB_SHORT_NAME_LENGTH );

                    RtlCopyMemory(  &extendedResponse2->ShortName[0],
                                    fileNameInfo->FileName,
                                    fileNameLength
                                    );

                    // null terminate the name
                    extendedResponse2->ShortName[fileNameLength/sizeof(WCHAR)] = L'\0';

                } else {

                    IF_DEBUG(ERRORS) {
                        KdPrint(( "SrvSmbNtCreateAndX: QueryInfoFile for short name returned length of %X\n", fileNameInfo->FileNameLength ));
                    }
                    extendedResponse2->ShortName[0] = L'\0';
                }
            } else {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbNtCreateAndX: QueryInfoFile for short name failed: "
                                "%X\n", status ));
                }

                extendedResponse2->ShortName[0] = L'\0';
            }

            status = NtQueryInformationFile(
                             rfcb->Lfcb->FileHandle,
                             &ioStatus,
                             (PVOID)fileNameInfo,
                             infoLength,
                             FileNameInformation
                            );

            if (NT_SUCCESS(status)) {

                ULONG fileNameLength = 0;

                //
                //  Use RtlMoveMemory as the source and destination will
                //  possibly overlap.
                //

                if (fileNameInfo->FileNameLength > 0) {

                    // only copy over the last component of the name.

                    PWCHAR lastBackSlash = &fileNameInfo->FileName[((fileNameInfo->FileNameLength)/sizeof(WCHAR))-1];

                    while (*lastBackSlash != UNICODE_DIR_SEPARATOR_CHAR &&
                        lastBackSlash > &fileNameInfo->FileName[0]) {

                        fileNameLength += sizeof(WCHAR);
                        lastBackSlash--;
                    }
                    lastBackSlash++;

                    RtlMoveMemory(  &extendedResponse2->Buffer[0],
                                    lastBackSlash,
                                    fileNameLength
                                    );
                }

                // null terminate the name
                extendedResponse2->Buffer[fileNameLength/sizeof(WCHAR)] = L'\0';

                SmbPutUshort( &extendedResponse2->ByteCount,
                                LOWORD(fileNameLength) + sizeof(WCHAR) );
                byteCountSet = TRUE;

                SmbPutUlong( &extendedResponse2->UsnValue.HighPart, ourUsnValue.HighPart );
                SmbPutUlong( &extendedResponse2->UsnValue.LowPart, ourUsnValue.LowPart );

                SmbPutUlong( &extendedResponse2->FileReferenceNumber.HighPart, ourFileRefNumber.HighPart );
                SmbPutUlong( &extendedResponse2->FileReferenceNumber.LowPart, ourFileRefNumber.LowPart );

                SmbPutUshort(
                    &response->AndXOffset,
                    GET_ANDX_OFFSET(
                        WorkContext->ResponseHeader,
                        WorkContext->ResponseParameters,
                        RESP_EXTENDED_NT_CREATE_ANDX2,
                        LOWORD(fileNameLength) + sizeof(WCHAR)
                        )
                    );

                response->WordCount = SMB_RESP_EXTENDED_NT_CREATE_ANDX2_WORK_COUNT;

            } else {

                //
                //  if we couldn't get the name for some reason, let's not fail
                //  the whole open.  Just leave the response as a
                //  RESP_EXTENDED_NT_CREATE_ANDX
                //

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbNtCreateAndX: QueryInfoFile for long name failed: "
                                "%X\n", status ));
                }
                status = STATUS_SUCCESS;

                //
                //  reset the byte count in case the CrcValue was set
                //  and overwrote it.
                //

                SmbPutUshort( &pExtendedResponse->ByteCount, 0 );
                byteCountSet = TRUE;
            }
        }
#endif
    } else {
        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_NT_CREATE_ANDX,
                0
                )
            );

        response->WordCount = 34;
    }

    response->OplockLevel = oplockLevel;

    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUlong( &response->CreateAction, CreateAction );

    SmbPutUlong(
        &response->CreationTime.HighPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.HighPart
        );
    SmbPutUlong(
        &response->CreationTime.LowPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.LowPart
        );
    SmbPutUlong(
        &response->LastAccessTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.HighPart
        );
    SmbPutUlong(
        &response->LastAccessTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.LowPart
        );
    SmbPutUlong(
        &response->LastWriteTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.HighPart
        );
    SmbPutUlong(
        &response->LastWriteTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.LowPart
        );
    SmbPutUlong(
        &response->ChangeTime.HighPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.HighPart
        );
    SmbPutUlong(
        &response->ChangeTime.LowPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.LowPart
        );

    SmbPutUlong( &response->FileAttributes, srvNtFileInformation.NwOpenInfo.FileAttributes );
    SmbPutUlong(
        &response->AllocationSize.HighPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.HighPart
        );
    SmbPutUlong(
        &response->AllocationSize.LowPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.LowPart
        );
    SmbPutUlong(
        &response->EndOfFile.HighPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.HighPart
        );
    SmbPutUlong(
        &response->EndOfFile.LowPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.LowPart
        );

    SmbPutUshort( &response->FileType, srvNtFileInformation.Type );
    SmbPutUshort( &response->DeviceState, srvNtFileInformation.HandleState );

    response->Directory = (srvNtFileInformation.NwOpenInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;

#ifdef INCLUDE_SMB_IFMODIFIED
    if (byteCountSet == FALSE) {
        //
        //  if we haven't already put the bytecount into the extended response,
        //  do so now.
        //
#endif
        SmbPutUshort( &response->ByteCount, 0 );
#ifdef INCLUDE_SMB_IFMODIFIED
    }
#endif

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_IOCTL:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbNtCreateAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        //
        // Return an error indicating that the followon command was bad.
        // Note that the open is still considered successful, so the
        // file remains open.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbStatusSendResponse;
    }

#ifdef INCLUDE_SMB_PERSISTENT
    if (persistentHandle && rfcb->Lfcb->TreeConnect->Share->AllowPersistentHandles) {

        rfcb->PersistentHandle = TRUE;

    } else {

        persistentHandle = rfcb->PersistentHandle = FALSE;
    }
#endif

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

#ifdef INCLUDE_SMB_PERSISTENT
        if (persistentHandle) {

            rc = SrvPostPersistentOpen( WorkContext, SmbStatusMoreCommands );

        } else {

            rc = SmbStatusMoreCommands;
        }

        return rc;
#else
        return SmbStatusMoreCommands;
#endif
    }

#ifdef INCLUDE_SMB_PERSISTENT
    if (persistentHandle) {

        rc = SrvPostPersistentOpen( WorkContext, SmbStatusSendResponse );

    } else {

        rc = SmbStatusSendResponse;
    }
#else
    rc = SmbStatusSendResponse;
#endif

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbNtCreateAndX complete.\n" ));
    return rc;

} // GenerateNtCreateAndXResponse

SMB_TRANS_STATUS
SrvSmbCreateWithSdOrEa (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an Create with SD or EA SMB.  This request arrives in an
    Nt Transaction SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/
{
    PREQ_CREATE_WITH_SD_OR_EA request;
    PRESP_CREATE_WITH_SD_OR_EA response;

    NTSTATUS status;
    PTRANSACTION transaction;

    ULONG eaErrorOffset = 0;
    LARGE_INTEGER allocationSize;

    PVOID securityDescriptorBuffer;
    ULONG sdLength;
    ULONG eaLength;
    PVOID eaBuffer;

    UNICODE_STRING fileName;
    PUCHAR name;
    USHORT nameLength;
    BOOLEAN isUnicode;

    SECURITY_QUALITY_OF_SERVICE qualityOfService;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_CREATE_WITH_SD_OR_EA)transaction->InParameters;
    response = (PRESP_CREATE_WITH_SD_OR_EA)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount < sizeof(REQ_CREATE_WITH_SD_OR_EA)) ||
         (transaction->MaxParameterCount < sizeof(RESP_CREATE_WITH_SD_OR_EA)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS)
            KdPrint(( "SrvSmbCreateWithSdOrEa: bad parameter byte counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));

        SrvLogInvalidSmb( WorkContext );

        return GenerateCreateWithSdOrEaResponse(
                    WorkContext,
                    STATUS_INVALID_SMB
                    );

    }

    eaErrorOffset = 0;
    allocationSize.HighPart = SmbGetUlong( &request->AllocationSize.HighPart );
    allocationSize.LowPart = SmbGetUlong( &request->AllocationSize.LowPart );

    //
    // First verify that the file path name doesnot extend beyond the
    // end of the SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    name = (PUCHAR)request->Buffer;
    if ( isUnicode ) {
        name = ALIGN_SMB_WSTR( name );
    }

    nameLength = (USHORT)SmbGetUshort( &request->NameLength );
    if ( name + nameLength > ((PCHAR)request + transaction->ParameterCount) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbCreateWithSdOrEa: failed at line %u\n", __LINE__ ));
        }
        SrvLogInvalidSmb( WorkContext );

        return GenerateCreateWithSdOrEaResponse(
                    WorkContext,
                    STATUS_INVALID_SMB
                    );

    }

    //
    // Convert the file name to a Unicode string.
    //

    status = SrvMakeUnicodeString(
                 isUnicode,
                 &fileName,
                 name,
                 &nameLength
                 );

    if ( !NT_SUCCESS( status ) ) {
        return GenerateCreateWithSdOrEaResponse( WorkContext, status );
    }


    sdLength = SmbGetUlong( &request->SecurityDescriptorLength );
    eaLength = SmbGetUlong( &request->EaLength );

    securityDescriptorBuffer = transaction->InData;
    eaBuffer = (PCHAR)securityDescriptorBuffer + ((sdLength + 3) & ~ 3);

    if( eaLength > transaction->DataCount ||
        sdLength > transaction->DataCount ||
        (PCHAR)securityDescriptorBuffer + eaLength + sdLength >
        (PCHAR)transaction->InData + transaction->DataCount ||
        ((sdLength != 0) && !RtlValidSecurityDescriptor(securityDescriptorBuffer))) {

        IF_DEBUG( SMB_ERRORS ) {
            KdPrint(( "SrvSmbCreateWithSdOrEa: failed at line %u\n", __LINE__ ));
            KdPrint(( "  eaLength %u, sdLength %u, DataCount %u\n",
                        eaLength, sdLength, transaction->DataCount ));
        }

        SrvLogInvalidSmb( WorkContext );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        return GenerateCreateWithSdOrEaResponse(
                    WorkContext,
                    STATUS_INVALID_SECURITY_DESCR
                    );
    }

    //
    // *** We always ask for STATIC tracking, not DYNAMIC, because we
    //     don't support dynamic tracking over the net yet.
    //
    // !!! Note that once we support dynamic tracking, we MUST CHANGE
    //     THE NAMED PIPE PROCESSING to not do writes/transceives at DPC
    //     level, because the NPFS needs to call SeCreateClientSecurity
    //     on every write when dynamic tracking is selected!
    //

    qualityOfService.Length = sizeof( qualityOfService );
    qualityOfService.ImpersonationLevel =
        SmbGetUlong( &request->ImpersonationLevel );
    qualityOfService.ContextTrackingMode = FALSE;
    //qualityOfService.ContextTrackingMode = (BOOLEAN)
    //    (request->SecurityFlags & SMB_SECURITY_DYNAMIC_TRACKING);
    qualityOfService.EffectiveOnly = (BOOLEAN)
        (request->SecurityFlags & SMB_SECURITY_EFFECTIVE_ONLY);

    status = SrvNtCreateFile(
                 WorkContext,
                 SmbGetUlong( &request->RootDirectoryFid ),
                 SmbGetUlong( &request->DesiredAccess ),
                 allocationSize,
                 SmbGetUlong( &request->FileAttributes ),
                 SmbGetUlong( &request->ShareAccess ),
                 SmbGetUlong( &request->CreateDisposition ),
                 SmbGetUlong( &request->CreateOptions ),
                 (sdLength == 0) ? NULL : securityDescriptorBuffer,
                 &fileName,
                 (eaLength == 0) ? NULL : eaBuffer,
                 eaLength,
                 &eaErrorOffset,
                 SmbGetUlong( &request->Flags ),
                 &qualityOfService,
                 (request->Flags & NT_CREATE_REQUEST_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (request->Flags & NT_CREATE_REQUEST_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartCreateWithSdOrEa
                 );

    //
    // Free the unicode file name buffer if it has been allocated.
    //

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &fileName );
    }

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        //
        // Save the ea error offset
        //

        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        return SmbTransStatusInProgress;

    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //

        WorkContext->FspRestartRoutine = (PRESTART_ROUTINE)ExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );
        return SmbStatusInProgress;


    } else {

        //
        // Save the ea error offset
        //

        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        //
        // The open has completed.  Generate and send the reply.
        //

        return GenerateCreateWithSdOrEaResponse( WorkContext, status );

    }

} // SrvSmbCreateWithSdOrEa


VOID SRVFASTCALL
RestartCreateWithSdOrEa (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open2 SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus;
    NTSTATUS openStatus;

    PAGED_CODE( );

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

        if( NT_SUCCESS( openStatus ) ) {
            //
            // It's obvious that the file already existed, because we've
            //  been working on an oplock break.  So set the
            //  IoStatus.Information field correctly.
            //
            WorkContext->Irp->IoStatus.Information = FILE_OPENED;
        }

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;
    smbStatus = GenerateCreateWithSdOrEaResponse( WorkContext, openStatus );

    SrvCompleteExecuteTransaction( WorkContext, smbStatus );

    return;

} // RestartCreateWithSdOrEa


SMB_TRANS_STATUS
GenerateCreateWithSdOrEaResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Create With SD or EA SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

--*/

{
    PREQ_CREATE_WITH_SD_OR_EA request;
    PRESP_CREATE_WITH_SD_OR_EA response;

    PRFCB rfcb;
    NTSTATUS status;
    SRV_NT_FILE_INFORMATION srvNtFileInformation;
    PTRANSACTION transaction;

    OPLOCK_TYPE oplockType;
    UCHAR oplockLevel;
    BOOLEAN allowLevelII;

    BOOLEAN SendExtendedResponse = FALSE;
    ACCESS_MASK MaximalAccessRights;
    ACCESS_MASK GuestMaximalAccessRights;

    ULONG eaErrorOffset;
    BOOLEAN extendedRequested;

    ULONG CreateAction = (ULONG)WorkContext->Irp->IoStatus.Information;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_CREATE_WITH_SD_OR_EA)transaction->InParameters;
    response = (PRESP_CREATE_WITH_SD_OR_EA)transaction->OutParameters;

    extendedRequested = ((request->Flags & NT_CREATE_REQUEST_EXTENDED_RESPONSE) != 0 );

    rfcb = WorkContext->Rfcb;
    eaErrorOffset = WorkContext->Parameters2.Open.EaErrorOffset;

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {

        SrvSetSmbError2( WorkContext, OpenStatus, TRUE );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        goto err_exit;
    }


    //
    // We always open with at least FILE_READ_ATTRIBUTES, so no
    // access check is needed.
    //

    status = SrvQueryNtInformationFile(
                 rfcb->Lfcb->FileHandle,
                 rfcb->Lfcb->FileObject,
                 rfcb->ShareType,
                 extendedRequested,
                 &srvNtFileInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "GenerateCreateWithSdOrEaResponse: "
                       "SrvQueryNtInformationFile failed: %X\n", status ));
        }

        SrvCloseRfcb( rfcb );

        SrvSetSmbError2( WorkContext, status, TRUE );
        goto err_exit;
    }

    //
    // Attempt to acquire the oplock.
    //

    if ( !(request->CreateOptions & FILE_DIRECTORY_FILE) ) {

        if ( request->Flags & NT_CREATE_REQUEST_OPLOCK ) {
            allowLevelII = CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, WorkContext->Connection );
            if ( request->Flags & NT_CREATE_REQUEST_OPBATCH ) {
                oplockType = OplockTypeBatch;
                oplockLevel = SMB_OPLOCK_LEVEL_BATCH;
            } else {
                oplockType = OplockTypeExclusive;
                oplockLevel = SMB_OPLOCK_LEVEL_EXCLUSIVE;
            }
        } else {
            allowLevelII = FALSE;
            oplockType = OplockTypeServerBatch;
            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
        }

        if ( SrvRequestOplock( WorkContext, &oplockType, allowLevelII ) ) {

            //
            // The oplock was granted.  Check to see if it was a level 2.
            //

            if ( oplockType == OplockTypeShareRead ) {
                oplockLevel = SMB_OPLOCK_LEVEL_II;
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );

        } else {

            //
            // The oplock request was denied.
            //

            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );

        }

    } else {

        oplockLevel = SMB_OPLOCK_LEVEL_NONE;

    }

    if ( extendedRequested ) {
        NTSTATUS ExtendedResponseStatus;

        PRESP_EXTENDED_CREATE_WITH_SD_OR_EA ExtendedResponse;

        ExtendedResponse = (PRESP_EXTENDED_CREATE_WITH_SD_OR_EA)response;

        ExtendedResponseStatus = SrvUpdateMaximalAccessRightsInResponse(
                                     WorkContext,
                                     &ExtendedResponse->MaximalAccessRights,
                                     &ExtendedResponse->GuestMaximalAccessRights);

        SendExtendedResponse = (ExtendedResponseStatus == STATUS_SUCCESS);
    }

    //
    // Set up response SMB.
    //

    response->OplockLevel = oplockLevel;

    if (SendExtendedResponse) {
        response->ExtendedResponse = 1;
    } else {
        response->ExtendedResponse = 0;
    }

    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUlong( &response->EaErrorOffset, eaErrorOffset );
    SmbPutUlong( &response->CreateAction, CreateAction );

    SmbPutUshort( &response->FileType, srvNtFileInformation.Type );
    SmbPutUshort( &response->DeviceState, srvNtFileInformation.HandleState );
    SmbPutUlong(
        &response->CreationTime.HighPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.HighPart
        );
    SmbPutUlong(
        &response->CreationTime.LowPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.LowPart
        );
    SmbPutUlong(
        &response->LastAccessTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.HighPart
        );
    SmbPutUlong(
        &response->LastAccessTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.LowPart
        );
    SmbPutUlong(
        &response->LastWriteTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.HighPart
        );
    SmbPutUlong(
        &response->LastWriteTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.LowPart
        );
    SmbPutUlong(
        &response->ChangeTime.HighPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.HighPart
        );
    SmbPutUlong(
        &response->ChangeTime.LowPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.LowPart
        );

    SmbPutUlong( &response->FileAttributes, srvNtFileInformation.NwOpenInfo.FileAttributes );
    SmbPutUlong(
        &response->AllocationSize.HighPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.HighPart
        );
    SmbPutUlong(
        &response->AllocationSize.LowPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.LowPart
        );
    SmbPutUlong(
        &response->EndOfFile.HighPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.HighPart
        );
    SmbPutUlong(
        &response->EndOfFile.LowPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.LowPart
        );

    response->Directory = (srvNtFileInformation.NwOpenInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;

    if (SendExtendedResponse) {
        transaction->ParameterCount = sizeof(RESP_EXTENDED_CREATE_WITH_SD_OR_EA);
    } else {
        transaction->ParameterCount = sizeof(RESP_CREATE_WITH_SD_OR_EA);
    }

    transaction->SetupCount = 0;
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbOpen2 complete.\n" ));
    return SmbTransStatusSuccess;

err_exit:

    RtlZeroMemory( (PVOID)response, sizeof(RESP_CREATE_WITH_SD_OR_EA) );
    SmbPutUlong( &response->EaErrorOffset, eaErrorOffset );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_CREATE_WITH_SD_OR_EA);
    transaction->DataCount = 0;

    return SmbTransStatusErrorWithData;

} // GenerateCreateWithSdOrEaResponse


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreate (
    SMB_PROCESSOR_PARAMETERS
    )
/*++

Routine Description:

    Processes the Create and Create New SMBs.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_CREATE request;

    UCHAR      command;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Create file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Create file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_CREATE)WorkContext->RequestParameters;

    command = WorkContext->RequestHeader->Command;

    //
    // Open the file in compatibility mode, obtaining read/write access
    // for this FID.
    //

    status = SrvCreateFile(
                 WorkContext,
                 SMB_DA_SHARE_COMPATIBILITY | SMB_DA_ACCESS_READ_WRITE,
                 SmbGetUshort( &request->FileAttributes ),
                 (USHORT) ( ( command == SMB_COM_CREATE ?
                              SMB_OFUN_OPEN_TRUNCATE : SMB_OFUN_OPEN_FAIL )
                            | SMB_OFUN_CREATE_CREATE ),
                 0,                   // SmbAllocationSize
                 (PCHAR)(request->Buffer + 1),
                 END_OF_REQUEST_SMB( WorkContext ),
                 NULL,
                 0L,
                 NULL,
                 (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK_NOTIFY_ANY) != 0 ?
                    OplockTypeBatch :
                    (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartSmbCreate
                 );

    if( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {
        //
        // The open is blocked, perhaps because some other client had this
        //  file open and is holding onto the handle with a batch oplock.
        //
        SmbStatus = SmbStatusInProgress;

    } else {
        SmbStatus = GenerateCreateResponse( WorkContext, status );
    }
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
}

VOID SRVFASTCALL
RestartSmbCreate(
    IN PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Completes processing of a Create SMB.

Arguments:

    WorkContext - A pointer to the work context block for this SMB.

Return Value:

    None.

--*/
{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS createStatus = STATUS_SUCCESS;

    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE;
    SrvWmiStartContext(WorkContext);

    createStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if( NT_SUCCESS( createStatus ) ) {
        createStatus = WorkContext->Irp->IoStatus.Status;

    } else {
        //
        // The create was waiting for an oplock break to occur, but
        // timed out. Close our handle to this file, then fail the create.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );
    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateCreateResponse( WorkContext, createStatus );

    SrvEndSmbProcessing( WorkContext, smbStatus );
    SrvWmiEndContext(WorkContext);
}

SMB_PROCESSOR_RETURN_TYPE
GenerateCreateResponse(
    PWORK_CONTEXT WorkContext,
    NTSTATUS CreateStatus
    )
/*++

Routine Description:

    Generates a response to a Create SMB

Arguments:

    WorkContext -
    Status - The status of the create operation

Return Value:

    The status of the SMB processing.

--*/
{
    PREQ_CREATE request;
    PRESP_CREATE response;
    PRFCB rfcb;

    PAGED_CODE();

    request = (PREQ_CREATE)WorkContext->RequestParameters;
    response = (PRESP_CREATE)WorkContext->ResponseParameters;

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS(CreateStatus) ) {

        SrvSetSmbError( WorkContext, CreateStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS.  In OS/2
        // ERROR_ALREADY_EXISTS is used for resources like Semaphores.
        // This cannot be passed back to the downlevel client and has
        // to be remapped to ERROR_FILE_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {

            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }
        return SmbStatusSendResponse;
    }

    //
    // Set the time on the file.
    //
    // !!! Should we do anything with the return code?

    rfcb = WorkContext->Rfcb;

#ifdef INCLUDE_SMB_IFMODIFIED

    (VOID)SrvSetLastWriteTime(
              rfcb,
              SmbGetUlong( &request->CreationTimeInSeconds ),
              rfcb->Lfcb->GrantedAccess,
              FALSE
              );
#else

    (VOID)SrvSetLastWriteTime(
              rfcb,
              SmbGetUlong( &request->CreationTimeInSeconds ),
              rfcb->Lfcb->GrantedAccess
              );
#endif
    //
    // Give the smart card a chance to get into the act
    //
    if( WorkContext->Endpoint->IsConnectionless && SrvIpxSmartCard.Open != NULL ) {

        PVOID handle;

        IF_DEBUG( SIPX ) {
            KdPrint(( "Trying the smart card for %wZ\n", &rfcb->Mfcb->FileName ));
        }

        if( SrvIpxSmartCard.Open(
            WorkContext->RequestBuffer->Buffer,
            rfcb->Lfcb->FileObject,
            &rfcb->Mfcb->FileName,
            &(WorkContext->ClientAddress->IpxAddress.Address[0].Address[0]),
            rfcb->Lfcb->FileObject->Flags & FO_CACHE_SUPPORTED,
            &handle
            ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "%wZ handled by Smart Card.  Handle %p\n",
                           &rfcb->Mfcb->FileName, handle ));
            }

            rfcb->PagedRfcb->IpxSmartCardContext = handle;
        }
    }

    //
    // Set up response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_CREATE,
                                          0
                                          );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbCreate complete.\n" ));
    return SmbStatusSendResponse;

} // SrvSmbCreate


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateTemporary (
    SMB_PROCESSOR_PARAMETERS
    )
/*++

Routine Description:

    Processes a Create Temporary SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_CREATE_TEMPORARY request;
    PRESP_CREATE_TEMPORARY response;

    PRFCB rfcb;
    NTSTATUS   status    = STATUS_OBJECT_NAME_COLLISION;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    CLONG nameCounter;
    USHORT i;
    PSZ nameStart, ep;
    CHAR name[9];

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE_TEMPORARY;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Create temporary file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Create temporary file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_CREATE_TEMPORARY)WorkContext->RequestParameters;
    response = (PRESP_CREATE_TEMPORARY)WorkContext->ResponseParameters;

    //
    // Find out where in the buffer the directory pathname ends.  We will
    // write the filename after this.
    //

    ep = END_OF_REQUEST_SMB( WorkContext );

    for( nameStart = (PSZ)request->Buffer; nameStart <= ep && *nameStart; nameStart++ ) {
        ;
    }

    //
    // If we didn't find a NULL, or we don't have room to add in the last part of the
    //  temporary filename, then we give up
    //
    if( *nameStart ||
        WorkContext->RequestBuffer->BufferLength - WorkContext->RequestBuffer->DataLength < 9 ) {

        //
        // We did not find a valid pathname!
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // The temporary file will be created with a name like SRVxxxxx, where
    // xxxxx is a hex integer.  We first try to create SRV00000, and if it
    // exists increment xxxxx until xxxxx = 0xFFFFF;
    //
    // !!! We may want to maintain a "last name" counter, to try to
    //     reduce the number of retries we need.  We may also want to
    //     have an explicit bound the number of tries, like 16 or 32, or
    //     293.
    //

    name[0] = 'S';
    name[1] = 'R';
    name[2] = 'V';
    name[8] = '\0';

    // *** for SrvCanonicalizePathName
    WorkContext->RequestBuffer->DataLength += 9;

    for ( nameCounter = 0;
          status == STATUS_OBJECT_NAME_COLLISION &&
                                            nameCounter < (CLONG)0xFFFFF;
          nameCounter++ ) {

        CCHAR j;
        PSZ s;

        name[3] = SrvHexChars[ (nameCounter & (CLONG)0xF0000) >> 16 ];
        name[4] = SrvHexChars[ (nameCounter & (CLONG)0xF000) >> 12 ];
        name[5] = SrvHexChars[ (nameCounter & (CLONG)0xF00) >> 8 ];
        name[6] = SrvHexChars[ (nameCounter & (CLONG)0xF0) >> 4 ];
        name[7] = SrvHexChars[ (nameCounter & (CLONG)0xF) ];

        // *** We could get rid of this loop and the name[9] variable
        //     if we could put the name directly into the SMB buffer.

        for ( j = 0, s = nameStart; j < 9; j++, s++ ) {
            *s = name[j];
        }

        //
        // Open the file in compatibility mode, obtaining read/write
        // access for this FID.
        //

        status = SrvCreateFile(
                     WorkContext,
                     SMB_DA_SHARE_COMPATIBILITY | SMB_DA_ACCESS_READ_WRITE,
                     0,                   // SmbFileAttributes (normal)
                     SMB_OFUN_OPEN_FAIL | SMB_OFUN_CREATE_CREATE,
                     0,                   // SmbAllocationSize
                     (PCHAR)(request->Buffer + 1),
                     END_OF_REQUEST_SMB( WorkContext ),
                     NULL,
                     0L,
                     NULL,
                     (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK_NOTIFY_ANY) != 0 ?
                        OplockTypeBatch :
                        (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK) != 0 ?
                            OplockTypeExclusive : OplockTypeServerBatch,
                     NULL
                     );

        ASSERT ( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

        //
        // If the open failed, send an error response.
        //

        if ( !NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_COLLISION ) {
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    if ( nameCounter == (CLONG)0xFFFFF ) {

        //
        // This will probably never happen, and if it did, it would take
        // a *long* time to attempt to open FFFFF == 1,048,575 files.
        //

        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Set up response SMB.
    //

    rfcb = WorkContext->Rfcb;
    rfcb->IsCacheable = FALSE;

    response->WordCount = 1;
    SmbPutUshort( &response->Fid, rfcb->Fid );
    for ( i = 0; i < 9; i++ ) {
        request->Buffer[i] = nameStart[i];
    }
    SmbPutUshort( &response->ByteCount, 9 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_CREATE_TEMPORARY,
                                          9
                                          );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbCreateTemporary complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbCreateTemporary


VOID
SetEofToMatchAllocation (
    IN HANDLE FileHandle,
    IN ULONG AllocationSize
    )

/*++

Routine Description:

    Sets the EOF location for a file to match the size allocated when
    the file was created.  This routine is necessary in order to gain
    compatibility with OS/2, which does not have separate concepts of
    EOF and allocation size.  When the server creates a file for an OS/2
    client, if the allocation size is greater than 0, the server sets
    the EOF to match that size.

    This routine was created to allow the server to pass variations 17
    and 18 of the filio003 test.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/


{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    FILE_END_OF_FILE_INFORMATION newEndOfFile;

    PAGED_CODE( );

    //
    // Don't bother doing this if the allocated size is zero.
    //

    if ( AllocationSize != 0 ) {

        newEndOfFile.EndOfFile.QuadPart = AllocationSize;

        status = NtSetInformationFile(
                    FileHandle,
                    &iosb,
                    &newEndOfFile,
                    sizeof( newEndOfFile ),
                    FileEndOfFileInformation
                    );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SetEofToMatchAllocation: SetInformationFile returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
        }

    }

    return;

} // SetEofToMatchAllocation

#ifdef INCLUDE_SMB_IFMODIFIED
#if 0

NTSTATUS
SrvGetUsnInfoForFile(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb,
    IN BOOLEAN SubmitClose,
    OUT PLARGE_INTEGER Usn,
    OUT PLARGE_INTEGER FileRefNumber
    )
{
    PIRP irp;
    ULONG fsControl;

    Usn->QuadPart = 0;
    FileRefNumber->QuadPart = 0;

    if (! Rfcb->Lfcb->TreeConnect->Share->UsnCapable) {

        return STATUS_SUCCESS;
    }

    // if the client opened the file with the short name, we could end up
    // having a buffer that's woefully too small.   We'll bump the
    // allocation up to a large amount so that we don't have to
    // go back and do it again.

    sizeRequired = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    sizeRequired += sizeof( USN_RECORD );
    sizeRequired = QuadAlign( sizeRequired );

    usnRecord = ALLOCATE_NONPAGED_POOL( sizeRequired, BlockTypeDataBuffer );

    if ( usnRecord == NULL) {

//      IF_DEBUG(ERRORS) {
            KdPrint(( "SrvGetUsnInfoForFile: unable to alloc block of size %u for handle 0x%x\n",
                         sizeRequired, Rfcb->Lfcb->FileObject ));
//      }
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    fsControl = SubmitClose ? FSCTL_WRITE_USN_CLOSE_RECORD : FSCTL_READ_FILE_USN_DATA;

    //
    //  get the current USN number for this file.
    //

    irp = SrvBuildIoControlRequest(
              NULL,                               // input IRP address
              Rfcb->Lfcb->FileObject,             // target file object address
              WorkContext,                        // context
              IRP_MJ_FILE_SYSTEM_CONTROL,         // major function
              fsControl,                          // minor function
              NULL,                               // input buffer address
              0,                                  // input buffer length
              usnRecord,                          // output buffer address
              sizeRequired,                       // output buffer length
              NULL,                               // MDL address
              SrvMdlCompletionRoutine             // completion routine
              );

    if (irp != NULL) {

        status = IoCallDriver( Rfcb->Lfcb->DeviceObject, irp );

//      if ( !NT_SUCCESS(status) ) {

            ASSERT( status != STATUS_MORE_PROCESSING_REQUIRED );
            ASSERT( status != STATUS_PENDING );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvGetUsnInfoForFile: Query USN info failed: 0x%X for handle %u\n",
                            status, Rfcb->Lfcb->FileObject ));
//          }
        } else {

            Usn->QuadPart = usnRecord->Usn;
            FileRefNumber->QuadPart = usnRecord->FileReferenceNumber;
        }
        IoFreeIrp( irp );
    } else {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvGetUsnInfoForFile: unable to alloc irp for handle 0x%x\n",
                         Rfcb->Lfcb->FileObject ));
        }
        status = STATUS_INSUFF_SERVER_RESOURCES;
    }

    DEALLOCATE_NONPAGED_POOL( usnRecord );

    return status;
}

#endif
#endif  // def INCLUDE_SMB_IFMODIFIED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbprint.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbprint.c

Abstract:

    This module implements printing SMB processors:

        Open Print File
        Close Print File
        Get Print Queue

Author:

    David Treadwell (davidtr) 08-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbprint.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbOpenPrintFile )
#pragma alloc_text( PAGE, SrvSmbGetPrintQueue )
#pragma alloc_text( PAGE, SrvSmbClosePrintFile )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenPrintFile (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Open Print File SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PTREE_CONNECT treeConnect;
    PRESP_OPEN_PRINT_FILE response;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN_PRINT_FILE;
    SrvWmiStartContext(WorkContext);

    //
    // Make sure we are on a blocking thread!
    //
    if( WorkContext->UsingBlockingThread == 0 ) {
        SrvQueueWorkToBlockingThread( WorkContext );
        return SmbStatusInProgress;
    }

    //
    // Verify that this is a print share.
    //
    // *** We are putting in this check because some public domain Samba
    //     smb clients are trying to print through a disk share.
    //

    treeConnect = SrvVerifyTid(
                         WorkContext,
                         SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )
                         );

    if ( treeConnect == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
             KdPrint(( "SrvSmbPrintFile: Invalid TID.\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        status    = STATUS_SMB_BAD_TID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // if it's not a print share, tell the client to get lost.
    //

    if ( treeConnect->Share->ShareType != ShareTypePrint ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_DEVICE_REQUEST );
        status    = STATUS_INVALID_DEVICE_REQUEST;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Call SrvCreateFile to open a print spooler file.  None of the
    // options such as desired access, etc. are relevant for a print
    // open--they are all set to default values by SrvCreateFile.
    //

    status = SrvCreateFile(
                 WorkContext,
                 0,                   // SmbDesiredAccess
                 0,                   // SmbFileAttributes
                 0,                   // SmbOpenFunction
                 0,                   // SmbAllocationSize
                 0,                   // SmbFileName
                 NULL,                // EndOfSmbFileName
                 NULL,                // EaBuffer
                 0,                   // EaLength
                 NULL,                // EaErrorOffset
                 0,                   // RequestedOplockType
                 NULL                 // RestartRoutine
                 );

    //
    // There should never be an oplock on one of these special spooler
    // files.
    //

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Set up the response SMB.
    //

    response = (PRESP_OPEN_PRINT_FILE)WorkContext->ResponseParameters;

    response->WordCount = 1;
    SmbPutUshort( &response->Fid, WorkContext->Rfcb->Fid );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_OPEN_PRINT_FILE,
                                          0
                                          );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbOpenPrintFile


SMB_PROCESSOR_RETURN_TYPE
SrvSmbClosePrintFile (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Close Print File SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_CLOSE_PRINT_FILE request;
    PRESP_CLOSE_PRINT_FILE response;

    PSESSION session;
    PRFCB rfcb;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CLOSE_PRINT_FILE;
    SrvWmiStartContext(WorkContext);

    //
    // Make sure we are on a blocking thread
    //
    if( WorkContext->UsingBlockingThread == 0 ) {
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Close print file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Close print file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_CLOSE_PRINT_FILE)(WorkContext->RequestParameters);
    response = (PRESP_CLOSE_PRINT_FILE)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbClose: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // First, verify the FID.  If verified, the RFCB and the TreeConnect
    // block are referenced and their addresses are stored in the
    // WorkContext block, and the RFCB address is returned.
    //
    // Call SrvVerifyFid, but do not fail (return NULL) if there
    // is a saved write behind error for this rfcb.  The rfcb is
    // needed in order to process the close.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                FALSE,
                SrvRestartSmbReceived,  // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbClose: Invalid FID: 0x%lx\n",
                            SmbGetUshort( &request->Fid ) ));
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            status    = STATUS_INVALID_HANDLE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    } else if ( !NT_SUCCESS( rfcb->SavedError ) ) {

        //
        // Check the saved error.
        //

        (VOID)SrvCheckForSavedError( WorkContext, rfcb );
    }

    //
    // Now proceed to do the actual close file, even if there was
    // a write behind error.
    //

    SrvCloseRfcb( rfcb );

    //
    // Dereference the RFCB immediately, rather than waiting for normal
    // work context cleanup after the response send completes.  This
    // gets the xFCB structures cleaned up in a more timely manner.
    //
    // *** The specific motivation for this change was to fix a problem
    //     where a compatibility mode open was closed, the response was
    //     sent, and a Delete SMB was received before the send
    //     completion was processed.  This resulted in the MFCB and LFCB
    //     still being present, which caused the delete processing to
    //     try to use the file handle in the LFCB, which we just closed
    //     here.
    //

    SrvDereferenceRfcb( rfcb );
    WorkContext->Rfcb = NULL;

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_CLOSE_PRINT_FILE,
                                        0
                                        );

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbClosePrintFile


SMB_PROCESSOR_RETURN_TYPE
SrvSmbGetPrintQueue (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Get Print Queue SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PAGED_CODE( );
    return SrvSmbNotImplemented( SMB_PROCESSOR_ARGUMENTS );

} // SrvSmbGetPrintQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbraw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbraw.c

Abstract:

    This module contains routines for processing the following SMBs in
    the server FSP:

        Read Block Raw
        Write Block Raw

    The routines in this module generally work closely with the routines
    in fsdraw.c.

    *** There is no support here for raw writes from MS-NET 1.03 clients.
        There are very few of these machines in existence, and raw mode
        is only a performance issue, so it is not worth the trouble to
        add the necessary hacks for MS-NET 1.03, which sends raw write
        requests in a different format.

Author:

    Chuck Lenzmeier (chuckl) 8-Sep-1990
    Manny Weiser (mannyw)
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "smbraw.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBRAW

//
// Forward declarations
//

VOID SRVFASTCALL
AbortRawWrite(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
PrepareRawCopyWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN SRVFASTCALL
ReadRawPipe (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartMdlReadRawResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartPipeReadRawPeek (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbWriteRaw )
#pragma alloc_text( PAGE, AbortRawWrite )
#pragma alloc_text( PAGE, PrepareRawCopyWrite )
#pragma alloc_text( PAGE, ReadRawPipe )
#pragma alloc_text( PAGE, RestartMdlReadRawResponse )
#pragma alloc_text( PAGE, RestartPipeReadRawPeek )
#pragma alloc_text( PAGE, SrvRestartRawReceive )
#pragma alloc_text( PAGE, SrvRestartReadRawComplete )
#pragma alloc_text( PAGE, SrvRestartWriteCompleteResponse )
#pragma alloc_text( PAGE, SrvBuildAndSendWriteCompleteResponse )
#endif
#if 0
NOT PAGEABLE -- DumpMdlChain
NOT PAGEABLE -- SrvSmbReadRaw
NOT PAGEABLE -- SrvDecrementRawWriteCount
#endif

#if DBG
VOID
DumpMdlChain(
    IN PMDL mdl
    )
{
    ULONG mdlCount = 0;
    ULONG length = 0;

    if ( mdl == NULL ) {
        KdPrint(( "  <empty MDL chain>\n" ));
        return;
    }
    do {
        KdPrint(( "  mdl %p len %04x flags %04x sysva %p va %p offset %04x\n",
                    mdl, mdl->ByteCount, mdl->MdlFlags,
                    mdl->MappedSystemVa, mdl->StartVa, mdl->ByteOffset ));
        length += mdl->ByteCount;
        mdlCount++;
        mdl = mdl->Next;
    } while ( mdl != NULL );
    KdPrint(( "  total of %ld bytes in %ld MDLs\n", length, mdlCount ));
    return;
}
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadRaw (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read Block Raw SMB.

    Note that Read Block Raw cannot return an error response.  When the
    server is unable to process the request, for whatever reason, it
    simply responds with a zero-length message.  The client uses a
    normal Read SMB to determine what happened.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description of the
        parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_READ_RAW request;
    PREQ_NT_READ_RAW ntRequest;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCONNECTION connection;
    UCHAR minorFunction = 0;
    PVOID rawBuffer = NULL;
    CLONG readLength;
    PMDL mdl = NULL;
    ULONG key;
    LARGE_INTEGER offset;
    SHARE_TYPE shareType;
    KIRQL oldIrql;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_RAW;
    SrvWmiStartContext(WorkContext);

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsAttempted );

    request = (PREQ_READ_RAW)WorkContext->RequestParameters;
    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(RAW1) {
        KdPrint(( "Read Block Raw request; FID 0x%lx, count %ld, "
                    "offset %ld\n",
                    fid, SmbGetUshort( &request->MaxCount ),
                    SmbGetUlong( &request->Offset ) ));
    }

    //
    // If raw mode has been disabled or if the connection is unreliable,
    // reject the raw read.  Ask the client to use standard read by
    // sending a zero-length response.  The client will react by issuing
    // a normal Read SMB, which we will be able to process.
    //

    connection = WorkContext->Connection;

    if ( !SrvEnableRawMode || !connection->EnableRawIo ) {

        IF_SMB_DEBUG(RAW1) {
            KdPrint(( "SrvSmbReadRaw: Raw mode is disabled\n" ));
        }
        goto error_exit_no_cleanup;
    }

    //
    // Get the rfcb
    //

    //
    // Acquire the spin lock that guards the connection's file table.
    //

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    if ( connection->CachedFid == fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        PTABLE_HEADER tableHeader;
        USHORT index;
        USHORT sequence;

        //
        // Initialize local variables:  obtain the connection block address
        // and crack the FID into its components.
        //

        index = FID_INDEX( fid );
        sequence = FID_SEQUENCE( fid );

        //
        // Verify that the FID is in range, is in use, and has the correct
        // sequence number.

        tableHeader = &connection->FileTable;

        if ( (index >= (USHORT)tableHeader->TableSize) ||
             (tableHeader->Table[index].Owner == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ) {
            goto error_exit_no_cleanup_locked;
        }
        rfcb = tableHeader->Table[index].Owner;

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            goto error_exit_no_cleanup_locked;
        }

        //
        // If there is a write behind error, reject the raw read.
        //

        if ( !NT_SUCCESS(rfcb->SavedError) ) {
            goto error_exit_no_cleanup_locked;
        }

        //
        // Cache this rfcb
        //

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)fid;
    }

    //
    // The FID is valid within the context of this connection.  Verify
    // that the file is still active and that the owning tree connect's
    // TID is correct.
    //
    // Do not verify the UID for clients that do not understand it.
    //

    if ( (rfcb->Tid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )) ||
         ((rfcb->Uid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )) &&
           DIALECT_HONORS_UID(connection->SmbDialect)) ) {
        goto error_exit_no_cleanup_locked;
    }

    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    //
    // If a raw write is active, queue this work item in the RFCB
    // pending completion of the raw write.
    //

    if ( rfcb->RawWriteCount != 0 ) {

        InsertTailList(
            &rfcb->RawWriteSerializationList,
            &WorkContext->ListEntry
            );

        //
        // These 2 fields must be set with the connection spinlock held
        // since the workitem might be picked up by another thread and
        // a race condition will occur.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        WorkContext->Rfcb = NULL;

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // If this is a pipe read, we do things differently.
    //

    shareType = rfcb->ShareType;
    if ( shareType == ShareTypePipe ) {

        //
        // Indicate that a raw read is in progress on the connection.
        //

        connection->RawReadsInProgress++;

        //
        // The raw read can be accepted.  Reference the RFCB.
        //

        rfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        WorkContext->Rfcb = rfcb;
        if ( !ReadRawPipe( WorkContext ) ) {
            goto error_exit_cleanup;
        }
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // If there is an oplock break in progress, return 0 bytes read.  We
    // do this because our oplock break request SMB may have crossed on
    // the wire with the read raw request and it may have been received
    // in the client's raw read buffer.  This would cause the raw data
    // to complete in the client's regular receive buffer and possibly
    // to overrun it.
    //
    // If this is not the case, the client will simply retry the read
    // using a different read protocol.  If it is the case, the client
    // must detect this and break the oplock, then redo the read.
    //

    if ( connection->OplockBreaksInProgress > 0 ) {
        goto error_exit_no_cleanup_locked;
    }

    //
    // Check to see whether we got a round trip break/response.  If so,
    // reject read raw.
    //

    if ( (LONG)(connection->LatestOplockBreakResponse -
                                            WorkContext->Timestamp) >= 0 ) {
        goto error_exit_no_cleanup_locked;
    }

    //
    // If this is the first SMB received after sending an oplock break
    // II to none, reject this read.  We need to do this because there
    // is no response to such a break, so we don't know for sure if the
    // break crossed with the read, which would mean that the break
    // actually completed the client's read, which would mean that any
    // raw data that we sent would be incorrectly received.
    //

    if ( connection->BreakIIToNoneJustSent ) {
        connection->BreakIIToNoneJustSent = FALSE;
        goto error_exit_no_cleanup_locked;
    }

    //
    // Indicate that a raw read is in progress on the connection.
    //

    connection->RawReadsInProgress++;

    //
    // The raw read can be accepted.  Reference the RFCB.
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    WorkContext->Rfcb = rfcb;

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto error_exit_cleanup;
    }
    
    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    lfcb = rfcb->Lfcb;

#if SRVCATCH
    if ( rfcb->SrvCatch ) {
        //
        // Force the client through the core read path for this file
        //
        goto error_exit_cleanup;
    }
#endif

    if ( !rfcb->ReadAccessGranted ) {
        CHECK_PAGING_IO_ACCESS(
                        WorkContext,
                        rfcb->GrantedAccess,
                        &status );
        if ( !NT_SUCCESS( status ) ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbReadRaw: Read access not granted.\n"));
            }
            goto error_exit_cleanup;
        }
    }

    //
    // Calculate and save the read offset.
    //

    if ( request->WordCount == 8 ) {

        //
        // The client supplied a 32-bit offset.
        //

        offset.QuadPart = SmbGetUlong( &request->Offset );

    } else if ( request->WordCount == 10 ) {

        //
        // The client supplied a 64-bit offset.
        //

        ntRequest = (PREQ_NT_READ_RAW)WorkContext->RequestParameters;
        offset.LowPart = SmbGetUlong( &ntRequest->Offset );
        offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

        //
        // Reject negative offsets
        //

        if ( offset.QuadPart < 0 ) {
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbReadRaw: Negative offset rejected.\n"));
            }
            goto error_exit_cleanup;
        }

    } else {

        //
        // Invalid word count.  Return 0 bytes.
        //

        goto error_exit_cleanup;
    }

    WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset = offset;

    //
    // If this operation may block, and we're running short of
    // resources, or if the target is a paused comm device, reject the
    // request.
    //

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // If the SMB buffer is large enough, use it to do the local read.
    //

    readLength = SmbGetUshort( &request->MaxCount );
    WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Length = readLength;

    if ( //0 &&
         (readLength <= SrvMdlReadSwitchover) ) {

do_copy_read:

        WorkContext->Parameters.ReadRaw.SavedResponseBuffer = NULL;
        WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

        //
        // Try the fast I/O path first.
        //

        if ( lfcb->FastIoRead != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        WorkContext->ResponseBuffer->Buffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadRaw( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.  Build an MDL describing the read buffer.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            WorkContext->ResponseBuffer->Buffer,
            readLength
            );

        mdl = WorkContext->ResponseBuffer->PartialMdl;
        rawBuffer = WorkContext->ResponseHeader;

        ASSERT( minorFunction == 0 );

    } else {

        //
        // The SMB buffer isn't big enough.  Does the target file system
        // support the cache manager routines?
        //

        if ( lfcb->FileObject->Flags & FO_CACHE_SUPPORTED ) {

            WorkContext->Parameters.ReadRaw.MdlRead = TRUE;

            //
            // We can use an MDL read.  Try the fast I/O path first.
            //

            WorkContext->Irp->MdlAddress = NULL;
            WorkContext->Irp->IoStatus.Information = 0;

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            if ( lfcb->MdlRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    key,
                    &WorkContext->Irp->MdlAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) && WorkContext->Irp->MdlAddress ) {

                //
                // The fast I/O path worked.  Send the data.
                //
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartReadRaw( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            //
            // The fast I/O path failed.  We need to issue a regular MDL
            // read request.
            //
            // The fast path may have partially succeeded, returning a
            // partial MDL chain.  We need to adjust our read request
            // to account for that.
            //

            offset.QuadPart += WorkContext->Irp->IoStatus.Information;
            readLength -= (ULONG)WorkContext->Irp->IoStatus.Information;

            mdl = WorkContext->Irp->MdlAddress;
            minorFunction = IRP_MN_MDL;

        } else if (readLength > WorkContext->ResponseBuffer->BufferLength) {

            //
            // We have to use a normal "copy" read.  We need to allocate
            // a separate raw buffer.
            //

            ASSERT( minorFunction == 0 );
            WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

            rawBuffer = ALLOCATE_NONPAGED_POOL(
                            readLength,
                            BlockTypeDataBuffer
                            );
            IF_SMB_DEBUG(RAW2) KdPrint(( "rawBuffer: 0x%p\n", rawBuffer ));

            if ( rawBuffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbReadRaw: Unable to allocate raw "
                                "buffer\n" ));
                }

                goto error_exit_cleanup;

            }

            //
            // We also need a buffer descriptor.
            //
            // *** Note: Currently, ResponseBuffer == RequestBuffer in a
            //     WorkContext block, so we don't really have to save
            //     the ResponseBuffer field.  But we do so just to be on
            //     the safe side.
            //

            WorkContext->Parameters.ReadRaw.SavedResponseBuffer =
                                             WorkContext->ResponseBuffer;

            WorkContext->ResponseBuffer = ALLOCATE_NONPAGED_POOL(
                                            sizeof(BUFFER),
                                            BlockTypeBuffer
                                            );

            if ( WorkContext->ResponseBuffer == NULL ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "SrvSmbReadRaw: Unable to allocate %d bytes from "
                    "nonpaged pool.",
                    sizeof(BUFFER),
                    NULL
                    );

                DEALLOCATE_NONPAGED_POOL( rawBuffer );

                WorkContext->ResponseBuffer =
                      WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

                goto error_exit_cleanup;

            }

            WorkContext->ResponseBuffer->Buffer = rawBuffer;
            WorkContext->ResponseBuffer->BufferLength = readLength;

            //
            // Finally, we need an MDL to describe the raw buffer.
            //
            // *** We used to try to use the PartialMdl for the SMB
            //     buffer here, if it was big enough.  But since we
            //     already decided that the buffer itself isn't big
            //     enough, it's extremely likely that the MDL isn't big
            //     enough either.
            //

            mdl = IoAllocateMdl( rawBuffer, readLength, FALSE, FALSE, NULL );

            if ( mdl == NULL ) {

                DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
                WorkContext->ResponseBuffer =
                   WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

                DEALLOCATE_NONPAGED_POOL( rawBuffer );

                goto error_exit_cleanup;

            }

            WorkContext->ResponseBuffer->Mdl = mdl;

            //
            // Build the mdl
            //

            MmBuildMdlForNonPagedPool( mdl );

            //
            // Try the fast I/O path first.
            //

            if ( lfcb->FastIoRead != NULL ) {

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

                try {
                    if ( lfcb->FastIoRead(
                            lfcb->FileObject,
                            &offset,
                            readLength,
                            TRUE,
                            key,
                            WorkContext->ResponseBuffer->Buffer,
                            &WorkContext->Irp->IoStatus,
                            lfcb->DeviceObject
                            ) ) {
    
                        //
                        // The fast I/O path worked.  Send the data.
                        //
                        WorkContext->bAlreadyTrace = TRUE;
                        SrvFsdRestartReadRaw( WorkContext );
                        SmbStatus = SmbStatusInProgress;
                        goto Cleanup;
                    }
                }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    // Fall through to the slow path on an exception
                    NTSTATUS status = GetExceptionCode();
                    IF_DEBUG(ERRORS) {
                        KdPrint(("FastIoRead threw exception %x\n", status ));
                    }
                }

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            }

            //
            // The fast I/O path failed, so we need to use a regular copy
            // I/O request.
            //

        } else {

            goto do_copy_read;
        }

    } // read fits in SMB buffer?

    //
    // Build the read request, reusing the receive IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_READ,                    // major function code
            minorFunction,                  // minor function code
            rawBuffer,                      // buffer address
            readLength,                     // buffer length
            mdl,                            // MDL address
            offset,                         // byte offset
            key                             // lock key
            );

    //
    // Pass the request to the file system.
    //
    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartReadRaw;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbReadRaw: reading from file 0x%p, offset %ld, length %ld, destination 0x%p, ",
                    lfcb->FileObject, offset.LowPart, readLength,
                    rawBuffer ));
        KdPrint(( "func 0x%lx\n", minorFunction ));
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  When it completes, processing
    // resumes in the FSD at SrvFsdRestartReadRaw.
    //

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbReadRaw complete\n" ));
    SmbStatus = SmbStatusInProgress;
    goto Cleanup;

error_exit_no_cleanup_locked:

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

error_exit_no_cleanup:

    WorkContext->ResponseParameters = WorkContext->ResponseHeader;

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsRejected );

    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

error_exit_cleanup:

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    //
    // We are about to release the work context and possibly free the
    // connection.  Create a referenced pointer to the connection so
    // that we can send delayed oplock breaks, if necessary.
    //

    SrvReferenceConnectionLocked( connection );

    //
    // Since we cannot return an error code, we return zero bytes of
    // data.
    //

    WorkContext->ResponseParameters = WorkContext->ResponseHeader;

    //
    // If there is an oplock break request pending, then we must go to the
    // FSP to initiate the break, otherwise complete processing in the FSD.
    //

    if ( IsListEmpty( &connection->OplockWorkList ) ) {
        connection->RawReadsInProgress--;
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        SrvFsdSendResponse( WorkContext );
    } else {
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        SrvFsdSendResponse2( WorkContext, SrvRestartReadRawComplete );
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsRejected );

    //
    // Release the connection reference.
    //

    SrvDereferenceConnection( connection );
    SmbStatus = SmbStatusInProgress;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbReadRaw complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbReadRaw

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteRaw (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write Block Raw SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description of the
        parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_WRITE_RAW request;
    PREQ_NT_WRITE_RAW ntRequest;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb = NULL;
    PLFCB lfcb;
    ULONG immediateLength;
    BOOLEAN immediateWriteDone = FALSE;
    USHORT fid;
    PCHAR writeAddress;
    ULONG writeLength;
    ULONG key;
    SHARE_TYPE shareType;
    LARGE_INTEGER offset;
    PWORK_CONTEXT rawWorkContext;
    PVOID finalResponseBuffer = NULL;
    PCONNECTION connection;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_RAW;
    SrvWmiStartContext(WorkContext);

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawWritesAttempted );

    request = (PREQ_WRITE_RAW)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_WRITE_RAW)WorkContext->RequestParameters;
    fid = SmbGetUshort( &request->Fid );

    //
    // If the client is MS-NET 1.03 or before, reject him.  We don't
    // support raw writes from these clients.
    //

    connection = WorkContext->Connection;
    if ( connection->SmbDialect >= SmbDialectMsNet103 ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "Raw write request from MS-NET 1.03 client.\n" ));
        }
        status = STATUS_SMB_USE_STANDARD;
        goto error_exit_no_rfcb;
    }

    IF_SMB_DEBUG(RAW1) {
        KdPrint(( "Write Block Raw request; FID 0x%lx, count %ld, "
                    "offset %ld, immediate length %ld\n",
                    fid,
                    SmbGetUshort( &request->Count ),
                    SmbGetUlong( &request->Offset ),
                    SmbGetUshort( &request->DataLength ) ));
    }

    immediateLength = SmbGetUshort( &request->DataLength );
    writeLength = SmbGetUshort( &request->Count );

    //
    // make sure the immediate length:
    //      is not greater than the total bytes, and
    //      does not go beyond what we are given
    //

    if ( ( immediateLength > writeLength ) ||
         ( immediateLength > ( WorkContext->ResponseBuffer->DataLength -
                                    SmbGetUshort(&request->DataOffset) ) )
       ) {

        status = STATUS_INVALID_SMB;
        goto error_exit_no_rfcb;
    }

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // address is stored in the WorkContext block, and the RFCB address
    // is returned.  In addition, the active raw write count is
    // incremented.
    //

    //
    // See if the fid matches the cached fid.
    //

    rfcb = SrvVerifyFidForRawWrite(
                WorkContext,
                fid,
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbWriteRaw: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            goto error_exit_no_rfcb;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    if( lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        goto error_exit;
    }
    
    //
    // Validate the word count.
    //

    if ( shareType == ShareTypePipe ) {

        if ( (request->WordCount != 12) && (request->WordCount != 14) ) {
            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

    } else {

        if ( request->WordCount == 12 ) {

            offset.QuadPart = SmbGetUlong( &request->Offset );

        } else if ( request->WordCount == 14 ) {

            offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh ) ;
            offset.LowPart = SmbGetUlong( &ntRequest->Offset ) ;

            //
            // Reject negative offsets.  Add the offset to the immediate
            // length and make sure that the result is not negative. We do the
            // first check ( highpart >= 0x7fffffff ) so that in most cases
            // we do only one check.
            //

            if ( (ULONG)offset.HighPart >= (ULONG)0x7fffffff &&
                 ( (offset.QuadPart < 0) ||
                   ((offset.QuadPart + immediateLength) < 0) ) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbWriteRaw: Negative offset rejected.\n"));
                }

                status = STATUS_INVALID_SMB;
                goto error_exit;
            }

        } else {

            status = STATUS_INVALID_SMB;
            goto error_exit;
        }
    }

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteRaw: Read access not granted.\n"));
        }
        status = STATUS_ACCESS_DENIED;
        goto error_exit;
    }

    //
    // Ensure that the write is extending the file if the user only has append access
    //
    if( !rfcb->WriteAccessGranted &&
        offset.QuadPart < rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteRaw: Only append access to file allowed!\n" ));
        }

        SrvStatistics.GrantedAccessErrors++;
        status = STATUS_ACCESS_DENIED;
        goto error_exit;
    }

#ifdef INCLUDE_SMB_IFMODIFIED
    rfcb->Lfcb->FileUpdated = TRUE;
#endif

    rfcb->WrittenTo = TRUE;

    //
    // If this operation may block, and we're running short of
    // resources, or if the target is a paused comm device, reject the
    // request.  Note that we do NOT write immediate data -- this is the
    // same behavior as the OS/2 server.
    //
    // !!! Implement the pause comm device test.
    //

    if ( rfcb->BlockingModePipe ) {

        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Reject the request.
            //
            // !!!  Consider routing the request to the FSP, instead.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbWriteRaw: No resources for blocking "
                            "write\n" ));
            }

            SrvFailedBlockingIoCount++;
            SrvStatistics.BlockingSmbsRejected++;
            status = STATUS_SMB_USE_STANDARD;
            goto error_exit;

        } else {

            //
            // It is okay to start a blocking operation.
            // SrvReceiveBufferShortage() has already incremented
            // SrvBlockingOpsInProgress.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    } else if ( shareType == ShareTypeDisk &&
         ( ((ULONG)request->WriteMode & SMB_WMODE_WRITE_THROUGH) << 1 !=
           ((ULONG)lfcb->FileMode & FILE_WRITE_THROUGH) ) ) {

        //
        // Change the write through mode of the file, if necessary.
        //

        ASSERT( SMB_WMODE_WRITE_THROUGH == 0x01 );
        ASSERT( FILE_WRITE_THROUGH == 0x02 );

        SrvSetFileWritethroughMode(
            lfcb,
            (BOOLEAN)( (SmbGetUshort( &request->WriteMode )
                            & SMB_WMODE_WRITE_THROUGH) != 0 )
            );
    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        ULONG immediateLength, rawLength;
        KIRQL oldIrql;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->WriteCount++;
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        entry->Flags = 0;
        immediateLength = SmbGetUshort( &request->DataLength );
        rawLength = SmbGetUshort( &request->Count ) - immediateLength;
        if ( immediateLength != 0 ) {
            entry->Flags = (UCHAR)(entry->Flags | 2);
        }

        if ( ((lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) != 0)
           ) {
            entry->Flags = (UCHAR)(entry->Flags | 1);
        }
#if 0
        if ( ((lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) != 0) &&
             (rawLength > SrvMaxCopyWriteLength) ) {
            entry->Flags = (UCHAR)(entry->Flags | 1);
        }
#endif
        KeQuerySystemTime( &entry->Time );
        entry->Data.ReadWrite.Offset = SmbGetUlong( &request->Offset );
        entry->Data.ReadWrite.Length = SmbGetUshort( &request->Count );
    }
#endif

    //
    // If immediate data was sent write it first.
    //
    // If this is a named pipe, do not write the data unless all of the
    // write data was sent in the original request.  We cannot do the
    // write in 2 parts, in case this is a message mode pipe.
    //
    // *** Note that this is different from the OS/2 server.  It turns
    //     out to be easier for us to write the immediate data first,
    //     rather than copying it into a staging buffer pending receipt
    //     of the raw write data.  This is largely due to using MDL
    //     writes -- we don't allocate a staging buffer when we do an
    //     MDL write.
    //

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to
    //     account for the folding of multiple remote
    //     compatibility mode opens into a single local
    //     open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );


    if ( immediateLength != 0 ) {

        if ( (shareType != ShareTypePipe) ||
             (SmbGetUshort( &request->Count ) == (USHORT)immediateLength) ) {

            if ( lfcb->FastIoWrite != NULL ) {

                writeAddress = (PCHAR)WorkContext->RequestHeader +
                                        SmbGetUshort( &request->DataOffset );

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

                try {
                    immediateWriteDone = lfcb->FastIoWrite(
                                            lfcb->FileObject,
                                            &offset,
                                            immediateLength,
                                            TRUE,
                                            key,
                                            writeAddress,
                                            &WorkContext->Irp->IoStatus,
                                            lfcb->DeviceObject
                                            );
                    IF_SMB_DEBUG(RAW2) {
                        KdPrint(( "SrvSmbWriteRaw: fast immediate write %s\n",
                                immediateWriteDone ? "worked" : "failed" ));
                    }
    
                    if ( immediateWriteDone ) {
                        writeLength -= immediateLength;
                        offset.QuadPart += immediateLength;
                    } else {
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );
                    }
                }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    // Fall through to the slow path on an exception
                    NTSTATUS status = GetExceptionCode();
                    immediateWriteDone = FALSE;
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );
                    IF_DEBUG(ERRORS) {
                        KdPrint(("FastIoRead threw exception %x\n", status ));
                    }
                }

            }

        }

    } else {

        immediateWriteDone = TRUE;

    }

    //
    // If the remaining write length is 0 (strange but legal), send a
    // success response.
    //

    if ( writeLength == 0 ) {

        IF_SMB_DEBUG(RAW1) {
            KdPrint(( "PrepareRawWrite: No raw data !?!\n" ));
        }
        status = STATUS_SUCCESS;
        goto error_exit;
    }

    //
    // Reject Raw write if:
    //      raw mode has been disabled, or
    //      connection is unreliable, or
    //      file is non-cached and it is a write behind and it is a disk
    //          file (this condition is necessary to prevent a client
    //          from getting old data back when it does a raw read
    //          immediately after a raw write.  This can result in
    //          synchronization problems.
    //

    if ( !SrvEnableRawMode ||
         !connection->EnableRawIo ) {

        IF_SMB_DEBUG(RAW1) {
            KdPrint(( "SrvSmbWriteRaw: Raw mode is disabled\n" ));
        }

        //
        // Update server statistics.
        //

        status =  STATUS_SMB_USE_STANDARD;
        goto error_exit;
    }

    //
    // Obtain a raw mode work item from the raw mode pool.  If none are
    // available, ask the client to use a standard write request.
    //

    rawWorkContext = SrvGetRawModeWorkItem( );

    if ( rawWorkContext == NULL ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteRaw: No raw mode work items "
                        "available\n" ));
        }

        SrvOutOfRawWorkItemCount++;

        status =  STATUS_SMB_USE_STANDARD;
        goto error_exit;

    }

    IF_SMB_DEBUG(RAW2) KdPrint(( "rawWorkContext: 0x%p\n", rawWorkContext ));

    //
    // If writethough mode was specified, we'll need to send a final
    // response SMB.  Allocate a nonpaged buffer to contain the
    // response.  If this fails, ask the client to use a standard write
    // request.
    //

    if ( (SmbGetUshort( &request->WriteMode ) &
                                        SMB_WMODE_WRITE_THROUGH) != 0 ) {

        finalResponseBuffer = ALLOCATE_NONPAGED_POOL(
                                sizeof(SMB_HEADER) +
                                    SIZEOF_SMB_PARAMS(RESP_WRITE_COMPLETE,0),
                                BlockTypeDataBuffer
                                );
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "finalResponseBuffer: 0x%p\n", finalResponseBuffer ));
        }

        if ( finalResponseBuffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbWriteRaw: Unable to allocate %d bytes from "
                    "nonpaged pool",
                sizeof(SMB_HEADER) + SIZEOF_SMB_PARAMS(RESP_WRITE_COMPLETE,0),
                NULL
            );

            SrvRequeueRawModeWorkItem( rawWorkContext );

            status = STATUS_SMB_USE_STANDARD;
            goto error_exit;
        }
    }

    //
    // Save necessary context information in the additional work context
    // block.
    //

    rawWorkContext->Parameters.WriteRaw.FinalResponseBuffer = finalResponseBuffer;
    rawWorkContext->Parameters.WriteRaw.ImmediateWriteDone = immediateWriteDone;
    rawWorkContext->Parameters.WriteRaw.ImmediateLength = immediateLength;

    rawWorkContext->Parameters.WriteRaw.Offset = offset;

    rawWorkContext->Parameters.WriteRaw.Pid =
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    WorkContext->Parameters.WriteRawPhase1.RawWorkContext = rawWorkContext;

    //
    // Copy the start time from the original work context.  Indicate
    // that no statistics should be saved from the original, and what
    // kind of statistics should be saved from the raw work context.
    //

    rawWorkContext->StartTime = 0;

    //
    // Copy pointers from the original work context to the raw work
    // context, referencing as necessary.
    //

    rawWorkContext->Endpoint = WorkContext->Endpoint; // not a referenced ptr

    rawWorkContext->Connection = connection;
    SrvReferenceConnection( connection );

    rawWorkContext->Share = NULL;
    rawWorkContext->Session = NULL;
    rawWorkContext->TreeConnect = NULL;

    rawWorkContext->Rfcb = rfcb;
    SrvReferenceRfcb( rfcb );

    //
    // Prepare either a copy write or an MDL write, as appropriate.
    //
    if ( !(lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

        //
        // The file system doesn't support MDL write.  Prepare a copy
        // write.
        //

        rawWorkContext->Parameters.WriteRaw.MdlWrite = FALSE;

        PrepareRawCopyWrite( WorkContext );
        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // The file system supports MDL write.  Prepare an MDL write.
    //

    rawWorkContext->Parameters.WriteRaw.MdlWrite = TRUE;
    rawWorkContext->Parameters.WriteRaw.Length = writeLength;

    //
    // Try the fast path first.
    //

    WorkContext->Irp->MdlAddress = NULL;
    WorkContext->Irp->IoStatus.Information = 0;
    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbWriteRaw: trying fast path for offset %ld, "
                    "length %ld\n", offset.LowPart, writeLength ));
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

    if ( lfcb->PrepareMdlWrite(
            lfcb->FileObject,
            &offset,
            writeLength,
            key,
            &WorkContext->Irp->MdlAddress,
            &WorkContext->Irp->IoStatus,
            lfcb->DeviceObject
            ) && WorkContext->Irp->MdlAddress != NULL ) {

        //
        // The fast I/O path worked.  Send the go-ahead response.
        //

#if DBG
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "SrvSmbWriteRaw: fast path worked; MDL %p, length 0x%p\n", WorkContext->Irp->MdlAddress,
                        (PVOID)WorkContext->Irp->IoStatus.Information ));
            DumpMdlChain( WorkContext->Irp->MdlAddress );
        }
#endif
        WorkContext->bAlreadyTrace = TRUE;
        SrvFsdRestartPrepareRawMdlWrite( WorkContext );
        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    //
    // The fast I/O path failed.  Build the write request, reusing the
    // receive IRP.
    //
    // The fast path may have partially succeeded, returning a partial
    // MDL chain.  We need to adjust our write request to account for
    // that.
    //

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbWriteRaw: fast path failed; MDL %p, length 0x%p\n", WorkContext->Irp->MdlAddress,
                    (PVOID)WorkContext->Irp->IoStatus.Information ));
    }

    offset.QuadPart += WorkContext->Irp->IoStatus.Information;
    writeLength -= (ULONG)WorkContext->Irp->IoStatus.Information;

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,                   // input IRP address
            lfcb->FileObject,                   // target file object address
            WorkContext,                        // context
            IRP_MJ_WRITE,                       // major function code
            IRP_MN_MDL,                         // minor function code
            NULL,                               // buffer address (ignored)
            writeLength,                        // buffer length
            WorkContext->Irp->MdlAddress,       // MDL address
            offset,                             // byte offset
            key                                 // lock key
            );

    //
    // Pass the request to the file system.
    //

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbWriteRaw: write to file 0x%p, offset %ld, length %ld\n",
                    lfcb->FileObject, offset.LowPart, writeLength ));
    }

        WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartPrepareRawMdlWrite;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The MDL write has been started.  When it completes, processing
    // resumes at SrvFsdRestartPrepareRawMdlWrite.
    //

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
    SmbStatus = SmbStatusInProgress;
    goto Cleanup;

error_exit:

    SrvDecrementRawWriteCount( rfcb );

error_exit_no_rfcb:

    SrvFsdBuildWriteCompleteResponse(
                                WorkContext,
                                status,
                                immediateWriteDone ? immediateLength : 0
                                );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawWritesRejected );
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbWriteRaw

VOID SRVFASTCALL
AbortRawWrite(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Handles cleanup when a raw write is aborted after the interim
    "go-ahead" response has been sent.  This routine is only used
    when a catastrophic errors occurs -- for example, the connection
    is closing.  It does not send a final response to the client.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

        This must be a pointer to the raw mode work item -- not the
        original work item that received the Write Raw SMB.

Return Value:

    None.

--*/

{
    PMDL cacheMdl;
    PMDL partialMdl;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Deallocate the final response buffer, if any.
    //

    if ( WorkContext->Parameters.WriteRaw.FinalResponseBuffer != NULL ) {
        DEALLOCATE_NONPAGED_POOL(
            WorkContext->Parameters.WriteRaw.FinalResponseBuffer
            );
        WorkContext->Parameters.WriteRaw.FinalResponseBuffer = NULL;
    }

    if ( !WorkContext->Parameters.WriteRaw.MdlWrite ) {

        //
        // This was a copy write.  Deallocate the raw receive buffer.
        // Note that we do not need to unlock the raw buffer, because it
        // was allocated out of nonpaged pool and locked using
        // MmBuildMdlForNonPagedPool, which doesn't increment reference
        // counts and therefore has no inverse.
        //

        if ( WorkContext->Parameters.WriteRaw.ImmediateWriteDone ) {
            DEALLOCATE_NONPAGED_POOL( WorkContext->RequestBuffer->Buffer );
        } else {
            DEALLOCATE_NONPAGED_POOL(
                (PCHAR)WorkContext->RequestBuffer->Buffer -
                        WorkContext->Parameters.WriteRaw.ImmediateLength );
        }

        //
        // Dereference control blocks and requeue the raw mode work
        // item.
        //

        WorkContext->ResponseBuffer->Buffer = NULL;
        SrvRestartWriteCompleteResponse( WorkContext );
        return;

    }

    //
    // This was an MDL write.  If a partial MDL was built (because of
    // immediate data), unmap it.  Then complete the MDL write,
    // indicating that no data was actually written.
    //

    cacheMdl = WorkContext->Parameters.WriteRaw.FirstMdl;
    partialMdl = WorkContext->Irp->MdlAddress;

    if ( partialMdl != cacheMdl ) {
        ASSERT( (partialMdl->MdlFlags & MDL_PARTIAL) != 0 );
        MmPrepareMdlForReuse( partialMdl );
    }

#if DBG
    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "AbortRawWrite: Completing MDL write with length 0\n" ));
        DumpMdlChain( cacheMdl );
    }
#endif

    if( WorkContext->Rfcb->Lfcb->MdlWriteComplete == NULL ||

        WorkContext->Rfcb->Lfcb->MdlWriteComplete(
           WorkContext->Rfcb->Lfcb->FileObject,
           &WorkContext->Parameters.WriteRaw.Offset,
           cacheMdl,
           WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

        status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                             cacheMdl,
                                             IRP_MJ_WRITE,
                                             &WorkContext->Parameters.WriteRaw.Offset,
                                             WorkContext->Parameters.WriteRaw.Length
                                           );

        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
        }
    }

    SrvRestartWriteCompleteResponse( WorkContext );

    return;

} // AbortRawWrite


VOID SRVFASTCALL
PrepareRawCopyWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Prepares for a raw "copy" write.  Allocates a buffer to receive the
    raw data, prepares a work context block and an IRP describing the
    raw receive, queues it to the connection, and sends a "go-ahead"
    response.

    Any immediate data sent in the request SMB has already been written
    when this routine is called, unless this is a named pipe write, in
    which case the immediate data has not been written.  In this case,
    we alllocate a buffer big enough for the the immediate data plus the
    raw data, then copy the immediate data to the raw buffer before
    proceeding.  The raw data will be received appended to the immediate
    data.  Then both peices can be written with a single write.  This is
    needed so that data written to a message mode pipe will not be
    written in 2 pieces.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PWORK_CONTEXT rawWorkContext;
    PREQ_WRITE_RAW request;
    PRESP_WRITE_RAW_INTERIM response;

    NTSTATUS status;
    PVOID rawBuffer;
    PCHAR writeAddress;
    PMDL mdl;
    SHARE_TYPE shareType;
    PVOID finalResponseBuffer;

    ULONG immediateLength;
    BOOLEAN immediateWriteDone;
    ULONG writeLength;
    ULONG bufferLength;

    BOOLEAN sendWriteComplete = TRUE;

    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - PrepareRawCopyWrite\n" ));

    //
    // Set up local variables.
    //

    rawWorkContext = WorkContext->Parameters.WriteRawPhase1.RawWorkContext;
    request = (PREQ_WRITE_RAW)WorkContext->RequestParameters;
    shareType = rawWorkContext->Rfcb->ShareType;
    immediateLength = rawWorkContext->Parameters.WriteRaw.ImmediateLength;
    immediateWriteDone =
                    rawWorkContext->Parameters.WriteRaw.ImmediateWriteDone;
    writeLength = SmbGetUshort( &request->Count ) - immediateLength;
    finalResponseBuffer =
        rawWorkContext->Parameters.WriteRaw.FinalResponseBuffer;

    if ( !immediateWriteDone ) {
        bufferLength = writeLength + immediateLength;
    } else {
        bufferLength = writeLength;
    }

    //
    // Allocate a nonpaged buffer to contain the write data.  If this
    // fails, ask the client to use a standard write request.
    //

    rawBuffer = ALLOCATE_NONPAGED_POOL( bufferLength, BlockTypeDataBuffer );
    IF_SMB_DEBUG(RAW2) KdPrint(( "rawBuffer: 0x%p\n", rawBuffer ));

    if ( rawBuffer == NULL ) {

        // !!! Should we log this error?

        IF_DEBUG(ERRORS) {
            KdPrint(( "PrepareRawCopyWrite: Unable to allocate "
                        "raw buffer\n" ));
        }

        status = STATUS_SMB_USE_STANDARD;
        goto abort;

    }

    if ( !immediateWriteDone ) {

        //
        // Copy the immediate data to the raw buffer.
        //

        writeAddress = (PCHAR)WorkContext->RequestHeader +
                                        SmbGetUshort( &request->DataOffset );

        RtlCopyMemory( rawBuffer, writeAddress, immediateLength );

        //
        // Move the virtual start of the raw buffer to the end of the
        // immediate data.
        //

        rawBuffer = (PCHAR)rawBuffer + immediateLength;

    }

    //
    // If a final response is going to be sent, save information from
    // the request in the final response buffer.
    //

    if ( finalResponseBuffer != NULL ) {
        RtlCopyMemory(
            (PSMB_HEADER)finalResponseBuffer,
            WorkContext->RequestHeader,
            sizeof(SMB_HEADER)
            );
    }

    //
    // Set up the buffer descriptor for the raw buffer.
    //

    rawWorkContext->RequestBuffer->Buffer = rawBuffer;
    rawWorkContext->RequestBuffer->BufferLength = writeLength;

    //
    // Initialize the MDL to describe the raw buffer.
    // (SrvBuildIoControlRequest will lock the buffer for I/O.)
    //

    mdl = rawWorkContext->RequestBuffer->Mdl;

    MmInitializeMdl( mdl, rawBuffer, writeLength );

    //
    // Build the mdl
    //

    MmBuildMdlForNonPagedPool( mdl );

    //
    // Set up the restart routines in the work context block.
    //

    rawWorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    rawWorkContext->FspRestartRoutine = SrvRestartRawReceive;

    //
    // Build the I/O request packet.
    //

    (VOID)SrvBuildIoControlRequest(
            rawWorkContext->Irp,                // input IRP address
            NULL,                               // target file object address
            rawWorkContext,                     // context
            IRP_MJ_INTERNAL_DEVICE_CONTROL,     // major function
            TDI_RECEIVE,                        // minor function
            NULL,                               // input buffer address
            0,                                  // input buffer length
            rawBuffer,                          // output buffer address
            writeLength,                        // output buffer length
            mdl,                                // MDL address
            NULL
            );

    irpSp = IoGetNextIrpStackLocation( rawWorkContext->Irp );

    //
    // If this is a writebehind write, tell the transport that we don't
    // plan to reply to the received message.
    //

    if ( finalResponseBuffer == NULL ) {
        ((PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters)->ReceiveFlags |=
                                                TDI_RECEIVE_NO_RESPONSE_EXP;
    }

    //
    // Post the receive.
    //

    irpSp->Flags = 0;
    irpSp->DeviceObject = rawWorkContext->Connection->DeviceObject;
    irpSp->FileObject = rawWorkContext->Connection->FileObject;

    ASSERT( rawWorkContext->Irp->StackCount >= irpSp->DeviceObject->StackSize );

    (VOID)IoCallDriver( irpSp->DeviceObject, rawWorkContext->Irp );

    //
    // Build the interim (go-ahead) response.
    //

    response = (PRESP_WRITE_RAW_INTERIM)WorkContext->ResponseParameters;

    response->WordCount = 1;
    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_RAW_INTERIM,
                                        0
                                        );

    //
    // Send off the interim response by ending processing of the SMB.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    IF_DEBUG(TRACE2) KdPrint(( "PrepareRawCopyWrite complete\n" ));
    return;

abort:

    //
    // For one reason or another, we are not going to receive any raw
    // data, so clean up.
    //
    if ( finalResponseBuffer != NULL ) {
        DEALLOCATE_NONPAGED_POOL( finalResponseBuffer );
    }

    SrvRestartWriteCompleteResponse( rawWorkContext );

    //
    // If a response is to be sent, send it now.
    //

    if ( sendWriteComplete ) {

        SrvFsdBuildWriteCompleteResponse(
            WorkContext,
            status,
            immediateWriteDone ? immediateLength : 0
            );

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    } else {

        SrvDereferenceWorkItem( WorkContext );

    }

    IF_DEBUG(TRACE2) KdPrint(( "PrepareRawCopyWrite complete\n" ));
    return;

} // PrepareRawCopyWrite

BOOLEAN SRVFASTCALL
ReadRawPipe (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Read Block Raw SMB for pipes.

    Note that Read Block Raw cannot return an error response.  When the
    server is unable to process the request, for whatever reason, it
    simply responds with a zero-length message.  The client uses a
    normal Read SMB to determine what happened.

Arguments:

    WorkContext - Pointer to the work context block.

Return Value:

    TRUE, if operation succeeds.
    FALSE, otherwise

--*/

{
    PREQ_READ_RAW request;

    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCONNECTION connection;
    UCHAR minorFunction = 0;
    BOOLEAN byteModePipe;
    PVOID rawBuffer = NULL;
    CLONG readLength;
    PMDL mdl = NULL;
    ULONG key;
    LARGE_INTEGER offset;

    PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;

    PAGED_CODE( );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsAttempted );

    request = (PREQ_READ_RAW)WorkContext->RequestParameters;

    fid = SmbGetUshort( &request->Fid );
    readLength = SmbGetUshort( &request->MaxCount );

    //
    // If raw mode has been disabled or if the connection is unreliable,
    // reject the raw read.  Ask the client to use standard read by
    // sending a zero-length response.  The client will react by issuing
    // a normal Read SMB, which we will be able to process.
    //

    connection = WorkContext->Connection;

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;
    byteModePipe = rfcb->ByteModePipe;

    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if ( !rfcb->ReadAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "ReadRawPipe: Read access not granted.\n"));
        }
        return(FALSE);
    }

    //
    // Verify the word counts
    //

    if ( (request->WordCount != 8) && (request->WordCount != 10) ) {

        //
        // Invalid word count.  Return 0 bytes.
        //

        return(FALSE);
    }

    //
    // If this operation may block, and we're running short of
    // resources, or if the target is a paused comm device, reject the
    // request.
    //

    if ( rfcb->BlockingModePipe ) {

         if ( SrvReceiveBufferShortage( ) ) {

            //
            // Reject the request.
            //
            // !!!  Consider routing the request to the FSP, instead.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "ReadRawPipe: No resources for blocking "
                            "read\n" ));
            }

            SrvFailedBlockingIoCount++;
            SrvStatistics.BlockingSmbsRejected++;
            return(FALSE);

        }

        //
        // It is okay to start a blocking operation.
        // SrvReceiveBufferShortage() has already incremented
        // SrvBlockingOpsInProgress.
        //

        WorkContext->BlockingOperation = TRUE;
    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // If the SMB buffer is large enough, use it to do the local read.
    //

    if ( readLength <= WorkContext->ResponseBuffer->BufferLength ) {

        WorkContext->Parameters.ReadRaw.SavedResponseBuffer = NULL;
        WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

        //
        // Try the fast I/O path first.
        //

        if ( byteModePipe && (lfcb->FastIoRead != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        WorkContext->ResponseBuffer->Buffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadRaw( WorkContext );
                    return TRUE;
    
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );
        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.  Build an MDL describing the read buffer.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            WorkContext->ResponseBuffer->Buffer,
            readLength
            );

        mdl = WorkContext->ResponseBuffer->PartialMdl;
        rawBuffer = WorkContext->ResponseHeader;

        ASSERT( minorFunction == 0 );

    } else {

        //
        // We have to use a normal "copy" read.  We need to allocate
        // a separate raw buffer.
        //

        ASSERT( minorFunction == 0 );
        WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

        rawBuffer = ALLOCATE_NONPAGED_POOL(
                        readLength,
                        BlockTypeDataBuffer
                        );
        IF_SMB_DEBUG(RAW2) KdPrint(( "rawBuffer: 0x%p\n", rawBuffer ));

        if ( rawBuffer == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "ReadRawPipe: Unable to allocate raw buffer\n" ));
            }

            return(FALSE);

        }

        //
        // We also need a buffer descriptor.
        //
        // *** Note: Currently, ResponseBuffer == RequestBuffer in a
        //     WorkContext block, so we don't really have to save
        //     the ResponseBuffer field.  But we do so just to be on
        //     the safe side.
        //

        WorkContext->Parameters.ReadRaw.SavedResponseBuffer =
                                         WorkContext->ResponseBuffer;

        WorkContext->ResponseBuffer = ALLOCATE_NONPAGED_POOL(
                                        sizeof(BUFFER),
                                        BlockTypeBuffer
                                        );

        if ( WorkContext->ResponseBuffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "ReadRawPipe: Unable to allocate %d bytes from "
                "nonpaged pool.",
                sizeof(BUFFER),
                NULL
                );

            DEALLOCATE_NONPAGED_POOL( rawBuffer );

            WorkContext->ResponseBuffer =
                  WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

            return(FALSE);
        }

        WorkContext->ResponseBuffer->Buffer = rawBuffer;
        WorkContext->ResponseBuffer->BufferLength = readLength;

        //
        // Finally, we need an MDL to describe the raw buffer.
        //
        // *** We used to try to use the PartialMdl for the SMB
        //     buffer here, if it was big enough.  But since we
        //     already decided that the buffer itself isn't big
        //     enough, it's extremely likely that the MDL isn't big
        //     enough either.
        //

        mdl = IoAllocateMdl( rawBuffer, readLength, FALSE, FALSE, NULL );

        if ( mdl == NULL ) {

            DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
            WorkContext->ResponseBuffer =
               WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

            DEALLOCATE_NONPAGED_POOL( rawBuffer );

            return(FALSE);

        }

        WorkContext->ResponseBuffer->Mdl = mdl;

        //
        // Build the mdl
        //

        MmBuildMdlForNonPagedPool( mdl );

        //
        // Try the fast I/O path first.
        //

        if ( byteModePipe && (lfcb->FastIoRead != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        WorkContext->ResponseBuffer->Buffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadRaw( WorkContext );
                    return TRUE;
    
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.
        //

    } // read fits in SMB buffer?

    //
    // This is a read block raw on a named pipe.  If this is a
    // non-blocking read on a blocking mode pipe, we need to do a
    // peek first.  This is to ensure that we don't end up waiting
    // when we're not supposed to.
    //
    // *** We used to have to peek on message mode pipes, in case
    //     the message was too large or zero-length.  But now we
    //     have a special pipe FSCTL for this.  See below.
    //

    if ( (SmbGetUshort( &request->MinCount ) == 0) &&
          rfcb->BlockingModePipe ) {

        //
        // Allocate a buffer to peek the pipe.  This buffer is freed
        // in RestartPipeReadRawPeek().
        //

        pipePeekBuffer = ALLOCATE_NONPAGED_POOL(
                            FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                            BlockTypeDataBuffer
                            );

        if ( pipePeekBuffer == NULL ) {

            //
            // Can't allocate a buffer to do a peek.  Nothing to do
            // but return zero bytes to the client.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "ReadRawPipe: Unable to allocate %d bytes from"
                    "nonpaged pool.",
                FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                NULL
                );

            if ( WorkContext->Parameters.ReadRaw.SavedResponseBuffer !=
                                                            NULL ) {

                if ( mdl != WorkContext->Parameters.ReadRaw.
                                SavedResponseBuffer->PartialMdl ) {
                    IoFreeMdl( mdl );
                }

                DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
                WorkContext->ResponseBuffer =
                   WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

                DEALLOCATE_NONPAGED_POOL( rawBuffer );

            }

            return(FALSE);

        }

        //
        // Save the address of the pipe peek buffer for the restart
        // routine.
        //

        WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.PipePeekBuffer =
            pipePeekBuffer;

        //
        // Build the pipe peek request.  We just want the header
        // information.  We do not need any data.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_PEEK,
            pipePeekBuffer,
            0,
            NULL,
            FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
            NULL,
            NULL
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartPipeReadRawPeek;

        //
        // Pass the request to NPFS.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    } else {

        //
        // This is a blocking read, or a non-blocking read on a
        // non-blocking pipe.  Build and issue the read request.  If
        // this is a message-mode pipe, use the special ReadOverflow
        // FSCTL.  This FSCTL returns an error if the pipe is a
        // message mode pipe and the first message in the pipe is
        // either too big or has length 0.  We need this because we
        // can't return an error on a raw read -- the best we can do
        // is return a zero-length message.  So we need the
        // operation to act like a Peek if the message is the wrong
        // size.  That's what the special FSCTL gives us.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            byteModePipe ?
                FSCTL_PIPE_INTERNAL_READ : FSCTL_PIPE_INTERNAL_READ_OVFLOW,
            WorkContext->ResponseBuffer->Buffer,
            0,
            NULL,
            SmbGetUshort( &request->MaxCount ),
            NULL,
            NULL
            );
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartReadRaw;
        DEBUG WorkContext->FspRestartRoutine = NULL;

        IF_SMB_DEBUG(RAW2) {
            KdPrint((
                "ReadRawPipe: reading from file 0x%p, "
                    "length %ld, destination 0x%p\n",
                 lfcb->FileObject,
                 SmbGetUshort( &request->MaxCount ),
                 WorkContext->Parameters.ReadRaw.
                     SavedResponseBuffer->Buffer
            ));
        }

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The read has been started.  When it completes, processing
        // resumes at SrvFsdRestartReadRaw.
        //

    }

    IF_DEBUG(TRACE2) KdPrint(( "ReadRawPipe complete\n" ));
    return TRUE;

} // ReadRawPipe

VOID SRVFASTCALL
RestartMdlReadRawResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes response send completion for an MDL read.  Releases the
    MDL back to the file system.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PAGED_CODE( );

    IF_DEBUG(FSD2) KdPrint(( " - RestartMdlReadRawResponse\n" ));

    //
    // Call the Cache Manager to release the MDL chain.  If the MDL read
    // failed to return an MDL (for example, if the read was entirely
    // beyond EOF), then we don't have to do this.
    //

    if ( WorkContext->Irp->MdlAddress ) {

        if( WorkContext->Rfcb->Lfcb->MdlReadComplete == NULL ||

            WorkContext->Rfcb->Lfcb->MdlReadComplete(
                WorkContext->Rfcb->Lfcb->FileObject,
                WorkContext->Irp->MdlAddress,
                WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                            WorkContext->Irp->MdlAddress,
                                            IRP_MJ_READ,
                                            &WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset,
                                            WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Length
                     );

            if( !NT_SUCCESS( status ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }

    }

    //
    // Start oplock break notifications, if any are outstanding.
    // SrvSendDelayedOplockBreak also sets read raw in progress to FALSE.
    //

    SrvSendDelayedOplockBreak( WorkContext->Connection );

    //
    // Finish postprocessing of the SMB.
    //

    SrvDereferenceWorkItem( WorkContext );

    IF_DEBUG(FSD2) KdPrint(( "RestartMdlReadRawResponse complete.\n" ));
    return;

} // RestartMdlReadRawResponse


VOID SRVFASTCALL
RestartPipeReadRawPeek (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function continues a read raw on a named pipe handle.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;
    PREQ_READ_RAW request;
    ULONG readLength;
    ULONG readDataAvailable;
    ULONG messageLength;
    ULONG numberOfMessages;
    PLFCB lfcb;
    PRFCB rfcb;

    PAGED_CODE( );

    pipePeekBuffer = WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.
                                                            PipePeekBuffer;
    request = (PREQ_READ_RAW)WorkContext->RequestParameters;
    readLength = SmbGetUshort( &request->MaxCount );

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    //
    // The pipe peek has completed.  Extract the critical information,
    // then free the buffer.
    //

    readDataAvailable = pipePeekBuffer->ReadDataAvailable;
    messageLength = pipePeekBuffer->MessageLength;
    numberOfMessages = pipePeekBuffer->NumberOfMessages;

    DEALLOCATE_NONPAGED_POOL( pipePeekBuffer );

    //
    // The read request is a non-blocking read on a blocking mode pipe.
    // We react differently based on whether it is a byte mode pipe or
    // a message mode pipe.
    //
    // Byte mode: If there is _any_ data in the pipe, we go get it.  The
    //      read will complete immediately, copying either as much data
    //      as is available, or enough to fill the buffer, whichever is
    //      less, and there will be no error.  If there is no data in
    //      the pipe, we have to return immediately, because we can't
    //      wait for data to arrive.
    //
    // Message mode:  If there are no messages available, or if the
    //      first message is either zero-length or bigger than the
    //      client's buffer, we return immediately.  We can't indicate
    //      underflow or overflow, so we can't allow the message to be
    //      pulled out of the queue.  Otherwise, we can do the read.
    //

    if ( ( rfcb->ByteModePipe &&
           (readDataAvailable == 0)
         )
         ||
         ( !rfcb->ByteModePipe &&
           ( (numberOfMessages == 0)
             ||
             (messageLength == 0)
             ||
             (messageLength > readLength)
           )
         )
       ) {

        if ( WorkContext->Parameters.ReadRaw.SavedResponseBuffer != NULL ) {

            if ( WorkContext->ResponseBuffer->Mdl != WorkContext->Parameters.
                            ReadRaw.SavedResponseBuffer->PartialMdl ) {
                IoFreeMdl( WorkContext->ResponseBuffer->Mdl );
            }

            DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer->Buffer );

            DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
            WorkContext->ResponseBuffer =
               WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

        }

        WorkContext->ResponseParameters = WorkContext->ResponseHeader;
        SrvFsdSendResponse( WorkContext );

        IF_DEBUG(TRACE2) KdPrint(( "RestartPipeReadRawPeek complete\n" ));
        return;

    }

    //
    // We have bypassed all of the pitfalls of doing a read block raw
    // on a named pipe.
    //
    // Build and issue the read request.
    //
    // *** Note that we do not use the special ReadOverflow FSCTL here
    //     because we know from the above tests that we don't need to.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_READ,
        WorkContext->ResponseBuffer->Buffer,
        0,
        NULL,
        readLength,
        NULL,
        NULL
        );

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartReadRaw;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "RestartPipeReadRawPeek: reading from file 0x%p, length %ld, destination 0x%p\n",
                    lfcb->FileObject, readLength,
                    WorkContext->ResponseBuffer->Buffer ));
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  When it completes, processing resumes
    // at SrvFsdRestartReadRaw.
    //

    IF_DEBUG(TRACE2) KdPrint(( "RestartPipeReadRawPeek complete\n" ));
    return;

} // RestartPipeReadRawPeek


VOID SRVFASTCALL
SrvDecrementRawWriteCount (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This routine decrements the count of active raw writes for an RFCB.
    If the count goes to zero, and there are work items queued pending
    completion of the raw write, they are restarted.  If the count goes
    to zero, and the RFCB is closing, then the RFCB's cleanup is resumed
    here.

    This routine is called in both the FSP and the FSD.

Arguments:

    Rfcb - Supplies a pointer to the RFCB.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    KIRQL oldIrql;
    PCONNECTION connection = Rfcb->Connection;

    //
    // Acquire the spin lock that guards the count.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Decrement the active raw write count.
    //

    ASSERT( Rfcb->RawWriteCount > 0 );
    Rfcb->RawWriteCount--;

    if ( Rfcb->RawWriteCount == 0 ) {

        //
        // No raw writes are active.  Flush the list of work items
        // that were queued pending the completion of the raw write
        // by restarting each of them.
        //

        while ( !IsListEmpty(&Rfcb->RawWriteSerializationList) ) {

            listEntry = RemoveHeadList( &Rfcb->RawWriteSerializationList );
            workContext = CONTAINING_RECORD(
                            listEntry,
                            WORK_CONTEXT,
                            ListEntry
                            );
            QUEUE_WORK_TO_FSP( workContext );

        }

        if ( GET_BLOCK_STATE(Rfcb) == BlockStateClosing ) {

            //
            // The count is now zero and the RFCB is closing.  The
            // cleanup was deferred pending the completion of all raw
            // writes.  Do the cleanup now.
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            SrvCompleteRfcbClose( Rfcb );

        } else {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        }

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    }

    return;

} // SrvDecrementRawWriteCount

VOID SRVFASTCALL
SrvRestartRawReceive (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine that is invoked when Write Block Raw
    write data is received.  It starts the local write operation.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PIRP irp;
    PRFCB rfcb;
    PLFCB lfcb;
    PMDL mdl;
    PMDL partialMdl;
    PCHAR writeAddress;
    CLONG writeLength;
    LARGE_INTEGER offset;
    PVOID finalResponseBuffer;
    CLONG immediateLength;
    ULONG key;
    NTSTATUS status;

    PAGED_CODE( );

    IF_DEBUG(FSD1) KdPrint(( " - SrvRestartRawReceive\n" ));

    //
    // If the I/O request failed or was canceled, or if the connection
    // that received the message is no longer active, or if the server
    // FSP isn't active, abort the request.
    //
    // *** Note that we don't send a final response in any of these
    //     cases.  We assume that the failure is catastrophic, so
    //     there's no use sending a response.
    //

    connection = WorkContext->Connection;
    irp = WorkContext->Irp;

    WorkContext->CurrentWorkQueue->stats.BytesReceived += irp->IoStatus.Information;

    if ( irp->Cancel ||
         !NT_SUCCESS(irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(connection) != BlockStateActive) ||
         SrvFspTransitioning ) {

        IF_DEBUG(TRACE2) {
            if ( irp->Cancel ) {
                KdPrint(( "  I/O canceled\n" ));
            } else if ( !NT_SUCCESS(irp->IoStatus.Status) ) {
                KdPrint(( "  I/O failed: %X\n", irp->IoStatus.Status ));
            } else if ( SrvFspTransitioning ) {
                KdPrint(( "  Server is shutting down.\n" ));
            } else {
                KdPrint(( "  Connection no longer active\n" ));
            }
        }

        //
        // Abort the raw write.
        //

        AbortRawWrite( WorkContext );

        IF_DEBUG(TRACE2) KdPrint(( "SrvRestartRawReceive complete\n" ));
        return;

    }

    //
    // Set up local variables.
    //

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;
    finalResponseBuffer = WorkContext->Parameters.WriteRaw.FinalResponseBuffer;
    immediateLength = WorkContext->Parameters.WriteRaw.ImmediateLength;

    //
    // Determine whether we're doing "copy write" or "MDL write".
    //

    if ( WorkContext->Parameters.WriteRaw.MdlWrite ) {

#if DBG
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "SrvRestartRawReceive: Receive MDL chain after receive\n" ));
            DumpMdlChain( irp->MdlAddress );
        }
#endif

        //
        // This was an MDL write.  If a partial MDL was built (because
        // of immediate data), unmap it.  Then complete the MDL write.
        //

        mdl = WorkContext->Parameters.WriteRaw.FirstMdl;
        partialMdl = WorkContext->Irp->MdlAddress;

        if ( partialMdl != mdl ) {
            ASSERT( (partialMdl->MdlFlags & MDL_PARTIAL) != 0 );
            MmPrepareMdlForReuse( partialMdl );
        }

        //
        // Build the "complete MDL write" request.  Note that
        // irp->IoStatus.Information, which is where we're supposed to
        // put the amount of data actually written, already contains the
        // length of the received data.
        //

        irp->MdlAddress = mdl;

        if ( !WorkContext->Parameters.WriteRaw.ImmediateWriteDone ) {
            irp->IoStatus.Information += immediateLength;
        }

#if DBG
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "SrvRestartRawReceive: Completing MDL write with length 0x%p\n",
                        (PVOID)irp->IoStatus.Information ));
            DumpMdlChain( mdl );
        }
#endif

        if( lfcb->MdlWriteComplete == NULL ||

            lfcb->MdlWriteComplete(
               lfcb->FileObject,
               &WorkContext->Parameters.WriteRaw.Offset,
               mdl,
               lfcb->DeviceObject ) == FALSE ) {

            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 mdl,
                                                 IRP_MJ_WRITE,
                                                 &WorkContext->Parameters.WriteRaw.Offset,
                                                 WorkContext->Parameters.WriteRaw.Length
                    );

            if( !NT_SUCCESS( status ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }

        SrvFsdRestartWriteRaw( WorkContext );

        return;

    }

    //
    // We're doing a copy write.  Get parameters for the request.
    //

    offset = WorkContext->Parameters.WriteRaw.Offset;
    mdl = WorkContext->RequestBuffer->Mdl;

    //
    // Determine the amount of data to write.  This is the actual amount
    // of data sent by the client.  (Note that this cannot be more than
    // the client originally requested.)
    //

    writeAddress = (PCHAR)WorkContext->RequestBuffer->Buffer;
    writeLength = (ULONG)irp->IoStatus.Information;

    //
    // If the immediate data was not written earlier, it immedidately
    // precedes the data we just received.  Adjust writeAddress and
    // writeLength so that it too is written.
    //

    if ( !WorkContext->Parameters.WriteRaw.ImmediateWriteDone ) {
        writeAddress -= immediateLength;
        writeLength += immediateLength;

    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid | WorkContext->Parameters.WriteRaw.Pid;

    //
    // Try the fast I/O path first.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly.
                //
    
                SrvFsdRestartWriteRaw( WorkContext );
                return;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The fast I/O path failed, so we need to issue a real I/O request.
    //
    // Remap the MDL to describe only the received data, which may be
    // less than was originally mapped.
    //
    // !!! Is this really necessary?  Can't we just pass in the entire
    //     MDL, and count on the file system to know when to stop?
    //

    if ( writeLength != WorkContext->RequestBuffer->BufferLength ) {
        MmInitializeMdl( mdl, writeAddress, writeLength );
        MmBuildMdlForNonPagedPool( mdl );
    }

    if ( rfcb->ShareType != ShareTypePipe ) {

        //
        // Start the write request, reusing the receive IRP.
        //

        SrvBuildReadOrWriteRequest(
                irp,                         // input IRP address
                lfcb->FileObject,            // target file object address
                WorkContext,                 // context
                IRP_MJ_WRITE,                // major function code
                0,                           // minor function code
                writeAddress,                // buffer address
                writeLength,                 // buffer length
                mdl,                         // MDL address
                offset,                      // byte offset
                key                          // lock key
                );

    } else {

        //
        // Build a write request for NPFS.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_WRITE,
            writeAddress,
            writeLength,
            NULL,
            0,
            NULL,
            NULL
            );

    }

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvRestartRawReceive: writing to file 0x%p, offset %ld, length %ld\n",
                    lfcb->FileObject, offset.LowPart, writeLength ));
    }

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvFsdRestartWriteRaw;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  When it completes, processing
    // continues at SrvFsdRestartWriteRaw.
    //

    return;

} // SrvRestartRawReceive


VOID SRVFASTCALL
SrvRestartReadRawComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine completes a read raw by starting any oplock breaks that
    may have been deferred due to the read raw.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Start oplock break notifications, if any are outstanding.
    // SrvSendDelayedOplockBreak also sets read raw in progress to FALSE.
    //

    SrvSendDelayedOplockBreak( WorkContext->Connection );

    //
    // Finish postprocessing of the SMB.
    //

    SrvDereferenceWorkItem( WorkContext );

    return;

} // SrvRestartReadRawComplete


VOID SRVFASTCALL
SrvRestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine that is invoked to clean up after a
    Write Block Raw/Mpx completes, and the necessary clean up could not
    be done in the FSD.  See RestartWriteCompleteResponse in fsd.c.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - SrvRestartWriteCompleteResponse\n" ));

    //
    // Decrement the active raw write count for the RFCB, potentially
    // allowing the RFCB to be closed.  If WorkContext->Rfcb is NULL,
    // then the count has been decremented in the fsd.
    //

    if ( WorkContext->Rfcb != NULL ) {
        SrvDecrementRawWriteCount ( WorkContext->Rfcb );
    }

    //
    // Dereference control blocks and the connection.
    //

    SrvReleaseContext( WorkContext );

    SrvDereferenceConnection( WorkContext->Connection );
    WorkContext->Connection = NULL;
    WorkContext->Endpoint = NULL;       // not a referenced pointer

    //
    // Put the work item back on the raw mode work item list.
    //

    SrvRequeueRawModeWorkItem( WorkContext );

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartWriteCompleteResponse complete\n" ));
    return;

} // SrvRestartWriteCompleteResponse


VOID SRVFASTCALL
SrvBuildAndSendWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Sets up and sends a final response to a Write Block Raw/Mpx request.

    This routine is called in the FSP.  It is invoked as a restart routine
    from the FSD when the status to be returned is not STATUS_SUCCESS.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    SrvFsdBuildWriteCompleteResponse(
        WorkContext,
        WorkContext->Irp->IoStatus.Status,
        (ULONG)WorkContext->Irp->IoStatus.Information
        );

    WorkContext->ResponseBuffer->DataLength =
                    (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                    (PCHAR)WorkContext->ResponseHeader );
    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    SRV_START_SEND_2(
        WorkContext,
        SrvFsdSendCompletionRoutine,
        WorkContext->FsdRestartRoutine,
        NULL
        );

    return;

} // SrvBuildAndSendWriteCompleteResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbprocs.h

Abstract:

    This module defines functions for processing SMBs.

Author:

    Chuck Lenzmeier (chuckl) 5-Oct-1989

Revision History:

--*/

#ifndef _SMBPROCS_
#define _SMBPROCS_

//#include <ntos.h>

//#include "srvblock.h"


//
// SMB processing routine definiton.  SMB_PROCESSOR_PARAMETERS is used
// to declare SMB processing routines.  It reduces the changes that
// have to be made if the definition changes.  SMB_PROCESSOR_ARGUMENTS
// is used by one SMB processor to call another.
//
//

#define SMB_PROCESSOR_PARAMETERS        \
    IN OUT PWORK_CONTEXT WorkContext

#define SMB_PROCESSOR_ARGUMENTS         \
    WorkContext

#define SMB_PROCESSOR_RETURN_TYPE SMB_STATUS SRVFASTCALL
#define SMB_PROCESSOR_RETURN_LOCAL SMB_STATUS

//
// SMB processor return status.
//

typedef enum _SMB_STATUS {
    SmbStatusMoreCommands,
    SmbStatusSendResponse,
    SmbStatusNoResponse,
    SmbStatusInProgress
} SMB_STATUS, *PSMB_STATUS;

//
// SMB transaction processor return status.
//

typedef enum _SMB_TRANS_STATUS {
    SmbTransStatusSuccess,
    SmbTransStatusErrorWithData,
    SmbTransStatusErrorWithoutData,
    SmbTransStatusInProgress
} SMB_TRANS_STATUS, *PSMB_TRANS_STATUS;


typedef
SMB_STATUS
(SRVFASTCALL *PSMB_PROCESSOR) (
    SMB_PROCESSOR_PARAMETERS
    );

/*++

Routine Description:

    The SMB_PROCESSOR is a routine that is called to process a specific
    SMB command.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  In particular, the following
        fields are valid:

        RequestHeader - Address of the request SMB header.

        RequestParameters - Address of the current command's request
            parameters.  The SMB processor should update this field to
            point to the next command in the SMB, if any.

        ResponseHeader - Address of the response SMB header.  Initially,
            this is a copy of the request header.  As return data, such
            as UID, TID, and FID, becomes available, it should be
            written into both the request header (for AndX command
            processors) and the response header (for the client).  Note
            that the response header address *may* be the same as the
            request header address.

        ResponseParameters - Address of the current command's response
            parameters.  The SMB processor should write the response
            data to this address, then update the pointer to point to
            the address of the next command's response area, if any.
            If there are no more commands in the SMB, this field should
            be set to point to the first byte after the response so that
            the length of the response can be computed.

        Endpoint, Connection - Addresses of the endpoint and the
            connection that received the SMB.  These fields should not
            be changed by the SMB processor.  Other block pointers in
            WorkContext (Share, Session, TreeConnect, and Rfcb) may be
            set by the SMB processor if such blocks are referenced
            during processing.  Any non-NULL pointers in these fields
            are dereferenced when SMB processing is complete, before the
            response (if any) is sent.  The Connection and Endpoint
            pointers are not cleared until the WorkContext is requeued
            to the receive queue.

        Parameters - This union is used by the various SMB processors to
            retain state during asynchronous operations.

Return Value:

    SMB_STATUS - Indicates the action to be taken by the calling routine.
        Possible values are the following:

        SmbStatusMoreCommands - There is at least one more AndX
            follow-on command in the request SMB.  The SMB processor has
            updated RequestParameters and ResponseParameters in
            WorkContext to point to the next command's request and
            response areas.  It has also copied the command code of
            the next command into RequestHeader->Command, so that
            SrvProcessSmb can dispatch the next request.

        SmbStatusSendResponse - Processing of the request is complete,
            and a response is to be sent.  ResponseParameters has been
            updated to point to the first location *after* the end of
            the response.  This is used to compute the length of the
            response.

        SmbStatusNoResponse - Processing of the request is complete, but
            either no response is needed or the SMB processor has
            already taken care of sending the response(s).

        SmbStatusInProgress - The SMB processor has started an
            asynchronous operation and will continue processing the SMB
            at an appropriate restart routine when the operation
            completes.  The restart routine, after updating WorkContext,
            calls SrvSmbProcessSmb to continue (or end) processing the
            SMB.

--*/


typedef
SMB_TRANS_STATUS
(*PSMB_TRANSACTION_PROCESSOR) (
    IN OUT PWORK_CONTEXT WorkContext
    );

/*++

Routine Description:

    The SMB_TRANSACTION_PROCESSOR is a routine that is called to process
    a specific Transaction or Transaction2 SMB subfunction.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  In particular, the following
        fields are valid and intended for use by the transaction
        processor:

        ResponseHeader - Address of the response SMB header.  Initially,
            this is a copy of the request header.  The transaction
            processor may update the error class and code fields if it
            encounters an error.

        Parameters.Transacton - Points to the transaction block
            describing the transaction.  All block pointer fields
            (Connection, Session, TreeConnect) in the block are valid.
            Pointers to the setup words and parameter and data bytes,
            and the lengths of these items, are valid.  The transaction
            block is on the connection's pending transaction list.

            The transaction processor must update the transaction block
            to indicate how much data to return.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  FALSE indicates that
        the operation was successful, and that the data counts were
        updated to indicate how much data to return.  TRUE indicates
        that an error occurred, and that SrvSetSmbError was called to
        update the response header and place a null parameters field at
        the end of the response.

--*/


//
// SMB Processing routines.
//

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNotImplemented (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateDirectory (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbDeleteDirectory (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpen (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreate (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbClose (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFlush (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbDelete (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbRename (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbRead (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWrite (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockByteRange (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbUnlockByteRange (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateTemporary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateNew (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCheckDirectory (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbProcessExit (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSeek (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockAndRead (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadRaw (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadMpx (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteRaw (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpx (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpxSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation2 (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation2 (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockingAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransaction (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransaction (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCreateAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctl (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctlSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbMove (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbEcho (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndClose (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCloseAndTreeDisc (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindClose2 (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindNotifyClose (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnect (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeDisconnect (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNegotiate (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSessionSetupAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLogoffAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnectAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformationDisk (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSearch (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenPrintFile (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbClosePrintFile (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbGetPrintQueue (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCancel (
    SMB_PROCESSOR_PARAMETERS
    );

//
// Transaction SMB processors
//

SMB_TRANS_STATUS
SrvSmbOpen2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFsctl (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbIoctl2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFindNotify (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbCreateDirectory2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbCreateWithSdOrEa (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbNtIoctl (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbNtNotifyChange (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbNtRename (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQuerySecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetSecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryQuota (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetQuota (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvTransactionNotImplemented (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Dfs transactions and support routines
//
VOID
SrvInitializeDfs();

VOID
SrvTerminateDfs();

SMB_TRANS_STATUS
SrvSmbGetDfsReferral (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbReportDfsInconsistency (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS SRVFASTCALL
DfsNormalizeName(
    IN PSHARE Share,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN BOOLEAN StripLastComponent,
    IN OUT PUNICODE_STRING String
    );

NTSTATUS SRVFASTCALL
DfsFindShareName(
    IN PUNICODE_STRING ShareName
    );

VOID SRVFASTCALL
SrvIsShareInDfs(
    IN PSHARE Share,
    OUT BOOLEAN *IsDfs,
    OUT BOOLEAN *IsDfsRoot
);


#if DBG
VOID
SrvValidateCompressedData(
    PWORK_CONTEXT         WorkContext,
    PMDL                  CompressedDataMdl,
    PCOMPRESSED_DATA_INFO Cdi
);
#endif

#endif // def _SMBPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbproc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbproc.c

Abstract:

   This module contains the high-level routines for processing SMBs.
   Current contents:

        SrvEndSmbProcessing
        SrvProcessSmb

        SrvRestartFsdComplete
        SrvRestartSmbReceived

        SrvSmbIllegalCommand
        SrvSmbNotImplemented
        SrvTransactionNotImplemented

Author:

    David Treadwell (davidtr) 25-Sept-1989
    Chuck Lenzmeier

Revision History:

--*/

#include "precomp.h"
#include "smbproc.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBPROC

#ifdef ALLOC_PRAGMA
//#pragma alloc_text( PAGE, SrvEndSmbProcessing )
//#pragma alloc_text( PAGE, SrvProcessSmb )
#pragma alloc_text( PAGE, SrvRestartFsdComplete )
//#pragma alloc_text( PAGE, SrvRestartReceive )
#pragma alloc_text( PAGE, SrvRestartSmbReceived )
#pragma alloc_text( PAGE, SrvSmbIllegalCommand )
#pragma alloc_text( PAGE, SrvSmbNotImplemented )
#pragma alloc_text( PAGE, SrvTransactionNotImplemented )
#endif

USHORT SessionInvalidateCommand = 0xFFFF;
USHORT SessionInvalidateIndex = 0;
USHORT SessionInvalidateMod = 100;


VOID
SrvEndSmbProcessing (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_STATUS SmbStatus
    )

/*++

Routine Description:

    This routine is called when all request processing on an SMB is
    complete.  If no response is to be sent, this routine simply cleans
    up and requeues the request buffer to the receive queue.  If a
    response is to be sent, this routine starts the sending of that
    response; in this case SrvFsdRestartSmbComplete will do the rest of
    the cleanup after the send completes.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        containing information about the SMB.

    SmbStatus - Either SmbStatusSendResponse or SmbStatusNoResponse.

Return Value:

    None.

--*/

{
    CLONG sendLength;

    PAGED_CODE( );

    IF_DEBUG(WORKER2) SrvPrint0( "SrvEndSmbProcessing entered\n" );

    if ( SmbStatus == SmbStatusSendResponse ) {

        //
        // A response is to be sent. The response starts at
        // WorkContext->ResponseHeader, and its length is calculated
        // using WorkContext->ResponseParameters, which the SMB
        // processor set to point to the next location *after* the end
        // of the response.
        //

        sendLength = (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                (PCHAR)WorkContext->ResponseHeader );

        WorkContext->ResponseBuffer->DataLength = sendLength;

        //
        // Set the bit in the SMB that indicates this is a response from
        // the server.
        //

        WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

        //
        // Send out the response.  When the send completes,
        // SrvFsdRestartSmbComplete is called.  We then put the original
        // buffer back on the receive queue.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );

        //
        // The send has been started.  Our work is done.
        //

        IF_DEBUG(WORKER2) SrvPrint0( "SrvEndSmbProcessing complete\n" );
        return;

    }

    //
    // There was no response to send.  Dereference the work item.
    //

    SrvDereferenceWorkItem( WorkContext );

    IF_DEBUG(WORKER2) SrvPrint0( "SrvEndSmbProcessing complete\n" );
    return;

} // SrvEndSmbProcessing


VOID SRVFASTCALL
SrvProcessSmb (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine dispatches the command(s) in an SMB to the appropriate
    processing routines.  Based on the current command code, it calls
    indirectly through the dispatch table (SrvFspSmbDispatchTable).  The
    SMB processor executes the command, updates pointers into the SMB,
    and returns with an indication of whether there is another command
    to be processed.  If yes, this routine dispatches the next command.
    If no, this routine sends a response, if any.  Alternatively, if the
    SMB processor starts an asynchronous operation, it can indicate so,
    and this routine will simply return to its caller.

    This routine is called initially from SrvRestartSmbReceived, which
    is the FSP routine that gains control after a TdiReceive completion
    work item is queued to the FSP.  It is also called from other
    restart routines when asynchronous operations, such as a file read,
    complete and there are chained (AndX) commands to process.

    SrvRestartSmbReceive loads SMB pointers and such into the work
    context block calling this routine.  Notably, it copies the first
    command code in the SMB into WorkContext->NextCommand.  When an AndX
    command is processed, the SMB processor must load the chained
    command code into NextCommand before calling this routine to process
    that command.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        containing information about the SMB to process.  This block
        is updated during the processing of the SMB.

Return Value:

    None.

--*/

{
    SMB_STATUS smbStatus;
    LONG commandIndex;

    PAGED_CODE( );

    IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb entered\n" );

    //
    // Loop dispatching SMB processors until a status other than
    // SmbStatusMoreCommands is returned.  When an SMB processor returns
    // this command code, it also sets the next command code in
    // WorkContext->NextCommand, so that we can dispatch the next
    // command.
    //

    if( WorkContext->ProcessingCount == 1 &&
        WorkContext->Connection->SmbSecuritySignatureActive &&
        SrvCheckSmbSecuritySignature( WorkContext ) == FALSE ) {

        //
        // We've received an SMB with an invalid security signature!
        //
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;
    }

    while ( TRUE ) {

        if( ( (WorkContext->NextCommand == SessionInvalidateCommand) ||
              (SessionInvalidateCommand == 0xFF00)
            ) &&
            !((SessionInvalidateIndex++)%SessionInvalidateMod)
          )
        {
            SrvVerifyUid( WorkContext, SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
            if( WorkContext->Session )
            {
                WorkContext->Session->IsSessionExpired = TRUE;
                KdPrint(( "-=- Expiring Session %p -=-\n", WorkContext->Session ));
            }
        }

        //
        // The first SMB has been validated in the FSD.  It is safe to
        // execute it now.
        //

        commandIndex = SrvSmbIndexTable[WorkContext->NextCommand];

#if DBG
        IF_SMB_DEBUG( TRACE ) {
            KdPrint(( "%s @%p, Blocking %d, Count %d\n",
                    SrvSmbDispatchTable[ commandIndex ].Name,
                    WorkContext,
                    WorkContext->UsingBlockingThread,
                    WorkContext->ProcessingCount ));
        }
#endif

        smbStatus = SrvSmbDispatchTable[commandIndex].Func( WorkContext );

        //
        // If the SMB processor returned SmbStatusInProgress, it started
        // an asynchronous operation and will restart SMB processing
        // when that operation completes.
        //

        if ( smbStatus == SmbStatusInProgress ) {
            IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb complete\n" );
            return;
        }

        //
        // If the SMB processor didn't return SmbStatusMoreCommands,
        // processing of the SMB is done.  Call SrvEndSmbProcessing to
        // send the response, if any, and rundown the WorkContext.
        //
        // *** SrvEndSmbProcessing is a separate function so that
        //     asynchronous restart routines have something to call when
        //     they are done processing the SMB.
        //

        if ( smbStatus != SmbStatusMoreCommands ) {
            SrvEndSmbProcessing( WorkContext, smbStatus );
            IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb complete\n" );
            return;
        }

        //
        // There are more commands in the SMB.  Verify the SMB to make
        // sure that it has a valid header, and that the word count and
        // byte counts are within range.
        //

        if ( !SrvValidateSmb( WorkContext ) ) {
            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvProcessSmb: Invalid SMB.\n" );
                SrvPrint1( "  SMB received from %z\n",
                        (PCSTRING)&WorkContext->Connection->OemClientMachineNameString );
            }
            SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
            IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb complete\n" );
            return;
        }

    }

    // can't get here.

} // SrvProcessSmb


VOID SRVFASTCALL
SrvRestartFsdComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine invoked when SMB processing by the FSD
    is complete.  It's necessary to get back into the FSP in order to
    dereference objects that were used during the processing of the SMB.
    This is true because dereferencing an object may cause it to be
    deleted, which cannot happen in the FSD.

    This routine first dereferences control blocks.  Then, if a response
    SMB was sent, it checks for and processes send errors.  Finally, it
    requeues the work context block as a receive work item.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(WORKER1) SrvPrint0( " - SrvRestartFsdComplete\n" );

    if ( WorkContext->OplockOpen ) {
        SrvCheckDeferredOpenOplockBreak( WorkContext );
    }

    //
    // Dereference the work item.
    //

    SrvDereferenceWorkItem( WorkContext );
    IF_DEBUG(TRACE2) SrvPrint0( "SrvRestartFsdComplete complete\n" );
    return;

} // SrvRestartFsdComplete


VOID SRVFASTCALL
SrvRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for TDI Receive completion.  It validates
    the smb and setups header and parameter pointers in the work context
    block and before forwarding the request to SmbProcessSmb.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PIRP irp;
    PSMB_HEADER header;
    ULONG length;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) SrvPrint0( " - SrvRestartReceive\n" );

    connection = WorkContext->Connection;
    irp = WorkContext->Irp;

    //
    // Save the length of the received message.  Store the length
    // in the work context block for statistics gathering.
    //

    length = (ULONG)irp->IoStatus.Information;
    WorkContext->RequestBuffer->DataLength = length;
    WorkContext->CurrentWorkQueue->stats.BytesReceived += length;

    //
    // Store in the work context block the time at which processing
    // of the request began.  Use the time that the work item was
    // queued to the FSP for this purpose.
    //

    WorkContext->StartTime = WorkContext->Timestamp;

    //
    // Update the server network error count.  If the TDI receive
    // failed or was canceled, don't try to process an SMB.
    //

    if ( !irp->Cancel &&
         NT_SUCCESS(irp->IoStatus.Status) ||
         irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW ) {

        SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

        if( irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW ) {
            WorkContext->LargeIndication = TRUE;
        }

        //
        // We (should) have received an SMB.
        //

        SMBTRACE_SRV2(
            WorkContext->ResponseBuffer->Buffer,
            WorkContext->ResponseBuffer->DataLength
            );

        //
        // Initialize the error class and code fields in the header to
        // indicate success.
        //

        header = WorkContext->ResponseHeader;

        SmbPutUlong( &header->ErrorClass, STATUS_SUCCESS );

        //
        // If the connection is closing or the server is shutting down,
        // ignore this SMB.
        //

        if ( (GET_BLOCK_STATE(connection) == BlockStateActive) &&
             !SrvFspTransitioning ) {

            //
            // Verify the SMB to make sure that it has a valid header,
            // and that the word count and byte counts are within range.
            //

            WorkContext->NextCommand = header->Command;

            if ( SrvValidateSmb( WorkContext ) ) {

                //
                // If this is NOT a raw read request, clear the flag
                // that indicates the we just sent an oplock break II to
                // none.  This allows subsequent raw reads to be
                // processed.
                //

                if ( header->Command != SMB_COM_READ_RAW ) {
                    connection->BreakIIToNoneJustSent = FALSE;
                }

                //
                // Process the received SMB.  The called routine is
                // responsible for sending any response(s) that are
                // needed and for getting the receive buffer back onto
                // the receive queue as soon as possible.
                //

                SrvProcessSmb( WorkContext );

                IF_DEBUG(TRACE2) SrvPrint0( "SrvRestartReceive complete\n" );
                return;

            } else {

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint0( "SrvProcessSmb: Invalid SMB.\n" );
                    SrvPrint1( "  SMB received from %z\n",
                               (PCSTRING)&WorkContext->Connection->OemClientMachineNameString );
                }

                //
                // The SMB is invalid.  We send back an INVALID_SMB
                // status, unless this looks like a Read Block Raw
                // request, in which case we send back a zero-byte
                // response, so as not to confuse the redirector.
                //

                if ( header->Command != SMB_COM_READ_RAW ) {
                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                } else {
                    WorkContext->ResponseParameters = header;
                }

                if( WorkContext->LargeIndication ) {
                    //
                    // We need to consume the rest of the messaage!
                    //
                    SrvConsumeSmbData( WorkContext );
                    return;
                }
                SrvFsdSendResponse( WorkContext );
                return;

            }

        } else {

            SrvDereferenceWorkItem( WorkContext );
            return;

        }

    } else if( irp->Cancel || (irp->IoStatus.Status == STATUS_CANCELLED) ) {
        
        // The Cancel routine was called while we were receiving.  Let us consume
        // any data left on the transport and return cancelled as the user wishes.
        // We don't bother to return anything if the connection is going down.
        if( (GET_BLOCK_STATE(connection) == BlockStateActive) &&
             !SrvFspTransitioning  )
        {
            SrvSetSmbError( WorkContext, STATUS_CANCELLED );

            if( WorkContext->LargeIndication ) {
                //
                // We need to consume the rest of the messaage!
                //
                SrvConsumeSmbData( WorkContext );
                return;
            }

            SrvFsdSendResponse( WorkContext );
            return;
        }
        else
        {
            SrvDereferenceWorkItem( WorkContext );
            return;
        }

    } else {

        IF_DEBUG(NETWORK_ERRORS) {
            SrvPrint2( "SrvRestartReceive: status = %X for IRP %p\n",
                irp->IoStatus.Status, irp );
        }
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, TRUE );
        SrvDereferenceWorkItem( WorkContext );
        return;

    }

} // SrvRestartReceive


VOID SRVFASTCALL
SrvRestartSmbReceived (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function is the worker thread restart routine for received
    SMBs.  It calls SrvProcessSmb to start processing of the first
    command in the SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(WORKER1) SrvPrint0( " - SrvRestartSmbReceived\n" );

    if ( (GET_BLOCK_STATE(WorkContext->Connection) != BlockStateActive) ||
         SrvFspTransitioning ) {

        //
        // The connection must be disconnecting.  Simply ignore this SMB.
        //

        SrvDereferenceWorkItem( WorkContext );

    } else {

        //
        // Process the received SMB.  The called routine is responsible
        // for sending any response(s) that are needed and for getting
        // the receive buffer back onto the receive queue as soon as
        // possible.
        //

        SrvProcessSmb( WorkContext );

    }

    IF_DEBUG(TRACE2) SrvPrint0( "SrvRestartSmbReceived complete\n" );
    return;

} // SrvRestartSmbReceived

SMB_PROCESSOR_RETURN_TYPE SRVFASTCALL
SrvSmbIllegalCommand (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine is called to process SMBs that have an illegal
    (unassigned) command code.  It builds an error response.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE( );

    IF_DEBUG(SMB_ERRORS) {
        SrvPrint1( "SrvSmbIllegalCommand: command code 0x%lx\n",
            (ULONG)WorkContext->NextCommand );
    }

    SrvLogInvalidSmb( WorkContext );

    SrvSetSmbError( WorkContext, STATUS_SMB_BAD_COMMAND );
    return SmbStatusSendResponse;

} // SrvSmbIllegalCommand


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNotImplemented (
    SMB_PROCESSOR_PARAMETERS
    )
{
    PAGED_CODE( );

    INTERNAL_ERROR(
        ERROR_LEVEL_UNEXPECTED,
        "SrvSmbNotImplemented: command code 0x%lx",
        (ULONG)WorkContext->NextCommand,
        NULL
        );

    SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );
    return SmbStatusSendResponse;

} // SrvSmbNotImplemented


SMB_TRANS_STATUS
SrvTransactionNotImplemented (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PTRANSACTION transaction = WorkContext->Parameters.Transaction;

    PAGED_CODE( );

    DEBUG SrvPrint1( "SrvTransactionNotImplemented: function code %lx\n",
                        SmbGetUlong( (PULONG)&transaction->InSetup[0] ) );

    SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );

    return SmbTransStatusErrorWithoutData;

} // SrvTransactionNotImplemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbrdwrt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbrdwrt.c

Abstract:

    This module contains routines for processing the following SMBs:

        Lock and Read
        Read
        Read and X
        Seek
        Write
        Write and Close
        Write and Unlock
        Write and X

    Note that raw mode and multiplexed mode SMB processors are not
    contained in this module.  Check smbraw.c and smbmpx.c instead.
    SMB commands that pertain exclusively to locking (LockByteRange,
    UnlockByteRange, and LockingAndX) are processed in smblock.c.

--*/

#include "precomp.h"
#include "smbrdwrt.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBRDWRT

//
// External routine from smblock.c
//

VOID
TimeoutLockRequest (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Forward declarations
//

STATIC
VOID SRVFASTCALL
RestartLockAndRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartPipeReadAndXPeek (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
BOOLEAN
SetNewPosition (
    IN PRFCB Rfcb,
    IN OUT PULONG Offset,
    IN BOOLEAN RelativeSeek
    );

STATIC
VOID SRVFASTCALL
SetNewSize (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndXCompressed (
    SMB_PROCESSOR_PARAMETERS
    );

VOID SRVFASTCALL
RestartPrepareWriteCompressed (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteCompressed (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteCompressedCopy (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbLockAndRead )
#pragma alloc_text( PAGE, SrvSmbReadAndX )
#pragma alloc_text( PAGE, SrvSmbSeek )
#pragma alloc_text( PAGE, SrvSmbWrite )
#pragma alloc_text( PAGE, SrvSmbWriteAndX )
#pragma alloc_text( PAGE, SrvSmbWriteAndXCompressed )
#pragma alloc_text( PAGE, RestartPrepareWriteCompressed )
#pragma alloc_text( PAGE, RestartWriteCompressedCopy )
#pragma alloc_text( PAGE, SrvRestartChainedClose )
#pragma alloc_text( PAGE, RestartLockAndRead )
#pragma alloc_text( PAGE, RestartPipeReadAndXPeek )
#pragma alloc_text( PAGE, SrvRestartWriteAndUnlock )
#pragma alloc_text( PAGE, SrvRestartWriteAndXRaw )
#pragma alloc_text( PAGE, SetNewSize )
#pragma alloc_text( PAGE, SrvBuildAndSendErrorResponse )
#pragma alloc_text( PAGE8FIL, SetNewPosition )

#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockAndRead (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes Lock And Read SMB.  The Lock part of this SMB is started
    here as an asynchronous request.  When the request completes, the
    routine RestartLockAndRead is called.  If the lock was obtained,
    that routine calls SrvSmbRead, the SMB processor for the core Read
    SMB, to process the Read part of the Lock And Read SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_READ request;

    USHORT fid;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN failImmediately;

    PRFCB rfcb;
    PLFCB lfcb;
    PSRV_TIMER timer;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_AND_READ;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_READ)WorkContext->RequestParameters;

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // addresses is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    fid = SmbGetUshort( &request->Fid );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status )) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbLockAndRead: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // Verify that the client has lock access to the file via the
    // specified handle.
    //

    if ( rfcb->LockAccessGranted ) {

        //
        // Get the offset and length of the range being locked.  Combine the
        // FID with the caller's PID to form the local lock key.
        //
        // *** The FID must be included in the key in order to account for
        //     the folding of multiple remote compatibility mode opens into
        //     a single local open.
        //

        offset.QuadPart = SmbGetUlong( &request->Offset );
        length.QuadPart = SmbGetUshort( &request->Count );

        key = rfcb->ShiftedFid |
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

        IF_SMB_DEBUG(READ_WRITE1) {
            KdPrint(( "Lock and Read request; FID 0x%lx, count %ld, offset %ld\n",
                        fid, length.LowPart, offset.LowPart ));
        }

#ifdef INCLUDE_SMB_PERSISTENT
        WorkContext->Parameters.Lock.Offset.QuadPart = offset.QuadPart;
        WorkContext->Parameters.Lock.Length.QuadPart = length.QuadPart;
        WorkContext->Parameters.Lock.Exclusive = TRUE;
#endif

        lfcb = rfcb->Lfcb;
        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbLockAndRead: Locking in file 0x%p: (%ld,%ld), key 0x%lx\n",
                        lfcb->FileObject, offset.LowPart, length.LowPart, key ));
        }

        //
        // If the session has expired, return that info
        //
        if( lfcb->Session->IsSessionExpired )
        {
            SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
            status =  SESSION_EXPIRED_STATUS_CODE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
        
        //
        // Try the turbo lock path first.  If the client is retrying the
        // lock that just failed, we want FailImmediately to be FALSE, so
        // that the fast path fails if there's a conflict.
        //

        failImmediately = (BOOLEAN)(
            (offset.QuadPart != rfcb->PagedRfcb->LastFailingLockOffset.QuadPart)
            &&
            (offset.QuadPart < SrvLockViolationOffset) );

        if ( lfcb->FastIoLock != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );

            if ( lfcb->FastIoLock(
                    lfcb->FileObject,
                    &offset,
                    &length,
                    IoGetCurrentProcess(),
                    key,
                    failImmediately,
                    TRUE,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // If the turbo path got the lock, start the read.
                // Otherwise, return an error.
                //

#ifdef INCLUDE_SMB_PERSISTENT
                if ( NT_SUCCESS( WorkContext->Irp->IoStatus.Status ) &&
                    ! rfcb->PersistentHandle ) {
#else
                if ( NT_SUCCESS( WorkContext->Irp->IoStatus.Status ) ) {
#endif

                    InterlockedIncrement( &rfcb->NumberOfLocks );
                    SmbStatus = SrvSmbRead( WorkContext );
                    goto Cleanup;
                }
                WorkContext->Parameters.Lock.Timer = NULL;
                RestartLockAndRead( WorkContext );
                return SmbStatusInProgress;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );
        }

        //
        // The turbo path failed (or didn't exist).  Start the lock request,
        // reusing the receive IRP.  If the client is retrying the lock that
        // just failed, start a timer for the request.
        //

        timer = NULL;
        if ( !failImmediately ) {
            timer = SrvAllocateTimer( );
            if ( timer == NULL ) {
                failImmediately = TRUE;
            }
        }

        SrvBuildLockRequest(
            WorkContext->Irp,                   // input IRP address
            lfcb->FileObject,                   // target file object address
            WorkContext,                        // context
            offset,                             // byte offset
            length,                             // range length
            key,                                // lock key
            failImmediately,
            TRUE                                // exclusive lock?
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = RestartLockAndRead;

        //
        // Start the timer, if necessary.
        //

        WorkContext->Parameters.Lock.Timer = timer;

        if ( timer != NULL ) {
            SrvSetTimer(
                timer,
                &SrvLockViolationDelayRelative,
                TimeoutLockRequest,
                WorkContext
                );
        }

        //
        // Pass the request to the file system.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The lock request has been started.  Return the InProgress status
        // to the caller, indicating that the caller should do nothing
        // further with the SMB/WorkContext at the present time.
        //

        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockAndRead complete\n" ));
        SmbStatus = SmbStatusInProgress;

    } else {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbLockAndRead: Lock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbLockAndRead


SMB_PROCESSOR_RETURN_TYPE
SrvSmbRead (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read SMB.  This is the "core" read.  Also processes
    the Read part of the Lock and Read SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCHAR readAddress;
    CLONG readLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Read request; FID 0x%lx, count %ld, offset %ld\n",
            fid, SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // First, verify the FID.  If verified, the RFCB is referenced and
    // its address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the
            // request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbRead: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }


    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if ( !rfcb->ReadAccessGranted ) {

        CHECK_PAGING_IO_ACCESS(
                        WorkContext,
                        rfcb->GrantedAccess,
                        &status );
        if ( !NT_SUCCESS( status ) ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbRead: Read access not granted.\n"));
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // If this operation may block, and we are running short of free
    // work items, fail this SMB with an out of resources error.
    //

    if ( rfcb->BlockingModePipe ) {
        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Fail the operation.
            //

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // It is okay to start a blocking operation.
            // SrvReceiveBufferShortage() has already incremented
            // SrvBlockingOpsInProgress.
            //

            WorkContext->BlockingOperation = TRUE;
        }
    }

    //
    // Form the lock key using the FID and the PID.  (This is also
    // irrelevant for pipes.)
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // See if the direct host IPX smart card can handle this read.  If so,
    //  return immediately, and the card will call our restart routine at
    //  SrvIpxSmartCardReadComplete
    //
    if( rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(( "SrvSmbRead: calling SmartCard Read for context %p\n",
                        WorkContext ));
        }

        //
        // Set the fields needed by SrvIpxSmartCardReadComplete in case the smart
        //  card is going to handle this request
        //
        WorkContext->Parameters.SmartCardRead.MdlReadComplete = lfcb->MdlReadComplete;
        WorkContext->Parameters.SmartCardRead.DeviceObject = lfcb->DeviceObject;

        if( SrvIpxSmartCard.Read( WorkContext->RequestBuffer->Buffer,
                                  rfcb->PagedRfcb->IpxSmartCardContext,
                                  key,
                                  WorkContext ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "  SrvSmbRead:  SmartCard Read returns TRUE\n" ));
            }

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        IF_DEBUG( SIPX ) {
            KdPrint(( "  SrvSmbRead:  SmartCard Read returns FALSE\n" ));
        }
    }

    //
    // Determine the maximum amount of data we can read.  This is the
    // minimum of the amount requested by the client and the amount of
    // room left in the response buffer.  (Note that even though we may
    // use an MDL read, the read length is still limited to the size of
    // an SMB buffer.)
    //

    readAddress = (PCHAR)response->Buffer;

    readLength = MIN(
                    (CLONG)SmbGetUshort( &request->Count ),
                    WorkContext->ResponseBuffer->BufferLength -
                        PTR_DIFF(readAddress, WorkContext->ResponseHeader)
                    );

    //
    // Get the file offset.  (This is irrelevant for pipes.)
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoRead != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        try {
            if ( lfcb->FastIoRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    TRUE,
                    key,
                    readAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
    
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartRead( WorkContext );
                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbRead complete.\n" ));
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

    }

    //
    // The turbo path failed.  Build the read request, reusing the
    // receive IRP.
    //

    if ( rfcb->ShareType != ShareTypePipe ) {

        //
        // Note that we never do MDL reads here.  The reasoning behind
        // this is that because the read is going into an SMB buffer, it
        // can't be all that large (by default, no more than 4K bytes),
        // so the difference in cost between copy and MDL is minimal; in
        // fact, copy read is probably faster than MDL read.
        //
        // Build an MDL describing the read buffer.  Note that if the
        // file system can complete the read immediately, the MDL isn't
        // really needed, but if the file system must send the request
        // to its FSP, the MDL _is_ needed.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            readAddress,
            readLength
            );

        //
        // Build the IRP.
        //

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,           // input IRP address
                lfcb->FileObject,           // target file object address
                WorkContext,                // context
                IRP_MJ_READ,                // major function code
                0,                          // minor function code
                readAddress,                // buffer address
                readLength,                 // buffer length
                WorkContext->ResponseBuffer->PartialMdl, // MDL address
                offset,                     // byte offset
                key                         // lock key
                );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbRead: copy read from file 0x%p, offset %ld, length %ld, destination 0x%p\n",
                        lfcb->FileObject, offset.LowPart, readLength,
                        readAddress ));
        }

    } else {               // if ( rfcb->ShareType != ShareTypePipe )

        //
        // Build the PIPE_INTERNAL_READ IRP.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_READ,
            readAddress,
            0,
            NULL,
            readLength,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbRead: reading from file 0x%p, length %ld, destination 0x%p\n",
                        lfcb->FileObject, readLength, readAddress ));
        }

    }

    //
    // Load the restart routine address and pass the request to the file
    // system.
    //

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartRead;
    DEBUG WorkContext->FspRestartRoutine = NULL;

#if SRVCATCH
    if( rfcb->SrvCatch ) {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartRead;
    }
#endif

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //
    SmbStatus = SmbStatusInProgress;
    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbRead complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbRead


SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read And X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_READ_ANDX request;
    PREQ_NT_READ_ANDX ntRequest;
    PRESP_READ_ANDX response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    CLONG bufferOffset;
    PCHAR readAddress;
    CLONG readLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;
    BOOLEAN largeRead;
    PMDL mdl = NULL;
    UCHAR minorFunction;
    PBYTE readBuffer;
    USHORT flags2;
    BOOLEAN compressedData = FALSE;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_READ_ANDX)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_READ_ANDX)WorkContext->RequestParameters;
    response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "ReadAndX request; FID 0x%lx, count %ld, offset %ld\n",
            fid, SmbGetUshort( &request->MaxCount ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // First, verify the FID.  If verified, the RFCB is referenced and
    // its address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the
            // request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbReadAndX Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if ( !rfcb->ReadAccessGranted ) {

        CHECK_PAGING_IO_ACCESS(
                        WorkContext,
                        rfcb->GrantedAccess,
                        &status );
        if ( !NT_SUCCESS( status ) ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbReadAndX: Read access not granted.\n"));
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    readLength = (CLONG)SmbGetUshort( &request->MaxCount );

    //
    // NT requests allow the specification of up to 32 bits worth of read length.
    //   This field is overlaid with the Timeout field for pipe reads.  Some redirs
    //   set this field to 0xFFFFFFFF, even if a pipe isn't involved.  So, we need to
    //   filter out those fellows.
    //
    if( request->WordCount == 12 &&
        shareType != ShareTypePipe
        && SmbGetUshort( &ntRequest->MaxCountHigh ) != 0xFFFF ) {

        readLength |= ((CLONG)SmbGetUshort( &ntRequest->MaxCountHigh )) << 16;
    }

    //
    // The returned data must be longword aligned.  (Note the assumption
    // that the SMB itself is longword aligned.)
    //
    // NOTE: Don't change this for 64-bit, as it will Break Win2K interop

    bufferOffset = PTR_DIFF(response->Buffer, WorkContext->ResponseHeader);

    WorkContext->Parameters.ReadAndX.PadCount = (USHORT)(3 - (bufferOffset & 3));

    // This was changed to be Pointer-size aligned so this works in 64-bit
    bufferOffset = (bufferOffset + 3) & ~3;

    //
    // If we are not reading from a disk file, or we're connectionless,
    //   or there's an ANDX command,
    //   don't let the client exceed the negotiated buffer size.
    //
    if( shareType != ShareTypeDisk ||
        request->AndXCommand != SMB_COM_NO_ANDX_COMMAND ||
        WorkContext->Endpoint->IsConnectionless ) {

        readLength = MIN( readLength,
                    WorkContext->ResponseBuffer->BufferLength - bufferOffset
                    );
    } else {
        //
        // We're letting large reads through!  Make sure it isn't
        //  too large
        //
        readLength = MIN( readLength, SrvMaxReadSize );
    }

    largeRead = ( readLength > WorkContext->ResponseBuffer->BufferLength - bufferOffset );

    readAddress = (PCHAR)WorkContext->ResponseHeader + bufferOffset;

    WorkContext->Parameters.ReadAndX.ReadAddress = readAddress;
    WorkContext->Parameters.ReadAndX.ReadLength = readLength;

    //
    // Get the file offset.  (This is irrelevant for pipes.)
    //

    if ( shareType != ShareTypePipe ) {

        if ( request->WordCount == 10 ) {

            //
            // The client supplied a 32-bit offset.
            //

            offset.QuadPart = SmbGetUlong( &request->Offset );

        } else if ( request->WordCount == 12 ) {

            //
            // The client supplied a 64-bit offset.
            //

            offset.LowPart = SmbGetUlong( &ntRequest->Offset );
            offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

            //
            // Reject negative offsets
            //

            if ( offset.QuadPart < 0 ) {

                SrvLogInvalidSmb( WorkContext );
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbReadAndX: Negative offset rejected.\n"));
                }
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // Is the client requesting compressed data?
            //
            flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );
            if( flags2 & SMB_FLAGS2_COMPRESSED ) {

                if( SrvSupportsCompression == TRUE &&
                    request->AndXCommand == SMB_COM_NO_ANDX_COMMAND &&
                    (lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

                    SrvStatistics.CompressedReads++;

                    compressedData = TRUE;
                }

                //
                // Turn off the bit in the response until we absolutely know that
                //  we've gotten compressed data to return to the client
                //
                flags2 &= ~SMB_FLAGS2_COMPRESSED;
                SmbPutAlignedUshort( &WorkContext->ResponseHeader->Flags2, flags2 );
            }

        } else {

            //
            // This is an invalid word count for Read and X.
            //

            SrvLogInvalidSmb( WorkContext );
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        WorkContext->Parameters.ReadAndX.ReadOffset = offset;

    } else {

        if ( (request->WordCount != 10) && (request->WordCount != 12) ) {

            //
            // This is an invalid word count for Read and X.
            //

            SrvLogInvalidSmb( WorkContext );
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // Form the lock key using the FID and the PID.  (This is also
    // irrelevant for pipes.)
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // Save the AndX command code.  This is necessary because the read
    // data may overwrite the AndX command.  This command must be Close.
    // We don't need to save the offset because we're not going to look
    // at the AndX command request after starting the read.
    //

    WorkContext->NextCommand = request->AndXCommand;

    if ( request->AndXCommand == SMB_COM_CLOSE ) {

        //
        // Make sure the accompanying CLOSE fits within the received SMB buffer
        //
        if( (PCHAR)WorkContext->RequestHeader + request->AndXOffset + FIELD_OFFSET(REQ_CLOSE,Buffer) >
            END_OF_REQUEST_SMB( WorkContext ) ) {

            SrvLogInvalidSmb( WorkContext );
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        WorkContext->Parameters.ReadAndX.LastWriteTimeInSeconds =
            ((PREQ_CLOSE)((PUCHAR)WorkContext->RequestHeader +
                            request->AndXOffset))->LastWriteTimeInSeconds;
    }

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if( !largeRead && !compressedData ) {
small_read:

        if ( lfcb->FastIoRead != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        readAddress,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Call the restart routine directly
                    // to do postprocessing (including sending the response).
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadAndX( WorkContext );
    
                    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbReadAndX complete.\n" ));
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The turbo path failed.  Build the read request, reusing the
        // receive IRP.
        //

        if ( shareType == ShareTypePipe ) {

            //
            // Pipe read.  If this is a non-blocking read, ensure we won't
            // block; otherwise, proceed with the request.
            //

            if ( rfcb->BlockingModePipe &&
                            (SmbGetUshort( &request->MinCount ) == 0) ) {

                PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;

                //
                // This is a non-blocking read.  Allocate a buffer to peek
                // the pipe, so that we can tell if a read operation will
                // block.  This buffer is freed in
                // RestartPipeReadAndXPeek().
                //

                pipePeekBuffer = ALLOCATE_NONPAGED_POOL(
                    FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                    BlockTypeDataBuffer
                    );

                if ( pipePeekBuffer == NULL ) {

                    //
                    //  Return to client with out of memory status.
                    //

                    SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                    status    = STATUS_INSUFF_SERVER_RESOURCES;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                //
                // Save the address of the peek buffer so that the restart
                // routine can find it.
                //

                WorkContext->Parameters.ReadAndX.PipePeekBuffer = pipePeekBuffer;

                //
                // Build the pipe peek request.  We just want the header
                // information.  We do not need any data.
                //

                WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
                WorkContext->FspRestartRoutine = RestartPipeReadAndXPeek;

                SrvBuildIoControlRequest(
                    WorkContext->Irp,
                    lfcb->FileObject,
                    WorkContext,
                    IRP_MJ_FILE_SYSTEM_CONTROL,
                    FSCTL_PIPE_PEEK,
                    pipePeekBuffer,
                    0,
                    NULL,
                    FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                    NULL,
                    NULL
                    );

                //
                // Pass the request to NPFS.
                //

                (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

            } else {

                //
                // This operation may block.  If we are short of receive
                // work items, reject the request.
                //

                if ( SrvReceiveBufferShortage( ) ) {

                    //
                    // Fail the operation.
                    //

                    SrvStatistics.BlockingSmbsRejected++;

                    SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                    status    = STATUS_INSUFF_SERVER_RESOURCES;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                } else {

                    //
                    // It is okay to start a blocking operation.
                    // SrvReceiveBufferShortage() has already incremented
                    // SrvBlockingOpsInProgress.
                    //

                    WorkContext->BlockingOperation = TRUE;

                    //
                    // Proceed with a potentially blocking read.
                    //

                    WorkContext->Parameters.ReadAndX.PipePeekBuffer = NULL;
                    RestartPipeReadAndXPeek( WorkContext );

                }

            }

        } else {

            //
            // This is not a pipe read.
            //
            // Note that we never do MDL reads here.  The reasoning behind
            // this is that because the read is going into an SMB buffer, it
            // can't be all that large (by default, no more than 4K bytes),
            // so the difference in cost between copy and MDL is minimal; in
            // fact, copy read is probably faster than MDL read.
            //
            // Build an MDL describing the read buffer.  Note that if the
            // file system can complete the read immediately, the MDL isn't
            // really needed, but if the file system must send the request
            // to its FSP, the MDL _is_ needed.
            //
            // *** Note the assumption that the response buffer already has
            //     a valid full MDL from which a partial MDL can be built.
            //

            IoBuildPartialMdl(
                WorkContext->ResponseBuffer->Mdl,
                WorkContext->ResponseBuffer->PartialMdl,
                readAddress,
                readLength
                );

            //
            // Build the IRP.
            //

            SrvBuildReadOrWriteRequest(
                    WorkContext->Irp,           // input IRP address
                    lfcb->FileObject,           // target file object address
                    WorkContext,                // context
                    IRP_MJ_READ,                // major function code
                    0,                          // minor function code
                    readAddress,                // buffer address
                    readLength,                 // buffer length
                    WorkContext->ResponseBuffer->PartialMdl, // MDL address
                    offset,                     // byte offset
                    key                         // lock key
                    );

            IF_SMB_DEBUG(READ_WRITE2) {
                KdPrint(( "SrvSmbReadAndX: copy read from file 0x%p, offset %ld, length %ld, destination 0x%p\n",
                            lfcb->FileObject, offset.LowPart, readLength,
                            readAddress ));
            }

            //
            // Pass the request to the file system.  If the chained command
            // is Close, we need to arrange to restart in the FSP after the
            // read completes.
            //

            if ( WorkContext->NextCommand != SMB_COM_CLOSE ) {
                WorkContext->bAlreadyTrace = TRUE;
                WorkContext->FsdRestartRoutine = SrvFsdRestartReadAndX;
                DEBUG WorkContext->FspRestartRoutine = NULL;
            } else {
                WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
                WorkContext->bAlreadyTrace = FALSE;
                WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
            }

#if SRVCATCH
            if( rfcb->SrvCatch ) {
                //
                // Ensure passive level on restart
                //
                WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
                WorkContext->bAlreadyTrace = FALSE;
                WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
            }
#endif

            (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

            //
            // The read has been started.  Control will return to the restart
            // routine when the read completes.
            //

        }

        IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbReadAndX complete.\n" ));
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    IF_DEBUG( COMPRESSION ) {
        if( compressedData ) {
            KdPrint(("SRV: Compressed ReadAndX: %u requested at %u:%u\n",
                readLength, offset.HighPart, offset.LowPart ));
        }
    }

    //
    // The client is doing a read from a disk file which exceeds our SMB buffer, or
    //  the client is asking for compressed data. We do our best to satisfy it.
    //
    //  If we are unable to get buffers, we resort to doing a short read which fits
    //  in our smb buffer.
    //

    WorkContext->Parameters.ReadAndX.MdlRead = FALSE;

    //
    // Does the target file system support the cache manager routines?
    //
    if( lfcb->FileObject->Flags & FO_CACHE_SUPPORTED ) {

        //
        // We can use an MDL read.  Try the fast I/O path first.
        //

        WorkContext->Irp->MdlAddress = NULL;
        WorkContext->Irp->IoStatus.Information = 0;

        //
        // Check if this is a compressed read request. If so, we'll try
        // an Mdl Read Compressed request to the cache manager.
        //
        //
        // If the requested offset is aligned on a 4KB boundary,
        // the readLength is a multiple of 4KB, the file is
        // compressed, and the file size is at least 4KB -> try for compressed!
        //
        if( compressedData &&
            lfcb->FastIoReadCompressed &&
            (offset.LowPart & 0xfff) == 0 &&
            (readLength & 0xfff) == 0  &&
            (rfcb->Mfcb->NonpagedMfcb->OpenFileAttributes & FILE_ATTRIBUTE_COMPRESSED) &&
            rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart >= 4096 ) {

            ULONG compressedInfoLength;

            WorkContext->Parameters.ReadAndXCompressed.ReadOffset = offset;
            WorkContext->Parameters.ReadAndXCompressed.ReadLength = readLength;

            RtlZeroMemory( &WorkContext->Parameters.ReadAndXCompressed.Aux,
                            sizeof( WorkContext->Parameters.ReadAndXCompressed.Aux ) );

            //
            // Calculate the maximal length for the COMPRESSED_DATA_INFO structure
            //
            compressedInfoLength = (FIELD_OFFSET(COMPRESSED_DATA_INFO, CompressedChunkSizes ) +
              (((readLength + 4096 - 1) / 4096) * sizeof(ULONG) ));

            //
            // Just to be sure!
            //
            compressedInfoLength += sizeof( ULONG );

            //
            // The COMPRESSED_DATA_INFO is pointed to by ReadAndX.Aux.Buffer,
            // which is carved out of the 4KB response buffer.  Place it into
            // the WORK_CONTEXT block at a quad aligned spot.  We'll move it into
            // place later for the response.
            //
            WorkContext->Parameters.ReadAndXCompressed.Aux.Buffer =
                (PVOID)((ULONG_PTR)(WorkContext->ResponseBuffer->Buffer) +
                    WorkContext->ResponseBuffer->BufferLength -
                    compressedInfoLength);

            //
            // Quad align the pointer
            //
            WorkContext->Parameters.ReadAndXCompressed.Aux.Buffer =
                (PVOID)((ULONG_PTR)(WorkContext->Parameters.ReadAndXCompressed.Aux.Buffer) & ~7);

            //
            // Set the length of the buffer
            //
            WorkContext->Parameters.ReadAndXCompressed.Aux.Length = compressedInfoLength;

            //
            // Be a good citizen!
            //
            RtlZeroMemory( WorkContext->Parameters.ReadAndXCompressed.Aux.Buffer,
                            WorkContext->Parameters.ReadAndXCompressed.Aux.Length );

            //
            // Try the fast compressed path first...
            //
            try {
                if ( lfcb->FastIoReadCompressed(
                        lfcb->FileObject,                               // File Object
                        &offset,                                        // File offset
                        readLength,                                     // Length of desired data
                        key,                                            // Lock Key
                        NULL,                                           // Output buffer
                        &WorkContext->Irp->MdlAddress,                  // Output MDL chain
                        &WorkContext->Irp->IoStatus,                    // I/O status block
                        WorkContext->Parameters.ReadAndXCompressed.Aux.Buffer,// CompressedDataInfo
                        WorkContext->Parameters.ReadAndXCompressed.Aux.Length,// Size of above buffer
                        lfcb->DeviceObject                              // Device object
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadAndXCompressed( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            //
            // The fast path failed, and a compressed read entirely
            //  succeeds or entirely fails.  There is no need to adjust
            //  offset or readLength (as we do with noncompressed reads)
            //

            IF_DEBUG( COMPRESSION ) {
                KdPrint(( "    Fast Path failed, submitting IRP\n" ));
            }

            ASSERT( WorkContext->Irp->MdlAddress == NULL );

            WorkContext->Irp->IoStatus.Information = 0;

            SrvBuildReadOrWriteRequest(
                WorkContext->Irp,               // input IRP address
                lfcb->FileObject,               // target file object address
                WorkContext,                    // context
                IRP_MJ_READ,                    // major function code
                IRP_MN_MDL | IRP_MN_COMPRESSED, // minor function code
                NULL,                           // buffer address
                readLength,                     // buffer length
                NULL,                           // MDL address
                offset,                         // byte offset
                key                             // lock key
                );

            WorkContext->Irp->Tail.Overlay.AuxiliaryBuffer =
                (PVOID)&WorkContext->Parameters.ReadAndXCompressed.Aux;
            WorkContext->bAlreadyTrace = TRUE;
            WorkContext->FsdRestartRoutine = SrvFsdRestartReadAndXCompressed;

#if DBG
            WorkContext->bAlreadyTrace = FALSE;
            WorkContext->FspRestartRoutine = SrvFsdRestartReadAndXCompressed;
            WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
#endif

            (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        } else if( compressedData ) {

            SrvStatistics.CompressedReadsRejected++;

            IF_DEBUG( COMPRESSION ) {
                    KdPrint(("SRV: Compressed ReadAndX: UNCOMPRESSED RESPONSE\n" ));
            }
        }

        //
        // Not a compressed read.
        //
        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        if( lfcb->MdlRead(
                lfcb->FileObject,
                &offset,
                readLength,
                key,
                &WorkContext->Irp->MdlAddress,
                &WorkContext->Irp->IoStatus,
                lfcb->DeviceObject
            ) && WorkContext->Irp->MdlAddress != NULL ) {

            //
            // The fast I/O path worked.  Send the data.
            //
            WorkContext->Parameters.ReadAndX.MdlRead = TRUE;
            WorkContext->Parameters.ReadAndX.CacheMdl = WorkContext->Irp->MdlAddress;
            WorkContext->bAlreadyTrace = TRUE;
            SrvFsdRestartLargeReadAndX( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        if( WorkContext->Irp->MdlAddress ) {
            //
            // The fast I/O path failed.  We need to issue a regular MDL read
            // request.
            //
            // The fast path may have partially succeeded, returning a partial MDL
            // chain.  We need to adjust our read request to account for that.
            //
            offset.QuadPart += WorkContext->Irp->IoStatus.Information;
            readLength -= (ULONG)WorkContext->Irp->IoStatus.Information;
            mdl = WorkContext->Irp->MdlAddress;
            WorkContext->Parameters.ReadAndX.CacheMdl = mdl;
            readBuffer = NULL;
            minorFunction = IRP_MN_MDL;
            WorkContext->Parameters.ReadAndX.MdlRead = TRUE;
        }
    }

    if( WorkContext->Parameters.ReadAndX.MdlRead == FALSE ) {

        minorFunction = 0;

        //
        // We have to use a normal "copy" read.  We need to allocate a
        //  separate buffer to hold the data, and we'll use the SMB buffer
        //  itself to hold the MDL
        //
        readBuffer = ALLOCATE_HEAP( readLength, BlockTypeLargeReadX );

        if( readBuffer == NULL ) {

            IF_DEBUG( ERRORS ) {
                KdPrint(( "SrvSmbReadX: Unable to allocate large buffer\n" ));
            }
            //
            // Trim back the read length so it will fit in the smb buffer and
            //  return as much data as we can.
            //
            readLength = MIN( readLength,
                WorkContext->ResponseBuffer->BufferLength - bufferOffset
                );

            largeRead = FALSE;
            goto small_read;
        }

        WorkContext->Parameters.ReadAndX.Buffer = readBuffer;

        //
        // Use the SMB buffer as the MDL to describe the just allocated read buffer.
        //  Lock the buffer into memory
        //
        mdl = (PMDL)(((ULONG_PTR)readAddress + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1));
        MmInitializeMdl( mdl, readBuffer, readLength );

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            IF_DEBUG( ERRORS ) {
                KdPrint(( "SrvSmbReadX: MmProbeAndLockPages status %X\n", GetExceptionCode() ));
            }

            FREE_HEAP( readBuffer );
            WorkContext->Parameters.ReadAndX.Buffer = NULL;

            //
            // Trim back the read length so it will fit in the smb buffer and
            //  return as much data as we can.
            //
            readLength = MIN( readLength,
                WorkContext->ResponseBuffer->BufferLength - bufferOffset
                );

            largeRead = FALSE;
            goto small_read;
        }

        if (MmGetSystemAddressForMdlSafe( mdl,NormalPoolPriority ) == NULL) {
            // The mapping call has failed. fail the read operation with the
            // appropriate error.

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        if( lfcb->FastIoRead != NULL ) {
            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        readBuffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    //
                    // The fast I/O path worked.  Send the data.
                    //
    
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartLargeReadAndX( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );
        }
    }

    //
    // We didn't satisfy the request with the fast I/O path
    //
    SrvBuildReadOrWriteRequest(
           WorkContext->Irp,               // input IRP address
           lfcb->FileObject,               // target file object address
           WorkContext,                    // context
           IRP_MJ_READ,                    // major function code
           minorFunction,                  // minor function code
           readBuffer,                     // buffer address
           readLength,                     // buffer length
           mdl,                            // MDL address
           offset,                         // byte offset
           key                             // lock key
           );

    //
    // Pass the request to the file system.  We want to queue the
    //  response to the head because we've tied up a fair amount
    //  resources with this SMB.
    //
    WorkContext->QueueToHead = 1;
    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartLargeReadAndX;
    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  When it completes, processing
    //  continues at SrvFsdRestartLargeReadAndX
    //
    SmbStatus = SmbStatusInProgress;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbReadAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSeek (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Seek SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SEEK request;
    PRESP_SEEK response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    PLFCB lfcb;
    LONG offset;
    ULONG newPosition;
    IO_STATUS_BLOCK iosb;
    FILE_STANDARD_INFORMATION fileInformation;
    BOOLEAN lockHeld = FALSE;
    SMB_DIALECT smbDialect;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SEEK;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_SEEK)WorkContext->RequestParameters;
    response = (PRESP_SEEK)WorkContext->ResponseParameters;

    offset = (LONG)SmbGetUlong( &request->Offset );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Seek request; FID 0x%lx, mode %ld, offset %ld\n",
                    SmbGetUshort( &request->Fid ),
                    SmbGetUshort( &request->Mode ),
                    offset ));
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbSeek: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // We maintain our own file pointer, because the I/O and file system
    // don't do it for us (at least not the way we need them to).  This
    // isn't all that bad, since the target file position is passed in
    // all read/write SMBs.  So we don't actually issue a system call to
    // set the file position here, although we do have to return the
    // position we would have set it to.
    //
    // The seek request is in one of three modes:
    //
    //      0 = seek relative to beginning of file
    //      1 = seek relative to current file position
    //      2 = seek relative to end of file
    //
    // For modes 0 and 1, we can easily calculate the final position.
    // For mode 2, however, we have to issue a system call to obtain the
    // current end of file and calculate the final position relative to
    // that.  Note that we can't just maintain our own end of file marker,
    // because another local process could change it out from under us.
    //
    // !!! Need to check for wraparound (either positive or negative).
    //

    switch ( SmbGetUshort( &request->Mode ) ) {
    case 0:

        //
        // Seek relative to beginning of file.  The new file position
        // is simply that specified in the request.  Note that this
        // may be beyond the actual end of the file.  This is OK.
        // Negative seeks must be handled specially.
        //

        newPosition = offset;
        if ( !SetNewPosition( rfcb, &newPosition, FALSE ) ) {
            goto negative_seek;
        }

        break;

    case 1:

        //
        // Seek relative to current position.  The new file position is
        // the current position plus the specified offset (which may be
        // negative).  Note that this may be beyond the actual end of
        // the file.  This is OK.  Negative seeks must be handled
        // specially.
        //

        newPosition = offset;
        if ( !SetNewPosition( rfcb, &newPosition, TRUE ) ) {
            goto negative_seek;
        }

        break;

    case 2:

        //
        // Seek relative to end of file.  The new file position
        // is the current end of file plus the specified offset.
        //

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbSeek: Querying end-of-file\n" ));
        }

        lfcb = rfcb->Lfcb;
        fastIoDispatch = lfcb->DeviceObject->DriverObject->FastIoDispatch;

        if ( fastIoDispatch &&
             fastIoDispatch->FastIoQueryStandardInfo &&
             fastIoDispatch->FastIoQueryStandardInfo(
                                        lfcb->FileObject,
                                        TRUE,
                                        &fileInformation,
                                        &iosb,
                                        lfcb->DeviceObject
                                        ) ) {

            status = iosb.Status;

        } else {

            status = NtQueryInformationFile(
                        lfcb->FileHandle,
                        &iosb,
                        &fileInformation,
                        sizeof(fileInformation),
                        FileStandardInformation
                        );
        }

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbSeek: QueryInformationFile (file information) "
                    "returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        if ( fileInformation.EndOfFile.HighPart != 0 ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbSeek: EndOfFile is beyond where client can read",
                NULL,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, STATUS_END_OF_FILE);
            SrvSetSmbError( WorkContext, STATUS_END_OF_FILE);
            status    = STATUS_END_OF_FILE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        newPosition = fileInformation.EndOfFile.LowPart + offset;
        if ( !SetNewPosition( rfcb, &newPosition, FALSE ) ) {
            goto negative_seek;
        }

        break;

    default:

        //
        // Invalid seek mode.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSeek: Invalid mode: 0x%lx\n",
                        SmbGetUshort( &request->Mode ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        status    = STATUS_INVALID_PARAMETER;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    } // switch ( request->Mode )

    //
    // Return the new file position in the response SMB.
    //
    // *** Note the assumption that the high part of the 64-bit EOF
    //     marker is zero.  If it's not (i.e., the file is bigger than
    //     4GB), then we're out of luck, because the SMB protocol can't
    //     express that.
    //

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "SrvSmbSeek: New file position %ld\n", newPosition ));
    }

    response->WordCount = 2;
    SmbPutUlong( &response->Offset, newPosition );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_SEEK, 0 );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSeek complete\n" ));
    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

negative_seek:

    //
    // The client specified an absolute or relative seek that pointed
    // before the beginning of the file.  For some clients, this is not
    // an error, and results in positioning at the BOF.  Non-NT LAN Man
    // clients can request a negative seek on a named-pipe and expect
    // the operation to succeed.
    //

    smbDialect = rfcb->Connection->SmbDialect;

    if( smbDialect >= SmbDialectLanMan20 ||
        ( !IS_NT_DIALECT( smbDialect ) && rfcb->ShareType == ShareTypePipe )) {

            //
            // Negative seeks allowed for these fellows!
            //  Seek to the beginning of the file
            //

            newPosition = 0;
            SetNewPosition( rfcb, &newPosition, FALSE );

            IF_SMB_DEBUG(READ_WRITE2) {
                KdPrint(( "SrvSmbSeek: New file position: 0\n" ));
            }

            response->WordCount = 2;
            SmbPutUlong( &response->Offset, 0 );
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_SEEK, 0 );

    } else {

        //
        // Negative seeks are not allowed!
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSeek: Negative seek\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_OS2_NEGATIVE_SEEK );
        status = STATUS_OS2_NEGATIVE_SEEK;
    }
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSeek complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSeek


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWrite (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write, Write and Close, and Write and Unlock, and
    Write Print File SMBs.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCHAR writeAddress;
    CLONG writeLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Write%s request; FID 0x%lx, count %ld, offset %ld\n",
            WorkContext->NextCommand == SMB_COM_WRITE_AND_UNLOCK ?
                " and Unlock" :
                WorkContext->NextCommand == SMB_COM_WRITE_AND_CLOSE ?
                    " and Close" : "",
            fid, SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // First, verify the FID.  If verified, the RFCB is referenced and
    // its address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //
    // Call SrvVerifyFid, but do not fail (return NULL) if there is
    // a saved write behind error for this rfcb.  We need the rfcb
    // in case this is a write and close SMB, in order to process
    // the close.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartSmbReceived,  // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(("SrvSmbWrite: Invalid FID: 0x%lx\n", fid ));
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            status    = STATUS_INVALID_HANDLE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    } else if ( !NT_SUCCESS( rfcb->SavedError ) ) {

        NTSTATUS savedErrorStatus;

        //
        // Check the saved error.
        //

        savedErrorStatus = SrvCheckForSavedError( WorkContext, rfcb );

        //
        // See if the saved error was still there.
        //

        if ( !NT_SUCCESS( savedErrorStatus ) ) {

            //
            // There was a write behind error.
            //

            //
            // Do not update the file timestamp.
            //

            WorkContext->Parameters.LastWriteTime = 0;

            //
            // If this is not a Write and Close, we can send the
            // response now.  If it is a Write and Close, we need to
            // close the file first.
            //

            if ( WorkContext->NextCommand != SMB_COM_WRITE_AND_CLOSE ) {

                //
                // Not Write and Close.  Just send the response.
                //
                status    = savedErrorStatus;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // This is a Write and Close.
            //

            SrvRestartChainedClose( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }
    }

    lfcb = rfcb->Lfcb;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    
    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWrite: Write access not granted.\n"));
        }
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the write length is zero, truncate the file at the specified
    // offset.
    //

    if ( (SmbGetUshort( &request->Count ) == 0) && (rfcb->GrantedAccess & FILE_WRITE_DATA) ) {
        SetNewSize( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    rfcb->WrittenTo = TRUE;
#ifdef INCLUDE_SMB_IFMODIFIED
    rfcb->Lfcb->FileUpdated = TRUE;
#endif

    //
    // Get the file share type.
    //

    shareType = rfcb->ShareType;

    //
    // If this operation may block, and we are running short of free
    // work items, fail this SMB with an out of resources error.
    //

    if ( rfcb->BlockingModePipe ) {
        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Fail the operation.
            //

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // It is okay to start a blocking operation.
            // SrvReceiveBufferShortage() has already incremented
            // SrvBlockingOpsInProgress.
            //

            WorkContext->BlockingOperation = TRUE;

        }
    }

    //
    // *** If the Remaining field of the request is ever used, make sure
    //     that this is not a write and close SMB, which does not
    //     include a valid Remaining field.
    //

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //
    // !!! Should it be an error for the client to send less data than
    //     it actually wants us to write?  The OS/2 server seems not to
    //     reject such requests.
    //

    if ( WorkContext->NextCommand != SMB_COM_WRITE_PRINT_FILE ) {

        if ( WorkContext->NextCommand != SMB_COM_WRITE_AND_CLOSE ) {

            writeAddress = (PCHAR)request->Buffer;

        } else {

            //
            // Look at the WordCount field -- it should be 6 or 12.
            // From this we can calculate the writeAddress.
            //

            if ( request->WordCount == 6 ) {

                writeAddress =
                    (PCHAR)((PREQ_WRITE_AND_CLOSE)request)->Buffer;

            } else if ( request->WordCount == 12 ) {

                writeAddress =
                    (PCHAR)((PREQ_WRITE_AND_CLOSE_LONG)request)->Buffer;

            } else {

                //
                // An illegal WordCount value was passed.  Return an error
                // to the client.
                //

                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbWrite: Bad WordCount for "
                                "WriteAndClose: %ld, should be 6 or 12\n",
                                request->WordCount ));
                }

                SrvLogInvalidSmb( WorkContext );

                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }
        }

        writeLength = MIN(
                        (CLONG)SmbGetUshort( &request->Count ),
                        WorkContext->ResponseBuffer->DataLength -
                            PTR_DIFF(writeAddress, WorkContext->RequestHeader)
                        );

        offset.QuadPart = SmbGetUlong( &request->Offset );

    } else {

        writeAddress = (PCHAR)( ((PREQ_WRITE_PRINT_FILE)request)->Buffer ) + 3;

        writeLength =
            MIN(
              (CLONG)SmbGetUshort(
                         &((PREQ_WRITE_PRINT_FILE)request)->ByteCount ) - 3,
              WorkContext->ResponseBuffer->DataLength -
                  PTR_DIFF(writeAddress, WorkContext->RequestHeader)
              );

        offset.QuadPart = rfcb->CurrentPosition;
    }

    //
    // Ensure that the client is writing beyond the original file size
    //
    if( !rfcb->WriteAccessGranted &&
        offset.QuadPart < rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

        //
        // The client is only allowed to append to this file!
        //

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        KIRQL oldIrql;

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->WriteCount++;
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        KeQuerySystemTime( &entry->Time );
        entry->Data.ReadWrite.Offset = offset.LowPart;
        entry->Data.ReadWrite.Length = writeLength;
    }
#endif

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartWrite( WorkContext );
    
                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWrite complete.\n" ));
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //

    if (shareType != ShareTypePipe) {

        //
        // Build an MDL describing the write buffer.  Note that if the
        // file system can complete the write immediately, the MDL isn't
        // really needed, but if the file system must send the request
        // to its FSP, the MDL _is_ needed.
        //
        // *** Note the assumption that the request buffer already has a
        //     valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            WorkContext->RequestBuffer->PartialMdl,
            writeAddress,
            writeLength
            );

        //
        // Build the IRP.
        //

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,               // input IRP address
                lfcb->FileObject,               // target file object address
                WorkContext,                    // context
                IRP_MJ_WRITE,                   // major function code
                0,                              // minor function code
                writeAddress,                   // buffer address
                writeLength,                    // buffer length
                WorkContext->RequestBuffer->PartialMdl,   // MDL address
                offset,                         // byte offset
                key                             // lock key
                );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWrite: writing to file 0x%p, offset %ld, length %ld, source 0x%p\n",
                        lfcb->FileObject, offset.LowPart, writeLength,
                        writeAddress ));
        }

    } else {

        //
        // Build the PIPE_INTERNAL_WRITE IRP.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_WRITE,
            writeAddress,
            writeLength,
            NULL,
            0,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWrite: writing to file 0x%p length %ld, destination 0x%p\n",
                        lfcb->FileObject, writeLength,
                        writeAddress ));
        }

    }

    //
    // Pass the request to the file system.  If this is a write and
    // close, we have to restart in the FSP because the restart routine
    // will free the MFCB stored in paged pool.  Similarly, if this is a
    // write and unlock, we have to restart in the FSP to do the unlock.
    //

    if ( (WorkContext->RequestHeader->Command == SMB_COM_WRITE_AND_CLOSE) ||
         (WorkContext->RequestHeader->Command == SMB_COM_WRITE_AND_UNLOCK) ) {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartWrite;
    } else {
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartWrite;
        DEBUG WorkContext->FspRestartRoutine = NULL;
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // SrvFsdRestartWrite when the write completes.
    //
    SmbStatus = SmbStatusInProgress;
    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWrite complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbWrite


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write And X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PSMB_HEADER header;
    PREQ_WRITE_ANDX request;
    PREQ_NT_WRITE_ANDX ntRequest;
    PRESP_WRITE_ANDX response;

    PCONNECTION connection;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    CLONG bufferOffset;
    PCHAR writeAddress;
    CLONG writeLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;
    BOOLEAN writeThrough;

    ULONG remainingBytes;
    ULONG totalLength;

    SMB_DIALECT smbDialect;

    PTRANSACTION transaction;
    PCHAR trailingBytes;
    USHORT flags2;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_AND_X;
    SrvWmiStartContext(WorkContext);

    header = (PSMB_HEADER)WorkContext->RequestHeader;
    request = (PREQ_WRITE_ANDX)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_WRITE_ANDX)WorkContext->RequestParameters;
    response = (PRESP_WRITE_ANDX)WorkContext->ResponseParameters;

    //
    // Initialize the transaction pointer.
    //

    WorkContext->Parameters.Transaction = NULL;

    //
    // If this WriteAndX is actually a psuedo WriteBlockMultiplex, all
    // of the WriteAndX pieces must be assembled before submitting the
    // request to NPFS.  (This exists to support large message mode
    // writes to clients that can't do WriteBlockMultiplex.)
    //
    // This must be handled in the FSP.
    //

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "WriteAndX request; FID 0x%lx, count %ld, offset %ld\n",
            fid, SmbGetUshort( &request->DataLength ),
            SmbGetUlong( &request->Offset ) ));
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbWriteAndX: status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Get the LFCB and the file share type.
    //

    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SrvConsumeSmbData( WorkContext );
        goto Cleanup;
    }
    
    if( WorkContext->LargeIndication && shareType != ShareTypeDisk ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status = STATUS_INVALID_SMB;

        //
        // We need to consume the rest of this SMB!
        //
        SmbStatus = SrvConsumeSmbData( WorkContext );
        goto Cleanup;
    }

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //
    if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteAndX: Write access not granted.\n"));
        }
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SrvConsumeSmbData( WorkContext );
        goto Cleanup;
    }

    rfcb->WrittenTo = TRUE;
#ifdef INCLUDE_SMB_IFMODIFIED
    rfcb->Lfcb->FileUpdated = TRUE;
#endif
    flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );

    //
    // Ensure the correct write through mode, and handle compressed writes
    //

    if ( shareType == ShareTypeDisk ) {

        writeThrough = (BOOLEAN)((SmbGetUshort( &request->WriteMode ) &
                                            SMB_WMODE_WRITE_THROUGH) != 0);

        if ( writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) == 0
            || !writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) != 0 ) {

            SrvSetFileWritethroughMode( lfcb, writeThrough );

        }

        RtlZeroMemory( &WorkContext->Parameters.WriteAndX,
                        sizeof( WorkContext->Parameters.WriteAndX) );

        //
        // If this is a compressed write, handle it separately.
        //
        if( flags2 & SMB_FLAGS2_COMPRESSED ) {
            SmbStatus = SrvSmbWriteAndXCompressed( WorkContext );
            goto Cleanup;
        }

    } else if ( rfcb->BlockingModePipe ) {
        //
        // If this operation may block, and we are running short of free
        // work items, fail this SMB with an out of resources error.
        //

        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Fail the operation.
            //

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;

        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;
        }
    }

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //
    // !!! Should it be an error for the client to send less data than
    //     it actually wants us to write?  The OS/2 server seems not to
    //     reject such requests.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    writeAddress = (PCHAR)WorkContext->ResponseHeader + bufferOffset;

    writeLength = MIN(
                    (CLONG)SmbGetUshort( &request->DataLength ),
                    WorkContext->ResponseBuffer->DataLength - bufferOffset
                    );

    remainingBytes = SmbGetUshort( &request->Remaining );

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );

    //
    // Get the file offset.
    //

    if  ( shareType != ShareTypePipe ) {

        if ( request->WordCount == 12 ) {

            //
            // The client has supplied a 32 bit file offset.
            //

            offset.QuadPart = SmbGetUlong( &request->Offset );

        } else if ( request->WordCount == 14 ) {

            //
            // The client has supplied a 64 bit file offset.  This must be an
            //  uplevel NT-like client
            //

            offset.LowPart = SmbGetUlong( &ntRequest->Offset );
            offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

            //
            // Reject negative offsets
            //
            if ( offset.QuadPart < 0 && offset.QuadPart != 0xFFFFFFFFFFFFFFFF ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbWriteAndX: Negative offset rejected.\n"));
                }

                SrvLogInvalidSmb( WorkContext );
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SrvConsumeSmbData( WorkContext );
                goto Cleanup;
            }

        } else {

            //
            // Invalid word count.
            //

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;
        }

        //
        // If the client can only append, ensure that the client is writing
        //   beyond the original EOF
        //
        if( !rfcb->WriteAccessGranted &&
            offset.QuadPart < rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

            //
            // The client is only allowed to append to this file!
            //

            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            status    = STATUS_ACCESS_DENIED;
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;
        }

        //
        // Gather up parameters for large writes
        //
        if( WorkContext->LargeIndication ) {

            //
            // There can be no follow-on command, and we can not be using security signatures
            //
            if( request->WordCount != 14 ||
                WorkContext->Connection->SmbSecuritySignatureActive == TRUE ||
                request->AndXCommand != SMB_COM_NO_ANDX_COMMAND ) {

                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SrvConsumeSmbData( WorkContext );
                goto Cleanup;
            }

            WorkContext->Parameters.WriteAndX.RemainingWriteLength =
                    (ULONG)SmbGetUshort( &ntRequest->DataLengthHigh ) << 16;
            WorkContext->Parameters.WriteAndX.RemainingWriteLength +=
                    (ULONG)SmbGetUshort( &ntRequest->DataLength );

            WorkContext->Parameters.WriteAndX.CurrentWriteLength = MIN(
                WorkContext->Parameters.WriteAndX.RemainingWriteLength,
                WorkContext->ResponseBuffer->DataLength - bufferOffset );

            writeLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength;

            WorkContext->Parameters.WriteAndX.RemainingWriteLength -= writeLength;

            WorkContext->Parameters.WriteAndX.WriteAddress = writeAddress;
            WorkContext->Parameters.WriteAndX.BufferLength = writeLength;

            WorkContext->Parameters.WriteAndX.Key = key;
            WorkContext->Parameters.WriteAndX.Offset = offset;

            //
            // If the data should have fit within the original SMB buffer, then
            // this is an error
            //
            if( WorkContext->Parameters.WriteAndX.RemainingWriteLength == 0 ) {
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SrvConsumeSmbData( WorkContext );
                goto Cleanup;
            }
        }

    } else {

        if ( (request->WordCount != 12) && (request->WordCount != 14) ) {

            //
            // Invalid word count.
            //

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Is this a multipiece named pipe write?
        //

        connection = WorkContext->Connection;

        if ( (SmbGetUshort( &request->WriteMode ) &
                                SMB_WMODE_WRITE_RAW_NAMED_PIPE) != 0 ) {

            //
            // This is a multipiece named pipe write, is this the first
            // piece?
            //

            if ( (SmbGetUshort( &request->WriteMode ) &
                                SMB_WMODE_START_OF_MESSAGE) != 0 ) {

                //
                // This is the first piece of a multipart WriteAndX SMB.
                // Allocate a buffer large enough to hold all of the data.
                //
                // The first two bytes of the data part of the SMB are the
                // named pipe message header, which we ignore.  Adjust for
                // that.
                //

                //
                // Ensure that enough bytes are available
                //
                if( writeLength < 2 ) {
                    SrvLogInvalidSmb( WorkContext );

                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                    status    = STATUS_INVALID_SMB;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                writeAddress += 2;
                writeLength -= 2;

                // If this is an OS/2 client, add the current write to the
                // remainingBytes count. This is a bug in the OS/2 rdr.
                //

                smbDialect = connection->SmbDialect;

                if ( smbDialect == SmbDialectLanMan21 ||
                     smbDialect == SmbDialectLanMan20 ||
                     smbDialect == SmbDialectLanMan10 ) {

                    //
                    // Ignore the 1st 2 bytes of the message as they are the
                    // OS/2 message header.
                    //

                    totalLength = writeLength + remainingBytes;

                } else {
                    if( writeLength > remainingBytes ) {
                        // This is an invalid SMB, they are trying to overrun the buffer
                       SrvLogInvalidSmb( WorkContext );
                       SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                       return SmbStatusSendResponse;
                    }

                    totalLength =  remainingBytes;
                }

                SrvAllocateTransaction(
                    &transaction,
                    (PVOID *)&trailingBytes,
                    connection,
                    totalLength,
#if DBG
                    StrWriteAndX,                  // Transaction name
#else
                    StrNull,
#endif
                    NULL,
                    TRUE,                          // Source name is Unicode
                    FALSE                          // Not a remote API
                    );

                if ( transaction == NULL ) {

                    //
                    // Could not allocate a large enough buffer.
                    //

                    IF_DEBUG(ERRORS) {
                        KdPrint(( "Unable to allocate transaction\n" ));
                    }

                    SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                    status    = STATUS_INSUFF_SERVER_RESOURCES;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                } else {

                    //
                    // Successfully allocated a transaction block.
                    //
                    // Save the TID, PID, UID, and MID from this request in
                    // the transaction block.  These values are used to
                    // relate secondary requests to the appropriate primary
                    // request.
                    //

                    transaction->Tid = SmbGetAlignedUshort( &header->Tid );
                    transaction->Pid = SmbGetAlignedUshort( &header->Pid );
                    transaction->Uid = SmbGetAlignedUshort( &header->Uid );
                    transaction->OtherInfo = fid;

                    //
                    // Remember the total size of the buffer and the number
                    // of bytes received so far.
                    //

                    transaction->DataCount = writeLength;
                    transaction->TotalDataCount = totalLength;
                    transaction->InData = trailingBytes + writeLength;
                    transaction->OutData = trailingBytes;

                    transaction->Connection = connection;
                    SrvReferenceConnection( connection );

                    transaction->Session = lfcb->Session;
                    SrvReferenceSession( transaction->Session );
                    transaction->TreeConnect = lfcb->TreeConnect;
                    SrvReferenceTreeConnect( transaction->TreeConnect );


                    //
                    // Copy the data out of the SMB buffer.
                    //

                    RtlCopyMemory(
                        trailingBytes,
                        writeAddress,
                        writeLength
                        );

                    //
                    // Increase the write length again, so as not to confuse
                    // the redirector.
                    //

                    writeLength += 2;

                    //
                    // Link the transaction block into the connection's
                    // pending transaction list.  This will fail if there is
                    // already a tranaction with the same xID values in the
                    // list.
                    //

                    if ( !SrvInsertTransaction( transaction ) ) {

                        //
                        // A transaction with the same xIDs is already in
                        // progress.  Return an error to the client.
                        //
                        // *** Note that SrvDereferenceTransaction can't be
                        //     used here because that routine assumes that
                        //     the transaction is queued to the transaction
                        //     list.
                        //

                        SrvDereferenceTreeConnect( transaction->TreeConnect );
                        SrvDereferenceSession( transaction->Session );

                        SrvFreeTransaction( transaction );

                        SrvDereferenceConnection( connection );

                        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                        status    = STATUS_INVALID_SMB;
                        SmbStatus = SmbStatusSendResponse;
                        goto Cleanup;
                    }

                } // else ( transaction sucessfully allocated )

            } else {   // This is a secondary piece to a multi-part message

                transaction = SrvFindTransaction(
                                  connection,
                                  header,
                                  fid
                                  );

                if ( transaction == NULL ) {

                    //
                    // Unable to find a matching transaction.
                    //

                    IF_DEBUG(ERRORS) {
                        KdPrint(( "Cannot find initial write request for "
                            "WriteAndX SMB\n"));
                    }

                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                    status    = STATUS_INVALID_SMB;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                //
                // Make sure there is enough space left in the transaction
                // buffer for the data that we have received.
                //

                if ( transaction->TotalDataCount - transaction->DataCount
                        < writeLength ) {

                    //
                    // Too much data.  Throw out the entire buffer and
                    // reject this write request.
                    //

                    SrvCloseTransaction( transaction );
                    SrvDereferenceTransaction( transaction );

                    SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                    status    = STATUS_BUFFER_OVERFLOW;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(transaction->InData, writeAddress, writeLength );

                //
                // Update the transaction data pointer to where the next
                // WriteAndX data buffer will go.
                //

                transaction->InData += writeLength;
                transaction->DataCount += writeLength;

            } // secondary piece of multipart write

            if ( transaction->DataCount < transaction->TotalDataCount ) {

                //
                // We don't have all of the data yet.
                //

                PRESP_WRITE_ANDX response;
                UCHAR nextCommand;

                //
                // SrvAllocateTransaction or SrvFindTransaction referenced
                // the transaction, so dereference it.
                //

                SrvDereferenceTransaction( transaction );

                //
                // Send an interim response.
                //

                ASSERT( request->AndXCommand == SMB_COM_NO_ANDX_COMMAND );

                response = (PRESP_WRITE_ANDX)WorkContext->ResponseParameters;

                nextCommand = request->AndXCommand;

                //
                // Build the response message.
                //

                response->AndXCommand = nextCommand;
                response->AndXReserved = 0;
                SmbPutUshort(
                    &response->AndXOffset,
                    GET_ANDX_OFFSET(
                        WorkContext->ResponseHeader,
                        WorkContext->ResponseParameters,
                        RESP_WRITE_ANDX,
                        0
                        )
                    );

                response->WordCount = 6;
                SmbPutUshort( &response->Count, (USHORT)writeLength );
                SmbPutUshort( &response->Remaining, (USHORT)-1 );
                SmbPutUlong( &response->Reserved, 0 );
                SmbPutUshort( &response->ByteCount, 0 );

                WorkContext->ResponseParameters =
                    (PCHAR)WorkContext->ResponseHeader +
                            SmbGetUshort( &response->AndXOffset );

                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // We have all of the data.  Set up to write it.
            //

            writeAddress = transaction->OutData;
            writeLength = PTR_DIFF(transaction->InData, transaction->OutData);

            //
            // Save a pointer to the transaction block so that it can be
            // freed when the write completes.
            //
            // *** Note that we retain the reference to the transaction that
            //     was set by SrvAllocateTransaction or added by
            //     SrvFindTransaction.
            //

            WorkContext->Parameters.Transaction = transaction;

            //
            // Fall through to issue the I/O request.
            //

        } // "raw mode" write?
    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        KIRQL oldIrql;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->WriteCount++;
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        KeQuerySystemTime( &entry->Time );
        entry->Data.ReadWrite.Offset = offset.LowPart;
        entry->Data.ReadWrite.Length = writeLength;
    }
#endif

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartWriteAndX( WorkContext );
    
                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWriteAndX complete.\n" ));
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //

    if ( shareType != ShareTypePipe ) {

        //
        // Build an MDL describing the write buffer.  Note that if the
        // file system can complete the write immediately, the MDL isn't
        // really needed, but if the file system must send the request
        // to its FSP, the MDL _is_ needed.
        //
        // *** Note the assumption that the request buffer already has a
        //     valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            WorkContext->RequestBuffer->PartialMdl,
            writeAddress,
            writeLength
            );

        //
        // Build the IRP.
        //

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,               // input IRP address
                lfcb->FileObject,               // target file object address
                WorkContext,                    // context
                IRP_MJ_WRITE,                   // major function code
                0,                              // minor function code
                writeAddress,                   // buffer address
                writeLength,                    // buffer length
                WorkContext->RequestBuffer->PartialMdl,   // MDL address
                offset,                         // byte offset
                key                             // lock key
                );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWriteAndX: writing to file 0x%p, offset %ld, length %ld, source 0x%p\n",
                        lfcb->FileObject, offset.LowPart, writeLength,
                        writeAddress ));
        }

    } else {

        //
        // Build the PIPE_INTERNAL_WRITE IRP.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_WRITE,
            writeAddress,
            writeLength,
            NULL,
            0,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWriteAndX: writing to file 0x%p length %ld, destination 0x%p\n",
                        lfcb->FileObject, writeLength,
                        writeAddress ));
        }

    }

    //
    // Pass the request to the file system.  If the chained command is
    // Close, we need to arrange to restart in the FSP after the write
    // completes.
    //
    // If we have a LargeIndication, we may want to do some cache
    //  operations in the restart routine.  For this, we must be at passive
    //  level.
    //

    if ( WorkContext->LargeIndication == FALSE
         && request->AndXCommand != SMB_COM_CLOSE ) {
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartWriteAndX;
        DEBUG WorkContext->FspRestartRoutine = NULL;

    } else {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // SrvFsdRestartWriteAndX when the write completes.
    //
    SmbStatus = SmbStatusInProgress;
    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWriteAndX complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbWriteAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndXCompressed (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write And X SMB to a disk file, when the request is compressed.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_NT_WRITE_ANDX ntRequest = (PREQ_NT_WRITE_ANDX)WorkContext->RequestParameters;
    PRFCB rfcb = WorkContext->Rfcb;
    PLFCB lfcb = rfcb->Lfcb;
    CLONG bufferOffset;
    ULONG numChunks, i;
    ULONG uncompressedLength;

    PAGED_CODE();

    //
    // We only support this over virtual circuits
    //
    if( WorkContext->Connection->DirectHostIpx ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected on direct host IPX!\n" ));
        }
        goto errout;
    }

    RtlZeroMemory( &WorkContext->Parameters.WriteC, sizeof( WorkContext->Parameters.WriteC ) );

    WorkContext->Parameters.WriteC.Offset.LowPart = SmbGetUlong( &ntRequest->Offset );
    WorkContext->Parameters.WriteC.Offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

    //
    // If all the client can do is to append, ensure that is all the client is doing
    //
    if( !rfcb->WriteAccessGranted &&
        WorkContext->Parameters.WriteC.Offset.QuadPart <
        rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(("Srv: Compressed write rejected, only APPEND access granted!\n" ));
        }

        goto errout;
    }

    //
    // If the server supports compression, this is an NT-style Write&X,
    //  there's no followon command, the client is writing to a 4K boundry,
    //  the target file is compressed, and the target filesystem supports the
    //  cache routines -- then we will give compressed writes a shot.
    //
    if( SrvSupportsCompression == FALSE ||
        lfcb->FastIoWriteCompressed == NULL ||
        ntRequest->WordCount != 14 ||
        ntRequest->AndXCommand != SMB_COM_NO_ANDX_COMMAND ||
        WorkContext->Parameters.WriteC.Offset.QuadPart < 0 ||
        (WorkContext->Parameters.WriteC.Offset.LowPart & 0xfff) ||
        !(rfcb->Mfcb->NonpagedMfcb->OpenFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ||
        !(lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

        //
        // We cannot do a compressed write to this file.  Tell the client
        //   to retry the operation uncompressed.  A polite client probably
        //   won't try compressed writes to this file again.
        //
        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected at %u\n", __LINE__));
        }

        goto errout;
    }

    WorkContext->Parameters.WriteC.CdiLength = SmbGetUshort( &ntRequest->CdiLength );

    //
    // If the client said it wanted to do a compressed write, but it
    // didn't give us a COMPRESSED_DATA_INFO structure, then it goofed.
    //
    if( WorkContext->Parameters.WriteC.CdiLength == 0 ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected: CdiLength == 0!\n" ));
        }
        goto errout;
    }

    bufferOffset = SmbGetUshort( &ntRequest->DataOffset );

    //
    // COMPRESSED_DATA_INFO struct must fit within the buffer we've received
    //
    if( WorkContext->Parameters.WriteC.CdiLength >
        WorkContext->RequestBuffer->DataLength - bufferOffset ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected: Cdi too large\n" ));
        }
        goto errout;
    }

    //
    // The number of elements in the COMPRESSED_DATA_INFO structure
    // must be sensible.  Make sure the COMPRESSED_DATA_INFO is properly
    // aligned.
    //
    if( ((ULONG_PTR)WorkContext->RequestHeader + bufferOffset) & 0x7 ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected: Cdi not properly aligned\n" ));
        }
        goto errout;
    }

    WorkContext->Parameters.WriteC.Cdi =
        (PCOMPRESSED_DATA_INFO)((ULONG_PTR)WorkContext->RequestHeader + bufferOffset);

    //
    // Make sure we know how to decompress this kind of format
    //
    if( RtlGetCompressionWorkSpaceSize(
            WorkContext->Parameters.WriteC.Cdi->CompressionFormatAndEngine,
            &numChunks,
            &numChunks ) != STATUS_SUCCESS ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected: RtlGetCompressionWorkSpaceSize!\n" ));
        }
        goto errout;
    }

    //
    // Calculate the number of chunks that we believe we should get, based
    // on the size of the COMPRESSED_DATA_INFO structure that the client indicated
    //
    numChunks =
        ( WorkContext->Parameters.WriteC.CdiLength -
         FIELD_OFFSET( COMPRESSED_DATA_INFO, CompressedChunkSizes ) )/ sizeof( ULONG );

    //
    // Make sure the number chunks in the COMPRESSED_DATA_INFO structure
    //  agrees with what we calculate.  Maybe if the client tries going uncompressed
    //  it will get it right!
    //
    if( numChunks != WorkContext->Parameters.WriteC.Cdi->NumberOfChunks ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected: numChunks wrong\n" ));
        }
        goto errout;
    }

    //
    // Calculate the amount of compressed data that accompanies this request.
    //
    WorkContext->Parameters.WriteC.CompressedDataLength =
        WorkContext->BytesAvailable -
        bufferOffset -
        WorkContext->Parameters.WriteC.CdiLength;

    if( WorkContext->Parameters.WriteC.CompressedDataLength == 0 ||
        WorkContext->Parameters.WriteC.CompressedDataLength > SrvMaxCompressedDataLength ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: Compressed write rejected: CompressedDataLength %u\n",
                WorkContext->Parameters.WriteC.CompressedDataLength ));
        }
        goto errout;
    }

    //
    // Compute the amount of Compressed data that we got in our initial receive.
    //
    WorkContext->Parameters.WriteC.InitialFragmentSize =
        WorkContext->RequestBuffer->DataLength -
        bufferOffset -
        WorkContext->Parameters.WriteC.CdiLength;

    //
    // If we got all of it in this request, but we have LargeIndication turned on, this
    //   is some sort of error by the client.
    //
    if( WorkContext->Parameters.WriteC.InitialFragmentSize >=
        WorkContext->Parameters.WriteC.CompressedDataLength &&
        WorkContext->LargeIndication ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV:  Compressed write rejected:  LargeIndication, but we got"
                     "all of it!\n" ));
        }
        goto errout;
    }

    uncompressedLength = ((ULONG)SmbGetUshort( &ntRequest->DataLengthHigh ) << 16) |
                         ((ULONG)SmbGetUshort( &ntRequest->DataLength ));

    WorkContext->Parameters.WriteC.UncompressedDataLength = uncompressedLength;

    WorkContext->Parameters.WriteC.Key =  rfcb->ShiftedFid |
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    WorkContext->Parameters.WriteC.DeviceObject =  lfcb->DeviceObject;
    WorkContext->Parameters.WriteC.FileObject = lfcb->FileObject;
    WorkContext->Parameters.WriteC.MdlWriteCompleteCompressed = lfcb->MdlWriteCompleteCompressed;

    //
    // We've gathered up all the state we need into the WriteC block.  Now let's
    //  see if we can do the write!
    //
    WorkContext->Irp->MdlAddress = NULL;
    WorkContext->Irp->IoStatus.Information = 0;
    WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;

    IF_DEBUG( COMPRESSION ) {
        KdPrint(("SRV: Compressed Write: %u compressed, %u uncompressed\n",
            WorkContext->Parameters.WriteC.CompressedDataLength,
            WorkContext->Parameters.WriteC.UncompressedDataLength
        ));
    }

    SrvStatistics.CompressedWrites++;

    try {
        if( lfcb->FastIoWriteCompressed(
                            lfcb->FileObject,
                            &WorkContext->Parameters.WriteC.Offset,
                            WorkContext->Parameters.WriteC.UncompressedDataLength,
                            WorkContext->Parameters.WriteC.Key,
                            NULL,
                            &WorkContext->Irp->MdlAddress,
                            &WorkContext->Irp->IoStatus,
                            (PVOID)WorkContext->Parameters.WriteC.Cdi,
                            WorkContext->Parameters.WriteC.CdiLength,
                            lfcb->DeviceObject ) && WorkContext->Irp->MdlAddress ) {
            WorkContext->bAlreadyTrace = TRUE;
            RestartPrepareWriteCompressed( WorkContext );
            return SmbStatusInProgress;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        // Fall through to the slow path on an exception
        NTSTATUS status = GetExceptionCode();
        IF_DEBUG(ERRORS) {
            KdPrint(("FastIoRead threw exception %x\n", status ));
        }
    }

    //
    // The fast path failed -- try using an IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_WRITE,
            IRP_MN_COMPRESSED | IRP_MN_MDL,
            NULL,
            WorkContext->Parameters.WriteC.UncompressedDataLength,
            NULL,
            WorkContext->Parameters.WriteC.Offset,
            WorkContext->Parameters.WriteC.Key
    );

    WorkContext->Parameters.WriteC.Aux.Buffer = WorkContext->Parameters.WriteC.Cdi;
    WorkContext->Parameters.WriteC.Aux.Length = WorkContext->Parameters.WriteC.CdiLength;
    WorkContext->Irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR)&WorkContext->Parameters.WriteC.Aux;

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->bAlreadyTrace = FALSE;
    WorkContext->FspRestartRoutine = RestartPrepareWriteCompressed;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The MDL write has been started.  When it completes, processing
    // resumes at RestartPrepareWriteCompressed at passive level
    //

    return SmbStatusInProgress;

errout:

    SrvStatistics.CompressedWritesRejected++;

    SrvSetSmbError( WorkContext, STATUS_SMB_USE_STANDARD );
    return SrvConsumeSmbData( WorkContext );
}

VOID SRVFASTCALL
RestartPrepareWriteCompressed(
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This is the restart routine invoked after we have tried to prepare
    an MDL for a compressed write.  It is called at passive level.

--*/
{
    PIRP irp = WorkContext->Irp;
    NTSTATUS status = irp->IoStatus.Status;
    PREQ_NT_WRITE_ANDX ntRequest = (PREQ_NT_WRITE_ANDX)WorkContext->RequestParameters;
    ULONG initialAmount;
    PCHAR bufferAddress;
    ULONG count;
    PMDL mdl = irp->MdlAddress;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    WorkContext->Parameters.WriteC.Mdl = mdl;

    if( mdl == NULL && status != STATUS_SUCCESS ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SRV: RestartPrepareWriteCompressed status %X, MDL %p\n", status, mdl ));
        }

        if( status == STATUS_BUFFER_OVERFLOW ||
            status == STATUS_NOT_SUPPORTED ||
            status == STATUS_USER_MAPPED_FILE ) {

            IF_DEBUG( COMPRESSION ) {
                KdPrint(( "SRV: RestartPrepareWriteCompressed, try uncompressed\n" ));
            }

            //
            // Ntfs will force us down the uncompressed path if no substantial gains
            // can be made in writing out the compressed data. Currently the savings
            // must be at least one chunk size.  Ntfs will also force us down the
            // uncompressed path if this file is mapped.  To avoid having the client
            // send us the data again, we'll decompress it in a side buffer and do
            // a normal write to the file.  Then we'll clear the flags2
            // SMB_FLAGS2_COMPRESSED flag to let the client know that we had to write
            // it uncompressed.  The client should cease sending us compressed data.
            //

            //
            // Let the client know that we were having to try it uncompressed
            //
            SmbPutAlignedUshort(
                &WorkContext->RequestHeader->Flags2,
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 )
                    & ~SMB_FLAGS2_COMPRESSED
            );

            //
            // Maybe we have already received the compressed data!
            //
            if( WorkContext->Parameters.WriteC.InitialFragmentSize ==
                WorkContext->Parameters.WriteC.CompressedDataLength ) {

                ASSERT( WorkContext->LargeIndication == FALSE );

                IF_DEBUG( COMPRESSION ) {
                    KdPrint(( "SRV: RestartPrepareWriteCompressed, already have the data!\n" ));
                }

                //
                // Make it look like the TDI receive was successful
                //
                WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;

                WorkContext->Parameters.WriteC.CompressedBuffer =
                                (PCHAR)WorkContext->RequestHeader +
                                SmbGetUshort( &ntRequest->DataOffset ) +
                                WorkContext->Parameters.WriteC.CdiLength;

                RestartWriteCompressed( WorkContext );

                return;
            }

            //
            // We need a buffer to receive the compressed data
            //
            WorkContext->Parameters.WriteC.CompressedBuffer =
                ALLOCATE_HEAP_COLD( WorkContext->Parameters.WriteC.CompressedDataLength,
                           BlockTypeDataBuffer );

            if( WorkContext->Parameters.WriteC.CompressedBuffer == NULL ) {

                status = STATUS_SMB_USE_STANDARD;

            } else {

                //
                // We need an MDL to describe the compressed data buffer
                //
                count = (ULONG)MmSizeOfMdl( WorkContext->Parameters.WriteC.CompressedBuffer,
                                            WorkContext->Parameters.WriteC.CompressedDataLength );

                mdl = ALLOCATE_NONPAGED_POOL( count, BlockTypeDataBuffer );

                if( mdl == NULL ) {
                    DEALLOCATE_NONPAGED_POOL( WorkContext->Parameters.WriteC.CompressedBuffer );
                    status = STATUS_SMB_USE_STANDARD;

                } else {

                    MmInitializeMdl( mdl,
                                    WorkContext->Parameters.WriteC.CompressedBuffer,
                                    WorkContext->Parameters.WriteC.CompressedDataLength
                                    );

                    try {

                        MmProbeAndLockPages( mdl, KernelMode, IoReadAccess | IoWriteAccess );
                        MmGetSystemAddressForMdl( mdl );
                        WorkContext->Parameters.WriteC.Mdl = mdl;
                        SrvStatistics.CompressedWritesExpanded++;

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        IF_DEBUG( ERRORS ) {
                            KdPrint(( "MmProbeAndLockPages status %X at line %d\n", GetExceptionCode(), __LINE__ ));
                        }
                        DEALLOCATE_NONPAGED_POOL( WorkContext->Parameters.WriteC.CompressedBuffer );
                        DEALLOCATE_NONPAGED_POOL( mdl );
                        WorkContext->Parameters.WriteC.CompressedBuffer = NULL;
                        mdl = NULL;
                        status = STATUS_SMB_USE_STANDARD;
                    }

                }
            }

        } else {
            SrvStatistics.CompressedWritesFailed++;
        }

        if( mdl == NULL ) {

            if( status == STATUS_SMB_USE_STANDARD ) {
                SrvStatistics.CompressedWritesRejected++;
            }

            SrvSetSmbError( WorkContext, status );

            if( SrvConsumeSmbData( WorkContext ) == SmbStatusSendResponse ) {

                WorkContext->ResponseBuffer->DataLength = sizeof( SMB_HEADER );
                WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

                //
                // Send the response!
                //
                SRV_START_SEND_2(
                    WorkContext,
                    SrvFsdRestartSmbAtSendCompletion,
                    NULL,
                    NULL
                    );
            }
            return;
        }
    }

    if( mdl ) {
        //
        //  We now have a place to receive the compressed data.  It's described by 'mdl'
        //
        bufferAddress = (PCHAR)WorkContext->RequestHeader +
                        SmbGetUshort( &ntRequest->DataOffset ) +
                        WorkContext->Parameters.WriteC.CdiLength;

        initialAmount = WorkContext->Parameters.WriteC.InitialFragmentSize;

        //
        // Copy the data that we initially received into the buffer described by 'mdl'
        //
        while( initialAmount > 0 ) {
            PVOID SystemAddress;

            count = MIN( initialAmount, MmGetMdlByteCount( mdl ) );

            SystemAddress = MmGetSystemAddressForMdl( mdl );

            if( !SystemAddress )
            {
                // In low resource situations, we can fail to map the buffer
                SrvSetSmbError( WorkContext, STATUS_INSUFFICIENT_RESOURCES );
                SrvConsumeSmbData( WorkContext );
                return;
            }

            RtlCopyMemory( SystemAddress, bufferAddress, count );

            bufferAddress += count;
            initialAmount -= count;

            if( initialAmount ) {
                ASSERT( mdl->Next != NULL );
                mdl = mdl->Next;
            }
        }

        if( mdl && count == MmGetMdlByteCount( mdl ) ) {
            mdl = mdl->Next;
            count = 0;
        }

    } else if( WorkContext->LargeIndication ) {

        //
        // We are here because the filesystem thought the CDI indicated that no
        //  more data was required.  Yet the client sent us a lot of data.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SrvConsumeSmbData( WorkContext );
        return;
    }

    //
    // If there is no more data to be received from the transport, we are done!
    //
    if( !WorkContext->LargeIndication ) {
        irp->MdlAddress = NULL;
        RestartWriteCompressed( WorkContext );
        return;
    }

    //
    // Time to build the IRP for the TDI receive.  We want to receive the remaining
    //  data into the buffer described by the MDL we've just gotten, but we
    //  need to skip over the InitialFragmentSize.  We therefore need to come up with
    //  another MDL.
    //

    //
    // Since we've already copied the initial data portion to the target buffer, we
    //  can reuse the space in the receive buffer for our MDL, ensuring it is properly
    //  aligned.
    //
    irp->MdlAddress = (PMDL)((PCHAR)WorkContext->RequestHeader +
                             SmbGetUshort( &ntRequest->DataOffset ) +
                             WorkContext->Parameters.WriteC.CdiLength);

    irp->MdlAddress = (PMDL)((((ULONG_PTR)(irp->MdlAddress)) + 7) & ~7);

    ASSERT( WorkContext->Parameters.WriteC.InitialFragmentSize );

    //
    // Build an MDL describing the region into which we want to receive the data.
    //  We want an MDL that describes the compressed buffer, but accounts for the
    //  fact that we've already consumed the InitialFragmentSize bytes.
    //
    //
    // I am sure this is not the prescribed way to do this!!
    //
    MmGetSystemAddressForMdl( mdl );
    RtlCopyMemory( irp->MdlAddress, mdl, mdl->Size );
    (PBYTE)(irp->MdlAddress->MappedSystemVa) += count;
    irp->MdlAddress->ByteCount -= count;
    irp->MdlAddress->ByteOffset += count;
    irp->MdlAddress->Next = mdl->Next;

    //
    // Prepare the TDI receive for the rest of the compressed data
    //
    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;

    irpSp = IoGetNextIrpStackLocation( irp );

    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
    irpSp->FileObject = WorkContext->Connection->FileObject;
    irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
    irpSp->Flags = 0;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = WorkContext->Parameters.WriteC.CompressedDataLength -
                                WorkContext->Parameters.WriteC.InitialFragmentSize;
    parameters->ReceiveFlags = 0;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->Flags = (ULONG)IRP_BUFFERED_IO;
    irp->Cancel = FALSE;

    if( WorkContext->Parameters.WriteC.CompressedBuffer ) {
        //
        // If we are using the side buffer, we need to restart at passive level.
        //
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = RestartWriteCompressed;
    } else {
        //
        // We can resume at dispatch level if we are writing directly to the cache
        // buffers
        //
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = RestartWriteCompressed;
    }

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );
}

VOID SRVFASTCALL
RestartWriteCompressed (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This is the restart routine invoked after the transport has completed the
     receipt of data into buffer we've supplied.

--*/
{
    NTSTATUS status = WorkContext->Irp->IoStatus.Status;

    IF_DEBUG( ERRORS ) {
        if( status != STATUS_SUCCESS ) {
            KdPrint(("RestartWriteCompressed: TDI rcv status %X\n", status ));
        }
    }

    //
    // Are we receiving the data directly into the file, or are we having
    //  to receive it into a side buffer so we can decompress it ourselves?
    //
    if( WorkContext->Parameters.WriteC.CompressedBuffer != NULL ) {

        PLFCB lfcb = WorkContext->Rfcb->Lfcb;
        BOOLEAN compressedBufferAllocated = FALSE;

        //
        // We are having to decompressed the data ourselves.  There are two cases:
        //  1) We received the compressed data in the initial SMB request and did
        //      not have to post a follow-on receive to TDI.  In this case, WriteC.Mdl
        //      is NULL, and WriteC.CompressedBuffer points into our initial SMB.  We
        //      need to ensure that we do not free it!
        //
        //  2) We had to submit a follow-on receive to TDI for all of the compressed
        //      data.  In this case WriteC.CompressedBuffer points to the buffer we
        //      allocated for the receive, and WriteC.Mdl describes this buffer.
        //

        if( WorkContext->Parameters.WriteC.Mdl ) {
            MmUnlockPages( WorkContext->Parameters.WriteC.Mdl );

            DEALLOCATE_NONPAGED_POOL( WorkContext->Parameters.WriteC.Mdl );
            WorkContext->Parameters.WriteC.Mdl = NULL;
            compressedBufferAllocated = TRUE;
        }

        //
        // Did we get all the data from the transport?  Note that if we received all
        //  of the data in the initial SMB buffer, then status has been set to
        //  STATUS_SUCCESS in RestartPrepareWriteCompressed() above.
        //
        if( status != STATUS_SUCCESS ) {

            FREE_HEAP( WorkContext->Parameters.WriteC.CompressedBuffer );

            SrvSetSmbError( WorkContext, status );

            if( status == STATUS_BUFFER_OVERFLOW ) {
                SrvConsumeSmbData( WorkContext );
                return;
            }

            //
            // Use the standard processor to return the WriteAndX response
            //
            WorkContext->LargeIndication = FALSE;
            WorkContext->Irp->IoStatus.Information = 0;
            SrvFsdRestartWriteAndX( WorkContext );
            return;
        }

        //
        // Now, we need to allocate a buffer for the decompression, and then
        //  actually do the decompression
        //
        WorkContext->LargeIndication = FALSE;
        WorkContext->Irp->IoStatus.Information = 0;

        WorkContext->Parameters.WriteC.UncompressedBuffer =
            ALLOCATE_HEAP_COLD( WorkContext->Parameters.WriteC.UncompressedDataLength,
                           BlockTypeDataBuffer );

        if( WorkContext->Parameters.WriteC.UncompressedBuffer == NULL ) {
            if( compressedBufferAllocated ) {
                FREE_HEAP( WorkContext->Parameters.WriteC.CompressedBuffer );
            }

            WorkContext->Irp->IoStatus.Status = STATUS_SMB_USE_STANDARD;
            SrvFsdRestartWriteAndX( WorkContext );
            return;
        }

        status = RtlDecompressChunks(
                                WorkContext->Parameters.WriteC.UncompressedBuffer,
                                WorkContext->Parameters.WriteC.UncompressedDataLength,
                                WorkContext->Parameters.WriteC.CompressedBuffer,
                                WorkContext->Parameters.WriteC.CompressedDataLength,
                                NULL,
                                0,
                                WorkContext->Parameters.WriteC.Cdi
                            );

        IF_DEBUG( ERRORS ) {
            if( !NT_SUCCESS( status ) ) {
                KdPrint(("RtlDecompressChunks( WC %p, Cdi %p, Buffer %p, Length %u ) status %X\n",
                    WorkContext,
                    WorkContext->Parameters.WriteC.Cdi,
                    WorkContext->Parameters.WriteC.CompressedBuffer,
                    WorkContext->Parameters.WriteC.CompressedDataLength,
                    status
                ));
            }
        }

        //
        // We don't need the compressed buffer anymore
        //
        if( compressedBufferAllocated ) {
            FREE_HEAP( WorkContext->Parameters.WriteC.CompressedBuffer );
        }

        WorkContext->Parameters.WriteC.CompressedBuffer = NULL;

        if( status != STATUS_SUCCESS ) {

            IF_DEBUG( COMPRESSION ) {
                KdPrint(( "RtlDecompressChunks returns status %X\n", status ));
            }

            FREE_HEAP( WorkContext->Parameters.WriteC.UncompressedBuffer );
            WorkContext->Irp->IoStatus.Status = status;
            SrvFsdRestartWriteAndX( WorkContext );
            return;
        }

        //
        // Since we are going to submit the data to the filesystem, we need an
        // MDL to describe it.  We can use the original CDI pointer now, since
        // we know that it is aligned, and it's sitting in the SMB buffer, which
        // is nonpaged pool.
        //
        WorkContext->Parameters.WriteC.Mdl = (PMDL)WorkContext->Parameters.WriteC.Cdi;
        WorkContext->Parameters.WriteC.Cdi = NULL;

        MmInitializeMdl( WorkContext->Parameters.WriteC.Mdl,
                        WorkContext->Parameters.WriteC.UncompressedBuffer,
                        WorkContext->Parameters.WriteC.UncompressedDataLength
                        );
        //
        // Filesystem wants the incoming data to be locked down
        //
        try {

            MmProbeAndLockPages(
                WorkContext->Parameters.WriteC.Mdl,
                KernelMode,
                IoReadAccess
            );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            status = GetExceptionCode();

            IF_DEBUG( COMPRESSION ) {
                KdPrint(( "MmProbeAndLockPages returns status %X\n", status ));
            }
            FREE_HEAP( WorkContext->Parameters.WriteC.UncompressedBuffer );
            WorkContext->Parameters.WriteC.UncompressedBuffer = NULL;
            WorkContext->Irp->IoStatus.Status = status;
            SrvFsdRestartWriteAndX( WorkContext );
            return;
        }

        MmGetSystemAddressForMdl( WorkContext->Parameters.WriteC.Mdl );

        //
        // Finally!  We have the uncompressed data in WriteC.UncompressedBuffer,
        //  its length is WriteC.UncompressedDataLength, and it
        //  is described by WriteC.Mdl
        //
        if ( lfcb->FastIoWrite != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

            try {
                if ( lfcb->FastIoWrite(
                        lfcb->FileObject,
                        &WorkContext->Parameters.WriteC.Offset,
                        WorkContext->Parameters.WriteC.UncompressedDataLength,
                        TRUE,
                        WorkContext->Parameters.WriteC.Key,
                        WorkContext->Parameters.WriteC.UncompressedBuffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {
    
                    RestartWriteCompressedCopy( WorkContext );
                    return;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }
        }

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,               // input IRP address
                lfcb->FileObject,               // target file object address
                WorkContext,                    // context
                IRP_MJ_WRITE,                   // major function code
                0,                              // minor function code
                WorkContext->Parameters.WriteC.UncompressedBuffer,
                WorkContext->Parameters.WriteC.UncompressedDataLength,
                WorkContext->Parameters.WriteC.Mdl,
                WorkContext->Parameters.WriteC.Offset,
                WorkContext->Parameters.WriteC.Key
                );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = RestartWriteCompressedCopy;

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );
        return;
    }

    //
    // We are not having to do the decompression ourselves -- we have written
    //  it directly to the filesystem!
    //

    //
    // We may be at raised IRQL at this point.  If we are, we should complete
    //  the compressed MDL write and come back around again at lowered IRQL
    //

    //
    // Complete the compressed write.  Then, if we are at raised IRQL, get out!
    //
    if( WorkContext->Parameters.WriteC.MdlCompleted == FALSE ) {

        if( WorkContext->Parameters.WriteC.MdlWriteCompleteCompressed == NULL ||
            WorkContext->Parameters.WriteC.MdlWriteCompleteCompressed(
                        WorkContext->Parameters.WriteC.FileObject,
                        &WorkContext->Parameters.WriteC.Offset,
                        WorkContext->Parameters.WriteC.Mdl,
                        WorkContext->Parameters.WriteC.DeviceObject ) == FALSE ) {

            NTSTATUS mdlStatus;

            mdlStatus = SrvIssueMdlCompleteRequest( NULL, NULL,
                                                 WorkContext->Parameters.WriteC.Mdl,
                                                 IRP_MJ_WRITE,
                                                 &WorkContext->Parameters.WriteC.Offset,
                                                 WorkContext->Parameters.WriteC.CompressedDataLength
                                                );

            if( !NT_SUCCESS( mdlStatus ) && KeGetCurrentIrql() == PASSIVE_LEVEL ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, mdlStatus );
            }
        }

        WorkContext->Parameters.WriteC.MdlCompleted = TRUE;

        //
        // If we are at raised IRQL, this is as far as we can go.
        //
        if( KeGetCurrentIrql() != PASSIVE_LEVEL ) {
            WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
            WorkContext->bAlreadyTrace = FALSE;
            WorkContext->FspRestartRoutine = RestartWriteCompressed;
            SrvQueueWorkToFspAtDpcLevel( WorkContext );
            return;
        }
    }

    //
    // If we didn't get all of the data from the transport, something really went
    //  wrong.
    //
    if( status == STATUS_BUFFER_OVERFLOW ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SrvConsumeSmbData( WorkContext );
        return;
    }

    //
    // Use the standard processor to return the WriteAndX response
    //
    WorkContext->LargeIndication = FALSE;
    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters.WriteC.UncompressedDataLength;
    SrvFsdRestartWriteAndX( WorkContext );
}

VOID SRVFASTCALL
RestartWriteCompressedCopy (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    If we needed to do an uncompressed write on the client's behalf, we
    decompress the buffer ourselves and write it to the file.  This is the
    restart routine for that uncompressed write attempt.

--*/
{
    PAGED_CODE();

    //
    // Clean up after ourselves
    //
    MmUnlockPages( WorkContext->Parameters.WriteC.Mdl );
    FREE_HEAP( WorkContext->Parameters.WriteC.UncompressedBuffer );
    WorkContext->Parameters.WriteC.UncompressedBuffer = NULL;

    //
    // And send the response to the client
    //
    SrvFsdRestartWriteAndX( WorkContext );
}


VOID SRVFASTCALL
SrvRestartChainedClose (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine invoked after before the response to a
    WriteAndClose, or a ReadAndX or a WriteAndX when the chained command
    is Close.  This routine closes the file, then sends the response.

    This operation cannot be done in the FSD.  Closing a file
    dereferences a number of blocks that are in the FSP address space.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item.  The response parameters must be
        fully set up.

Return Value:

    None.

--*/

{
    PRFCB rfcb = WorkContext->Rfcb;
    PRESP_CLOSE closeResponse = WorkContext->ResponseParameters;

    PAGED_CODE( );

    //
    // Set the file last write time.
    //

    if ( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {

#ifdef INCLUDE_SMB_IFMODIFIED
        (VOID)SrvSetLastWriteTime(
                  rfcb,
                  WorkContext->Parameters.LastWriteTime,
                  rfcb->Lfcb->GrantedAccess,
                  FALSE
                  );
#else
        (VOID)SrvSetLastWriteTime(
                  rfcb,
                  WorkContext->Parameters.LastWriteTime,
                  rfcb->Lfcb->GrantedAccess
                  );
#endif
    }

    //
    // Close the file.
    //

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "SrvRestartChainedClose: closing RFCB 0x%p\n", WorkContext->Rfcb ));
    }

#ifdef SLMDBG
    if ( SrvIsSlmStatus( &rfcb->Mfcb->FileName ) &&
         (rfcb->GrantedAccess & FILE_WRITE_DATA) ) {

        NTSTATUS status;
        ULONG offset;

        status = SrvValidateSlmStatus( rfcb->Lfcb->FileHandle, WorkContext, &offset );

        if ( !NT_SUCCESS(status) ) {
            SrvReportCorruptSlmStatus(
                &rfcb->Mfcb->FileName,
                status,
                offset,
                SLMDBG_CLOSE,
                rfcb->Lfcb->Session
                );
            SrvReportSlmStatusOperations( rfcb, FALSE );
            SrvDisallowSlmAccess(
                &rfcb->Lfcb->FileObject->FileName,
                rfcb->Lfcb->TreeConnect->Share->RootDirectoryHandle
                );
        }

    }
#endif

    SrvCloseRfcb( WorkContext->Rfcb );

    //
    // Dereference the RFCB immediately, rather than waiting for normal
    // work context cleanup after the response send completes.  This
    // gets the xFCB structures cleaned up in a more timely manner.
    //
    // *** The specific motivation for this change was to fix a problem
    //     where a compatibility mode open was closed, the response was
    //     sent, and a Delete SMB was received before the send
    //     completion was processed.  This resulted in the MFCB and LFCB
    //     still being present, which caused the delete processing to
    //     try to use the file handle in the LFCB, which we just closed
    //     here.
    //

    SrvDereferenceRfcb( WorkContext->Rfcb );
    WorkContext->Rfcb = NULL;

    //
    // Build the response parameters.
    //

    closeResponse->WordCount = 0;
    SmbPutUshort( &closeResponse->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( closeResponse, RESP_CLOSE, 0 );

    //
    // Send the response.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    return;

} // SrvRestartChainedClose


VOID SRVFASTCALL
RestartLockAndRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file lock completion for a Lock and Read SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_READ request;

    LARGE_INTEGER offset;
    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS smbStatus = SmbStatusInProgress;
    PSRV_TIMER timer;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    PAGED_CODE( );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_AND_READ;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(WORKER1) KdPrint(( " - RestartLockAndRead\n" ));

    //
    // If this request was being timed, cancel the timer.
    //

    timer = WorkContext->Parameters.Lock.Timer;
    if ( timer != NULL ) {
        SrvCancelTimer( timer );
        SrvFreeTimer( timer );
    }

    //
    // If the lock request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.LockViolations );
        IF_DEBUG(ERRORS) KdPrint(( "Lock failed: %X\n", status ));

        //
        // Store the failing lock offset.
        //

        request = (PREQ_READ)WorkContext->RequestParameters;
        offset.QuadPart = SmbGetUlong( &request->Offset );

        WorkContext->Rfcb->PagedRfcb->LastFailingLockOffset = offset;

        //
        // Send back the bad news.
        //

        if ( status == STATUS_CANCELLED ) {
            status = STATUS_FILE_LOCK_CONFLICT;
        }
        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

        IF_DEBUG(TRACE2) KdPrint(( "RestartLockAndRead complete\n" ));
        goto Cleanup;
    }

    //
    // The lock request completed successfully.
    //

    InterlockedIncrement(
        &WorkContext->Rfcb->NumberOfLocks
        );

#ifdef INCLUDE_SMB_PERSISTENT
    if (WorkContext->Rfcb->PersistentHandle) {

        //
        //  record the lock in the state file before we send back the response.
        //

    }
#endif

    //
    // Start the read to complete the LockAndRead.
    //

    smbStatus = SrvSmbRead( WorkContext );
    if ( smbStatus != SmbStatusInProgress ) {
        SrvEndSmbProcessing( WorkContext, smbStatus );
    }

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartLockAndRead


VOID SRVFASTCALL
RestartPipeReadAndXPeek(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function continues a read and X on a named pipe handle.  It can
    be called as a restart routine if a peek is preformed, but can also
    be called directly from SrvSmbReadAndX if it is not necessary to
    peek the pipe before reading from it.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PLFCB lfcb;
    PIRP irp = WorkContext->Irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE( );

    lfcb = WorkContext->Rfcb->Lfcb;
    if ( WorkContext->Parameters.ReadAndX.PipePeekBuffer != NULL ) {

        //
        // Non-blocking read.  We have issued a pipe peek; free the peek
        // buffer.
        //

        DEALLOCATE_NONPAGED_POOL(
            WorkContext->Parameters.ReadAndX.PipePeekBuffer
            );

        //
        // Now see if there is data to read.
        //

        status = irp->IoStatus.Status;

        if ( NT_SUCCESS(status) ) {

            //
            // There is no data in the pipe.  Fail the read.
            //

            SrvSetSmbError( WorkContext, STATUS_PIPE_EMPTY );
            SrvFsdSendResponse( WorkContext );
            IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "RestartPipeReadAndXPeek complete.\n" ));
            return;

        } else if ( status != STATUS_BUFFER_OVERFLOW ) {

            //
            // An error occurred.  Return the status to the caller.
            //

            SrvSetSmbError( WorkContext, status );
            SrvFsdSendResponse( WorkContext );
            IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "RestartPipeReadAndXPeek complete.\n" ));
            return;
        }

        //
        // There is data in pipe; proceed with read.
        //

    }

    //
    // in line internal read
    //

    deviceObject = lfcb->DeviceObject;

    irp->Tail.Overlay.OriginalFileObject = lfcb->FileObject;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL,
    irpSp->MinorFunction = 0;
    irpSp->FileObject = lfcb->FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.FileSystemControl.OutputBufferLength =
                            WorkContext->Parameters.ReadAndX.ReadLength;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_PIPE_INTERNAL_READ;

    irp->MdlAddress = NULL;
    irp->AssociatedIrp.SystemBuffer =
                WorkContext->Parameters.ReadAndX.ReadAddress,
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    //
    // end in-line
    //

    //
    // Pass the request to the file system.  If the chained command is
    // Close, we need to arrange to restart in the FSP after the read
    // completes.
    //

    if ( WorkContext->NextCommand != SMB_COM_CLOSE ) {
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartReadAndX;
        DEBUG WorkContext->FspRestartRoutine = NULL;
    } else {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
    }

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "RestartPipeReadAndXPeek: reading from file 0x%p, length %ld, destination 0x%p\n",
                     lfcb->FileObject,
                     WorkContext->Parameters.ReadAndX.ReadLength,
                     WorkContext->Parameters.ReadAndX.ReadAddress
                     ));
    }

    (VOID)IoCallDriver( deviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //

    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "RestartPipeReadAndXPeek complete.\n" ));
    return;

} // RestartPipeReadAndXPeek


VOID SRVFASTCALL
SrvRestartWriteAndUnlock (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This restart routine is used when the Write part of a Write and
    Unlock SMB completes successfully.  (Note that the range remains
    locked if the write fails.) This routine handles the Unlock part of
    the request.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS status;
    PRFCB rfcb;
    PLFCB lfcb;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - SrvRestartWriteAndUnlock\n" ));

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    IF_DEBUG(TRACE2) {
        KdPrint(( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb ));
    }

    lfcb = rfcb->Lfcb;

    //
    // Get the offset and length of the range being unlocked.
    // Combine the FID with the caller's PID to form the local
    // lock key.
    //
    // *** The FID must be included in the key in order to
    //     account for the folding of multiple remote
    //     compatibility mode opens into a single local open.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );
    length.QuadPart = SmbGetUshort( &request->Count );

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // Verify that the client has unlock access to the file via
    // the specified handle.
    //

    if ( rfcb->UnlockAccessGranted ) {

        //
        // Issue the Unlock request.
        //
        // *** Note that we do the Unlock synchronously.  Unlock is a
        //     quick operation, so there's no point in doing it
        //     asynchronously.  In order to do this, we have to let
        //     normal I/O completion happen (so the event is set), which
        //     means that we have to allocate a new IRP (I/O completion
        //     likes to deallocate an IRP).  This is a little wasteful,
        //     since we've got a perfectly good IRP hanging around.
        //

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvRestartWriteAndUnlock: Unlocking in file 0x%p: (%ld,%ld), key 0x%lx\n", lfcb->FileObject,
                        offset.LowPart, length.LowPart, key ));
        }

        status = SrvIssueUnlockRequest(
                    lfcb->FileObject,               // target file object
                    &lfcb->DeviceObject,            // target device object
                    IRP_MN_UNLOCK_SINGLE,           // unlock operation
                    offset,                         // byte offset
                    length,                         // range length
                    key                             // lock key
                    );

        //
        // If the unlock request failed, set an error status in
        // the response header.  Otherwise, build a success response.
        //

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvRestartWriteAndUnlock: Unlock failed: %X\n",
                            status ));
            }
            SrvSetSmbError( WorkContext, status );

        } else {

            response->WordCount = 1;
            SmbPutUshort( &response->Count, (USHORT)length.LowPart );
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters =
                                    NEXT_LOCATION( response, RESP_WRITE, 0 );

        }

    } else {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvRestartWriteAndUnlock: Unlock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
    }

    //
    // Processing of the SMB is complete.  Call SrvEndSmbProcessing
    // to send the response.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    IF_DEBUG(TRACE2) KdPrint(( "RestartWrite complete\n" ));
    return;

} // SrvRestartWriteAndUnlock


VOID SRVFASTCALL
SrvRestartWriteAndXRaw (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function completes processing of a WriteAndX raw protocol.
    The work context block already points to the correct response.  All
    that is left to do is free the transaction block, and dispatch the
    And-X command, or send the response.

Arguments:

    WorkContext - A pointer to a set of

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    ASSERT( transaction != NULL );
    ASSERT( GET_BLOCK_TYPE( transaction ) == BlockTypeTransaction );

    SrvCloseTransaction( transaction );
    SrvDereferenceTransaction( transaction );

    //
    // Test for a legal followon command, and dispatch as appropriate.
    // Close and CloseAndTreeDisconnect are handled specially.
    //

    switch ( WorkContext->NextCommand ) {

    case SMB_COM_NO_ANDX_COMMAND:

        //
        // No more commands.  Send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        break;

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_LOCK_AND_READ:

        //
        // Redispatch the SMB for more processing.
        //

        SrvProcessSmb( WorkContext );
        break;

    case SMB_COM_CLOSE:
    //case SMB_COM_CLOSE_AND_TREE_DISC:   // Bogus SMB

        //
        // Call SrvRestartChainedClose to get the file time set and the
        // file closed.
        //

        WorkContext->Parameters.LastWriteTime =
            ((PREQ_CLOSE)WorkContext->RequestParameters)->LastWriteTimeInSeconds;

        SrvRestartChainedClose( WorkContext );

        break;

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvRestartWriteAndXRaw: Illegal followon "
                        "command: 0x%lx\n", WorkContext->NextCommand ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartWriteAndXRaw complete\n" ));
    return;

} // SrvRestartWriteAndXRaw


VOID SRVFASTCALL
SetNewSize (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Write SMB when Count == 0.  Sets the size of the
    target file to the specified Offset.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    ACCESS_MASK grantedAccess;
    PLFCB lfcb;
    FILE_END_OF_FILE_INFORMATION newEndOfFile;
    FILE_ALLOCATION_INFORMATION newAllocation;

    PAGED_CODE( );

    IF_DEBUG(TRACE2) KdPrint(( "SetNewSize entered\n" ));

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    grantedAccess = WorkContext->Rfcb->GrantedAccess;
    lfcb = WorkContext->Rfcb->Lfcb;

    //
    // Verify that the client has the appropriate access to the file via
    // the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        grantedAccess,
        IRP_MJ_SET_INFORMATION,
        FileEndOfFileInformation,
        &status
        );

    if ( NT_SUCCESS(status) ) {
        CHECK_FILE_INFORMATION_ACCESS(
            grantedAccess,
            IRP_MJ_SET_INFORMATION,
            FileAllocationInformation,
            &status
            );
    }

    if ( !NT_SUCCESS(status) ) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SetNewSize: IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, grantedAccess ));
        }

        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;

    }

    //
    // NtSetInformationFile allows a 64-bit file size, but the SMB
    // protocol only allows 32-bit file sizes.  Only set the lower 32
    // bits, leaving the upper bits zero.
    //

    newEndOfFile.EndOfFile.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Set the new EOF.
    //

    status = NtSetInformationFile(
                 lfcb->FileHandle,
                 &ioStatusBlock,
                 &newEndOfFile,
                 sizeof(newEndOfFile),
                 FileEndOfFileInformation
                 );

    if ( NT_SUCCESS(status) ) {

        //
        // Set the new allocation size for the file.
        //
        // !!! This should ONLY be done if this is a down-level client!
        //

        newAllocation.AllocationSize = newEndOfFile.EndOfFile;

        status = NtSetInformationFile(
                     lfcb->FileHandle,
                     &ioStatusBlock,
                     &newAllocation,
                     sizeof(newAllocation),
                     FileAllocationInformation
                     );
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SetNewSize: NtSetInformationFile failed, "
                        "status = %X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;
    }

    //
    // Build and send the response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Count, 0 );
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_WRITE, 0 );

#ifdef INCLUDE_SMB_IFMODIFIED
    WorkContext->Rfcb->Lfcb->FileUpdated = TRUE;
#endif

    IF_DEBUG(TRACE2) KdPrint(( "SetNewSize complete\n" ));
    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    return;

} // SetNewSize


BOOLEAN
SetNewPosition (
    IN PRFCB Rfcb,
    IN OUT PULONG Offset,
    IN BOOLEAN RelativeSeek
    )

/*++

Routine Description:

    Sets the new file pointer.

Arguments:

    Rfcb - A pointer to the rfcb block which contains the position.
    Offset - A pointer to the offset sent by client.  If RelativeSeek is
        TRUE, then this pointer will be updated.
    RelativeSeek - Whether the seek is relative to the current position.

Return Value:

    TRUE, Not nagative seek. Position has been updated.
    FALSE, Negative seek. Position not updated.

--*/

{
    LARGE_INTEGER newPosition;

    UNLOCKABLE_CODE( 8FIL );

    if ( RelativeSeek ) {
        newPosition.QuadPart = Rfcb->CurrentPosition + *Offset;
    } else {
        newPosition.QuadPart = *Offset;
    }

    if ( newPosition.QuadPart < 0 ) {
        return FALSE;
    }

    Rfcb->CurrentPosition = newPosition.LowPart;
    *Offset = newPosition.LowPart;
    return TRUE;

} // SetNewPosition


VOID SRVFASTCALL
SrvBuildAndSendErrorResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PAGED_CODE( );

    SrvSetSmbError( WorkContext, WorkContext->Irp->IoStatus.Status );
    SrvFsdSendResponse( WorkContext );

    return;

} // SrvBuildAndSendErrorResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbsrch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsrch.c

Abstract:

    This module contains routines for processing the Search SMB.

Author:

    David Treadwell (davidtr)    13-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbsrch.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBSRCH

#define VOLUME_BUFFER_SIZE \
        FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel) + \
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbSearch )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSearch (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the various search SMBs, including the core
    Search and the LM 1.0 Find, Find Unique, and Find Close.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SEARCH request;
    PRESP_SEARCH response;

    NTSTATUS status      = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    UNICODE_STRING fileName;
    PSRV_DIRECTORY_INFORMATION directoryInformation = NULL;
    CLONG availableSpace;
    CLONG totalBytesWritten;
    BOOLEAN calledQueryDirectory;
    BOOLEAN findFirst;
    BOOLEAN isUnicode;
    BOOLEAN filterLongNames;
    BOOLEAN isCoreSearch;
    PTABLE_ENTRY entry = NULL;
    SHORT sidIndex;
    SHORT sequence;
    PSMB_RESUME_KEY resumeKey = NULL;
    PCCHAR s;
    PSMB_DIRECTORY_INFORMATION smbDirInfo;
    USHORT smbFileAttributes;
    PSEARCH search = NULL;
    PDIRECTORY_CACHE dirCache, dc;
    USHORT count;
    USHORT maxCount;
    USHORT i;
    USHORT resumeKeyLength;
    UCHAR command;
    CCHAR j;
    CLONG nonPagedBufferSize;
    ULONG resumeFileIndex;
    WCHAR nameBuffer[8 + 1 + 3 + 1];
    OEM_STRING oemString;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    HANDLE RootDirectoryHandle;

    WCHAR unicodeResumeName[ sizeof( dirCache->UnicodeResumeName ) / sizeof( WCHAR ) ];
    USHORT unicodeResumeNameLength = 0;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SEARCH;
    SrvWmiStartContext(WorkContext);

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    //
    // HackHack: Check the flags2 field if dos client.  Some dos clients
    // set flags2 to 0xffff.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    if ( isUnicode && IS_DOS_DIALECT(connection->SmbDialect) ) {
        WorkContext->RequestHeader->Flags2 = 0;
        isUnicode = FALSE;
    }

    filterLongNames =
        ((SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
          SMB_FLAGS2_KNOWS_LONG_NAMES) == 0) ||
        IS_DOS_DIALECT(connection->SmbDialect);

    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint2( "Search request header at 0x%p, response header at 0x%p\n",
                      WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Search request params at 0x%p, response params%p\n",
                      WorkContext->RequestParameters,
                      WorkContext->ResponseParameters );
    }

    request = (PREQ_SEARCH)WorkContext->RequestParameters;
    response = (PRESP_SEARCH)WorkContext->ResponseParameters;
    command = WorkContext->RequestHeader->Command;

    //
    // Set up a pointer in the SMB buffer where we will write
    // information about files.  The +3 is to account for the
    // SMB_FORMAT_VARIABLE and the word that holds the data length.
    //

    smbDirInfo = (PSMB_DIRECTORY_INFORMATION)(response->Buffer + 3);

    fileName.Buffer = NULL;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbSearch: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    isCoreSearch = (BOOLEAN)(command == SMB_COM_SEARCH);

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Get necessary information from the request SMB before we start
    // overwriting it.
    //

    maxCount = SmbGetUshort( &request->MaxCount );

    //
    // If they aren't asking for any files, then they are confused!
    //
    if( maxCount == 0 ) {

        //
        // We would log this, but certain linux clients mistakenly do this
        //  over and over and over...
        //
        status = STATUS_INVALID_SMB;

        goto error_exit;
    }

    //
    // If this is a core search, we don't want to get too many files,
    // as we have to cache information about them between requests.
    //
    //
    // A buffer of nonpaged pool is required by SrvQueryDirectoryFile.
    // We need to use the SMB buffer for found file names and
    // information, so allocate a buffer from nonpaged pool.
    //
    // If we don't need to return many files, we don't need to allocate
    // a large buffer.  The buffer size is the configurable size or
    // enough to hold two more than the number of files we need to
    // return.  We get space to hold two extra files in case some files
    // do not meet the search criteria (eg directories).
    //

    if ( isCoreSearch ) {
        maxCount = MIN( maxCount, (USHORT)MAX_DIRECTORY_CACHE_SIZE );
        nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;

    } else {

        if ( maxCount > MAX_FILES_FOR_MED_SEARCH ) {
            nonPagedBufferSize = MAX_SEARCH_BUFFER_SIZE;
        } else if ( maxCount > MAX_FILES_FOR_MIN_SEARCH ) {
            nonPagedBufferSize = MED_SEARCH_BUFFER_SIZE;
        } else {
            nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;
        }
    }

    //
    // The response to a search is never unicode, though the request may be.
    //
    if( isUnicode ) {
        USHORT flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );
        flags2 &= ~SMB_FLAGS2_UNICODE;
        SmbPutAlignedUshort( &WorkContext->ResponseHeader->Flags2, flags2 );
    }

    //
    // If there was a resume key, verify the SID.  If there was no
    // resume key, allocate a search block.  The first two bytes after
    // the format token are the length of the resume key.  If they are
    // both zero, then the request was a find first.
    //
    count = SmbGetUshort( &request->ByteCount );

    if( isUnicode ) {
        PWCHAR p;

        for( p = (PWCHAR)((PCCHAR)request->Buffer+1), i = 0;
             i < count && SmbGetUshort(p) != UNICODE_NULL;
             p++, i += sizeof(*p) );

            s = (PCCHAR)(p + 1);        // skip past the null to the next char

    } else {

        for ( s = (PCCHAR)request->Buffer, i = 0;
              i < count && *s != (CCHAR)SMB_FORMAT_VARIABLE;
              s++, i += sizeof(*s) );
    }

    //
    // If there was no SMB_FORMAT_VARIABLE token in the buffer, fail.
    //

    if ( i == count || *s != (CCHAR)SMB_FORMAT_VARIABLE ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbSearch: no SMB_FORMAT_VARIABLE token.\n" );
        }

        SrvLogInvalidSmb( WorkContext );

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    resumeKeyLength = SmbGetUshort( (PSMB_USHORT)(s+1) );

    if ( resumeKeyLength == 0 ) {

        //
        // There was no resume key, so either a Find First or a Find
        // Unique was intended.  If it was actually a Find Close, return
        // an error to the client.
        //

        if ( command == SMB_COM_FIND_CLOSE ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbSearch: Find Close sent w/o resume key.\n" );
            }

            status = STATUS_INVALID_SMB;

            SrvLogInvalidSmb( WorkContext );
            goto error_exit;
        }

        IF_SMB_DEBUG(SEARCH2) SrvPrint0( "FIND FIRST\n" );

        findFirst = TRUE;
        calledQueryDirectory = FALSE;

        //
        // Initialize the string containing the path name.  The +1 is to
        // account for the ASCII token in the Buffer field of the
        // request SMB.
        //

        status = SrvCanonicalizePathName(
                WorkContext,
                treeConnect->Share,
                NULL,
                (PVOID)(request->Buffer + 1),
                END_OF_REQUEST_SMB( WorkContext ),
                FALSE,
                isUnicode,
                &fileName
                );

        if( !NT_SUCCESS( status ) ) {
            goto error_exit;
        }

        //
        // If the volume attribute bit is set, just return the volume name.
        //

        if ( SmbGetUshort( &request->SearchAttributes )
                 == SMB_FILE_ATTRIBUTE_VOLUME ) {

            //
            // Use NtQueryVolumeInformationFile to get the volume name.
            //

            IO_STATUS_BLOCK ioStatusBlock;
            PFILE_FS_VOLUME_INFORMATION volumeInformation;

            //
            // Allocate enough space to store the volume information structure
            // and MAXIMUM_FILENAME_LENGTH bytes for the volume label name.
            //

            volumeInformation = ALLOCATE_HEAP( VOLUME_BUFFER_SIZE, BlockTypeVolumeInformation );

            if ( volumeInformation == NULL ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "SrvSmbSearch: Unable to allocate memory from server heap",
                    NULL,
                    NULL
                    );

                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto error_exit;
            }

            RtlZeroMemory( volumeInformation, VOLUME_BUFFER_SIZE );

            //
            // Get the Share root handle.
            //

            status = SrvGetShareRootHandle( treeConnect->Share );

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint1( "SrvSmbSearch: SrvGetShareRootHandle failed %x.\n",
                                status );
                }

                FREE_HEAP( volumeInformation );
                goto error_exit;
            }
                        //
            // Handle SnapShot case
            //
            status = SrvSnapGetRootHandle( WorkContext, &RootDirectoryHandle );
            if( !NT_SUCCESS(status) )
            {
                FREE_HEAP( volumeInformation );
                goto error_exit;
            }

            status = NtQueryVolumeInformationFile(
                         RootDirectoryHandle,
                         &ioStatusBlock,
                         volumeInformation,
                         VOLUME_BUFFER_SIZE,
                         FileFsVolumeInformation
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( treeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &RootDirectoryHandle );
                if( !NT_SUCCESS(status) )
                {
                    FREE_HEAP( volumeInformation );
                    goto error_exit;
                }

                status = NtQueryVolumeInformationFile(
                             RootDirectoryHandle,
                             &ioStatusBlock,
                             volumeInformation,
                             VOLUME_BUFFER_SIZE,
                             FileFsVolumeInformation
                             );
            }

            //
            // Release the share root handle
            //

            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( !NT_SUCCESS(status) ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvSmbSearch: NtQueryVolumeInformationFile returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_VOL_INFO_FILE, status );

                FREE_HEAP( volumeInformation );
                goto error_exit;
            }

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint2( "NtQueryVolumeInformationFile succeeded, name = %ws, "
                          "length %ld\n", volumeInformation->VolumeLabel,
                              volumeInformation->VolumeLabelLength );
            }


            //
            // Check if we have a volume label
            //

            if ( volumeInformation->VolumeLabelLength > 0 ) {

                //
                // Build the response SMB.
                //

                response->WordCount = 1;
                SmbPutUshort( &response->Count, 1 );
                SmbPutUshort(
                    &response->ByteCount,
                    3 + sizeof(SMB_DIRECTORY_INFORMATION)
                    );
                response->Buffer[0] = SMB_FORMAT_VARIABLE;
                SmbPutUshort(
                    (PSMB_USHORT)(response->Buffer+1),
                    sizeof(SMB_DIRECTORY_INFORMATION)
                    );

                //
                // *** Is there anything that we must set in the resume key?
                //

                smbDirInfo->FileAttributes = SMB_FILE_ATTRIBUTE_VOLUME;
                SmbZeroTime( &smbDirInfo->LastWriteTime );
                SmbZeroDate( &smbDirInfo->LastWriteDate );
                SmbPutUlong( &smbDirInfo->FileSize, 0 );

                {
                    UNICODE_STRING unicodeString;
                    OEM_STRING oemString;

                    //
                    // Volume labels may be longer than 11 bytes, but we
                    // truncate then to this length in order to make sure that
                    // the label will fit into the 8.3+NULL -byte space in the
                    // SMB_DIRECTORY_INFORMATION structure.  Also, the LM 1.2
                    // ring 3 and Pinball servers do this.
                    //

                    unicodeString.Length =
                                    (USHORT) MIN(
                                        volumeInformation->VolumeLabelLength,
                                        11 * sizeof(WCHAR) );

                    unicodeString.MaximumLength = 13;
                    unicodeString.Buffer = volumeInformation->VolumeLabel;

                    oemString.MaximumLength = 13;
                    oemString.Buffer = (PCHAR)smbDirInfo->FileName;

                    RtlUnicodeStringToOemString(
                        &oemString,
                        &unicodeString,
                        FALSE
                        );

                    //
                    // If the volume label is greater than 8 characters, it
                    // needs to be turned into 8.3 format.
                    //
                    if( oemString.Length > 8 ) {
                        //
                        // Slide the last three characters one position to the
                        // right and insert a '.' to formulate an 8.3 name
                        //
                        smbDirInfo->FileName[11] = smbDirInfo->FileName[10];
                        smbDirInfo->FileName[10] = smbDirInfo->FileName[9];
                        smbDirInfo->FileName[9] = smbDirInfo->FileName[8];
                        smbDirInfo->FileName[8] = '.';
                        oemString.Length++;
                    }

                    smbDirInfo->FileName[oemString.Length] = '\0';

                    //
                    // Blank pad space after the volume label.
                    //

                    for ( i = (USHORT)(oemString.Length + 1);
                          i < 13;
                          i++ ) {
                        smbDirInfo->FileName[i] = ' ';
                    }

                }

                //
                // Store the resume key in the response packet. DOS redirs
                // actually use this!
                //

                {

                    UNICODE_STRING baseFileName;

                    SrvGetBaseFileName( &fileName, &baseFileName );

                    SrvUnicodeStringTo8dot3(
                        &baseFileName,
                        (PSZ)smbDirInfo->ResumeKey.FileName,
                        FALSE
                        );

                    //
                    // I set Sid = 1 because the next 5 bytes should
                    // be nonzero and we don't really have a sid.
                    //

                    smbDirInfo->ResumeKey.Sid = 0x01;
                    SmbPutUlong( &smbDirInfo->ResumeKey.FileIndex, 0);

                }

            } else {

                //
                // There is no volume label.
                //

                response->WordCount = 1;
                SmbPutUshort( &response->Count, 0 );
                SmbPutUshort( &response->ByteCount, 3 );
                response->Buffer[0] = SMB_FORMAT_VARIABLE;
                SmbPutUshort( (PSMB_USHORT)(response->Buffer+1), 0 );

            }

            WorkContext->ResponseParameters =
                NEXT_LOCATION(
                    response,
                    RESP_SEARCH,
                    SmbGetUshort( &response->ByteCount )
                    );

            FREE_HEAP( volumeInformation );

            if ( !isUnicode &&
                fileName.Buffer != NULL &&
                fileName.Buffer != nameBuffer ) {
                RtlFreeUnicodeString( &fileName );
            }

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // If this is a core search without patterns, short circuit the
        //  whole thing right here.
        //
        if( isCoreSearch && fileName.Length <= sizeof( nameBuffer ) &&
            ( fileName.Length == 0 ||
              !FsRtlDoesNameContainWildCards( &fileName )) ) {

            IO_STATUS_BLOCK ioStatus;
            OBJECT_ATTRIBUTES objectAttributes;
            ULONG attributes;
            ULONG inclusiveSearchAttributes, exclusiveSearchAttributes;
            USHORT searchAttributes;
            UNICODE_STRING baseFileName;
            BOOLEAN returnDirectories, returnDirectoriesOnly;
            FILE_NETWORK_OPEN_INFORMATION fileInformation;
            PSZ dirInfoName;
            SMB_DATE dosDate;
            SMB_TIME dosTime;
            UNICODE_STRING foundFileName;

            UNICODE_STRING ObjectNameString;
            PUNICODE_STRING filePathName;
            BOOLEAN FreePathName = FALSE;

            ObjectNameString.Buffer = fileName.Buffer;
            ObjectNameString.Length = fileName.Length;
            ObjectNameString.MaximumLength = fileName.Length;

            if( fileName.Length == 0 ) {

                //
                // Since we are opening the root of the share, set the attribute to
                // case insensitive, as this is how we opened the share when it was added
                //
                status = SrvSnapGetNameString( WorkContext, &filePathName, &FreePathName );
                if( !NT_SUCCESS(status) )
                {
                    goto error_exit;
                }

                ObjectNameString = *filePathName;
                attributes = OBJ_CASE_INSENSITIVE;

            } else {

                attributes =
                    (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                     WorkContext->Session->UsingUppercasePaths ) ?
                    OBJ_CASE_INSENSITIVE : 0;

            }

            SrvInitializeObjectAttributes_U(
                &objectAttributes,
                &ObjectNameString,
                attributes,
                NULL,
                NULL
                );

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = SrvGetShareRootHandle( treeConnect->Share );

                if( NT_SUCCESS( status ) ) {

                    //
                    // The file name is always relative to the share root
                    //
                    status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                    if( !NT_SUCCESS(status) )
                    {
                        goto SnapError;
                    }

                    //
                    // Get the attributes of the object
                    //
                    if( IoFastQueryNetworkAttributes(
                                            &objectAttributes,
                                            FILE_READ_ATTRIBUTES,
                                            0,
                                            &ioStatus,
                                            &fileInformation
                                            ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatus.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    status = ioStatus.Status;

                    //
                    // If the media was changed and we can come up with a new share root handle,
                    //  then we should retry the operation
                    //
                    if( SrvRetryDueToDismount( treeConnect->Share, status ) ) {

                        status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                        if( !NT_SUCCESS(status) )
                        {
                            goto SnapError;
                        }

                        //
                        // Get the attributes of the object
                        //
                        if( IoFastQueryNetworkAttributes(
                                                &objectAttributes,
                                                FILE_READ_ATTRIBUTES,
                                                0,
                                                &ioStatus,
                                                &fileInformation
                                                ) == FALSE ) {

                            SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                            ioStatus.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                        }
                    }

                    SrvReleaseShareRootHandle( treeConnect->Share );
                }

SnapError:

                REVERT();
            }

            // Free up the string
            if( FreePathName )
            {
                FREE_HEAP( filePathName );
                filePathName = NULL;
            }

            if( !NT_SUCCESS( status ) ) {
                //
                // Do error mapping to keep the DOS clients happy
                //
                if ( status == STATUS_NO_SUCH_FILE ||
                     status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                    status = STATUS_NO_MORE_FILES;
                }
                goto error_exit;
            }

            searchAttributes = SmbGetUshort( &request->SearchAttributes );
            searchAttributes &= SMB_FILE_ATTRIBUTE_READONLY |
                                SMB_FILE_ATTRIBUTE_HIDDEN |
                                SMB_FILE_ATTRIBUTE_SYSTEM |
                                SMB_FILE_ATTRIBUTE_VOLUME |
                                SMB_FILE_ATTRIBUTE_DIRECTORY |
                                SMB_FILE_ATTRIBUTE_ARCHIVE;

            //
            // The file or directory exists, now we need to see if it matches the
            // criteria given by the client
            //
            SRV_SMB_ATTRIBUTES_TO_NT(
                searchAttributes & 0xff,
                &returnDirectories,
                &inclusiveSearchAttributes
            );

            inclusiveSearchAttributes |= FILE_ATTRIBUTE_NORMAL |
                                         FILE_ATTRIBUTE_ARCHIVE |
                                         FILE_ATTRIBUTE_READONLY;

            SRV_SMB_ATTRIBUTES_TO_NT(
                searchAttributes >> 8,
                &returnDirectoriesOnly,
                &exclusiveSearchAttributes
            );

            exclusiveSearchAttributes &= ~FILE_ATTRIBUTE_NORMAL;

            //
            // See if the returned file meets our objectives
            //
            if(
                //
                // If we're only supposed to return directories, then we don't want it
                //
                returnDirectoriesOnly
                ||

                //
                // If there are bits set in FileAttributes that are
                //  not set in inclusiveSearchAttributes, then we don't want it
                //
                ((fileInformation.FileAttributes << 24 ) |
                ( inclusiveSearchAttributes << 24 )) !=
                ( inclusiveSearchAttributes << 24 )

                ||
                //
                // If the file doesn't have attribute bits specified as exclusive
                // bits, we don't want it
                //
                ( ((fileInformation.FileAttributes << 24 ) |
                  (exclusiveSearchAttributes << 24 )) !=
                   (fileInformation.FileAttributes << 24) )

            ) {
                //
                // Just as though the file was never there!
                //
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                goto error_exit;
            }

            //
            // We want this entry!
            // Fill in the response
            //

            //
            // Switch over to a private name buffer, to avoid overwriting info
            //  in the SMB buffer.
            //
            RtlCopyMemory( nameBuffer, fileName.Buffer, fileName.Length );
            foundFileName.Buffer = nameBuffer;
            foundFileName.Length = fileName.Length;
            foundFileName.MaximumLength = fileName.MaximumLength;

            SrvGetBaseFileName( &foundFileName, &baseFileName );
            SrvUnicodeStringTo8dot3(
                &baseFileName,
                (PSZ)smbDirInfo->ResumeKey.FileName,
                TRUE
            );

            //
            // Resume Key doesn't matter, since the client will not come back.  But
            // just in case it does, make sure we have a bum resume key
            //
            SET_RESUME_KEY_INDEX( (PSMB_RESUME_KEY)smbDirInfo, 0xff );
            SET_RESUME_KEY_SEQUENCE(   (PSMB_RESUME_KEY)smbDirInfo, 0xff );
            SmbPutUlong( &((PSMB_RESUME_KEY)smbDirInfo)->FileIndex, 0 );
            SmbPutUlong( (PSMB_ULONG)&((PSMB_RESUME_KEY)smbDirInfo)->Consumer[0], 0 );

            //
            // Fill in the name (even though they knew what it was!)
            //
            oemString.Buffer = smbDirInfo->FileName;
            oemString.MaximumLength = sizeof( smbDirInfo->FileName );
            RtlUpcaseUnicodeStringToOemString( &oemString, &baseFileName, FALSE );

            //
            // Null terminate and blank-pad the name
            //
            oemString.Buffer[ oemString.Length ] = '\0';

            for( i=(USHORT)oemString.Length+1; i < sizeof( smbDirInfo->FileName); i++ ) {
                oemString.Buffer[i] = ' ';
            }

            SRV_NT_ATTRIBUTES_TO_SMB(
                fileInformation.FileAttributes,
                fileInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
                &smbFileAttributes
                );
            smbDirInfo->FileAttributes = (UCHAR)smbFileAttributes;

            SrvTimeToDosTime(
                &fileInformation.LastWriteTime,
                &dosDate,
                &dosTime
                );

            SmbPutDate( &smbDirInfo->LastWriteDate, dosDate );
            SmbPutTime( &smbDirInfo->LastWriteTime, dosTime );

            SmbPutUlong( &smbDirInfo->FileSize, fileInformation.EndOfFile.LowPart );

            totalBytesWritten = sizeof(SMB_DIRECTORY_INFORMATION);
            count = 1;
            goto done_core;
        }

        directoryInformation = ALLOCATE_NONPAGED_POOL(
                                   nonPagedBufferSize,
                                   BlockTypeDirectoryInfo
                                   );

        if ( directoryInformation == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbSearch: unable to allocate nonpaged pool",
                NULL,
                NULL
                );

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        directoryInformation->DirectoryHandle = NULL;

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                          nonPagedBufferSize, directoryInformation );
        }

        //
        // Allocate a search block.  The search block is used to retain
        // state information between search or find SMBs.  The search
        // blocks for core and regular searches are slightly different,
        // hence the BOOLEAN parameter to SrvAllocateSearch.
        //

        //
        // If we've reached our max, start closing searches.
        //

        if ( SrvStatistics.CurrentNumberOfOpenSearches >= SrvMaxOpenSearches ) {

            SrvForceTimeoutSearches( connection );
        }

        SrvAllocateSearch(
            &search,
            &fileName,
            isCoreSearch
            );

        if ( search == NULL ) {

            IF_DEBUG(ERRORS) {
                SrvPrint0( "SrvSmbSearch: unable to allocate search block.\n" );
            }

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        search->Pid = SmbGetAlignedUshort(
                               &WorkContext->RequestHeader->Pid
                               );

        //
        // Set up referenced session and tree connect pointers and
        // increment the count of open files on the session.  This
        // prevents an idle session with an open search from being
        // autodisconnected.
        //

        ACQUIRE_LOCK( &connection->Lock );

        if ( isCoreSearch ) {
            pagedConnection->CurrentNumberOfCoreSearches++;
        }

        search->Session = WorkContext->Session;
        SrvReferenceSession( WorkContext->Session );

        search->TreeConnect = WorkContext->TreeConnect;
        SrvReferenceTreeConnect( WorkContext->TreeConnect );

        //
        // If this is not a find unique, put the search block in the
        // search table.  Otherwise, just set the sidIndex and sequence
        // variables to 0 to distinguish between a valid resumable
        // search block.
        //

        if ( command == SMB_COM_FIND_UNIQUE ) {

            WorkContext->Session->CurrentSearchOpenCount++;
            RELEASE_LOCK( &connection->Lock );

            sequence = sidIndex = -1;

        } else {
            NTSTATUS TableStatus;
            PTABLE_HEADER searchTable = &pagedConnection->SearchTable;

            //
            // If there are no free entries in the table, attempt to
            // grow the table.  If we are unable to grow the table,
            // attempt to timeout a search block using the shorter
            // timeout period.  If this fails, reject the request.
            //

            if ( searchTable->FirstFreeEntry == -1
                 &&
                 SrvGrowTable(
                     searchTable,
                     SrvInitialSearchTableSize,
                     SrvMaxSearchTableSize,
                     &TableStatus ) == FALSE
                 &&
                 SrvTimeoutSearches(
                     NULL,
                     connection,
                     TRUE ) == 0
               ) {

                IF_DEBUG(ERRORS)
                    SrvPrint0( "SrvSmbSearch: Connection searchTable full.\n" );

                RELEASE_LOCK( &connection->Lock );

                if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
                {
                    SrvLogTableFullError( SRV_TABLE_SEARCH );
                    status = STATUS_OS2_NO_MORE_SIDS;
                }
                else
                {
                    status = TableStatus;
                }

                goto error_exit;

            } else if ( GET_BLOCK_STATE( session ) != BlockStateActive ) {

                //
                //
                // If the session is closing do not insert this search
                // on the search list, because the list may already
                // have been cleaned up.
                //

                RELEASE_LOCK( &connection->Lock );

                status = STATUS_SMB_BAD_UID;
                goto error_exit;

            } else if ( GET_BLOCK_STATE( treeConnect ) != BlockStateActive ) {

                //
                // Tree connect is closing.  Don't insert the search block
                // so the tree connect can be cleaned up immediately.
                //

                RELEASE_LOCK( &connection->Lock );

                status = STATUS_SMB_BAD_TID;
                goto error_exit;

            }

            //
            // increment the count of open searches
            //

            WorkContext->Session->CurrentSearchOpenCount++;

            sidIndex = searchTable->FirstFreeEntry;

            //
            // A free SID was found.  Remove it from the free list and set
            // its owner and sequence number.
            //

            entry = &searchTable->Table[sidIndex];

            searchTable->FirstFreeEntry = entry->NextFreeEntry;
            DEBUG entry->NextFreeEntry = -2;
            if ( searchTable->LastFreeEntry == sidIndex ) {
                searchTable->LastFreeEntry = -1;
            }

            INCREMENT_SID_SEQUENCE( entry->SequenceNumber );

            //
            // SID = sequence | sidIndex == 0 is illegal.  If this is
            // the current value, increment the sequence.
            //

            if ( entry->SequenceNumber == 0 && sidIndex == 0 ) {
                INCREMENT_SID_SEQUENCE( entry->SequenceNumber );
            }

            sequence = entry->SequenceNumber;
            entry->Owner = search;

            RELEASE_LOCK( &connection->Lock );
        }

        //
        // Fill in other fields of the search block.
        //

        search->SearchAttributes =
            SmbGetUshort( &request->SearchAttributes );
        search->TableIndex = sidIndex;

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint3( "Allocated search block at 0x%p.  Index = 0x%lx, sequence = 0x%lx\n", search, sidIndex, sequence );
        }

    } else {

        //
        // The resume key length was nonzero, so this should be a find
        // next.  Check the resume key length to be safe.
        //

        USHORT resumeSequence;

        if ( resumeKeyLength != sizeof(SMB_RESUME_KEY) ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint2( "Resume key length was incorrect--was %ld instead "
                          "of %ld\n", resumeKeyLength, sizeof(SMB_RESUME_KEY) );
            }

            SrvLogInvalidSmb( WorkContext );

            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

        findFirst = FALSE;

        resumeKey = (PSMB_RESUME_KEY)(s + 3);

        //
        // Set up the sequence number and index.  These are used for the
        // return resume keys.
        //

        sequence = SID_SEQUENCE( resumeKey );
        sidIndex = SID_INDEX( resumeKey );

        directoryInformation = ALLOCATE_NONPAGED_POOL(
                                   nonPagedBufferSize,
                                   BlockTypeDirectoryInfo
                                   );

        if ( directoryInformation == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbSearch: unable to allocate nonpaged pool",
                NULL,
                NULL
                );

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        directoryInformation->DirectoryHandle = NULL;

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                          nonPagedBufferSize, directoryInformation );
        }
        //
        // Verify the SID in the resume key.  SrvVerifySid also fills in
        // fields of directoryInformation so it is ready to be used by
        // SrvQueryDirectoryFile.
        //

        search = SrvVerifySid(
                     WorkContext,
                     sidIndex,
                     sequence,
                     directoryInformation,
                     nonPagedBufferSize
                     );

        if ( search == NULL ) {

            if (0) IF_DEBUG(SMB_ERRORS) {
                SrvPrint2( "SrvSmbSearch: Invalid resume key (SID): index = "
                          "%lx, seq. = %lx\n",
                          sidIndex, sequence );
            }

            status = STATUS_INVALID_PARAMETER;
            goto error_exit;
        }

        //
        // If this is a core search, take the search block off its last-use
        // list.  We will return it to the end of the list when we are
        // done processing this SMB.
        //

        if ( isCoreSearch ) {

            USHORT dirCacheIndex;

            ACQUIRE_LOCK( &connection->Lock );

            //
            // If the reference count on the search block is not 2,
            // somebody messed up and we could run into problems,
            // because the timeout code assumes that dereferencing a
            // search block will kill it.  The reference count is 2--one
            // for our pointer, one for the active status.
            //

            ASSERT( search->BlockHeader.ReferenceCount == 2 );

            //
            // If the search block has already been taken off the LRU
            // list, then the client has attempted two simultaneous core
            // searches with the same search block.  This is an error on
            // the part of the client.
            //

            if ( search->LastUseListEntry.Flink == NULL ) {

                RELEASE_LOCK( &connection->Lock );
                status = STATUS_INVALID_SMB;

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint0( "SrvSmbSearch: Attempt to do two simultaneuos core searches on same search block.\n" );
                }

                SrvLogInvalidSmb( WorkContext );
                goto error_exit;
            }

            SrvRemoveEntryList(
                &pagedConnection->CoreSearchList,
                &search->LastUseListEntry
                );

            DECREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

            //
            // Set the entry pointer fields to NULL so that if another
            // core search comes in for this search block we will know
            // there is an error.
            //

            search->LastUseListEntry.Flink = NULL;
            search->LastUseListEntry.Blink = NULL;

            //
            // Get the information from the directory cache
            // corresponding to this file and put it into the resume key
            // so that SrvQueryDirectoryFile has the proper information
            // in the resume key.  Core clients do not return the
            // correct file name in the resume key, and have special
            // requirements for the file index in the resume key.
            //

            resumeFileIndex = SmbGetUlong( &resumeKey->FileIndex );
            resumeSequence = (USHORT)((resumeFileIndex & 0xFFFF0000) >> 16);

            dirCacheIndex = (USHORT)(resumeFileIndex & (USHORT)0xFFFF);

            //
            // If the directory cache pointer in the search block
            // indicates that there is no directory cache, then we
            // returned no files last time, so return no files this
            // time.  This is due to DOS weirdness.
            //

            if ( search->DirectoryCache == NULL ||
                 dirCacheIndex >= search->NumberOfCachedFiles ) {

                IF_SMB_DEBUG(SEARCH2) {
                    SrvPrint0( "Core request for rewind when no dircache exists.\n" );
                }

                //
                // Put the search block back on the LRU list if the
                // session and tree connect is still active.
                //

                if ((GET_BLOCK_STATE( session ) == BlockStateActive) &&
                    (GET_BLOCK_STATE( treeConnect ) == BlockStateActive)) {

                    KeQuerySystemTime( &search->LastUseTime );
                    SrvInsertTailList(
                        &pagedConnection->CoreSearchList,
                        &search->LastUseListEntry
                        );
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

                    RELEASE_LOCK( &connection->Lock );

                } else {

                    RELEASE_LOCK( &connection->Lock );

                    //
                    // Not needed any more since session is closing.
                    //

                    SrvCloseSearch( search );
                }

                //
                // Remove our pointer's reference.
                //

                SrvDereferenceSearch( search );

                //
                // Build the response SMB.
                //

                response->WordCount = 1;
                SmbPutUshort( &response->Count, 0 );
                SmbPutUshort( &response->ByteCount, 3 );
                response->Buffer[0] = SMB_FORMAT_VARIABLE;
                SmbPutUshort( (PSMB_USHORT)(response->Buffer+1), 0 );

                WorkContext->ResponseParameters = NEXT_LOCATION(
                                                     response,
                                                     RESP_SEARCH,
                                                     3
                                                     );

                DEALLOCATE_NONPAGED_POOL( directoryInformation );

                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            dirCache = &search->DirectoryCache[dirCacheIndex];

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint3( "Accessing dircache, real file = %ws, index = 0x%lx, "
                          "cache index = %ld\n",
                              dirCache->UnicodeResumeName, dirCache->FileIndex,
                              dirCacheIndex );
            }

            SmbPutUlong( &resumeKey->FileIndex, dirCache->FileIndex );
            unicodeResumeNameLength = dirCache->UnicodeResumeNameLength;

            ASSERT( unicodeResumeNameLength <= sizeof( unicodeResumeName ) );

            RtlCopyMemory( unicodeResumeName,
                           dirCache->UnicodeResumeName,
                           unicodeResumeNameLength );

            //
            // Free the directory cache--it is no longer needed.
            //

            FREE_HEAP( search->DirectoryCache );
            search->DirectoryCache = NULL;
            search->NumberOfCachedFiles = 0;

            RELEASE_LOCK( &connection->Lock );

        } else if ( command == SMB_COM_FIND_CLOSE ) {

            //
            // If this is a find close request, close the search block and
            // dereference it. Close out the directory query, and send the
            // response SMB.
            //

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "FIND CLOSE: Closing search block at 0x%p\n",
                              search );
            }

            SrvCloseQueryDirectory( directoryInformation );
            search->DirectoryHandle = NULL;

            SrvCloseSearch( search );

            //
            // Dereference the search block.  SrvCloseSearch has already
            // dereferenced it once, so it will be deallocated when we
            // dereference it here.
            //

            SrvDereferenceSearch( search );

            DEALLOCATE_NONPAGED_POOL( directoryInformation );

            response->WordCount = 1;
            SmbPutUshort( &response->ByteCount, 3 );
            response->Buffer[0] = SMB_FORMAT_VARIABLE;
            SmbPutUshort( (PSMB_USHORT)(response->Buffer+1), 0 );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  response,
                                                  RESP_SEARCH,
                                                  0
                                                  );

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "FIND NEXT: Resuming search with file %s\n",
                          resumeKey->FileName );
        }

        //
        // Set the filename string so that SrvQueryDirectoryFile knows
        // what search to resume on.
        //


        if( unicodeResumeNameLength != 0 ) {

            fileName.Buffer = unicodeResumeName;
            fileName.Length = fileName.MaximumLength = unicodeResumeNameLength;

        } else {

            fileName.Buffer = nameBuffer;

            Srv8dot3ToUnicodeString(
                (PSZ)resumeKey->FileName,
                &fileName
                );
        }


        //
        // Set calledQueryDirectory to TRUE will indicate to
        // SrvQueryDirectoryFile that it does not need to parse the
        // input name for the directory in which the search occurs, nor
        // does it need to open the directory.
        //

        calledQueryDirectory = TRUE;

        //
        // Get the resume file index in an aligned field for later use.
        //

        resumeFileIndex = SmbGetUlong( &resumeKey->FileIndex );

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "Found search block at 0x%p\n", search );
        }
    }

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Sequence # = %ld, index = %ld\n", sequence, sidIndex );
    }

    //
    // Find the amount of space we have available for writing file
    // entries into.  The total buffer size available (includes space
    // for the SMB header and parameters) is the minimum of our buffer
    // size and the client's buffer size.  The available space is the
    // total buffer space less the amount we will need for the SMB
    // header and parameters.
    //

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint4( "BL = %ld, MBS = %ld, r->B = 0x%p, RB->Buffer = 0x%p\n",
                      WorkContext->ResponseBuffer->BufferLength,
                      session->MaxBufferSize, (PSZ)response->Buffer,
                      (PSZ)WorkContext->ResponseBuffer->Buffer );
    }

    availableSpace =
        MIN(
            WorkContext->ResponseBuffer->BufferLength,
            (CLONG)session->MaxBufferSize
            ) -
        PTR_DIFF(response->Buffer, WorkContext->ResponseBuffer->Buffer );

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint1( "Available buffer space: %ld\n", availableSpace );
    }

    //
    // Simplify the search patterns if possible.  This makes the filesystems more
    //  efficient, as they special case the '*' pattern
    //
    if ( (fileName.Length >= (12 * sizeof(WCHAR))) &&
         (RtlEqualMemory(
            &fileName.Buffer[fileName.Length/sizeof(WCHAR) - 12],
            StrQuestionMarks,
            12 * sizeof(WCHAR)))) {

            if( fileName.Length == (12 * sizeof( WCHAR )) ||
                fileName.Buffer[ fileName.Length/sizeof(WCHAR) - 13 ] == L'\\' ) {

                //
                // The search name ends in ????????.???, replace it with *
                //
                fileName.Buffer[fileName.Length/sizeof(WCHAR)-12] = L'*';
                fileName.Length -= 11 * sizeof(WCHAR);

            }

    } else if ((fileName.Length >= (3 * sizeof(WCHAR))) &&
         (RtlEqualMemory(
            &fileName.Buffer[fileName.Length/sizeof(WCHAR) - 3],
            StrStarDotStar,
            3 * sizeof(WCHAR)))) {

            if( fileName.Length == (3 * sizeof( WCHAR )) ||
                fileName.Buffer[ fileName.Length/sizeof(WCHAR) - 4 ] == L'\\' ) {

                //
                // The search name ends in *.*, replace it with *
                //

                fileName.Length -= 2 * sizeof(WCHAR);

            }
    }

    if( isCoreSearch ) {
        dirCache = (PDIRECTORY_CACHE)ALLOCATE_HEAP(
                                     maxCount * sizeof(DIRECTORY_CACHE),
                                     BlockTypeDirCache
                                     );

        if( dirCache == NULL ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbSearch: Unable to allocate %d bytes from heap",
                maxCount * sizeof(DIRECTORY_CACHE),
                NULL
                );

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        RtlZeroMemory( dirCache, maxCount * sizeof(DIRECTORY_CACHE) );
    }

    //
    // Now we can start getting files.  We do this until one of three
    // conditions is met:
    //
    //   1) There are no more files to return.
    //   2) We have obtained as many files as were requested.
    //   3) The SMB buffer is full.
    //

    count = 0;
    totalBytesWritten = 0;
    dc = dirCache;

    do {

        PSZ dirInfoName;
        UNICODE_STRING name;
        PFILE_BOTH_DIR_INFORMATION bothDirInfo;
        SMB_DATE dosDate;
        SMB_TIME dosTime;
        ULONG effectiveBufferSize;

        //
        // Since the file information returned by NtQueryDirectoryFile is
        // about twice the size of the information we must return in the SMB
        // (SMB_DIRECTORY_INFORMATION), use a buffer size equal to twice the
        // available space if the available space is getting small.  This
        // optimization means that NtQueryDirectoryFile will return unused
        // files less often.  For example, if there is only space left in
        // the SMB buffer for a single file entry, it does not make sense
        // for NtQueryDirectoryFile to completely fill up the buffer--all it
        // really needs to return is a single file.
        //

        effectiveBufferSize = MIN( nonPagedBufferSize, availableSpace * 2 );

        //
        // Make sure that there is at least enough room to hold a single
        // file.
        //

        effectiveBufferSize = MAX( effectiveBufferSize, MIN_SEARCH_BUFFER_SIZE );

        status = SrvQueryDirectoryFile(
                       WorkContext,
                       (BOOLEAN)!calledQueryDirectory,
                       TRUE,                        // filter long names
                       FALSE,                       // not for backup intent
                       FileBothDirectoryInformation,
                       0,
                       &fileName,
                       (PULONG)( (findFirst || count != 0) ?
                                  NULL : &resumeFileIndex ),
                       search->SearchAttributes,
                       directoryInformation,
                       effectiveBufferSize
                       );

        calledQueryDirectory = TRUE;

        if ( status == STATUS_NO_SUCH_FILE ) {
            status = STATUS_NO_MORE_FILES;
        } else if ( status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }

        if ( status == STATUS_NO_MORE_FILES ) {

            if ( findFirst && count == 0 ) {

                //
                // If no files matched on the find first, close out
                // the search.
                //

                IF_SMB_DEBUG(SEARCH1) {
                    SrvPrint1( "SrvSmbSearch: no matching files (%wZ).\n",
                                  &fileName );
                }

                if( isCoreSearch ) {
                    FREE_HEAP( dirCache );
                }
                goto error_exit;
            }

            break;

        } else if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                SrvPrint1(
                    "SrvSmbSearch: SrvQueryDirectoryFile returned %X\n",
                    status
                    );
            }

            if( isCoreSearch ) {
                FREE_HEAP( dirCache );
            }

            goto error_exit;
        }

        //
        // Set the resumeKey pointer to NULL.  If this is a find next, we
        // have already resumed/rewound the search, so calls to
        // NtQueryDirectoryFile during this search should continue where
        // the last search left off.
        //

        resumeKey = NULL;

        //
        // If this is a Find command, then put the 8dot3 (no ".")
        // representation of the file name into the resume key.  If
        // this is a search command, then put the 8dot3 representation of
        // the search specification in the resume key.
        //

        bothDirInfo = (PFILE_BOTH_DIR_INFORMATION)
                                directoryInformation->CurrentEntry;


        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint3( "SrvQueryDirectoryFile--name %ws, length = %ld, "
                      "status = %X\n",
                          bothDirInfo->FileName,
                          bothDirInfo->FileNameLength,
                          status );
            SrvPrint1( "smbDirInfo = 0x%p\n", smbDirInfo );
        }

        //
        // Use the FileName, unless it is not legal 8.3
        //
        name.Buffer = bothDirInfo->FileName;
        name.Length = (SHORT)bothDirInfo->FileNameLength;

        if( bothDirInfo->ShortNameLength != 0 ) {

            if( !SrvIsLegalFatName( bothDirInfo->FileName,
                                    bothDirInfo->FileNameLength ) ) {

                //
                // FileName is not legal 8.3, so switch to the
                //  ShortName
                //
                name.Buffer = bothDirInfo->ShortName;
                name.Length = (SHORT)bothDirInfo->ShortNameLength;
            }
        }

        name.MaximumLength = name.Length;

        if ( isCoreSearch ) {

            UNICODE_STRING baseFileName;

            SrvGetBaseFileName( &search->SearchName, &baseFileName );

            SrvUnicodeStringTo8dot3(
                &baseFileName,
                (PSZ)smbDirInfo->ResumeKey.FileName,
                filterLongNames
                );

            //
            // Save the unicode version of the 8.3 name in the dirCache
            //
            dc->UnicodeResumeNameLength = name.Length;
            RtlCopyMemory( dc->UnicodeResumeName, name.Buffer, name.Length );
            dc->FileIndex = bothDirInfo->FileIndex;

            ++dc;

        } else {

            SrvUnicodeStringTo8dot3(
                &name,
                (PSZ)smbDirInfo->ResumeKey.FileName,
                filterLongNames
                );
        }

        //
        // Generate the resume key for this file.
        //
        // *** This must be done AFTER setting the file name in the resume
        //     key, as setting the resume key name would overwrite some
        //     of the sequence bytes which are stored in the high bits
        //     of the file name bytes.
        //

        SET_RESUME_KEY_INDEX( (PSMB_RESUME_KEY)smbDirInfo, sidIndex );
        SET_RESUME_KEY_SEQUENCE( (PSMB_RESUME_KEY)smbDirInfo, sequence );

        //
        // Put the file index in the resume key.
        //

        SmbPutUlong(
            &((PSMB_RESUME_KEY)smbDirInfo)->FileIndex,
            bothDirInfo->FileIndex
            );

        SmbPutUlong(
            (PSMB_ULONG)&((PSMB_RESUME_KEY)smbDirInfo)->Consumer[0],
            0
            );

        //
        // Load the file name into the SMB_DIRECTORY_INFORMATION structure.
        //

        dirInfoName = (PSZ)smbDirInfo->FileName;

        oemString.Buffer = dirInfoName;
        oemString.MaximumLength = (USHORT)RtlUnicodeStringToOemSize( &name );

        if ( filterLongNames ) {

            //
            // If the client doesn't understand long names, upcase the file
            // name.  This is necessary for compatibility reasons.  Note
            // that the FAT file system returns upcased names anyway.
            //

            RtlUpcaseUnicodeStringToOemString( &oemString, &name, FALSE );

        } else {

            RtlUnicodeStringToOemString( &oemString, &name, FALSE );

        }

        //
        // Blank-pad the end of the filename in order to be compatible with
        // prior redirectors.
        //
        // !!! It is not certain whether this is required.
        //

        for ( i = (USHORT)(oemString.MaximumLength); i < 13; i++ ) {
            dirInfoName[i] = ' ';
        }

        //
        // Fill in other fields in the file entry.
        //

        SRV_NT_ATTRIBUTES_TO_SMB(
            bothDirInfo->FileAttributes,
            bothDirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
            &smbFileAttributes
            );

        smbDirInfo->FileAttributes = (UCHAR)smbFileAttributes;

        SrvTimeToDosTime(
            &bothDirInfo->LastWriteTime,
            &dosDate,
            &dosTime
            );

        SmbPutDate( &smbDirInfo->LastWriteDate, dosDate );
        SmbPutTime( &smbDirInfo->LastWriteTime, dosTime );

        //
        // *** NT file sizes are LARGE_INTEGERs (64 bits), SMB file sizes
        //     are longwords (32 bits).  We just return the low 32 bits
        //     of the NT file size, because that is all we can do.
        //

        SmbPutUlong( &smbDirInfo->FileSize, bothDirInfo->EndOfFile.LowPart );

        //
        // Find the space left in the SMB buffer.
        //

        availableSpace -= sizeof(SMB_DIRECTORY_INFORMATION);

        totalBytesWritten += sizeof(SMB_DIRECTORY_INFORMATION);

        //
        // Set up the smbDirInfo pointer for the next file.  There is
        // no padding for alignment between files, so just increment
        // the pointer.
        //

        smbDirInfo++;

        count++;

    } while ( ( availableSpace > sizeof(SMB_DIRECTORY_INFORMATION) ) &&
              ( count < maxCount ) );

    IF_SMB_DEBUG(SEARCH2) {

        SrvPrint0( "Stopped putting entries in buffer.  Reason:\n" );

        if ( status == STATUS_NO_MORE_FILES ) {
            SrvPrint0( "status = STATUS_NO_MORE_FILES\n" );
        } else if ( count >= maxCount ) {
            SrvPrint2( "count = %ld, maxCount = %ld\n", count, maxCount );
        } else {
            SrvPrint1( "Available space = %ld\n", availableSpace );
        }
    }

    //
    // Store information in the search block.
    //

    search->DirectoryHandle = directoryInformation->DirectoryHandle;
    search->Wildcards = directoryInformation->Wildcards;

    //
    // If this was a core search, store information about the files that
    // were returned in a directory cache.  Also, modify the information
    // in the SMB buffer, as it is slightly different for core searches.
    //

    if ( isCoreSearch ) {

        if ( count == 0 ) {

            FREE_HEAP( dirCache );

            IF_SMB_DEBUG(SEARCH1) {
                SrvPrint3( "SrvSmbSearch: prematurely closing search %p, index %lx sequence %lx\n",
                               search, sidIndex, sequence );
            }

            SrvCloseSearch( search );
            goto done_core;
        }

        //
        // Modify the CoreSequence field of the search block.  This is
        // done because core searches demand that the FileIndex field of
        // the resume key always increase.
        //

        search->CoreSequence++;

        //
        // Set up the pointer to the file information now stored in the
        // SMB buffer and save the location of the directory cache.
        // Store the number of files in the directory cache.
        //

        smbDirInfo = (PSMB_DIRECTORY_INFORMATION)(response->Buffer + 3);
        search->DirectoryCache = dirCache;
        search->NumberOfCachedFiles = count;

        //
        // Loop through the files changing information about the files
        // in the SMB buffer to conform to what the core client expects.
        //

        for ( i = 0; i < count; i++ ) {

            SmbPutUlong(
                &smbDirInfo->ResumeKey.FileIndex,
                (search->CoreSequence << 16) + i
                );

            smbDirInfo++;
            dirCache++;
        }

        //
        // If this was a core search, put the search block back on the
        // appropriate search block list.  If no files were found for this
        // SMB, put the search block on the complete list.  Also, set the
        // last use time field of the search block.
        //
        // If this is a find first to which we responded with
        // one file AND either more than one file was requested or this
        // is a unique search (no wildcards) AND there was space in the
        // buffer for more, close out the search.  This saves the memory
        // associated with an open handle and frees up the search table
        // entry.  Also close the search if zero files are being returned.
        //
        // We can do this safely because we know that the client would
        // not be able to do a rewind or resume with these conditions
        // and get back anything other than NO_MORE_FILES, which is what
        // we'll return if the client attempts to resume or rewind to an
        // invalid SID.
        //

        if ( (count == 1
                 &&
              findFirst
                 &&
              ( maxCount > 1 || !search->Wildcards )
                 &&
              availableSpace > sizeof(SMB_DIRECTORY_INFORMATION) ) ) {

            IF_SMB_DEBUG(SEARCH1) {
                SrvPrint3( "SrvSmbSearch: prematurely closing search %p, index %lx sequence %lx\n",
                               search, sidIndex, sequence );
            }

            SrvCloseSearch( search );

        } else {

            PLIST_ENTRY hashEntry;

            //
            // Put the search on the core search list.
            //

            ACQUIRE_LOCK( &connection->Lock );

            if ( GET_BLOCK_STATE( session ) != BlockStateActive ) {

                //
                // The session is closing.  Do not insert this search
                // on the search list, because the list may already
                // have been cleaned up.
                //

                RELEASE_LOCK( &connection->Lock );
                status = STATUS_SMB_BAD_UID;
                goto error_exit;

            } else if ( GET_BLOCK_STATE( treeConnect ) != BlockStateActive ) {

                //
                // Tree connect is closing.  Don't insert the search block
                // so the tree connect can be cleaned up immediately.
                //

                RELEASE_LOCK( &connection->Lock );
                status = STATUS_SMB_BAD_TID;
                goto error_exit;
            }

            KeQuerySystemTime( &search->LastUseTime );

            SrvInsertTailList(
                &pagedConnection->CoreSearchList,
                &search->LastUseListEntry
                );

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

            //
            // Insert this into the hash table.
            //

            hashEntry = &search->HashTableEntry;

            if ( hashEntry->Flink == NULL ) {
                SrvAddToSearchHashTable(
                                pagedConnection,
                                search
                                );
            } else {

                PLIST_ENTRY listHead;

                listHead = &pagedConnection->SearchHashTable[
                                            search->HashTableIndex].ListHead;

                if ( listHead->Flink != hashEntry ) {

                    //
                    // remove it and put it back on the front of the queue.
                    //

                    SrvRemoveEntryList(
                        listHead,
                        hashEntry
                        );

                    SrvInsertHeadList(
                        listHead,
                        hashEntry
                        );
                }
            }

            RELEASE_LOCK( &connection->Lock );

            //
            // Make sure the reference count will be 2.  1 for out pointer,
            // and one for the active status.
            //

            ASSERT( search->BlockHeader.ReferenceCount == 2 );
        }

    } else if ( command == SMB_COM_FIND_UNIQUE ) {

        //
        // If this was a find unique, get rid of the search block by
        // closing the query directory and the search block.
        //

        search->DirectoryHandle = NULL;
        SrvCloseQueryDirectory( directoryInformation );
        SrvCloseSearch( search );
    }

done_core:

    //
    // Set up the response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Count, count );
    SmbPutUshort( &response->ByteCount, (USHORT)(totalBytesWritten+3) );
    response->Buffer[0] = SMB_FORMAT_VARIABLE;
    SmbPutUshort(
        (PSMB_USHORT)(response->Buffer+1),
        (USHORT)totalBytesWritten
        );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_SEARCH,
                                          SmbGetUshort( &response->ByteCount )
                                          );

    //
    // Remove our pointer's reference.
    //

    if( search ) {
        search->InUse = FALSE;
        SrvDereferenceSearch( search );
    }

    if ( !isUnicode &&
        fileName.Buffer != NULL &&
        fileName.Buffer != nameBuffer &&
        fileName.Buffer != unicodeResumeName ) {

        RtlFreeUnicodeString( &fileName );
    }

    if( directoryInformation ) {
        DEALLOCATE_NONPAGED_POOL( directoryInformation );
    }

    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

error_exit:

    if ( search != NULL ) {

        //
        // If findFirst == TRUE, then we allocated a search block which
        //      we have to close.
        // If findFirst == TRUE and calledQueryDirectory == TRUE, then
        //      we also opened the directory handle and need to close it.
        // If findFirst == FALSE, then then we got an existing search
        //      block with an existing directory handle.
        //

        if ( findFirst) {
            if ( calledQueryDirectory ) {
                SrvCloseQueryDirectory( directoryInformation );
                search->DirectoryHandle = NULL;
            }
            SrvCloseSearch( search );
        }

        search->InUse = FALSE;

        //
        // Remove our pointer's reference.
        //

        SrvDereferenceSearch( search );
    }

    //
    // Deallocate the directory information block.  We do not need
    // to close the directoryhandle here since we should have already
    // closed it (if we need to) in the preceding code.
    //

    if ( directoryInformation != NULL ) {
        DEALLOCATE_NONPAGED_POOL( directoryInformation );
    }

    if ( !isUnicode &&
        fileName.Buffer != NULL &&
        fileName.Buffer != nameBuffer &&
        fileName.Buffer != unicodeResumeName ) {

        RtlFreeUnicodeString( &fileName );
    }

    if( status == STATUS_PATH_NOT_COVERED ) {
        SrvSetSmbError( WorkContext, status );

    } else {
        SrvSetSmbError(
            WorkContext,
            isCoreSearch && (status != STATUS_OBJECT_PATH_NOT_FOUND) ?
                STATUS_NO_MORE_FILES : status
        );
    }

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

    Add SRVNTVERCHK to the C_DEFINES line below if you want to enable
    server side checking of NT build numbers.  Having compiled with this,
    you can set REG_DWORD MinNt5Client in the registry to the minimum NT5
    build number that a client must be running in order to connect to a disk
    share on this server.  If you have clients which you want to exclude from
    this check, you can add their static IP address to REG_MULTI_SZ ValidNT5IPAddr
    as dotted quad values. You do not need to restart the server if you make
    changes to these registry values.  If you want to restrict clients from connecting
    to all shares (not just disk), use the MinNT5ClientIPC keyword instead of
    MinNt5Client.



!ENDIF

MAJORCOMP=ntos
MINORCOMP=srv

TARGETNAME=srv
TARGETTYPE=DRIVER
TARGETPATH=obj

TARGETLIBS=$(DDK_LIB_PATH)\tdi.lib \
           ..\..\smbtrsup\$(O)\smbtrsup.lib \
           $(DDK_LIB_PATH)\ksecdd.lib \
           $(DS_LIB_PATH)\rsa32k.lib

# merge RSA32K.LIB paged code & data into non-paged sections.
LINKER_FLAGS = $(LINKER_FLAGS) -merge:PAGER32C=.text -merge:PAGER32D=.data -merge:PAGER32R=.rdata


NT_UP=0

INCLUDES=\
    ..;\
    $(O);\
    $(NET_INC_PATH);\
    $(DS_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(DRIVERS_INC_PATH);\
    $(IFSKIT_INC_PATH)


C_DEFINES=$(C_DEFINES) -D_NTDRIVER_ -D_PNP_POWER_ -DSRVNTVERCHK -DSRVCATCH

MSC_WARNING_LEVEL=/W3 /WX

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

!IFDEF BUILD_FOR_3_51
C_DEFINES=$(C_DEFINES) -D_NTIFS_
!ENDIF

NTPROFILEINPUT=yes

SOURCES=               \
        ..\access.c    \
        ..\blkconn.c   \
        ..\blkdebug.c  \
        ..\blkdir.c    \
        ..\blkendp.c   \
        ..\blkfile.c   \
        ..\blklock.c   \
        ..\blksess.c   \
        ..\blkshare.c  \
        ..\blksrch.c   \
        ..\blktable.c  \
        ..\blktimer.c  \
        ..\blktrans.c  \
        ..\blktree.c   \
        ..\blkwork.c   \
        ..\copy.c      \
        ..\dfs.c       \
        ..\ea.c        \
        ..\errorlog.c  \
        ..\fsd.c       \
        ..\fsddisp.c   \
        ..\fsdraw.c    \
        ..\fsdsmb.c    \
        ..\fspinit.c   \
        ..\heapmgr.c   \
        ..\info.c      \
        ..\ipx.c       \
        ..\io.c        \
        ..\lock.c      \
        ..\lockcode.c  \
        ..\move.c      \
        ..\network.c   \
        ..\open.c      \
        ..\oplock.c    \
        ..\persist.c   \
        ..\pipe.c      \
        ..\prnsupp.c   \
        ..\scavengr.c  \
        ..\share.c     \
        ..\slmcheck.c  \
        ..\smbadmin.c  \
        ..\smbattr.c   \
        ..\smbclose.c  \
        ..\smbdir.c    \
        ..\smbfile.c   \
        ..\smbfind.c   \
        ..\smbioctl.c  \
        ..\smblock.c   \
        ..\smbmisc.c   \
        ..\smbmpx.c    \
        ..\smbnotfy.c  \
        ..\smbopen.c   \
        ..\smbprint.c  \
        ..\smbproc.c   \
        ..\smbraw.c    \
        ..\smbrdwrt.c  \
        ..\smbsrch.c   \
        ..\smbsupp.c   \
        ..\smbtrans.c  \
        ..\smbtree.c   \
        ..\srv.rc      \
        ..\srvconfg.c  \
        ..\srvdata.c   \
        ..\srvsnap.c   \
        ..\srvstamp.c  \
        ..\srvstat.c   \
        ..\srvstrng.c  \
        ..\svcconn.c   \
        ..\svcfile.c   \
        ..\svcsess.c   \
        ..\svcshare.c  \
        ..\svcsrv.c    \
        ..\svcstats.c  \
        ..\svcsupp.c   \
        ..\svcxport.c  \
        ..\worker.c    \
        ..\xssupp.c

RUN_WPP=$(SOURCES) -km -gen{simple.tpl}*.tmh -func:KdPrint((MSG,...)) -ini:localwpp.ini -func:SrvPrint0(MSG) -func:SrvPrint1(MSG,...) -func:SrvPrint2(MSG,...) -func:SrvPrint3(MSG,...) -func:SrvPrint4(MSG,...)

NTTARGETFILE0=srv.bmf

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\SOURCES.INC
MISCFILES=smbsrv.sld
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbtrans.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbtrans.c

Abstract:

    This module contains routines for processing the following SMBs:

        Transaction
        Transaction2

Author:

    Chuck Lenzmeier (chuckl) 19-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbtrans.tmh"
#include <align.h> // ROUND_UP_POINTER
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBTRANS

//
// Forward declarations
//

SMB_STATUS SRVFASTCALL
ExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartTransactionResponse (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartIpxMultipieceSend (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartIpxTransactionResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
MailslotTransaction (
    PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartMailslotWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ExecuteTransaction )
#pragma alloc_text( PAGE, SrvCompleteExecuteTransaction )
#pragma alloc_text( PAGE, SrvFindTransaction )
#pragma alloc_text( PAGE, SrvInsertTransaction )
#pragma alloc_text( PAGE, RestartTransactionResponse )
#pragma alloc_text( PAGE, SrvSmbTransaction )
#pragma alloc_text( PAGE, SrvSmbTransactionSecondary )
#pragma alloc_text( PAGE, SrvSmbNtTransaction )
#pragma alloc_text( PAGE, SrvSmbNtTransactionSecondary )
#pragma alloc_text( PAGE, MailslotTransaction )
#pragma alloc_text( PAGE, RestartMailslotWrite )
#pragma alloc_text( PAGE, SrvRestartExecuteTransaction )
#pragma alloc_text( PAGE, RestartIpxMultipieceSend )
#pragma alloc_text( PAGE, RestartIpxTransactionResponse )
#endif


SMB_STATUS SRVFASTCALL
ExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Executes a transaction and starts the process of sending the
    zero or more responses.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The block
        contains information about the last SMB received for the
       transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    SMB_STATUS - Indicates the status of SMB processing.

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;
    SMB_TRANS_STATUS resultStatus;
    CLONG offset;
    USHORT command;

    PAGED_CODE( );

    resultStatus = SmbTransStatusErrorWithoutData;

    transaction = WorkContext->Parameters.Transaction;

    if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION ||
          WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY ) &&
         transaction->RemoteApiRequest &&
         WorkContext->UsingBlockingThread == 0 ) {

        //
        // This is a downlevel API request, we must make sure we are on
        // a blocking thread before handling it, since it will LPC to the
        // srvsvc which might take some time to complete.
        //
        WorkContext->FspRestartRoutine = ExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );

        return SmbStatusInProgress;
    }

    header = WorkContext->ResponseHeader;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    //
    // Setup output pointers
    //

    if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ||
         WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY ) {
        transaction->OutSetup = (PSMB_USHORT)ntResponse->Buffer;
    } else {
        transaction->OutSetup = (PSMB_USHORT)response->Buffer;
    }

    if ( transaction->OutParameters == NULL ) {

        //
        // Parameters will go into the SMB buffer.  Calculate the pointer
        // then round it up to the next DWORD address.
        //

        transaction->OutParameters = (PCHAR)(transaction->OutSetup +
            transaction->MaxSetupCount);
        offset = (PTR_DIFF(transaction->OutParameters, header) + 3) & ~3;
        transaction->OutParameters = (PCHAR)header + offset;
    }

    if ( transaction->OutData == NULL ) {

        //
        // Data will go into the SMB buffer.  Calculate the pointer
        // then round it up to the next DWORD address.
        //

        transaction->OutData = transaction->OutParameters +
            transaction->MaxParameterCount;
        offset = (PTR_DIFF(transaction->OutData, header) + 3) & ~3;
        transaction->OutData = (PCHAR)header + offset;
    }

    //
    // If this is a Transaction2 request, then we can simply index into
    // a table to find the right transaction processor.  If it's a
    // Transaction request, we have to do more complicated things to
    // determine what to do.
    //

    if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION) ||
         (WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY) ) {

        //
        // Dispatching for Transaction SMBs
        //

        if ( transaction->RemoteApiRequest ) {

           //
           // This is a down-level remote API request.  Send it to
           // XACTSRV for processing.
           //

           ASSERT( transaction->PipeRequest );

           resultStatus = SrvXsRequest( WorkContext );

        } else if ( transaction->PipeRequest ) {

            //
            // Normal pipe function.  Handle it.
            //

            command = SmbGetUshort(&transaction->InSetup[0]);

            //
            // If this operation may block, and we are running short of
            // free work items, fail this SMB with an out of resources error.
            //

            if ( !WorkContext->BlockingOperation &&
                 (command == TRANS_CALL_NMPIPE ||
                  command == TRANS_TRANSACT_NMPIPE ||
                  command == TRANS_WAIT_NMPIPE ||
                  command == TRANS_RAW_WRITE_NMPIPE) ) {

                if ( SrvReceiveBufferShortage( ) ) {

                    SrvStatistics.BlockingSmbsRejected++;

                    SrvSetSmbError(
                        WorkContext,
                        STATUS_INSUFF_SERVER_RESOURCES
                        );

                    resultStatus = SmbTransStatusErrorWithoutData;
                    goto exit;

                } else {

                    //
                    // SrvBlockingOpsInProgress has already been incremented.
                    // Flag this work item as a blocking operation.
                    //

                    WorkContext->BlockingOperation = TRUE;

                }

            }


            switch( command ) {

            case TRANS_TRANSACT_NMPIPE:
                resultStatus = SrvTransactNamedPipe( WorkContext );
                break;

            case TRANS_PEEK_NMPIPE:
                resultStatus = SrvPeekNamedPipe( WorkContext );
                break;

            case TRANS_CALL_NMPIPE:
                resultStatus = SrvCallNamedPipe( WorkContext );
                break;

            case TRANS_WAIT_NMPIPE:
                resultStatus = SrvWaitNamedPipe( WorkContext );
                break;

            case TRANS_QUERY_NMPIPE_STATE:
                resultStatus = SrvQueryStateNamedPipe( WorkContext );
                break;

            case TRANS_SET_NMPIPE_STATE:
                resultStatus = SrvSetStateNamedPipe( WorkContext );
                break;

            case TRANS_QUERY_NMPIPE_INFO:
                resultStatus = SrvQueryInformationNamedPipe( WorkContext );
                break;

            case TRANS_RAW_WRITE_NMPIPE:
                resultStatus = SrvRawWriteNamedPipe( WorkContext );
                break;

            case TRANS_RAW_READ_NMPIPE:  // Legal command, unsupported by server
                SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
                resultStatus = SmbTransStatusErrorWithoutData;
                break;

            case TRANS_WRITE_NMPIPE:
                resultStatus = SrvWriteNamedPipe( WorkContext );
                break;

            case TRANS_READ_NMPIPE:
                resultStatus = SrvReadNamedPipe( WorkContext );
                break;

            default:
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                resultStatus = SmbTransStatusErrorWithoutData;

                SrvLogInvalidSmb( WorkContext );
            }

        } else if ( _wcsnicmp(
                        transaction->TransactionName.Buffer,
                        StrSlashMailslot,
                        UNICODE_SMB_MAILSLOT_PREFIX_LENGTH / sizeof(WCHAR)
                        ) == 0 ) {

            //
            // This is a mailslot transaction
            //

            resultStatus = MailslotTransaction( WorkContext );

        } else {

            //
            // This is not a named pipe transaction or a mailslot
            // transaction.  The server should never see these.
            //

            SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );
            resultStatus = SmbTransStatusErrorWithoutData;

        }

    } else if ( (WorkContext->NextCommand == SMB_COM_NT_TRANSACT) ||
         (WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY) ) {

        command = transaction->Function;

        if ( command >= NT_TRANSACT_MIN_FUNCTION &&
                command <= NT_TRANSACT_MAX_FUNCTION ) {

            //
            // Legal function code.  Call the processing routine.  The
            // transaction processor returns TRUE if it encountered an
            // error and updated the response header appropriately (by
            // calling SrvSetSmbError).  In this case, no transaction-
            // specific response data will be sent.
            //

            resultStatus =
                SrvNtTransactionDispatchTable[ command ]( WorkContext );

            IF_SMB_DEBUG(TRANSACTION1) {
                if ( resultStatus != SmbTransStatusSuccess ) {
                    SrvPrint0( "NT Transaction processor returned error\n" );
                }
            }

        } else {

            //
            // Either no setup words were sent, or the function code is
            // out-of-range.  Return an error.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "Invalid NT Transaction function code 0x%lx\n",
                           transaction->Function );
            }

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            resultStatus = SmbTransStatusErrorWithoutData;

        }

    } else if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION2) ||
         (WorkContext->NextCommand == SMB_COM_TRANSACTION2_SECONDARY) ) {

        USHORT command;

        command = SmbGetUshort( &transaction->InSetup[0] );

        if ( (transaction->SetupCount >= 1) &&
             (command <= TRANS2_MAX_FUNCTION) ) {

            //
            // Legal function code.  Call the processing routine.  The
            // transaction processor returns TRUE if it encountered an
            // error and updated the response header appropriately (by
            // calling SrvSetSmbError).  In this case, no transaction-
            // specific response data will be sent.
            //

            resultStatus =
                SrvTransaction2DispatchTable[ command ]( WorkContext );

            IF_SMB_DEBUG(TRANSACTION1) {
                if ( resultStatus != SmbTransStatusSuccess ) {
                    SrvPrint0( "Transaction processor returned error\n" );
                }
            }

        } else {

            //
            // Either no setup words were sent, or the function code is
            // out-of-range.  Return an error.
            //

            IF_DEBUG(SMB_ERRORS) {
                if ( transaction->SetupCount <= 0 ) {
                    SrvPrint0( "No Transaction2 setup words\n" );
                } else {
                    SrvPrint1( "Invalid Transaction2 function code 0x%lx\n",
                                (ULONG)SmbGetUshort(
                                           &transaction->InSetup[0] ) );
                }
            }

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            resultStatus = SmbTransStatusErrorWithoutData;

        }

    } else {

        ASSERT( FALSE );

    }

exit:

    //
    // If the transaction call completed synchronously, generate the
    // response and send it.
    //
    // If the call will be completed asynchronously, then the handler
    // for that call will call SrvCompleteExectuteTransaction().
    //

    if ( resultStatus != SmbTransStatusInProgress ) {
        SrvCompleteExecuteTransaction(WorkContext, resultStatus);
    }

    return SmbStatusInProgress;

} // ExecuteTransaction


VOID
SrvCompleteExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_TRANS_STATUS ResultStatus
    )

/*++

Routine Description:

    This function completes the execution of a transaction and sends
    the response

Arguments:

    WorkContext - A pointer to the associated work context block.
    ResultStatus - The return code from the

--*/

{
    PTRANSACTION transaction;
    UCHAR transactionCommand;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;

    CLONG maxSize;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramLength;
    CLONG paramOffset;
    PCHAR dataPtr;
    CLONG dataLength;
    CLONG dataOffset;
    CLONG sendLength;

    BOOLEAN ntTransaction = FALSE;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    header = WorkContext->ResponseHeader;
    transactionCommand = (UCHAR)SmbGetUshort( &transaction->InSetup[0] );

    if ( ResultStatus == SmbTransStatusErrorWithoutData ) {

        USHORT flags = transaction->Flags;

        //
        // An error occurred, so no transaction-specific response data
        // will be returned.  Close the transaction and arrange for a
        // response message indicating the error to be returned.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint1( "Error response. Closing transaction 0x%p\n",
                        transaction );
        }

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // If the NO_RESPONSE bit was set in the request, don't send a
        // response; instead, just close the transaction.  (If the
        // transaction arrived as part of an AndX chain, we need to send a
        // response anyway, to respond to the preceeding commands.)
        //

        if ( (flags & SMB_TRANSACTION_NO_RESPONSE) &&
             (header->Command == WorkContext->NextCommand) ) {

            if ( WorkContext->OplockOpen ) {
                SrvCheckDeferredOpenOplockBreak( WorkContext );
            }

            //
            // The Transaction request came by itself.  No response.
            //

            SrvDereferenceWorkItem( WorkContext );

            return;

        }

        //
        // Calculate the length of the response message.
        //

        sendLength = (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                (PCHAR)WorkContext->ResponseHeader );

        WorkContext->ResponseBuffer->DataLength = sendLength;
        WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );

        return;
    }

    //
    // The transaction has been executed, and transaction-specific
    // response data is to be returned.  The processing routine updated
    // the output pointers and counts appropriately.
    //

    ASSERT( transaction->SetupCount <= transaction->MaxSetupCount);
    ASSERT( transaction->ParameterCount <= transaction->MaxParameterCount);
    ASSERT( transaction->DataCount <= transaction->MaxDataCount);

    //
    // If the NO_RESPONSE bit was set in the request, don't send a
    // response; instead, just close the transaction.  (If the
    // transaction arrived as part of an AndX chain, we need to send a
    // response anyway, to respond to the preceeding commands.)
    //

    if ( (transaction->Flags & SMB_TRANSACTION_NO_RESPONSE) &&
        ResultStatus != SmbTransStatusErrorWithData ) {

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint1( "No response.  Closing transaction 0x%p\n",
                        transaction );
        }

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        if ( header->Command == WorkContext->NextCommand ) {

            if ( WorkContext->OplockOpen ) {
                SrvCheckDeferredOpenOplockBreak( WorkContext );
            }

            SrvDereferenceWorkItem( WorkContext );

            //
            // The Transaction request came by itself.  No response.
            //

            return;

        } else {

            //
            // The Transaction request was part of an AndX chain.  Find
            // the preceding command in the chain and update it to
            // indicate that it is now the end of the chain.
            //

            PGENERIC_ANDX response;

            IF_SMB_DEBUG(TRANSACTION1) {
                SrvPrint0( "AndX chain.  Sending response anyway\n" );
            }

            response = (PGENERIC_ANDX)(header + 1);
            while( response->AndXCommand != WorkContext->NextCommand ) {
                response = (PGENERIC_ANDX)((PCHAR)header +
                              SmbGetUshort( &response->AndXOffset ) );
            }

            response->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
            SmbPutUshort( &response->AndXOffset, 0 );

            //
            // Calculate the length of the response message.
            //

            sendLength = (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                    (PCHAR)WorkContext->ResponseHeader );

            WorkContext->ResponseBuffer->DataLength = sendLength;

            //
            // Send the response.
            //

            SRV_START_SEND_2(
                WorkContext,
                SrvFsdRestartSmbAtSendCompletion,
                NULL,
                NULL
                );

            return;
        }
    }

    //
    // The client wants a response.  Build the first (and possibly only)
    // response.  The last received SMB of the transaction request was
    // retained for this purpose.
    //

    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    //
    // If the transaction arrived in multiple pieces, then we have to
    // put the correct command code in the response header.  (Note that
    // a multi-part transaction request cannot be sent as part of an
    // AndX chain, so we know it's safe to write into the header.)
    //

    if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION) ||
         (WorkContext->NextCommand == SMB_COM_TRANSACTION2) ) {
       ;
    } else if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ) {
       ntTransaction = TRUE;
    } else if ( WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY ) {
       header->Command = SMB_COM_TRANSACTION;
    } else if ( WorkContext->NextCommand == SMB_COM_TRANSACTION2_SECONDARY ) {
       header->Command = SMB_COM_TRANSACTION2;
    } else if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY ) {
       header->Command = SMB_COM_NT_TRANSACT;
       ntTransaction = TRUE;
    }

    //
    // Is this an NT transaction?  If so format an nt transaction
    // response.  The response formats for transact and transact2
    // are essentially identical.
    //
    // Build the parameters portion of the response.
    //

    if ( ntTransaction ) {
        ntResponse->WordCount = (UCHAR)(18 + transaction->SetupCount);
        ntResponse->Reserved1 = 0;
        SmbPutUshort( &ntResponse->Reserved2, 0 );
        SmbPutUlong( &ntResponse->TotalParameterCount,
                     transaction->ParameterCount
                     );
        SmbPutUlong( &ntResponse->TotalDataCount,
                     transaction->DataCount
                     );
        ntResponse->SetupCount = (UCHAR)transaction->SetupCount;
    } else {
        response->WordCount = (UCHAR)(10 + transaction->SetupCount);
        SmbPutUshort( &response->TotalParameterCount,
                      (USHORT)transaction->ParameterCount
                      );
        SmbPutUshort( &response->TotalDataCount,
                      (USHORT)transaction->DataCount
                      );
        SmbPutUshort( &response->Reserved, 0 );
        response->SetupCount = (UCHAR)transaction->SetupCount;
        response->Reserved2 = 0;
    }

    //
    // Save a pointer to the byte count field.
    //
    // If the output data and parameters are not already in the SMB
    // buffer we must calculate how much of the parameters and data can
    // be sent in this response.  The maximum amount we can send is
    // minimum of the size of our buffer and the size of the client's
    // buffer.
    //
    // The parameter and data byte blocks are aligned on longword
    // boundaries in the message.
    //

    byteCountPtr = transaction->OutSetup + transaction->SetupCount;

    //
    // Either we have a session, in which case the client's buffer sizes
    // are contained therein, or someone put the size in the transaction.
    // There is one known instance of the latter: Kerberos authentication
    // that requires an extra negotiation leg.
    //

    maxSize = MIN(
                WorkContext->ResponseBuffer->BufferLength,
                transaction->Session ?
                  (CLONG)transaction->Session->MaxBufferSize :
                    transaction->cMaxBufferSize
                );

    if ( transaction->OutputBufferCopied ) {

        //
        // The response data was not written directly in the SMB
        // response buffer.  It must now be copied out of the transaction
        // block into the SMB.
        //

        paramPtr = (PCHAR)(byteCountPtr + 1);    // first legal location
        paramOffset = PTR_DIFF(paramPtr, header);// offset from start of header
        paramOffset = (paramOffset + 3) & ~3;    // round to next longword
        paramPtr = (PCHAR)header + paramOffset;  // actual location

        paramLength = transaction->ParameterCount;  // assume all parameters fit

        if ( (paramOffset + paramLength) > maxSize ) {

            //
            // Not all of the parameter bytes will fit.  Send the maximum
            // number of longwords that will fit.  Don't send any data bytes
            // in the first message.
            //

            paramLength = maxSize - paramOffset;    // max that will fit
            paramLength = paramLength & ~3;         // round down to longword

            dataLength = 0;                         // don't send data bytes
            dataOffset = 0;
            dataPtr = paramPtr + paramLength;       // make calculations work

        } else {

            //
            // All of the parameter bytes fit.  Calculate how many of the
            // data bytes fit.
            //

            dataPtr = paramPtr + paramLength;       // first legal location
            dataOffset = PTR_DIFF(dataPtr, header); // offset from start of header
            dataOffset = (dataOffset + 3) & ~3;     // round to next longword
            dataPtr = (PCHAR)header + dataOffset;   // actual location

            dataLength = transaction->DataCount;    // assume all data bytes fit

            if ( (dataOffset + dataLength) > maxSize ) {

                //
                // Not all of the data bytes will fit.  Send the maximum
                // number of longwords that will fit.
                //

                dataLength = maxSize - dataOffset;  // max that will fit
                dataLength = dataLength & ~3;       // round down to longword

            }

        }

        //
        // Copy the appropriate parameter and data bytes into the message.
        //
        // !!! Note that it would be possible to use the chain send
        //     capabilities of TDI to send the parameter and data bytes from
        //     their own buffers.  There is extra overhead involved in doing
        //     this, however, because the buffers must be locked down and
        //     mapped into system space so that the network drivers can look
        //     at them.
        //

        if ( paramLength != 0 ) {
            RtlMoveMemory( paramPtr, transaction->OutParameters, paramLength );
        }

        if ( dataLength != 0 ) {
            RtlMoveMemory( dataPtr, transaction->OutData, dataLength );
        }


    } else {

        //
        // The data and paramter are already in the SMB buffer.  The entire
        // response will fit in one response buffer and there is no copying
        // to do.
        //

        paramPtr = transaction->OutParameters;
        paramOffset = PTR_DIFF(paramPtr, header);
        paramLength = transaction->ParameterCount;

        dataPtr = transaction->OutData;
        dataOffset = PTR_DIFF(dataPtr, header);
        dataLength = transaction->DataCount;

    }

    //
    // Finish filling in the response parameters.
    //

    if ( ntTransaction ) {
        SmbPutUlong( &ntResponse->ParameterCount, paramLength );
        SmbPutUlong( &ntResponse->ParameterOffset, paramOffset );
        SmbPutUlong( &ntResponse->ParameterDisplacement, 0 );

        SmbPutUlong( &ntResponse->DataCount, dataLength );
        SmbPutUlong( &ntResponse->DataOffset, dataOffset );
        SmbPutUlong( &ntResponse->DataDisplacement, 0 );
    } else {
        SmbPutUshort( &response->ParameterCount, (USHORT)paramLength );
        SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
        SmbPutUshort( &response->ParameterDisplacement, 0 );

        SmbPutUshort( &response->DataCount, (USHORT)dataLength );
        SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
        SmbPutUshort( &response->DataDisplacement, 0 );
    }

    transaction->ParameterDisplacement = paramLength;
    transaction->DataDisplacement = dataLength;

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // If this isn't the last part of the response, inhibit statistics
    // gathering.  If it is the last part of the response, restore the
    // start time to the work context block.
    //
    // If this isn't the last part of the response, tell TDI that we
    // do not expect back traffic, so that the client will immediately
    // ACK this packet, rather than waiting.
    //

    if ( (paramLength != transaction->ParameterCount) ||
         (dataLength != transaction->DataCount) ) {

        ASSERT( transaction->Inserted );
        WorkContext->StartTime = 0;

        //
        // Save the address of the transaction block in the work context
        // block.  Send out the response.  When the send completes,
        // RestartTransactionResponse is called to either send the next
        // message or close the transaction.
        //
        //
        // Note that the transaction block remains referenced while the
        // response is being sent.
        //

        WorkContext->Parameters.Transaction = transaction;
        WorkContext->ResponseBuffer->Mdl->ByteCount = sendLength;

        if ( WorkContext->Endpoint->IsConnectionless ) {

            WorkContext->FspRestartRoutine = RestartIpxMultipieceSend;
            WorkContext->FsdRestartRoutine = NULL;
            transaction->MultipieceIpxSend = TRUE;

            SrvIpxStartSend( WorkContext, SrvQueueWorkToFspAtSendCompletion );

        } else {

            SRV_START_SEND(
                WorkContext,
                WorkContext->ResponseBuffer->Mdl,
                TDI_SEND_NO_RESPONSE_EXPECTED,
                SrvQueueWorkToFspAtSendCompletion,
                NULL,
                RestartTransactionResponse
                );
        }

    } else {

        //
        // This is the final piece. Close the transaction.
        //

        WorkContext->StartTime = transaction->StartTime;

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );
    }

    //
    // The response send is in progress.  The caller will assume
    // the we will handle send completion.
    //

    return;

} // SrvCompleteExecuteTransaction


PTRANSACTION
SrvFindTransaction (
    IN PCONNECTION Connection,
    IN PSMB_HEADER Header,
    IN USHORT Fid OPTIONAL
    )

/*++

Routine Description:

    Searches the list of pending transactions for a connection, looking
    for one whose identity matches that of a received secondary
    Transaction(2) request.  If one is found, it is referenced.

Arguments:

    Connection - Supplies a pointer to the connection block for the
        connection on which the secondary request was received.

    Header - Supplies a pointer to the header of the received
        Transaction(2) Secondary SMB.

    Fid - The file handle for this operation.  The parameter is required
       if operation is progress is a WriteAndX SMB.

Return Value:

    PTRANSACTION - Returns a pointer to the matching transaction block,
        if one is found, else NULL.

--*/

{
    PLIST_ENTRY listEntry;
    PTRANSACTION thisTransaction;

    USHORT targetOtherInfo;

    PAGED_CODE( );

    //
    // If this is a multipiece transaction SMB, the MIDs of all the pieces
    // must match.  If it is a multipiece WriteAndX protocol the pieces
    // using the FID.
    //

    if (Header->Command == SMB_COM_WRITE_ANDX) {
        targetOtherInfo = Fid;
    } else {
        targetOtherInfo = SmbGetAlignedUshort( &Header->Mid );
    }

    //
    // Acquire the transaction lock.  This prevents the connection's
    // transaction list from changing while we walk it.
    //

    ACQUIRE_LOCK( &Connection->Lock );

    //
    // Walk the transaction list, looking for one with the same
    // identity as the new transaction.
    //

    for ( listEntry = Connection->PagedConnection->TransactionList.Flink;
          listEntry != &Connection->PagedConnection->TransactionList;
          listEntry = listEntry->Flink ) {

        thisTransaction = CONTAINING_RECORD(
                            listEntry,
                            TRANSACTION,
                            ConnectionListEntry
                            );

        if ( ( thisTransaction->Tid == SmbGetAlignedUshort( &Header->Tid ) ) &&
             ( thisTransaction->Pid == SmbGetAlignedUshort( &Header->Pid ) ) &&
             ( thisTransaction->Uid == SmbGetAlignedUshort( &Header->Uid ) ) &&
             ( thisTransaction->OtherInfo == targetOtherInfo ) ) {

            //
            // A transaction with the same identity has been found.  If
            // it's still active, reference it and return its address.
            // Otherwise, return a NULL pointer to indicate that a valid
            // matching transaction was not found.
            //

            if ( GET_BLOCK_STATE(thisTransaction) == BlockStateActive ) {

                SrvReferenceTransaction( thisTransaction );

                RELEASE_LOCK( &Connection->Lock );

                return thisTransaction;

            } else {

                RELEASE_LOCK( &Connection->Lock );
                return NULL;

            }

        }

    } // for

    //
    // We made it all the way through the list without finding a
    // matching transaction.  Return a NULL pointer.
    //

    RELEASE_LOCK( &Connection->Lock );

    return NULL;

} // SrvFindTransaction


BOOLEAN
SrvInsertTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    Inserts a transaction block into the list of pending transactions
    for a connection.  Prior to doing so, it ensures a transaction
    with the same identity (combination of TID, PID, UID, and MID)
    is not already in the list.

Arguments:

    Transaction - Supplies a pointer to a transaction block.  The
        Connection, Tid, Pid, Uid, and Mid fields must be valid.

Return Value:

    BOOLEAN - Returns TRUE if the transaction block was inserted.
        Returns FALSE if the block was not inserted because a
        transaction with the same identity already exists in the list.

--*/

{
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PLIST_ENTRY listEntry;
    PTRANSACTION thisTransaction;

    PAGED_CODE( );

    ASSERT( !Transaction->Inserted );

    //
    // Acquire the transaction lock.  This prevents the connection's
    // transaction list from changing while we walk it.
    //

    connection = Transaction->Connection;
    pagedConnection = connection->PagedConnection;

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Make sure the connection, session, and tree connect aren't
    // closing, so that we don't put the transaction on the list
    // after the list has been run down.
    //

    if ( (GET_BLOCK_STATE(connection) != BlockStateActive) ||
         ((Transaction->Session != NULL) &&
            (GET_BLOCK_STATE(Transaction->Session) != BlockStateActive)) ||
         ((Transaction->TreeConnect != NULL) &&
            (GET_BLOCK_STATE(Transaction->TreeConnect) != BlockStateActive)) ) {

        RELEASE_LOCK( &connection->Lock );
        return FALSE;
    }

    //
    // Walk the transaction list, looking for one with the same
    // identity as the new transaction.
    //

    for ( listEntry = pagedConnection->TransactionList.Flink;
          listEntry != &pagedConnection->TransactionList;
          listEntry = listEntry->Flink ) {

        thisTransaction = CONTAINING_RECORD(
                            listEntry,
                            TRANSACTION,
                            ConnectionListEntry
                            );

        if ( (thisTransaction->Tid == Transaction->Tid) &&
             (thisTransaction->Pid == Transaction->Pid) &&
             (thisTransaction->Uid == Transaction->Uid) &&
             (thisTransaction->OtherInfo == Transaction->OtherInfo) ) {

            //
            // A transaction with the same identity has been found.
            // Don't insert the new one in the list.
            //

            RELEASE_LOCK( &connection->Lock );

            return FALSE;

        }

    } // for

    //
    // We made it all the way through the list without finding a
    // matching transaction.  Insert the new one at the tail of the
    // list.
    //

    SrvInsertTailList(
        &pagedConnection->TransactionList,
        &Transaction->ConnectionListEntry
        );

    Transaction->Inserted = TRUE;

    RELEASE_LOCK( &connection->Lock );

    return TRUE;

} // SrvInsertTransaction


VOID SRVFASTCALL
RestartTransactionResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for a Transaction response.  If more
    responses are required, it builds and sends the next one.  If all
    responses have been sent, it closes the transaction.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The
        block contains information about the last SMB received for
        the transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;
    PCONNECTION connection;

    CLONG maxSize;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramLength;
    CLONG paramOffset;
    CLONG paramDisp;
    PCHAR dataPtr;
    CLONG dataLength;
    CLONG dataOffset;
    CLONG dataDisp;
    CLONG sendLength;

    BOOLEAN ntTransaction;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    paramDisp = transaction->ParameterDisplacement;
    dataDisp = transaction->DataDisplacement;

    IF_DEBUG(WORKER1) SrvPrint0( " - RestartTransactionResponse\n" );

    //
    // Get the connection pointer.  The connection pointer is a
    // referenced pointer.
    //

    connection = WorkContext->Connection;
    IF_DEBUG(TRACE2) {
        SrvPrint2( "  connection 0x%p, endpoint 0x%p\n",
                    connection, WorkContext->Endpoint );
    }

    //
    // If the I/O request failed or was canceled, or if the connection
    // is no longer active, clean up.  (The connection is marked as
    // closing when it is disconnected or when the endpoint is closed.)
    //
    // !!! If I/O failure, should we drop the connection?
    //

    if ( WorkContext->Irp->Cancel ||
          !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ||
          (GET_BLOCK_STATE(connection) != BlockStateActive) ) {

        IF_DEBUG(TRACE2) {
            if ( WorkContext->Irp->Cancel ) {
                SrvPrint0( "  I/O canceled\n" );
            } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                SrvPrint1( "  I/O failed: %X\n",
                            WorkContext->Irp->IoStatus.Status );
            } else {
                SrvPrint0( "  Connection no longer active\n" );
            }
        }

        //
        // Close the transaction.  Indicate that SMB processing is
        // complete.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint1( "I/O error. Closing transaction 0x%p\n", transaction );
        }
        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        if ( WorkContext->OplockOpen ) {
            SrvCheckDeferredOpenOplockBreak( WorkContext );
        }
        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );

        IF_DEBUG(TRACE2) {
            SrvPrint0( "RestartTransactionResponse complete\n" );
        }
        return;

    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint2( "Continuing transaction response; block 0x%p, name %wZ\n",
                    transaction, &transaction->TransactionName );
        SrvPrint3( "Connection 0x%p, session 0x%p, tree connect 0x%p\n",
                    transaction->Connection, transaction->Session,
                    transaction->TreeConnect );
        SrvPrint2( "Remaining: parameters %ld bytes, data %ld bytes\n",
                    transaction->ParameterCount - paramDisp,
                    transaction->DataCount - dataDisp );
    }

    //
    // Update the parameters portion of the response, reusing the last
    // SMB.
    //

    ASSERT( transaction->Inserted );

    header = WorkContext->ResponseHeader;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ||
         WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY ) {

        ntTransaction = TRUE;
        ntResponse->WordCount = (UCHAR)18;
        ntResponse->SetupCount = 0;

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)ntResponse->Buffer;

    } else {

        ntTransaction = FALSE;
        response->WordCount = (UCHAR)10;
        response->SetupCount = 0;

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)response->Buffer;
    }

    //
    // Either we have a session, in which case the client's buffer sizes
    // are contained therein, or someone put the size in the transaction.
    // There is one known instance of the latter: Kerberos authentication
    // that requires an extra negotiation leg.
    //

    maxSize = MIN(
                WorkContext->ResponseBuffer->BufferLength,
                transaction->Session ?
                  (CLONG)transaction->Session->MaxBufferSize :
                    transaction->cMaxBufferSize
                );

    paramPtr = (PCHAR)(byteCountPtr + 1);       // first legal location
    paramOffset = PTR_DIFF(paramPtr, header);   // offset from start of header
    paramOffset = (paramOffset + 3) & ~3;       // round to next longword
    paramPtr = (PCHAR)header + paramOffset;     // actual location

    paramLength = transaction->ParameterCount - paramDisp;
                                                // assume all parameters fit

    if ( (paramOffset + paramLength) > maxSize ) {

        //
        // Not all of the parameter bytes will fit.  Send the maximum
        // number of longwords that will fit.  Don't send any data bytes
        // in this message.
        //

        paramLength = maxSize - paramOffset;    // max that will fit
        paramLength = paramLength & ~3;         // round down to longword

        dataLength = 0;                         // don't send data bytes
        dataOffset = 0;
        dataPtr = paramPtr + paramLength;       // make calculations work

    } else {

        //
        // All of the parameter bytes fit.  Calculate how many of data
        // bytes fit.
        //

        dataPtr = paramPtr + paramLength;       // first legal location
        dataOffset = PTR_DIFF(dataPtr, header); // offset from start of header
        dataOffset = (dataOffset + 3) & ~3;     // round to next longword
        dataPtr = (PCHAR)header + dataOffset;   // actual location

        dataLength = transaction->DataCount - dataDisp;
                                                // assume all data bytes fit

        if ( (dataOffset + dataLength) > maxSize ) {

            //
            // Not all of the data bytes will fit.  Send the maximum
            // number of longwords that will fit.
            //

            dataLength = maxSize - dataOffset;  // max that will fit
            dataLength = dataLength & ~3;       // round down to longword

        }

    }

    //
    // Finish filling in the response parameters.
    //

    if ( ntTransaction) {
        SmbPutUlong( &ntResponse->ParameterCount, paramLength );
        SmbPutUlong( &ntResponse->ParameterOffset, paramOffset );
        SmbPutUlong( &ntResponse->ParameterDisplacement, paramDisp );

        SmbPutUlong( &ntResponse->DataCount, dataLength );
        SmbPutUlong( &ntResponse->DataOffset, dataOffset );
        SmbPutUlong( &ntResponse->DataDisplacement, dataDisp );
    } else {
        SmbPutUshort( &response->ParameterCount, (USHORT)paramLength );
        SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
        SmbPutUshort( &response->ParameterDisplacement, (USHORT)paramDisp );

        SmbPutUshort( &response->DataCount, (USHORT)dataLength );
        SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
        SmbPutUshort( &response->DataDisplacement, (USHORT)dataDisp );
    }

    transaction->ParameterDisplacement = paramDisp + paramLength;
    transaction->DataDisplacement = dataDisp + dataLength;

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Copy the appropriate parameter and data bytes into the message.
    //
    // !!! Note that it would be possible to use the chain send
    //     capabilities of TDI to send the parameter and data bytes from
    //     their own buffers.  There is extra overhead involved in doing
    //     this, however, because the buffers must be locked down and
    //     mapped into system space so that the network drivers can look
    //     at them.
    //

    if ( paramLength != 0 ) {
        RtlMoveMemory(
            paramPtr,
            transaction->OutParameters + paramDisp,
            paramLength
            );
    }

    if ( dataLength != 0 ) {
        RtlMoveMemory(
            dataPtr,
            transaction->OutData + dataDisp,
            dataLength
            );
    }

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // If this is the last part of the response, reenable statistics
    // gathering and restore the start time to the work context block.
    //

    if ( ((paramLength + paramDisp) == transaction->ParameterCount) &&
         ((dataLength + dataDisp) == transaction->DataCount) ) {

        //
        // This is the final piece. Close the transaction.
        //

        WorkContext->StartTime = transaction->StartTime;

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );


    } else {

        // If this isn't the last part of the response, tell TDI that we
        // do not expect back traffic, so that the client will immediately
        // ACK this packet, rather than waiting.

        WorkContext->ResponseBuffer->Mdl->ByteCount = sendLength;

        //
        // Send out the response.  When the send completes,
        // RestartTransactionResponse is called to either send the next
        // message or close the transaction.
        //
        // Note that the response bit in the SMB header is already set.
        //

        SRV_START_SEND(
            WorkContext,
            WorkContext->ResponseBuffer->Mdl,
            TDI_SEND_NO_RESPONSE_EXPECTED,
            SrvQueueWorkToFspAtSendCompletion,
            NULL,
            RestartTransactionResponse
            );
    }

    //
    // The response send is in progress.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactionResponse complete\n" );
    return;

} // RestartTransactionResponse


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransaction (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a primary Transaction or Transaction2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PREQ_TRANSACTION request;
    PSMB_HEADER header;

    PCONNECTION connection;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PTRANSACTION transaction;
    PCHAR trailingBytes;
    PCHAR startOfTrailingBytes;
    PVOID name;
    PVOID endOfSmb;

    CLONG setupOffset;
    CLONG setupCount;
    CLONG maxSetupCount;
    CLONG totalSetupCount;
    CLONG parameterOffset;
    CLONG parameterCount;       // For input on this buffer
    CLONG maxParameterCount;    // For output
    CLONG totalParameterCount;  // For input
    CLONG dataOffset;
    CLONG dataCount;            // For input on this buffer
    CLONG maxDataCount;         // For output
    CLONG totalDataCount;       // For input
    CLONG smbLength;

    CLONG outputBufferSize = (CLONG)-1;
    CLONG inputBufferSize = (CLONG)-1;
    CLONG requiredBufferSize;

    USHORT command;

    BOOLEAN pipeRequest;
    BOOLEAN remoteApiRequest;
    BOOLEAN buffersOverlap = FALSE;
    BOOLEAN noResponse;
    BOOLEAN singleBufferTransaction;
    BOOLEAN isUnicode;


    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;
    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Transaction%s (primary) request\n",
                    (WorkContext->NextCommand == SMB_COM_TRANSACTION)
                    ? "" : "2" );
    }

    //
    // Make sure that the WordCount is correct to avoid any problems
    // with overrunning the SMB buffer.  SrvProcessSmb was unable to
    // verify WordCount because it is variable, but it did verify that
    // the supplied WordCount/ByteCount combination was valid.
    // Verifying WordCount here ensure that what SrvProcessSmb thought
    // was ByteCount really was, and that it's valid.  The test here
    // also implicit verifies SetupCount and that all of the setup words
    // are "in range".
    //

    if ( (ULONG)request->WordCount != (ULONG)(14 + request->SetupCount) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint3( "SrvSmbTransaction: Invalid WordCount: %ld, should be "
                      "SetupCount+14 = %ld+14 = %ld\n",
                      request->WordCount, request->SetupCount,
                      14 + request->SetupCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Even though we know that WordCount and ByteCount are valid, it's
    // still possible that the offsets and lengths of the Parameter and
    // Data bytes are invalid.  So we check them now.
    //

    setupOffset = PTR_DIFF(request->Buffer, header);
    setupCount = request->SetupCount * sizeof(USHORT);
    maxSetupCount = request->MaxSetupCount * sizeof(USHORT);
    totalSetupCount = setupCount;

    parameterOffset = SmbGetUshort( &request->ParameterOffset );
    parameterCount = SmbGetUshort( &request->ParameterCount );
    maxParameterCount = SmbGetUshort( &request->MaxParameterCount );
    totalParameterCount = SmbGetUshort( &request->TotalParameterCount );

    dataOffset = SmbGetUshort( &request->DataOffset );
    dataCount = SmbGetUshort( &request->DataCount );
    maxDataCount = SmbGetUshort( &request->MaxDataCount );
    totalDataCount = SmbGetUshort( &request->TotalDataCount );

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( (setupOffset + setupCount) > smbLength ) ||
         ( (parameterOffset + parameterCount) > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( dataCount > totalDataCount ) ||
         ( parameterCount > totalParameterCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransaction: Invalid setup, parameter or data "
                      "offset+count: sOff=%ld,sCnt=%ld;pOff=%ld,pCnt=%ld;",
                      setupOffset, setupCount,
                      parameterOffset, parameterCount );
            SrvPrint2( "dOff=%ld,dCnt=%ld;", dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    singleBufferTransaction = (dataCount == totalDataCount) &&
                              (parameterCount == totalParameterCount);

    //
    // Should we return a final response?  If this is not a single buffer
    // transaction, we need to return an interim response regardless of the
    // no response flag.
    //

    noResponse = singleBufferTransaction &&
                    ((SmbGetUshort( &request->Flags ) &
                     SMB_TRANSACTION_NO_RESPONSE) != 0);

    //
    // Calculate buffer sizes.
    //
    // First determine whether this is a named pipe, LanMan RPC, or
    // mailslot transaction.  We avoid checking the transaction name
    // ("\PIPE\" or "\MAILSLOT\") by recognizing that Transaction SMB
    // must be one of the three, and that a mailslot write must have a
    // setup count of 3 (words) and command code of
    // TRANS_MAILSLOT_WRITE, and that a LanMan RPC must have a setup
    // count of 0.
    //

    command = SmbGetUshort( (PSMB_USHORT)&request->Buffer[0] );

    name = StrNull;
    endOfSmb = NULL;
    isUnicode = TRUE;

    ASSERT( TRANS_SET_NMPIPE_STATE == TRANS_MAILSLOT_WRITE );

    pipeRequest = (BOOLEAN)( (WorkContext->NextCommand == SMB_COM_TRANSACTION)
                             &&
                             ( (setupCount != 6) ||
                               ( (setupCount == 6) &&
                                 (command != TRANS_MAILSLOT_WRITE) ) ) );

    remoteApiRequest = (BOOLEAN)(pipeRequest && (setupCount == 0) );

    if ( pipeRequest && !remoteApiRequest ) {

        //
        // Step 1.  Have we received all of the input data and parameters?
        //
        // If so, we can generate the input buffers directly from the SMB
        // buffer.
        //
        // If not, then we must copy all of the pieces to a single buffer
        // which will are about to allocate.  Both parameters and data
        // must be dword aligned.
        //

        if ( singleBufferTransaction ) {

            SMB_STATUS smbStatus;

            //
            // If this is a single buffer transact named pipe request, try
            // the server fast path.
            //

            if ( (command == TRANS_TRANSACT_NMPIPE) &&
                 SrvFastTransactNamedPipe( WorkContext, &smbStatus ) ) {
                SmbStatus =smbStatus;
                goto Cleanup;
            }

            inputBufferSize = 0;
        } else {
            inputBufferSize = ((totalSetupCount * sizeof(UCHAR) + 3) & ~3) +
                              ((totalDataCount * sizeof(UCHAR) + 3) & ~3) +
                              ((totalParameterCount * sizeof(UCHAR) + 3) & ~3);
        }

        //
        // If a session block has not already been assigned to the current
        // work context, verify the UID.  If verified, the address of the
        // session block corresponding to this user is stored in the
        // WorkContext block and the session block is referenced.
        //
        // If a tree connect block has not already been assigned to the
        // current work context, find the tree connect corresponding to the
        // given TID.
        //

        status = SrvVerifyUidAndTid(
                    WorkContext,
                    &session,
                    &treeConnect,
                    ShareTypeWild
                    );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbTransaction: Invalid UID or TID\n" );
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = noResponse ? SmbStatusNoResponse
                                   : SmbStatusSendResponse;
            goto Cleanup;
        }

        if( session->IsSessionExpired )
        {
            status = SESSION_EXPIRED_STATUS_CODE;
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Step 2. Can all the output data and paramter fit in the SMB
        // buffer?  If so then we do not need to allocate extra space.
        //

        //
        // Special case.  If this is a PEEK_NMPIPE call, then allocate
        // at least enough parameter bytes for the NT call.
        //
        // Since the SMB request normally asks for 6 parameter bytes,
        // and NT NPFS will return 16 parameter bytes, this allows us
        // to read the data and parameters directly from the NT call
        // into the transaction buffer.
        //
        // At completion time, we will reformat the paramters, but if
        // the data is read directly into the SMB buffer, there will
        // be no need to recopy it.
        //

        if ( command == TRANS_PEEK_NMPIPE) {
            maxParameterCount = MAX(
                                    maxParameterCount,
                                    4 * sizeof(ULONG)
                                    );
        }

        outputBufferSize = ((maxParameterCount * sizeof(CHAR) + 3) & ~3) +
                           ((maxDataCount * sizeof(CHAR) + 3) & ~3);

        if ( sizeof(SMB_HEADER) +
                sizeof (RESP_TRANSACTION) +
                sizeof(USHORT) * request->SetupCount +
                sizeof(USHORT) +
                outputBufferSize
                        <= (ULONG)session->MaxBufferSize) {
            outputBufferSize = 0;
        }

        //
        // Since input and output data and parameters can overlap, just
        // allocate a buffer big enough for the biggest possible buffer.
        //

        requiredBufferSize = MAX( inputBufferSize, outputBufferSize );

        //
        // If this is a call or wait named pipe operation, we need to
        // keep the pipe name in the transaction block.
        //

        if ( (command == TRANS_CALL_NMPIPE) ||
             (command == TRANS_WAIT_NMPIPE) ) {
            isUnicode = SMB_IS_UNICODE( WorkContext );
            name = ((PUSHORT)(&request->WordCount + 1) +
                                                    request->WordCount + 1);
            if ( isUnicode ) {
                name = ALIGN_SMB_WSTR( name );
            }
            endOfSmb = END_OF_REQUEST_SMB( WorkContext );
        }

        //
        // This is a named pipe transaction.  Input and output buffers
        // can safely overlap.
        //

        buffersOverlap = TRUE;

    } else {

        //
        // If a session block has not already been assigned to the current
        // work context, verify the UID.  If verified, the address of the
        // session block corresponding to this user is stored in the
        // WorkContext block and the session block is referenced.
        //
        // If a tree connect block has not already been assigned to the
        // current work context, find the tree connect corresponding to the
        // given TID.
        //

        status = SrvVerifyUidAndTid(
                    WorkContext,
                    &session,
                    &treeConnect,
                    ShareTypeWild
                    );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbTransaction: Invalid UID or TID\n" );
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = noResponse ? SmbStatusNoResponse
                                   : SmbStatusSendResponse;
            goto Cleanup;
        }

        if( session->IsSessionExpired )
        {
            status = SESSION_EXPIRED_STATUS_CODE;
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // This is a Transaction2 call or a mailslot or LanMan RPC
        // Transaction call.  Don't assume anything about the buffers.
        //
        // !!! It should be possible to be smarter about buffer space
        //     on Trans2 SMBs.  We should be able to overlap input
        //     and output as well as avoiding copies to and from
        //     the SMB buffer.
        //

        requiredBufferSize =
            ((totalSetupCount + 3) & ~3) + ((maxSetupCount + 3) & ~3) +
            ((totalParameterCount + 3) & ~3) + ((maxParameterCount + 3) & ~3) +
            ((totalDataCount + 3) & ~3) + ((maxDataCount + 3) & ~3);

        //
        // If this is a remote API request, check whether we have
        // initialized the connection with XACTSRV.
        //

        if ( remoteApiRequest ) {

            if ( SrvXsPortMemoryHeap == NULL ) {

                //
                // XACTSRV is not started.  Reject the request.
                //

                IF_DEBUG(ERRORS) {
                    SrvPrint0( "SrvSmbTransaction: The XACTSRV service is not started.\n" );
                }

                SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
                status    = STATUS_NOT_SUPPORTED;
                SmbStatus = noResponse ? SmbStatusNoResponse
                                       : SmbStatusSendResponse;
                goto Cleanup;
            }

        } else if ( WorkContext->NextCommand == SMB_COM_TRANSACTION ) {

            //
            // We need to save the transaction name for mailslot writes.
            //

            isUnicode = SMB_IS_UNICODE( WorkContext );
            name = ((PUSHORT)(&request->WordCount + 1) +
                                                    request->WordCount + 1);
            if ( isUnicode ) {
                name = ALIGN_SMB_WSTR( name );
            }
            endOfSmb = END_OF_REQUEST_SMB( WorkContext );

        }

    }

    //
    // If there is a transaction secondary buffer on the way, ensure
    // that we have a free work item to receive it.  Otherwise fail
    // this SMB with an out of resources error.
    //

    if  ( !singleBufferTransaction ) {

        if ( SrvReceiveBufferShortage( ) ) {

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = noResponse ? SmbStatusNoResponse
                                   : SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    //
    // Allocate a transaction block.  This block is used to retain
    // information about the state of the transaction.  This is
    // necessary because multiple SMBs are potentially sent and
    // received.
    //

    connection = WorkContext->Connection;

    SrvAllocateTransaction(
        &transaction,
        (PVOID *)&trailingBytes,
        connection,
        requiredBufferSize,
        name,
        endOfSmb,
        isUnicode,
        remoteApiRequest
        );

    if ( transaction == NULL ) {

        //
        // Unable to allocate transaction.  Return an error to the
        // client.  (The session and tree connect blocks are
        // dereferenced automatically.)
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "Unable to allocate transaction\n" );
        }

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = noResponse ? SmbStatusNoResponse : SmbStatusSendResponse;
        goto Cleanup;
    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Allocated transaction 0x%p\n", transaction );
    }

    transaction->PipeRequest = pipeRequest;

    //
    // Save the connection, session, and tree connect pointers in the
    // transaction block.  If this transaction will NOT require multiple
    // SMB exchanges, the session and tree connect pointers are not
    // referenced pointers, because the work context block's pointers
    // will remain valid for the duration of the transaction.
    //

    transaction->Connection = connection;
    SrvReferenceConnection( connection );

    if ( session != NULL ) {

        transaction->Session = session;
        transaction->TreeConnect = treeConnect;

        if ( requiredBufferSize != 0 ) {
            SrvReferenceSession( session );
            SrvReferenceTreeConnect( treeConnect );
        }

    } else {
        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "SrvSmbTransaction - Session Setup: skipping session and tree connect reference.\n" );
        }
    }

    //
    // Save the TID, PID, UID, and MID from this request in the
    // transaction block.  These values are used to relate secondary
    // requests to the appropriate primary request.
    //

    transaction->Tid = SmbGetAlignedUshort( &header->Tid );
    transaction->Pid = SmbGetAlignedUshort( &header->Pid );
    transaction->Uid = SmbGetAlignedUshort( &header->Uid );
    transaction->OtherInfo = SmbGetAlignedUshort( &header->Mid );

    //
    // Save the time that the initial request SMB arrived, for use in
    // calculating the elapsed time for the entire transaction.
    //

    transaction->StartTime = WorkContext->StartTime;

    //
    // Save other sundry information, but don't load the ParameterCount
    // and DataCount fields until after copying the data.  This is to
    // prevent the reception of a secondary request prior to our
    // completion here from causing the transaction to be executed
    // twice.  (These fields are initialized to 0 during allocation.)
    //

    transaction->Timeout = SmbGetUlong( &request->Timeout );
    transaction->Flags = SmbGetUshort( &request->Flags );

    transaction->SetupCount = totalSetupCount;
    transaction->MaxSetupCount = maxSetupCount;

    transaction->TotalParameterCount = totalParameterCount;
    transaction->MaxParameterCount = maxParameterCount;

    transaction->TotalDataCount = totalDataCount;
    transaction->MaxDataCount = maxDataCount;

    startOfTrailingBytes = trailingBytes;

    //
    // Calculate the addresses of the various buffers.
    //

    if ( inputBufferSize != 0 ) {

        //
        // Input setup, parameters and data will be copied to a separate
        // buffer.
        //

        transaction->InSetup = (PSMB_USHORT)trailingBytes;
        trailingBytes += (totalSetupCount + 3) & ~3;

        transaction->InParameters = (PCHAR)trailingBytes;
        trailingBytes += (totalParameterCount + 3) & ~3;

        transaction->InData = (PCHAR)trailingBytes;
        trailingBytes += (totalDataCount + 3) & ~3;

        transaction->InputBufferCopied = TRUE;

    } else {

        //
        // Input parameters and data will be sent directly out of the
        // request buffer.
        //

        transaction->InSetup = (PSMB_USHORT)( (PCHAR)header + setupOffset );
        transaction->InParameters = (PCHAR)header + parameterOffset;
        transaction->InData = (PCHAR)header + dataOffset;
        transaction->InputBufferCopied = FALSE;
    }

    //
    // Setup the output data pointers.
    //

    transaction->OutSetup = (PSMB_USHORT)NULL;

    if ( buffersOverlap ) {

        //
        // The output buffer overlaps the input buffer.
        //

        trailingBytes = startOfTrailingBytes;
    }

    if ( outputBufferSize != 0 ) {

        //
        // The output is going into a separate buffer, to be copied
        // later into the response SMB buffer.
        //

        transaction->OutParameters = (PCHAR)trailingBytes;
        trailingBytes += (maxParameterCount + 3) & ~3;

        transaction->OutData = (PCHAR)trailingBytes;

        transaction->OutputBufferCopied = TRUE;

    } else {

        //
        // The data (and parameters) will be going into the response
        // SMB buffer, which may not be the one we are currently
        // processing.  So temporarily set these pointers to NULL.  The
        // correct pointers will be calculated at ExecuteTransaction time.
        //

        transaction->OutParameters = NULL;
        transaction->OutData = NULL;
        transaction->OutputBufferCopied = FALSE;
    }

    //
    // If this transaction will require multiple SMB exchanges, link the
    // transaction block into the connection's pending transaction list.
    // This will fail if there is already a transaction with the same
    // xID values in the list.
    //
    // !!! Need a way to prevent the transaction list from becoming
    //     clogged with pending transactions.
    //

    if ( (requiredBufferSize != 0) && !SrvInsertTransaction( transaction ) ) {

        //
        // A transaction with the same xIDs is already in progress.
        // Return an error to the client.
        //
        // *** Note that SrvDereferenceTransaction can't be used here
        //     because that routine assumes that the transaction is
        //     queued to the transaction list.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Duplicate transaction exists\n" );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvDereferenceSession( session );
        DEBUG transaction->Session = NULL;

        SrvDereferenceTreeConnect( treeConnect );
        DEBUG transaction->TreeConnect = NULL;

        SrvFreeTransaction( transaction );

        SrvDereferenceConnection( connection );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = noResponse ? SmbStatusNoResponse : SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Copy the setup, parameter and data bytes that arrived in the
    // primary SMB.
    //
    // !!! We could allow secondary requests to start by allocating a
    //     separate buffer for the interim response, sending the
    //     response, then copying the data.
    //

    if ( inputBufferSize != 0 ) {

        if ( setupCount != 0 ) {
            RtlMoveMemory(
                (PVOID)transaction->InSetup,
                (PCHAR)header + setupOffset,
                setupCount
                );
        }

        //
        // We can now check to see if we are doing a session setup trans2
        //

        if ( session == NULL ) {

            IF_SMB_DEBUG(TRANSACTION1) {
                SrvPrint0( "SrvSmbTransaction - Receiving a Session setup SMB\n");
            }
        }

        if ( parameterCount != 0 ) {
            RtlMoveMemory(
                transaction->InParameters,
                (PCHAR)header + parameterOffset,
                parameterCount
                );
        }

        if ( dataCount != 0 ) {
            RtlMoveMemory(
                transaction->InData,
                (PCHAR)header + dataOffset,
                dataCount
                );
        }

    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute it.  Otherwise, send
    // an interim response.
    //

    transaction->ParameterCount = parameterCount;
    transaction->DataCount = dataCount;

    if ( singleBufferTransaction ) {

        //
        // All of the data has arrived.  Execute the transaction.  When
        // ExecuteTransaction returns, the first (possibly only)
        // response, if any, has been sent.  Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        //
        // Not all of the data has arrived.  We have already queued the
        // transaction to the connection's transaction list.  We need to
        // send an interim response telling the client to send the
        // remaining data.  We also need to dereference the transaction
        // block, since we'll no longer have a pointer to it.
        //

        PRESP_TRANSACTION_INTERIM response;

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "More transaction data expected.\n" );
        }

        ASSERT( transaction->Inserted );
        SrvDereferenceTransaction( transaction );

        response = (PRESP_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_TRANSACTION_INTERIM,
                                            0
                                            );
        //
        // Inhibit statistics gathering -- this isn't the end of the
        // transaction.
        //

        WorkContext->StartTime = 0;

        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    return SmbStatus;

} // SrvSmbTransaction


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a secondary Transaction or Transaction2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_TRANSACTION_SECONDARY request;
    PSMB_HEADER header;

    PTRANSACTION transaction;
    PCONNECTION connection;

    CLONG parameterOffset;
    CLONG parameterCount;
    CLONG parameterDisplacement;
    CLONG dataOffset;
    CLONG dataCount;
    CLONG dataDisplacement;
    CLONG smbLength;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION_SECONDARY)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Transaction%s (secondary) request\n",
                    (WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY)
                    ? "" : "2" );
    }

    //
    // Find the transaction block that matches this secondary request.
    // The TID, PID, UID, and MID in the headers of all messages in
    // a transaction are the same.  If a match is found, it is
    // referenced to prevent its deletion and its address is returned.
    //

    connection = WorkContext->Connection;

    transaction = SrvFindTransaction( connection, header, 0 );

    if ( transaction == NULL ) {

        //
        // Unable to find a matching transaction.  Ignore this SMB.
        //
        // !!! Is this the right thing to do?  It's what PIA does.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "No matching transaction.  Ignoring request.\n" );
        }
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    ASSERT( transaction->Connection == connection );

    if( transaction->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Ensure that the transaction isn't already complete.
    //     That is, that this is not a message accidentally added to a
    //     transaction that's already being executed.
    //


#if 0
    // !!! Apparently we don't get any secondary request on remote
    //     APIs, because this little piece of code causes an infinite
    //     loop because it doesn't check to see if it's already in a
    //     blocking thread.  And it's been here for 2-1/2 years!
    //     Besides, we don't do primary remote APIs in blocking threads,
    //     so why do secondaries?
    //
    // If this is a remote API request, send it off to a blocking thread
    // since it is possible for the operation to take a long time.
    //

    if ( transaction->RemoteApiRequest ) {

        DEBUG WorkContext->FsdRestartRoutine = NULL;
        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;

        SrvQueueWorkToBlockingThread( WorkContext );
        SrvDereferenceTransaction( transaction );

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }
#endif

    //
    // Unlike the Transaction[2] SMB, the Transaction[2] Secondary SMB
    // has a fixed WordCount, so SrvProcessSmb has already verified it.
    // But it's still possible that the offsets and lengths of the
    // Parameter and Data bytes are invalid.  So we check them now.
    //

    parameterOffset = SmbGetUshort( &request->ParameterOffset );
    parameterCount = SmbGetUshort( &request->ParameterCount );
    parameterDisplacement = SmbGetUshort( &request->ParameterDisplacement );
    dataOffset = SmbGetUshort( &request->DataOffset );
    dataCount = SmbGetUshort( &request->DataCount );
    dataDisplacement = SmbGetUshort( &request->DataDisplacement );

    //
    // See if this is a special ack by the client to tell us to send
    // the next piece of a multipiece response.
    //

    if ( transaction->MultipieceIpxSend ) {

        ASSERT( WorkContext->Endpoint->IsConnectionless );

        if ( (parameterCount == 0) && (parameterOffset == 0) &&
             (dataCount == 0) && (dataOffset == 0)) {

            //
            // got the ACK. Make sure the displacement numbers are reasonable.
            //

            if ( (dataDisplacement > transaction->DataCount) ||
                 (parameterDisplacement > transaction->ParameterCount) ) {

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint2( "SrvSmbTransactionSecondary: Invalid parameter or data "
                              "displacement: pDisp=%ld ;dDisp=%ld",
                              parameterDisplacement, dataDisplacement );
                }

                goto invalid_smb;
            }

            transaction->DataDisplacement = dataDisplacement;
            transaction->ParameterDisplacement = parameterDisplacement;

            WorkContext->Parameters.Transaction = transaction;

            //
            // Change the secondary command code to the primary code.
            //

            WorkContext->NextCommand--;
            header->Command = WorkContext->NextCommand;

            RestartIpxTransactionResponse( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        } else {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint4( "SrvSmbTransactionSecondary: Invalid parameter or data "
                          "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                          parameterOffset, parameterCount,
                          dataOffset, dataCount );
                SrvPrint0("Should be all zeros.\n");
            }

            goto invalid_smb;
        }
    }

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( (parameterOffset + parameterCount) > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength )  ||
         ( (parameterCount + parameterDisplacement ) >
             transaction->TotalParameterCount ) ||
         ( (dataCount + dataDisplacement ) > transaction->TotalDataCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransactionSecondary: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                      parameterOffset, parameterCount,
                      dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        goto invalid_smb;
    }

    ACQUIRE_LOCK( &connection->Lock );

    if( transaction->Executing == TRUE ) {
        RELEASE_LOCK( &connection->Lock );
        IF_DEBUG(ERRORS) {
            SrvPrint0( "Transaction already executing.  Ignoring request.\n" );
        }
        goto invalid_smb;
    }

    //
    // Copy the parameter and data bytes that arrived in this SMB.  We do
    //  this while we hold the resource to ensure that we don't copy memory
    //  into the buffer if somebody sends us an extra secondary transaction.
    //
    if ( parameterCount != 0 ) {
        RtlMoveMemory(
            transaction->InParameters + parameterDisplacement,
            (PCHAR)header + parameterOffset,
            parameterCount
            );
    }

    if ( dataCount != 0 ) {
        RtlMoveMemory(
            transaction->InData + dataDisplacement,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute the transaction.  We
    // check for the unlikely case of the transaction having been
    // aborted in the short amount of time since we verified that it was
    // on the transaction list.
    //
    // *** This is all done under a lock in order to prevent the arrival
    //     of another secondary request (which could very easily happen)
    //     from interfering with our processing.  Only one arrival can
    //     be allowed to actually update the counters such that they
    //     match the expected data size.
    //


    if ( GET_BLOCK_STATE(transaction) != BlockStateActive ) {

        RELEASE_LOCK( &connection->Lock );

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Transaction closing.  Ignoring request.\n" );
        }
        SrvDereferenceTransaction( transaction );

        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    transaction->ParameterCount += parameterCount;
    transaction->DataCount += dataCount;

    if ( (transaction->DataCount == transaction->TotalDataCount) &&
         (transaction->ParameterCount == transaction->TotalParameterCount) ) {

        //
        // All of the data has arrived.  Prepare to execute the
        // transaction.  Reference the tree connect and session blocks,
        // saving pointers in the work context block.  Note that even
        // though the transaction block already references these blocks,
        // we store pointers to them in the work context block so that
        // common support routines only have to look there to find their
        // pointers.
        //

        WorkContext->Session = transaction->Session;
        SrvReferenceSession( transaction->Session );

        WorkContext->TreeConnect = transaction->TreeConnect;
        SrvReferenceTreeConnect( transaction->TreeConnect );

        transaction->Executing = TRUE;

        RELEASE_LOCK( &connection->Lock );

        //
        // Execute the transaction.  When ExecuteTransaction returns,
        // the first (possibly only) response, if any, has been sent.
        // Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        RELEASE_LOCK( &connection->Lock );

        //
        // Not all of the data has arrived.  Leave the transaction on
        // the list, and don't send a response.  Dereference the
        // transaction block, since we'll no longer have a pointer to
        // it.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "More transaction data expected.\n" );
        }

        SrvDereferenceTransaction( transaction );

        //
        // We do things differently when we are directly using ipx.
        //

        if ( WorkContext->Endpoint->IsConnectionless ) {

            //
            // Send a go-ahead response.
            //

            PRESP_TRANSACTION_INTERIM response;

            response = (PRESP_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
            response->WordCount = 0;
            SmbPutUshort( &response->ByteCount, 0 );
            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                response,
                                                RESP_TRANSACTION_INTERIM,
                                                0
                                                );
            //
            // Inhibit statistics gathering -- this isn't the end of the
            // transaction.
            //

            WorkContext->StartTime = 0;

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {
            SmbStatus = SmbStatusNoResponse;
            goto Cleanup;
        }
    }

invalid_smb:
    SrvDereferenceTransaction( transaction );
    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
    status    = STATUS_INVALID_SMB;
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    return SmbStatus;
} // SrvSmbTransactionSecondary


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransaction (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a primary NT Transaction SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PREQ_NT_TRANSACTION request;
    PSMB_HEADER header;

    PCONNECTION connection;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PTRANSACTION transaction;
    PCHAR trailingBytes;

    CLONG parameterOffset;
    CLONG parameterCount;       // For input on this buffer
    CLONG maxParameterCount;    // For output
    CLONG totalParameterCount;  // For input
    CLONG dataOffset;
    CLONG dataCount;            // For input on this buffer
    CLONG maxDataCount;         // For output
    CLONG totalDataCount;       // For input
    CLONG smbLength;

    CLONG requiredBufferSize;

    CLONG parameterLength;      // MAX of input and output param length

    BOOLEAN singleBufferTransaction;

    PAGED_CODE( );

    request = (PREQ_NT_TRANSACTION)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint0( "NT Transaction (primary) request\n" );
    }

    //
    // Make sure that the WordCount is correct to avoid any problems
    // with overrunning the SMB buffer.  SrvProcessSmb was unable to
    // verify WordCount because it is variable, but it did verify that
    // the supplied WordCount/ByteCount combination was valid.
    // Verifying WordCount here ensure that what SrvProcessSmb thought
    // was ByteCount really was, and that it's valid.  The test here
    // also implicit verifies SetupCount and that all of the setup words
    // are "in range".
    //

    if ( (ULONG)request->WordCount != (ULONG)(19 + request->SetupCount) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint3( "SrvSmbTransaction: Invalid WordCount: %ld, should be "
                      "SetupCount+19 = %ld+14 = %ld\n",
                      request->WordCount, request->SetupCount,
                      19 + request->SetupCount );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Even though we know that WordCount and ByteCount are valid, it's
    // still possible that the offsets and lengths of the Parameter and
    // Data bytes are invalid.  So we check them now.
    //

    parameterOffset = request->ParameterOffset;
    parameterCount = request->ParameterCount;
    maxParameterCount = request->MaxParameterCount;
    totalParameterCount = request->TotalParameterCount;

    dataOffset = request->DataOffset;
    dataCount = request->DataCount;
    maxDataCount = request->MaxDataCount;
    totalDataCount = request->TotalDataCount;

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( parameterOffset > smbLength ) ||
         ( parameterCount > smbLength ) ||
         ( (parameterOffset + parameterCount) > smbLength ) ||
         ( dataOffset > smbLength ) ||
         ( dataCount > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( dataCount > totalDataCount ) ||
         ( parameterCount > totalParameterCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransaction: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                      parameterOffset, parameterCount,
                      dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Ensure the client isn't asking for more data than we are willing
    //  to deal with
    //
    if( ( totalParameterCount > SrvMaxNtTransactionSize) ||
        ( totalDataCount > SrvMaxNtTransactionSize ) ||
        ( (totalParameterCount + totalDataCount) > SrvMaxNtTransactionSize) ||
        ( maxParameterCount > SrvMaxNtTransactionSize ) ||
        ( maxDataCount > SrvMaxNtTransactionSize ) ||
        ( (maxParameterCount + maxDataCount) > SrvMaxNtTransactionSize ) ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_BUFFER_SIZE );
        status    = STATUS_INVALID_BUFFER_SIZE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    singleBufferTransaction = (dataCount == totalDataCount) &&
                              (parameterCount == totalParameterCount);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // If a tree connect block has not already been assigned to the
    // current work context, find the tree connect corresponding to the
    // given TID.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbNtTransaction: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is a transaction secondary buffer on the way, ensure
    // that we have a free work item to receive it.  Otherwise fail
    // this SMB with an out of resources error.
    //

    if  ( !singleBufferTransaction ) {

        if ( SrvReceiveBufferShortage( ) ) {

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    //
    // Calculate buffer sizes.
    //
    // Input and output parameter buffers overlap.
    // Input and output data buffers overlap.
    //

    //
    // !!! It should be possible to be smarter about buffer space
    //     on NT Transaction SMBs.  We should be able to avoid
    //     copies to and from the SMB buffer.
    //

    parameterLength =
        MAX( ( (request->TotalParameterCount + 7) & ~7),
             ( (request->MaxParameterCount + 7) & ~7));

    requiredBufferSize = parameterLength +
        MAX( ( (request->TotalDataCount + 7) & ~7),
             ( (request->MaxDataCount + 7) & ~7) );

    if( !singleBufferTransaction ) {
        requiredBufferSize += (((request->SetupCount * sizeof(USHORT)) + 7 ) & ~7);
    }

    //
    // We will later quad-word align input buffer for OFS query
    // FSCTL since they are using MIDL to generate there marshalling
    // (pickling). For this reason, we have to bump up our requiredBufferSize
    // by 8 bytes (because the subsequent quad align might go up by as many
    // as 7 bytes. 8 looks like a better number to use.
    //
    // While OFS is long gone, we now always quad-align the buffer for the 64-bit case,
    // and for 32-bit transactions that require LARGE_INTEGER alignment.
    requiredBufferSize += 8;

    //
    // Allocate a transaction block.  This block is used to retain
    // information about the state of the transaction.  This is
    // necessary because multiple SMBs are potentially sent and
    // received.
    //

    connection = WorkContext->Connection;

    SrvAllocateTransaction(
        &transaction,
        (PVOID *)&trailingBytes,
        connection,
        requiredBufferSize,
        StrNull,
        NULL,
        TRUE,
        FALSE   // This is not a remote API
        );

    if ( transaction == NULL ) {

        //
        // Unable to allocate transaction.  Return an error to the
        // client.  (The session and tree connect blocks are
        // dereferenced automatically.)
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "Unable to allocate transaction\n" );
        }

        if( requiredBufferSize > MAX_TRANSACTION_TAIL_SIZE )
        {
            SrvSetSmbError( WorkContext, STATUS_INVALID_BUFFER_SIZE );
            status    = STATUS_INVALID_BUFFER_SIZE;
        }
        else
        {
            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
        }
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Allocated transaction 0x%p\n", transaction );
    }

    //
    // Save the connection, session, and tree connect pointers in the
    // transaction block.  These are referenced pointers to prevent the
    // blocks from being deleted while the transaction is pending.
    //

    SrvReferenceConnection( connection );
    transaction->Connection = connection;

    SrvReferenceSession( session );
    transaction->Session = session;

    SrvReferenceTreeConnect( treeConnect );
    transaction->TreeConnect = treeConnect;

    //
    // Save the TID, PID, UID, and MID from this request in the
    // transaction block.  These values are used to relate secondary
    // requests to the appropriate primary request.
    //

    transaction->Tid = SmbGetAlignedUshort( &header->Tid );
    transaction->Pid = SmbGetAlignedUshort( &header->Pid );
    transaction->Uid = SmbGetAlignedUshort( &header->Uid );
    transaction->OtherInfo = SmbGetAlignedUshort( &header->Mid );

    //
    // Save the time that the initial request SMB arrived, for use in
    // calculating the elapsed time for the entire transaction.
    //

    transaction->StartTime = WorkContext->StartTime;

    //
    // Save other sundry information, but don't load the ParameterCount
    // and DataCount fields until after copying the data.  This is to
    // prevent the reception of a secondary request prior to our
    // completion here from causing the transaction to be executed
    // twice.  (These fields are initialized to 0 during allocation.)
    //

    transaction->Flags = SmbGetUshort( &request->Flags );
    transaction->Function = SmbGetUshort( &request->Function );

    transaction->SetupCount = request->SetupCount;
    transaction->MaxSetupCount = request->MaxSetupCount;

    transaction->TotalParameterCount = totalParameterCount;
    transaction->MaxParameterCount = maxParameterCount;

    transaction->TotalDataCount = totalDataCount;
    transaction->MaxDataCount = maxDataCount;

    //
    // Calculate the addresses of the various buffers.
    //

    if( singleBufferTransaction ) {
        transaction->InSetup = (PSMB_USHORT)request->Buffer;

    } else {

        if( request->SetupCount ) {
            transaction->InSetup = (PSMB_USHORT)trailingBytes;
            RtlCopyMemory( transaction->InSetup, request->Buffer, request->SetupCount * sizeof(USHORT) );
            trailingBytes += (((request->SetupCount * sizeof(USHORT)) + 7 ) & ~7);
        } else {
            transaction->InSetup = NULL;
        }

    }

    //
    // Input parameters and data will be copied to a separate buffer.
    //

    transaction->InParameters = (PCHAR)trailingBytes;
    trailingBytes += parameterLength;

    // We can always Quad-Align this because we padded the buffer for the OFS queries.
    // This will allow all our 64-bit calls to go through fine, along with our 32-bit ones
    transaction->InData = (PCHAR)ROUND_UP_POINTER(trailingBytes, 8);

    transaction->InputBufferCopied = TRUE;

    //
    // Setup the output data pointers.
    //

    transaction->OutSetup = (PSMB_USHORT)NULL;

    //
    // The output is going into a separate buffer, to be copied
    // later into the response SMB buffer.
    //

    transaction->OutParameters = transaction->InParameters;
    transaction->OutData = transaction->InData;

    transaction->OutputBufferCopied = TRUE;

    //
    // Link the transaction block into the connection's pending
    // transaction list.  This will fail if there is already a
    // tranaction with the same xID values in the list.
    //
    // !!! Need a way to prevent the transaction list from becoming
    //     clogged with pending transactions.
    //
    // *** We can link the block into the list even though we haven't
    //     yet copied the data from the current message into the list
    //     because even if a secondary request arrives before we've done
    //     the copy, only one of us will be the one to find out that all
    //     of the data has arrived.  This is because we update the
    //     counters while we hold a lock.
    //

    if ( !SrvInsertTransaction( transaction ) ) {

        //
        // A transaction with the same xIDs is already in progress.
        // Return an error to the client.
        //
        // *** Note that SrvDereferenceTransaction can't be used here
        //     because that routine assumes that the transaction is
        //     queued to the transaction list.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Duplicate transaction exists\n" );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvDereferenceSession( session );
        DEBUG transaction->Session = NULL;

        SrvDereferenceTreeConnect( treeConnect );
        DEBUG transaction->TreeConnect = NULL;

        SrvFreeTransaction( transaction );

        SrvDereferenceConnection( connection );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Copy the parameter and data bytes that arrived in the primary SMB.
    // There is no need to copy the setup words as they always arrive
    // completely in the primary buffer (unless we have a multipiece transaction)
    //
    // !!! We could allow secondary requests to start by allocating a
    //     separate buffer for the interim response, sending the
    //     response, then copying the data.
    //

    if ( parameterCount != 0 ) {
        RtlMoveMemory(
            transaction->InParameters,
            (PCHAR)header + parameterOffset,
            parameterCount
            );
    }

    if ( dataCount != 0 ) {
        RtlMoveMemory(
            transaction->InData,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute it.  Otherwise, send
    // an interim response.
    //

    transaction->ParameterCount = parameterCount;
    transaction->DataCount = dataCount;

    if ( singleBufferTransaction ) {

        //
        // All of the data has arrived.  Execute the transaction.  When
        // ExecuteTransaction returns, the first (possibly only)
        // response, if any, has been sent.  Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        //
        // Not all of the data has arrived.  We have already queued the
        // transaction to the connection's transaction list.  We need to
        // send an interim response telling the client to send the
        // remaining data.  We also need to dereference the transaction
        // block, since we'll no longer have a pointer to it.
        //

        PRESP_NT_TRANSACTION_INTERIM response;

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "More transaction data expected.\n" );
        }
        ASSERT( transaction->Inserted );
        SrvDereferenceTransaction( transaction );

        response = (PRESP_NT_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_NT_TRANSACTION_INTERIM,
                                            0
                                            );

        //
        // Inhibit statistics gathering -- this isn't the end of the
        // transaction.
        //

        WorkContext->StartTime = 0;

        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    return SmbStatus;
} // SrvSmbNtTransaction


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a secondary Nt Transaction SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_NT_TRANSACTION_SECONDARY request;
    PSMB_HEADER header;

    PTRANSACTION transaction;
    PCONNECTION connection;

    CLONG parameterOffset;
    CLONG parameterCount;
    CLONG parameterDisplacement;
    CLONG dataOffset;
    CLONG dataCount;
    CLONG dataDisplacement;
    CLONG smbLength;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    request = (PREQ_NT_TRANSACTION_SECONDARY)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint0( "Nt Transaction (secondary) request\n" );
    }

    //
    // Find the transaction block that matches this secondary request.
    // The TID, PID, UID, and MID in the headers of all messages in
    // a transaction are the same.  If a match is found, it is
    // referenced to prevent its deletion and its address is returned.
    //

    connection = WorkContext->Connection;

    transaction = SrvFindTransaction( connection, header, 0 );

    if ( transaction == NULL ) {

        //
        // Unable to find a matching transaction.  Ignore this SMB.
        //
        // !!! Is this the right thing to do?  It's what PIA does.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "No matching transaction.  Ignoring request.\n" );
        }

        SrvLogInvalidSmb( WorkContext );
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    ASSERT( transaction->Connection == connection );

    if( transaction->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // !!! Should ensure that the transaction isn't already complete.
    //     That is, that this is not a message accidentally added to a
    //     transaction that's already being executed.  (This is pretty
    //     much impossible to completely prevent, but we should do
    //     something to stop it.)
    //

    //
    // Unlike the NtTransaction SMB, the NtTransaction Secondary SMB
    // has a fixed WordCount, so SrvProcessSmb has already verified it.
    // But it's still possible that the offsets and lengths of the
    // Parameter and Data bytes are invalid.  So we check them now.
    //

    parameterOffset = request->ParameterOffset;
    parameterCount = request->ParameterCount;
    parameterDisplacement = request->ParameterDisplacement;
    dataOffset = request->DataOffset;
    dataCount = request->DataCount;
    dataDisplacement = request->DataDisplacement;

    //
    // See if this is a special ack by the client to tell us to send
    // the next piece of a multipiece response.
    //

    if ( transaction->MultipieceIpxSend ) {

        ASSERT( WorkContext->Endpoint->IsConnectionless );

        if ( (parameterCount == 0) && (parameterOffset == 0) &&
             (dataCount == 0) && (dataOffset == 0)) {

            //
            // got the ACK. Make sure the displacement numbers are reasonable.
            //

            if ( (dataDisplacement > transaction->DataCount) ||
                 (parameterDisplacement > transaction->ParameterCount) ) {

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint2( "SrvSmbNtTransactionSecondary: Invalid parameter or data "
                              "displacement: pDisp=%ld ;dDisp=%ld",
                              parameterDisplacement, dataDisplacement );
                }

                goto invalid_smb;
            }

            transaction->DataDisplacement = dataDisplacement;
            transaction->ParameterDisplacement = parameterDisplacement;

            WorkContext->Parameters.Transaction = transaction;

            //
            // Change the secondary command code to the primary code.
            //

            WorkContext->NextCommand = SMB_COM_NT_TRANSACT;
            header->Command = WorkContext->NextCommand;

            RestartIpxTransactionResponse( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        } else {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint4( "SrvSmbNtTransactionSecondary: Invalid parameter or data "
                          "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                          parameterOffset, parameterCount,
                          dataOffset, dataCount );
                SrvPrint0("Should be all zeros.\n");
            }

            goto invalid_smb;
        }
    }

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( parameterOffset > smbLength ) ||
         ( parameterCount > smbLength ) ||
         ( (parameterOffset + parameterCount) > smbLength ) ||
         ( dataOffset > smbLength ) ||
         ( dataCount > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( parameterCount > transaction->TotalParameterCount ) ||
         ( parameterDisplacement > transaction->TotalParameterCount ) ||
         ( (parameterCount + parameterDisplacement ) > transaction->TotalParameterCount ) ||
         ( dataCount > transaction->TotalDataCount ) ||
         ( dataDisplacement > transaction->TotalDataCount ) ||
         ( (dataCount + dataDisplacement ) > transaction->TotalDataCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransactionSecondary: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                      parameterOffset, parameterCount,
                      dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        goto invalid_smb;
    }

    ACQUIRE_LOCK( &connection->Lock );

    if( transaction->Executing == TRUE ) {
        RELEASE_LOCK( &connection->Lock );
        IF_DEBUG(ERRORS) {
            SrvPrint0( "Transaction already executing.  Ignoring request.\n" );
        }
        goto invalid_smb;
    }

    //
    // Copy the parameter and data bytes that arrived in this SMB.
    //

    if ( parameterCount != 0 ) {
        RtlMoveMemory(
            transaction->InParameters + parameterDisplacement,
            (PCHAR)header + parameterOffset,
            parameterCount
            );
    }

    if ( dataCount != 0 ) {
        RtlMoveMemory(
            transaction->InData + dataDisplacement,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute the transaction.  We
    // check for the unlikely case of the transaction having been
    // aborted in the short amount of time since we verified that it was
    // on the transaction list.
    //
    // *** This is all done under a lock in order to prevent the arrival
    //     of another secondary request (which could very easily happen)
    //     from interfering with our processing.  Only one arrival can
    //     be allowed to actually update the counters such that they
    //     match the expected data size.
    //


    if ( GET_BLOCK_STATE(transaction) != BlockStateActive ) {

        RELEASE_LOCK( &connection->Lock );

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Transaction closing.  Ignoring request.\n" );
        }
        SrvDereferenceTransaction( transaction );

        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    transaction->ParameterCount += parameterCount;
    transaction->DataCount += dataCount;

    if ( (transaction->DataCount == transaction->TotalDataCount) &&
         (transaction->ParameterCount == transaction->TotalParameterCount) ) {

        //
        // All of the data has arrived.  Prepare to execute the
        // transaction.  Reference the tree connect and session blocks,
        // saving pointers in the work context block.  Note that even
        // though the transaction block already references these blocks,
        // we store pointers to them in the work context block so that
        // common support routines only have to look there to find their
        // pointers.
        //

        WorkContext->Session = transaction->Session;
        SrvReferenceSession( transaction->Session );

        WorkContext->TreeConnect = transaction->TreeConnect;
        SrvReferenceTreeConnect( transaction->TreeConnect );

        transaction->Executing = TRUE;

        RELEASE_LOCK( &connection->Lock );

        //
        // Execute the transaction.  When ExecuteTransaction returns,
        // the first (possibly only) response, if any, has been sent.
        // Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        //
        // Not all of the data has arrived.  Leave the transaction on
        // the list, and don't send a response.  Dereference the
        // transaction block, since we'll no longer have a pointer to
        // it.
        //

        RELEASE_LOCK( &connection->Lock );

        SrvDereferenceTransaction( transaction );
        IF_SMB_DEBUG(TRANSACTION1) SrvPrint0( "More data expected.\n" );

        //
        // We do things differently when we are directly using ipx.
        //

        if ( WorkContext->Endpoint->IsConnectionless ) {

            //
            // Send the go-ahead response.
            //

            PRESP_NT_TRANSACTION_INTERIM response;

            response = (PRESP_NT_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
            response->WordCount = 0;
            SmbPutUshort( &response->ByteCount, 0 );
            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                response,
                                                RESP_NT_TRANSACTION_INTERIM,
                                                0
                                                );
            //
            // Inhibit statistics gathering -- this isn't the end of the
            // transaction.
            //

            WorkContext->StartTime = 0;

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {
            SmbStatus = SmbStatusNoResponse;
            goto Cleanup;
        }
    }

invalid_smb:
    SrvDereferenceTransaction( transaction );
    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
    status    = STATUS_INVALID_SMB;
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    return SmbStatus;
} // SrvSmbNtTransactionSecondary


SMB_TRANS_STATUS
MailslotTransaction (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a mailslot transaction.

Arguments:

    WorkContext - Supplies a pointer to a work context block.

Return Value:

    SMB_TRANS_STATUS

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PREQ_TRANSACTION request;
    USHORT command;
    PCHAR name;
    NTSTATUS status;

    HANDLE fileHandle;
    PFILE_OBJECT fileObject;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    OBJECT_HANDLE_INFORMATION handleInformation;
    UNICODE_STRING mailslotPath;
    UNICODE_STRING fullName;

    PAGED_CODE( );

    header = WorkContext->ResponseHeader;
    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    transaction = WorkContext->Parameters.Transaction;

    command = SmbGetUshort( &transaction->InSetup[0] );
    name = (PCHAR)((PUSHORT)(&request->WordCount + 1) +
            request->WordCount + 1);

    //
    // The only legal mailslot transaction is a mailslot write.
    //

    if ( command != TRANS_MAILSLOT_WRITE ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Strip "\MAILSLOT\" prefix from the path string.  Ensure that the
    // name contains more than just "\MAILSLOT\".
    //

    fullName.Buffer = NULL;

    mailslotPath = WorkContext->Parameters.Transaction->TransactionName;

    if ( mailslotPath.Length <=
            (UNICODE_SMB_MAILSLOT_PREFIX_LENGTH + sizeof(WCHAR)) ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    mailslotPath.Length -=
            (UNICODE_SMB_MAILSLOT_PREFIX_LENGTH + sizeof(WCHAR));
    mailslotPath.Buffer +=
            (UNICODE_SMB_MAILSLOT_PREFIX_LENGTH + sizeof(WCHAR))/sizeof(WCHAR);

    SrvAllocateAndBuildPathName(
        &SrvMailslotRootDirectory,
        &mailslotPath,
        NULL,
        &fullName
        );

    if ( fullName.Buffer == NULL ) {

        //
        // Unable to allocate heap for the full name.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "MailslotTransaction: Unable to allocate heap for full path name\n" );
        }

        SrvSetSmbError (WorkContext, STATUS_INSUFF_SERVER_RESOURCES);
        IF_DEBUG(TRACE2) SrvPrint0( "MailslotTransaction complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Attempt to open the mailslot.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &fullName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                WorkContext,
                &fileHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,                      // Create Options
                NULL,                   // EA Buffer
                0,                      // EA Length
                CreateFileTypeMailslot,
                (PVOID)NULL,            // Create parameters
                IO_FORCE_ACCESS_CHECK,
                NULL
                );

    FREE_HEAP( fullName.Buffer );


    if (!NT_SUCCESS(status)) {

        //
        // If the user didn't have this permission, update the
        // statistics database.
        //

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        //
        // The server could not open the requested mailslot
        // return the error.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint2( "MailslotTransaction: Failed to open %ws, err=%d\n",
                WorkContext->Parameters.Transaction->TransactionName.Buffer,
                status );
        }

        SrvSetSmbError (WorkContext, status);
        IF_DEBUG(TRACE2) SrvPrint0( "MailslotTransaction complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 31, transaction );
    SrvStatistics.TotalFilesOpened++;

    //
    // Get a pointer to the file object, so that we can directly
    // build IRPs for asynchronous operations (read and write).
    // Also, get the granted access mask, so that we can prevent the
    // client from doing things that it isn't allowed to do.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)&fileObject,
                &handleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "MailslotTransaction: unable to reference file handle 0x%lx",
            fileHandle,
            NULL
            );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "Mailslot transaction complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Save file handle for the completion routine.
    //

    transaction = WorkContext->Parameters.Transaction;
    transaction->FileHandle = fileHandle;
    transaction->FileObject = fileObject;

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartMailslotWrite;

    transaction = WorkContext->Parameters.Transaction;

    //
    // Build the IRP to start a mailslot write.
    // Pass this request to MSFS.
    //

    SrvBuildMailslotWriteRequest(
        WorkContext->Irp,                    // input IRP address
        fileObject,                          // target file object address
        WorkContext,                         // context
        transaction->InData,                 // buffer address
        transaction->TotalDataCount          // buffer length
        );

    (VOID)IoCallDriver(
                IoGetRelatedDeviceObject( fileObject ),
                WorkContext->Irp
                );

    //
    // The write was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "MailslotTransaction complete\n" );
    return SmbTransStatusInProgress;

} // MailslotTransaction


VOID SRVFASTCALL
RestartMailslotWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for MailslotTransaction

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the write request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Close the open pipe handle.
    //

    SRVDBG_RELEASE_HANDLE( transaction->FileHandle, "FIL", 52, transaction );
    SrvNtClose( transaction->FileHandle, TRUE );
    ObDereferenceObject( transaction->FileObject );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "RestartMailslotWrite:  Mailslot write failed: %X\n",
                        status );
        }
        SrvSetSmbError( WorkContext, status );

        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
    } else {

        //
        // Success.  Prepare to generate and send the response.
        //

        transaction->SetupCount = 0;
        transaction->ParameterCount = 2;   // return 2 parameter bytes
        transaction->DataCount = 0;

        //
        // Return an OS/2 error code in the return parameter bytes.  Just copy
        // the error from the header.  If it is a network error the client
        // will figure it out.
        //
        // *** If the client understands NT errors, make it look in the
        //     SMB header.
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) ) {
            SmbPutUshort(
                (PSMB_USHORT)transaction->OutParameters,
                SmbGetUshort( &WorkContext->ResponseHeader->Error )
                );
        } else {
            SmbPutUshort(
                (PSMB_USHORT)transaction->OutParameters,
                (USHORT)-1
                );
        }

        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartCallNamedPipe complete\n" );
    return;

} // RestartMailslotWrite


VOID SRVFASTCALL
SrvRestartExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for Transaction SMBs that need to be
    queued pending the completion of a raw write.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    SMB_STATUS status;

    PAGED_CODE( );

    status = ExecuteTransaction( WorkContext );
    ASSERT( status == SmbStatusInProgress );

    return;

} // SrvRestartExecuteTransaction

VOID SRVFASTCALL
RestartIpxMultipieceSend (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for a multipiece Transaction response over IPX.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The
        block contains information about the last SMB received for
        the transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    None.

--*/
{
    PTRANSACTION transaction = WorkContext->Parameters.Transaction;

    PAGED_CODE( );

    //
    // If the I/O request failed or was canceled, or if the connection
    // is no longer active, clean up.  (The connection is marked as
    // closing when it is disconnected or when the endpoint is closed.)
    //
    // !!! If I/O failure, should we drop the connection?
    //

    if ( WorkContext->Irp->Cancel ||
         !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(WorkContext->Connection) != BlockStateActive) ) {

        IF_DEBUG(TRACE2) {
            if ( WorkContext->Irp->Cancel ) {
                SrvPrint0( "  I/O canceled\n" );
            } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                SrvPrint1( "  I/O failed: %X\n",
                            WorkContext->Irp->IoStatus.Status );
            } else {
                SrvPrint0( "  Connection no longer active\n" );
            }
        }

        //
        // Close the transaction.  Indicate that SMB processing is
        // complete.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint1( "I/O error. Closing transaction 0x%p\n", transaction );
        }
        SrvCloseTransaction( transaction );
    }

    //
    // We had a reference to this transaction during the send.  Remove it.
    //

    DEBUG WorkContext->Parameters.Transaction = NULL;
    SrvDereferenceTransaction( transaction );
    SrvRestartFsdComplete( WorkContext );
    return;

} // RestartIpxMultipieceSend


VOID SRVFASTCALL
RestartIpxTransactionResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for a Transaction response.  If more
    responses are required, it builds and sends the next one.  If all
    responses have been sent, it closes the transaction.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The
        block contains information about the last SMB received for
        the transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;
    PCONNECTION connection;

    CLONG maxSize;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramLength;
    CLONG paramOffset;
    CLONG paramDisp;
    PCHAR dataPtr;
    CLONG dataLength;
    CLONG dataOffset;
    CLONG dataDisp;
    CLONG sendLength;

    BOOLEAN ntTransaction;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    paramDisp = transaction->ParameterDisplacement;
    dataDisp = transaction->DataDisplacement;

    IF_DEBUG(WORKER1) SrvPrint0( " - RestartIpxTransactionResponse\n" );

    //
    // Get the connection pointer.  The connection pointer is a
    // referenced pointer.
    //

    connection = WorkContext->Connection;
    IF_DEBUG(TRACE2) {
        SrvPrint2( "  connection 0x%p, endpoint 0x%p\n",
                    connection, WorkContext->Endpoint );
    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint2( "Continuing transaction response; block 0x%p, name %wZ\n",
                    transaction, &transaction->TransactionName );
        SrvPrint3( "Connection 0x%p, session 0x%p, tree connect 0x%p\n",
                    transaction->Connection, transaction->Session,
                    transaction->TreeConnect );
        SrvPrint2( "Remaining: parameters %ld bytes, data %ld bytes\n",
                    transaction->ParameterCount - paramDisp,
                    transaction->DataCount - dataDisp );
    }

    //
    // Update the parameters portion of the response, reusing the last
    // SMB.
    //

    ASSERT( transaction->Inserted );

    header = WorkContext->ResponseHeader;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ) {

        ntTransaction = TRUE;
        ntResponse->WordCount = (UCHAR)18;
        ntResponse->SetupCount = 0;

        ntResponse->Reserved1 = 0;
        SmbPutUshort( &ntResponse->Reserved2, 0 );
        SmbPutUlong( &ntResponse->TotalParameterCount,
                     transaction->ParameterCount
                     );
        SmbPutUlong( &ntResponse->TotalDataCount,
                     transaction->DataCount
                     );

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)ntResponse->Buffer;

    } else {

        ntTransaction = FALSE;
        response->WordCount = (UCHAR)10;
        response->SetupCount = 0;

        SmbPutUshort( &response->Reserved, 0 );
        SmbPutUshort( &response->TotalParameterCount,
                      (USHORT)transaction->ParameterCount
                      );
        SmbPutUshort( &response->TotalDataCount,
                      (USHORT)transaction->DataCount
                      );

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)response->Buffer;
    }

    maxSize = MIN(
                WorkContext->ResponseBuffer->BufferLength,
                (CLONG)transaction->Session->MaxBufferSize
                );

    paramPtr = (PCHAR)(byteCountPtr + 1);       // first legal location
    paramOffset = PTR_DIFF(paramPtr, header);   // offset from start of header
    paramOffset = (paramOffset + 3) & ~3;       // round to next longword
    paramPtr = (PCHAR)header + paramOffset;     // actual location

    paramLength = transaction->ParameterCount - paramDisp;
                                                // assume all parameters fit

    if ( (paramOffset + paramLength) > maxSize ) {

        //
        // Not all of the parameter bytes will fit.  Send the maximum
        // number of longwords that will fit.  Don't send any data bytes
        // in this message.
        //

        paramLength = maxSize - paramOffset;    // max that will fit
        paramLength = paramLength & ~3;         // round down to longword

        dataLength = 0;                         // don't send data bytes
        dataOffset = 0;
        dataPtr = paramPtr + paramLength;       // make calculations work

    } else {

        //
        // All of the parameter bytes fit.  Calculate how many of data
        // bytes fit.
        //

        dataPtr = paramPtr + paramLength;       // first legal location
        dataOffset = PTR_DIFF(dataPtr, header); // offset from start of header
        dataOffset = (dataOffset + 3) & ~3;     // round to next longword
        dataPtr = (PCHAR)header + dataOffset;   // actual location

        dataLength = transaction->DataCount - dataDisp;
                                                // assume all data bytes fit

        if ( (dataOffset + dataLength) > maxSize ) {

            //
            // Not all of the data bytes will fit.  Send the maximum
            // number of longwords that will fit.
            //

            dataLength = maxSize - dataOffset;  // max that will fit
            dataLength = dataLength & ~3;       // round down to longword

        }

    }

    //
    // Finish filling in the response parameters.
    //

    if ( ntTransaction) {
        SmbPutUlong( &ntResponse->ParameterCount, paramLength );
        SmbPutUlong( &ntResponse->ParameterOffset, paramOffset );
        SmbPutUlong( &ntResponse->ParameterDisplacement, paramDisp );

        SmbPutUlong( &ntResponse->DataCount, dataLength );
        SmbPutUlong( &ntResponse->DataOffset, dataOffset );
        SmbPutUlong( &ntResponse->DataDisplacement, dataDisp );
    } else {
        SmbPutUshort( &response->ParameterCount, (USHORT)paramLength );
        SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
        SmbPutUshort( &response->ParameterDisplacement, (USHORT)paramDisp );

        SmbPutUshort( &response->DataCount, (USHORT)dataLength );
        SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
        SmbPutUshort( &response->DataDisplacement, (USHORT)dataDisp );
    }

    transaction->ParameterDisplacement = paramDisp + paramLength;
    transaction->DataDisplacement = dataDisp + dataLength;

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Copy the appropriate parameter and data bytes into the message.
    //
    // !!! Note that it would be possible to use the chain send
    //     capabilities of TDI to send the parameter and data bytes from
    //     their own buffers.  There is extra overhead involved in doing
    //     this, however, because the buffers must be locked down and
    //     mapped into system space so that the network drivers can look
    //     at them.
    //

    if ( paramLength != 0 ) {
        RtlMoveMemory(
            paramPtr,
            transaction->OutParameters + paramDisp,
            paramLength
            );
    }

    if ( dataLength != 0 ) {
        RtlMoveMemory(
            dataPtr,
            transaction->OutData + dataDisp,
            dataLength
            );
    }

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // If this is the last part of the response, reenable statistics
    // gathering and restore the start time to the work context block.
    //

    header->Flags |= SMB_FLAGS_SERVER_TO_REDIR;
    if ( ((paramLength + paramDisp) == transaction->ParameterCount) &&
         ((dataLength + dataDisp) == transaction->DataCount) ) {

        //
        // This is the final piece.  Close the transaction.
        //

        WorkContext->StartTime = transaction->StartTime;

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );


    } else {

        WorkContext->ResponseBuffer->Mdl->ByteCount = sendLength;

        //
        // Send out the response.  When the send completes,
        // RestartTransactionResponse is called to either send the next
        // message or close the transaction.
        //
        // Note that the response bit in the SMB header is already set.
        //

        WorkContext->FspRestartRoutine = RestartIpxMultipieceSend;
        WorkContext->FsdRestartRoutine = NULL;
        transaction->MultipieceIpxSend = TRUE;

        SrvIpxStartSend( WorkContext, SrvQueueWorkToFspAtSendCompletion );
    }

    //
    // The response send is in progress.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "RestartIpxTransactionResponse complete\n" );
    return;

} // RestartIpxTransactionResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbsupp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsupp.c

Abstract:

    This module contains various support routines for processing SMBs.

Author:

    Chuck Lenzmeier (chuckl) 9-Nov-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "smbsupp.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBSUPP

#define CHAR_SP ' '

//
// Mapping is defined in inc\srvfsctl.h
//

STATIC GENERIC_MAPPING SrvFileAccessMapping = GENERIC_SHARE_FILE_ACCESS_MAPPING;

//
// Forward references
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, Srv8dot3ToUnicodeString )
#pragma alloc_text( PAGE, SrvAllocateAndBuildPathName )
#pragma alloc_text( PAGE, SrvCanonicalizePathName )
#pragma alloc_text( PAGE, SrvCanonicalizePathNameWithReparse )
#pragma alloc_text( PAGE, SrvCheckSearchAttributesForHandle )
#pragma alloc_text( PAGE, SrvCheckSearchAttributes )
#pragma alloc_text( PAGE, SrvGetAlertServiceName )
#pragma alloc_text( PAGE, SrvGetBaseFileName )
#pragma alloc_text( PAGE, SrvGetMultiSZList )
#pragma alloc_text( PAGE, SrvGetOsVersionString )
#pragma alloc_text( PAGE, SrvGetString )
#pragma alloc_text( PAGE, SrvGetStringLength )
#pragma alloc_text( PAGE, SrvGetSubdirectoryLength )
#pragma alloc_text( PAGE, SrvIsLegalFatName )
#pragma alloc_text( PAGE, SrvMakeUnicodeString )
//#pragma alloc_text( PAGE, SrvReleaseContext )
#pragma alloc_text( PAGE, SrvSetFileWritethroughMode )
#pragma alloc_text( PAGE, SrvOemStringTo8dot3 )
#pragma alloc_text( PAGE, SrvUnicodeStringTo8dot3 )
#pragma alloc_text( PAGE, SrvVerifySid )
#pragma alloc_text( PAGE, SrvVerifyTid )
#pragma alloc_text( PAGE, SrvVerifyUid )
#pragma alloc_text( PAGE, SrvVerifyUidAndTid )
#pragma alloc_text( PAGE, SrvIoCreateFile )
#pragma alloc_text( PAGE, SrvNtClose )
#pragma alloc_text( PAGE, SrvVerifyDeviceStackSize )
#pragma alloc_text( PAGE, SrvImpersonate )
#pragma alloc_text( PAGE, SrvRevert )
#pragma alloc_text( PAGE, SrvSetLastWriteTime )
#pragma alloc_text( PAGE, SrvCheckShareFileAccess )
#pragma alloc_text( PAGE, SrvReleaseShareRootHandle )
#pragma alloc_text( PAGE, SrvUpdateVcQualityOfService )
#pragma alloc_text( PAGE, SrvIsAllowedOnAdminShare )
#pragma alloc_text( PAGE, SrvRetrieveMaximalAccessRightsForUser )
#pragma alloc_text( PAGE, SrvRetrieveMaximalAccessRights )
#pragma alloc_text( PAGE, SrvRetrieveMaximalShareAccessRights )
#pragma alloc_text( PAGE, SrvUpdateMaximalAccessRightsInResponse )
#pragma alloc_text( PAGE, SrvUpdateMaximalShareAccessRightsInResponse )
//#pragma alloc_text( PAGE, SrvValidateSmb )
#pragma alloc_text( PAGE, SrvWildcardRename )
#pragma alloc_text( PAGE8FIL, SrvCheckForSavedError )
#pragma alloc_text( PAGE, SrvIsDottedQuadAddress )
#endif
#if 0
NOT PAGEABLE -- SrvUpdateStatistics2
NOT PAGEABLE -- SrvVerifyFid2
NOT PAGEABLE -- SrvVerifyFidForRawWrite
NOT PAGEABLE -- SrvReceiveBufferShortage
#endif


VOID
Srv8dot3ToUnicodeString (
    IN PSZ Input8dot3,
    OUT PUNICODE_STRING OutputString
    )

/*++

Routine Description:

    Convert FAT 8.3 format into a string.

Arguments:

    Input8dot3 - Supplies the input 8.3 name to convert

    OutputString - Receives the converted name.  The memory must be
        supplied by the caller.

Return Value:

    None

--*/

{
    LONG i;
    CLONG lastOutputChar;
    UCHAR tempBuffer[8+1+3];
    OEM_STRING tempString;

    PAGED_CODE( );

    //
    // If we get "." or "..", just return them.  They do not follow
    // the usual rules for FAT names.
    //

    lastOutputChar = 0;

    if ( Input8dot3[0] == '.' && Input8dot3[1] == '\0' ) {

        tempBuffer[0] = '.';
        lastOutputChar = 0;

    } else if ( Input8dot3[0] == '.' && Input8dot3[1] == '.' &&
                    Input8dot3[2] == '\0' ) {

        tempBuffer[0] = '.';
        tempBuffer[1] = '.';
        lastOutputChar = 1;

    } else {

        //
        // Copy over the 8 part of the 8.3 name into the output buffer,
        // then back up the index to the first non-space character,
        // searching backwards.
        //

        RtlCopyMemory( tempBuffer, Input8dot3, 8 );

        for ( i = 7;
              (i >= 0) && (tempBuffer[i] == CHAR_SP);
              i -- ) {
            ;
        }

        //
        // Add a dot.
        //

        i++;
        tempBuffer[i] = '.';

        //
        // Copy over the 3 part of the 8.3 name into the output buffer,
        // then back up the index to the first non-space character,
        // searching backwards.
        //

        lastOutputChar = i;

        for ( i = 8; i < 11; i++ ) {

            //
            // Copy the byte.
            //
            // *** This code used to mask off the top bit.  This was a
            //     legacy of very ancient times when the bit may have
            //     been used as a resume key sequence bit.
            //

            tempBuffer[++lastOutputChar] = (UCHAR)Input8dot3[i];

        }

        while ( tempBuffer[lastOutputChar] == CHAR_SP ) {
            lastOutputChar--;
        }

        //
        // If the last character is a '.', then we don't have an
        // extension, so back up before the dot.
        //

        if ( tempBuffer[lastOutputChar] == '.') {
            lastOutputChar--;
        }

    }

    //
    // Convert to Unicode.
    //

    tempString.Length = (SHORT)(lastOutputChar + 1);
    tempString.Buffer = tempBuffer;

    OutputString->MaximumLength =
                            (SHORT)((lastOutputChar + 2) * sizeof(WCHAR));

    RtlOemStringToUnicodeString( OutputString, &tempString, FALSE );

    return;

} // Srv8dot3ToUnicodeString


VOID
SrvAllocateAndBuildPathName(
    IN PUNICODE_STRING Path1,
    IN PUNICODE_STRING Path2 OPTIONAL,
    IN PUNICODE_STRING Path3 OPTIONAL,
    OUT PUNICODE_STRING BuiltPath
    )

/*++

Routine Description:

    Allocates space and concatenates the paths in the parameter strings.
    ALLOCATE_HEAP is used to allocate the memory for the full
    pathname.  Directory separator characters ('\') are added as
    necessary so that a legitimate path is built.  If the third
    parameter is NULL, then only the first two strings are concatenated,
    and if both the second and third parameters are NULL then the first
    string is simply copied over to a new location.

Arguments:

    Input8dot3 - Supplies the input 8.3 name to convert

    OutputString - Receives the converted name, the memory must be supplied
        by the caller.

Return Value:

    None

--*/

{
    UNICODE_STRING path2;
    UNICODE_STRING path3;
    PWCH nextLocation;
    PWSTR pathBuffer;
    ULONG allocationLength;
    WCHAR nullString = 0;

    PAGED_CODE( );

    //
    // Set up the strings for optional parameters Path2 and Path3.  Doing
    // this allows later code to be ignorant of whether the strings were
    // actually passed.
    //

    if ( ARGUMENT_PRESENT(Path2) ) {

        path2.Buffer = Path2->Buffer;
        path2.Length = Path2->Length;

    } else {

        path2.Buffer = &nullString;
        path2.Length = 0;
    }

    if ( ARGUMENT_PRESENT(Path3) ) {

        path3.Buffer = Path3->Buffer;
        path3.Length = Path3->Length;

    } else {

        path3.Buffer = &nullString;
        path3.Length = 0;
    }

    //
    // Allocate space in which to put the path name we are building.
    // The +3 if to account for as many as two directory separator
    // characters being added and the zero terminator at the end.  This
    // has a small cost in terms of memory usage, but it simplifies this
    // code.
    //
    // The calling routine must be careful to deallocate this space
    // when it is done with the path name.
    //

    allocationLength = Path1->Length + path2.Length + path3.Length +
                        3 * sizeof(WCHAR);

    pathBuffer = ALLOCATE_HEAP_COLD(
                        allocationLength,
                        BlockTypeDataBuffer
                        );
    if ( pathBuffer == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateAndBuildPathName: Unable to allocate %d bytes "
                "from heap.",
            allocationLength,
            NULL
            );

        BuiltPath->Buffer = NULL;
        return;
    }

    BuiltPath->Buffer = pathBuffer;
    BuiltPath->MaximumLength = (USHORT)allocationLength;

    ASSERT ( ( allocationLength & 0xffff0000 ) == 0 );

    RtlZeroMemory( pathBuffer, allocationLength );

    //
    // Copy the first path name to the space we have allocated.
    //

    RtlCopyMemory( pathBuffer, Path1->Buffer, Path1->Length );
    nextLocation = (PWCH)((PCHAR)pathBuffer + Path1->Length);

    //
    // If there was no separator character at the end of the first path
    // or at the beginning of the next path, put one in.  We don't
    // want to put in leading slashes, however, so don't put one in
    // if it would be the first character.  Also, we don't want to insert
    // a slash if a relative stream is being opened (i.e. name begins with ':')
    //

    if ( nextLocation > pathBuffer &&
             *(nextLocation - 1) != DIRECTORY_SEPARATOR_CHAR &&
             *path2.Buffer != DIRECTORY_SEPARATOR_CHAR &&
             *path2.Buffer != RELATIVE_STREAM_INITIAL_CHAR ) {

        *nextLocation++ = DIRECTORY_SEPARATOR_CHAR;
    }

    //
    // Concatenate the second path name with the first.
    //

    RtlCopyMemory( nextLocation, path2.Buffer, path2.Length );
    nextLocation = (PWCH)((PCHAR)nextLocation + path2.Length);

    //
    // If there was no separator character at the end of the first path
    // or at the beginning of the next path, put one in.  Again, don't
    // put in leading slashes, and watch out for relative stream opens.
    //

    if ( nextLocation > pathBuffer &&
             *(nextLocation - 1) != DIRECTORY_SEPARATOR_CHAR &&
             *path3.Buffer != DIRECTORY_SEPARATOR_CHAR &&
             *path3.Buffer != RELATIVE_STREAM_INITIAL_CHAR ) {

        *nextLocation++ = DIRECTORY_SEPARATOR_CHAR;
    }

    //
    // Concatenate the third path name.
    //

    RtlCopyMemory( nextLocation, path3.Buffer, path3.Length );
    nextLocation = (PWCH)((PCHAR)nextLocation + path3.Length);

    //
    // The path cannot end in a '\', so if there was one at the end get
    // rid of it.
    //

    if ( nextLocation > pathBuffer &&
             *(nextLocation - 1) == DIRECTORY_SEPARATOR_CHAR ) {
        *(--nextLocation) = '\0';
    }

    //
    // Find the length of the path we built.
    //

    BuiltPath->Length = (SHORT)((PCHAR)nextLocation - (PCHAR)pathBuffer);

    return;

} // SrvAllocateAndBuildPathName

NTSTATUS
SrvCanonicalizePathName(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine canonicalizes a filename.  All ".\" are removed, and
    "..\" are evaluated to go up a directory level.  A check is also
    made to ensure that the pathname does not go to a directory above
    the share root directory (i.e., no leading "..\").  Trailing blanks
    are always removed, as are trailing dots if RemoveTrailingDots is
    TRUE.

    If the input string is not Unicode, a Unicode representation of the
    input is obtained.  This requires that additional space be
    allocated, and it is the caller's responsibility to free this space.

    If the input string IS Unicode, this routine will align the input
    pointer (Name) to the next two-byte boundary before performing the
    canonicalization.  All Unicode strings in SMBs must be aligned
    properly.

    This routine operates "in place," meaning that it puts the
    canonicalized pathname in the same storage as the uncanonicalized
    pathname.  This is useful for operating on the Buffer fields of the
    request SMBs--simply call this routine and it will fix the pathname.
    However, the calling routine must be careful if there are two
    pathnames stored in the buffer field--the second won't necessarily
    start in the space just after the first '\0'.

    The LastValidLocation parameter is used to determine the maximum
    possible length of the name.  This prevents an access violation if
    the client fails to include a zero terminator, or for strings (such
    as the file name in NT Create And X) that are not required to be
    zero terminated.

    If the SMB described by WorkContext is marked as containing Dfs names,
    this routine will additionally call the Dfs driver to translate the
    Dfs name to a path relative to the Share. Since this call to the Dfs
    driver is NOT idempotent, the SMB flag indicating that it contains a
    Dfs name is CLEARED after a call to this routine. This posses a problem
    for the few SMBs that contain multiple names. The handlers for those
    SMBs must make sure that they conditionally call the SMB_MARK_AS_DFS_NAME
    macro before calling this routine.

Arguments:

    WorkContext - contains information about the negotiated dialect. This
        is used for deciding whether to strip trailing spaces and dots.

    Share - a pointer to the share entry

    Name - a pointer to the filename to canonicalize.

    LastValidLocation - a pointer to the last valid location in the
        buffer pointed to by Name.

    RemoveTrailingDots - if TRUE, trailing dots are removed.  Otherwise,
        they are left in (this supports special behavior needed by
        directory search logic).

    SourceIsUnicode - if TRUE, the input is canonicalized in place.
        If FALSE, the input is first converted to Unicode, then
        canonicalized.

    String - a pointer to string descriptor.

Return Value:

    BOOLEAN - FALSE if the name was invalid or if storage for the
        Unicode string could not be obtained.

--*/

{
    PWCH source, destination, lastComponent, name;
    BOOLEAN notNtClient;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD numberOfPathElements = 0;

    PAGED_CODE( );

#if DBG
    return SrvCanonicalizePathNameWithReparse( WorkContext, Share, RelatedPath, Name, LastValidLocation, RemoveTrailingDots, SourceIsUnicode, String );
#else
    if( SMB_IS_UNICODE( WorkContext ) &&
        FlagOn( WorkContext->RequestHeader->Flags2, SMB_FLAGS2_REPARSE_PATH ) )
    {
        return SrvCanonicalizePathNameWithReparse( WorkContext, Share, RelatedPath, Name, LastValidLocation, RemoveTrailingDots, SourceIsUnicode, String );
    }
#endif


    notNtClient = !IS_NT_DIALECT( WorkContext->Connection->SmbDialect );

    if ( SourceIsUnicode ) {

        //
        // The source string is already Unicode.  Align the pointer.
        // Save the character at the last location in the buffer, then
        // set that location to zero.  This prevents any loops from
        // going past the end of the buffer.
        //

        name = ALIGN_SMB_WSTR(Name);
        String->Buffer = name;

    } else {

        OEM_STRING oemString;
        PCHAR p;
        ULONG length;

        //
        // The source string is not Unicode.  Determine the length of
        // the string by finding the zero terminator or the end of the
        // input buffer.  We need the length in order to convert the
        // string to Unicode, and we can't just call RtlInitString, in
        // case the string isn't terminated.
        //

        for ( p = Name, length = 0;
              p <= LastValidLocation && *p != 0;
              p++, length++ ) {
            ;
        }

        //
        // Convert the source string to Unicode.
        //

        oemString.Buffer = Name;
        oemString.Length = (USHORT)length;
        oemString.MaximumLength = (USHORT)length;

        status = RtlOemStringToUnicodeString(
                            String,
                            &oemString,
                            TRUE
                            );

        if( !NT_SUCCESS( status ) ) {
            return status;
        }

        name = (PWCH)String->Buffer;
        LastValidLocation = (PCHAR)String->Buffer + String->Length;

    }

    //
    // Though everything is done in place, separate source and
    // destination pointers are maintained.  It is necessary that source
    // >= destination at all times to avoid writing into space we
    // haven't looked at yet.  The three main operations performed by
    // this routine ( ".\", "..\", and getting rid of trailing "." and "
    // ") do not interfere with this goal.
    //

    destination = name;
    source = name;

    //
    // The lastComponent variable is used as a placeholder when
    // backtracking over trailing blanks and dots.  It points to the
    // first character after the last directory separator or the
    // beginning of the pathname.
    //

    lastComponent = destination;

    //
    // Get rid of leading directory separators.
    //

    while ( source <= (PWCH)LastValidLocation &&
            (*source == UNICODE_DIR_SEPARATOR_CHAR) && (*source != L'\0') ) {
        source++;
    }

    //
    // Walk through the pathname until we reach the zero terminator.  At
    // the start of this loop, source points to the first charaecter
    // after a directory separator or the first character of the
    // pathname.
    //

    while ( (source <= (PWCH)LastValidLocation) && (*source != L'\0') ) {

        if ( *source == L'.' ) {

            //
            // If we see a dot, look at the next character.
            //

            if ( notNtClient &&
                 ((source+1) <= (PWCH)LastValidLocation) &&
                 (*(source+1) == UNICODE_DIR_SEPARATOR_CHAR) ) {

                //
                // If the next character is a directory separator,
                // advance the source pointer to the directory
                // separator.
                //

                source += 1;

            } else if ( ((source+1) <= (PWCH)LastValidLocation) &&
                        (*(source+1) == L'.') &&
                        ((source+1) == (PWCH)LastValidLocation ||
                        IS_UNICODE_PATH_SEPARATOR( *(source+2) ))) {

                //
                // If the following characters are ".\", we have a "..\".
                // Advance the source pointer to the "\".
                //

                source += 2;

                //
                // Move the destination pointer to the charecter before the
                // last directory separator in order to prepare for backing
                // up.  This may move the pointer before the beginning of
                // the name pointer.
                //

                destination -= 2;

                //
                // If destination points before the beginning of the name
                // pointer, fail because the user is attempting to go
                // to a higher directory than the share root.  This is
                // the equivalent of a leading "..\", but may result from
                // a case like "dir\..\..\file".
                //

                if ( destination <= name ) {
                    if ( !SourceIsUnicode ) {
                        RtlFreeUnicodeString( String );
                        String->Buffer = NULL;
                    }
                    return STATUS_OBJECT_PATH_SYNTAX_BAD;
                }

                //
                // Back up the destination pointer to after the last
                // directory separator or to the beginning of the pathname.
                // Backup to the beginning of the pathname will occur
                // in a case like "dir\..\file".
                //

                while ( destination >= name &&
                        *destination != UNICODE_DIR_SEPARATOR_CHAR ) {
                    destination--;
                }

                //
                // destination points to \ or character before name; we
                // want it to point to character after last \.
                //

                destination++;

            } else {

                //
                // The characters after the dot are not "\" or ".\", so
                // so just copy source to destination until we reach a
                // directory separator character.  This will occur in
                // a case like ".file" (filename starts with a dot).
                //

                do {
                    *destination++ = *source++;
                } while ( (source <= (PWCH)LastValidLocation) &&
                          !IS_UNICODE_PATH_SEPARATOR( *source ) );

                numberOfPathElements++;

            }

        } else {             // if ( *source == L'.' )

            //
            // source does not point to a dot, so copy source to
            // destination until we get to a directory separator.
            //

            while ( (source <= (PWCH)LastValidLocation) &&
                    !IS_UNICODE_PATH_SEPARATOR( *source ) ) {
                    *destination++ = *source++;
            }

            numberOfPathElements++;

        }

        //
        // Truncate trailing dots and blanks.  destination should point
        // to the last character before the directory separator, so back
        // up over blanks and dots.
        //

        if ( notNtClient ) {

            while ( ( destination > lastComponent ) &&
                    ( (RemoveTrailingDots && *(destination-1) == '.')
                        || *(destination-1) == ' ' ) ) {
                destination--;
            }
        }

        //
        // At this point, source points to a directory separator or to
        // a zero terminator.  If it is a directory separator, put one
        // in the destination.
        //

        if ( (source <= (PWCH)LastValidLocation) &&
             (*source == UNICODE_DIR_SEPARATOR_CHAR) ) {

            //
            // If we haven't put the directory separator in the path name,
            // put it in.
            //

            if ( destination != name &&
                 *(destination-1) != UNICODE_DIR_SEPARATOR_CHAR ) {

                *destination++ = UNICODE_DIR_SEPARATOR_CHAR;

            }

            //
            // It is legal to have multiple directory separators, so get
            // rid of them here.  Example: "dir\\\\\\\\file".
            //

            do {
                source++;
            } while ( (source <= (PWCH)LastValidLocation) &&
                      (*source == UNICODE_DIR_SEPARATOR_CHAR) );

            //
            // Make lastComponent point to the character after the directory
            // separator.
            //

            lastComponent = destination;

        }

    }

    //
    // We're just about done.  If there was a trailing ..  (example:
    // "file\.."), trailing .  ("file\."), or multiple trailing
    // separators ("file\\\\"), then back up one since separators are
    // illegal at the end of a pathname.
    //

    if ( destination > name &&
        *(destination-1) == UNICODE_DIR_SEPARATOR_CHAR ) {

        destination--;
    }

    *destination = L'\0';

    //
    // The length of the destination string is the difference between the
    // destination pointer (points to zero terminator at this point)
    // and the name pointer (points to the beginning of the destination
    // string).
    //

    String->Length = (SHORT)((PCHAR)destination - (PCHAR)name);
    String->MaximumLength = String->Length;

    //
    // One final thing:  Is this SMB referring to a DFS name?  If so, ask
    //  the DFS driver to turn it into a local name.
    //
    if( ARGUMENT_PRESENT( Share ) &&
        Share->IsDfs &&
        SMB_CONTAINS_DFS_NAME( WorkContext )) {

        BOOLEAN stripLastComponent = FALSE;

        //
        // We have to special case some SMBs (like TRANS2_FIND_FIRST2)
        // because they contain path Dfs path names that could refer to a
        // junction point. The SMB handlers for these SMBs are not interested
        // in a STATUS_PATH_NOT_COVERED error; instead they want the name
        // to be resolved to the the junction point.
        //

        if (WorkContext->NextCommand == SMB_COM_TRANSACTION2 ) {

            PTRANSACTION transaction;
            USHORT command;

            transaction = WorkContext->Parameters.Transaction;
            command = SmbGetUshort( &transaction->InSetup[0] );

            if (command == TRANS2_FIND_FIRST2 && numberOfPathElements > 2 )
                stripLastComponent = TRUE;

        }

        status =
            DfsNormalizeName(Share, RelatedPath, stripLastComponent, String);

        SMB_MARK_AS_DFS_TRANSLATED( WorkContext );

        if( !NT_SUCCESS( status ) ) {
            if ( !SourceIsUnicode ) {
                RtlFreeUnicodeString( String );
                String->Buffer = NULL;
            }
        }
    }

    return status;

} // SrvCanonicalizePathName

NTSTATUS
SrvCanonicalizePathNameWithReparse(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine is identical to the one above with the exception that it
    checks the path for reparse-able names (such as snapshot references) and
    handles them accordingly.  This allows us to present new features within
    the Win32 namespace so old applications can use them.

Arguments:

    WorkContext - contains information about the negotiated dialect. This
        is used for deciding whether to strip trailing spaces and dots.

    Share - a pointer to the share entry

    Name - a pointer to the filename to canonicalize.

    LastValidLocation - a pointer to the last valid location in the
        buffer pointed to by Name.

    RemoveTrailingDots - if TRUE, trailing dots are removed.  Otherwise,
        they are left in (this supports special behavior needed by
        directory search logic).

    SourceIsUnicode - if TRUE, the input is canonicalized in place.
        If FALSE, the input is first converted to Unicode, then
        canonicalized.

    String - a pointer to string descriptor.

Return Value:

    BOOLEAN - FALSE if the name was invalid or if storage for the
        Unicode string could not be obtained.

--*/

{
    PWCH source, destination, lastComponent, name;
    BOOLEAN notNtClient;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD numberOfPathElements = 0;

    PAGED_CODE( );

    notNtClient = !IS_NT_DIALECT( WorkContext->Connection->SmbDialect );

    if ( SourceIsUnicode ) {

        //
        // The source string is already Unicode.  Align the pointer.
        // Save the character at the last location in the buffer, then
        // set that location to zero.  This prevents any loops from
        // going past the end of the buffer.
        //

        name = ALIGN_SMB_WSTR(Name);
        String->Buffer = name;

    } else {

        OEM_STRING oemString;
        PCHAR p;
        ULONG length;

        //
        // The source string is not Unicode.  Determine the length of
        // the string by finding the zero terminator or the end of the
        // input buffer.  We need the length in order to convert the
        // string to Unicode, and we can't just call RtlInitString, in
        // case the string isn't terminated.
        //

        for ( p = Name, length = 0;
              p <= LastValidLocation && *p != 0;
              p++, length++ ) {
            ;
        }

        //
        // Convert the source string to Unicode.
        //

        oemString.Buffer = Name;
        oemString.Length = (USHORT)length;
        oemString.MaximumLength = (USHORT)length;

        status = RtlOemStringToUnicodeString(
                            String,
                            &oemString,
                            TRUE
                            );

        if( !NT_SUCCESS( status ) ) {
            return status;
        }

        name = (PWCH)String->Buffer;
        LastValidLocation = (PCHAR)String->Buffer + String->Length;

    }

    //
    // Though everything is done in place, separate source and
    // destination pointers are maintained.  It is necessary that source
    // >= destination at all times to avoid writing into space we
    // haven't looked at yet.  The three main operations performed by
    // this routine ( ".\", "..\", and getting rid of trailing "." and "
    // ") do not interfere with this goal.
    //

    destination = name;
    source = name;

    //
    // The lastComponent variable is used as a placeholder when
    // backtracking over trailing blanks and dots.  It points to the
    // first character after the last directory separator or the
    // beginning of the pathname.
    //

    lastComponent = destination;

    //
    // Get rid of leading directory separators.
    //

    while ( source <= (PWCH)LastValidLocation &&
            (*source == UNICODE_DIR_SEPARATOR_CHAR) && (*source != L'\0') ) {
        source++;
    }

    //
    // Walk through the pathname until we reach the zero terminator.  At
    // the start of this loop, source points to the first charaecter
    // after a directory separator or the first character of the
    // pathname.
    //

    while ( (source <= (PWCH)LastValidLocation) && (*source != L'\0') ) {

        if ( *source == L'.' ) {

            //
            // If we see a dot, look at the next character.
            //

            if ( notNtClient &&
                 ((source+1) <= (PWCH)LastValidLocation) &&
                 (*(source+1) == UNICODE_DIR_SEPARATOR_CHAR) ) {

                //
                // If the next character is a directory separator,
                // advance the source pointer to the directory
                // separator.
                //

                source += 1;

            } else if ( ((source+1) <= (PWCH)LastValidLocation) &&
                        (*(source+1) == L'.') &&
                        ((source+1) == (PWCH)LastValidLocation ||
                        IS_UNICODE_PATH_SEPARATOR( *(source+2) ))) {

                //
                // If the following characters are ".\", we have a "..\".
                // Advance the source pointer to the "\".
                //

                source += 2;

                //
                // Move the destination pointer to the charecter before the
                // last directory separator in order to prepare for backing
                // up.  This may move the pointer before the beginning of
                // the name pointer.
                //

                destination -= 2;

                //
                // If destination points before the beginning of the name
                // pointer, fail because the user is attempting to go
                // to a higher directory than the share root.  This is
                // the equivalent of a leading "..\", but may result from
                // a case like "dir\..\..\file".
                //

                if ( destination <= name ) {
                    if ( !SourceIsUnicode ) {
                        RtlFreeUnicodeString( String );
                        String->Buffer = NULL;
                    }
                    return STATUS_OBJECT_PATH_SYNTAX_BAD;
                }

                //
                // Back up the destination pointer to after the last
                // directory separator or to the beginning of the pathname.
                // Backup to the beginning of the pathname will occur
                // in a case like "dir\..\file".
                //

                while ( destination >= name &&
                        *destination != UNICODE_DIR_SEPARATOR_CHAR ) {
                    destination--;
                }

                //
                // destination points to \ or character before name; we
                // want it to point to character after last \.
                //

                destination++;

            } else {

                //
                // The characters after the dot are not "\" or ".\", so
                // so just copy source to destination until we reach a
                // directory separator character.  This will occur in
                // a case like ".file" (filename starts with a dot).
                //

                do {
                    *destination++ = *source++;
                } while ( (source <= (PWCH)LastValidLocation) &&
                          !IS_UNICODE_PATH_SEPARATOR( *source ) );

                numberOfPathElements++;

            }

        } else {             // if ( *source == L'.' )

            // Try to parse out a snap token
            if( SrvSnapParseToken( source, &WorkContext->SnapShotTime ) )
            {
                while ( (source <= (PWCH)LastValidLocation) &&
                        !IS_UNICODE_PATH_SEPARATOR( *source ) ) {
                        source++;
                }

#if DBG
                if( !(WorkContext->RequestHeader->Flags2 & SMB_FLAGS2_REPARSE_PATH) )
                {
                    DbgPrint( "Found token but REPARSE not set!\n" );
                    DbgBreakPoint();
                }
#endif
            }
            else
            {
                while ( (source <= (PWCH)LastValidLocation) &&
                        !IS_UNICODE_PATH_SEPARATOR( *source ) ) {
                        *destination++ = *source++;
                }
            }

            numberOfPathElements++;

        }

        //
        // Truncate trailing dots and blanks.  destination should point
        // to the last character before the directory separator, so back
        // up over blanks and dots.
        //

        if ( notNtClient ) {

            while ( ( destination > lastComponent ) &&
                    ( (RemoveTrailingDots && *(destination-1) == '.')
                        || *(destination-1) == ' ' ) ) {
                destination--;
            }
        }

        //
        // At this point, source points to a directory separator or to
        // a zero terminator.  If it is a directory separator, put one
        // in the destination.
        //

        if ( (source <= (PWCH)LastValidLocation) &&
             (*source == UNICODE_DIR_SEPARATOR_CHAR) ) {

            //
            // If we haven't put the directory separator in the path name,
            // put it in.
            //

            if ( destination != name &&
                 *(destination-1) != UNICODE_DIR_SEPARATOR_CHAR ) {

                *destination++ = UNICODE_DIR_SEPARATOR_CHAR;

            }

            //
            // It is legal to have multiple directory separators, so get
            // rid of them here.  Example: "dir\\\\\\\\file".
            //

            do {
                source++;
            } while ( (source <= (PWCH)LastValidLocation) &&
                      (*source == UNICODE_DIR_SEPARATOR_CHAR) );

            //
            // Make lastComponent point to the character after the directory
            // separator.
            //

            lastComponent = destination;

        }

    }

    //
    // We're just about done.  If there was a trailing ..  (example:
    // "file\.."), trailing .  ("file\."), or multiple trailing
    // separators ("file\\\\"), then back up one since separators are
    // illegal at the end of a pathname.
    //

    if ( destination > name &&
        *(destination-1) == UNICODE_DIR_SEPARATOR_CHAR ) {

        destination--;
    }

    *destination = L'\0';

    //
    // The length of the destination string is the difference between the
    // destination pointer (points to zero terminator at this point)
    // and the name pointer (points to the beginning of the destination
    // string).
    //

    String->Length = (SHORT)((PCHAR)destination - (PCHAR)name);
    String->MaximumLength = String->Length;

    //
    // One final thing:  Is this SMB referring to a DFS name?  If so, ask
    //  the DFS driver to turn it into a local name.
    //
    if( ARGUMENT_PRESENT( Share ) &&
        Share->IsDfs &&
        SMB_CONTAINS_DFS_NAME( WorkContext )) {

        BOOLEAN stripLastComponent = FALSE;

        //
        // We have to special case some SMBs (like TRANS2_FIND_FIRST2)
        // because they contain path Dfs path names that could refer to a
        // junction point. The SMB handlers for these SMBs are not interested
        // in a STATUS_PATH_NOT_COVERED error; instead they want the name
        // to be resolved to the the junction point.
        //

        if (WorkContext->NextCommand == SMB_COM_TRANSACTION2 ) {

            PTRANSACTION transaction;
            USHORT command;

            transaction = WorkContext->Parameters.Transaction;
            command = SmbGetUshort( &transaction->InSetup[0] );

            if (command == TRANS2_FIND_FIRST2 && numberOfPathElements > 2 )
                stripLastComponent = TRUE;

        }

        status =
            DfsNormalizeName(Share, RelatedPath, stripLastComponent, String);

        SMB_MARK_AS_DFS_TRANSLATED( WorkContext );

        if( !NT_SUCCESS( status ) ) {
            if ( !SourceIsUnicode ) {
                RtlFreeUnicodeString( String );
                String->Buffer = NULL;
            }
        }
    }

#if DBG
    if( (WorkContext->RequestHeader->Flags2 & SMB_FLAGS2_REPARSE_PATH) &&
        (WorkContext->SnapShotTime.QuadPart == 0) )
    {
        DbgPrint( "Token not found but REPARSE set!\n" );
        DbgBreakPoint();
    }
#endif

    return status;

} // SrvCanonicalizePathNameWithReparse



NTSTATUS
SrvCheckForSavedError(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This routine checks to see if there was a saved error.

Arguments:

    WorkContext - Pointer to the workcontext block which will be
        marked with the error.

    Rfcb - Pointer to the rfcb which contains the saved error status.

Return Value:

    status of SavedErrorCode.

--*/

{

    NTSTATUS savedErrorStatus;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the spin lock and see if the saved error
    // is still there.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );
    savedErrorStatus = Rfcb->SavedError;
    if ( !NT_SUCCESS( savedErrorStatus ) ) {

        //
        // There was a write behind error.  Fail this operation
        // with the write error.
        //

        Rfcb->SavedError = STATUS_SUCCESS;
        RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, oldIrql );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvCheckForSavedError: Returning write"
                "behind error %X\n", savedErrorStatus ));
        }
        SrvSetSmbError( WorkContext, savedErrorStatus );

    } else {

        RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, oldIrql );
    }

    return savedErrorStatus;

} // SrvCheckForSavedError


NTSTATUS SRVFASTCALL
SrvCheckSearchAttributes(
    IN USHORT FileAttributes,
    IN USHORT SmbSearchAttributes
    )
/*++

Routine Description:

    Determines whether the FileAttributes has
    attributes not specified in SmbSearchAttributes.  Only the system
    and hidden bits are examined.

Arguments:

    FileAttributes - The attributes in question

    SmbSearchAttributes - the search attributes passed in an SMB.

Return Value:

    STATUS_NO_SUCH_FILE if the attributes do not jive, or STATUS_SUCCESS if
        the search attributes encompass the attributes on the file.

--*/
{
    PAGED_CODE( );

    //
    // If the search attributes has both the system and hidden bits set,
    // then the file must be OK.
    //

    if ( (SmbSearchAttributes & FILE_ATTRIBUTE_SYSTEM) != 0 &&
         (SmbSearchAttributes & FILE_ATTRIBUTE_HIDDEN) != 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Mask out everything but the system and hidden bits--they're all
    // we care about.
    //

    FileAttributes &= (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);

    //
    // If a bit is set in fileAttributes that was not set in the search
    // attributes, then their bitwise OR will have a bit set that is
    // not set in search attributes.
    //

    if ( (SmbSearchAttributes | FileAttributes) != SmbSearchAttributes ) {
        return STATUS_NO_SUCH_FILE;
    }

    return STATUS_SUCCESS;

} // SrvCheckSearchAttributes


NTSTATUS
SrvCheckSearchAttributesForHandle(
    IN HANDLE FileHandle,
    IN USHORT SmbSearchAttributes
    )

/*++

Routine Description:

    Determines whether the file corresponding to FileHandle has
    attributes not specified in SmbSearchAttributes.  Only the system
    and hidden bits are examined.

Arguments:

    FileHandle - handle to the file; must have FILE_READ_ATTRIBUTES access.

    SmbSearchAttributes - the search attributes passed in an SMB.

Return Value:

    STATUS_NO_SUCH_FILE if the attributes do not jive, some other status
        code if the NtQueryInformationFile fails, or STATUS_SUCCESS if
        the search attributes encompass the attributes on the file.

--*/

{
    NTSTATUS status;
    FILE_BASIC_INFORMATION fileBasicInformation;

    PAGED_CODE( );

    //
    // If the search attributes has both the system and hidden bits set,
    // then the file must be OK.
    //

    if ( (SmbSearchAttributes & FILE_ATTRIBUTE_SYSTEM) != 0 &&
         (SmbSearchAttributes & FILE_ATTRIBUTE_HIDDEN) != 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Get the attributes on the file.
    //

    status = SrvQueryBasicAndStandardInformation(
                                            FileHandle,
                                            NULL,
                                            &fileBasicInformation,
                                            NULL
                                            );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCheckSearchAttributesForHandle: NtQueryInformationFile (basic "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        return status;
    }

    return SrvCheckSearchAttributes( (USHORT)fileBasicInformation.FileAttributes,
                                     SmbSearchAttributes );

} // SrvCheckSearchAttributesForHandle

VOID
SrvGetAlertServiceName(
    VOID
    )

/*++

Routine Description:

    This routine gets the server display string from the registry.

Arguments:

    None.

Return Value:

    none.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeRegPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;

    ULONG lengthNeeded;
    NTSTATUS status;

    PWCHAR displayString;
    PWCHAR newString;

    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    PAGED_CODE( );

    RtlInitUnicodeString( &unicodeRegPath, StrRegServerPath );
    RtlInitUnicodeString( &unicodeKeyName, StrRegSrvDisplayName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeRegPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( infoBuffer == NULL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    //
    // If it's empty, use the default.
    //

    lengthNeeded = infoBuffer->DataLength;
    if ( lengthNeeded <= sizeof(WCHAR) ) {
        goto use_default;
    }

    //
    // Get the display string.  If this is the same as the default,
    // exit.
    //

    displayString = (PWCHAR)((PCHAR)infoBuffer + infoBuffer->DataOffset);

    if ( wcscmp( displayString, StrDefaultSrvDisplayName ) == 0 ) {
        goto use_default;
    }

    //
    // allocate memory for the new display string
    //

    newString = (PWCHAR)ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( newString == NULL ) {
        goto use_default;
    }

    RtlCopyMemory(
            newString,
            displayString,
            lengthNeeded
            );

    SrvAlertServiceName = newString;
    FREE_HEAP( infoBuffer );
    return;

use_default:

    if ( infoBuffer != NULL ) {
        FREE_HEAP( infoBuffer );
    }

    SrvAlertServiceName = StrDefaultSrvDisplayName;
    return;

} // SrvGetAlertServiceName

VOID
SrvGetBaseFileName (
    IN PUNICODE_STRING InputName,
    OUT PUNICODE_STRING OutputName
    )

/*++

Routine Description:

    This routine finds the part of a path name that is only a file
    name.  For example, with a\b\c\filename, it sets the buffer
    field of OutputName to point to "filename" and the length to 8.

    *** This routine should be used AFTER SrvCanonicalizePathName has
        been used on the path name to ensure that the name is good and
        '..' have been removed.

Arguments:

    InputName - Supplies a pointer to the pathname string.

    OutputName - a pointer to where the base name information should
        be written.

Return Value:

    None.

--*/

{
    PWCH ep = &InputName->Buffer[ InputName->Length / sizeof(WCHAR) ];
    PWCH baseFileName = ep - 1;

    PAGED_CODE( );

    for( ; baseFileName > InputName->Buffer; --baseFileName ) {
        if( *baseFileName == DIRECTORY_SEPARATOR_CHAR ) {
            OutputName->Buffer = baseFileName + 1;
            OutputName->Length = PTR_DIFF_SHORT(ep, OutputName->Buffer);
            OutputName->MaximumLength = OutputName->Length;
            return;
        }
    }

    *OutputName = *InputName;

    return;

} // SrvGetBaseFileName

VOID
SrvGetMultiSZList(
    PWSTR **ListPointer,
    PWSTR BaseKeyName,
    PWSTR ParameterKeyName,
    PWSTR *DefaultList
    )

/*++

Routine Description:

    This routine queries a registry value key for its MULTI_SZ values.

Arguments:

    ListPointer - Pointer to receive the pointer to the null session pipes.
    ParameterKeyValue - Name of the value parameter to query.
    DefaultList - Value to assign to the list pointer in case
        something goes wrong.

Return Value:

    none.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeParamPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;

    ULONG lengthNeeded;
    ULONG i;
    ULONG numberOfEntries;
    ULONG numberOfDefaultEntries = 0;
    NTSTATUS status;

    PWCHAR regEntry;
    PWCHAR dataEntry;
    PWSTR *ptrEntry;
    PCHAR newBuffer;
    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    PAGED_CODE( );

    RtlInitUnicodeString( &unicodeParamPath, BaseKeyName );
    RtlInitUnicodeString( &unicodeKeyName, ParameterKeyName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( infoBuffer == NULL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    //
    // Figure out how many entries there are.
    //
    // numberOfEntries should be total number of entries + 1.  The extra
    // one is for the NULL sentinel entry.
    //

    lengthNeeded = infoBuffer->DataLength;
    if ( lengthNeeded <= sizeof(WCHAR) ) {

        //
        // No entries on the list.  Use default.
        //

        goto use_default;
    }

    dataEntry = (PWCHAR)((PCHAR)infoBuffer + infoBuffer->DataOffset);
    for ( i = 0, regEntry = dataEntry, numberOfEntries = 0;
        i < lengthNeeded;
        i += sizeof(WCHAR) ) {

        if ( *regEntry++ == L'\0' ) {
            numberOfEntries++;
        }
    }

    //
    // Add the number of entries in the default list.
    //

    if ( DefaultList != NULL ) {
        for ( i = 0; DefaultList[i] != NULL ; i++ ) {
            numberOfDefaultEntries++;
        }
    }

    //
    // Allocate space needed for the array of pointers.  This is in addition
    // to the ones in the default list.
    //

    newBuffer = ALLOCATE_HEAP_COLD(
                        lengthNeeded +
                            (numberOfDefaultEntries + numberOfEntries + 1) *
                            sizeof( PWSTR ),
                        BlockTypeDataBuffer
                        );

    if ( newBuffer == NULL ) {
        goto use_default;
    }

    //
    // Copy the names
    //

    regEntry = (PWCHAR)(newBuffer +
        (numberOfDefaultEntries + numberOfEntries + 1) * sizeof(PWSTR));

    RtlCopyMemory(
            regEntry,
            dataEntry,
            lengthNeeded
            );

    //
    // Free the info buffer
    //

    FREE_HEAP( infoBuffer );

    //
    // Copy the pointers in the default list.
    //

    ptrEntry = (PWSTR *) newBuffer;

    for ( i = 0; i < numberOfDefaultEntries ; i++ ) {

        *ptrEntry++ = DefaultList[i];

    }

    //
    // Build the array of pointers.  If numberOfEntries is 1, then
    // it means that the list is empty.
    //


    if ( numberOfEntries > 1 ) {

        *ptrEntry++ = regEntry++;

        //
        // Skip the first WCHAR and the last 2 NULL terminators.
        //

        for ( i = 3*sizeof(WCHAR) ; i < lengthNeeded ; i += sizeof(WCHAR) ) {
            if ( *regEntry++ == L'\0' ) {
                *ptrEntry++ = regEntry;
            }
        }
    }

    *ptrEntry = NULL;
    *ListPointer = (PWSTR *)newBuffer;
    return;

use_default:

    if ( infoBuffer != NULL ) {
        FREE_HEAP( infoBuffer );
    }
    *ListPointer = DefaultList;
    return;

} // SrvGetMultiSZList

VOID
SrvGetOsVersionString(
    VOID
    )
{

    ULONG lengthNeeded;
    NTSTATUS status;
    HANDLE keyHandle;
    UNICODE_STRING unicodeParamPath;
    UNICODE_STRING unicodeKeyName;
    OBJECT_ATTRIBUTES objAttributes;
    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    PAGED_CODE();

    //
    // Read the version number string
    //

    RtlInitUnicodeString( &unicodeParamPath, StrRegOsVersionPath );
    RtlInitUnicodeString( &unicodeKeyName, StrRegVersionKeyName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( infoBuffer == NULL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    //
    // Construct the version (oem and unicode) strings.
    //

    if ( infoBuffer->DataLength != 0 ) {

        ULONG stringLength;

        stringLength = infoBuffer->DataLength +
                       STRLEN(StrNativeOsPrefix) * sizeof(WCHAR);

        SrvNativeOS.MaximumLength = (USHORT)stringLength;
        SrvNativeOS.Length = SrvNativeOS.MaximumLength - sizeof(WCHAR);

        SrvNativeOS.Buffer =
            ALLOCATE_HEAP_COLD( SrvNativeOS.MaximumLength, BlockTypeDataBuffer );

        if ( SrvNativeOS.Buffer == NULL) {

            goto use_default;
        }

        RtlCopyMemory(
            SrvNativeOS.Buffer,
            StrNativeOsPrefix,
            STRLEN(StrNativeOsPrefix) * sizeof(WCHAR)
            );

        RtlCopyMemory(
            SrvNativeOS.Buffer + STRLEN(StrNativeOsPrefix),
            (PCHAR)infoBuffer+infoBuffer->DataOffset,
            infoBuffer->DataLength
            );

        FREE_HEAP( infoBuffer );
        infoBuffer = NULL;

        //
        // Now get the oem version
        //

        status = RtlUnicodeStringToOemString(
                                &SrvOemNativeOS,
                                &SrvNativeOS,
                                TRUE
                                );

        if ( !NT_SUCCESS(status) ) {

            FREE_HEAP( SrvNativeOS.Buffer );
            goto use_default;
        }

        return;
    }

use_default:

    if ( infoBuffer != NULL ) {
        FREE_HEAP( infoBuffer );
    }

    RtlInitUnicodeString( &SrvNativeOS, StrDefaultNativeOs );
    RtlInitAnsiString( (PANSI_STRING)&SrvOemNativeOS, StrDefaultNativeOsOem );

    return;

} // SrvGetOsVersionString


USHORT
SrvGetString (
    IN OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode
    )

/*++

Routine Description:

    Reads a string out of an SMB buffer, and converts it to Unicode,
    if necessary.  This function is similar to SrvMakeUnicodeString,
    except

    (1) It always copies data from source to destination
    (2) It assumes storage for destination has been preallocated.  Its length
        is Destination->MaximumLength

Arguments:

    Destination - the resultant Unicode string.

    Source - a zero-terminated input.

    EndOfSourceBuffer - A pointer to the end of the SMB buffer.  Used to
        protect the server from accessing beyond the end of the SMB buffer,
        if the format is invalid.

    SourceIsUnicode - TRUE if the source is already Unicode.

Return Value:

    Length - Length of input buffer (included the NUL terminator).
             -1 if EndOfSourceBuffer is reached before the NUL terminator.

--*/

{
    USHORT length;

    PAGED_CODE( );

    if ( SourceIsUnicode ) {

        PWCH currentChar = Source;

        ASSERT( ((ULONG_PTR)Source & 1) == 0 );

        length = 0;
        while ( currentChar < (PWCH)EndOfSourceBuffer &&
                *currentChar != UNICODE_NULL ) {
            currentChar++;
            length += sizeof( WCHAR );
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar >= (PWCH)EndOfSourceBuffer ) {
            return (USHORT)-1;
        }

        //
        // If we overran our storage buffer, this is a bad string.  Return an error
        //
        if( length + sizeof( UNICODE_NULL ) > Destination->MaximumLength ) {
            return (USHORT)-1;
        }

        //
        // Copy the unicode data to the destination, including the NULL.  Set length
        //  of Destination to the non-null string length.
        //
        Destination->Length = length;

        //
        // We didn't change this to RtlCopyMemory because it is possible that
        // the source and destination can overlap.  Copy the NULL as well
        //

        RtlMoveMemory( Destination->Buffer, Source, length );

    } else {

        PCHAR currentChar = Source;
        OEM_STRING sourceString;

        length = 0;
        while ( currentChar <= (PCHAR)EndOfSourceBuffer &&
                *currentChar != '\0' ) {
            currentChar++;
            length++;
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar > (PCHAR)EndOfSourceBuffer ) {
            return (USHORT)-1;
        }

        //
        // If we overran our storage buffer, this is a bad string.  Return an error
        //
        if( (USHORT)(length + 1)*sizeof(WCHAR) > Destination->MaximumLength ) {
            return (USHORT)-1;
        }

        sourceString.Buffer = Source;
        sourceString.Length = length;

        //
        // Convert the data to unicode.
        //

        Destination->Length = 0;
        RtlOemStringToUnicodeString( Destination, &sourceString, FALSE );

        //
        // Increment 'length', to indicate that the NUL has been copied.
        //

        length++;

    }

    //
    // Return the number of bytes copied from the source buffer.
    //

    return length;

} // SrvGetString

USHORT
SrvGetStringLength (
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN IncludeNullTerminator
    )

/*++

Routine Description:

    This routine returns the length of a string in an SMB buffer in bytes.
    If the end of the buffer is encountered before the NUL terminator,
    the function returns -1 as the length.

Arguments:

    Source - a NUL-terminated input.

    EndOfSourceBuffer - A pointer to the end of the SMB buffer.  Used to
        protect the server from accessing beyond the end of the SMB buffer,
        if the format is invalid.

    SourceIsUnicode - TRUE if the source is already Unicode.

    IncludeNullTerminator - TRUE if the Length to be returned includes the
        null terminator.

Return Value:

    Length - Length of input buffer.  -1 if EndOfSourceBuffer is reached
    before the NUL terminator.

--*/

{
    USHORT length;

    PAGED_CODE( );

    if ( IncludeNullTerminator) {
        length = 1;
    } else {
        length = 0;
    }

    if ( SourceIsUnicode ) {

        PWCH currentChar = (PWCH)Source;

        ASSERT( ((ULONG_PTR)currentChar & 1) == 0 );

        while ( currentChar < (PWCH)EndOfSourceBuffer &&
                *currentChar != UNICODE_NULL ) {
            currentChar++;
            length++;
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar >= (PWCH)EndOfSourceBuffer ) {
            length = (USHORT)-1;
        } else {
            length = (USHORT)(length * sizeof(WCHAR));
        }

    } else {

        PCHAR currentChar = Source;

        while ( currentChar <= (PCHAR)EndOfSourceBuffer &&
                *currentChar != '\0' ) {
            currentChar++;
            length++;
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar > (PCHAR)EndOfSourceBuffer ) {
            length = (USHORT)-1;
        }

    }

    //
    // Return the length of the string.
    //

    return length;

} // SrvGetStringLength


USHORT
SrvGetSubdirectoryLength (
    IN PUNICODE_STRING InputName
    )

/*++

Routine Description:

    This routine finds the length of "subdirectory" information in a
    path name, that is, the parts of the path name that are not the
    actual name of the file.  For example, for a\b\c\filename, it
    returns 5.  This allows the calling routine to open the directory
    containing the file or get a full pathname to a file after a search.

    *** This routine should be used AFTER SrvCanonicalizePathName has
        been used on the path name to ensure that the name is good and
        '..' have been removed.

Arguments:

    InputName - Supplies a pointer to the pathname string.

Return Value:

    The number of bytes that contain directory information.  If the
    input is just a filename, then 0 is returned.

--*/

{
    ULONG i;
    PWCH baseFileName = InputName->Buffer;

    PAGED_CODE( );

    for ( i = 0; i < InputName->Length / sizeof(WCHAR); i++ ) {

        //
        // If s points to a directory separator, set fileBaseName to
        // the character after the separator.
        //

        if ( InputName->Buffer[i] == DIRECTORY_SEPARATOR_CHAR ) {
            baseFileName = &InputName->Buffer[i];
        }

    }

    return (USHORT)((baseFileName - InputName->Buffer) * sizeof(WCHAR));

} // SrvGetSubdirectoryLength


BOOLEAN SRVFASTCALL
SrvIsLegalFatName (
    IN PWSTR InputName,
    IN CLONG InputNameLength
    )

/*++

Routine Description:

    Determines whether a file name would be legal for FAT.  This
    is needed for SrvQueryDirectoryFile because it must filter names
    for clients that do not know about long or non-FAT filenames.

Arguments:

    InputName - Supplies the string to test
    InputNameLength - Length of the string (excluding the NULL termination)
                to test.

Return Value:

    TRUE if the name is a legal FAT name, FALSE if the name would be
    rejected by FAT.

--*/

{
    UNICODE_STRING original_name;

    UNICODE_STRING upcase_name;
    WCHAR          upcase_buffer[ 13 ];

    STRING         oem_string;
    CHAR           oem_buffer[ 13 ];

    UNICODE_STRING converted_name;
    WCHAR          converted_name_buffer[ 13 ];

    BOOLEAN spacesInName, nameValid8Dot3;

    PAGED_CODE();

    //
    // Special case . and .. -- they are legal FAT names
    //
    if( InputName[0] == L'.' ) {

        if( InputNameLength == sizeof(WCHAR) ||
            ((InputNameLength == 2*sizeof(WCHAR)) && InputName[1] == L'.')) {
            return TRUE;
        }

        return FALSE;
    }

    original_name.Buffer = InputName;
    original_name.Length = original_name.MaximumLength = (USHORT)InputNameLength;

    nameValid8Dot3 = RtlIsNameLegalDOS8Dot3( &original_name, NULL, &spacesInName );

    if( !nameValid8Dot3 || spacesInName ) {
        return FALSE;
    }

    if( SrvFilterExtendedCharsInPath == FALSE ) {
        //
        // One final test -- we must be able to convert this name to OEM and back again
        //  without any loss of information.
        //

        oem_string.Buffer = oem_buffer;
        upcase_name.Buffer = upcase_buffer;
        converted_name.Buffer = converted_name_buffer;

        oem_string.MaximumLength = sizeof( oem_buffer );
        upcase_name.MaximumLength = sizeof( upcase_buffer );
        converted_name.MaximumLength = sizeof( converted_name_buffer );

        oem_string.Length = 0;
        upcase_name.Length = 0;
        converted_name.Length = 0;

        nameValid8Dot3 = NT_SUCCESS( RtlUpcaseUnicodeString( &upcase_name, &original_name, FALSE )) &&
            NT_SUCCESS( RtlUnicodeStringToOemString( &oem_string, &upcase_name, FALSE )) &&
            FsRtlIsFatDbcsLegal( oem_string, FALSE, FALSE, FALSE ) &&
            NT_SUCCESS( RtlOemStringToUnicodeString( &converted_name, &oem_string, FALSE )) &&
            RtlEqualUnicodeString( &upcase_name, &converted_name, FALSE );
    }

    return nameValid8Dot3;

} // SrvIsLegalFatName

NTSTATUS
SrvMakeUnicodeString (
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PUSHORT SourceLength OPTIONAL
    )

/*++

Routine Description:

    Makes a unicode string from a zero-terminated input that is either
    ANSI or Unicode.

Arguments:

    SourceIsUnicode - TRUE if the source is already Unicode.  If FALSE,
        RtlOemStringToUnicodeString will allocate space to hold the
        Unicode string; it is the responsibility of the caller to
        free this space.

    Destination - the resultant Unicode string.

    Source - a zero-terminated input.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    OEM_STRING oemString;

    PAGED_CODE( );

    if ( SourceIsUnicode ) {

        ASSERT( ((ULONG_PTR)Source & 1) == 0 );

        if ( ARGUMENT_PRESENT( SourceLength ) ) {
            ASSERT( (*SourceLength) != (USHORT) -1 );
            Destination->Buffer = Source;
            Destination->Length = *SourceLength;
            Destination->MaximumLength = *SourceLength;
        } else {
            RtlInitUnicodeString( Destination, Source );
        }

        return STATUS_SUCCESS;
    }

    if ( ARGUMENT_PRESENT( SourceLength ) ) {
        oemString.Buffer = Source;
        oemString.Length = *SourceLength;
        oemString.MaximumLength = *SourceLength;
    } else {
        RtlInitString( &oemString, Source );
    }

    return RtlOemStringToUnicodeString(
               Destination,
               &oemString,
               TRUE
               );

} // SrvMakeUnicodeString


VOID
SrvReleaseContext (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function releases (dereferences) control blocks referenced by a
    Work Context block.  It is called when processing of an incoming SMB
    is complete, just before the response SMB (if any) is set.

    The following control blocks are dereferenced: Share, Session,
    TreeConnect, and File.  If any of these fields is nonzero in
    WorkContext, the block is dereferenced and the fields is zeroed.

    Note that the Connection block and the Endpoint block are NOT
    dereferenced.  This is based on the assumption that a response is
    about to be sent, so the connection must stay referenced.  The
    Connection block is dereferenced after the send of the response (if
    any) when SrvRequeueReceiveIrp is called.  That function also
    releases the response buffer, if it is different from the request
    buffer.

Arguments:

    WorkContext - Supplies a pointer to a work context block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // !!! If you change the way this routine works (e.g., you add
    //     another block that needs to be dereferenced), make sure you
    //     check fsd.c\SrvFsdRestartSmbComplete to see if it needs to be
    //     changed too.
    //

    //
    // Dereference the Share block, if any.
    //

    if ( WorkContext->Share != NULL ) {
        SrvDereferenceShare( WorkContext->Share );
        WorkContext->Share = NULL;
    }

    //
    // Dereference the Session block, if any.
    //

    if ( WorkContext->Session != NULL ) {
        SrvDereferenceSession( WorkContext->Session );
        WorkContext->Session= NULL;
    }

    //
    // Dereference the Tree Connect block, if any.
    //

    if ( WorkContext->TreeConnect != NULL ) {
        SrvDereferenceTreeConnect( WorkContext->TreeConnect );
        WorkContext->TreeConnect = NULL;
    }

    //
    // Dereference the RFCB, if any.
    //

    if ( WorkContext->Rfcb != NULL ) {
        SrvDereferenceRfcb( WorkContext->Rfcb );
        WorkContext->OplockOpen = FALSE;
        WorkContext->Rfcb = NULL;
    }

    //
    // Dereference the wait for oplock break, if any
    //

    if ( WorkContext->WaitForOplockBreak != NULL ) {
        SrvDereferenceWaitForOplockBreak( WorkContext->WaitForOplockBreak );
        WorkContext->WaitForOplockBreak = NULL;
    }

    //
    // If this was a blocking operation, update the blocking i/o count.
    //

    if ( WorkContext->BlockingOperation ) {
        InterlockedDecrement( &SrvBlockingOpsInProgress );
        WorkContext->BlockingOperation = FALSE;
    }

    return;

} // SrvReleaseContext


BOOLEAN
SrvSetFileWritethroughMode (
    IN PLFCB Lfcb,
    IN BOOLEAN Writethrough
    )

/*++

Routine Description:

    Sets the writethrough mode of a file as specified.  Returns the
    original mode of the file.

Arguments:

    Lfcb - A pointer to the LFCB representing the open file.

    Writethrough - A boolean indicating whether the file is to be placed
        into writethrough mode (TRUE) or writebehind mode (FALSE).

Return Value:

    BOOLEAN - Returns the original mode of the file.

--*/

{
    FILE_MODE_INFORMATION modeInformation;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // If the file is already in the correct mode, simply return.
    // Otherwise, set the file to the correct mode.
    //

    if ( Writethrough ) {

        if ( (Lfcb->FileMode & FILE_WRITE_THROUGH) != 0 ) {
            return TRUE;
        } else {
            Lfcb->FileMode |= FILE_WRITE_THROUGH;
        }

    } else {

        if ( (Lfcb->FileMode & FILE_WRITE_THROUGH) == 0 ) {
            return FALSE;
        } else {
            Lfcb->FileMode &= ~FILE_WRITE_THROUGH;
        }

    }

    //
    // Change the file mode.
    //
    // !!! Don't do this by file handle -- build and issue an IRP using
    //     the file object pointer directly.
    //

    modeInformation.Mode = Lfcb->FileMode;

    (VOID)NtSetInformationFile(
            Lfcb->FileHandle,
            &iosb,
            &modeInformation,
            sizeof( modeInformation ),
            FileModeInformation
            );

    //
    // Return the original mode of the file, which was the opposite of
    // what was requested.
    //

    return (BOOLEAN)!Writethrough;

} // SrvSetFileWritethroughMode

VOID
SrvOemStringTo8dot3 (
    IN POEM_STRING InputString,
    OUT PSZ Output8dot3
    )

/*++

Routine Description:

    Convert a string into FAT 8.3 format.  This derived from GaryKi's
    routine FatStringTo8dot3 in fastfat\namesup.c.

Arguments:

    InputString - Supplies the input string to convert

    Output8dot3 - Receives the converted string.  The memory must be
        supplied by the caller.

Return Value:

    None.

--*/
{
    CLONG i, j;
    PCHAR inBuffer = InputString->Buffer;
    ULONG inLength = InputString->Length;

    PAGED_CODE( );

    ASSERT( inLength <= 12 );

    //
    // First make the output name all blanks.
    //

    RtlFillMemory( Output8dot3, 11, CHAR_SP );

    //
    // If we get "." or "..", just return them.  They do not follow
    // the usual rules for FAT names.
    //

    if( inBuffer[0] == '.' ) {
        if( inLength == 1 ) {
            Output8dot3[0] = '.';
            return;
        }

        if( inLength == 2 && inBuffer[1] == '.' ) {
            Output8dot3[0] = '.';
            Output8dot3[1] = '.';
            return;
        }
    }

    //
    // Copy over the first part of the file name.  Stop when we get to
    // the end of the input string or a dot.
    //

    if (NLS_MB_CODE_PAGE_TAG) {

        for ( i = 0;
              (i < inLength) && (inBuffer[i] != '.') && (inBuffer[i] != '\\');
              i++ ) {

            if (FsRtlIsLeadDbcsCharacter(inBuffer[i])) {

                if (i+1 < inLength) {
                    Output8dot3[i] = inBuffer[i];
                    i++;
                    Output8dot3[i] = inBuffer[i];
                } else {
                    break;
                }

            } else {

                Output8dot3[i] = inBuffer[i];
            }
        }

    } else {

        for ( i = 0;
              (i < inLength) && (inBuffer[i] != '.') && (inBuffer[i] != '\\');
              i++ ) {

            Output8dot3[i] = inBuffer[i];
        }

    }

    //
    // See if we need to add an extension.
    //

    if ( i < inLength ) {

        //
        // Skip over the dot.
        //

        ASSERT( (inLength - i) <= 4 );
        ASSERT( inBuffer[i] == '.' );

        i++;

        //
        // Add the extension to the output name
        //

        if (NLS_MB_CODE_PAGE_TAG) {

            for ( j = 8;
                  (i < inLength) && (inBuffer[i] != '\\');
                  i++, j++ ) {

                if (FsRtlIsLeadDbcsCharacter(inBuffer[i])) {

                    if (i+1 < inLength) {
                        Output8dot3[j] = inBuffer[i];
                        i++; j++;
                        Output8dot3[j] = inBuffer[i];
                    } else {
                        break;
                    }

                } else {

                    Output8dot3[j] = inBuffer[i];

                }
            }

        } else {

            for ( j = 8;
                  (i < inLength) && (inBuffer[i] != '\\');
                  i++, j++ ) {

                Output8dot3[j] = inBuffer[i];
            }
        }
    }

    //
    // We're all done with the conversion.
    //

    return;

} // SrvOemStringTo8dot3


VOID
SrvUnicodeStringTo8dot3 (
    IN PUNICODE_STRING InputString,
    OUT PSZ Output8dot3,
    IN BOOLEAN Upcase
    )

/*++

Routine Description:

    Convert a string into fat 8.3 format.  This derived from GaryKi's
    routine FatStringTo8dot3 in fat\fatname.c.

Arguments:

    InputString - Supplies the input string to convert

    Output8dot3 - Receives the converted string, the memory must be supplied
        by the caller.

    Upcase - Whether the string is to be uppercased.

Return Value:

    None.

--*/

{
    ULONG oemSize;
    OEM_STRING oemString;
    ULONG index = 0;
    UCHAR aSmallBuffer[ 50 ];
    NTSTATUS status;

    PAGED_CODE( );

    oemSize = RtlUnicodeStringToOemSize( InputString );

    ASSERT( oemSize < MAXUSHORT );

    if( oemSize <= sizeof( aSmallBuffer ) ) {
        oemString.Buffer = aSmallBuffer;
    } else {
        oemString.Buffer = ALLOCATE_HEAP( oemSize, BlockTypeBuffer );
        if( oemString.Buffer == NULL ) {
           *Output8dot3 = '\0';
            return;
        }
    }

    oemString.MaximumLength = (USHORT)oemSize;
    oemString.Length = (USHORT)oemSize - 1;

    if ( Upcase ) {

        status = RtlUpcaseUnicodeToOemN(
                    oemString.Buffer,
                    oemString.Length,
                    &index,
                    InputString->Buffer,
                    InputString->Length
                    );

        ASSERT( NT_SUCCESS( status ) );


    } else {

        status = RtlUnicodeToOemN(
                    oemString.Buffer,
                    oemString.Length,
                    &index,
                    InputString->Buffer,
                    InputString->Length
                    );

        ASSERT( NT_SUCCESS( status ) );
    }

    if( NT_SUCCESS( status ) ) {

        oemString.Buffer[ index ] = '\0';

        SrvOemStringTo8dot3(
                    &oemString,
                    Output8dot3
                    );
    } else {

        *Output8dot3 = '\0';
    }

    if( oemSize > sizeof( aSmallBuffer ) ) {
        FREE_HEAP( oemString.Buffer );
    }

} // SrvUnicodeStringTo8dot3

#if SRVDBG_STATS
VOID SRVFASTCALL
SrvUpdateStatistics2 (
    PWORK_CONTEXT WorkContext,
    UCHAR SmbCommand
    )

/*++

Routine Description:

    Update the server statistics database to reflect the work item
    that is being completed.

Arguments:

    WorkContext - pointer to the work item containing the statistics
        for this request.

    SmbCommand - The SMB command code of the current operation.

Return Value:

    None.

--*/

{
    if ( WorkContext->StartTime != 0 ) {

        LARGE_INTEGER td;

        td.QuadPart = WorkContext->CurrentWorkQueue->stats.SystemTime - WorkContext->StartTime;

        //
        // Update the SMB-specific statistics fields.
        //
        // !!! doesn't work for original transact smb--SmbCommand is too
        //     large.

        //ASSERT( SmbCommand <= MAX_STATISTICS_SMB );

        if ( SmbCommand <= MAX_STATISTICS_SMB ) {
            SrvDbgStatistics.Smb[SmbCommand].SmbCount++;
            SrvDbgStatistics.Smb[SmbCommand].TotalTurnaroundTime.QuadPart +=
                td.QuadPart;
        }

#if 0 // this code is no longer valid!
        //
        // Update the size-dependent IO fields if necessary.  The arrays
        // in SrvStatistics correspond to powers of two sizes for the IO.
        // The correspondence between array location and IO size is:
        //
        //     Location        IO Size (min)
        //        0                  0
        //        1                  1
        //        2                  2
        //        3                  4
        //        4                  8
        //        5                 16
        //        6                 32
        //        7                 64
        //        8                128
        //        9                256
        //       10                512
        //       11               1024
        //       12               2048
        //       13               4096
        //       14               8192
        //       15              16384
        //       16              32768
        //

        if ( WorkContext->BytesRead != 0 ) {

            CLONG i;

            for ( i = 0;
                  i < 17 && WorkContext->BytesRead != 0;
                  i++, WorkContext->BytesRead >>= 1 );

            SrvDbgStatistics.ReadSize[i].SmbCount++;
            SrvDbgStatistics.ReadSize[i].TotalTurnaroundTime.QuadPart +=
                td.QuadPart;
        }

        if ( WorkContext->BytesWritten != 0 ) {

            CLONG i;

            for ( i = 0;
                  i < 17 && WorkContext->BytesWritten != 0;
                  i++, WorkContext->BytesWritten >>= 1 );

            SrvDbgStatistics.WriteSize[i].SmbCount++;
            SrvDbgStatistics.WriteSize[i].TotalTurnaroundTime.QuadPart +=
                td.QuadPart;
        }
#endif

    }

    return;

} // SrvUpdateStatistics2
#endif // SRVDBG_STATS


PRFCB
SrvVerifyFid2 (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    IN BOOLEAN FailOnSavedError,
    IN PRESTART_ROUTINE SerializeWithRawRestartRoutine OPTIONAL,
    OUT PNTSTATUS NtStatus
    )

/*++

Routine Description:

    Verifies the FID, TID, and UID in an incoming SMB.  If they are
    valid, the address of the RFCB corresponding to the FID is returned,
    and the block is referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate file table.  If the FID is valid,
        the RFCB address is stored in WorkContext->Rfcb.

    Fid - Supplies the FID sent in the request SMB

    FailOnSavedError - If TRUE, return NULL to the caller if there is
        an outstanding write behind error.  If FALSE, always attempt
        to return a pointer to the RFCB.

    SerializeWithRawRestartRoutine - If not NULL, is the address of an
        FSP restart routine, and specifies that this operation should be
        queued if a raw write is currently in progress on the file.  If
        this is the case, this routine queues the work context block to
        a queue in the RFCB.  When the raw write completes, all work
        items on the queue are restarted.

    NtStatus - This field is filled in only when this function returns
        NULL.  If there was a write behind error, NtStatus returns the
        write behind error status, otherwise it returns
        STATUS_INVALID_HANDLE.

Return Value:

    PRFCB - Address of the RFCB, or SRV_INVALID_RFCB_POINTER if the Fid
        was invalid, or if there is a raw write in progress and
        serialization was requested (in which case *NtStatus is set
        to STATUS_SUCCESS).

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PRFCB rfcb;
    USHORT index;
    USHORT sequence;
    KIRQL oldIrql;

#if 0
    // THIS IS NOW DONE IN THE SrvVerifyFid MACRO.
    //
    // If the FID has already been verified, return the RFCB pointer.
    //
    // *** Note that we don't do the saved error checking or the raw
    //     write serialization in this case, on the assumption that
    //     since we already passed the checks once (in order to get the
    //     RFCB pointer in the first place), we don't need to do them
    //     again.
    //

    if ( WorkContext->Rfcb != NULL ) {
        return WorkContext->Rfcb;
    }
#endif

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the FID into its components.
    //

    connection = WorkContext->Connection;

    //
    // Acquire the spin lock that guards the connection's file table.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // See if this is the cached rfcb
    //

    if ( connection->CachedFid == (ULONG)Fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        //
        // Verify that the FID is in range, is in use, and has the correct
        // sequence number.

        index = FID_INDEX( Fid );
        sequence = FID_SEQUENCE( Fid );
        tableHeader = &connection->FileTable;

        if ( (index >= tableHeader->TableSize) ||
             (tableHeader->Table[index].Owner == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        rfcb = tableHeader->Table[index].Owner;

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        //
        // If the caller wants to fail when there is a write behind
        // error and the error exists, fill in NtStatus and do not
        // return the RFCB pointer.
        //

        if ( !NT_SUCCESS(rfcb->SavedError) && FailOnSavedError ) {

            if ( !NT_SUCCESS(rfcb->SavedError) ) {
                *NtStatus = rfcb->SavedError;
                rfcb->SavedError = STATUS_SUCCESS;
                goto error_exit;
            }
        }

        //
        // Cache the fid.
        //

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)Fid;
    }

    //
    // The FID is valid within the context of this connection.  Verify
    // that the owning tree connect's TID is correct.
    //
    // Do not verify the UID for clients that do not understand it.
    //

    if ( (rfcb->Tid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )) ||
         ((rfcb->Uid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )) &&
           DIALECT_HONORS_UID(connection->SmbDialect)) ) {

        *NtStatus = STATUS_INVALID_HANDLE;
        goto error_exit;
    }

    //
    // If raw write serialization was requested, and a raw write
    // is active, queue this work item in the RFCB pending
    // completion of the raw write.
    //

    if ( (rfcb->RawWriteCount != 0) &&
         ARGUMENT_PRESENT(SerializeWithRawRestartRoutine) ) {

        InsertTailList(
            &rfcb->RawWriteSerializationList,
            &WorkContext->ListEntry
            );

        WorkContext->FspRestartRoutine = SerializeWithRawRestartRoutine;
        *NtStatus = STATUS_SUCCESS;
        goto error_exit;
    }

    //
    // The file is active and the TID is valid.  Reference the
    // RFCB.  Release the spin lock (we don't need it anymore).
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    //
    // Save the RFCB address in the work context block and
    // return the file address.
    //

    WorkContext->Rfcb = rfcb;

    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    ASSERT( GET_BLOCK_TYPE( rfcb->Mfcb ) == BlockTypeMfcb );

    return rfcb;

error_exit:

    //
    // Either the FID is invalid for this connection, the file is
    // closing, or the TID doesn't match.  Release the lock, clear the
    // file address in the work context block, and return a file address
    // of NULL.
    //

    WorkContext->Rfcb = NULL;   // connection spinlock must be held
    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return SRV_INVALID_RFCB_POINTER;

} // SrvVerifyFid2


PRFCB
SrvVerifyFidForRawWrite (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    OUT PNTSTATUS NtStatus
    )

/*++

Routine Description:

    Verifies the FID, TID, and UID in an incoming SMB.  If they are
    valid, the address of the RFCB corresponding to the FID is returned,
    and the block is referenced.  In addition, the RawWriteCount in the
    RFCB is incremented.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate file table.  If the FID is valid,
        the RFCB address is stored in WorkContext->Rfcb.

    Fid - Supplies the FID sent in the request SMB

    NtStatus - This field is filled in only when this function returns
        NULL.  If there was a write behind error, NtStatus returns the
        write behind error status, otherwise it returns
        STATUS_INVALID_HANDLE.

Return Value:

    PRFCB - Address of the RFCB, or SRV_INVALID_RFCB_POINTER if the Fid
        was invalid, or if there is a raw write in progress and
        serialization was requested (in which case *NtStatus is set
        to STATUS_SUCCESS).

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PRFCB rfcb;
    USHORT index;
    USHORT sequence;
    KIRQL oldIrql;

    ASSERT( WorkContext->Rfcb == NULL );

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the FID into its components.
    //

    connection = WorkContext->Connection;

    //
    // Acquire the spin lock that guards the connection's file table.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // See if this is the cached rfcb
    //

    if ( connection->CachedFid == Fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        //
        // Verify that the FID is in range, is in use, and has the correct
        // sequence number.

        index = FID_INDEX( Fid );
        sequence = FID_SEQUENCE( Fid );
        tableHeader = &connection->FileTable;

        if ( (index >= tableHeader->TableSize) ||
             (tableHeader->Table[index].Owner == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        rfcb = tableHeader->Table[index].Owner;

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        //
        // If there is a write behind error, fill in NtStatus and do
        // not return the RFCB pointer.
        //

        if ( !NT_SUCCESS( rfcb->SavedError ) ) {
            if ( !NT_SUCCESS( rfcb->SavedError ) ) {
                *NtStatus = rfcb->SavedError;
                rfcb->SavedError = STATUS_SUCCESS;
                goto error_exit;
            }
        }

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)Fid;

        //
        // The FID is valid within the context of this connection.  Verify
        // that the owning tree connect's TID is correct.
        //
        // Do not verify the UID for clients that do not understand it.
        //

        if ( (rfcb->Tid !=
                 SmbGetAlignedUshort(&WorkContext->RequestHeader->Tid)) ||
             ( (rfcb->Uid !=
                 SmbGetAlignedUshort(&WorkContext->RequestHeader->Uid)) &&
               DIALECT_HONORS_UID(connection->SmbDialect) ) ) {
            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }
    }

    //
    // If a raw write is already active, queue this work item in
    // the RFCB pending completion of the raw write.
    //

    if ( rfcb->RawWriteCount != 0 ) {

        InsertTailList(
            &rfcb->RawWriteSerializationList,
            &WorkContext->ListEntry
            );

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        *NtStatus = STATUS_SUCCESS;
        goto error_exit;
    }

    //
    // The file is active and the TID is valid.  Reference the
    // RFCB and increment the raw write count.  Release the spin
    // lock (we don't need it anymore).
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    rfcb->RawWriteCount++;

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    //
    // Save the RFCB address in the work context block and
    // return the file address.
    //

    WorkContext->Rfcb = rfcb;
    ASSERT( GET_BLOCK_TYPE( rfcb->Mfcb ) == BlockTypeMfcb );

    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    return rfcb;

error_exit:

    //
    // Either the FID is invalid for this connection, the file is
    // closing, or the TID and UID don't match.  Clear the file address
    // in the work context block, and return a file address of NULL.
    //

    WorkContext->Rfcb = NULL;   // connection spinlock must be held
    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return SRV_INVALID_RFCB_POINTER;

} // SrvVerifyFidForRawWrite


PSEARCH
SrvVerifySid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Index,
    IN USHORT Sequence,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize
    )

/*++

Routine Description:

    Verifies the SID in the resume key of a Search or Find SMB.  If the
    SID is valid, the address of the search block corresponding to the
    SID is returned.  The appropiate fields in the DirectoryInformation
    structure are filled in so that SrvQueryDirectoryFile may be called.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate search table.

    ResumeKey - a pointer the the resume key to evaluate.

Return Value:

    PSEARCH - address of the Search block, or NULL.

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PSEARCH search;

    PAGED_CODE( );

    connection = WorkContext->Connection;

    //
    // Acquire the connection's lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Verify that the index is in range, that the search block is in use,
    // and that the resume key has the correct sequence number.
    //

    tableHeader = &connection->PagedConnection->SearchTable;
    if ( (Index < tableHeader->TableSize) &&
         (tableHeader->Table[Index].Owner != NULL) &&
         (tableHeader->Table[Index].SequenceNumber == Sequence) ) {

        search = tableHeader->Table[Index].Owner;

        //
        // The SID is valid.  Verify that the search block is still
        // active.
        //
        // !!! Does this really apply for search blocks?
        //

        if ( GET_BLOCK_STATE(search) != BlockStateActive || search->InUse ) {

            //
            // The search block is no longer active or somebody is
            // already using the search block.
            //

            search = NULL;

        } else {

            //
            // We found a legitimate search block, so reference it.
            //

            SrvReferenceSearch( search );

            //
            // Fill in fields of DirectoryInformation.
            //

            DirectoryInformation->DirectoryHandle = search->DirectoryHandle;
            DirectoryInformation->CurrentEntry = NULL;
            DirectoryInformation->BufferLength = BufferSize -
                sizeof(SRV_DIRECTORY_INFORMATION);
            DirectoryInformation->Wildcards = search->Wildcards;
            DirectoryInformation->ErrorOnFileOpen = FALSE;

            //
            // Indicate that the search is being used.
            //

            search->InUse = TRUE;
        }

    } else {

        //
        // The SID is invalid.
        //

        search = NULL;

    }

    //
    // Release the lock and return the search block address (or NULL).
    //

    RELEASE_LOCK( &connection->Lock );

    return search;

} // SrvVerifySid


PTREE_CONNECT
SrvVerifyTid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Tid
    )

/*++

Routine Description:

    Verifies the TID in an incoming SMB.  If the TID is valid, the
    address of the tree connect block corresponding to the TID is
    returned, and the block is referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate tree table.  Also, the tree connect
        block address, if the TID is valid, is stored in
        WorkContext->TreeConnect.

    Tid - Supplies the TID sent in the request SMB

Return Value:

    PTREE_CONNECT - Address of the tree connect block, or NULL

--*/

{
    PCONNECTION connection;
    PTREE_CONNECT treeConnect;
    PTABLE_HEADER tableHeader;
    USHORT index;
    USHORT sequence;

    PAGED_CODE( );

    //
    // If the TID has already been verified, return the tree connect
    // pointer.
    //

    if ( WorkContext->TreeConnect != NULL ) {
        return WorkContext->TreeConnect;
    }

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the TID into its components.
    //

    connection = WorkContext->Connection;
    index = TID_INDEX( Tid );
    sequence = TID_SEQUENCE( Tid );

    //
    // Acquire the connection's tree connect lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Verify that the TID is in range, is in use, and has the correct
    // sequence number.

    tableHeader = &connection->PagedConnection->TreeConnectTable;
    if ( (index < tableHeader->TableSize) &&
         (tableHeader->Table[index].Owner != NULL) &&
         (tableHeader->Table[index].SequenceNumber == sequence) ) {

        treeConnect = tableHeader->Table[index].Owner;

        //
        // The TID is valid within the context of this connection.
        // Verify that the tree connect is still active.
        //

        if ( GET_BLOCK_STATE(treeConnect) == BlockStateActive ) {

            //
            // The tree connect is active.  Reference it.
            //

            SrvReferenceTreeConnect( treeConnect );

        } else {

            //
            // The tree connect is closing.
            //

            treeConnect = NULL;

        }

    } else {

        //
        // The TID is invalid for this connection.
        //

        treeConnect = NULL;

    }

    //
    // Release the lock, save the tree connect address in the work context
    // block, and return the tree connect address (or NULL).
    //

    RELEASE_LOCK( &connection->Lock );

    WorkContext->TreeConnect = treeConnect;

    return treeConnect;

} // SrvVerifyTid


PSESSION
SrvVerifyUid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Uid
    )

/*++

Routine Description:

    Verifies the UID in an incoming SMB.  If the UID is valid, the
    address of the session block corresponding to the UID is returned,
    and the block is referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate user table.  Also, the session block
        address, if the UID is valid, is stored in WorkContext->Session.

    Uid - Supplies the UID sent in the request SMB

Return Value:

    PSESSION - Address of the session block, or NULL

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PSESSION session;
    USHORT index;
    USHORT sequence;

    PAGED_CODE( );

    //
    // If the UID has already been verified, return the session pointer.
    //

    if ( WorkContext->Session != NULL ) {
        return WorkContext->Session;
    }

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the UID into its components.
    //

    connection = WorkContext->Connection;
    index = UID_INDEX( Uid );
    sequence = UID_SEQUENCE( Uid );

    //
    // Acquire the connection's session lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // If this is a down-level (LAN Man 1.0 or earlier) client, than
    // we will not receive a UID, and there will only be one session
    // per connection.  Reference that session.
    //

    tableHeader = &connection->PagedConnection->SessionTable;
    if (!DIALECT_HONORS_UID(connection->SmbDialect) ) {

        session = tableHeader->Table[0].Owner;

    } else if ( (index < tableHeader->TableSize) &&
         (tableHeader->Table[index].Owner != NULL) &&
         (tableHeader->Table[index].SequenceNumber == sequence) ) {

        //
        // The UID is in range, is in use, and has the correct sequence
        // number.
        //

        session = tableHeader->Table[index].Owner;

    } else {

        //
        // The UID is invalid for this connection.
        //

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvVerifyUid: index %d, size %d\n", index, tableHeader->TableSize ));
            if( index < tableHeader->TableSize ) {
                KdPrint(("    Owner %p, Table.SequenceNumber %d, seq %d\n",
                    tableHeader->Table[index].Owner,
                    tableHeader->Table[index].SequenceNumber,
                    sequence
                ));
            }
        }

        session = NULL;
    }

    if ( session != NULL ) {

        //
        // The UID is valid within the context of this connection.
        // Verify that the session is still active.
        //

        if ( GET_BLOCK_STATE(session) == BlockStateActive ) {

            LARGE_INTEGER liNow;

            KeQuerySystemTime( &liNow);

            if( session->LogonSequenceInProgress == FALSE &&
                liNow.QuadPart >= session->LogOffTime.QuadPart )
            {
                IF_DEBUG( ERRORS ) {
                    KdPrint(( "SrvVerifyUid: LogOffTime has passed %x %x\n",
                        session->LogOffTime.HighPart,
                        session->LogOffTime.LowPart
                    ));
                }

                // Mark the session as expired
                session->IsSessionExpired = TRUE;
                KdPrint(( "Marking session as expired.\n" ));
            }

            //
            // The session is active.  Reference it.
            //

            SrvReferenceSession( session );

            //
            // Update the last use time for autologoff.
            //

            session->LastUseTime = liNow;

        } else {

            //
            // The session is closing.
            //

            IF_DEBUG( ERRORS ) {
                KdPrint(( "SrvVerifyUid: Session state %x\n",  GET_BLOCK_STATE( session ) ));
            }

            session = NULL;
        }
    }

    //
    // Release the lock, save the session address in the work context
    // block, and return the session address (or NULL).
    //

    RELEASE_LOCK( &connection->Lock );

    WorkContext->Session = session;

    return session;

} // SrvVerifyUid


NTSTATUS
SrvVerifyUidAndTid (
    IN  PWORK_CONTEXT WorkContext,
    OUT PSESSION *Session,
    OUT PTREE_CONNECT *TreeConnect,
    IN  SHARE_TYPE ShareType
    )

/*++

Routine Description:

    Verifies the UID and TID in an incoming SMB.  If both the UID and
    the TDI are valid, the addresses of the session/tree connect blocks
    corresponding to the UID/TID are returned, and the blocks are
    referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate user table.  If the UID and TID are
        valid, the session/tree connect block addresses are stored in
        WorkContext->Session and WorkContext->TreeConnect.

    Uid - Supplies the UID sent in the request SMB

    Tid - Supplies the TID sent in the request SMB

    Session - Returns a pointer to the session block

    TreeConnect - Returns a pointer to the tree connect block

    ShareType - the type of share it should be

Return Value:

    NTSTATUS - STATUS_SUCCESS, STATUS_SMB_BAD_UID, or STATUS_SMB_BAD_TID

--*/

{
    PCONNECTION connection;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_HEADER tableHeader;
    USHORT index;
    USHORT Uid;
    USHORT Tid;
    USHORT sequence;
    LARGE_INTEGER liNow;

    PAGED_CODE( );

    //
    // If the UID and TID have already been verified, don't do all this
    // work again.
    //

    if ( (WorkContext->Session != NULL) &&
         (WorkContext->TreeConnect != NULL) ) {

        if( ShareType != ShareTypeWild &&
            WorkContext->TreeConnect->Share->ShareType != ShareType ) {
            return STATUS_ACCESS_DENIED;
        }

        *Session = WorkContext->Session;
        *TreeConnect = WorkContext->TreeConnect;

        return STATUS_SUCCESS;
    }

    //
    // Obtain the connection block address and lock the connection.
    //

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    ACQUIRE_LOCK( &connection->Lock );

    //
    // If we haven't negotiated successfully with this client, then we have
    //  a failure
    //
    if( connection->SmbDialect == SmbDialectIllegal) {
        RELEASE_LOCK( &connection->Lock );
        return STATUS_INVALID_SMB;
    }

    //
    // If the UID has already been verified, don't verify it again.
    //

    if ( WorkContext->Session != NULL ) {

        session = WorkContext->Session;

    } else {

        //
        // Crack the UID into its components.
        //

        Uid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ),
        index = UID_INDEX( Uid );
        sequence = UID_SEQUENCE( Uid );

        //
        // If this is a down-level (LAN Man 1.0 or earlier) client, than
        // we will not receive a UID, and there will only be one session
        // per connection.  Reference that session.
        //
        // For clients that do send UIDs, verify that the UID is in
        // range, is in use, and has the correct sequence number, and
        // that the session is not closing.
        //

        tableHeader = &pagedConnection->SessionTable;


        if (!DIALECT_HONORS_UID(connection->SmbDialect))
        {
            session = tableHeader->Table[0].Owner;
        }
        else if( (index >= tableHeader->TableSize) ||
                 ((session = tableHeader->Table[index].Owner) == NULL) ||
                 (tableHeader->Table[index].SequenceNumber != sequence) ||
                 (GET_BLOCK_STATE(session) != BlockStateActive) )
        {

            //
            // The UID is invalid for this connection, or the session is
            // closing.
            //

            RELEASE_LOCK( &connection->Lock );

            return STATUS_SMB_BAD_UID;

        }

        //
        // it's valid
        //

        KeQuerySystemTime(&liNow);

        if( session == NULL )
        {
            RELEASE_LOCK( &connection->Lock );

            return STATUS_SMB_BAD_UID;
        }

        if( session->LogonSequenceInProgress == FALSE &&
            liNow.QuadPart >= session->LogOffTime.QuadPart )
        {
            // Mark the session as expired
            session->IsSessionExpired = TRUE;
        }

    }

    //
    // The UID is valid.  Check the TID.  If the TID has already been
    // verified, don't verify it again.
    //

    if ( WorkContext->TreeConnect != NULL ) {

        treeConnect = WorkContext->TreeConnect;

    } else {

        //
        // Crack the TID into its components.
        //

        Tid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ),
        index = TID_INDEX( Tid );
        sequence = TID_SEQUENCE( Tid );

        //
        // Verify that the TID is in range, is in use, and has the
        // correct sequence number, and that the tree connect is not
        // closing.
        //

        tableHeader = &pagedConnection->TreeConnectTable;
        if ( (index >= tableHeader->TableSize) ||
             ((treeConnect = tableHeader->Table[index].Owner) == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ||
             (GET_BLOCK_STATE(treeConnect) != BlockStateActive) ) {

            //
            // The TID is invalid for this connection, or the tree
            // connect is closing.
            //

            RELEASE_LOCK( &connection->Lock );

            return STATUS_SMB_BAD_TID;

        }

        //
        // Make sure this is not a Null session trying to sneak in
        // through an established tree connect.
        //

        if ( session->IsNullSession &&
             SrvRestrictNullSessionAccess &&
             ( treeConnect->Share->ShareType != ShareTypePipe ) ) {


            BOOLEAN matchFound = FALSE;
            ULONG i;

            ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

            for ( i = 0; SrvNullSessionShares[i] != NULL ; i++ ) {

                if ( _wcsicmp(
                        SrvNullSessionShares[i],
                        treeConnect->Share->ShareName.Buffer
                        ) == 0 ) {

                    matchFound = TRUE;
                    break;
                }
            }

            RELEASE_LOCK( &SrvConfigurationLock );

            //
            // The null session is not allowed to access this share - reject.
            //

            if ( !matchFound ) {

                RELEASE_LOCK( &connection->Lock );
                return(STATUS_ACCESS_DENIED);
            }
        }
    }

    //
    // Both the UID and the TID are valid.  Reference the session and
    // tree connect blocks.
    //

    if ( WorkContext->Session == NULL ) {

        SrvReferenceSession( session );
        WorkContext->Session = session;

        //
        // Update the last use time for autologoff.
        //

        session->LastUseTime = liNow;

    }

    if ( WorkContext->TreeConnect == NULL ) {

        SrvReferenceTreeConnect( treeConnect );
        WorkContext->TreeConnect = treeConnect;

    }

    //
    // Release the connection lock and return success.
    //

    RELEASE_LOCK( &connection->Lock );

    *Session = session;
    *TreeConnect = treeConnect;

    //
    // Make sure this is the correct type of share
    //
    if( ShareType != ShareTypeWild && (*TreeConnect)->Share->ShareType != ShareType ) {
        return STATUS_ACCESS_DENIED;
    }

    return STATUS_SUCCESS;

} // SrvVerifyUidAndTid


BOOLEAN
SrvReceiveBufferShortage (
    VOID
    )

/*++

Routine Description:

    This function calculates if the server is running low on receive
    work items that are not involved in blocking operations.

Arguments:

    None.

Return Value:

    TRUE - The server is running short on receive work items.
    FALSE - The server is *not* running short on receive work items.

--*/

{
    KIRQL oldIrql;
    BOOLEAN bufferShortage;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    //
    // Even if we have reached our limit, we will allow this blocking
    // operation if we have enough free work items to allocate.  This
    // will allow the resource thread to allocate more work items to
    // service blocking requests.
    //

    if ( (queue->FreeWorkItems < queue->MaximumWorkItems) ||
         ((queue->FreeWorkItems - SrvBlockingOpsInProgress)
                                 > SrvMinFreeWorkItemsBlockingIo) ) {

        //
        // The caller will start a blocking operation.  Increment the
        // blocking operation count.
        //

        InterlockedIncrement( &SrvBlockingOpsInProgress );
        bufferShortage = FALSE;

    } else {

        //
        // The server is running short on uncommitted receive work items.
        //

        bufferShortage = TRUE;
    }

    return bufferShortage;

} // SrvReceiveBufferShortage

#if SMBDBG

//
// The following functions are defined in smbgtpt.h.  When debug mode is
// disabled (!SMBDBG), these functions are instead defined as macros.
//

USHORT
SmbGetUshort (
    IN PSMB_USHORT SrcAddress
    )

{
    return (USHORT)(
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 )
            );
}

USHORT
SmbGetAlignedUshort (
    IN PUSHORT SrcAddress
    )

{
    return *(SrcAddress);
}

VOID
SmbPutUshort (
    OUT PSMB_USHORT DestAddress,
    IN USHORT Value
    )

{
    ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);
    ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);
    return;
}

VOID
SmbPutAlignedUshort (
    OUT PUSHORT DestAddress,
    IN USHORT Value
    )

{
    *(DestAddress) = (Value);
    return;
}

ULONG
SmbGetUlong (
    IN PSMB_ULONG SrcAddress
    )

{
    return (ULONG)(
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 ) |
            ( ( (PUCHAR)(SrcAddress) )[2] << 16 ) |
            ( ( (PUCHAR)(SrcAddress) )[3] << 24 )
            );
}

ULONG
SmbGetAlignedUlong (
    IN PULONG SrcAddress
    )

{
    return *(SrcAddress);
}

VOID
SmbPutUlong (
    OUT PSMB_ULONG DestAddress,
    IN ULONG Value
    )

{
    ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);
    ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);
    ( (PUCHAR)(DestAddress) )[2] = BYTE_2(Value);
    ( (PUCHAR)(DestAddress) )[3] = BYTE_3(Value);
    return;
}

VOID
SmbPutAlignedUlong (
    OUT PULONG DestAddress,
    IN ULONG Value
    )

{
    *(DestAddress) = Value;
    return;
}

VOID
SmbPutDate (
    OUT PSMB_DATE DestAddress,
    IN SMB_DATE Value
    )

{
    ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0(Value.Ushort);
    ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1(Value.Ushort);
    return;
}

VOID
SmbMoveDate (
    OUT PSMB_DATE DestAddress,
    IN PSMB_DATE SrcAddress
    )

{
    (DestAddress)->Ushort = (USHORT)(
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 ) );
    return;
}

VOID
SmbZeroDate (
    IN PSMB_DATE Date
    )

{
    (Date)->Ushort = 0;
}

BOOLEAN
SmbIsDateZero (
    IN PSMB_DATE Date
    )

{
    return (BOOLEAN)( (Date)->Ushort == 0 );
}

VOID
SmbPutTime (
    OUT PSMB_TIME DestAddress,
    IN SMB_TIME Value
    )

{
    ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0(Value.Ushort);
    ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1(Value.Ushort);
    return;
}

VOID
SmbMoveTime (
    OUT PSMB_TIME DestAddress,
    IN PSMB_TIME SrcAddress
    )

{
    (DestAddress)->Ushort = (USHORT)(
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 ) );
    return;
}

VOID
SmbZeroTime (
    IN PSMB_TIME Time
    )

{
    (Time)->Ushort = 0;
}

BOOLEAN
SmbIsTimeZero (
    IN PSMB_TIME Time
    )

{
    return (BOOLEAN)( (Time)->Ushort == 0 );
}

#endif // SMBDBG


NTSTATUS
SrvIoCreateFile (
    IN PWORK_CONTEXT WorkContext,
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PSHARE Share OPTIONAL
    )
{
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    NTSTATUS tempStatus;
    BOOLEAN dispositionModified = FALSE;
    ULONG eventToLog = 0;
    ULONG newUsage;
    ULONG requiredSize;
    SHARE_TYPE shareType = ShareTypeWild;
    UNICODE_STRING fileName, *pName;

#if SRVDBG_STATS
    LARGE_INTEGER timeStamp, currentTime;
    LARGE_INTEGER timeDifference;
#endif

    PAGED_CODE( );

    IF_DEBUG( CREATE ) {
        KdPrint(("\nSrvIoCreateFile:\n" ));
        KdPrint(("  Obja->ObjectName <%wZ>\n", ObjectAttributes->ObjectName ));
        KdPrint(("  Obja->Attributes %X,", ObjectAttributes->Attributes ));
        KdPrint((" RootDirectory %p,", ObjectAttributes->RootDirectory ));
        KdPrint((" SecurityDescriptor %p,", ObjectAttributes->SecurityDescriptor ));
        KdPrint((" SecurityQOS %p\n", ObjectAttributes->SecurityQualityOfService ));
        KdPrint(("    DesiredAccess %X, FileAttributes %X, ShareAccess %X\n",
                    DesiredAccess, FileAttributes, ShareAccess ));
        KdPrint(("    Disposition %X, CreateOptions %X, EaLength %X\n",
                    Disposition, CreateOptions, EaLength ));
        KdPrint(("    CreateFileType %X, ExtraCreateParameters %p, Options %X\n",
                    CreateFileType, ExtraCreateParameters, Options ));
    }

    //
    // See if this operation is allowed on this share
    //
    if( ARGUMENT_PRESENT( Share ) ) {
        status = SrvIsAllowedOnAdminShare( WorkContext, Share );

        if( !NT_SUCCESS( status ) ) {
            IF_DEBUG( CREATE ) {
                KdPrint(("Create disallowed on Admin Share: %X\n", status ));
            }
            return status;
        }
    }

    //
    // We do not allow the remote opening of structured storage files
    //
    if( (CreateOptions & FILE_STRUCTURED_STORAGE) == FILE_STRUCTURED_STORAGE ) {
        IF_DEBUG( CREATE ) {
            KdPrint(("Create FILE_STRUCTURED_STORAGE unsupported\n" ));
        }
        return STATUS_NOT_SUPPORTED;
    }

    //
    // We do not allow opening files by ID.  It is too easy to escape the share
    //
    if( CreateOptions & FILE_OPEN_BY_FILE_ID ) {
        IF_DEBUG( CREATE ) {
            KdPrint(("Create FILE_OPEN_BY_FILE_ID unsupported\n" ));
        }
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Make sure the client isn't trying to create a file having the name
    //   of a DOS device
    //
    SrvGetBaseFileName( ObjectAttributes->ObjectName, &fileName );
    for( pName = SrvDosDevices; pName->Length; pName++ ) {
        if( pName->Length == fileName.Length &&
            RtlCompareUnicodeString( pName, &fileName, TRUE ) == 0 ) {
            //
            // Whoa!  We don't want clients trying to create files having a
            //   DOS device name
            //
            IF_DEBUG( CREATE ) {
                KdPrint(("Create open %wZ unsupported\n", &fileName ));
            }
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // If this is from the NULL session, allow it to open only certain
    // pipes.
    //

    if ( CreateFileType != CreateFileTypeMailslot ) {

        shareType = WorkContext->TreeConnect->Share->ShareType;

        if( shareType == ShareTypePipe ) {
            if ( WorkContext->Session->IsNullSession ) {

                if( SrvRestrictNullSessionAccess ) {
                    BOOLEAN matchFound = FALSE;
                    ULONG i;

                    ACQUIRE_LOCK( &SrvConfigurationLock );

                    for ( i = 0; SrvNullSessionPipes[i] != NULL ; i++ ) {

                        if ( _wcsicmp(
                                SrvNullSessionPipes[i],
                                ObjectAttributes->ObjectName->Buffer
                                ) == 0 ) {

                            matchFound = TRUE;
                            break;
                        }
                    }

                    RELEASE_LOCK( &SrvConfigurationLock );

                    if ( !matchFound ) {
                        IF_DEBUG( CREATE ) {
                            KdPrint(( "Create via NULL session denied\n" ));
                        }
                        return(STATUS_ACCESS_DENIED);
                    }
                }

            } else if( WorkContext->Session->IsLSNotified == FALSE ) {
                //
                // We have a pipe open request, not a NULL session, and
                //  we haven't gotten clearance from the license server yet.
                //  If this pipe requires clearance, get a license.
                //
                ULONG i;
                BOOLEAN matchFound = FALSE;

                ACQUIRE_LOCK( &SrvConfigurationLock );

                for ( i = 0; SrvPipesNeedLicense[i] != NULL ; i++ ) {

                    if ( _wcsicmp(
                            SrvPipesNeedLicense[i],
                            ObjectAttributes->ObjectName->Buffer
                            ) == 0 ) {
                        matchFound = TRUE;
                        break;
                    }
                }

                RELEASE_LOCK( &SrvConfigurationLock );

                if( matchFound == TRUE ) {
                    status = SrvXsLSOperation( WorkContext->Session,
                                               XACTSRV_MESSAGE_LSREQUEST );

                    if( !NT_SUCCESS( status ) ) {
                        IF_DEBUG( CREATE ) {
                            KdPrint(( "Create failed due to license server: %X\n", status ));
                        }
                        return status;
                    }
                }
            }
        }

        //
        // !!! a hack to handle a bug in the Object system and path-based
        //     operations on print shares.  to test a fix, try from OS/2:
        //
        //         copy config.sys \\server\printshare
        //

        if ( Share == NULL &&
                 ObjectAttributes->ObjectName->Length == 0 &&
                 ObjectAttributes->RootDirectory == NULL ) {

            IF_DEBUG( CREATE ) {
                KdPrint(("Create failed: ObjectName Len == 0, an ! Root directory\n" ));
            }
            return STATUS_OBJECT_PATH_SYNTAX_BAD;
        }

        //
        // Check desired access against share ACL.
        //
        // This gets a little hairy.  Basically, we simply want to check the
        // desired access against the ACL.  But this doesn't correctly
        // handle the case where the client only has read access to the
        // share, and wants to (perhaps optionally) create (or overwrite) a
        // file or directory, but only asks for read access to the file.  We
        // deal with this problem by, in effect, adding write access to the
        // access requested by the client if the client specifies a
        // dispostion mode that will or may create or overwrite the file.
        //
        // If the client specifies a dispostion that WILL create or
        // overwrite (CREATE, SUPERSEDE, OVERWRITE, or OVERWRITE_IF), we
        // turn on the FILE_WRITE_DATA (aka FILE_ADD_FILE) and
        // FILE_APPEND_DATA (aka FILE_ADD_SUBDIRECTORY) accesses.  If the
        // access check fails, we return STATUS_ACCESS_DENIED.
        //
        // If the client specifies optional creation, then we have to be
        // even more tricky.  We don't know if the file actually exists, so
        // we can't just reject the request out-of-hand, because if the file
        // does exist, and the client really does have read access to the
        // file, it will look weird if we deny the open.  So in this case we
        // turn the OPEN_IF request into an OPEN (fail if doesn't exist)
        // request.  If the open fails because the file doesn't exist, we
        // return STATUS_ACCESS_DENIED.
        //
        // Note that this method effectively means that the share ACL cannot
        // distinguish between a user who can write to existing files but
        // who cannot create new files.  This is because of the overloading
        // of FILE_WRITE_DATA/FILE_ADD_FILE and
        // FILE_APPEND_DATA/FILE_ADD_SUBDIRECTORY.
        //
        //
        // OK.  First, check the access exactly as requested.
        //

        status = SrvCheckShareFileAccess( WorkContext, DesiredAccess );
        if ( !NT_SUCCESS( status )) {
            //
            // Some clients want ACCESS_DENIED to be in the server class
            // instead of the DOS class when it's due to share ACL
            // restrictions.  So we need to keep track of why we're
            // returning ACCESS_DENIED.
            //
            IF_DEBUG( CREATE ) {
                KdPrint(("Create failed, SrvCheckShareFileAccess returns %X\n", status ));
            }

            WorkContext->ShareAclFailure = TRUE;
            return STATUS_ACCESS_DENIED;
        }

    } else {

        //
        // Set it to CreateFileTypeNone so no extra checking is done.
        //

        CreateFileType = CreateFileTypeNone;
    }

    //
    // That worked.  Now, if the Disposition may or will create or
    // overwrite, do more checking.
    //

    if ( Disposition != FILE_OPEN ) {

        status = SrvCheckShareFileAccess(
                    WorkContext,
                    DesiredAccess | FILE_WRITE_DATA | FILE_APPEND_DATA
                    );

        if ( !NT_SUCCESS( status )) {

            //
            // The client cannot create or overwrite files.  Unless
            // they asked for FILE_OPEN_IF, jump out now.
            //

            if ( Disposition != FILE_OPEN_IF ) {
                //
                // Some clients want ACCESS_DENIED to be in the server class
                // instead of the DOS class when it's due to share ACL
                // restrictions.  So we need to keep track of why we're
                // returning ACCESS_DENIED.
                //
                IF_DEBUG( CREATE ) {
                    KdPrint(("Create failed, SrvCheckShareFileAccess returns ACCESS_DENIED\n"));
                }
                WorkContext->ShareAclFailure = TRUE;
                return STATUS_ACCESS_DENIED;
            }

            //
            // Change OPEN_IF to OPEN, and remember that we did it.
            //

            Disposition = FILE_OPEN;
            dispositionModified = TRUE;

        }

    }

    //
    // If this client is reading from the file, turn off FILE_SEQUENTIAL_ONLY in case
    //  caching this file would be beneficial to other clients.
    //
    if( shareType == ShareTypeDisk &&
        !(DesiredAccess & (FILE_WRITE_DATA|FILE_APPEND_DATA)) ) {

        CreateOptions &= ~FILE_SEQUENTIAL_ONLY;
    }

    if( SrvMaxNonPagedPoolUsage != 0xFFFFFFFF ) {
        //
        // Make sure that this open will not push the server over its
        // nonpaged and paged quotas.
        //

        newUsage = InterlockedExchangeAdd(
                        (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                        IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE
                        ) + IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE;

        if ( newUsage > SrvMaxNonPagedPoolUsage ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            eventToLog = EVENT_SRV_NONPAGED_POOL_LIMIT;
            goto error_exit1;
        }

        if ( SrvStatistics.CurrentNonPagedPoolUsage > SrvStatistics.PeakNonPagedPoolUsage) {
            SrvStatistics.PeakNonPagedPoolUsage = SrvStatistics.CurrentNonPagedPoolUsage;
        }
    }

    if( SrvMaxPagedPoolUsage != 0xFFFFFFFF ) {

        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
        newUsage = InterlockedExchangeAdd(
                        (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                        IO_FILE_OBJECT_PAGED_POOL_CHARGE
                        ) + IO_FILE_OBJECT_PAGED_POOL_CHARGE;
        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );

        if ( newUsage > SrvMaxPagedPoolUsage ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            eventToLog = EVENT_SRV_PAGED_POOL_LIMIT;
            goto error_exit;
        }

        if ( SrvStatistics.CurrentPagedPoolUsage > SrvStatistics.PeakPagedPoolUsage) {
            SrvStatistics.PeakPagedPoolUsage = SrvStatistics.CurrentPagedPoolUsage;
        }
    }


    //
    // If Share is specified, we may need to fill up the root share
    // handle of the object attribute.
    //

    if ( ARGUMENT_PRESENT( Share ) && (shareType != ShareTypePrint) ) {

        //
        // Get the Share root handle.
        //

        status = SrvGetShareRootHandle( Share );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(CREATE) {
                KdPrint(( "SrvIoCreateFile: SrvGetShareRootHandle failed: %X\n",
                              status ));
            }
            goto error_exit;

        }

        //
        // Fill in the root handle.
        //

        status = SrvSnapGetRootHandle( WorkContext, &ObjectAttributes->RootDirectory );
        if( !NT_SUCCESS( status ) )
        {
            goto error_exit;
        }

    }

    //
    // Impersonate the client.  This makes us look like the client for
    // the purpose of checking security.  Don't do impersonation if
    // this is a spool file since spool files have admin all access,
    // everybody read access by definition.
    //

    status = STATUS_SUCCESS;

    if ( shareType != ShareTypePrint ) {
        status = IMPERSONATE( WorkContext );
    }

#if SRVDBG_STATS
    //
    // Get the system time for statistics tracking.
    //

    KeQuerySystemTime( &timeStamp );
#endif

    //
    // Perform the actual open.
    //
    // *** Do not lose the status returned by IoCreateFile!  Even if
    //     it's a success code.  The caller needs to know if it's
    //     STATUS_OPLOCK_BREAK_IN_PROGRESS.
    //

    if( NT_SUCCESS( status ) ) {

        status = IoCreateFile(
                     FileHandle,
                     DesiredAccess,
                     ObjectAttributes,
                     IoStatusBlock,
                     AllocationSize,
                     FileAttributes,
                     ShareAccess,
                     Disposition,
                     CreateOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileType,
                     ExtraCreateParameters,
                     Options
                     );

        //
        // If the volume was dismounted, and we can refresh the share root handle,
        //   we should try the operation again.
        //

        if( ARGUMENT_PRESENT( Share ) && SrvRetryDueToDismount( Share, status ) ) {

            status = SrvSnapGetRootHandle( WorkContext, &ObjectAttributes->RootDirectory );
            if( !NT_SUCCESS( status ) )
            {
                goto error_exit;
            }

            status = IoCreateFile(
                         FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         AllocationSize,
                         FileAttributes,
                         ShareAccess,
                         Disposition,
                         CreateOptions,
                         EaBuffer,
                         EaLength,
                         CreateFileType,
                         ExtraCreateParameters,
                         Options
                         );
        }

    }

#if SRVDBG_STATS
    //
    // Grab the time again.
    //

    KeQuerySystemTime( &currentTime );
#endif

    //
    // Go back to the server's security context.
    //

    if ( shareType != ShareTypePrint ) {
        //
        // Calling REVERT() even if the impersonate failed is harmless
        //
        REVERT( );
    }

#if SRVDBG_STATS
    //
    // Determine how long the IoCreateFile took.
    //
    timeDifference.QuadPart = currentTime.QuadPart - timeStamp.QuadPart;

    //
    // Update statistics, including server pool quota statistics if the
    // open didn't succeed.
    //

    ExInterlockedAddLargeInteger(
        &SrvDbgStatistics.TotalIoCreateFileTime,
        timeDifference,
        &GLOBAL_SPIN_LOCK(Statistics)
        );
#endif
    //
    // Release the share root handle
    //

    if ( ARGUMENT_PRESENT( Share ) ) {
        SrvReleaseShareRootHandle( Share );
    }

    if ( NT_SUCCESS(status) ) {

        IF_DEBUG( CREATE ) {
            KdPrint(( "    ** %wZ, handle %p\n",
                    ObjectAttributes->ObjectName, *FileHandle ));
        }

        tempStatus = SrvVerifyDeviceStackSize(
                        *FileHandle,
                        TRUE,
                        &fileObject,
                        &deviceObject,
                        NULL
                        );

        if ( !NT_SUCCESS( tempStatus )) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvIoCreateFile: Verify Device Stack Size failed: %X\n",
                tempStatus,
                NULL
                );

            SRVDBG_RELEASE_HANDLE( *FileHandle, "FIL", 50, 0 );
            SrvNtClose( *FileHandle, FALSE );
            status = tempStatus;
        } else {

             //
             //  Mark the orgin of this file as remote.  This should
             //  never fail.  If it does, it means it is already set.
             //  Check for this in a debug build, but ignore errors
             //  in the retail build.
             //

#if DBG
             tempStatus =
#endif
             IoSetFileOrigin( fileObject,
                              TRUE );

             ASSERT( tempStatus == STATUS_SUCCESS );

             //
             //  Remove the reference we added in SrvVerifyDeviceStackSize().
             //

             ObDereferenceObject( fileObject );
        }

    }

    if ( !NT_SUCCESS(status) ) {
        goto error_exit;
    }

    IF_DEBUG(HANDLES) {
        if ( NT_SUCCESS(status) ) {
            PVOID caller, callersCaller;
            RtlGetCallersAddress( &caller, &callersCaller );
            KdPrint(( "opened handle %p for %wZ (%p %p)\n",
                           *FileHandle, ObjectAttributes->ObjectName,
                           caller, callersCaller ));
        }
    }

    IF_DEBUG( CREATE ) {
        KdPrint(("    Status %X\n", status ));
    }

    return status;

error_exit:

    if( SrvMaxPagedPoolUsage != 0xFFFFFFFF ) {
        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= IO_FILE_OBJECT_PAGED_POOL_CHARGE );

        InterlockedExchangeAdd(
            (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
            -IO_FILE_OBJECT_PAGED_POOL_CHARGE
            );

        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
    }

error_exit1:

    if( SrvMaxNonPagedPoolUsage != 0xFFFFFFFF ) {
        ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE );

        InterlockedExchangeAdd(
            (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
            -IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE
            );

        ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= 0 );
    }

    if ( status == STATUS_INSUFF_SERVER_RESOURCES ) {

        requiredSize = ((eventToLog == EVENT_SRV_NONPAGED_POOL_LIMIT) ?
                            IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE :
                            IO_FILE_OBJECT_PAGED_POOL_CHARGE);

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvIoCreateFile: nonpaged pool limit reached, current = %ld, max = %ld\n",
            newUsage - requiredSize,
            SrvMaxNonPagedPoolUsage
            );

        SrvLogError(
            SrvDeviceObject,
            eventToLog,
            STATUS_INSUFFICIENT_RESOURCES,
            &requiredSize,
            sizeof(ULONG),
            NULL,
            0
            );

    } else {

        //
        // Finish up the access checking started above.  If the open failed
        // because the file didn't exist, and we turned off the create-if
        // mode because the client doesn't have write access, change the
        // status to STATUS_ACCESS_DENIED.
        //

        if ( dispositionModified && (status == STATUS_OBJECT_NAME_NOT_FOUND) ) {
            status = STATUS_ACCESS_DENIED;
        }

    }

    IF_DEBUG( CREATE ) {
        KdPrint(("    Status %X\n", status ));
    }

    return status;

} // SrvIoCreateFile


NTSTATUS
SrvNtClose (
    IN HANDLE Handle,
    IN BOOLEAN QuotaCharged
    )

/*++

Routine Description:

    Closes a handle, records statistics for number of handles closed,
    total time spent closing handles.

Arguments:

    Handle - the handle to close.

    QuotaCharged - indicates whether the server's internal quota for
        paged and nonpaged pool was charged for this open.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
#if SRVDBG_STATS
    LARGE_INTEGER timeStamp, currentTime;
    LARGE_INTEGER timeDifference;
#endif
    PEPROCESS process;

    PAGED_CODE( );

#if SRVDBG_STATS
    //
    // SnapShot the system time.
    //

    KeQuerySystemTime( &timeStamp );
#endif

    //
    // Make sure we're in the server FSP.
    //

    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        //KdPrint(( "SRV: Closing handle %x in process %x\n", Handle, process ));
        KeAttachProcess( SrvServerProcess );
    }

    IF_DEBUG( CREATE ) {
        KdPrint(( "SrvNtClose handle %p\n", Handle ));
    }

    //
    // Close the handle.
    //

    status = NtClose( Handle );

    //
    // Return to the original process.
    //

    if ( process != SrvServerProcess ) {
        KeDetachProcess();
    }

    IF_DEBUG( ERRORS ) {
        if ( !NT_SUCCESS( status ) ) {
            KdPrint(( "SRV: NtClose failed: %x\n", status ));
            DbgBreakPoint( );
        }
    }

    ASSERT( NT_SUCCESS( status ) );

#if SRVDBG_STATS
    //
    // Get the time again.
    //

    KeQuerySystemTime( &currentTime );

    //
    // Determine how long the close took.
    //

    timeDifference.QuadPart = currentTime.QuadPart - timeStamp.QuadPart;
#endif

    //
    // Update the relevant statistics, including server quota statistics.
    //

#if SRVDBG_STATS
    SrvDbgStatistics.TotalNtCloseTime.QuadPart += timeDifference.QuadPart;
#endif

    if ( QuotaCharged ) {
        if( SrvMaxPagedPoolUsage != 0xFFFFFFFF ) {
            ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
            InterlockedExchangeAdd(
                (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                -(LONG)IO_FILE_OBJECT_PAGED_POOL_CHARGE
                );
            ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
        }

        if( SrvMaxNonPagedPoolUsage != 0xFFFFFFFF ) {
            ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= 0 );
            InterlockedExchangeAdd(
                (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                -(LONG)IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE
                );
            ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= 0 );
        }
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalHandlesClosed );

    IF_DEBUG(HANDLES) {
        PVOID caller, callersCaller;
        RtlGetCallersAddress( &caller, &callersCaller );
        if ( NT_SUCCESS(status) ) {
            KdPrint(( "closed handle %p (%p %p)\n",
                           Handle, caller, callersCaller ));
        } else {
            KdPrint(( "closed handle %p (%p %p) FAILED: %X\n",
                           Handle, caller, callersCaller, status ));
        }
    }

    return STATUS_SUCCESS;

} // SrvNtClose


NTSTATUS
SrvVerifyDeviceStackSize (
    IN HANDLE FileHandle,
    IN BOOLEAN ReferenceFileObject,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL
    )
/*++

Routine Description:

    Ths routine references the file object associated with the
    file handle and checks whether our work item has sufficient
    irp stack size to handle requests to this device or the device
    associated with this file.

Arguments:

    FileHandle - The handle to an open device or file
    ReferenceFileObject - if TRUE, the file object is left referenced.
    FileObject - The file object associated with the filehandle.
    DeviceObject - the device object associated with the filehandle.
    HandleInformation - if not NULL, returns information about the file handle.

Return Value:

    Status of request.

--*/
{

    NTSTATUS status;

    PAGED_CODE( );

    //
    // Get a pointer to the file object, so that we can directly
    // get the related device object that should contain a count
    // of the irp stack size needed by that device.
    //

    status = ObReferenceObjectByHandle(
                FileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)FileObject,
                HandleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "SrvVerifyDeviceStackSize: unable to reference file handle 0x%lx",
            FileHandle,
            NULL
            );

    } else {

        *DeviceObject = IoGetRelatedDeviceObject( *FileObject );

        if ( (*DeviceObject)->StackSize > SrvReceiveIrpStackSize ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvVerifyStackSize: WorkItem Irp StackSize too small. Need %d Allocated %d\n",
                (*DeviceObject)->StackSize+1,
                SrvReceiveIrpStackSize
                );

            SrvLogSimpleEvent( EVENT_SRV_IRP_STACK_SIZE, STATUS_SUCCESS );

            ObDereferenceObject( *FileObject );
            *FileObject = NULL;
            status = STATUS_INSUFF_SERVER_RESOURCES;

        } else if ( !ReferenceFileObject ) {

            ObDereferenceObject( *FileObject );
            *FileObject = NULL;

        }
    }

    return status;

} // SrvVerifyDeviceStackSize


NTSTATUS
SrvImpersonate (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Impersonates the remote client specified in the Session pointer
    of the work context block.

Arguments:

    WorkContext - a work context block containing a valid pointer to
        a session block.

Return Value:

    status code of the attempt

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( WorkContext->Session != NULL );

    if( !IS_VALID_SECURITY_HANDLE (WorkContext->Session->UserHandle) ) {
        return STATUS_ACCESS_DENIED;
    }

    status = ImpersonateSecurityContext(
                    &WorkContext->Session->UserHandle
                    );

    if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "IMPERSONATE: NtSetInformationThread failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_THREAD, status );
    }

    return status;

} // SrvImpersonate


VOID
SrvRevert (
    VOID
    )

/*++

Routine Description:

    Reverts to the server FSP's default thread context.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    status = PsAssignImpersonationToken(PsGetCurrentThread(),NULL);

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "REVERT: NtSetInformationThread failed: %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_THREAD, status );
    }

    return;

} // SrvRevert


#ifdef INCLUDE_SMB_IFMODIFIED
NTSTATUS
SrvSetLastWriteTime (
    IN PRFCB Rfcb,
    IN ULONG LastWriteTimeInSeconds,
    IN ACCESS_MASK GrantedAccess,
    IN BOOLEAN ForceChanges
    )
#else
NTSTATUS
SrvSetLastWriteTime (
    IN PRFCB Rfcb,
    IN ULONG LastWriteTimeInSeconds,
    IN ACCESS_MASK GrantedAccess
    )
#endif
/*++

Routine Description:

    Sets the last write time on a file if the specified handle has
    sufficient access.  This is used by the Close and Create SMBs to
    ensure that file times on server files are consistent with
    times on clients.

Arguments:

    Rfcb - pointer to the rfcb block that is associated with the file
        which we need to set the lastwrite time on.

    LastWriteTimeInSeconds - the time, in seconds since 1970, to put
        on the file.  If it is 0 or -1, the last write time is not
        changed.

    GrantedAccess - an access mask specifying the access the specified
        handle has.  If it has insufficient access, the file time is
        not changed.

    ForceChanges - flag set to true if we want to send down the
        SetFileInfo anyway even if the client specified a zero lastWriteTime.
        Useful to force the filesystem to update the file control block now
        rather than at the close.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    FILE_BASIC_INFORMATION fileBasicInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    PAGED_CODE( );

    //
    // If the client doesn't want to set the time, don't set it.
    //

#ifdef INCLUDE_SMB_IFMODIFIED
    if (ForceChanges && LastWriteTimeInSeconds == 0xFFFFFFFF) {

        LastWriteTimeInSeconds = 0;
    }

    if ( Rfcb->ShareType != ShareTypeDisk ||
        ( ( LastWriteTimeInSeconds == 0 ) && ! ForceChanges ) ||
        ( LastWriteTimeInSeconds == 0xFFFFFFFF ) ) {
#else
    if ( Rfcb->ShareType != ShareTypeDisk ||
         LastWriteTimeInSeconds == 0     ||
         LastWriteTimeInSeconds == 0xFFFFFFFF ) {

#endif
        //
        // If the file was written to, we won't cache the file.  This is to
        // ensure the file directory entry gets updated by the file system.
        //

        if ( Rfcb->WrittenTo ) {
            Rfcb->IsCacheable = FALSE;
        }
        return STATUS_SUCCESS;
    }

    //
    // Make sure that we have the correct access on the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        GrantedAccess,
        IRP_MJ_SET_INFORMATION,
        FileBasicInformation,
        &status
        );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set to 0 the fields we don't want to change.
    //

    fileBasicInfo.CreationTime.QuadPart = 0;
    fileBasicInfo.LastAccessTime.QuadPart = 0;
    fileBasicInfo.ChangeTime.QuadPart = 0;
    fileBasicInfo.FileAttributes = 0;

    //
    // Set up the last write time.
    //

#ifdef INCLUDE_SMB_IFMODIFIED
    if (LastWriteTimeInSeconds == 0) {

        fileBasicInfo.LastWriteTime.QuadPart = 0;

    } else {
#endif
        RtlSecondsSince1970ToTime(
            LastWriteTimeInSeconds,
            &fileBasicInfo.LastWriteTime
            );

        ExLocalTimeToSystemTime(
            &fileBasicInfo.LastWriteTime,
            &fileBasicInfo.LastWriteTime
            );
#ifdef INCLUDE_SMB_IFMODIFIED
    }
#endif

    //
    // Set the time using the passed-in file handle.
    //

    status = NtSetInformationFile(
                 Rfcb->Lfcb->FileHandle,
                 &ioStatusBlock,
                 &fileBasicInfo,
                 sizeof(FILE_BASIC_INFORMATION),
                 FileBasicInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSetLastWriteTime: NtSetInformationFile returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
        return status;
    }

    return STATUS_SUCCESS;

} // SrvSetLastWriteTime

NTSTATUS
SrvCheckShareFileAccess(
    IN PWORK_CONTEXT WorkContext,
    IN ACCESS_MASK FileDesiredAccess
    )

/*++

Routine Description:

    This routine checks the desired access against the permissions
    set for this client.

Arguments:

    WorkContext - pointer to the work context block that contains information
        about the request.
    FileDesiredAccess - the desired access.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    SECURITY_SUBJECT_CONTEXT subjectContext;
    PSECURITY_DESCRIPTOR securityDescriptor;
    ACCESS_MASK grantedAccess;
    ACCESS_MASK mappedAccess = FileDesiredAccess;
    PPRIVILEGE_SET privileges = NULL;

    PAGED_CODE( );

    ACQUIRE_LOCK_SHARED( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    securityDescriptor = WorkContext->TreeConnect->Share->FileSecurityDescriptor;

    if (securityDescriptor != NULL) {

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            SeCaptureSubjectContext( &subjectContext );

            RtlMapGenericMask( &mappedAccess, &SrvFileAccessMapping );

            //
            // SYNCHRONIZE does not make any sense for a share ACL
            //
            mappedAccess &= ~SYNCHRONIZE;

            if ( !SeAccessCheck(
                        securityDescriptor,
                        &subjectContext,
                        FALSE,                  // Locked ?
                        mappedAccess,
                        0,                      // PreviousGrantedAccess
                        &privileges,
                        &SrvFileAccessMapping,
                        UserMode,
                        &grantedAccess,
                        &status
                        ) ) {


                IF_DEBUG(ERRORS) {
                    KdPrint((
                        "SrvCheckShareFileAccess: Status %x, Desired access %x, mappedAccess %x\n",
                        status,
                        FileDesiredAccess,
                        mappedAccess
                        ));
                }
            }


            if ( privileges != NULL ) {
                SeFreePrivileges( privileges );
            }

            SeReleaseSubjectContext( &subjectContext );

            REVERT( );
        }
    }

    RELEASE_LOCK( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    return status;

} // SrvCheckShareFileAccess

VOID
SrvReleaseShareRootHandle (
    IN PSHARE Share
    )

/*++

Routine Description:

    This routine releases the root handle for a given share if the
    shared device is removable (floopy, or cdrom).

Arguments:

    Share - The share for which the root directory handle is to be released.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( Share->Removable ) {

        ASSERT( Share->CurrentRootHandleReferences > 0 );
        ACQUIRE_LOCK( &SrvShareLock );

        if ( --Share->CurrentRootHandleReferences == 0 ) {

            ASSERT( Share->RootDirectoryHandle != NULL );
            SRVDBG_RELEASE_HANDLE( Share->RootDirectoryHandle, "RTD", 51, Share );
            SrvNtClose( Share->RootDirectoryHandle, FALSE );
            Share->RootDirectoryHandle = NULL;
            SrvDereferenceShare( Share );

        }

        RELEASE_LOCK( &SrvShareLock );

    }

    return;

} // SrvReleaseShareRootHandle

VOID
SrvUpdateVcQualityOfService (
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime OPTIONAL
    )

/*++

Routine Description:

    Updates the connection quality of service information by
    querying the underlying transport.

Arguments:

    Connection - pointer to the connection whose qos we want to update.

    CurrentTime - an optional pointer to a large interger containing the
                current time.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTDI_CONNECTION_INFO connectionInfo;
    LARGE_INTEGER currentTime;
    LARGE_INTEGER throughput;
    LARGE_INTEGER linkDelay;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

    PAGED_CODE( );

    //
    // This routine is a no-op on connectionless transports.
    //

    if ( Connection->Endpoint->IsConnectionless ) {

        Connection->EnableOplocks = FALSE;
        Connection->EnableRawIo = FALSE;
        return;
    }

    //
    // Update the connection information
    //

    if ( ARGUMENT_PRESENT( CurrentTime ) ) {

        currentTime = *CurrentTime;

    } else {

        KeQuerySystemTime( &currentTime );

    }

    //
    // Check if connection info is still valid.
    //

    if ( pagedConnection->LinkInfoValidTime.QuadPart > currentTime.QuadPart ) {
        return;
    }

    //
    // We need to update the connection information.
    //

    connectionInfo = ALLOCATE_NONPAGED_POOL(
                            sizeof(TDI_CONNECTION_INFO),
                            BlockTypeDataBuffer
                            );

    if ( connectionInfo == NULL ) {
        goto exitquery;
    }

    //
    // Issue a TdiQueryInformation to get the current connection info
    // from the transport provider for this connection.  This is a
    // synchronous operation.
    //

    status = SrvIssueTdiQuery(
                Connection->FileObject,
                &Connection->DeviceObject,
                (PUCHAR)connectionInfo,
                sizeof(TDI_CONNECTION_INFO),
                TDI_QUERY_CONNECTION_INFO
                );

    //
    // If the request failed, log an event.
    //
    // *** We special-case STATUS_INVALID_CONNECTION because NBF completes
    //     our Accept IRP before it's actually ready to accept requests.
    //

    if ( !NT_SUCCESS(status) ) {
        if ( status != STATUS_INVALID_CONNECTION &&
             status != STATUS_CONNECTION_INVALID ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvUpdateVcQualityOfService: SrvIssueTdiQuery failed: %X\n",
                status,
                NULL
                );
            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        }

        DEALLOCATE_NONPAGED_POOL( connectionInfo );
        goto exitquery;
    }

    //
    // Set the time when this information becomes invalid.
    //

    currentTime.QuadPart += SrvLinkInfoValidTime.QuadPart;

    //
    // Get a positive delay.  The TP returns a relative time which
    // is negative.
    //

    linkDelay.QuadPart = -connectionInfo->Delay.QuadPart;
    if ( linkDelay.QuadPart < 0 ) {
        linkDelay.QuadPart = 0;
    }

    //
    // Get the throughput
    //

    throughput = connectionInfo->Throughput;

    //
    // If connection is reliable, check and see if the delay and throughput
    // are within our limits. If not, the vc is unreliable.
    //

    Connection->EnableOplocks =
            (BOOLEAN) ( !connectionInfo->Unreliable &&
                        throughput.QuadPart >= SrvMinLinkThroughput.QuadPart );

    DEALLOCATE_NONPAGED_POOL( connectionInfo );

    //
    // We need to check the delay for Raw I/O.
    //

    Connection->EnableRawIo =
            (BOOLEAN) ( Connection->EnableOplocks &&
                        linkDelay.QuadPart <= SrvMaxLinkDelay.QuadPart );

    //
    // See if oplocks are always disabled for this connection.  We do it
    // here so that Connection->EnableRawIo can be computed correctly.
    //

    if ( Connection->OplocksAlwaysDisabled ) {
        Connection->EnableOplocks = FALSE;
    }

    //
    // Access "large" connection QOS fields using a lock, to
    // ensure consistent values.
    //

    ACQUIRE_LOCK( &Connection->Lock );
    pagedConnection->LinkInfoValidTime = currentTime;
    pagedConnection->Delay = linkDelay;
    pagedConnection->Throughput = throughput;
    RELEASE_LOCK( &Connection->Lock );

    return;

exitquery:

    Connection->EnableOplocks = TRUE;
    Connection->EnableRawIo = TRUE;
    return;

} // SrvUpdateVcQualityOfService


BOOLEAN SRVFASTCALL
SrvValidateSmb (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function validates an SMB header.

Arguments:

    WorkContext - Pointer to a work context block.  The RequestHeader
        and RequestParameter fields must be valid.

Return Value:

    TRUE - The SMB is valid
    FALSE - The SMB is invalid

--*/

{
    PSMB_HEADER smbHeader;
    UCHAR wordCount = 0;
    PSMB_USHORT byteCount = NULL;
    ULONG availableSpaceForSmb = 0;

    PAGED_CODE( );

    smbHeader = WorkContext->RequestHeader;

    //
    // Did we get an entire SMB?  We check here for an SMB that at least goes
    // to the WordCount field.
    //
    if( WorkContext->RequestBuffer->DataLength < sizeof( SMB_HEADER ) + sizeof( UCHAR ) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB of %d bytes too short!\n", availableSpaceForSmb ));
        }
        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- msg too small\n", WorkContext->Connection ));
        }
        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );
        return FALSE;
    }

    //
    // Does it start with 0xFF S M B ?
    //
    if ( SmbGetAlignedUlong( (PULONG)smbHeader->Protocol ) !=
                                                SMB_HEADER_PROTOCOL ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB does not start with SMB_HEADER_PROTOCOL\n" ));
        }
        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- no ffSMB\n", WorkContext->Connection ));
        }
        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );
        return FALSE;
    }

#if 0

    if ( smbHeader->Reserved != 0 ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB Header->Reserved %x != 0!\n", smbHeader->Reserved ));
        }
        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }

    //
    // DOS LM2.1 sets SMB_FLAGS_SERVER_TO_REDIR on an oplock break
    // response, so ignore that bit.
    //

    if ( (smbHeader->Flags &
            ~(INCOMING_SMB_FLAGS | SMB_FLAGS_SERVER_TO_REDIR)) != 0 ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB Header->Flags (%x) invalid\n", smbHeader->Flags ));
        }
        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }

    if ( (SmbGetAlignedUshort( &smbHeader->Flags2 ) &
                                            ~INCOMING_SMB_FLAGS2) != 0 ) {
        KdPrint(( "ValidatesmbHeader: Flags2 = %lx, valid bits = %lx, "
                  "invalid bit(s) = %lx\n",
                      SmbGetAlignedUshort( &smbHeader->Flags2 ),
                      INCOMING_SMB_FLAGS2,
                      SmbGetAlignedUshort( &smbHeader->Flags2 ) &
                          ~INCOMING_SMB_FLAGS2 ));

        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }

#endif

#if 0
    if( (smbHeader->Command != SMB_COM_LOCKING_ANDX) &&
        (smbHeader->Flags & SMB_FLAGS_SERVER_TO_REDIR) ) {

        //
        // A client has set the bit indicating that this is a server response
        //   packet. This could be an attempt by a client to sneak through a
        //   firewall -- because the firewall may be configured to allow incoming
        //   responses, but no incomming requests (thereby allowing internal clients
        //   to access Internet servers, but not allowing external clients to access
        //   internal servers).  Reject this SMB.
        //
        //

        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }
#endif

    if( WorkContext->Connection->SmbDialect == SmbDialectIllegal &&
        smbHeader->Command != SMB_COM_NEGOTIATE ) {

        //
        // Whoa -- the client sent us an SMB, but we haven't negotiated a dialect
        //  yet!
        //
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB command %x w/o negotiate!\n", smbHeader->Command ));
        }
        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- no Negotiate\n", WorkContext->Connection ));
        }

        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );

        return FALSE;
    }

    //
    // Get the WordCount and ByteCount values to make sure that there
    // was enough information sent to satisfy the specifications.
    //

    wordCount = *((PUCHAR)WorkContext->RequestParameters);
    byteCount = (PSMB_USHORT)( (PCHAR)WorkContext->RequestParameters +
                sizeof(UCHAR) + (wordCount * sizeof(USHORT)) );
    availableSpaceForSmb = WorkContext->RequestBuffer->DataLength -
                           PTR_DIFF( WorkContext->ResponseParameters,
                                     WorkContext->RequestBuffer->Buffer );

    //
    // Verify all of the fixed valued SMB header fields.  Variable
    // valued fields (such as Tid) are verified as needed by the
    // individual SMB handlers.
    //

    //
    // Make sure that the valid word count was sent across.  If the
    // value in the table is -1, then the processing routine will
    // verify the word count, and if the word count is -2 then this
    // is an illegal command which will be caught later.
    //
    // We check whether the word count is negative first since
    // critical smbs like read/write (andX/raw) have -1.
    //

    //
    // Make sure that the ByteCount lies within the boundaries of
    // the received SMB.  Without this test, it would be possible,
    // when at the end of a long AndX chain and WordCount is large,
    // for the server to take an access violation when looking at
    // ByteCount.  The location for ByteCount must be at least two
    // bytes short of the end of the buffer, as ByteCount is a
    // USHORT (two bytes).
    //

    //
    // The WordCount parameter is a byte that indicates the number of
    // word parameters, and ByteCount is a word that indicated the
    // number of following bytes.  They do not account for their own
    // sizes, so add sizeof(UCHAR) + sizeof(USHORT) to account for them.
    //

    if ( ((SrvSmbWordCount[WorkContext->NextCommand] < 0)
                        ||
          ((CHAR)wordCount == SrvSmbWordCount[WorkContext->NextCommand]))

            &&

         ((PCHAR)byteCount <= (PCHAR)WorkContext->RequestBuffer->Buffer +
                             WorkContext->RequestBuffer->DataLength -
                             sizeof(USHORT))

            &&

         ((wordCount*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
            SmbGetUshort( byteCount )) <= availableSpaceForSmb) ) {

        return(TRUE);

    }

    //
    // If we have an NT style WriteAndX, we let the client exceed the negotiated
    //  buffer size.  We do not need to check the WordCount, because we know that
    //  the SMB processor itself checks it.
    //
    if( WorkContext->LargeIndication ) {

        if( WorkContext->NextCommand == SMB_COM_WRITE_ANDX ) {
            return(TRUE);
        } else {
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "LargeIndication but not WRITE_AND_X (%x) received!\n",
                        WorkContext->NextCommand ));
            }
            IF_DEBUG( ERRORS ) {
                KdPrint(("Closing connection %p -- msg too large\n", WorkContext->Connection ));
            }
            //
            // This client has really misbehaved.  Nuke it!
            //
            WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
            SrvCloseConnection( WorkContext->Connection, FALSE );

            return( FALSE );
        }

    }

    //
    // Make sure that the valid word count was sent across.  If the
    // value in the table is -1, then the processing routine will
    // verify the word count, and if the word count is -2 then this
    // is an illegal command which will be caught later.
    //
    // We check whether the word count is negative first since
    // critical smbs like read/write (andX/raw) have -1.
    //

    if ( (CHAR)wordCount != SrvSmbWordCount[WorkContext->NextCommand] ) {

        //
        // Living with sin.  The DOS redir sends a word count of 9
        // (instead of 8) on a Transaction secondary SMB.  Pretend it
        // sent the correct number.
        //

        if ( WorkContext->RequestHeader->Command ==
                       SMB_COM_TRANSACTION_SECONDARY &&
             IS_DOS_DIALECT( WorkContext->Connection->SmbDialect) &&
             wordCount == 9 ) {

             wordCount = 8;
             *((PUCHAR)WorkContext->RequestParameters) = 8;

             byteCount = (PSMB_USHORT)( (PCHAR)WorkContext->RequestParameters +
                         sizeof(UCHAR) + (8 * sizeof(USHORT)) );

#ifdef INCLUDE_SMB_IFMODIFIED
        } else if ( IS_POSTNT5_DIALECT( WorkContext->Connection->SmbDialect ) &&
                    ( (( WorkContext->RequestHeader->Command  ==
                         SMB_COM_NT_CREATE_ANDX ) &&
                         (wordCount == SMB_REQ_EXTENDED_NT_CREATE_ANDX2_WORK_COUNT)) ||
                      (( WorkContext->RequestHeader->Command ==
                         SMB_COM_CLOSE ) && (wordCount == 5)) )) {

            //
            //  Per SethuR's suggestion, some SMB commands will have
            //  multiple number of arguments rather than define new
            //  SMBs.
            //
            if (((PCHAR)byteCount <= (PCHAR)WorkContext->RequestBuffer->Buffer +
                             WorkContext->RequestBuffer->DataLength -
                             sizeof(USHORT))
                &&
                ((wordCount*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                 SmbGetUshort( byteCount )) <= availableSpaceForSmb) ) {

                return(TRUE);
            }
#endif
        } else {

            //
            // Any other request with an incorrect word count is
            // toast.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SMB WordCount incorrect.  WordCount=%ld, "
                    "should be %ld (command = 0x%lx)\n", wordCount,
                    SrvSmbWordCount[WorkContext->NextCommand],
                    WorkContext->NextCommand ));
                KdPrint(( "  SMB received from %z\n",
                    (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));

            }
            SrvLogInvalidSmb( WorkContext );
            return FALSE;
        }
    }

    //
    // Make sure that the ByteCount lies within the boundaries of
    // the received SMB.  Without this test, it would be possible,
    // when at the end of a long AndX chain and WordCount is large,
    // for the server to take an access violation when looking at
    // ByteCount.  The location for ByteCount must be at least two
    // bytes short of the end of the buffer, as ByteCount is a
    // USHORT (two bytes).
    //

    if ( (PCHAR)byteCount > (PCHAR)WorkContext->RequestBuffer->Buffer +
                             WorkContext->RequestBuffer->DataLength -
                             sizeof(USHORT) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "ByteCount address past end of sent SMB. "
                        "ByteCount address=0x%p, "
                        "End of buffer=0x%lx\n",
                        byteCount,
                        WorkContext->RequestBuffer->DataLength ));
            KdPrint(( "  SMB received from %z\n",
                    (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));

        }

        SrvLogInvalidSmb( WorkContext );

        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- ByteCount too big\n", WorkContext->Connection ));
        }

        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );

    } else {

        //
        // if this is an IOCTL smb with category 0x53, set byte count to zero.
        // This is due to a DOS Lm2.0 and Lm2.1 bug which does not zero out
        // the bcc causing the preceding check to fail.
        //

        if ( (WorkContext->RequestHeader->Command == SMB_COM_IOCTL) &&
             (((PREQ_IOCTL) WorkContext->RequestParameters)->Category == 0x53)
           ) {

            SmbPutUshort( byteCount , 0 );
            return(TRUE);
        }

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB WordCount and/or ByteCount incorrect.  "
                        "WordCount=%ld, ByteCount=%ld, Space=%ld\n",
                        wordCount, SmbGetUshort( byteCount ),
                        availableSpaceForSmb ));
            KdPrint(( "  SMB received from %z\n",
                        (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));

        }

        SrvLogInvalidSmb( WorkContext );
    }

    return FALSE;

} // SrvValidateSmb


NTSTATUS
SrvWildcardRename(
            IN PUNICODE_STRING FileSpec,
            IN PUNICODE_STRING SourceString,
            OUT PUNICODE_STRING TargetString
            )

/*++

Routine Description:

    This routine converts a filespec and a source filename into a
    destination file name.  This routine is used to support DOS-based
    wildcard renames.

Arguments:

    FileSpec - The wildcard specification describing the destination file.
    SourceString - Pointer to a string that contains the source file name.
    TargetString - Pointer to a string that will contain the destination name.

Return Value:

    Status of operation.

--*/
{
    PWCHAR currentFileSpec;
    WCHAR delimit;
    PWCHAR buffer;
    PWCHAR source;
    ULONG bufferSize;
    ULONG sourceLeft;
    ULONG i;

    //
    // This will store the number of bytes we have written to the
    // target buffer so far.
    //

    ULONG resultLength = 0;

    PAGED_CODE( );

    //
    // This points to the current character in the filespec.
    //

    currentFileSpec = FileSpec->Buffer;

    //
    //  Initialize the pointer and the length of the source buffer.
    //

    source = SourceString->Buffer;
    sourceLeft = SourceString->Length;

    //
    //  Initialize the pointer and the length of the target buffer.
    //

    buffer = TargetString->Buffer;
    bufferSize = TargetString->MaximumLength;

    //
    // Go throught each character in the filespec.
    //

    for ( i = 0; i < (ULONG)FileSpec->Length ; i += sizeof(WCHAR) ) {

        if (resultLength < bufferSize) {

            switch ( *currentFileSpec ) {
                case L':':
                case L'\\':
                    return STATUS_OBJECT_NAME_INVALID;

                case L'*':

                    //
                    // Store the next character.
                    //

                    delimit = *(currentFileSpec+1);

                    //
                    //  While we have not exceeded the buffer and
                    //  we have not reached the end of the source string
                    //  and the current source character is not equal to
                    //  the delimeter, copy the source character to the
                    //  target string.
                    //

                    while ( ( resultLength < bufferSize ) &&
                            ( sourceLeft > 0 ) &&
                            ( *source != delimit )  ) {

                        *(buffer++) = *(source++);
                        sourceLeft -= sizeof(WCHAR);
                        resultLength += sizeof(WCHAR);
                    }
                    break;

                case L'?':  //
                case L'>':  // should we even consider >, <, and "
                case L'<':  // I'll just put this here to be safe

                    //
                    // For each ? in the filespec, we copy one character
                    // from the source string.
                    //

                    if ( ( *source != L'.' ) && ( sourceLeft > 0 )) {

                        if (resultLength < bufferSize) {

                            *(buffer++) = *(source++);
                            sourceLeft -= sizeof(WCHAR);
                            resultLength += sizeof(WCHAR);

                        } else {

                            return(STATUS_BUFFER_OVERFLOW);

                        }

                    }
                    break;

                case L'.':
                case L'"':

                    //
                    // Discard all the characters from the source string up
                    // to . or the end of the string.
                    //

                    while ( (*source != L'.') && (sourceLeft > 0) ) {
                        source++;
                        sourceLeft -= sizeof(WCHAR);
                    }

                    *(buffer++) = L'.';
                    resultLength += sizeof(WCHAR);

                    if ( sourceLeft > 0 ) {
                        source++;
                        sourceLeft -= sizeof(WCHAR);
                    }
                    break;

                default:

                    //
                    // Just copy one to one
                    //

                    if ( (*source != L'.') && (sourceLeft > 0)) {
                        source++;
                        sourceLeft -= sizeof(WCHAR);
                    }

                    if (resultLength < bufferSize) {
                        *(buffer++) = *currentFileSpec;
                        resultLength += sizeof(WCHAR);

                    } else {

                        return(STATUS_BUFFER_OVERFLOW);

                   }
                   break;
            }

            currentFileSpec++;

        } else {
            return(STATUS_BUFFER_OVERFLOW);
        }
    }

    TargetString->Length = (USHORT)resultLength;

    return( STATUS_SUCCESS );

}  // SrvWildcardRename

VOID
DispatchToOrphanage(
    IN PQUEUEABLE_BLOCK_HEADER Block
    )
{
    KIRQL oldIrql;

    ASSERT( Block->BlockHeader.ReferenceCount == 1 );

    ExInterlockedPushEntrySList(
        &SrvBlockOrphanage,
        &Block->SingleListEntry,
        &GLOBAL_SPIN_LOCK(Fsd)
        );

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    InterlockedIncrement( &SrvResourceOrphanedBlocks );

    SrvFsdQueueExWorkItem(
        &SrvResourceThreadWorkItem,
        &SrvResourceThreadRunning,
        CriticalWorkQueue
        );

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    return;
} // DispatchToOrphanage

NTSTATUS
SrvIsAllowedOnAdminShare(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share
)
/*++

Routine Description:

    This routine returns STATUS_SUCCESS if the client represented by
    the WorkContext should be allowed to access the Share, if the share
    is an Administrative Disk share.

Arguments:

    WorkContext - the unit of work
    Share - pointer to a share, possibly an administrative share

Return Value:

    STATUS_SUCCESS if allowed.  Error otherwise.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if( Share->SpecialShare && Share->ShareType == ShareTypeDisk ) {

        SECURITY_SUBJECT_CONTEXT subjectContext;
        ACCESS_MASK desiredAccess, grantedAccess;

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {
            SeCaptureSubjectContext( &subjectContext );

            if( !SeAccessCheck(
                    Share->SecurityDescriptor,
                    &subjectContext,
                    FALSE,
                    SRVSVC_SHARE_CONNECT,
                    0L,
                    NULL,
                    &SrvShareConnectMapping,
                    UserMode,
                    &grantedAccess,
                    &status
                    ) ) {

                //
                // We have a non-administrative user trying to access a file
                // through an administrative share.  Can't allow that!
                //
                // Some clients want ACCESS_DENIED to be in the server class
                // instead of the DOS class when it's due to share ACL
                // restrictions.  So we need to keep track of why we're
                // returning ACCESS_DENIED.
                //

                WorkContext->ShareAclFailure = TRUE;
            }

            SeReleaseSubjectContext( &subjectContext );

            REVERT();
        }
    }

    return status;
}

NTSTATUS
SrvRetrieveMaximalAccessRightsForUser(
    CtxtHandle              *pUserHandle,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PGENERIC_MAPPING        pMapping,
    PACCESS_MASK            pMaximalAccessRights)
/*++

Routine Description:

    This routine retrieves the maximal access rights for this client

Arguments:

    pUserHandle     - the users security handle

    pSecurityDescriptor  - the security descriptor

    pMapping        - the mapping of access rights

    pMaximalAccessRights - the computed rights

Return Value:

    Status of operation.

Notes:

    The srv macros IMPERSONATE is defined in terms of a WORK_CONTEXT. Since
    we desire this routine should be used in all situations even when a
    WORK_CONTEXT is not available the code in SrvImpersonate is duplicated
    over here

--*/
{
    NTSTATUS status;
    PPRIVILEGE_SET privileges = NULL;
    SECURITY_SUBJECT_CONTEXT subjectContext;

    if( !IS_VALID_SECURITY_HANDLE (*pUserHandle) ) {
        return STATUS_ACCESS_DENIED;
    }

    status = ImpersonateSecurityContext(
                pUserHandle);

    if( NT_SUCCESS( status ) ) {

        SeCaptureSubjectContext( &subjectContext );

        if (!SeAccessCheck(
                pSecurityDescriptor,
                &subjectContext,
                FALSE,                  // Locked ?
                MAXIMUM_ALLOWED,
                0,                      // PreviousGrantedAccess
                &privileges,
                pMapping,
                UserMode,
                pMaximalAccessRights,
                &status
                ) ) {
            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvCheckShareFileAccess: Status %x, Desired access %x\n",
                    status,
                    MAXIMUM_ALLOWED
                    ));
            }
        }

        if ( privileges != NULL ) {
            SeFreePrivileges( privileges );
        }

        SeReleaseSubjectContext( &subjectContext );

        REVERT();

        if (status == STATUS_ACCESS_DENIED) {
            *pMaximalAccessRights = 0;
            status = STATUS_SUCCESS;
        }
    }

    return status;
}

NTSTATUS
SrvRetrieveMaximalAccessRights(
    IN  OUT PWORK_CONTEXT WorkContext,
    OUT     PACCESS_MASK  pMaximalAccessRights,
    OUT     PACCESS_MASK  pGuestMaximalAccessRights)
/*++

Routine Description:

    This routine retrieves the maximal access rights for this client as well
    as a guest based upon the ACLs specified for the file

Arguments:

    WorkContext - pointer to the work context block that contains information
        about the request.

    pMaximalAccessRights  - the maximal access rights for this client.

    pGuestMaximalAccessRights - the maximal access rights for a guest

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;

    BOOLEAN  SecurityBufferAllocated = FALSE;

    PRFCB rfcb;

    ULONG lengthNeeded;

    LONG SecurityDescriptorBufferLength;

    PSECURITY_DESCRIPTOR SecurityDescriptorBuffer;

    GENERIC_MAPPING Mapping = {
                                FILE_GENERIC_READ,
                                FILE_GENERIC_WRITE,
                                FILE_GENERIC_EXECUTE,
                                FILE_ALL_ACCESS
                              };

    rfcb = WorkContext->Rfcb;

    SecurityDescriptorBufferLength = (WorkContext->RequestBuffer->DataLength -
                                      sizeof(SMB_HEADER) -
                                      - 4);

    if (SecurityDescriptorBufferLength > 0) {
        SecurityDescriptorBufferLength &= ~3;
    } else {
        SecurityDescriptorBufferLength = 0;
    }

    SecurityDescriptorBuffer = ((PCHAR)WorkContext->RequestBuffer->Buffer +
                                WorkContext->RequestBuffer->BufferLength -
                                SecurityDescriptorBufferLength);

    status = NtQuerySecurityObject(
                 rfcb->Lfcb->FileHandle,
                 (DACL_SECURITY_INFORMATION |
                  SACL_SECURITY_INFORMATION |
                  GROUP_SECURITY_INFORMATION |
                  OWNER_SECURITY_INFORMATION),
                 SecurityDescriptorBuffer,
                 SecurityDescriptorBufferLength,
                 &lengthNeeded
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {
        SecurityDescriptorBuffer = ALLOCATE_HEAP(lengthNeeded,PagedPool);

        if (SecurityDescriptorBuffer != NULL) {
            SecurityBufferAllocated = TRUE;

            SecurityDescriptorBufferLength = lengthNeeded;

            status = NtQuerySecurityObject(
                         rfcb->Lfcb->FileHandle,
                         (DACL_SECURITY_INFORMATION |
                          SACL_SECURITY_INFORMATION |
                          GROUP_SECURITY_INFORMATION |
                          OWNER_SECURITY_INFORMATION),
                         SecurityDescriptorBuffer,
                         SecurityDescriptorBufferLength,
                         &lengthNeeded
                         );
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (status == STATUS_SUCCESS) {
        status = SrvRetrieveMaximalAccessRightsForUser(
                     &WorkContext->Session->UserHandle,
                     SecurityDescriptorBuffer,
                     &Mapping,
                     pMaximalAccessRights);
    }

    // Extract the GUEST access rights
    if (status == STATUS_SUCCESS) {
        status = SrvRetrieveMaximalAccessRightsForUser(
                     &SrvNullSessionToken,
                     SecurityDescriptorBuffer,
                     &Mapping,
                     pGuestMaximalAccessRights);

    }

    if (SecurityBufferAllocated) {
        FREE_HEAP(SecurityDescriptorBuffer);
    }

    return status;
}

NTSTATUS
SrvRetrieveMaximalShareAccessRights(
    IN PWORK_CONTEXT WorkContext,
    OUT PACCESS_MASK pMaximalAccessRights,
    OUT PACCESS_MASK pGuestMaximalAccessRights)
/*++

Routine Description:

    This routine retrieves the maximal access rights for this client as well
    as a guest based upon the ACLs specified for the share

Arguments:

    WorkContext - pointer to the work context block that contains information
        about the request.

    pMaximalAccessRights  - the maximal access rights for this client.

    pGuestMaximalAccessRights - the maximal access rights for a guest

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR securityDescriptor;
    ACCESS_MASK grantedAccess;
    ACCESS_MASK mappedAccess = MAXIMUM_ALLOWED;

    PAGED_CODE( );

    ACQUIRE_LOCK_SHARED( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    securityDescriptor = WorkContext->TreeConnect->Share->FileSecurityDescriptor;

    if (securityDescriptor != NULL) {
        status = SrvRetrieveMaximalAccessRightsForUser(
                     &WorkContext->Session->UserHandle,
                     securityDescriptor,
                     &SrvFileAccessMapping,
                     pMaximalAccessRights);

        if (NT_SUCCESS(status)) {
            // Get the guest rights
            status = SrvRetrieveMaximalAccessRightsForUser(
                         &SrvNullSessionToken,
                         securityDescriptor,
                         &SrvFileAccessMapping,
                         pGuestMaximalAccessRights);
        }
    } else {
        // No Share Level ACL, Grant maximum access to both the current client
        // as well as guest

        *pMaximalAccessRights = 0x1ff;
        *pGuestMaximalAccessRights = 0x1ff;
    }

    RELEASE_LOCK( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    return status;
}

NTSTATUS
SrvUpdateMaximalAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    )
/*++

Routine Description:

    This routine updates the maximal access rights fields in an extended
    response. This is used to update these fields in various kinds of
    OPEN requests

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

    pMaximalAccessRightsInResponse - the maximal access rights field in
    the response

    pGuestMaximalAccessRightsInResponse - the guest maximal access rights field
    in the response

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error code

--*/
{
    NTSTATUS status;

    ACCESS_MASK  OwnerMaximalAccessRights = 0;
    ACCESS_MASK  GuestMaximalAccessRights = 0;

    status = SrvRetrieveMaximalAccessRights(
                 WorkContext,
                 &OwnerMaximalAccessRights,
                 &GuestMaximalAccessRights);

    if (status == STATUS_SUCCESS) {
        SmbPutUlong(
            pMaximalAccessRightsInResponse,
            OwnerMaximalAccessRights
            );

        SmbPutUlong(
            pGuestMaximalAccessRightsInResponse,
            GuestMaximalAccessRights
            );
    }

    return status;
}


NTSTATUS
SrvUpdateMaximalShareAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    )
/*++

Routine Description:

    This routine updates the maximal access rights fields in an extended
    response. This is used to update these fields in various kinds of
    TREE_CONNECT requests

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

    pMaximalAccessRightsInResponse - the maximal access rights field in
    the response

    pGuestMaximalAccessRightsInResponse - the guest maximal access rights field
    in the response

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error code

--*/
{
    NTSTATUS status;

    ACCESS_MASK  OwnerMaximalAccessRights = 0;
    ACCESS_MASK  GuestMaximalAccessRights = 0;

    status = SrvRetrieveMaximalShareAccessRights(
                 WorkContext,
                 &OwnerMaximalAccessRights,
                 &GuestMaximalAccessRights);

    if (status == STATUS_SUCCESS) {
        SmbPutUlong(
            pMaximalAccessRightsInResponse,
            OwnerMaximalAccessRights
            );

        SmbPutUlong(
            pGuestMaximalAccessRightsInResponse,
            GuestMaximalAccessRights
            );
    }

    return status;
}

VOID SRVFASTCALL
RestartConsumeSmbData(
    IN OUT PWORK_CONTEXT WorkContext
)
/*++

Routine Description:

    This is the restart routine for 'SrvConsumeSmbData'.  We need to see if we
    drained the current message from the transport.  If we have, then we send
    the response SMB to the client.  If we have not, we keep going.

--*/
{
    PIRP irp = WorkContext->Irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;

    ASSERT( WorkContext->LargeIndication );

    //
    // Check to see if we are done.  If so, send the response to the client
    //
    if( irp->Cancel ||
        NT_SUCCESS( irp->IoStatus.Status ) ||
        irp->IoStatus.Status != STATUS_BUFFER_OVERFLOW ) {

        RtlZeroMemory( WorkContext->ResponseHeader + 1, sizeof( SMB_PARAMS ) );
        WorkContext->ResponseBuffer->DataLength = sizeof( SMB_HEADER ) + sizeof( SMB_PARAMS );
        WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

        //
        // Send the data!
        //
        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );

        return;
    }

    //
    // Not done yet.  Consume more data!
    //

    WorkContext->Connection->ReceivePending = FALSE;

    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //
    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine
    //
    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartConsumeSmbData;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
    irpSp->FileObject = WorkContext->Connection->FileObject;
    irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
    irpSp->Flags = 0;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = WorkContext->ResponseBuffer->BufferLength - sizeof( SMB_HEADER );
    parameters->ReceiveFlags = 0;

    //
    // Set the buffer's partial mdl to point just after the header for this
    // WriteAndX SMB.  We need to preserve the header to make it easier to send
    // back the response.
    //

    IoBuildPartialMdl(
        WorkContext->RequestBuffer->Mdl,
        WorkContext->RequestBuffer->PartialMdl,
        WorkContext->ResponseHeader + 1,
        parameters->ReceiveLength
    );

    irp->MdlAddress = WorkContext->RequestBuffer->PartialMdl;
    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->Flags = (ULONG)IRP_BUFFERED_IO;        // ???

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

}

SMB_PROCESSOR_RETURN_TYPE
SrvConsumeSmbData(
    IN OUT PWORK_CONTEXT WorkContext
)
/*++

Routine Description:

    This routine handles the case where we have received a LargeIndication
    from a client (i.e. received SMB exceeds the negotiated buffer size).  Some
    error has occurred prior to consuming the entire message.  The SMB header is
    already formatted for the response, but we need to consume the rest of the
    incoming data and then send the response.

--*/
{
    if( WorkContext->LargeIndication == FALSE ) {
        return SmbStatusSendResponse;
    }

    IF_DEBUG( ERRORS ) {
        KdPrint(("SRV: SrvConsumeSmbData, BytesAvailable = %u\n",
                WorkContext->BytesAvailable ));
    }

    WorkContext->Irp->Cancel = FALSE;
    WorkContext->Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
    RestartConsumeSmbData( WorkContext );

    return SmbStatusInProgress;
}

BOOLEAN
SrvIsDottedQuadAddress(
    IN PUNICODE_STRING ServerName
)
/*++

Routine Description:
    Return true if the ServerName appears to be a dotted quad address along the lines
    of xxx.yyy.zzz.qqq

    False otherwise
--*/
{
    PWCHAR p, ep;
    DWORD numberOfDots = 0;
    DWORD numberOfDigits = 0;

    PAGED_CODE();

    //
    // If the address is all digits and contains 3 dots, then we'll figure that it's
    //  a dotted quad address.
    //

    ep = &ServerName->Buffer[ ServerName->Length / sizeof( WCHAR ) ];

    for( p = ServerName->Buffer; p < ep; p++ ) {

        if( *p == L'.' ) {
            if( ++numberOfDots > 3 || numberOfDigits == 0 ) {
                return FALSE;
            }
            numberOfDigits = 0;

        } else if( (*p < L'0' || *p > L'9') || ++numberOfDigits > 3 ) {
            return FALSE;
        }
    }

    return (numberOfDots == 3) && (numberOfDigits <= 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvconfg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvconfg.c

Abstract:

    This module defines global configuration data for the LAN Manager
    server.  The variables referenced herein, because they are part of
    the driver image, are not pageable.

    All variables defined here are initialized, but not with real values.
    The initializers are present to get the variables into the Data
    section and out of the BSS section.  The real initialization occurs
    when the server is started.

Author:

    Chuck Lenzmeier (chuckl) 31-Dec-1989

Revision History:

--*/

#include "precomp.h"
#include "srvconfg.tmh"
#pragma hdrstop


//
// Product type and server size.
//

BOOLEAN SrvProductTypeServer = FALSE;
ULONG SrvServerSize = 2;

//
// Server "heuristics", enabling various capabilities.
//

BOOLEAN SrvEnableOplocks = 0;
BOOLEAN SrvEnableFcbOpens = 0;
BOOLEAN SrvEnableSoftCompatibility = 0;
BOOLEAN SrvEnableRawMode = 0;

//
// Receive buffer size, receive work item count, and receive IRP stack
// size.
//

CLONG SrvReceiveBufferLength = 0;
CLONG SrvReceiveBufferSize = 0;

CLONG SrvInitialReceiveWorkItemCount = 0;
CLONG SrvMaxReceiveWorkItemCount = 0;

CLONG SrvInitialRawModeWorkItemCount = 0;
CLONG SrvMaxRawModeWorkItemCount = 0;

CCHAR SrvReceiveIrpStackSize = 0;
CLONG SrvReceiveIrpSize = 0;
CLONG SrvReceiveMdlSize = 0;
CLONG SrvMaxMdlSize = 0;

//
// Minimum negotiated buffer size we'll allow from a client
//
CLONG SrvMinClientBufferSize;

//
// Minimum and maximum number of free connections for an endpoint.
//

ULONG SrvFreeConnectionMinimum = 0;
ULONG SrvFreeConnectionMaximum = 0;

//
// Maximum raw mode buffer size.
//

CLONG SrvMaxRawModeBufferLength = 0;

//
// Cache-related parameters.
//

CLONG SrvMaxCopyReadLength = 0;

CLONG SrvMaxCopyWriteLength = 0;

//
// Initial table sizes.
//

USHORT SrvInitialSessionTableSize = 0;
USHORT SrvMaxSessionTableSize = 0;

USHORT SrvInitialTreeTableSize = 0;
USHORT SrvMaxTreeTableSize = 0;

USHORT SrvInitialFileTableSize = 0;
USHORT SrvMaxFileTableSize = 0;

USHORT SrvInitialSearchTableSize = 0;
USHORT SrvMaxSearchTableSize = 0;

USHORT SrvInitialCommDeviceTableSize = 0;
USHORT SrvMaxCommDeviceTableSize = 0;


//
// Core search timeouts.  There are four timeout values: two for core
// searches that have completed, two for core searches that have had
// STATUS_NO_MORE_FILES returned to the client.  For each of these cases,
// there is a maximum timeout, which is used by the scavanger thread
// and is the longest possible time the search block can be around, and
// a minimum timeout, which is the minimum amount of time the search
// block will be kept around.  The minimum timeout is used when the search
// table is full and cannot be expanded.
//

LARGE_INTEGER SrvSearchMaxTimeout = {0};

//
// Should we remove duplicate searches?
//

BOOLEAN SrvRemoveDuplicateSearches = TRUE;

//
// restrict null session access ?
//

BOOLEAN SrvRestrictNullSessionAccess = TRUE;

//
// This flag is needed to enable old (snowball) clients to connect to the
// server over direct hosted ipx.  It is enabled by default even though
// Snowball ipx clients don't do pipes correctly, because disabling it
// breaks browsing.
//
// *** We actually don't expect anybody to use this parameter now that
//     it defaults to enabled, but due to the nearness of the Daytona
//     release, we are just changing the default instead of removing
//     the parameter.
//

BOOLEAN SrvEnableWfW311DirectIpx = TRUE;

//
// The maximum number of threads allowed on each work queue.  The
//  server tries to minimize the number of threads -- this value is
//  just to keep the threads from getting out of control.
//
// Since the blocking work queue is not per-processor, the max thread
//  count for the blocking work queue is the following value times the
//  number of processors in the system.
//
ULONG SrvMaxThreadsPerQueue = 0;

//
// Load balancing variables
//
ULONG SrvPreferredAffinity = 0;
ULONG SrvOtherQueueAffinity = 0;
ULONG SrvBalanceCount = 0;
LARGE_INTEGER SrvQueueCalc = {0};

//
// Scavenger thread idle wait time.
//

LARGE_INTEGER SrvScavengerTimeout = {0};
ULONG SrvScavengerTimeoutInSeconds = 0;

//
// Various information variables for the server.
//

USHORT SrvMaxMpxCount = 0;
CLONG SrvMaxNumberVcs = 0;

//
// Enforced minimum number of receive work items for the free queue
// at all times.
//

CLONG SrvMinReceiveQueueLength = 0;

//
// Enforced minimum number of receive work items on the free queue
// before the server may initiate a blocking operation.
//

CLONG SrvMinFreeWorkItemsBlockingIo = 0;

//
// Enforced maximum number of RFCBs held on the internal free lists, per processor
//

CLONG SrvMaxFreeRfcbs = 0;

//
// Enforced maximum number of RFCBs held on the internal free lists, per processor
//

CLONG SrvMaxFreeMfcbs = 0;

//
// Enforced maximum size of a saved pool chunk per processor
//
CLONG SrvMaxPagedPoolChunkSize = 0;

//
// Enforced maximum size of a saved non paged pool chunk per processor
//
CLONG SrvMaxNonPagedPoolChunkSize = 0;

//
// The number of elements in the directory name cache per connection
//
CLONG SrvMaxCachedDirectory;

//
// Size of the shared memory section used for communication between the
// server and XACTSRV.
//

LARGE_INTEGER SrvXsSectionSize = {0};

//
// The time sessions may be idle before they are automatically
// disconnected.  The scavenger thread does the disconnecting.
//

LARGE_INTEGER SrvAutodisconnectTimeout = {0};
ULONG SrvIpxAutodisconnectTimeout = {0};

//
// The time a connection structure can hang around without any sessions
//
ULONG SrvConnectionNoSessionsTimeout = {0};

//
// The maximum number of users the server will permit.
//

ULONG SrvMaxUsers = 0;

//
// Priority of server worker and blocking threads.
//

KPRIORITY SrvThreadPriority = 0;

//
// The time to wait before timing out a wait for oplock break.
//

LARGE_INTEGER SrvWaitForOplockBreakTime = {0};

//
// The time to wait before timing out a an oplock break request.
//

LARGE_INTEGER SrvWaitForOplockBreakRequestTime = {0};

//
// This BOOLEAN determines whether files with oplocks that have had
// an oplock break outstanding for longer than SrvWaitForOplockBreakTime
// should be closed or if the subsequest opens should fail.
//
// !!! it is currently ignored, defaulting to FALSE.

BOOLEAN SrvEnableOplockForceClose = 0;

//
// Overall limits on server memory usage.
//

ULONG SrvMaxPagedPoolUsage = 0;
ULONG SrvMaxNonPagedPoolUsage = 0;

//
// This BOOLEAN indicates whether the forced logoff code in the scavenger
// thread should actually disconnect a user that remains on beyond
// his logon hours, or just send messages coaxing them to log off.
//

BOOLEAN SrvEnableForcedLogoff = 0;

//
// The delay and throughput thresholds used to determine if a link
// is unreliable.  The delay is in 100ns.  The Throughput is in bytes/s
// SrvLinkInfoValidTime is the time within which the link info is still
// considered valid.
//

LARGE_INTEGER SrvMaxLinkDelay = {0};
LARGE_INTEGER SrvMinLinkThroughput = {0};
LARGE_INTEGER SrvLinkInfoValidTime = {0};
LONG SrvScavengerUpdateQosCount = 0;

//
// Used to determine how long a work context block can stay idle
// before being freed.
//

ULONG SrvWorkItemMaxIdleTime = 0;

LARGE_INTEGER SrvAlertSchedule = {0}; // Interval at which we do alert checks
ULONG SrvAlertMinutes = 0;            // As above, in minutes
ULONG SrvFreeDiskSpaceThreshold = 0;  // The disk free space threshold to raise an alert
ULONG SrvFreeDiskSpaceCeiling   = 250;// The minimum disk free space to log an event
ULONG SrvDiskConfiguration = 0;       // A bit mask of available disks

//
// List of pipes and shares that can be opened by the NULL session.
//

PWSTR *SrvNullSessionPipes = NULL;
PWSTR *SrvNullSessionShares = NULL;

#if SRVNTVERCHK
//
// List of domain names that we disallow
//
PWSTR *SrvInvalidDomainNames = NULL;
#endif

//
// List of pipes that shouldn't be remapped, even in the clusters case
//
PWSTR *SrvNoRemapPipeNames = NULL;

//
// List of error codes that we do not log to the error log
//
NTSTATUS SrvErrorLogIgnore[ SRVMAXERRLOGIGNORE+1 ];

//
// List of pipes that require a license
//
PWSTR *SrvPipesNeedLicense = NULL;

//
// Delay and number of retries for opens returning sharing violation
//

ULONG SrvSharingViolationRetryCount = 0;
LARGE_INTEGER SrvSharingViolationDelay = {0};

//
// Delay for lock requests returning lock violation
//

ULONG SrvLockViolationDelay = 0;
LARGE_INTEGER SrvLockViolationDelayRelative = {0};
ULONG SrvLockViolationOffset = 0;

//
// Upper limit for searches.
//

ULONG SrvMaxOpenSearches = 0;

//
// length to switchover to mdl read
//

ULONG SrvMdlReadSwitchover = 0;
ULONG SrvMpxMdlReadSwitchover = 0;

//
// maximum length of buffers to copy before taking the whole receive buffer.
// currently this is enabled only for WRITE_MPX on direct host IPX.
//

ULONG SrvMaxCopyLength;

//
// Number of open files that can be cached after close.
//

ULONG SrvCachedOpenLimit = 0;

//
// Globally unique id identifying server
//

GUID ServerGuid;

//
// Does the server support compressed read/write transfers?
//
BOOLEAN SrvSupportsCompression = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvconfg.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvconfg.h

Abstract:

    This module defines global configuration data for the LAN Manager
    server.

Author:

    Chuck Lenzmeier (chuckl) 31-Dec-1989

Revision History:

--*/

#ifndef _SRVCONFG_
#define _SRVCONFG_

//#include <ntos.h>

//#include "srvconst.h"

//
// All global variables referenced in this module are defined in
// srvconfg.c.  See that module for complete descriptions.
//
// The variables referenced herein, because they are part of the driver
// image, are not pageable.
//


//
// Product type and server size.
//

extern BOOLEAN SrvProductTypeServer; // FALSE for Workstation, TRUE for Server
extern ULONG SrvServerSize;

//
// Server "heuristics", enabling various capabilities.
//

extern BOOLEAN SrvEnableOplocks;
extern BOOLEAN SrvEnableFcbOpens;
extern BOOLEAN SrvEnableSoftCompatibility;
extern BOOLEAN SrvEnableRawMode;

//
// Receive buffer size, receive work item count, and receive IRP stack
// size.
//

extern CLONG SrvReceiveBufferLength;
extern CLONG SrvReceiveBufferSize;

extern CLONG SrvInitialReceiveWorkItemCount;
extern CLONG SrvMaxReceiveWorkItemCount;

extern CLONG SrvInitialRawModeWorkItemCount;
extern CLONG SrvMaxRawModeWorkItemCount;

extern CCHAR SrvReceiveIrpStackSize;
extern CLONG SrvReceiveIrpSize;
extern CLONG SrvReceiveMdlSize;
extern CLONG SrvMaxMdlSize;

//
// Minimum negotiated buffer size we'll allow from a client
//
extern CLONG SrvMinClientBufferSize;

//
// Minimum and maximum number of free connections for an endpoint.  When
// the minimum is reached, the resource thread creates more.  When the
// maximum is reached, connections are closed as they are disconnected.
//

extern ULONG SrvFreeConnectionMinimum;
extern ULONG SrvFreeConnectionMaximum;

//
// Initial and maximum table sizes.
//

extern USHORT SrvInitialSessionTableSize;
extern USHORT SrvMaxSessionTableSize;

extern USHORT SrvInitialTreeTableSize;
extern USHORT SrvMaxTreeTableSize;

extern USHORT SrvInitialFileTableSize;
extern USHORT SrvMaxFileTableSize;

extern USHORT SrvInitialSearchTableSize;
extern USHORT SrvMaxSearchTableSize;

//
// Core search timeouts.  The first is for active core searches, the second
// is for core searches where we have returned STATUS_NO_MORE_FILES.  The
// second should be shorter, as these are presumably complete.
//

extern LARGE_INTEGER SrvSearchMaxTimeout;

//
// Should we remove duplicate searches?
//

extern BOOLEAN SrvRemoveDuplicateSearches;

//
// restrict null session access ?
//

extern BOOLEAN SrvRestrictNullSessionAccess;

//
// This flag is needed to enable old (snowball) clients to connect to the
// server over direct hosted ipx.  It is disabled by default because
// snowball  ipx clients don't do pipes correctly.
//

extern BOOLEAN SrvEnableWfW311DirectIpx;

//
// The maximum number of threads allowed on each work queue.  The
//  server tries to minimize the number of threads -- this value is
//  just to keep the threads from getting out of control.
//
// Since the blocking work queue is not per-processor, the max thread
//  count for the blocking work queue is the following value times the
//  number of processors in the system.
//
extern ULONG SrvMaxThreadsPerQueue;

//
// Load balancing variables
//
extern ULONG SrvPreferredAffinity;
extern ULONG SrvOtherQueueAffinity;
extern ULONG SrvBalanceCount;
extern LARGE_INTEGER SrvQueueCalc;

//
// Scavenger thread idle wait time.
//

extern LARGE_INTEGER SrvScavengerTimeout;
extern ULONG SrvScavengerTimeoutInSeconds;

//
// Various information variables for the server.
//

extern USHORT SrvMaxMpxCount;

//
// This is supposed to indicate how many virtual connections are allowed
// between this server and client machines.  It should always be set to
// one, though more VCs can be established.  This duplicates the LM 2.0
// server's behavior.
//

extern CLONG SrvMaxNumberVcs;

//
// Receive work item thresholds
//

//
// The minimum desirable number of free receive work items.
//

extern CLONG SrvMinReceiveQueueLength;

//
// The number of freed RFCBs that we keep internally, per processor
//
extern CLONG SrvMaxFreeRfcbs;

//
// The number of freed MFCBs that we keep internally, per processor
//
extern CLONG SrvMaxFreeMfcbs;

//
// Enforced maximum size of a saved pool chunk per processor
//
extern CLONG SrvMaxPagedPoolChunkSize;

//
// Enforced maximum size of a saved non paged pool chunk per processor
//
extern CLONG SrvMaxNonPagedPoolChunkSize;

//
// The minimum number of free receive work items available before
// the server will start processing a potentially blocking SMB.
//

extern CLONG SrvMinFreeWorkItemsBlockingIo;

//
// The number of cached directory names per connection
//
extern CLONG SrvMaxCachedDirectory;

//
// Size of the shared memory section used for communication between the
// server and XACTSRV.
//

extern LARGE_INTEGER SrvXsSectionSize;

//
// The time sessions may be idle before they are automatically
// disconnected.  The scavenger thread does the disconnecting.
//

extern LARGE_INTEGER SrvAutodisconnectTimeout;
extern ULONG SrvIpxAutodisconnectTimeout;

//
// The time a connection structure can hang around without any sessions
//
extern ULONG SrvConnectionNoSessionsTimeout;

//
// The maximum number of users the server will permit.
//

extern ULONG SrvMaxUsers;

//
// Priority of server worker and blocking threads.
//

extern KPRIORITY SrvThreadPriority;

//
// The time to wait before timing out a wait for oplock break.
//

extern LARGE_INTEGER SrvWaitForOplockBreakTime;

//
// The time to wait before timing out a an oplock break request.
//

extern LARGE_INTEGER SrvWaitForOplockBreakRequestTime;

//
// This BOOLEAN determines whether files with oplocks that have had
// an oplock break outstanding for longer than SrvWaitForOplockBreakTime
// should be closed or if the subsequest opens should fail.
//

extern BOOLEAN SrvEnableOplockForceClose;

//
// Overall limits on server memory usage.
//

extern ULONG SrvMaxPagedPoolUsage;
extern ULONG SrvMaxNonPagedPoolUsage;

//
// This BOOLEAN indicates whether the forced logoff code in the scavenger
// thread should actually disconnect a user that remains on beyond
// his logon hours, or just send messages coaxing them to log off.
//

extern BOOLEAN SrvEnableForcedLogoff;

//
// The delay and throughput thresholds used to determine if a link
// is unreliable.  The delay is in 100ns.  The Throughput is in bytes/s
// SrvLinkInfoValidTime is the time within which the link info is still
// considered valid.
//

extern LARGE_INTEGER SrvMaxLinkDelay;
extern LARGE_INTEGER SrvMinLinkThroughput;
extern LARGE_INTEGER SrvLinkInfoValidTime;
extern LONG SrvScavengerUpdateQosCount;

//
// Used to determine how long a work context block can stay idle
// before being freed.
//

extern ULONG SrvWorkItemMaxIdleTime;

//
// Alert information
//

extern LARGE_INTEGER SrvAlertSchedule;
extern ULONG SrvAlertMinutes;
extern ULONG SrvFreeDiskSpaceThreshold;
extern ULONG SrvFreeDiskSpaceCeiling;
extern ULONG SrvDiskConfiguration;

//
// List of pipes and shares that can be opened by the NULL session.
//

extern PWSTR *SrvNullSessionPipes;
extern PWSTR *SrvNullSessionShares;

#if SRVNTVERCHK
//
// List of domain names that we disallow
//
extern PWSTR *SrvInvalidDomainNames;
#endif

//
// List of pipes that are not remapped, even when we are in a cluster environment
//
extern PWSTR *SrvNoRemapPipeNames;

//
// List of error codes that we do not log to the error log
//
extern NTSTATUS SrvErrorLogIgnore[ SRVMAXERRLOGIGNORE + 1 ];

//
// List of pipes that require a license from the license server
//
extern PWSTR *SrvPipesNeedLicense;

//
// Interval at which SMB statistics are calculated.
//

#define STATISTICS_SMB_INTERVAL 16

//
// Interval at which each thread determines the current system time
//
#define TIME_SMB_INTERVAL   16

//
// Delay and number of retries for opens returning sharing violation
//

extern ULONG SrvSharingViolationRetryCount;
extern LARGE_INTEGER SrvSharingViolationDelay;

//
// Delay for lock requests returning lock violation
//

extern ULONG SrvLockViolationDelay;
extern LARGE_INTEGER SrvLockViolationDelayRelative;
extern ULONG SrvLockViolationOffset;

//
// Upper limit for searches.
//

extern ULONG SrvMaxOpenSearches;

//
// length to switchover to mdl read
//

extern ULONG SrvMdlReadSwitchover;
extern ULONG SrvMpxMdlReadSwitchover;


//
// maximum length of buffers to copy, rather than take the whole buffer.
// currently this is only enabled for WRITE_MPX on direct host IPX.
//

extern ULONG SrvMaxCopyLength;

//
// Globally unique id identifying this server
//

extern
GUID ServerGuid;

//
// Number of open files that can be cached after close.
//

extern ULONG SrvCachedOpenLimit;

//
// Does the server support compressed read/write transfers?
//
extern BOOLEAN SrvSupportsCompression;

//
// *** Change the following defines to limit WinNT (vs. NTAS) parameters.
//
// *** If you make a change here, you need to make the same change in
//     srvsvc\server\srvconfg.h!

#define MAX_USERS_WKSTA                 10
#define MAX_MAXWORKITEMS_WKSTA          64
#define MAX_THREADS_WKSTA                5

#define MAX_USERS_PERSONAL               5
#define MAX_USERS_WEB_BLADE             10


#endif // def _SRVCONFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvconst.h

Abstract:

    This module defines manifest constants for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

#ifndef _SRVCONST_
#define _SRVCONST_

// !!! #include <lmcons.h>


// !!! The following constant should be gotten from netcons.h
#define COMPUTER_NAME_LENGTH 15

//
// This is the size of the data for doing oplock breaks.  Used to compute
// round trip propagation delays.
//

#define SRV_PROPAGATION_DELAY_SIZE  (ULONG) \
            (sizeof(SMB_HEADER) + sizeof(REQ_LOCKING_ANDX) + \
            sizeof(SMB_HEADER) + sizeof(RESP_LOCKING_ANDX) + 100)

//
// The number of slots in the error log record array, must be a power
// of 2.
//

#define NUMBER_OF_SLOTS 8

//
// The number of entries in the SrvMfcbHashTable.  Arbitrary.
//
#define NMFCB_HASH_TABLE    131

//
// The number of resources which guard entries in SrvMfcbHashTable. Only makes
//   sense for this number to be <= NMFCB_HASH_TABLE.
//
#define NMFCB_HASH_TABLE_LOCKS  10      // arbitrary

//
// The number of entries in the SrvShareHashTable.  Arbitrary
//
#define NSHARE_HASH_TABLE   17

//
// The number of pieces of pool we'll hang onto in a LOOK_ASIDE_LIST
// after deallocation for quick re-allocation.  Per processor.
// Involves a linear search...
//
#define LOOK_ASIDE_MAX_ELEMENTS 4

//
// Two look aside lists for quick pool allocation and deallocation are
//  kept, and a POOL_HEADER goes on one list or the other depending on
//  the size of the allocated block.  This is to reduce memory wastage.
//  LOOK_ASIDE_SWITCHOVER is the maximum block size for a memory chunk
//  to end up on the SmallFreeList in the LOOK_ASIDE_LIST
//
#define LOOK_ASIDE_SWITCHOVER   32

//
// We have to multiply the ea size we get back from the system to get
// the buffer size we need to query the ea.  This is because the returned
// ea size is the os/2 ea size.
//
#define EA_SIZE_FUDGE_FACTOR    2

#define ENDPOINT_LOCK_COUNT 4
#define ENDPOINT_LOCK_MASK  (ENDPOINT_LOCK_COUNT-1)

//
// The server keeps a table of NTSTATUS codes that it will avoid putting in
// the error log.  This is the number of codes we can hold
//
#define SRVMAXERRLOGIGNORE  50

//
// The following constants are copied from net\inc\apinums.h
// This is a list of apis and apinumbers that are callable
// on the null session.
//
#define API_WUserGetGroups                          59
#define API_WUserPasswordSet2                       115
#define API_NetServerEnum2                          104
#define API_WNetServerReqChallenge                  126
#define API_WNetServerAuthenticate                  127
#define API_WNetServerPasswordSet                   128
#define API_WNetAccountDeltas                       129
#define API_WNetAccountSync                         130
#define API_WWkstaUserLogoff                        133
#define API_WNetWriteUpdateLog                      208
#define API_WNetAccountUpdate                       209
#define API_WNetAccountConfirmUpdate                210
#define API_SamOEMChgPasswordUser2_P                214
#define API_NetServerEnum3                          215

//
// This is the presumed cache line size for the processor
//
#define CACHE_LINE_SIZE 32

//
// This is the number of ULONGS in a cache line
//
#define ULONGS_IN_CACHE (CACHE_LINE_SIZE / sizeof( ULONG ))

//
// This is the number of samples used to compute the average WORK_QUEUE depth.
// Must be a power of 2
//
#define QUEUE_SAMPLES   8

//
// This is Log2( QUEUE_SAMPLES )
//
#define LOG2_QUEUE_SAMPLES  3

//
// If we have an IPX client, we want to drop every few retries of the same SMB
//  by the client to decrease the server load.  WIN95 backs off its requests
//  when it gets ERR_WORKING, but wfw does not.  So, there's no value (from the
//  server's perspective) in responding very often to the wfw client.  The WfW
//  client retries approx every 300mS, and must receive a response in approx 9
//  seconds.  Therefore, we choose 9 drops as approx 3 seconds.  This will allow two
//  of our responses to be dropped and will allow enough time for the client to
//  try a third time.
//
#define MIN_IPXDROPDUP  2
#define MAX_IPXDROPDUP  9

//
// The number of configuration work items.  This roughly governs the number of kernel
//   worker threads which will be occupied processing configuration irps
//
#define MAX_CONFIG_WORK_ITEMS 2

//
// The maximum size of the buffer associated with a TRANSACTION
//
#define MAX_TRANSACTION_TAIL_SIZE 65*1024

//
// The number of times we will continue doing paged writes with WriteThrough
// set before we try and go back to cached writes.  This is used in situations
// where the cache manager has hit the cache throttle to prevent deadlocks
//
#define MAX_FORCED_WRITE_THROUGH 64

#endif // ndef _SRVCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvblock.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvblock.h

Abstract:

    This module defines the standard header for data blocks maintained
    by the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989
    David Treadwell (davidtr)

Revision History:

--*/

#ifndef _SRVBLOCK_
#define _SRVBLOCK_

//#include "srvtypes.h"


//
// The following define the various types of data blocks used by the
// server.
//
// *** The pool tag array in heapmgr.c must be maintained in concert
//     with these definitions.
//

#define BlockTypeGarbage            0x00
#define BlockTypeBuffer             0x01
#define BlockTypeConnection         0x02
#define BlockTypeEndpoint           0x03
#define BlockTypeLfcb               0x04
#define BlockTypeMfcb               0x05
#define BlockTypeRfcb               0x06
#define BlockTypeSearch             0x07
#define BlockTypeSearchCore         0x08
#ifdef INCLUDE_SMB_PERSISTENT
#define BlockTypeByteRangeLock      0x09
#endif
#define BlockTypeSession            0x0A
#define BlockTypeShare              0x0B
#define BlockTypeTransaction        0x0C
#define BlockTypeTreeConnect        0x0D
#define BlockTypeWaitForOplockBreak 0x0E
#define BlockTypeCommDevice         0x0F
#define BlockTypeWorkContextInitial 0x10
#define BlockTypeWorkContextNormal  0x11
#define BlockTypeWorkContextRaw     0x12
#define BlockTypeWorkContextSpecial 0x13
#define BlockTypeCachedDirectory    0x14

// The following "blocks" do NOT have block headers.

#define BlockTypeDataBuffer         0x15
#define BlockTypeTable              0x16
#define BlockTypeNonpagedHeader     0x17
#define BlockTypePagedConnection    0x18
#define BlockTypePagedRfcb          0x19
#define BlockTypeNonpagedMfcb       0x1A
#define BlockTypeTimer              0x1B
#define BlockTypeAdminCheck         0x1C
#define BlockTypeWorkQueue          0x1D
#define BlockTypeDfs                0x1E
#define BlockTypeLargeReadX         0x1F
#define BlockTypeAdapterStatus      0x20
#define BlockTypeShareRemark        0x21
#define BlockTypeShareSecurityDescriptor    0x22
#define BlockTypeVolumeInformation  0x23
#define BlockTypeFSName             0x24
#define BlockTypeNameInfo           0x25
#define BlockTypeDirectoryInfo      0x26
#define BlockTypeDirCache           0x27
#define BlockTypeMisc               0x28
#define BlockTypeSnapShot           0x29
#ifdef INCLUDE_SMB_PERSISTENT
#define BlockTypePersistentState    0x2A
#define BlockTypePersistentBitMap   0x2B
#define BlockTypePersistShareState  0x2C

// The following is defined just to know how many types there are.

#define BlockTypeMax                0x2D

#else

// The following is defined just to know how many types there are.

#define BlockTypeMax                0x2A
#endif

//
// The following define the various states that blocks can be in.
// Initializing is used (relatively rarely) to indicate that
// creation/initialization of a block is in progress.  Active is the
// state blocks are usually in.  Closing is used to indicate that a
// block is being prepared for deletion; when the reference count on the
// block reaches 0, the block will be deleted.  Dead is used when
// debugging code is enabled to indicate that the block has been
// deleted.
//

#define BlockStateDead          0x00
#define BlockStateInitializing  0x01
#define BlockStateActive        0x02
#define BlockStateClosing       0x03

// The following is defined just to know how many states there are.

#define BlockStateMax           0x04


//
// ALLOCATE_NONPAGED_POOL is a macro that translates to a call to
// SrvAllocateNonPagedPool if debugging is not enabled or to
// SrvAllocateNonPagedPoolDebug if it is enabled.
// DEALLOCATE_NONPAGED_POOL translates to SrvFreeNonPagedPool or
// SrvFreeNonPagedPoolDebug.  The Srv routines are used to track pool
// usage by the server.
//

//
// When POOL_TAGGING is on, we pass the block type through to
// SrvAllocateNonPagedPool so that it can pass a tag to the pool
// allocator.
//

#ifdef POOL_TAGGING
#define ALLOCATE_NONPAGED_POOL(size,type) \
            SrvAllocateNonPagedPool( (size), (type) )
#else
#define ALLOCATE_NONPAGED_POOL(size,type) \
            SrvAllocateNonPagedPool( (size) )
#endif

#define DEALLOCATE_NONPAGED_POOL(addr) SrvFreeNonPagedPool( (addr) )

//
// Routines that track server nonpaged pool usage in order to support the
// "maxnonpagedmemoryusage" configuration parameter.
//

PVOID SRVFASTCALL
SrvAllocateNonPagedPool (
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    ,IN CLONG BlockType
#endif
    );

VOID SRVFASTCALL
SrvFreeNonPagedPool (
    IN PVOID Address
    );

VOID SRVFASTCALL
SrvClearLookAsideList(
    PLOOK_ASIDE_LIST l,
    VOID (SRVFASTCALL *FreeRoutine )( PVOID )
    );

//
// The _HEAP macros are like the _NONPAGED_POOL macros, except they
// operate on paged pool.  The "HEAP" name is historical, from the
// days when the server used process heap instead of paged pool.
//
// *** When SRVDBG2 is enabled, all server control blocks and all
//     reference history blocks must be allocated from nonpaged pool,
//     because SrvUpdateReferenceHistory touches these thing while
//     holding a spin lock (i.e., at raised IRQL).  To make this easy,
//     the ALLOCATE_HEAP and FREE_HEAP macros are modified to use
//     nonpaged pool.  This means that ALL memory allocated by the
//     server comes out of nonpaged pool when SRVDBG2 is on.
//

#if SRVDBG2

#define ALLOCATE_HEAP(size,type) ALLOCATE_NONPAGED_POOL( (size), (type) )
#define ALLOCATE_HEAP_COLD(size,type) ALLOCATE_NONPAGED_POOL( (size), (type) )
#define FREE_HEAP(addr) DEALLOCATE_NONPAGED_POOL( (addr) )

#else // SRVDBG2

//
// When POOL_TAGGING is on, we pass the block type through to
// SrvAllocateNonPagedPool so that it can pass a tag to the pool
// allocator.
//

#ifdef POOL_TAGGING
#define ALLOCATE_HEAP(size,type) SrvAllocatePagedPool( PagedPool, (size), (type) )
#define ALLOCATE_HEAP_COLD(size,type) SrvAllocatePagedPool( (PagedPool | POOL_COLD_ALLOCATION), (size), (type) )
#else
#define ALLOCATE_HEAP(size,type) SrvAllocatePagedPool( PagedPool, (size) )
#define ALLOCATE_HEAP_COLD(size,type) SrvAllocatePagedPool( (PagedPool | POOL_COLD_ALLOCATION), (size) )
#endif

#define FREE_HEAP(addr) SrvFreePagedPool( (addr) )

#endif // else SRVDBG2

//
// Routines that track server paged pool usage in order to support the
// "maxpagedmemoryusage" configuration parameter.
//

PVOID SRVFASTCALL
SrvAllocatePagedPool (
    IN POOL_TYPE PoolType,
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    ,IN CLONG BlockType
#endif
    );

VOID SRVFASTCALL
SrvFreePagedPool (
    IN PVOID Address
    );


//
// SHARE_TYPE is an enumerated type used to indicate what type of
// resource is being shared.  This type corresponds to the server
// table StrShareTypeNames.  Keep the two in sync.
//

typedef enum _SHARE_TYPE {
    ShareTypeDisk,
    ShareTypePrint,
    ShareTypePipe,
    ShareTypeWild   // not a real share type, but can be specified in tcon
} SHARE_TYPE, *PSHARE_TYPE;

//
// SHARE_SNAPSHOT represents a snapshot availible for this share.
//
typedef struct _SHARE_SNAPSHOT
{
    LIST_ENTRY SnapShotList;
    ULONG Flags;
    HANDLE SnapShotRootDirectoryHandle;
    LARGE_INTEGER Timestamp;
    UNICODE_STRING SnapShotName;    // "SS@GMT-YYYY.MM.DD-HH.MM.SS"
    UNICODE_STRING SnapShotPath;
} SHARE_SNAPSHOT, *PSHARE_SNAPSHOT;

#define SNAPSHOT_NAME_LENGTH (strlen("@GMT-YYYY.MM.DD-HH.MM.SS")+1)*sizeof(WCHAR)
#define SNAPSHOT_NAME_FORMAT L"@GMT-%04d.%02d.%02d-%02d.%02d.%02d"
#define SRV_SNAP_SHARE_NOT_FOUND 1

//
// For each resource that the server shares, a Share Block is
// maintained.  The global share list is anchored at SrvShareHashTable.  A
// list of active tree connections using a resource is anchored in the
// Share Block.
//

typedef struct _SHARE {
    BLOCK_HEADER BlockHeader;   // must be first element

    LIST_ENTRY TreeConnectList;
    LIST_ENTRY GlobalShareList;

    HANDLE RootDirectoryHandle;

    UNICODE_STRING ShareName;
    UNICODE_STRING NtPathName;
    UNICODE_STRING DosPathName;
    UNICODE_STRING Remark;


    ULONG ShareNameHashValue;

    union {
        struct {
            UNICODE_STRING Name;
            OEM_STRING OemName;
        } FileSystem;
        HANDLE hPrinter;
    } Type;

    ULONG MaxUses;
    ULONG CurrentUses;
    ULONG CurrentRootHandleReferences;              // used for removable devices
    LONG QueryNamePrefixLength;

    PSECURITY_DESCRIPTOR SecurityDescriptor;        // for tree connects
    PSECURITY_DESCRIPTOR FileSecurityDescriptor;    // file acls on shares

    SHARE_TYPE ShareType;
    BOOLEAN Removable;                              // Is the share storage removable?
    BOOLEAN SpecialShare;
    BOOLEAN IsDfs;                                  // Is this share in the Dfs?
    BOOLEAN IsDfsRoot;                              // Is this share the root of a Dfs?
    BOOLEAN PotentialSystemFile;                    // Are files in this share potentially
                                                    //   system files?
    BOOLEAN IsCatchShare;                           // Should the SRVCATCH code be active
    BOOLEAN UniqueNames;                            // Are all names unique or are shortnames used?

#ifdef INCLUDE_SMB_IFMODIFIED
    BOOLEAN UsnCapable;                             // does this volume have a USN journal?
#endif
    //
    // These flags are returned to the client on a tree connect to instruct the client
    //  how it can cache the files on this share.  The server does not interpret these
    //  flags -- it is the client's responsibility to do the right thing.
    //
    ULONG CSCState;

#ifdef INCLUDE_SMB_PERSISTENT
    BOOLEAN AllowPersistentHandles;                 // allow persistent handles on this volume?
    PERSISTENT_INFO;                                // persistent info
    PVOID   PersistentStateFile;
#endif

    PSRV_LOCK SecurityDescriptorLock;

    LIST_ENTRY SnapShots;
    PSRV_LOCK  SnapShotLock;

    // WCHAR ShareNameData[ShareName.MaximumLength];
    // WCHAR NtPathNameData[PathName.MaximumLength];
    // WCHAR DosPathNameData[PathName.MaximumLength];
    // SECURITY_DESCRIPTOR SecurityDescriptor;

} SHARE, *PSHARE;

//
// For each network that the server uses, an Endpoint Block is
// maintained.  An ENDPOINT contains the network name (for
// administrative purposes), the endpoint name (server address), the
// endpoint (file) handle, a pointer to the endpoint object, a pointer
// to the transport provider's device object, and state information.
// The global endpoint list is anchored at SrvEndpointList.  A list of
// active connections created using an endpoint is anchored in the
// Endpoint Block.
//

#if SRVDBG29
#define HISTORY_LENGTH 256
typedef struct {
    ULONG Operation;
    PVOID Connection;
    BLOCK_HEADER ConnectionHeader;
} HISTORY, *PHISTORY;
#define UpdateConnectionHistory(_op,_endp,_conn) {                          \
    PHISTORY history = &(_endp)->History[(_endp)->NextHistoryLocation++];   \
    if ((_endp)->NextHistoryLocation >= HISTORY_LENGTH) {                   \
        (_endp)->NextHistoryLocation = 0;                                   \
    }                                                                       \
    history->Operation = *(PULONG)(_op);                                    \
    history->Connection = (_conn);                                          \
    if (_conn) {                                                            \
        history->ConnectionHeader = *(PBLOCK_HEADER)(_conn);                \
    }                                                                       \
}
#endif

struct _CONNECTION;

typedef struct _ENDPOINT {
    BLOCK_HEADER BlockHeader;   // must be first element

    //
    // List of free connections.
    //

    LIST_ENTRY FreeConnectionList;

    //
    // Table of connections.  We use a table instead of a list in order
    // to speed up lookup of IPX connections based on the SID stored in
    // the SMB header.
    //

    TABLE_HEADER ConnectionTable;

    ORDERED_LIST_ENTRY GlobalEndpointListEntry;

    //
    // Handle and file/device objects for connection-oriented endpoint
    // or for connectionless server data socket.
    //

    HANDLE EndpointHandle;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PULONG IpxMaxPacketSizeArray;
    ULONG MaxAdapters;

    //
    // Handle and file/device objects for connectionless NetBIOS name
    // socket.
    //

    HANDLE NameSocketHandle;
    PFILE_OBJECT NameSocketFileObject;
    PDEVICE_OBJECT NameSocketDeviceObject;

    PDRIVER_DISPATCH FastTdiSend;
    PDRIVER_DISPATCH FastTdiSendDatagram;

    TDI_ADDRESS_IPX LocalAddress;

    ULONG FreeConnectionCount;
    ULONG TotalConnectionCount;

    //
    // Various flags
    //
    struct {
        ULONG IsConnectionless  : 1;    // connectionless transport?
        ULONG NameInConflict    : 1;    // unable to claim name?
        ULONG IsPrimaryName     : 1;    // set if not an alternate name
        ULONG IsNoNetBios       : 1;    // set if we are direct hosting on a VC
        ULONG RemapPipeNames    : 1;    // set if we are remapping pipe names for clusters
    };

    WCHAR NetworkAddressData[12 + 1];

    UNICODE_STRING NetworkName;         // administrative name
    UNICODE_STRING TransportName;       // e.g., "\Device\Nbf_Elnkii01"
    UNICODE_STRING ServerName;          // e.g., L"NTSERVER"
    ANSI_STRING TransportAddress;       // e.g., "NTSERVER        "
    UNICODE_STRING NetworkAddress;
    UNICODE_STRING DomainName;          // domain being served by this endpoint
    OEM_STRING     OemDomainName;       // oem version of domain name

    // WCHAR NetworkNameData[NetworkName.MaximumLength/2];
    // WCHAR TransportNameData[TransportName.MaximumLength/2];
    // WCHAR ServerName[ ServerName.MaximumLength/2 ];
    // CHAR TransportAddressData[TransportAddress.MaximumLength];
    // WCHAR DomainNameData[ DNLEN + 1];
    // CHAR  OemDomainNameData[ DNLEN+1 ]

    BOOLEAN AlternateAddressFormat;     // should this endpoint be included when
                                        // enumerating?
#if SRVDBG29
    ULONG NextHistoryLocation;
    HISTORY History[HISTORY_LENGTH];
#endif

} ENDPOINT, *PENDPOINT;


//
// Size of search hash table (must be a power of 2)
//

#define SEARCH_HASH_TABLE_SIZE      4

typedef struct _HASH_TABLE_ENTRY {

    LIST_ENTRY ListHead;
    BOOLEAN Dirty;

} HASH_TABLE_ENTRY, *PHASH_TABLE_ENTRY;

//
// When we discover something which is a directory, we place the name
//  in this per-connection cache for quick re-use for CheckPath.
//
typedef struct {
    BLOCK_HEADER;
    LIST_ENTRY      ListEntry;                  // list is linked through this element
    UNICODE_STRING  DirectoryName;              // canonicalized name of this directory
    USHORT          Tid;                        // DirectoryName is relative to this tid
    ULONG           TimeStamp;                  // Tick count when this element was cached

} CACHED_DIRECTORY, *PCACHED_DIRECTORY;

//
// For each connection (virtual circuit) that is created, a Connection
// Block is maintained.  All connections made over a single endpoint are
// linked through that endpoint.  Tables of sessions, tree connects, and
// files created using a connection are anchored in the connection
// block.
//
// The Lock field in the connection protects the data in the connection
// and the data structures associated with the connection, such as
// the tree connects and sessions.  However, the list of connections
// linked off the endpoint is protected by the endpoint lock, and
// LFCBs and RFCBs associated with a connection are protected by
// the MFCB's lock.
//

typedef struct _PAGED_CONNECTION {

    PAGED_HEADER PagedHeader;

    //
    // List of active transactions
    //

    LIST_ENTRY TransactionList;

    //
    // This list is maintained in order of access, so the entry at the top
    // of the list is the oldest, the entry at the bottom is the youngest.
    //

    LIST_ENTRY CoreSearchList;

    //
    // This information is used to determine whether oplocks and Raw
    // I/O's are allowed.  This is determined by information obtained by
    // querying the transport provider using TDI_QUERY_CONNECTION_INFO.
    //

    LARGE_INTEGER LinkInfoValidTime;
    LARGE_INTEGER Throughput;
    LARGE_INTEGER Delay;

    //
    // Table headers for session, tree connect, and search tables.
    //

    TABLE_HEADER SessionTable;
    TABLE_HEADER TreeConnectTable;
    TABLE_HEADER SearchTable;

    HANDLE ConnectionHandle;

    //
    // The number of sessions active on the connection.
    //

    USHORT CurrentNumberOfSessions;
    USHORT CurrentNumberOfCoreSearches;

    //
    // Hash table for picking out duplicate core searches
    //

    HASH_TABLE_ENTRY SearchHashTable[SEARCH_HASH_TABLE_SIZE];

    //
    // A string for the client's name.  The Buffer field points to the
    // leading slashes (below), the MaximumLength is
    // (COMPUTER_NAME_LENGTH + 3) * sizeof(WCHAR), and Length is the
    // number of characters in the name that are not blanks *
    // sizeof(WHCAR).
    //

    UNICODE_STRING ClientMachineNameString;

    //
    // The following two fields make up the client's name in the form
    // "\\client              ", including a trailing NULL.
    //

    WCHAR LeadingSlashes[2];
    WCHAR ClientMachineName[COMPUTER_NAME_LENGTH+1];

    //
    // The encryption key obtained from LsaCallAuthenticationPackage.
    // This is a per-VC value--any logon on a given VC uses this
    // encryption key.
    //

    UCHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH];

    //
    // If we have an NT5 client, this is its build number (if non-zero)
    //
    ULONG ClientBuildNumber;

    //
    //  If the client has a persistent connection, here's the info for this
    //  record in the state file.
    //
#ifdef INCLUDE_SMB_PERSISTENT
    PERSISTENT_INFO;                                // persistent info
#endif

    //
    // Have we logged an invalid SMB for this client yet?  We use this
    //  flag to keep a single client from flooding the event log
    //
    BOOLEAN LoggedInvalidSmb;

#if SRVNTVERCHK
    //
    // Have we determined that the client's NT build number is too old to
    //  allow it to connect to this server?
    //
    BOOLEAN ClientTooOld;
#endif

} PAGED_CONNECTION, *PPAGED_CONNECTION;

#define MAX_SAVED_RESPONSE_LENGTH 100

typedef struct _CONNECTION {

    QUEUEABLE_BLOCK_HEADER ;    // must be first element

/* start of spin lock cache line */

    //
    // Per-connection spin lock.
    //

    KSPIN_LOCK SpinLock;

    //
    // Points to the endpoint spinlock that guards this connection's
    // entry in the endpoint connection table.
    //

    PKSPIN_LOCK EndpointSpinLock;

    //
    // This is the WORK_QUEUE we are queueing on, which may not be the
    //  same as PreferredWorkQueue due to load balancing
    //
    PWORK_QUEUE CurrentWorkQueue;

    //
    // A countdown for the number of operations we'll do before we try
    //  to pick a better processor for this connection
    //
    ULONG BalanceCount;

    //
    // Cached Rfcb
    //

    struct _RFCB *CachedRfcb;
    ULONG CachedFid;

    //
    // BreakIIToNoneJustSent is set when a oplock break II to none is
    // sent, and reset whenever an SMB is received.  If a raw read
    // arrives while this is set, the raw read is rejected.
    //

    BOOLEAN BreakIIToNoneJustSent;

    //
    // Raw io enabled
    //

    BOOLEAN EnableRawIo;

    //
    // Sid represents the connection's location in the endpoint's
    // connection table.
    //

    USHORT Sid;

    // The SidIndex allows us to use all the 16 bits for the index. For
    // regular connections this prevents the aliasing problem that can occur
    // in using the IXPSID index since the IPX sequence number takes up 4 bits

    USHORT  SidIndex;

    // additional USHORT to satisfy alignment on dword boundaries
    USHORT  Pad;

    //
    // Pointer to the endpoint, fileobject, and deviceobject
    //

    PENDPOINT Endpoint;
    PFILE_OBJECT FileObject;

    PDEVICE_OBJECT DeviceObject;

    //
    // The maximum message size we can send over this connection.
    //

    ULONG   MaximumSendSize;

    //
    // This is the WORK_QUEUE we would prefer to be on, because this
    //  queue assigns work to the same procesor that is handling the
    //  adaptor's DPCs
    //

    PWORK_QUEUE PreferredWorkQueue;

    //
    // Table header for file table.
    //

    TABLE_HEADER FileTable;

    //
    // The SMB dialect chosen for this connection.  Used in fsd.
    //

    SMB_DIALECT SmbDialect;

    //
    // List of active work items associated with the connection.
    //

    LIST_ENTRY InProgressWorkItemList;

    //
    // Stores the time of the last oplock break resp processed.  This is
    // used to synchronize readraw processing with the oplock break
    // processing.
    //

    ULONG LatestOplockBreakResponse;

    //
    // The following two fields descibe operations in progress on this
    // connection.  It is possible that there are multiple oplock breaks
    // in progress.  Also, there is a brief window when multiple raw
    // reads can be active -- after we've sent the response to one raw
    // read, but before we've done postprocessing (so it looks like the
    // first one is still in progress), we could receive another raw
    // read request.
    //
    // Interaction between the two fields are controlled using
    // SrvFsdSpinLock (see the block comment in oplock.c for details).
    //

    LONG OplockBreaksInProgress;
    ULONG RawReadsInProgress;

    //
    // Are oplocks allowed?
    //

    BOOLEAN OplocksAlwaysDisabled;
    BOOLEAN EnableOplocks;

    //
    // Is the client coming in over IPX?
    //
    BOOLEAN DirectHostIpx;

    //
    // Are security signatures currently active for this connection?
    //  Security signatures are not supported for Direct Host IPX connections
    //  and some W9x clients
    //
    BOOLEAN SmbSecuritySignatureActive;

    union {
        //
        //  The following struct of this union holds relevant state
        //   when the client is connecting over direct host IPX.
        //   IpxAddress holds the client's IPX address, when the client
        //   'connects' over IPX.
        //
        struct {
            USHORT SequenceNumber;
            USHORT LastResponseLength;
            USHORT LastResponseBufferLength;
            USHORT LastUid;
            USHORT LastTid;
            NTSTATUS LastResponseStatus;
            ULONG IpxDuplicateCount;
            ULONG IpxDropDuplicateCount;
            ULONG StartupTime;
            TDI_ADDRESS_IPX IpxAddress;
            PVOID LastResponse;
        };

        //
        // This struct holds relevant state when the client is using
        //  a virtual circuit.
        //
        struct {

            //
            // The following fields are used for security signatures.
            //
            MD5_CTX Md5Context;

            ULONG SmbSecuritySignatureIndex;

            // If we are unable to allocate a WORK_CONTEXT
            // at receive indicate time, the receive is done
            // in SrvFsdServiceNeedResourceQueue.  Depending
            // on the received SMB, we sometimes do not send
            // a response SMB.  Since the Tdi lookahead data
            // is not available when SrvFsdServiceNeedResourceQueue
            // is run, we have to remember not to advance the signature
            // index for the response.

            BOOLEAN NoResponseSignatureIndex;

            //
            // The following field, if non-zero is the IP address of the client
            //
            ULONG ClientIPAddress;

        };
    };

    //
    // Pointer to paged part of connection block.
    //

    PPAGED_CONNECTION PagedConnection;

    //
    // Per-connection interlock.
    //

    KSPIN_LOCK Interlock;

    //
    // Quadword align list entries and large ints
    //

    LIST_ENTRY EndpointFreeListEntry;

    //
    // A list of deferred oplock work break items.  Oplock breaks are
    // deferred if a read raw is in progress, or if the server runs
    // out of work context blocks, and cannot send the oplock break
    // request.
    //

    LIST_ENTRY OplockWorkList;

    //
    // List of RFCBs with batch oplocks that have been cached after
    // being closed by the client.  Count of such RFCBs.
    //

    LIST_ENTRY CachedOpenList;
    ULONG CachedOpenCount;

    //
    // List of directories which have been recently identified.  This is a list of
    //  CACHED_DIRECTORY entries.
    //
    LIST_ENTRY CachedDirectoryList;
    ULONG      CachedDirectoryCount;

    //
    // Security context handle for the extensible security negotiate buffer.
    //

    CtxtHandle NegotiateHandle;

    //
    // The following represent consumer capabilities.
    //

    ULONG ClientCapabilities;

    //
    // Per-connection resource.
    //

    SRV_LOCK Lock;

    //
    // Lock for dealing with the license server
    //

    SRV_LOCK LicenseLock;

    //
    // Oem version of the client machine name string.
    //

    OEM_STRING OemClientMachineNameString;

    //
    // Head of singly linked list of cached transactions.
    //

    SLIST_HEADER CachedTransactionList;
    LONG CachedTransactionCount;

    //
    // The time when the last message was received for this connection
    //
    ULONG LastRequestTime;

    //
    // If we are on the OnNeedResourceQueue for a pending recieve, this
    //  is the amount of data that was indicated to us.
    //
    ULONG BytesAvailable;

    //
    // OnNeedResource is true if this connection is on the global need
    // recource queue.  This happens if it is waiting for a work context
    // block to complete a pending receive or an oplock break request.
    //

    BOOLEAN OnNeedResourceQueue;

    //
    // NotReusable is set when an operation fails in such a way that the
    // server's idea of the connection state may be different than the
    // transport's.  For example, a server-initiated disconnect failed.
    // If we tried to reuse the connection (by returning it from a
    // connect indication), the transport would get confused.  When
    // NotReusable is set, SrvDereferenceConnection frees the connection
    // instead of putting it on the endpoint's free list.
    //

    BOOLEAN NotReusable;

    //
    // DisconnectPending indicates that a disconect indication has been
    // received from the transport.  ReceivePending indicates that the
    // server could not assign a work item to handle a receive indication.
    //

    BOOLEAN DisconnectPending;
    BOOLEAN ReceivePending;

    //
    // Oem version of the client name.  We need this because we could
    // not do unicode operations in the fsd, where we initially get our
    // computer name.
    //

    CHAR OemClientMachineName[COMPUTER_NAME_LENGTH+1];

    //
    // Information about the client context.
    //

    UNICODE_STRING ClientOSType;
    UNICODE_STRING ClientLanManType;

    UCHAR BuiltinSavedResponse[MAX_SAVED_RESPONSE_LENGTH];

    // Used to monitor how many work contexts a client is using up
    LONG InProgressWorkContextCount;
    LONG OperationsPendingOnTransport;
    BOOLEAN IsConnectionSuspect;
    DISCONNECT_REASON DisconnectReason;

} CONNECTION, *PCONNECTION;

//
// For each session that is created, a Session Block is maintained.  All
// sessions created over a single connection are linked through a table
// owned by that connection.  A list of files opened using a session can
// be obtained by searching the file table owned by the connection
// block.
//

// This is copied from ntmsv1_0.h

#define MSV1_0_USER_SESSION_KEY_LENGTH 16

typedef struct _SESSION {
    //
    // *** NOTE:  The reference count field in the session block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;

    PNONPAGED_HEADER NonpagedHeader;

    ULONG CurrentFileOpenCount;          // count of files open on the session
    ULONG CurrentSearchOpenCount;        // count of searches open on the session

    ORDERED_LIST_ENTRY GlobalSessionListEntry;

    PCONNECTION Connection;

    //
    // If clients are using the GSS-style authentication, we query the
    //  UserHandle for the user and domain names.  If they are using
    //  old-style authentication, we store the names here.  In any case,
    //  code that needs access to the user and/or domain names should
    //  call SrvGetUserAndDomainName() and SrvReleaseUserAndDomainName()
    //
    UNICODE_STRING NtUserName;
    UNICODE_STRING NtUserDomain;

    LARGE_INTEGER StartTime;
    LARGE_INTEGER LastUseTime;           // for autologoff
    LARGE_INTEGER LogOffTime;            // for forced logoff
    LARGE_INTEGER KickOffTime;           // for forced logoff
    LARGE_INTEGER LastExpirationMessage; // for forced logoff

    LUID LogonId;
    CHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    CHAR LanManSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    CtxtHandle UserHandle;               // Security handle to this user

    USHORT MaxBufferSize;                // Consumer's maximum buffer size
    USHORT MaxMpxCount;                  // Actual max multiplexed pending requests
    USHORT Uid;

    BOOLEAN UsingUppercasePaths;         // Must paths be uppercased?
    BOOLEAN GuestLogon;                  // Is the client logged on as a guest?
    BOOLEAN EncryptedLogon;              // Was an encrypted password sent?
    BOOLEAN LogoffAlertSent;
    BOOLEAN TwoMinuteWarningSent;
    BOOLEAN FiveMinuteWarningSent;
    BOOLEAN IsNullSession;               // Is client using a null session?
    BOOLEAN IsAdmin;                     // Is this an administrative user?
    BOOLEAN IsLSNotified;                // Does license server know about this user?
    BOOLEAN LogonSequenceInProgress;     // Are we in the middle of an extended logon sequence?
    BOOLEAN IsSessionExpired;            // Do we need to reauthenticate?
    HANDLE  hLicense;                    // if( IsLSNotified ) this is License handle

    //
    //  If the client has a persistent connection, here's the info for this
    //  record in the state file.
    //
#ifdef INCLUDE_SMB_PERSISTENT
    PERSISTENT_INFO;                                // persistent info
#endif

#if SRVNTVERCHK
    //
    // Have we determined that we don't like this client's domain?
    //
    BOOLEAN ClientBadDomain;
#endif

    //CHAR UserNameBuffer[UserName.MaximumLength];

} SESSION, *PSESSION;

//
// For each tree connect that is made, a Tree Connect Block is
// maintained.  All tree connects made over a single connection are
// linked through a table owned by that connection.  All tree connects
// made to a single shared resource are linked through that share block.
// A list of files opened using a tree connect can be obtained by
// searching the file table owned by the connection block.
//

typedef struct _TREE_CONNECT {
    //
    // *** NOTE:  The reference count field in the tree connect block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;

    PNONPAGED_HEADER NonpagedHeader;

    PCONNECTION Connection;
    PSESSION Session;
    PSHARE Share;

    ORDERED_LIST_ENTRY GlobalTreeConnectListEntry;

    ULONG CurrentFileOpenCount;

    LIST_ENTRY ShareListEntry;
    LIST_ENTRY PrintFileList;                // only if print share

    LARGE_INTEGER StartTime;

    UNICODE_STRING ServerName;

    BOOLEAN RemapPipeNames;

    USHORT Tid;

} TREE_CONNECT, *PTREE_CONNECT;


//
// Master File Control Block (MFCB) -- one per named file that is open
//      at least once.  Used to support compatibility mode and oplocks.
//
// Local File Control Block (LFCB) -- one for each local open instance.
//      Represents local file object/handle.  There may be multiple
//      LFCBs linked to a single MFCB.
//
// Remote File Control Block (RFCB) -- one for each remote open instance.
//      Represents remote FID.  There is usually one RFCB per LFCB, but
//      multiple compatibility mode RFCBs may be linked to a single LFCB.
//      Multiple remote FCB opens for a single file from a single session
//      are folded into one RFCB, because old DOS redirectors only send
//      one close.
//

//
// For each disk file that is open, a Master File Control Block (MFCB)
// is maintained.  If a given file is open multiple times, there is one
// MFCB for the file and multiple LFCBs, one for each local open
// instance.  All MFCBs are linked into the global Master File Table.
// The MFCB has a list of the LFCBs representing open instances for the
// file.
//

typedef struct _NONPAGED_MFCB {

    union {

        //
        // When NONPAGED_MFCB structures are freed, they may be placed
        // on the WORK_QUEUE's MfcbFreeList to avoid unnecessary Nonpaged
        // pool activity.  SingleListEntry is used for the linkage.
        //

        SINGLE_LIST_ENTRY SingleListEntry;

        struct {
            ULONG Type;
            PVOID PagedBlock;

            //
            // We must serialize opens to the same file, since 2 concurrent opens
            // may be compatibility mode opens.  This lock also protects all data
            // in this MFCB and the LFCBs and RFCBs associated with this MFCB.
            //

            SRV_LOCK Lock;
        };
    };

    LARGE_INTEGER OpenFileSize;
    ULONG OpenFileAttributes;

} NONPAGED_MFCB, *PNONPAGED_MFCB;

typedef struct _MFCB {

    //
    // *** NOTE:  The reference count field in the mfcb block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;   // must be first element

    PNONPAGED_MFCB NonpagedMfcb;

    //
    // All LFCBs for a given named file are linked to the parent MFCB.
    //

    LIST_ENTRY LfcbList;

    //
    // The count of active RFCB for this MFCB.  This is used to coordinate
    // compatibility opens with non-compatibility mode opens.
    //

    ULONG ActiveRfcbCount;

    //
    // The fully qualified name of the file is appended to the MFCB.
    // The FileName field is a descriptor for the name.
    //
    UNICODE_STRING FileName;

    //
    // Mfcbs are linked into the MfcbHashTable by MfcbHashTableEntry
    //
    LIST_ENTRY MfcbHashTableEntry;

    //
    // FileNameHashValue is a hash value derived from the upper case
    //  version of FileName.  It is used to speed up name comparisons, and to
    //  locate the hash entry
    //
    ULONG FileNameHashValue;

    //
    // CompatibilityOpen indicates whether the file is open in
    // compatibility mode.
    //
    BOOLEAN CompatibilityOpen;

    //
    // Timestamp for SnapShot opens
    //
    LARGE_INTEGER SnapShotTime;

#if SRVCATCH
    BOOLEAN SrvCatch;
#endif

    // WCHAR FileNameData[FileName.MaximumLength/2];

} MFCB, *PMFCB;

//
// The MFCBs are all linked into the master MFCB hash table.
//
typedef struct {
    LIST_ENTRY  List;           // the list of MFCBs in this bucket
    PSRV_LOCK   Lock;           // protects this bucket's list
} MFCBHASH, *PMFCBHASH;


//
// For each instance of a local file open, a Local File Control Block
// (LFCB) is maintained.  All LFCBs for a particular named file are
// linked through the MFCB for that file.
//
// LFCBs contain information that is specific to the local open, such
// as the file handle and a pointer to the file object.  The LFCB also
// contains other information that is common to all child RFCBs, such
// as pointers to the owning connection and tree connect.
//
//

typedef struct _LFCB {

    union {
        BLOCK_HEADER BlockHeader;           // must be first element
        SINGLE_LIST_ENTRY SingleListEntry;  // used when LFCB is freed
    };

    //
    // Multiple remote opens of a file are folded into a single local
    // open by linking the RFCBs to the parent LFCB.
    //

    LIST_ENTRY RfcbList;

    //
    // The number of associated active RFCBs.
    //

    ULONG HandleCount;

    //
    // LFCBs are linked into their MFCB's open file list.
    //

    PMFCB Mfcb;
    LIST_ENTRY MfcbListEntry;

    //
    // Connection, Session, and TreeConnect are referenced pointers to
    // the respective "owning" blocks.
    //

    PCONNECTION Connection;
    PSESSION Session;
    PTREE_CONNECT TreeConnect;

    //
    // GrantedAccess is the access obtained when the file was opened.
    // For a compatibility mode open, this is the maximum access
    // available to the client; individual opens may have less access.
    //

    ACCESS_MASK GrantedAccess;

    //
    // FileHandle is a handle to the open file.  FileObject is a
    // referenced pointer.  DeviceObject is NOT a referenced pointer;
    // the reference to the file object prevents the device object from
    // going away.
    //

    HANDLE FileHandle;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;

    //
    // FileMode tracks whether writethrough is enabled for this file
    // object.

    ULONG FileMode;

    //
    // The job ID of a print job corresponding to the opened file.
    // This is only used for print file opens.
    //

    ULONG JobId;

    //
    // Cache these hot-path entry points.
    //

    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;

    //
    // CompatibilityOpen indicates whether the file is open in
    // compatibility mode.
    //

    BOOLEAN CompatibilityOpen;

    //
    //  Has this file been modified by any clients?  Used to determine when
    //  we should write out USN close records on file close.
    //

#ifdef INCLUDE_SMB_IFMODIFIED
    BOOLEAN FileUpdated;
#endif

} LFCB, *PLFCB;


//
// For each instance of a remote file open, a Remote File Control Block
// (RFCB) is maintained.  The RFCB points to the LFCB that contains the
// local file handle.  Normally RFCBs and LFCBs exist in one-to-one
// correspondence, but multiple compatibility mode opens are folded into
// a single local open, so that the server can enforce the appropriate
// sharing rules.
//
// RFCBs contain information that is specific to the remote open, such
// as the assigned FID, the PID of the creator, the granted access mask,
// and the current file position.
//
// All RFCBs for a single connection are linked through a table owned by
// that connection; the FID assigned to the RFCB represents an index
// into the file table.  Pointers to the owning connection and tree
// connect can be found in the LFCB, which is pointed to by the RFCB.  A
// list of files opened through a given tree connect can be obtained by
// searching the owning connection's file table for RFCBs whose parent
// LFCBs point to the tree connect.
//

#ifdef SLMDBG

#define SLMDBG_CLOSE 1
#define SLMDBG_RENAME 2

#define SLMDBG_TRACE_COUNT 32
#define SLMDBG_TRACE_DATA  32

typedef struct _RFCB_TRACE {
    UCHAR Command;
    UCHAR Flags;
    TIME Time;
    union {
        struct {
            ULONG Offset;
            ULONG Length;
        } ReadWrite;
        struct {
            ULONG Offset;
            ULONG Length;
        } LockUnlock;
    } Data;
} RFCB_TRACE, *PRFCB_TRACE;

#endif

//
// WRITE_MPX_CONTEXT holds context associated with an active Write Block
// Multiplexed sequence.
//
// !!! This structure is probably big enough to be worth putting
//     outside the RFCB.
//

#define MAX_GLOM_RUN_COUNT 8

typedef struct _WRITE_MPX_RUN {
    USHORT Offset;
    USHORT Length;
} WRITE_MPX_RUN, *PWRITE_MPX_RUN;

typedef struct _WRITE_MPX_CONTEXT {

    //
    // ReferenceCount counts the number of Write Mpx SMBs that are
    // currently being processed.  When this count goes to zero, and
    // we have received the sequenced command that ends the current
    // mux, we send the response.  This method is needed to ensure
    // that we don't process the mux SMBs out-of-order, which leads
    // to performance problems, and even worse, data corruption,
    // thanks to the mask-shifting method used by the Snowball redir.
    //

    ULONG ReferenceCount;

    //
    // Mask holds the logical OR of the masks received in multiplexed
    // write requests.  When an IPX client sends the last block of write
    // mpx data, we send back MpxMask to indicate whether we lost any
    // frames.
    //

    ULONG Mask;

    //
    // FileObject is a copy of the file object pointer from the LFCB.
    //

    PFILE_OBJECT FileObject;

    //
    // Mid holds the MID of the current multiplexed write.  PreviousMid
    // hold the MID of the previous one.  This needs to be retained in
    // order to deal with duplicated write mux SMBs -- if a duplicate
    // SMB arrives AFTER the first SMB of the next write mux (with a new
    // MID), we need to know to toss it, not kill the new write mux.
    //

    USHORT Mid;
    USHORT PreviousMid;

    //
    // SequenceNumber holds the sequence number given in the last
    // request of the mux.  This needs to be retained because we
    // may be simultaneously processing previous parts of the mux
    // when we detect that we've received the sequenced comand.
    //

    USHORT SequenceNumber;

    //
    // Glomming is set if the current write mux series is being glommed
    // into one large write.
    //
    // GlomPending is set when the indication for the first packet of
    // a new write mux occurs.  It is cleared when the FSP is done
    // preparing the glomming operation.  While GlomPending is set,
    // subsequent packets of the write mux are queued to GlomDelayList.
    //

    BOOLEAN Glomming;
    BOOLEAN GlomPending;
    LIST_ENTRY GlomDelayList;

    ULONG StartOffset;
    USHORT Length;
    BOOLEAN GlomComplete;

    //
    // MpxGlommingAllowed is set when the underlying file system
    // supports MDL write.
    //

    BOOLEAN MpxGlommingAllowed;

    PMDL MdlChain;

    ULONG NumberOfRuns;
    WRITE_MPX_RUN RunList[MAX_GLOM_RUN_COUNT];

} WRITE_MPX_CONTEXT, *PWRITE_MPX_CONTEXT;

#define NO_OPLOCK_BREAK_IN_PROGRESS     ((UCHAR)-1)

typedef struct _PAGED_RFCB {

    PAGED_HEADER PagedHeader;

    //
    // RFCBs are linked into their parent LFCB's compatibility open
    // list.
    //

    LIST_ENTRY LfcbListEntry;

    //
    // Information about the last lock attempt by the client that failed.
    //

    LARGE_INTEGER LastFailingLockOffset;

    //
    // Current oplock break timeout.
    //

    LARGE_INTEGER OplockBreakTimeoutTime;

    //
    // FcbOpenCount indicates how many remote FCB opens this RFCB
    // represents.  (Whether an RFCB represents a compatibility mode
    // open can be determined by looking at the LFCB.)
    //
    // *** Note that FCB opens are treated similarly to compatibility
    //     mode opens.  However, soft compatibility maps compatibility
    //     opens into regular opens, but it does not change an FCB open
    //     into a non-FCB open.  So it is possible to have an FCB open
    //     that is not a compatibility mode open.
    //

    CLONG FcbOpenCount;

    //
    // Per-file context for a direct host IPX smart card, if we have one.
    //  The smart card is willing to handle the read operations for this file if
    //  IpxSmartCardContext is not NULL.
    //
    PVOID   IpxSmartCardContext;

    //
    //  list of outstanding byte locks we have for this RFCB
    //

#ifdef INCLUDE_SMB_PERSISTENT
    LIST_ENTRY ByteRangeLocks;

    //
    //  If the client has a persistent connection, here's the info for this
    //  record in the state file.
    //
    PERSISTENT_INFO;                                // persistent info
#endif

} PAGED_RFCB, *PPAGED_RFCB;

typedef struct _RFCB {

    //
    // The list entry in the RFCB's block header is used to queue the
    // RFCB for oplock processing to the nonblocking worker thread work
    // queue, which also contains work context blocks.
    //
    // *** Note that this is an unnamed field, so that its elements can
    //     can be referenced directly.  The field names defined in
    //     QUEUEABLE_BLOCK_HEADER cannot be used elsewhere in this
    //     block.
    //

    QUEUEABLE_BLOCK_HEADER ;   // must be first element

/* start of spin lock cache line */

    //
    // These booleans indicate whether we've already been granted
    // read/write/lock access, thus saving a few instructions on every
    // read/write/lock.  These are checked during the file open.
    //

    BOOLEAN ReadAccessGranted;   // TRUE, if read access in granted
    BOOLEAN WriteAccessGranted;  // TRUE, if write access is granted
    BOOLEAN LockAccessGranted;   // TRUE, if lock access is granted
    BOOLEAN UnlockAccessGranted; // TRUE, if unlock access is granted
    BOOLEAN AppendAccessGranted; // TRUE, if append access is granted

    //
    // CurrentPosition maintains the file position after the last Read,
    // Write, or Seek by the client.  This field is needed only to
    // support relative Seeks.  Since clients that use relative seeks only
    // need 32-bits of file position, this field is maintained as a ULONG.
    //

    ULONG CurrentPosition;

    //
    // Type of this share.  Accessed in the fsd.
    //

    SHARE_TYPE ShareType;

    //
    // The connection pointer is copied from the LFCB so that we can
    // find the connection at DPC level (the LFCB is paged, as is the
    // pointer to the LFCB in PagedRfcb).
    //

    PCONNECTION Connection;

    //
    // The LFCB is used to find the file handle, file object, etc.
    //

    PLFCB Lfcb;

    //
    // MpxGlommingAllowed is set when the underlying file system
    // supports MDL write.
    //

    BOOLEAN MpxGlommingAllowed;

    //
    // The following two booleans describe the read mode, and blocking
    // mode of a named pipe.
    //

    BOOLEAN BlockingModePipe;  // TRUE = Blocking, FALSE = Nonblocking
    BOOLEAN ByteModePipe;      // TRUE = Byte mode, FALSE = Message mode

    //
    // Indicates whether this file has been written to.
    //

    BOOLEAN WrittenTo;

/* end of spin lock cache line */

    //
    // RawWriteSerializationList holds works items that have been queued
    // pending completion of a raw write.  When the raw write count is
    // decremented to 0, this list is flushed by restarting all queued
    // work items.
    //

    LIST_ENTRY RawWriteSerializationList;

    //
    // fid << 16.  Used for key computations.
    //

    ULONG ShiftedFid;

    //
    // RawWriteCount counts the number of active raw writes.  This is
    // used to prevent the file handle from being closed while raw
    // writes are in progress.  If Raw writes are in progress when the
    // close happens, we defer the cleanup until the rawwritecount goes
    // to zero.
    //

    ULONG RawWriteCount;

    //
    // SavedError retains the error code when a raw read or a raw write
    // in writebehind mode gets an error.  The next access to the file
    // will receive an error indication.
    //

    NTSTATUS SavedError;

    //
    // NumberOfLocks is the count of locks currently on the file.
    // It is here to support the File APis and RFCB cacheing -- you can't
    //   cache an RFCB if it has locks in it.
    //

    LONG NumberOfLocks;

    //
    // Fid is the file ID assigned to the file and returned to the
    // client.  Pid is the process ID given by the client when the file
    // was opened.  Tid is a copy of the parent tree connect's Tid
    // field.  Uid is used to ensure that the client using a file handle
    // is the same one that opened the file.
    //

    USHORT Fid;
    USHORT Pid;
    USHORT Tid;
    USHORT Uid;

    //
    // WriteMpx is a WRITE_MPX_CONTEXT structure.  It retains context
    // about multiplexed write operations.  This structure is not used
    // on connectionless sessions.
    //

    WRITE_MPX_CONTEXT WriteMpx;

    //
    // FileMode tracks whether writethrough is enabled for this file
    // object.

    ULONG FileMode;

    //
    // MFCB points to the Master File Control Block for this file.
    //

    PMFCB Mfcb;

    //
    // Oplock information.  The oplock IRP currently in progress, etc.
    // The list entry for queueing the RFCB for oplock break processing
    // is located in the block header.
    //

    PIRP Irp;
    BOOLEAN OnOplockBreaksInProgressList;

    //
    // The oplock level to change to, if there is an oplock break
    // in progress.  Otherwise it is always NO_OPLOCK_BREAK_IN_PROGRESS.
    //

    UCHAR NewOplockLevel;

    //
    // This boolean indicates whether or an oplock granted open response
    // need to be sent for this RFCB.  If it is FALSE, and an oplock break
    // request needs to be sent, the request must be deferred until after
    // sending the open response.
    //
    // Access to these fields is synchronized using the MFCB lock.
    //

    BOOLEAN OpenResponseSent;
    BOOLEAN DeferredOplockBreak;

    //
    // Pointer to the paged portion of the rfcb
    //

    PPAGED_RFCB PagedRfcb;

    //
    // CachedOpen is set if the RFCB has been cached after being
    // closed by the client.
    //

    LIST_ENTRY CachedOpenListEntry;
    BOOLEAN CachedOpen;

    //
    // See if this rfcb can be cached.
    //

    BOOLEAN IsCacheable;

    //
    // See if the file was accessed in the last scavenger update period.
    // (This is used to update the session last access time).
    //

    BOOLEAN IsActive;

    //
    // Is it ok for us to do MPX writes to this RFCB?
    //
    BOOLEAN MpxWritesOk;

    //
    // Is this file a persistent handle?
    //
#ifdef INCLUDE_SMB_PERSISTENT
    BOOLEAN PersistentHandle;
#endif

    //
    //  This event is used when the server needs to request an oplock II
    //  when the initial oplock request fails.
    //

    PKEVENT RetryOplockRequest;

    //
    // All RFCBs in the server are stored in a global list to support
    // NetFileEnum.  This field contains the LIST_ENTRY for the RFCB in
    // the global list and a resume handle to support resuming
    // enumerations.
    //

    ORDERED_LIST_ENTRY GlobalRfcbListEntry;

    //
    // GrantedAccess is the access allowed through this open.  This
    // GrantedAccess may allow less access than that given in the parent
    // LFCB for compatibility mode opens.
    //

    ACCESS_MASK GrantedAccess;

    //
    // ShareAccess is the file sharing access specified when the file
    // was opened.
    //

    ULONG ShareAccess;

    //
    // Current oplock state.
    //

    OPLOCK_STATE OplockState;

    //
    // Is it ok for us to do MPX reads to this RFCB?
    //
    BOOLEAN MpxReadsOk;
#ifdef SRVCATCH
    BOOLEAN SrvCatch;
#endif

#ifdef SRVDBG_RFCBHIST
    UCHAR HistoryIndex;
    ULONG History[256];
#endif

#ifdef SLMDBG
    ULONG NextTrace;
    ULONG TraceWrapped;
    ULONG WriteCount;
    ULONG OperationCount;
    RFCB_TRACE Trace[SLMDBG_TRACE_COUNT];
#endif

} RFCB, *PRFCB;

#ifdef SRVDBG_RFCBHIST
VOID UpdateRfcbHistory( PRFCB Rfcb, ULONG Event );
#else
#define UpdateRfcbHistory(_rfcb,_event)
#endif

#ifdef INCLUDE_SMB_PERSISTENT
typedef struct _BYTELOCK {

    BLOCK_HEADER BlockHeader;

    //
    // Locks are linked into their parent RFCB's open list.
    //

    LIST_ENTRY RfcbListEntry;

    PRFCB   Rfcb;

    //
    // Information about the lock.
    //

    LARGE_INTEGER LockOffset;
    LARGE_INTEGER LockLength;

    BOOLEAN Exclusive;

    //
    //  If the client has a persistent connection, here's the info for this
    //  record in the state file.
    //
    PERSISTENT_INFO;                                // persistent info

} BYTELOCK, *PBYTELOCK;
#endif

#ifdef SLMDBG

NTSTATUS
SrvValidateSlmStatus (
    IN HANDLE StatusFile,
    IN struct _WORK_CONTEXT *WorkContext,
    OUT PULONG FileOffsetOfInvalidData
    );

VOID
SrvReportCorruptSlmStatus (
    IN PUNICODE_STRING StatusFile,
    IN NTSTATUS Status,
    IN ULONG Offset,
    IN ULONG Operation,
    IN PSESSION Session
    );

VOID
SrvReportSlmStatusOperations (
    IN PRFCB Rfcb,
    IN BOOLEAN Force
    );

VOID
SrvDisallowSlmAccess (
    IN PUNICODE_STRING StatusFile,
    IN HANDLE RootDirectory
    );

VOID
SrvDisallowSlmAccessA (
    IN PANSI_STRING StatusFile,
    IN HANDLE RootDirectory
    );

BOOLEAN
SrvIsSlmAccessDisallowed (
    IN PUNICODE_STRING StatusFile,
    IN HANDLE RootDirectory
    );

BOOLEAN
SrvIsSlmStatus (
    IN PUNICODE_STRING StatusFile
    );

BOOLEAN
SrvIsTempSlmStatus (
    IN PUNICODE_STRING StatusFile
    );

#endif

//
// Each incoming (request) and outgoing (response) buffer is represented
// by a BUFFER structure.  This descriptor describes the size of the
// buffer, its address, and a full and partial MDL that may be used
// to describe the buffer.
//
// *** The descriptor contains a pointer to the real buffer, which is
//     normally allocated out of nonpaged pool.  The descriptor itself
//     may be allocated out of the FSP heap, although receive buffer
//     descriptors are allocated from nonpaged pool, so the FSD
//     read/write code can access them.
//

typedef struct _BUFFER {
    PVOID Buffer;
    CLONG BufferLength;             // Length allocated to buffer
    PMDL Mdl;                       // MDL describing entire buffer
    PMDL PartialMdl;                // Partial MDL for read/write/etc.
    CLONG DataLength;               // Length of data currently in buffer
    ULONG Reserved;                 // Pad to quadword
} BUFFER, *PBUFFER;

#define MIN_SEND_SIZE               512
#define MAX_PARTIAL_BUFFER_SIZE     65535

//
// For each search request that is started (Find First or core Search),
// a search block is allocated.  This is used to hold enough information
// that the search may be quickly restarted or rewound.
//
// Ths InUse field is protected by Connection->Lock--this lock must be
// held when accessing this field of the search block.
//

typedef struct _SEARCH {
    BLOCK_HEADER BlockHeader;

    HANDLE DirectoryHandle;

    ULONG LastFileIndexReturned;
    UNICODE_STRING SearchName;
    UNICODE_STRING LastFileNameReturned;

    LARGE_INTEGER LastUseTime;
    LIST_ENTRY LastUseListEntry;
    LIST_ENTRY HashTableEntry;

    PSESSION Session;
    PTREE_CONNECT TreeConnect;
    ULONG SearchStorageType;

    struct _DIRECTORY_CACHE *DirectoryCache;
    USHORT NumberOfCachedFiles;

    USHORT SearchAttributes;
    SHORT CoreSequence;
    SHORT TableIndex;
    USHORT HashTableIndex;

    USHORT Pid;
    USHORT Flags2;

    BOOLEAN Wildcards;
    BOOLEAN InUse;

    // WCHAR SearchNameData[SearchName.MaximumLength/2];

} SEARCH, *PSEARCH;

//
// Each pending transaction request (Transaction, Transaction2, and
// Ioctl) has a transaction block.  It records information that is
// needed to stage input and output data across multiple SMBs.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE WITHOUT CHANGING THE CORRESPONDING *
// * STRUCTURE IN net\inc\xstypes.h!                                 *
// *                                                                 *
// *******************************************************************
//

typedef struct _TRANSACTION {

    //
    // *** NOTE:  The reference count field in the transaction block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;

    PNONPAGED_HEADER NonpagedHeader;

    //
    // The connection, session, and tree connect pointers are referenced
    // pointers if and only if Inserted is TRUE.  Otherwise, they are
    // simply copies of the work context block's pointers.
    //

    PCONNECTION Connection;
    PSESSION Session;
    PTREE_CONNECT TreeConnect;

    LIST_ENTRY ConnectionListEntry;

    UNICODE_STRING TransactionName; // not used if Transaction2

    ULONG StartTime;
    ULONG Timeout;
    CLONG cMaxBufferSize;        // if needed we stash this here

    //
    // The following pointers point into either the trailing portion
    // of the transaction block or the last received SMB.
    //
    // *** ALL information in buffers pointed to by these parameters
    //     should ALWAYS be in little-endian format.  Always use the
    //     macros defined in srvmacro.h (SmbGetAlignedUshort, etc.) to
    //     read from or write into these buffers.
    //

    PSMB_USHORT InSetup;
    PSMB_USHORT OutSetup;
    PCHAR InParameters;
    PCHAR OutParameters;
    PCHAR InData;
    PCHAR OutData;

    //
    // *** Data in all the remaining fields of the transaction block are
    //     in native format, so no special macros should be used, except
    //     when copying data to/from the actual SMB.
    //

    CLONG SetupCount;               // amount received (all in first buffer)
    CLONG MaxSetupCount;            // max that can be sent back
    CLONG ParameterCount;           // amount received or sent
    CLONG TotalParameterCount;      // amount expected
    CLONG MaxParameterCount;        // max that can be sent back
    CLONG DataCount;                // amount received or sent
    CLONG TotalDataCount;           // amount expected
    CLONG MaxDataCount;             // max that can be sent back

    USHORT Category;                // Ioctl function category
    USHORT Function;                // Nt Transaction or ioctl function code

    //
    // The SMB data and paramters may or may not be copied to the
    // transaction buffer.  If they are not copied, they are read
    // and/or written directly into an SMB buffer.
    //
    // Setup words are never copied.
    //

    BOOLEAN InputBufferCopied;       // if FALSE input buffer is in SMB
    BOOLEAN OutputBufferCopied;      // if FALSE output buffer is in SMB
    BOOLEAN OutDataAllocated;        // if TRUE OutData buffer has been separately allocated

    USHORT Flags;

    USHORT Tid;
    USHORT Pid;
    USHORT Uid;
    USHORT OtherInfo;

    HANDLE FileHandle;              // Used only for CallNamedPipe processing
    PFILE_OBJECT FileObject;        // Used only for CallNamedPipe processing

    //
    // The following fields are used while the response is being sent.
    //

    CLONG ParameterDisplacement;
    CLONG DataDisplacement;

    //
    // PipeRequest is set for named pipe transactions.  RemoteApiRequest
    // is set for remote API requests.
    //

    BOOLEAN PipeRequest;
    BOOLEAN RemoteApiRequest;

    //
    // The following boolean is TRUE if the transaction has been inserted
    // on the connection's transaction list.  It will be FALSE when the
    // transaction can be handled using a single SMB exchange.
    //

    BOOLEAN Inserted;

    //
    // This boolean is TRUE if the transaction is in the state where
    // it is waiting for a transaction secondary request to come in
    // to acknowledge the receipt of the previous piece of a multipiece
    // transaction response.
    //

    BOOLEAN MultipieceIpxSend;

    //
    // This boolean is TRUE if all of the transaction data has been received
    //  and the transaction has been scheduled for execution.
    //
    BOOLEAN Executing;

    //
    // The main part of the transaction block is trailed by transaction
    // name data and possibly setup words and parameter and data bytes.
    //

} TRANSACTION, *PTRANSACTION;

//
// Each pending blocking open request has a BLOCKING_OPEN block.  This
// block contains all the info needed to make the call into the file
// system.

typedef struct _BLOCKING_OPEN {
    BLOCK_HEADER BlockHeader;

    PMFCB Mfcb;

    PIO_STATUS_BLOCK IoStatusBlock;

    OBJECT_ATTRIBUTES ObjectAttributes;

    UNICODE_STRING RelativeName;

    PVOID EaBuffer;
    CLONG EaLength;

    LARGE_INTEGER AllocationSize;
    ULONG DesiredAccess;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;

    BOOLEAN CaseInsensitive;

} BLOCKING_OPEN, *PBLOCKING_OPEN;

//
// SRV_TIMER is used for timed operations.  The server maintains a pool
// of these structures.
//

typedef struct _SRV_TIMER {
    SINGLE_LIST_ENTRY Next;
    KEVENT Event;
    KTIMER Timer;
    KDPC Dpc;
} SRV_TIMER, *PSRV_TIMER;

typedef struct _IPX_CLIENT_ADDRESS {
    TA_IPX_ADDRESS IpxAddress;
    TDI_CONNECTION_INFORMATION Descriptor;
    IPX_DATAGRAM_OPTIONS DatagramOptions;
} IPX_CLIENT_ADDRESS, *PIPX_CLIENT_ADDRESS;

//
// The state for an I/O request is maintained in a Work Context Block.
// Various fields in the block are filled in or not depending upon the
// request.  When a worker thread removes a work item from the FSP work
// queue, it uses the context block, and items pointed to by the
// context block, to determine what to do.
//
// *** Not all of the back pointers have to be here, because a tree
//     connect points to a session, which points to a connection, which
//     points to an endpoint, etc.  However, depending on the operation
//     and the state of the operation, we may have a connection pointer
//     but no session pointer, etc.  So we maintain all of the
//     pointers.
//
// *** Any changes to the first 2 elements of this structure must be
//     made in concert with the SPECIAL_WORK_ITEM structure in srvtypes.h
//

typedef struct _WORK_CONTEXT {

    //
    // The list entry in the block header is used to queue the WC for to
    // the nonblocking or blocking worker thread work queue.  The
    // nonblocking work queue also contains RFCBs.
    //
    // *** Note that this is an unnamed field, so that its elements can
    //     can be referenced directly.  The field names defined in
    //     QUEUEABLE_BLOCK_HEADER cannot be used elsewhere in this
    //     block.
    //
    // Timestamp (in the block header) is used to calculate the total
    // time this work context block was on the work queue.
    //
    // When the work context block is not in use, Timestamp is used to
    // record the time at which the block was inserted on the free list.
    // This is used to determine when dynamically-allocated work context
    // blocks have been idle long enough justify their deletion.
    //
    // FspRestartRoutine (in the block header) is the routine that is to
    // be called by worker thread when the work item is dequeued from
    // the work queue.
    //

    QUEUEABLE_BLOCK_HEADER ;   // must be first element

    //
    // This is the WORK_QUEUE to queue on if we're doing nonblocking work
    //   It will always point to a valid WORK_QUEUE, even if we're doing
    //   blocking work.
    //
    PWORK_QUEUE CurrentWorkQueue;

    //
    // The free list this should be returned to when work is done
    //
    PSLIST_HEADER FreeList;

    //
    // FsdRestartRoutine is the routine that is to be called by the
    // FSD's I/O completion routine.  This routine can do more
    // processing or queue the work item to the FSP.  In this case, when
    // a worker thread removes the item from the work queue, it calls
    // FspRestartRoutine.
    //

    PRESTART_ROUTINE FsdRestartRoutine;

    //
    // Linkage field for the in-progress work item list.
    //

    LIST_ENTRY InProgressListEntry;

    //
    // Pointers to various structures that might be used.
    // These pointers are all referenced pointers.  It is
    // the responsibility of the SMB processing routines to
    // dereference and clear these pointers when they are no
    // longer needed.
    //
    PRFCB Rfcb;
    PSHARE Share;
    PSESSION Session;
    PTREE_CONNECT TreeConnect;


    //
    // These are gathered in one place to facilitate quick zeroing
    // of their values when the work context is finished
    //
    struct _WorkContextZeroBeforeReuse {
        //
        // unreferenced pointer to the endpoint structure for
        //  this work context.  Filled in by SrvRestartReceive and
        //  available to all SMB processing routines.
        //
        //  Endpoint must be the first element in this structure.  See
        //   INITIALIZE_WORK_CONTEXT in srvmacro.h if changed.
        //
        PENDPOINT Endpoint;         // not a referenced pointer

        //
        // referenced pointer to the connection structure for this
        //  this work context.  Filled in by SrvRestartReceive and
        //  available to all SMB processing routines.
        //
        PCONNECTION Connection;     // a reference pointer

        //
        // The number of times this SMB has been queued to a worker thread
        // for processing.
        //
        ULONG ProcessingCount;

        //
        // This is a random collection of flags that are needed to steer
        // the WorkItem
        //
        struct {

            //
            // Can the processing of the current SMB block?
            //

            ULONG BlockingOperation : 1;

            //
            // UsingExtraSmbBuffer is TRUE if this work context uses the an extra SMB
            // buffer.
            //

            ULONG UsingExtraSmbBuffer : 1;

            //
            // Did this Work Item cause a successful oplock open to occur?
            //

            ULONG OplockOpen : 1;

            //
            // If we got an ACCESS_DENIED error when opening a file, was it because
            // of share ACL checking?

            ULONG ShareAclFailure : 1;

            //
            // Should the WorkContext be queued to the head of the list?
            //
            ULONG QueueToHead : 1;

            //
            //  Even if security signatures are enabled, do not generate a signature for
            //   this response.
            //
            ULONG NoResponseSmbSecuritySignature : 1;

            //
            // The indicated message exceeds the SMB buffer size.  This is allowed
            //  only for specific SMB(s)
            //
            ULONG LargeIndication: 1;

#if DBG_STUCK
            //
            // Do not include this operation in the StuckOperation catching logic
            //  which is in the scavenger
            //
            ULONG IsNotStuck : 1;
#endif

        };

        // For SnapShot usage
        LARGE_INTEGER SnapShotTime;

    };

    //
    // Pointers to allocated buffers.  RequestBuffer is the buffer into
    // which the SMB is read.  ResponseBuffer is the buffer into which
    // the response is written.
    //
    // *** Currently, ResponseBuffer is always the same as
    //     RequestBuffer.  We have separate pointers in order to reduce
    //     dependence on this being the case.
    //

    PBUFFER RequestBuffer;
    PBUFFER ResponseBuffer;

    //
    // SMB processing pointers.  These are pointers into the request
    // buffer.  They are maintained in the work context block in support
    // of SMB processors that do asynchronous I/O.
    //
    // Separate request and response parameter pointers are maintained
    // to make AndX processing simpler and more efficient.  RequestHeader
    // is normally the same as ResponseHeader -- both are normally the
    // same as RequestBuffer.Buffer.  SMB processing code must not depend
    // on this -- it must not assume the the request and response buffers
    // are the same, nor can it assume that they are different.  Special
    // rules around AndX SMBs do allow them to assume that the response
    // to one command will not overwrite the next request.
    //

    PSMB_HEADER RequestHeader;
    PVOID RequestParameters;
    PSMB_HEADER ResponseHeader;
    PVOID ResponseParameters;

    //
    // Pointer to the IRP associated with this work item.
    //

    PIRP Irp;

    //
    // StartTime stores the time at which processing of the current
    // request began so that the turnaround time may be calculated.
    //

    ULONG StartTime;

    //
    // The PartOfInitialAllocation boolean indicates whether this work
    // item is part of the block of work items allocated at server
    // startup (see blkwork.c\SrvAllocateInitialWorkItems).  Such work
    // items cannot be deleted during server operation.  A work item
    // that is dynamically allocated in response to server load does not
    // have this bit set, and is a candidate for deletion when the
    // server's load decreases.
    //

    ULONG PartOfInitialAllocation;

    //
    // The following field contadins the command code of the next
    // command to be processed in an SMB.  The SMB processing
    // initializer and chained (AndX) SMB command processors load this
    // field prior to calling or returning to SrvProcessSmb.
    //

    UCHAR NextCommand;

    //
    // ClientAddress is used when receiving or sending over IPX.
    //

    PIPX_CLIENT_ADDRESS ClientAddress;

    //
    // Spin lock protecting reference count.
    //

    KSPIN_LOCK SpinLock;

    //
    // The security signature index for the request
    //
    ULONG SmbSecuritySignatureIndex;

    //
    // The security signature index for the response
    //
    ULONG ResponseSmbSecuritySignatureIndex;


    //
    // The following union is used to hold request-specific state while
    // a response is being sent or while waiting for more data.
    //

    union {

        //
        // RemainingEchoCount is used when processing the Echo SMB.
        //

        USHORT RemainingEchoCount;

        //
        // Structure used for lock processing.  This structure is
        // currently used when processing the Lock, LockingAndX, and the
        // LockAndRead SMBs.
        //

        struct {

            //
            // LockRange is used when processing the LockingAndX SMB.  It is
            // really either a PLOCKING_ANDX_RANGE, or a PNTLOCKING_ANDX_RANGE
            // not just a PVOID.
            //

            PVOID LockRange;

            //
            // Timer is a timer and DPC used to timeout lock requests.
            //

            PSRV_TIMER Timer;

#ifdef INCLUDE_SMB_PERSISTENT
            LARGE_INTEGER Offset;           // offset for this lock
            LARGE_INTEGER Length;           // length of this lock
            BOOLEAN Exclusive;              // is this lock exclusive?
#endif

        } Lock;

        //
        // Transaction is used when processing the Transaction[2] SMBs.
        // Or when processing a write and X SMB.
        //

        PTRANSACTION Transaction;

        //
        // MdlIo is used when processing the ReadRaw or WriteRaw
        // SMBs when "MDL read" or "MDL write" is used.  It
        // retains the status of the response send while the MDL is
        // returned to the file system.
        //

        struct {
            IO_STATUS_BLOCK IoStatus;
            ULONG IrpFlags;
        } MdlIo;

        //
        // LastWriteTime is used when processing any Read or Write SMB
        // that uses RestartChainedClose as a restart routine.  This
        // field contains the new last write time to set for the file.
        //

        ULONG LastWriteTime;

        //
        // CurrentTableIndex is used when processing the Flush SMB.  It
        // retains the current index into the connection's file table
        // when an asynchronous flush is in progress.
        //

        LONG CurrentTableIndex;

        //
        // ReadRaw is used when processing the Read Block Raw SMB.
        // Offset is the file offset of the read.  SavedResponseBuffer
        // points to the original SMB response buffer descriptor, which
        // is temporarily replaced by a descriptor for the raw read
        // buffer.  MdlRead indicates whether an MDL read was used,
        // rather than a Copy read.
        //

        struct {

            union {

                //
                // Used for non named pipe reads
                //

                LARGE_INTEGER Offset;
                ULONG Length;

                //
                // Used only for named pipe reads
                //

                PFILE_PIPE_PEEK_BUFFER PipePeekBuffer;

            } ReadRawOtherInfo;

            PBUFFER SavedResponseBuffer;

            BOOLEAN MdlRead;

        } ReadRaw;

        //
        // WriteRaw is used when processing the Write Block Raw SMB.
        // FinalResponseBuffer points to the buffer allocated to contain
        // the final response SMB, if writethrough mode was specified.
        // Offset is the file offset of the write.  ImmediateLength is
        // the amount of write data that was sent with the request SMB.
        // Pid is the PID of the writer, used to form the lock key on
        // the write.  FileObject is a pointer to the file object copied
        // from the LFCB.  (Pid is not used when MDL write is used;
        // FileObject is not used when copy write is used.)
        //

        struct {
            struct _WORK_CONTEXT *RawWorkContext;
        } WriteRawPhase1;

        struct {
            LARGE_INTEGER Offset;
            ULONG Length;
            PVOID FinalResponseBuffer;
            CLONG ImmediateLength;
            PMDL FirstMdl;
            //PFILE_OBJECT FileObject;
            USHORT Pid;
            BOOLEAN MdlWrite;
            BOOLEAN ImmediateWriteDone;
        } WriteRaw;

        //
        // ReadAndXCompressed is the structure used when handling
        //  compressed ReadAndX
        //
        struct {
            LARGE_INTEGER ReadOffset;   // original read offset
            ULONG ReadLength;           // original read length
            ULONG CompressedInfoLength;
            FSRTL_AUXILIARY_BUFFER Aux;
        } ReadAndXCompressed;

        //
        // ReadAndX is the structure used when handling the ReadAndX
        // SMB.
        //

        struct {
            LARGE_INTEGER ReadOffset;
            ULONG ReadLength;
            PCHAR ReadAddress;
            union {
                struct {
                    PFILE_PIPE_PEEK_BUFFER PipePeekBuffer;
                    ULONG LastWriteTimeInSeconds;   // used if Close is chained
                };
                struct {                        // used for ReadLength > negotiated size
                    PBYTE   Buffer;             // allocated paged pool, if copy read
                    PMDL    SavedMdl;
                    PMDL    CacheMdl;
                    USHORT  PadCount;
                    BOOLEAN MdlRead;
                };
            };
        } ReadAndX;

#define READX_BUFFER_OFFSET (sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_ANDX, Buffer) )

        //
        // WriteAndX is the structure used when handling the flavor of WriteAndX that
        //  exceeds the negotiated buffer size
        //
        struct {
            ULONG CurrentWriteLength;       // amount of data that was written this time
            LARGE_INTEGER Offset;           // file offset for this piece of the write
            ULONG RemainingWriteLength;     // amount of data remaining to be read from xport
            ULONG Key;                      // lock key for the operation
            PCHAR WriteAddress;             // address in buffer for the data
            ULONG BufferLength;             // Maximum buffer length in this WorkContext
            NTSTATUS FinalStatus;           // Final status of the operation
            PMDL MdlAddress;                // File MDL if MdlWrite == TRUE
            BOOLEAN InitialComplete;        // TRUE if we have written first part to the file
        } WriteAndX;

        //
        // WriteC is used when we are doing compressed writes
        //
        struct {
            LARGE_INTEGER Offset;           // File offset for this piece of the write
            ULONG Key;                      // Lock key for the operation
            ULONG CdiLength;                // COMPRESSED_DATA_INFO length if compressed write
            ULONG CompressedDataLength;     // Length of compressed data
            ULONG UncompressedDataLength;   // Uncompressed length of the write
            PCOMPRESSED_DATA_INFO Cdi;      // The compressed data info descriptor for this write
            ULONG InitialFragmentSize;      // Amount of CompressedData in initial receive
            FSRTL_AUXILIARY_BUFFER Aux;
            PMDL    Mdl;                    // Mdl we are using for compressed writes
            BOOLEAN MdlCompleted;           // Have we called MdlWriteCompleteCompressed yet?
            PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
            PFILE_OBJECT FileObject;
            PDEVICE_OBJECT DeviceObject;
            PBYTE CompressedBuffer;         // In case the PrepareMdlWrite failed!
            PBYTE UncompressedBuffer;
        } WriteC;

        //
        // ReadMpx is the structure used when handling the ReadMpx SMB, unless
        //  we have a SmartCard accelerating our reads.  In this case,
        //  SmartCardRead is used.
        //

        struct {
            ULONG Offset;
            USHORT FragmentSize;
            USHORT RemainingLength;
            ULONG ReadLength;
            BOOLEAN MdlRead;
            UCHAR Unused;
            USHORT CurrentMdlOffset; // logically part of MDL read struct below
            union {
                struct {
                    PVOID MpxBuffer;
                    PMDL MpxBufferMdl;
                    PCHAR NextFragmentAddress;
                } ;
                struct {
                    PMDL FirstMdl;
                    PMDL CurrentMdl;
                } ;
            } ;
        } ReadMpx;

        //
        // SmartCardRead is used to handle direct host read requests if we have
        //   a Smart Card accelerating the particular request.
        //
        struct {
            PDEVICE_OBJECT DeviceObject;
            PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
        } SmartCardRead;

        //
        // WriteMpx is the structure used when handling the WriteMpx SMB.
        //

        struct {
            ULONG Offset;
            USHORT WriteLength;
            USHORT Mid;
            BOOLEAN FirstPacketOfGlom;
            PVOID Buffer;
            ULONG ReceiveDatagramFlags;
            PVOID TransportContext;
            PMDL DataMdl;
        } WriteMpx;

        struct {
            LARGE_INTEGER   CacheOffset;
            ULONG           WriteLength;
            PMDL            CacheMdl;
        } WriteMpxMdlWriteComplete;


        //
        // FastTransactNamedPipe is used when handling a small named pipe
        // transaction.
        //

        struct {
            PSMB_USHORT OutSetup;
            PCHAR OutParam;
            PCHAR OutData;
        } FastTransactNamedPipe;

#ifdef INCLUDE_SMB_PERSISTENT
        struct {

            ULONG            ResumeSmbStatus;
            PRESTART_ROUTINE FsdRestartRoutine;
            PRESTART_ROUTINE FspRestartRoutine;

        } MakePersistent;
#endif

    } Parameters;

    // !!! check whether the compiler leaves a dword gap here!

    //
    // The following union holds state information about SMBs in progress
    // waiting for an oplock break.  It is kept separate from the Parameters
    // union, since information from both is needed to process some SMBs.
    //

    union {

        //
        // Open is the structure used when handling the Open,
        // OpenAndX, Open2, Create, or CreateTemporary SMB.
        //

        struct {
            PRFCB Rfcb;
            PFILE_FULL_EA_INFORMATION NtFullEa;
            ULONG EaErrorOffset;

            //
            // The Irp used to open the file is the same Irp used to handle
            //  the oplock processing.  This can cause us to lose the original
            //  iosb->Information.  Save it here.
            //
            ULONG_PTR IosbInformation;

            //
            // If TRUE, the file was opened only in order to get a handle
            // so that we can wait for an oplock to break.  This handle will
            // be immediately closed, and the open will be retried with the
            // user requested access.
            //

            BOOLEAN TemporaryOpen;
        } Open;

        //
        // FileInformation is the structure used when handling the
        // QueryInformation, SetInformation, QueryPathInformation,
        // or SetPathInformation SMB.
        //

        struct {
            HANDLE FileHandle;
        } FileInformation;

        //
        // LockLength is used to contain the length of a byte range
        // lock since the IRP stack location has no room to hold it.

        LARGE_INTEGER LockLength;

        //
        // StartSend is used by SrvStartSend when queueing a work item
        // to the FSP for handling by the SmbTrace logic.
        //

        struct {
            PRESTART_ROUTINE FspRestartRoutine;
            ULONG SendLength;
        } StartSend;

    } Parameters2;

    //
    // This field is used when the current operation is blocked waiting
    // for an oplock break to occur.
    //

    struct _WAIT_FOR_OPLOCK_BREAK *WaitForOplockBreak;


    union {
        //
        // where we keep the actual client address data.
        //
        IPX_CLIENT_ADDRESS ClientAddressData;


        //
        // For a VC-based client, this is the amount of available data if
        //  LargeIndication is set (above)
        //
        ULONG BytesAvailable;
    };

    struct {
        LARGE_INTEGER G_StartTime;
        ULONG         ElapseKCPU;
        ULONG         ElapseUCPU;
        ULONG         ClientAddr;
        PFILE_OBJECT  FileObject;
    };

    ULONG         KCPUStart;
    ULONG         UCPUStart;
    UCHAR         PreviousSMB;
    UCHAR         bAlreadyTrace;
    USHORT        FileNameSize;
    WCHAR         strFileName[1024];

#if DBG_STUCK
    //
    // Time at which this work context was allocated for this current
    //  unit of work.  This time is examined by debugging code in the
    //  scavenger to help find operations which are taking too long
    //  to complete.
    //
    LARGE_INTEGER OpStartTime;
#endif
} WORK_CONTEXT, *PWORK_CONTEXT;

//
// Structure used to maintain information about a thread waiting for
// an oplock break.
//

typedef struct _WAIT_FOR_OPLOCK_BREAK {
    BLOCK_HEADER BlockHeader;
    LIST_ENTRY ListEntry;
    LARGE_INTEGER TimeoutTime;
    PIRP Irp;
    WAIT_STATE WaitState;
} WAIT_FOR_OPLOCK_BREAK, *PWAIT_FOR_OPLOCK_BREAK;


//
// Block manager routines
//

//
// Buffer routines
//

VOID
SrvAllocateBuffer (
    OUT PBUFFER *Buffer,
    IN CLONG BufferLength
    );

VOID
SrvFreeBuffer (
    IN PBUFFER Buffer
    );

//
// Connection routines
//

VOID
SrvAllocateConnection (
    OUT PCONNECTION *Connection
    );

VOID
SrvCloseConnection (
    IN PCONNECTION Connection,
    IN BOOLEAN RemoteDisconnect
    );

VOID
SrvCloseConnectionsFromClient(
    IN PCONNECTION Connection,
    IN BOOLEAN OnlyIfNoSessions
    );

VOID
SrvCloseFreeConnection (
    IN PCONNECTION Connection
    );

VOID
SrvDereferenceConnection (
    IN PCONNECTION Connection
    );

VOID
SrvFreeConnection (
    IN PCONNECTION Connection
    );

#if DBG
NTSTATUS
SrvQueryConnections (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesWritten
    );
#endif

//
// Endpoint routines
//

VOID
SrvAllocateEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceEndpoint (
    IN PENDPOINT Endpoint
    );

VOID
SrvCloseEndpoint (
    IN PENDPOINT Endpoint
    );

VOID SRVFASTCALL
SrvDereferenceEndpoint (
    IN PENDPOINT Endpoint
    );

VOID
SrvFreeEndpoint (
    IN PENDPOINT Endpoint
    );

VOID
SrvReferenceEndpoint (
    IN PENDPOINT Endpoint
    );

BOOLEAN
SrvFindNamedEndpoint (
    IN PUNICODE_STRING ServerName,
    IN PBOOLEAN RemapPipeNames OPTIONAL
    );

VOID
EmptyFreeConnectionList (
    IN PENDPOINT Endpoint
    );

PCONNECTION
WalkConnectionTable (
    IN PENDPOINT Endpoint,
    IN PUSHORT Index
    );

//
// Local File Control Block routines
//

VOID
SrvAllocateLfcb (
    OUT PLFCB *Lfcb,
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvCloseLfcb (
    IN PLFCB Lfcb
    );

VOID
SrvDereferenceLfcb (
    IN PLFCB Lfcb
    );

VOID
SrvFreeLfcb (
    IN PLFCB Lfcb,
    IN PWORK_QUEUE queue
    );

VOID
SrvReferenceLfcb (
    IN PLFCB Lfcb
    );

//
// Master File Control Block routines
//


PMFCB
SrvCreateMfcb(
    IN PUNICODE_STRING FileName,
    IN PWORK_CONTEXT WorkContext,
    IN ULONG HashValue
    );

PMFCB
SrvFindMfcb(
    IN PUNICODE_STRING FileName,
    IN BOOLEAN CaseInsensitive,
    OUT PSRV_LOCK *Lock,
    OUT PULONG HashValue,
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvDereferenceMfcb (
    IN PMFCB Mfcb
    );

VOID
SrvFreeMfcb (
    IN PMFCB Mfcb
    );

VOID
SrvUnlinkLfcbFromMfcb (
    IN PLFCB Lfcb
    );

//
// Remote File Control Block routines
//

VOID SRVFASTCALL
SrvAllocateRfcb (
    OUT PRFCB *Rfcb,
    IN PWORK_CONTEXT WorkContext
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceRfcb (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvCloseRfcb (
    IN PRFCB Rfcb
    );

VOID
SrvCloseRfcbsOnLfcb (
    PLFCB Lfcb
    );

VOID
SrvCloseRfcbsOnSessionOrPid (
    IN PSESSION Session,
    IN PUSHORT Pid OPTIONAL
    );

VOID
SrvCloseRfcbsOnTree (
    PTREE_CONNECT TreeConnect
    );

VOID
SrvCompleteRfcbClose (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvDereferenceRfcb (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvFreeRfcb (
    IN PRFCB Rfcb,
    IN PWORK_QUEUE queue
    );

VOID SRVFASTCALL
SrvReferenceRfcb (
    IN PRFCB Rfcb
    );

BOOLEAN
SrvFindCachedRfcb (
    IN PWORK_CONTEXT WorkContext,
    IN PMFCB Mfcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPLOCK_TYPE RequestedOplockType,
    OUT PNTSTATUS Status
    );

VOID
SrvCloseCachedRfcb (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

VOID
SrvCloseCachedRfcbsOnConnection (
    IN PCONNECTION Connection
    );

VOID
SrvCloseCachedRfcbsOnLfcb (
    IN PLFCB Lfcb
    );

ULONG
SrvCountCachedRfcbsForTid(
    PCONNECTION connection,
    USHORT Tid
);

ULONG
SrvCountCachedRfcbsForUid(
    PCONNECTION connection,
    USHORT Uid
);


//
// Search Block routines
//

typedef
BOOLEAN
(*PSEARCH_FILTER_ROUTINE) (
    IN PSEARCH Search,
    IN PVOID FunctionParameter1,
    IN PVOID FunctionParameter2
    );

VOID
SrvAllocateSearch (
    OUT PSEARCH *Search,
    IN PUNICODE_STRING SearchName,
    IN BOOLEAN IsCoreSearch
    );

VOID
SrvCloseSearch (
    IN PSEARCH Search
    );

VOID
SrvCloseSearches (
    IN PCONNECTION Connection,
    IN PSEARCH_FILTER_ROUTINE SearchFilterRoutine,
    IN PVOID FunctionParameter1,
    IN PVOID FunctionParameter2
    );

VOID
SrvDereferenceSearch (
    IN PSEARCH Search
    );

VOID
SrvFreeSearch (
    IN PSEARCH Search
    );

VOID
SrvReferenceSearch (
    IN PSEARCH Search
    );

BOOLEAN
SrvSearchOnDelete(
    IN PSEARCH Search,
    IN PUNICODE_STRING DirectoryName,
    IN PTREE_CONNECT TreeConnect
    );

BOOLEAN
SrvSearchOnPid(
    IN PSEARCH Search,
    IN USHORT Pid,
    IN PVOID Dummy
    );

BOOLEAN
SrvSearchOnSession(
    IN PSEARCH Search,
    IN PSESSION Session,
    IN PVOID Dummy
    );

BOOLEAN
SrvSearchOnTreeConnect(
    IN PSEARCH Search,
    IN PTREE_CONNECT TreeConnect,
    IN PVOID Dummy
    );

VOID
SrvForceTimeoutSearches(
    IN PCONNECTION Connection
    );

ULONG
SrvTimeoutSearches(
    IN PLARGE_INTEGER SearchCutoffTime OPTIONAL,
    IN PCONNECTION Connection,
    IN BOOLEAN OnlyTimeoutOneBlock
    );

VOID
RemoveDuplicateCoreSearches(
    IN PPAGED_CONNECTION PagedConnection
    );

VOID
SrvAddToSearchHashTable(
    IN PPAGED_CONNECTION PagedConnection,
    IN PSEARCH Search
    );

//
// Cached directory routines
//
BOOLEAN
SrvIsDirectoryCached (
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
    );

VOID
SrvCacheDirectoryName (
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
    );

VOID
SrvRemoveCachedDirectoryName (
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
    );

VOID
SrvCloseCachedDirectoryEntries (
    IN PCONNECTION      Connection
    );

//
// Session routines
//

VOID
SrvAllocateSession (
    OUT PSESSION *Session,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceSession (
    IN PSESSION Session
    );

VOID
SrvCloseSession (
    IN PSESSION Session
    );

VOID
SrvCloseSessionsOnConnection (
    IN PCONNECTION Connection,
    IN PUNICODE_STRING UserName OPTIONAL
    );

VOID SRVFASTCALL
SrvDereferenceSession (
    IN PSESSION Session
    );

VOID
SrvFreeSession (
    IN PSESSION Session
    );

//
// Smb Security Signature Routines
//
BOOLEAN SRVFASTCALL
SrvCheckSmbSecuritySignature(
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvAddSmbSecuritySignature(
    IN OUT PWORK_CONTEXT WorkContext,
    IN PMDL Mdl,
    IN ULONG SendLength
    );

VOID SRVFASTCALL
SrvInitializeSmbSecuritySignature(
    IN OUT PCONNECTION Connection,
    IN PUCHAR SessionKey,
    IN PUCHAR ChallengeResponse,
    IN ULONG ChallengeResponseLength
    );

//
// Share routines
//

VOID
SrvAllocateShare (
    OUT PSHARE *Share,
    IN PUNICODE_STRING ShareName,
    IN PUNICODE_STRING NtPathName,
    IN PUNICODE_STRING DosPathName,
    IN PUNICODE_STRING Remark,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR FileSecurityDescriptor OPTIONAL,
    IN SHARE_TYPE ShareType
    );

VOID
SrvCloseShare (
    IN PSHARE Share
    );

VOID
SrvDereferenceShare (
    IN PSHARE Share
    );

VOID
SrvDereferenceShareForTreeConnect (
    PSHARE Share
    );

VOID
SrvFreeShare (
    IN PSHARE Share
    );

VOID
SrvReferenceShare (
    IN PSHARE Share
    );

NTSTATUS
SrvReferenceShareForTreeConnect (
    PSHARE Share
    );

//
// Table routines
//

VOID
SrvAllocateTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfEntries,
    IN BOOLEAN Nonpaged
    );

#define SrvFreeTable( _table ) {                                    \
        if ( (_table)->Nonpaged ) {                                 \
            DEALLOCATE_NONPAGED_POOL( (_table)->Table );            \
        } else {                                                    \
            FREE_HEAP( (_table)->Table );                           \
        }                                                           \
        DEBUG (_table)->Table = NULL;                               \
        DEBUG (_table)->TableSize = -1;                             \
        DEBUG (_table)->FirstFreeEntry = -1;                        \
        DEBUG (_table)->LastFreeEntry = -1;                         \
    }

BOOLEAN
SrvGrowTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfNewEntries,
    IN ULONG MaxNumberOfEntries,
    OUT NTSTATUS* pStatus
    );

VOID
SrvRemoveEntryTable (
    IN PTABLE_HEADER TableHeader,
    IN USHORT Index
    );

//
// Transaction routines
//

VOID
SrvAllocateTransaction (
    OUT PTRANSACTION *Transaction,
    OUT PVOID *TrailingBytes,
    IN PCONNECTION Connection,
    IN CLONG TrailingByteCount,
    IN PVOID TransactionName,
    IN PVOID EndOfSourceBuffer OPTIONAL,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN RemoteApiRequest
    );

VOID
SrvCloseTransaction (
    IN PTRANSACTION Transaction
    );

VOID
SrvCloseTransactionsOnSession (
    PSESSION Session
    );

VOID
SrvCloseTransactionsOnTree (
    PTREE_CONNECT TreeConnect
    );

VOID
SrvDereferenceTransaction (
    IN PTRANSACTION Transaction
    );

VOID
SrvFreeTransaction (
    IN PTRANSACTION Transaction
    );

PTRANSACTION
SrvFindTransaction (
    IN PCONNECTION Connection,
    IN PSMB_HEADER Header,
    IN USHORT Fid OPTIONAL
    );

BOOLEAN
SrvInsertTransaction (
    IN PTRANSACTION Transaction
    );

//
// Tree connect routines
//

VOID
SrvAllocateTreeConnect (
    OUT PTREE_CONNECT *TreeConnect,
    IN PUNICODE_STRING ServerName OPTIONAL
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID
SrvCloseTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID SRVFASTCALL
SrvDereferenceTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID
SrvFreeTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID
SrvDisconnectTreeConnectsFromSession (
    PCONNECTION connection,
    PSESSION Session
    );

VOID
SrvCloseTreeConnectsOnShare (
    IN PSHARE Share
    );

//
// Work item routines (includes work contexts, buffers, MDLs, IRPs, etc)
//

NTSTATUS
SrvAllocateInitialWorkItems (
    VOID
    );

NTSTATUS
SrvAllocateNormalWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    IN  PWORK_QUEUE queue
    );

VOID
SrvAllocateRawModeWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    IN PWORK_QUEUE queue
);

PWORK_CONTEXT
SrvGetRawModeWorkItem (
    VOID
    );

VOID
SrvRequeueRawModeWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvFsdDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvAllocateExtraSmbBuffer (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvAllocateWaitForOplockBreak (
    OUT PWAIT_FOR_OPLOCK_BREAK *WaitForOplockBreak
    );

VOID
SrvDereferenceWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

VOID
SrvFreeWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

VOID
SrvOplockWaitTimeout(
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

NTSTATUS
SrvCheckOplockWaitState(
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

NTSTATUS
SrvWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE FileHandle
    );

NTSTATUS
SrvStartWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN PRESTART_ROUTINE RestartRoutine,
    IN HANDLE Handle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

VOID
SrvSendDelayedOplockBreak (
    IN PCONNECTION Connection
    );

VOID
SrvFreeInitialWorkItems (
    VOID
    );

VOID
SrvFreeNormalWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvFreeRawModeWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

//
//  Byte range lock routines
//

#ifdef INCLUDE_SMB_PERSISTENT
VOID
SrvAllocateLock (
    OUT PBYTELOCK *Lock,
    IN PRFCB Rfcb,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN BOOLEAN Exclusive
    );

PBYTELOCK
SrvFindAndReferenceLock (
    IN PRFCB Rfcb,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN BOOLEAN Exclusive
    );

VOID
SrvCloseLock (
    IN PBYTELOCK Lock,
    IN BOOLEAN HaveMfcbLock
    );

VOID
SrvCloseLocksOnRfcb (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvDereferenceLock (
    IN PBYTELOCK Lock
    );
#endif

//
// Timer routines
//

PSRV_TIMER
SrvAllocateTimer (
    VOID
    );

VOID
SrvCancelTimer (
    IN PSRV_TIMER Timer
    );

#define SrvDeleteTimer(_timer) DEALLOCATE_NONPAGED_POOL(_timer)

#define SrvFreeTimer(_timer) \
        ExInterlockedPushEntrySList(&SrvTimerList, &(_timer)->Next, &GLOBAL_SPIN_LOCK(Timer))

VOID
SrvSetTimer (
    IN PSRV_TIMER Timer,
    IN PLARGE_INTEGER Timeout,
    IN PKDEFERRED_ROUTINE TimeoutHandler,
    IN PVOID Context
    );

#if SRVDBG2

VOID
SrvInitializeReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN LONG InitialReferenceCount
    );

VOID
SrvUpdateReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN PVOID Caller,
    IN PVOID CallersCaller,
    IN BOOLEAN IsDereference
    );

VOID
SrvTerminateReferenceHistory (
    IN PBLOCK_HEADER Block
    );


#define INITIALIZE_REFERENCE_HISTORY(block)                        \
            SrvInitializeReferenceHistory(                         \
                &(block)->BlockHeader,                             \
                ((PBLOCK_HEADER)(block))->ReferenceCount           \
                )

#define UPDATE_REFERENCE_HISTORY(block,isdereference)              \
        {                                                          \
            PVOID caller, callerscaller;                           \
            RtlGetCallersAddress( &caller, &callerscaller );       \
            SrvUpdateReferenceHistory(                             \
                &(block)->BlockHeader,                             \
                caller,                                            \
                callerscaller,                                     \
                isdereference                                      \
                );                                                 \
        }

#define TERMINATE_REFERENCE_HISTORY(block) \
            SrvTerminateReferenceHistory( &(block)->BlockHeader )

#else

#define INITIALIZE_REFERENCE_HISTORY(block)
#define UPDATE_REFERENCE_HISTORY(block,isdereference)
#define TERMINATE_REFERENCE_HISTORY(block)

#endif // if SRVDBG2

#endif // ndef _SRVBLOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbtree.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbtree.c

Abstract:

    This module contains routines for dealing with tree connects and
    disconnects:

        Tree Connect
        Tree Connect And X
        Tree Disconnect

Author:

    David Treadwell (davidtr)    15-Nov-1989

Revision History:


--*/

#include "precomp.h"
#include "smbtree.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbTreeConnect )
#pragma alloc_text( PAGE, SrvSmbTreeConnectAndX )
#pragma alloc_text( PAGE, SrvSmbTreeDisconnect )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnect (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a tree connect SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_TREE_CONNECT request;
    PRESP_TREE_CONNECT response;

    PSESSION session;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_HEADER tableHeader;
    PTABLE_ENTRY entry;
    SHORT tidIndex;
    PSHARE share;
    PTREE_CONNECT treeConnect;
    PSZ password, service;
    USHORT len;
    NTSTATUS   status    = STATUS_SUCCESS;
    NTSTATUS   TableStatus;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    BOOLEAN didLogon = FALSE;
    SHORT uidIndex;
    SMB_DIALECT smbDialect;
    PUNICODE_STRING clientMachineNameString;
    ACCESS_MASK desiredAccess;
    ACCESS_MASK grantedAccess;
    SECURITY_SUBJECT_CONTEXT subjectContext;
    UNICODE_STRING domain = { 0, 0, StrNull };

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_TREE_CONNECT;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Tree connect request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader ));
        KdPrint(( "Tree connect request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_TREE_CONNECT)(WorkContext->RequestParameters);
    response = (PRESP_TREE_CONNECT)(WorkContext->ResponseParameters);

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;
    smbDialect = connection->SmbDialect;

    //
    // If this client has not yet done a session setup and this his first
    // tree connection then we must first do a logon.  (i.e. SessionSetup)
    //

    len = SrvGetStringLength(
                             (PSZ)request->Buffer,
                             END_OF_REQUEST_SMB( WorkContext ),
                             FALSE,             // not unicode
                             FALSE              // do not include null terminator
                             );
    if( len == (USHORT)-1 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    password = (PSZ)request->Buffer + 2 + len;

    len = SrvGetStringLength(
                             password,
                             END_OF_REQUEST_SMB( WorkContext ),
                             FALSE,             // not unicode
                             FALSE              // do not include null terminator
                             );

    if( len == (USHORT)-1 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    service = password + (len + 1) + 1;

    //
    // Allocate a tree connect block.  We do this early on the
    // assumption that the request will usually succeed.  This also
    // reduces the amount of time that we hold the lock.
    //

    SrvAllocateTreeConnect( &treeConnect, NULL );

    if ( treeConnect == NULL ) {

        //
        // Unable to allocate tree connect.  Return an error to the
        // client.
        //

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ASSERT( SrvSessionList.Lock == &SrvOrderedListLock );

    ACQUIRE_LOCK( &connection->Lock );

    if ( pagedConnection->CurrentNumberOfSessions != 0 ) {

        RELEASE_LOCK( &connection->Lock );

        session = SrvVerifyUid (
                      WorkContext,
                      SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                      );

        if ( session == NULL ) {

            //
            // This should only happen if the client has already
            // established a session, as in tree connecting with a bad
            // UID.
            //

            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
            status    = STATUS_SMB_BAD_UID;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
        else if( session->IsSessionExpired )
        {
            SrvFreeTreeConnect( treeConnect );

            status = SESSION_EXPIRED_STATUS_CODE;
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

    } else if ( (smbDialect <= SmbDialectLanMan10) ||
                (smbDialect == SmbDialectIllegal) ) {

        //
        // An LM 1.0 or newer client has tried to do a tree connect
        // without first doing session setup.  We call this a protocol
        // violation.
        //
        // Also catch clients that are trying to connect without
        // negotiating a valid protocol.
        //

        RELEASE_LOCK( &connection->Lock );

        IF_DEBUG(SMB_ERRORS) {

            if ( smbDialect == SmbDialectIllegal ) {

                KdPrint(("SrvSmbTreeConnect: Client %z is using an illegal "
                    "dialect.\n", (PCSTRING)&connection->OemClientMachineNameString ));;

            } else {

                KdPrint(( "Client speaking dialect %ld sent tree connect without session setup.\n", connection->SmbDialect ));
            }
        }

        SrvFreeTreeConnect( treeConnect );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    } else {

        UNICODE_STRING machineName;
        PENDPOINT endpoint;
        BOOLEAN seqNumbers;

        RELEASE_LOCK( &connection->Lock );

        //
        // Convert the client name to unicode
        //

        clientMachineNameString = &pagedConnection->ClientMachineNameString;
        if ( clientMachineNameString->Length == 0 ) {

            UNICODE_STRING clientMachineName;
            clientMachineName.Buffer = pagedConnection->ClientMachineName;
            clientMachineName.MaximumLength =
                            (USHORT)(COMPUTER_NAME_LENGTH+1)*sizeof(WCHAR);

            (VOID)RtlOemStringToUnicodeString(
                            &clientMachineName,
                            &connection->OemClientMachineNameString,
                            FALSE
                            );

            //
            // Add the double backslashes to the length
            //

            clientMachineNameString->Length =
                            (USHORT)(clientMachineName.Length + 2*sizeof(WCHAR));

        }

        //
        // Form a string describing the computer name without the
        // leading backslashes.
        //

        machineName.Buffer = clientMachineNameString->Buffer + 2;
        machineName.Length = clientMachineNameString->Length - 2 * sizeof(WCHAR);
        machineName.MaximumLength =
            clientMachineNameString->MaximumLength - 2 * sizeof(WCHAR);

        //
        // Allocate a session block.
        //

        SrvAllocateSession(
            &session,
            &machineName,
            &domain );

        if ( session == NULL ) {

            //
            // Unable to allocate a Session block.  Return an error
            // status.
            //

            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Assume that down-level clients that are getting logged on
        // here will always use canonicalized (uppercase) paths.  This
        // will result in case insensitivity for all operations.
        //

        session->UsingUppercasePaths = TRUE;

        //
        // The only way for a client to tell us the buffer size or the
        // max count of pending requests he wants to use is the Session
        // Setup SMB.  If he didn't send one, then we get to
        // unilaterally determine the buffer size and multiplex count
        // used by both of us.
        //

        endpoint = connection->Endpoint;
        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;

            //
            // Our session max buffer size is the smaller of the
            // server receive buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            session->MaxBufferSize =
                        (USHORT) GetIpxMaxBufferSize(
                                                endpoint,
                                                adapterNumber,
                                                SrvReceiveBufferLength
                                                );

        } else {

            session->MaxBufferSize = (USHORT)SrvReceiveBufferLength;
        }

        session->MaxMpxCount = SrvMaxMpxCount;

        if ( session->MaxMpxCount < 2 ) {
            connection->OplocksAlwaysDisabled = TRUE;
        }


        if( SrvSmbSecuritySignaturesRequired == TRUE &&
            WorkContext->Connection->Endpoint->IsConnectionless == FALSE ) {

            seqNumbers = TRUE;

        } else {
            seqNumbers = FALSE;

        }

        //
        // Try to find legitimate name/password combination.
        //

        status = SrvValidateUser(
                    &session->UserHandle,
                    session,
                    connection,
                    &machineName,
                    password,
                    strlen( password ) + 1,
                    NULL,                        // CaseSensitivePassword
                    0,                           // CaseSensitivePasswordLength
                    seqNumbers,
                    NULL                         // action
                    );

        //
        // If a bad name/password combination was sent, return an error.
        //

        if ( !NT_SUCCESS(status) ) {

            SrvFreeSession( session );
            SrvFreeTreeConnect ( treeConnect );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnect: Bad user/password combination.\n" ));
            }

            SrvStatistics.LogonErrors++;

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        IF_SMB_DEBUG(ADMIN1) {
            KdPrint(( "Validated user: %ws\n",
                connection->PagedConnection->ClientMachineName ));
        }

        //
        // Making a new session visible is a multiple-step operation.  It
        // must be inserted in the global ordered tree connect list and the
        // containing connection's session table, and the connection must be
        // referenced.  We need to make these operations appear atomic, so
        // that the session cannot be accessed elsewhere before we're done
        // setting it up.  In order to do this, we hold all necessary locks
        // the entire time we're doing the operations.  The first operation
        // is protected by the global ordered list lock
        // (SrvOrderedListLock), while the other operations are protected by
        // the per-connection lock.  We take out the ordered list lock
        // first, then the connection lock.  This ordering is required by
        // lock levels (see lock.h).
        //
        //
        // Ready to try to find a UID for the session.  Check to see if
        // the connection is being closed, and if so, terminate this
        // operation.
        //

        ASSERT( SrvSessionList.Lock == &SrvOrderedListLock );

        ACQUIRE_LOCK( SrvSessionList.Lock );
        ACQUIRE_LOCK( &connection->Lock );

        if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

            RELEASE_LOCK( &connection->Lock );
            RELEASE_LOCK( SrvSessionList.Lock );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnect: Connection closing\n" ));
            }

            SrvFreeSession( session );
            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            status    = STATUS_INVALID_PARAMETER;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Because the client is speaking the "core" dialect, it will
        // not send a valid UID in future SMBs, so it can only have one
        // session.  We define that session to live in UID slot 0.  We
        // know that the client has no sessions yet, so slot 0 must be
        // free.
        //

        tableHeader = &pagedConnection->SessionTable;
        ASSERT( tableHeader->Table[0].Owner == NULL );

        uidIndex = 0;

        //
        // Remove the UID slot from the free list and set its owner and
        // sequence number.  Create a UID for the session.  Increment
        // count of sessions.
        //

        entry = &tableHeader->Table[uidIndex];

        tableHeader->FirstFreeEntry = entry->NextFreeEntry;
        DEBUG entry->NextFreeEntry = -2;
        if ( tableHeader->LastFreeEntry == uidIndex ) {
            tableHeader->LastFreeEntry = -1;
        }

        entry->Owner = session;

        INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        if ( uidIndex == 0 && entry->SequenceNumber == 0 ) {
            INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        }
        session->Uid = MAKE_UID( uidIndex, entry->SequenceNumber );

        pagedConnection->CurrentNumberOfSessions++;

        IF_SMB_DEBUG(ADMIN1) {
            KdPrint(( "Found UID.  Index = 0x%lx, sequence = 0x%lx\n",
                        (ULONG)UID_INDEX( session->Uid ),
                        (ULONG)UID_SEQUENCE( session->Uid ) ));
        }

        //
        // Insert the session on the global session list.
        //

        SrvInsertEntryOrderedList( &SrvSessionList, session );

        //
        // Reference the connection block to account for the new
        // session.
        //

        SrvReferenceConnection( connection );
        session->Connection = connection;

        RELEASE_LOCK( &connection->Lock );
        RELEASE_LOCK( SrvSessionList.Lock );

        //
        // Session successfully created.  Remember its address in the
        // work context block.
        //
        // *** Note that the reference count on the session block is
        //     initially set to 2, to allow for the active status on the
        //     block and the pointer that we're maintaining.  In other
        //     words, this is a referenced pointer, and the pointer must
        //     be dereferenced when processing of this SMB is complete.
        //

        WorkContext->Session = session;

        didLogon = TRUE;

    }

    //
    // Try to match pathname against available shared resources.  Note
    // that if SrvVerifyShare finds a matching share, it references it
    // and stores its address in WorkContext->Share.
    //

    share = SrvVerifyShare(
                WorkContext,
                (PSZ)request->Buffer + 1,
                service,
                SMB_IS_UNICODE( WorkContext ),
                session->IsNullSession,
                &status,
                NULL
                );

    //
    // If no match was found, return an error.
    //

    if ( share == NULL ) {

        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: SrvVerifyShare failed for %s. Status = %x\n", request->Buffer+1, status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Impersonate the user so that we can capture his security context.
    // This is necessary in order to determine whether the user can
    // connect to the share.
    //

    status = IMPERSONATE( WorkContext );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    SeCaptureSubjectContext( &subjectContext );

    //
    // Set up the desired access on the share, based on whether the
    // server is paused.  If the server is paused, admin privilege is
    // required to connect to any share; if the server is not paused,
    // admin privilege is required only for admin shares (C$, etc.).
    //

    if ( SrvPaused ) {
        desiredAccess = SRVSVC_PAUSED_SHARE_CONNECT;
    } else {
        desiredAccess = SRVSVC_SHARE_CONNECT;
    }

    //
    // Check whether the user has access to this share.
    //

    if ( !SeAccessCheck(
              share->SecurityDescriptor,
              &subjectContext,
              FALSE,
              desiredAccess,
              0L,
              NULL,
              &SrvShareConnectMapping,
              UserMode,
              &grantedAccess,
              &status
              ) ) {

        IF_SMB_DEBUG(TREE2) {
            KdPrint(( "SrvSmbTreeConnect: SeAccessCheck failed: %X\n",
                           status ));
        }

        //
        // Release the subject context and revert to the server's security
        // context.
        //

        SeReleaseSubjectContext( &subjectContext );

        REVERT( );

        if ( SrvPaused ) {
            SrvSetSmbError( WorkContext, STATUS_SHARING_PAUSED );
            status = STATUS_SHARING_PAUSED;
        } else {
            SrvSetSmbError( WorkContext, status );
        }

        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ASSERT( grantedAccess == desiredAccess );

    //
    // Release the subject context and revert to the server's security
    // context.
    //

    SeReleaseSubjectContext( &subjectContext );

    REVERT( );


    //
    // Let the license server know
    //
    if( share->ShareType != ShareTypePipe ) {

        status = SrvXsLSOperation( session, XACTSRV_MESSAGE_LSREQUEST );

        if( !NT_SUCCESS( status ) ) {
            if ( didLogon ) {
                SrvCloseSession( session );
            }
            SrvFreeTreeConnect( treeConnect );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnect: License server returned %X\n",
                               status ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // Making a new tree connect visible is a three-step operation.  It
    // must be inserted in the containing share's tree connect list, the
    // global ordered tree connect list, and the containing connection's
    // tree connect table.  We need to make these operations appear
    // atomic, so that the tree connect cannot be accessed elsewhere
    // before we're done setting it up.  In order to do this, we hold
    // all necessary locks the entire time we're doing the three
    // operations.  The first and second operations are protected by the
    // global share lock (SrvShareLock), while the third operation is
    // protected by the per-connection lock.  We take out the share lock
    // first, then the connection lock.  This ordering is required by
    // lock levels (see lock.h).
    //
    // Another problem here is that the checking of the share state, the
    // inserting of the tree connect on the share's list, and the
    // referencing of the share all need to be atomic.  (The same holds
    // for the connection actions.)  Normally this would not be a
    // problem, because we could just hold the share lock while doing
    // all three actions.  However, in this case we also need to hold
    // the connection lock, and we can't call SrvReferenceShare while
    // doing that.  To get around this problem, we reference the share
    // _before_ taking out the locks, and dereference after releasing
    // the locks if we decide not to insert the tree connect.
    //

    status = SrvReferenceShareForTreeConnect( share );

    //
    // SrvReferenceShareForTreeConnect will fail if it cannot open the
    // share root directory for some reason.  If this happens,
    // fail the tree connect attempt.
    //

    if ( !NT_SUCCESS(status) ) {

        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: open of share root failed:%X\n",
                           status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ACQUIRE_LOCK( &SrvShareLock );
    ASSERT( SrvTreeConnectList.Lock == &SrvShareLock );
    ACQUIRE_LOCK( &connection->Lock );

    //
    // We first check all conditions to make sure that we can actually
    // insert this tree connect block.
    //
    // Make sure that the share isn't closing, and that there aren't
    // already too many uses on this share.
    //

    if ( GET_BLOCK_STATE(share) != BlockStateActive ) {

        //
        // The share is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: Share %wZ (0x%p) is closing\n",
                        &share->ShareName, share ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    if ( share->CurrentUses > share->MaxUses ) {

        //
        // The share is full.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: No more uses available for share %wZ (0x%p), max = %ld\n",
                        &share->ShareName, share, share->MaxUses ));
        }

        status = STATUS_REQUEST_NOT_ACCEPTED;
        goto cant_insert;

    }

    //
    // Make sure that the connection isn't closing.
    //

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: Connection closing\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Find a TID that can be used for this tree connect.
    //

    tableHeader = &pagedConnection->TreeConnectTable;
    if ( tableHeader->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             tableHeader,
             SrvInitialTreeTableSize,
             SrvMaxTreeTableSize,
             &TableStatus ) == FALSE
       ) {

        //
        // No free entries in the tree table.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: No more TIDs available.\n" ));
        }

        status = TableStatus;

        if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
        {
            SrvLogTableFullError( SRV_TABLE_TREE_CONNECT );
        }
        goto cant_insert;

    }

    tidIndex = tableHeader->FirstFreeEntry;

    //
    // All conditions have been satisfied.  We can now do the things
    // necessary to make the tree connect visible.
    //
    // Increment the count of uses for the share.  Link the tree connect
    // into the list of active tree connects for the share.  Save the
    // share address in the tree connect.  Note that we referenced the
    // share earlier, before taking out the connection lock.
    //

    SrvInsertTailList(
        &share->TreeConnectList,
        &treeConnect->ShareListEntry
        );

    treeConnect->Share = share;

    //
    // Remove the TID slot from the free list and set its owner and
    // sequence number.  Create a TID for the tree connect.
    //

    entry = &tableHeader->Table[tidIndex];

    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == tidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    entry->Owner = treeConnect;

    INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    if ( tidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    }
    treeConnect->Tid = MAKE_TID( tidIndex, entry->SequenceNumber );

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Found TID.  Index = 0x%lx, sequence = 0x%lx\n",
                    TID_INDEX( treeConnect->Tid ),
                    TID_SEQUENCE( treeConnect->Tid ) ));
    }

    //
    // Reference the connection to account for the active tree connect.
    //

    SrvReferenceConnection( connection );
    treeConnect->Connection = connection;

    if( session )
    {
        SrvReferenceSession( session );
        treeConnect->Session = session;
    }

    //
    // Link the tree connect into the global list of tree connects.
    //

    SrvInsertEntryOrderedList( &SrvTreeConnectList, treeConnect );

    //
    // Release the locks used to make this operation appear atomic.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    //
    // Get the qos information for this connection
    //

    SrvUpdateVcQualityOfService ( connection, NULL );

    //
    // Tree connect successfully created.  Because the tree connect was
    // created with an initial reference count of 2, dereference it now.
    //
    // *** Don't bother to save the tree connect address in the work
    //     context block, because we're going to forget our pointers
    //     soon anyway (we're done with the request).  TreeConnectAndX
    //     has to remember these things, though.
    //

    SrvDereferenceTreeConnect( treeConnect );

    //
    // Set up response SMB.
    //

    SmbPutAlignedUshort( &WorkContext->ResponseHeader->Tid, treeConnect->Tid );

    response->WordCount = 2;
    SmbPutUshort( &response->MaxBufferSize, (USHORT)session->MaxBufferSize );
    SmbPutUshort( &response->Tid, treeConnect->Tid  );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_TREE_CONNECT,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbTreeConnect complete.\n" ));
    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

cant_insert:

    //
    // We get here if for some reason we decide that we can't insert
    // the tree connect.  On entry, status contains the reason code.
    // The connection lock and the share lock are held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    if ( didLogon ) {
        SrvCloseSession( session );
    }

    SrvDereferenceShareForTreeConnect( share );

    SrvFreeTreeConnect( treeConnect );

    SrvSetSmbError( WorkContext, status );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbTreeConnect


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnectAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a tree connect and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_TREE_CONNECT_ANDX request;
    PRESP_TREE_CONNECT_ANDX response;
    PRESP_EXTENDED_TREE_CONNECT_ANDX responseExtended;
    PRESP_21_TREE_CONNECT_ANDX response21;

    NTSTATUS   status    = STATUS_SUCCESS;
    NTSTATUS   TableStatus;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_HEADER tableHeader;
    PTABLE_ENTRY entry;
    SHORT tidIndex;
    PSHARE share;
    PTREE_CONNECT treeConnect;
    PVOID shareName;
    PUCHAR shareType;
    USHORT shareNameLength;
    USHORT reqAndXOffset;
    UCHAR nextCommand;
    PSZ shareString;
    USHORT shareStringLength;
    USHORT RequestFlags;
    USHORT byteCount;
    PUCHAR smbBuffer;
    PSESSION session;
    SECURITY_SUBJECT_CONTEXT subjectContext;
    ACCESS_MASK desiredAccess;
    ACCESS_MASK grantedAccess;
    BOOLEAN isUnicode;
    UNICODE_STRING serverName;
    BOOLEAN remapPipeNames = FALSE;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_TREE_CONNECT_AND_X;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Tree connect and X request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader ));
        KdPrint(( "Tree connect and X request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_TREE_CONNECT_ANDX)(WorkContext->RequestParameters);
    response = (PRESP_TREE_CONNECT_ANDX)(WorkContext->ResponseParameters);
    responseExtended = (PRESP_EXTENDED_TREE_CONNECT_ANDX)(WorkContext->ResponseParameters);
    response21 = (PRESP_21_TREE_CONNECT_ANDX)(WorkContext->ResponseParameters);

    //
    // If bit 0 of Flags is set, disconnect tree in header TID.  We must
    // get the appropriate tree connect pointer.  SrvVerifyTid does this
    // for us, referencing the tree connect and storing the pointer in
    // the work context block.  We have to dereference the block and
    // erase the pointer after calling SrvCloseTreeConnect.
    //

    if ( (SmbGetUshort( &request->Flags ) & 1) != 0 ) {

        if ( SrvVerifyTid(
                WorkContext,
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )
                ) == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnectAndX: Invalid TID to disconnect: 0x%lx\n",
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ) ));
            }

            //
            // Just ignore an invalid TID--this is what the LM 2.0
            // server does.
            //

        } else {

            SrvCloseTreeConnect( WorkContext->TreeConnect );

            SrvDereferenceTreeConnect( WorkContext->TreeConnect );
            WorkContext->TreeConnect = NULL;

        }

    }

    //
    // Validate the UID in the header and get a session pointer.  We need
    // the user's token to check whether they can access this share.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    //
    // If we couldn't find a valid session fail the tree connect.
    //

    if ( session == NULL ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: rejecting tree connect for "
                       "session %p due to server paused.\n", session ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    else if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Try to match pathname against available shared resources.  Note
    // that if SrvVerifyShare finds a matching share, it references it
    // and stores its address in WorkContext->Share.
    //

    shareName = (PSZ)request->Buffer +
                    SmbGetUshort( &request->PasswordLength );

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    isUnicode = SMB_IS_UNICODE( WorkContext );

    if ( isUnicode ) {
        shareName = ALIGN_SMB_WSTR( shareName );
    }

    shareNameLength = SrvGetStringLength(
                                    shareName,
                                    END_OF_REQUEST_SMB( WorkContext ),
                                    SMB_IS_UNICODE( WorkContext ),
                                    TRUE        // include null terminator
                                    );

    //
    // if share name is bogus, return an error.
    //

    if ( shareNameLength == (USHORT)-1 ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: pathname is bogus.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_BAD_NETWORK_NAME );
        status    = STATUS_BAD_NETWORK_NAME;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    shareType = (PCHAR)shareName + shareNameLength;

    share = SrvVerifyShare(
                WorkContext,
                shareName,
                shareType,
                isUnicode,
                session->IsNullSession,
                &status,
                &serverName
                );

    //
    // If no match was found, return an error.
    //

    if ( share == NULL ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: pathname does not match "
                        "any shares: %s\n", shareName ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the the client is connecting with a netbiosless transport and the name of the
    //  server which the client was requesting doesn't match any of our servernames, then
    //  the client has accidentally connected to the wrong server.  Let the client know.
    //
    if( !SrvDisableStrictNameChecking &&
        serverName.Buffer != NULL &&
        connection->Endpoint->IsNoNetBios &&
        SrvIsDottedQuadAddress( &serverName ) == FALSE &&
        SrvFindNamedEndpoint( &serverName, NULL ) == FALSE ) {

        BOOL bBadName = TRUE;

        // Last check, make sure its not the domain DNS name (which may differ from the NETBIOS DNS name)
        ACQUIRE_LOCK_SHARED( &SrvEndpointLock );

        // We only check up to the first ., so ntdev.microsoft.com would match SrvDnsDomainName "NTDEV"
        // Strip off the excess info for the check, then put it back
        if( SrvDnsDomainName ) {
            if( SrvDnsDomainName->Length <= serverName.Length )
            {
                USHORT oldLength = serverName.Length;
                serverName.Length = SrvDnsDomainName->Length;

                if( RtlEqualUnicodeString( &serverName, SrvDnsDomainName, TRUE ) )
                {
                    bBadName = FALSE;
                }

                serverName.Length = oldLength;
            }
        }

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // The client has connected to this server in error--turn the client back!
        //
        if( bBadName )
        {
            SrvSetSmbError( WorkContext,  STATUS_DUPLICATE_NAME );
            status    = STATUS_DUPLICATE_NAME;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // Impersonate the user so that we can capture his security context.
    // This is necessary in order to determine whether the user can
    // connect to the share.
    //

    status = IMPERSONATE( WorkContext );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    SeCaptureSubjectContext( &subjectContext );

    //
    // Set up the desired access on the share, based on whether the
    // server is paused.  If the server is paused, admin privilege is
    // required to connect to any share; if the server is not paused,
    // admin privilege is required only for admin shares (C$, etc.).
    //

    if ( SrvPaused ) {
        desiredAccess = SRVSVC_PAUSED_SHARE_CONNECT;
    } else {
        desiredAccess = SRVSVC_SHARE_CONNECT;
    }

    //
    // Check whether the user has access to this share.
    //

    if ( !SeAccessCheck(
              share->SecurityDescriptor,
              &subjectContext,
              FALSE,
              desiredAccess,
              0L,
              NULL,
              &SrvShareConnectMapping,
              UserMode,
              &grantedAccess,
              &status
              ) ) {

        IF_SMB_DEBUG(TREE2) {
            KdPrint(( "SrvSmbTreeConnectAndX: SeAccessCheck failed: %X\n",
                           status ));
        }

        //
        // Release the subject context and revert to the server's security
        // context.
        //

        SeReleaseSubjectContext( &subjectContext );

        REVERT( );

        if ( SrvPaused ) {
            SrvSetSmbError( WorkContext, STATUS_SHARING_PAUSED );
            status = STATUS_SHARING_PAUSED;
        } else {
            SrvSetSmbError( WorkContext, status );
        }

        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ASSERT( grantedAccess == desiredAccess );

    //
    // Release the subject context and revert to the server's security
    // context.
    //

    SeReleaseSubjectContext( &subjectContext );

    REVERT( );

    //
    // See if the license server wants to let this person in on the NTAS
    //
    if( share->ShareType != ShareTypePipe ) {

        status = SrvXsLSOperation( session, XACTSRV_MESSAGE_LSREQUEST );

        if( !NT_SUCCESS( status ) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnectAndX: License server returned %X\n",
                               status ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

    } else if( serverName.Buffer != NULL ) {

        //
        // This is the IPC$ share.  See if we're supposed to remap pipe names
        //
        SrvFindNamedEndpoint( &serverName, &remapPipeNames );

    }

    //
    // Allocate a tree connect block.
    //

    SrvAllocateTreeConnect( &treeConnect, serverName.Buffer ? &serverName : NULL );

    if ( treeConnect == NULL ) {

        //
        // Unable to allocate tree connect.  Return an error to the
        // client.
        //

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    treeConnect->RemapPipeNames = remapPipeNames;

    //
    // Making a new tree connect visible is a three-step operation.  It
    // must be inserted in the containing share's tree connect list, the
    // global ordered tree connect list, and the containing connection's
    // tree connect table.  We need to make these operations appear
    // atomic, so that the tree connect cannot be accessed elsewhere
    // before we're done setting it up.  In order to do this, we hold
    // all necessary locks the entire time we're doing the three
    // operations.  The first and second operations are protected by the
    // global share lock (SrvShareLock), while the third operation is
    // protected by the per-connection lock.  We take out the share lock
    // first, then the connection lock.  This ordering is required by
    // lock levels (see lock.h).
    //
    // Another problem here is that the checking of the share state, the
    // inserting of the tree connect on the share's list, and the
    // referencing of the share all need to be atomic.  (The same holds
    // for the connection actions.)  Normally this would not be a
    // problem, because we could just hold the share lock while doing
    // all three actions.  However, in this case we also need to hold
    // the connection lock, and we can't call SrvReferenceShare while
    // doing that.  To get around this problem, we reference the share
    // _before_ taking out the locks, and dereference after releasing
    // the locks if we decide not to insert the tree connect.
    //

    status = SrvReferenceShareForTreeConnect( share );

    //
    // SrvReferenceShareForTreeConnect will fail if it cannot open the
    // share root directory for some reason.  If this happens,
    // fail the tree connect attempt.
    //

    if ( !NT_SUCCESS(status) ) {

        SrvFreeTreeConnect( treeConnect );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: open of share root failed:%X\n",
                           status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ACQUIRE_LOCK( &SrvShareLock );
    ASSERT( SrvTreeConnectList.Lock == &SrvShareLock );
    ACQUIRE_LOCK( &connection->Lock );

    //
    // We first check all conditions to make sure that we can actually
    // insert this tree connect block.
    //
    // Make sure that the share isn't closing, and that there aren't
    // already too many uses on this share.
    //

    if ( GET_BLOCK_STATE(share) != BlockStateActive ) {

        //
        // The share is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: Share %wZ (0x%p) is closing\n",
                        &share->ShareName, share ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    if ( share->CurrentUses > share->MaxUses ) {

        //
        // The share is full.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: No more uses available for share %wZ (0x%p), max = %ld\n",
                        &share->ShareName, share, share->MaxUses ));
        }

        status = STATUS_REQUEST_NOT_ACCEPTED;
        goto cant_insert;

    }

    //
    // Make sure that the connection isn't closing, and that there's
    // room in its tree connect table.
    //

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: Connection closing\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Find a TID that can be used for this tree connect.
    //

    tableHeader = &pagedConnection->TreeConnectTable;
    if ( tableHeader->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             tableHeader,
             SrvInitialTreeTableSize,
             SrvMaxTreeTableSize,
             &TableStatus ) == FALSE
       ) {

        //
        // No free entries in the tree table.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: No more TIDs available.\n" ));
        }

        if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
        {
            SrvLogTableFullError( SRV_TABLE_TREE_CONNECT );
        }

        status = TableStatus;
        goto cant_insert;

    }

    tidIndex = tableHeader->FirstFreeEntry;

    //
    // All conditions have been satisfied.  We can now do the things
    // necessary to make the tree connect visible.
    //
    // Link the tree connect into the list of active tree connects for
    // the share.  Save the share address in the tree connect.  Note
    // that we referenced the share earlier, before taking out the
    // connection lock.
    //

    SrvInsertTailList(
        &share->TreeConnectList,
        &treeConnect->ShareListEntry
        );

    treeConnect->Share = share;

    //
    // Remove the TID slot from the free list and set its owner and
    // sequence number.  Create a TID for the tree connect.
    //

    entry = &tableHeader->Table[tidIndex];

    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == tidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    entry->Owner = treeConnect;

    INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    if ( tidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    }
    treeConnect->Tid = MAKE_TID( tidIndex, entry->SequenceNumber );

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Found TID.  Index = 0x%lx, sequence = 0x%lx\n",
                    TID_INDEX( treeConnect->Tid ),
                    TID_SEQUENCE( treeConnect->Tid ) ));
    }

    //
    // Reference the connection to account for the active tree connect.
    //

    SrvReferenceConnection( connection );
    treeConnect->Connection = connection;
    if( session )
    {
        SrvReferenceSession( session );
        treeConnect->Session = session;
    }

    //
    // Link the tree connect into the global list of tree connects.
    //

    SrvInsertEntryOrderedList( &SrvTreeConnectList, treeConnect );

    //
    // Release the locks used to make this operation appear atomic.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    //
    // Get the qos information for this connection
    //

    SrvUpdateVcQualityOfService ( connection, NULL );

    //
    // Tree connect successfully created.  Save the tree connect block
    // address in the work context block.  Note that the reference count
    // on the new block was incremented on creation to account for our
    // reference to the block.
    //

    WorkContext->TreeConnect = treeConnect;

    //
    // Set up response SMB, making sure to save request fields first in
    // case the response overwrites the request.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );
    nextCommand = request->AndXCommand;

    RequestFlags = SmbGetUshort(&request->Flags);

    SmbPutAlignedUshort( &WorkContext->RequestHeader->Tid, treeConnect->Tid );
    SmbPutAlignedUshort( &WorkContext->ResponseHeader->Tid, treeConnect->Tid );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;

    if ( connection->SmbDialect > SmbDialectDosLanMan21) {
        response->WordCount = 2;
        smbBuffer = (PUCHAR)response->Buffer;
    } else {
        if (RequestFlags & TREE_CONNECT_ANDX_EXTENDED_RESPONSE) {
            responseExtended->WordCount = 7;
            smbBuffer = (PUCHAR)responseExtended->Buffer;
        } else {
            response21->WordCount = 3;
            smbBuffer = (PUCHAR)response21->Buffer;
        }

        // Fields common to 21 and extended response.
        response21->OptionalSupport = SMB_SUPPORT_SEARCH_BITS;

        SrvIsShareInDfs( share, &share->IsDfs, &share->IsDfsRoot );

        if (share->IsDfs) {
            response21->OptionalSupport |= SMB_SHARE_IS_IN_DFS;
        }

        switch( share->CSCState ) {
        case CSC_CACHE_MANUAL_REINT:
            response21->OptionalSupport |= SMB_CSC_CACHE_MANUAL_REINT;
            break;
        case CSC_CACHE_AUTO_REINT:
            response21->OptionalSupport |= SMB_CSC_CACHE_AUTO_REINT;
            break;
        case CSC_CACHE_VDO:
            response21->OptionalSupport |= SMB_CSC_CACHE_VDO;
            break;
        case CSC_CACHE_NONE:
            response21->OptionalSupport |= SMB_CSC_NO_CACHING;
            break;
        }

        if( share->UniqueNames )
        {
            response21->OptionalSupport |= SMB_UNIQUE_FILE_NAME;
        }
    }

    //
    // Append the service name string to the SMB.  The service name
    // is always sent in ANSI.
    //

    shareString = StrShareTypeNames[share->ShareType];
    shareStringLength = (USHORT)( strlen( shareString ) + 1 );
    RtlCopyMemory ( smbBuffer, shareString, shareStringLength );

    byteCount = shareStringLength;
    smbBuffer += shareStringLength;

    if ( connection->SmbDialect <= SmbDialectDosLanMan21 ) {

        //
        // Append the file system name to the response.
        // If the file system name is unavailable, supply the nul string
        // as the name.
        //

        if ( isUnicode ) {

            if ( ((ULONG_PTR)smbBuffer & 1) != 0 ) {
                smbBuffer++;
                byteCount++;
            }

            if ( share->Type.FileSystem.Name.Buffer != NULL ) {

                RtlCopyMemory(
                    smbBuffer,
                    share->Type.FileSystem.Name.Buffer,
                    share->Type.FileSystem.Name.Length
                    );

                byteCount += share->Type.FileSystem.Name.Length;

            } else {

                *(PWCH)smbBuffer = UNICODE_NULL;
                byteCount += sizeof( UNICODE_NULL );

            }

        } else {

            if ( share->Type.FileSystem.Name.Buffer != NULL ) {

                RtlCopyMemory(
                    smbBuffer,
                    share->Type.FileSystem.OemName.Buffer,
                    share->Type.FileSystem.OemName.Length
                    );

                byteCount += share->Type.FileSystem.OemName.Length;

            } else {

                *(PUCHAR)smbBuffer = '\0';
                byteCount += 1;

            }

        }


        if (RequestFlags & TREE_CONNECT_ANDX_EXTENDED_RESPONSE) {
            PRESP_EXTENDED_TREE_CONNECT_ANDX ExtendedResponse;

            ExtendedResponse = (PRESP_EXTENDED_TREE_CONNECT_ANDX)response;

            SmbPutUshort( &ExtendedResponse->ByteCount, byteCount );

            SrvUpdateMaximalShareAccessRightsInResponse(
                WorkContext,
                &ExtendedResponse->MaximalShareAccessRights,
                &ExtendedResponse->GuestMaximalShareAccessRights);

            SmbPutUshort(
                &ExtendedResponse->AndXOffset,
                GET_ANDX_OFFSET(
                    WorkContext->ResponseHeader,
                    WorkContext->ResponseParameters,
                    RESP_EXTENDED_TREE_CONNECT_ANDX,
                    byteCount
                    )
                );
        } else {
            SmbPutUshort( &response21->ByteCount, byteCount );

            SmbPutUshort(
                &response->AndXOffset,
                GET_ANDX_OFFSET(
                    WorkContext->ResponseHeader,
                    WorkContext->ResponseParameters,
                    RESP_21_TREE_CONNECT_ANDX,
                    byteCount
                    )
                );
        }
    } else {  // if Smb dialect == LAN Man 2.1
        SmbPutUshort( &response->ByteCount, byteCount );

        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_TREE_CONNECT_ANDX,
                byteCount
                )
            );
    }


    WorkContext->ResponseParameters = (PUCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_OPEN:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_CREATE:
    case SMB_COM_CREATE_NEW:
    case SMB_COM_CREATE_DIRECTORY:
    case SMB_COM_DELETE:
    case SMB_COM_DELETE_DIRECTORY:
    case SMB_COM_SEARCH:
    case SMB_COM_FIND:
    case SMB_COM_FIND_UNIQUE:
    case SMB_COM_COPY:
    case SMB_COM_RENAME:
    case SMB_COM_NT_RENAME:
    case SMB_COM_CHECK_DIRECTORY:
    case SMB_COM_QUERY_INFORMATION:
    case SMB_COM_SET_INFORMATION:
    case SMB_COM_QUERY_INFORMATION_SRV:
    case SMB_COM_OPEN_PRINT_FILE:
    case SMB_COM_GET_PRINT_QUEUE:
    case SMB_COM_TRANSACTION:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: Illegal followon command: 0x%c\n", nextCommand ));
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        // *** Watch out for overwriting request with response.

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PUCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        SmbStatus = SmbStatusMoreCommands;
        goto Cleanup;
    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbTreeConnectAndX complete.\n" ));
    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

cant_insert:

    //
    // We get here if for some reason we decide that we can't insert
    // the tree connect.  On entry, status contains the reason code.
    // The connection lock and the share lock are held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    SrvDereferenceShareForTreeConnect( share );

    SrvFreeTreeConnect( treeConnect );

    SrvSetSmbError( WorkContext, status );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbTreeConnectAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeDisconnect (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a tree disconnect SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_TREE_DISCONNECT request;
    PRESP_TREE_DISCONNECT response;
    PTREE_CONNECT treeConnect;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_TREE_DISCONNECT;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Tree disconnect request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader ));
        KdPrint(( "Tree disconnect request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_TREE_DISCONNECT)(WorkContext->RequestParameters);
    response = (PRESP_TREE_DISCONNECT)(WorkContext->ResponseParameters);

    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    treeConnect = SrvVerifyTid(
                    WorkContext,
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )
                    );

    if ( treeConnect == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeDisconnect: Invalid TID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Do the actual tree disconnect.
    //

    SrvCloseTreeConnect( WorkContext->TreeConnect );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_TREE_DISCONNECT,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbTreeDisconnect complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbTreeDisconnect
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvdata.h

Abstract:

    This module defines global data for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

#ifndef _SRVDATA_
#define _SRVDATA_

//#include <ntos.h>

//#include "lock.h"
//#include "srvconst.h"
//#include "smbtypes.h"

//
// All global variables referenced in this module are defined in
// srvdata.c.  See that module for complete descriptions.
//
// The variables referenced herein, because they are part of the driver
// image, are not pageable.  However, some of the things pointed to by
// these variables are in the FSP's address space and are pageable.
// These variables are only accessed by the FSP, and only at low IRQL.
// Any data referenced by the FSP at elevated IRQL or by the FSD must
// be nonpageable.
//

//
// Routine to initialize data structures contained herein that cannot
// be statically initialized.
//

VOID
SrvInitializeData (
    VOID
    );

//
// Routine to clean up global server data when the driver is unloaded.
//

VOID
SrvTerminateData (
    VOID
    );

//
// This is an enum structure that enumerates all the routines in the
// SrvSmbDispatchTable.  This is done for convenience only.  Note that
// this will only work if this list corresponds exactly to
// SrvSmbDispatchTable.
//

typedef enum _SRV_SMB_INDEX {
    ISrvSmbIllegalCommand,
    ISrvSmbCreateDirectory,
    ISrvSmbDeleteDirectory,
    ISrvSmbOpen,
    ISrvSmbCreate,
    ISrvSmbClose,
    ISrvSmbFlush,
    ISrvSmbDelete,
    ISrvSmbRename,
    ISrvSmbQueryInformation,
    ISrvSmbSetInformation,
    ISrvSmbRead,
    ISrvSmbWrite,
    ISrvSmbLockByteRange,
    ISrvSmbUnlockByteRange,
    ISrvSmbCreateTemporary,
    ISrvSmbCheckDirectory,
    ISrvSmbProcessExit,
    ISrvSmbSeek,
    ISrvSmbLockAndRead,
    ISrvSmbSetInformation2,
    ISrvSmbQueryInformation2,
    ISrvSmbLockingAndX,
    ISrvSmbTransaction,
    ISrvSmbTransactionSecondary,
    ISrvSmbIoctl,
    ISrvSmbIoctlSecondary,
    ISrvSmbMove,
    ISrvSmbEcho,
    ISrvSmbOpenAndX,
    ISrvSmbReadAndX,
    ISrvSmbWriteAndX,
    ISrvSmbFindClose2,
    ISrvSmbFindNotifyClose,
    ISrvSmbTreeConnect,
    ISrvSmbTreeDisconnect,
    ISrvSmbNegotiate,
    ISrvSmbSessionSetupAndX,
    ISrvSmbLogoffAndX,
    ISrvSmbTreeConnectAndX,
    ISrvSmbQueryInformationDisk,
    ISrvSmbSearch,
    ISrvSmbNtTransaction,
    ISrvSmbNtTransactionSecondary,
    ISrvSmbNtCreateAndX,
    ISrvSmbNtCancel,
    ISrvSmbOpenPrintFile,
    ISrvSmbClosePrintFile,
    ISrvSmbGetPrintQueue,
    ISrvSmbReadRaw,
    ISrvSmbWriteRaw,
    ISrvSmbReadMpx,
    ISrvSmbWriteMpx,
    ISrvSmbWriteMpxSecondary
} SRV_SMB_INDEX;


//
// Address of the server device object.
//

extern PDEVICE_OBJECT SrvDeviceObject;

//
// Fields describing the state of the FSP.
//

extern BOOLEAN SrvFspActive;             // Indicates whether the FSP is running
extern BOOLEAN SrvFspTransitioning;      // Indicates that the server is in the
                                         // process of starting up or
                                         // shutting down

extern PEPROCESS SrvServerProcess;       // Pointer to the initial system process

extern PEPROCESS SrvSvcProcess;          // Pointer to the service controller process

extern BOOLEAN SrvCompletedPNPRegistration; // Indicates whether the FSP has completed
                                            //  registering for PNP notifications

//
// Endpoint variables.  SrvEndpointCount is used to count the number of
// active endpoints.  When the last endpoint is closed, SrvEndpointEvent
// is set so that the thread processing the shutdown request continues
// server termination.
//

extern CLONG SrvEndpointCount;          // Number of transport endpoints
extern KEVENT SrvEndpointEvent;         // Signaled when no active endpoints

//
// DMA alignment size
//
extern ULONG SrvCacheLineSize;

//
// Global spin locks.
//

extern SRV_GLOBAL_SPIN_LOCKS SrvGlobalSpinLocks;

#if SRVDBG || SRVDBG_HANDLES
//
// Lock used to protect debugging structures.
//

extern SRV_LOCK SrvDebugLock;
#endif

//
// SrvConfigurationLock is used to synchronize configuration requests.
//

extern SRV_LOCK SrvConfigurationLock;

//
// SrvStartupShutdownLock is used to synchronize driver starting and stopping
//

extern SRV_LOCK SrvStartupShutdownLock;

//
// SrvEndpointLock serializes access to the global endpoint list and
// all endpoints.  Note that the list of connections in each endpoint
// is also protected by this lock.
//

extern SRV_LOCK SrvEndpointLock;

//
// SrvShareLock protects all shares.
//

extern SRV_LOCK SrvShareLock;

//
// The number of processors in the system
//
extern ULONG SrvNumberOfProcessors;

//
// Work queues -- nonblocking, blocking, and critical.
//

#if MULTIPROCESSOR
extern PBYTE SrvWorkQueuesBase;
extern PWORK_QUEUE SrvWorkQueues;
#else
extern WORK_QUEUE SrvWorkQueues[1];
#endif

extern PWORK_QUEUE eSrvWorkQueues;          // used to terminate 'for' loops
extern WORK_QUEUE SrvBlockingWorkQueue;
extern ULONG SrvReBalanced;                 // how often we've picked another CPU
extern ULONG SrvNextBalanceProcessor;       // Which processor we'll look for next

extern CLONG SrvBlockingOpsInProgress;

//
// Various list heads.
//

extern LIST_ENTRY SrvNeedResourceQueue;    // The need resource queue
extern LIST_ENTRY SrvDisconnectQueue;      // The disconnect queue

//
// Queue of connections that needs to be dereferenced.
//

extern SLIST_HEADER SrvBlockOrphanage;

//
// FSP configuration queue.  The FSD puts configuration request IRPs
// (from NtDeviceIoControlFile) on this queue, and it is serviced by an
// EX worker thread.
//

extern LIST_ENTRY SrvConfigurationWorkQueue;

//
// This is the number of configuration IRPs which have been queued but not
//  yet completed.
//
extern ULONG SrvConfigurationIrpsInProgress;

//
// Work item for running the configuration thread in the context of an
// EX worker thread.

extern WORK_QUEUE_ITEM SrvConfigurationThreadWorkItem[ MAX_CONFIG_WORK_ITEMS ];

//
// Base address of the large block allocated to hold initial normal
// work items (see blkwork.c\SrvAllocateInitialWorkItems).
//

extern PVOID SrvInitialWorkItemBlock;

//
// Work item used to run the resource thread.  Booleans used to inform
// the resource thread to continue running.
//

extern WORK_QUEUE_ITEM SrvResourceThreadWorkItem;
extern BOOLEAN SrvResourceThreadRunning;
extern BOOLEAN SrvResourceDisconnectPending;
extern BOOLEAN SrvResourceFreeConnection;
extern LONG SrvResourceOrphanedBlocks;

//
// Denial of Service monitoring variables for the Resource Thread
//
#define SRV_DOS_MINIMUM_DOS_WAIT_PERIOD (50*1000*10)
#define SRV_DOS_TEARDOWN_MIN (LONG)MAX((SrvMaxReceiveWorkItemCount>>4),32)
#define SRV_DOS_TEARDOWN_MAX (LONG)(SrvMaxReceiveWorkItemCount>>1)
#define SRV_DOS_INCREASE_TEARDOWN() {                                               \
    LONG lTearDown = InterlockedCompareExchange( &SrvDoSWorkItemTearDown, 0, 0 );    \
    LONG lNewTearDown = MIN(lTearDown+(lTearDown>>2), SRV_DOS_TEARDOWN_MAX);        \
    SrvDoSRundownIncreased = TRUE;                                                  \
    InterlockedCompareExchange( &SrvDoSWorkItemTearDown, lNewTearDown, lTearDown );  \
}
#define SRV_DOS_DECREASE_TEARDOWN() {                                               \
    LONG lTearDown = InterlockedCompareExchange( &SrvDoSWorkItemTearDown, 0, 0 );    \
    LONG lNewTearDown = MAX(lTearDown-(SRV_DOS_TEARDOWN_MIN), SRV_DOS_TEARDOWN_MIN);        \
    if( lNewTearDown == SRV_DOS_TEARDOWN_MIN ) SrvDoSRundownIncreased = FALSE;      \
    InterlockedCompareExchange( &SrvDoSWorkItemTearDown, lNewTearDown, lTearDown );  \
}
#define SRV_DOS_GET_TEARDOWN()  InterlockedCompareExchange( &SrvDoSWorkItemTearDown, 0, 0 )
#define SRV_DOS_IS_TEARDOWN_IN_PROGRESS() InterlockedCompareExchange( &SrvDoSTearDownInProgress, 0, 0 )
#define SRV_DOS_CAN_START_TEARDOWN() !InterlockedCompareExchange( &SrvDoSTearDownInProgress, 1, 0 )
#define SRV_DOS_COMPLETE_TEARDOWN() InterlockedCompareExchange( &SrvDoSTearDownInProgress, 0, 1 )
extern LONG SrvDoSWorkItemTearDown;
extern LONG SrvDoSTearDownInProgress;      // Is a teardown in progress?
extern BOOLEAN SrvDoSDetected;
extern BOOLEAN SrvDoSRundownDetector;      // Used to rundown the teardown amounts
extern BOOLEAN SrvDoSRundownIncreased;     // Have we increased the Rundown past the minimum
extern BOOLEAN SrvDisableDoSChecking;
extern SPECIAL_WORK_ITEM SrvDoSWorkItem;
extern KSPIN_LOCK SrvDosSpinLock;
extern LARGE_INTEGER SrvDoSLastRan;

//
// Should we disable strict name checking
//
extern BOOLEAN SrvDisableStrictNameChecking;

//
// Generic security mapping for connecting to shares
//
extern GENERIC_MAPPING SrvShareConnectMapping;

//
// What's the minumum # of free work items each processor should have?
//
extern ULONG SrvMinPerProcessorFreeWorkItems;

//
// The server has callouts to enable a smart card to accelerate its direct
//  host IPX performance.  This is the vector of entry points.
//
extern SRV_IPX_SMART_CARD SrvIpxSmartCard;

//
// This is the name of the server computer.  Returned in the negprot response
//
extern UNICODE_STRING SrvComputerName;

//
// The master file table contains one entry for each named file that has
// at least one open instance.
//
extern MFCBHASH SrvMfcbHashTable[ NMFCB_HASH_TABLE ];

//
// The share table contains one entry for each share
//
extern LIST_ENTRY SrvShareHashTable[ NSHARE_HASH_TABLE ];

//
// Hex digits array used by the dump routines and SrvSmbCreateTemporary.
//

extern CHAR SrvHexChars[];

#if SRVCATCH
//
// Are we looking for the special file?
//
extern UNICODE_STRING SrvCatch;
extern PWSTR *SrvCatchBuf;
extern UNICODE_STRING SrvCatchExt;
extern PWSTR *SrvCatchExtBuf;
extern ULONG SrvCatchShares;
extern PWSTR *SrvCatchShareNames;
#endif

//
// SMB dispatch table
//

extern UCHAR SrvSmbIndexTable[];

typedef struct {
    PSMB_PROCESSOR  Func;
#if DBG
    LPSTR           Name;
#endif
} SRV_SMB_DISPATCH_TABLE;

extern SRV_SMB_DISPATCH_TABLE SrvSmbDispatchTable[];

//
// SMB word count table.
//

extern SCHAR SrvSmbWordCount[];

//
// Device prefix strings.
//

extern UNICODE_STRING SrvCanonicalNamedPipePrefix;
extern UNICODE_STRING SrvNamedPipeRootDirectory;
extern UNICODE_STRING SrvMailslotRootDirectory;

//
// Transaction2 dispatch table
//

extern PSMB_TRANSACTION_PROCESSOR SrvTransaction2DispatchTable[];
extern PSMB_TRANSACTION_PROCESSOR SrvNtTransactionDispatchTable[];

extern SRV_STATISTICS SrvStatistics;
#if SRVDBG_STATS || SRVDBG_STATS2
extern SRV_STATISTICS_DEBUG SrvDbgStatistics;
#endif

//
// The number of abortive disconnects that the server has gotten
//
extern ULONG SrvAbortiveDisconnects;

//
// Server environment information strings.
//

extern UNICODE_STRING SrvNativeOS;
extern OEM_STRING SrvOemNativeOS;
extern UNICODE_STRING SrvNativeLanMan;
extern OEM_STRING SrvOemNativeLanMan;
extern UNICODE_STRING SrvSystemRoot;

//
// The following will be a permanent handle and device object pointer
// to NPFS.
//

extern HANDLE SrvNamedPipeHandle;
extern PDEVICE_OBJECT SrvNamedPipeDeviceObject;
extern PFILE_OBJECT SrvNamedPipeFileObject;

//
// The following are used to converse with the Dfs driver
//
extern PFAST_IO_DEVICE_CONTROL SrvDfsFastIoDeviceControl;
extern PDEVICE_OBJECT SrvDfsDeviceObject;
extern PFILE_OBJECT SrvDfsFileObject;

//
// The following will be a permanent handle and device object pointer
// to MSFS.
//

extern HANDLE SrvMailslotHandle;
extern PDEVICE_OBJECT SrvMailslotDeviceObject;
extern PFILE_OBJECT SrvMailslotFileObject;

//
// Flag indicating XACTSRV whether is active, and resource synchronizing
// access to XACTSRV-related variabled.
//

extern BOOLEAN SrvXsActive;

extern ERESOURCE SrvXsResource;

//
// Handle to the unnamed shared memory and communication port used for
// communication between the server and XACTSRV.
//

extern HANDLE SrvXsSectionHandle;
extern HANDLE SrvXsPortHandle;

//
// Pointers to control the unnamed shared memory for the XACTSRV LPC port.
//

extern PVOID SrvXsPortMemoryBase;
extern ULONG_PTR SrvXsPortMemoryDelta;
extern PVOID SrvXsPortMemoryHeap;

//
// Pointer to heap header for the special XACTSRV shared-memory heap.
//

extern PVOID SrvXsHeap;

//
// Dispatch table for handling server API requests.
//

extern PAPI_PROCESSOR SrvApiDispatchTable[];

//
// Names for the various types of clients.
//

extern UNICODE_STRING SrvClientTypes[];

//
// All the resumable Enum APIs use ordered lists for context-free
// resume.  All data blocks in the server that correspond to return
// information for Enum APIs are maintained in ordered lists.
//

extern SRV_LOCK SrvOrderedListLock;

extern ORDERED_LIST_HEAD SrvEndpointList;
extern ORDERED_LIST_HEAD SrvRfcbList;
extern ORDERED_LIST_HEAD SrvSessionList;
extern ORDERED_LIST_HEAD SrvShareList;
extern ORDERED_LIST_HEAD SrvTreeConnectList;

// The DNS domain name for the domain
extern PUNICODE_STRING SrvDnsDomainName;

//
// To synchronize server shutdown with API requests handled in the
// server FSD, we track the number of outstanding API requests.  The
// shutdown code waits until all APIs have been completed to start
// termination.
//
// SrvApiRequestCount tracks the active APIs in the FSD.
// SrvApiCompletionEvent is set by the last API to complete, and the
// shutdown code waits on it if there are outstanding APIs.
//

extern ULONG SrvApiRequestCount;
extern KEVENT SrvApiCompletionEvent;


//
// Security contexts required for mutual authentication.
// SrvKerberosLsaHandle and SrvLmLsaHandle are credentials of the server
// principal. They are used to validate incoming kerberos tickets.
// SrvNullSessionToken is a cached token handle representing the null session.
//
extern CtxtHandle SrvLmLsaHandle;
extern CtxtHandle SrvNullSessionToken;


extern CtxtHandle SrvExtensibleSecurityHandle;

//
// Oplock break information.
//

extern LIST_ENTRY SrvWaitForOplockBreakList;
extern SRV_LOCK SrvOplockBreakListLock;
extern LIST_ENTRY SrvOplockBreaksInProgressList;

//
// The default server security quality of service.
//

extern SECURITY_QUALITY_OF_SERVICE SrvSecurityQOS;

//
// A BOOLEAN to indicate whether the server is paused.  If paused, the
// server will not accept new tree connections from non-admin users.
//

extern BOOLEAN SrvPaused;

//
// Alerting information.
//

extern SRV_ERROR_RECORD SrvErrorRecord;
extern SRV_ERROR_RECORD SrvNetworkErrorRecord;
extern BOOLEAN SrvDiskAlertRaised[26];

//
// Counts of the number of times pool allocations have failed because
// the server was at its configured pool limit.
//

extern ULONG SrvNonPagedPoolLimitHitCount;
extern ULONG SrvPagedPoolLimitHitCount;

//
// SrvOpenCount counts the number of active opens of the server device.
// This is used at server shutdown time to determine whether the server
// service should unload the driver.
//

extern ULONG SrvOpenCount;

//
// Counters for logging resource shortage events during a scavenger pass.
//

extern ULONG SrvOutOfFreeConnectionCount;
extern ULONG SrvOutOfRawWorkItemCount;
extern ULONG SrvFailedBlockingIoCount;

//
// Current core search timeout time in seconds
//

extern ULONG SrvCoreSearchTimeout;

//
// SrvTimerList is a pool of timer/DPC structures available for use by
// code that needs to start a timer.
//

extern SLIST_HEADER SrvTimerList;

//
// Name that should be displayed when doing a server alert.
//

extern PWSTR SrvAlertServiceName;

//
// Variable to store the number of tick counts for 5 seconds
//

extern ULONG SrvFiveSecondTickCount;

//
// Holds the PNP notification handle for TDI
//
extern HANDLE SrvTdiNotificationHandle;

//
// Flag indicating whether or not SMB security signatures are enabled.
//
extern BOOLEAN SrvSmbSecuritySignaturesEnabled;

//
// Flag indicating whether or not SMB security signatures are required.  The signature
//   must match between the client and the server for the smb to be accepted.
//
extern BOOLEAN SrvSmbSecuritySignaturesRequired;

//
// Flag indicating whether or not SMB security signatures should be applied to W9x
// clients.
//
extern BOOLEAN SrvEnableW9xSecuritySignatures;

//
// Security descriptor granting Administrator READ access.
//  Used to see if a client has administrative privileges
//
extern SECURITY_DESCRIPTOR SrvAdminSecurityDescriptor;

//
// Security descriptor granting Anonymous READ access.
//  Used to see if a client was an anonymous (null session) logon
//
extern SECURITY_DESCRIPTOR SrvNullSessionSecurityDescriptor;

//
// Flag indicating whether or not we need to filter extended characters
//  out of 8.3 names ourselves.
//
extern BOOLEAN SrvFilterExtendedCharsInPath;

//
// Flag indicating whether we enforce logoff times
//
extern BOOLEAN SrvEnforceLogoffTimes;

//
// Maximum amount of data that we'll allocate to support a METHOD_NEITHER Fsctl call
//
extern ULONG SrvMaxFsctlBufferSize;

//
// Maximum NT transaction size which we'll accept.
//
extern ULONG SrvMaxNtTransactionSize;

//
// Maximum size of large Read&X that we'll allow.  We need to lock down a cache region
//  to service this request, so we don't want it to get too big
//
extern ULONG SrvMaxReadSize;

//
// Maximum size of a compressed write that we'll allow.  We need to lock down a cache
//  region to service this request, so we dont' want it to get too big.
//
extern ULONG SrvMaxCompressedDataLength;

//
// When we receive an uncompressed large write from a client, we receive it in chunks,
//  locking & unlocking the file cache as we receive the data.  SrvMaxWriteChunk is the
//  size of this 'chunk'.  There's no magic to this chosen value.
//
extern ULONG SrvMaxWriteChunk;

//
// Handle used for PoRegisterSystemState calls
//
extern PVOID SrvPoRegistrationState;

//
// Counter used to suppress extraneous PoRegisterSystemStateCalls
//
extern ULONG SrvIdleCount;

#if SRVNTVERCHK
//
// This is the minimum NT5 client build number that we will allow to connect to the server
//
extern ULONG SrvMinNT5Client;
extern BOOLEAN SrvMinNT5ClientIPCToo;

//
// To force upgrades of our internal development community, we can set a
//  value in the registry that governs the minimum NT release that we allow
//  people to run to connect to this server.  However, some folks have special
//  needs that preclude a forced upgrade.  Presuming they have a static IP address,
//  you can add their address to the registry to exclude them from the build number
//  checking logic
//
extern DWORD SrvAllowIPAddress[25];

//
// If a server worker threads remains idle for this many ticks, then it terminate
//
extern LONGLONG SrvIdleThreadTimeOut;

extern LARGE_INTEGER SrvLastDosAttackTime;
extern ULONG SrvDOSAttacks;
extern BOOLEAN SrvLogEventOnDOS;

#endif

//
//  These are used to track persistent connections/handles.  The counters are
//  assigned to RFCBs, connections, and sessions.
//

#ifdef INCLUDE_SMB_PERSISTENT
extern ULONG   SrvGlobalPersistentSessionId;
extern ULONG   SrvGlobalPersistentRfcbId;
#endif

//
//  These are used for internal testing of the reauthentication code
//
extern USHORT SessionInvalidateCommand;
extern USHORT SessionInvalidateMod;

typedef struct _SRV_REAUTH_TEST_
{
    USHORT InvalidateCommand;
    USHORT InvalidateModulo;
} SRV_REAUTH_TEST, *PSRV_REAUTH_TEST;

#endif // ndef _SRVDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvdata.c

Abstract:

    This module defines global data for the LAN Manager server FSP.  The
    globals defined herein are part of the server driver image, and are
    therefore loaded into the system address space and are nonpageable.
    Some of the fields point to, or contain pointers to, data that is
    also in the system address space and nonpageable.  Such data can be
    accessed by both the FSP and the FSD.  Other fields point to data
    that is in the FSP address and may or may not be pageable.  Only the
    FSP is allowed to address this data.  Pageable data can only be
    accessed at low IRQL (so that page faults are allowed).

    This module also has a routine to initialize those fields defined
    here that cannot be statically initialized.

Author:

    Chuck Lenzmeier (chuckl)    3-Oct-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "srvdata.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SrvInitializeData )
#pragma alloc_text( PAGE, SrvTerminateData )
#endif


#if SRVDBG

ULARGE_INTEGER SrvDebug = {DEBUG_STOP_ON_ERRORS};
ULARGE_INTEGER SmbDebug = {0};

CLONG SrvDumpMaximumRecursion = 0;

#endif // SRVDBG

#ifdef PAGED_DBG
ULONG ThisCodeCantBePaged = 0;
#endif

//
// SrvDeviceObject is a pointer to the server's device object, which
// is created by the server FSD during initialization.  This global
// location is accessed primarily by the FSP.  The FSD usually knows
// the device object address by other means -- because it was called
// with the address as a parameter, or via a file object, etc.  But
// the transport receive event handler in the FSD doesn't have such
// other means, so it needs to access the global storage.
//
// *** The event handler has the address of a server connection block
//     (in its ConnectionContext parameter).  The device object address
//     could be found through the connection block.
//

PDEVICE_OBJECT SrvDeviceObject = NULL;

//
// Fields describing the state of the FSP.
//

BOOLEAN SrvFspActive = FALSE;             // Indicates whether the FSP is
                                          // running
BOOLEAN SrvFspTransitioning = FALSE;      // Indicates that the server is
                                          // in the process of starting up
                                          // or shutting down

BOOLEAN SrvMultiProcessorDriver = FALSE;  // Is this a multiprocessor driver?

BOOLEAN SrvCompletedPNPRegistration = FALSE;    // Indicates whether the FSP has completed
                                                //  registering for PNP notifications

PEPROCESS SrvServerProcess = NULL;        // Pointer to the initial system process

PEPROCESS SrvSvcProcess = NULL;           // Pointer to the service controller process

CLONG SrvEndpointCount = 0;               // Number of transport endpoints
KEVENT SrvEndpointEvent = {0};            // Signaled when no active endpoints

//
// DMA alignment size
//

ULONG SrvCacheLineSize = 0;

//
// Global spin locks.
//

SRV_GLOBAL_SPIN_LOCKS SrvGlobalSpinLocks = {0};

#if SRVDBG || SRVDBG_HANDLES
//
// Lock used to protect debugging structures.
//

SRV_LOCK SrvDebugLock = {0};
#endif

//
// SrvConfigurationLock is used to synchronize configuration requests.
//

SRV_LOCK SrvConfigurationLock = {0};

//
// SrvStartupShutdownLock is used to synchronize server startup and shutdown
//

SRV_LOCK SrvStartupShutdownLock = {0};

//
// SrvEndpointLock serializes access to the global endpoint list and
// all endpoints.  Note that the list of connections in each endpoint
// is also protected by this lock.
//

SRV_LOCK SrvEndpointLock = {0};

//
// SrvShareLock protects all shares.
//

SRV_LOCK SrvShareLock = {0};

//
// The number of processors in the system
//
ULONG SrvNumberOfProcessors = {0};

//
// A vector of nonblocking work queues, one for each processor
//
#if MULTIPROCESSOR

PBYTE SrvWorkQueuesBase = 0;      // base of allocated memory for the queues
PWORK_QUEUE SrvWorkQueues = 0;    // first queue in the allocated memory

#else

WORK_QUEUE SrvWorkQueues[1];

#endif

PWORK_QUEUE eSrvWorkQueues = 0;   // used for terminating 'for' loops

//
// Blocking Work Queue
//
WORK_QUEUE SrvBlockingWorkQueue = {0};
ULONG SrvReBalanced = 0;
ULONG SrvNextBalanceProcessor = 0;

CLONG SrvBlockingOpsInProgress = 0; // Number of blocking ops currently
                                    //   being processed


//
// The queue of connections that need an SMB buffer to process a pending
// receive completion.
//

LIST_ENTRY SrvNeedResourceQueue = {0};  // The queue

//
// The queue of connections that are disconnecting and need resource
// thread processing.
//

LIST_ENTRY SrvDisconnectQueue = {0};    // The queue

//
// Queue of connections that needs to be dereferenced.
//

SLIST_HEADER SrvBlockOrphanage = {0};    // The queue

//
// FSP configuration queue.  The FSD puts configuration request IRPs
// (from NtDeviceIoControlFile) on this queue, and it is serviced by an
// EX worker thread.
//

LIST_ENTRY SrvConfigurationWorkQueue = {0};     // The queue itself

//
// This is the number of configuration IRPs which have been queued but not
//  yet completed.
//
ULONG SrvConfigurationIrpsInProgress = 0;

//
// Base address of the large block allocated to hold initial normal
// work items (see blkwork.c\SrvAllocateInitialWorkItems).
//

PVOID SrvInitialWorkItemBlock = NULL;

//
// Work item used to run the resource thread.  Notification event used
// to inform the resource thread to continue running.
//

WORK_QUEUE_ITEM SrvResourceThreadWorkItem = {0};
BOOLEAN SrvResourceThreadRunning = FALSE;
BOOLEAN SrvResourceDisconnectPending = FALSE;
BOOLEAN SrvResourceFreeConnection = FALSE;
LONG SrvResourceOrphanedBlocks = 0;

//
// Denial of Service monitoring variables for the Resource Thread
//
LONG SrvDoSTearDownInProgress = 0;
LONG SrvDoSWorkItemTearDown = 0;
BOOLEAN SrvDoSDetected = FALSE;
BOOLEAN SrvDoSRundownDetector = FALSE;
BOOLEAN SrvDoSRundownIncreased = FALSE;
BOOLEAN SrvDisableDoSChecking = FALSE;
SPECIAL_WORK_ITEM SrvDoSWorkItem;
KSPIN_LOCK SrvDosSpinLock;
LARGE_INTEGER SrvDoSLastRan = {0};

//
// Should we enforce strict name checking?
//
BOOLEAN SrvDisableStrictNameChecking = FALSE;

//
// Generic security mapping for connecting to shares
//
GENERIC_MAPPING SrvShareConnectMapping = GENERIC_SHARE_CONNECT_MAPPING;

//
// What's the minumum # of free work items each processor should have?
//
ULONG SrvMinPerProcessorFreeWorkItems = 0;

//
// The server has callouts to enable a smart card to accelerate its direct
//  host IPX performance.  This is the vector of entry points.
//
SRV_IPX_SMART_CARD SrvIpxSmartCard = {0};

//
// This is the name of the server computer.  Returned in the negprot response
//
UNICODE_STRING SrvComputerName = {0};

//
// The master file table contains one entry for each named file that has
// at least one open instance.
//
MFCBHASH SrvMfcbHashTable[ NMFCB_HASH_TABLE ] = {0};

//
// This is the list of resources which protect the SrvMfcbHashTable buckets
//
SRV_LOCK SrvMfcbHashTableLocks[ NMFCB_HASH_TABLE_LOCKS ];

//
// The share table contains one entry for each share the server is supporting
//
LIST_ENTRY SrvShareHashTable[ NSHARE_HASH_TABLE ] = {0};

//
// Array of the hex digits for use by the dump routines and
// SrvSmbCreateTemporary.
//

CHAR SrvHexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                       'A', 'B', 'C', 'D', 'E', 'F' };


#if SRVCATCH
//
// Are we looking for the special file?
//
UNICODE_STRING SrvCatch;
PWSTR *SrvCatchBuf = NULL;
UNICODE_STRING SrvCatchExt;
PWSTR *SrvCatchExtBuf = NULL;
ULONG SrvCatchShares = 0;
PWSTR *SrvCatchShareNames = NULL;
#endif

//
// SrvSmbIndexTable is the first-layer index table for processing SMBs.
// The contents of this table are used to index into SrvSmbDispatchTable.
//

UCHAR SrvSmbIndexTable[] = {
    ISrvSmbCreateDirectory,         // SMB_COM_CREATE_DIRECTORY
    ISrvSmbDeleteDirectory,         // SMB_COM_DELETE_DIRECTORY
    ISrvSmbOpen,                    // SMB_COM_OPEN
    ISrvSmbCreate,                  // SMB_COM_CREATE
    ISrvSmbClose,                   // SMB_COM_CLOSE
    ISrvSmbFlush,                   // SMB_COM_FLUSH
    ISrvSmbDelete,                  // SMB_COM_DELETE
    ISrvSmbRename,                  // SMB_COM_RENAME
    ISrvSmbQueryInformation,        // SMB_COM_QUERY_INFORMATION
    ISrvSmbSetInformation,          // SMB_COM_SET_INFORMATION
    ISrvSmbRead,                    // SMB_COM_READ
    ISrvSmbWrite,                   // SMB_COM_WRITE
    ISrvSmbLockByteRange,           // SMB_COM_LOCK_BYTE_RANGE
    ISrvSmbUnlockByteRange,         // SMB_COM_UNLOCK_BYTE_RANGE
    ISrvSmbCreateTemporary,         // SMB_COM_CREATE_TEMPORARY
    ISrvSmbCreate,                  // SMB_COM_CREATE
    ISrvSmbCheckDirectory,          // SMB_COM_CHECK_DIRECTORY
    ISrvSmbProcessExit,             // SMB_COM_PROCESS_EXIT
    ISrvSmbSeek,                    // SMB_COM_SEEK
    ISrvSmbLockAndRead,             // SMB_COM_LOCK_AND_READ
    ISrvSmbWrite,                   // SMB_COM_WRITE_AND_UNLOCK
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbReadRaw,                 // SMB_COM_READ_RAW
    ISrvSmbReadMpx,                 // SMB_COM_READ_MPX
    ISrvSmbIllegalCommand,          // SMB_COM_READ_MPX_SECONDARY (server only)
    ISrvSmbWriteRaw,                // SMB_COM_WRITE_RAW
    ISrvSmbWriteMpx,                // SMB_COM_WRITE_MPX
    ISrvSmbWriteMpxSecondary,       // SMB_COM_WRITE_MPX_SECONDARY
    ISrvSmbIllegalCommand,          // SMB_COM_WRITE_COMPLETE (server only)
    ISrvSmbIllegalCommand,          // SMB_COM_QUERY_INFORMATION_SRV
    ISrvSmbSetInformation2,         // SMB_COM_SET_INFORMATION2
    ISrvSmbQueryInformation2,       // SMB_COM_QUERY_INFORMATION2
    ISrvSmbLockingAndX,             // SMB_COM_LOCKING_ANDX
    ISrvSmbTransaction,             // SMB_COM_TRANSACTION
    ISrvSmbTransactionSecondary,    // SMB_COM_TRANSACTION_SECONDARY
    ISrvSmbIoctl,                   // SMB_COM_IOCTL
    ISrvSmbIoctlSecondary,          // SMB_COM_IOCTL_SECONDARY
    ISrvSmbMove,                    // SMB_COM_COPY
    ISrvSmbMove,                    // SMB_COM_MOVE
    ISrvSmbEcho,                    // SMB_COM_ECHO
    ISrvSmbWrite,                   // SMB_COM_WRITE_AND_CLOSE
    ISrvSmbOpenAndX,                // SMB_COM_OPEN_ANDX
    ISrvSmbReadAndX,                // SMB_COM_READ_ANDX
    ISrvSmbWriteAndX,               // SMB_COM_WRITE_ANDX
    ISrvSmbIllegalCommand,          // SMB_COM_SET_NEW_SIZE
    ISrvSmbClose,                   // SMB_COM_CLOSE_AND_TREE_DISC
    ISrvSmbTransaction,             // SMB_COM_TRANSACTION2
    ISrvSmbTransactionSecondary,    // SMB_COM_TRANSACTION2_SECONDARY
    ISrvSmbFindClose2,              // SMB_COM_FIND_CLOSE2
    ISrvSmbFindNotifyClose,         // SMB_COM_FIND_NOTIFY_CLOSE
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbTreeConnect,             // SMB_COM_TREE_CONNECT
    ISrvSmbTreeDisconnect,          // SMB_COM_TREE_DISCONNECT
    ISrvSmbNegotiate,               // SMB_COM_NEGOTIATE
    ISrvSmbSessionSetupAndX,        // SMB_COM_SESSION_SETUP_ANDX
    ISrvSmbLogoffAndX,              // SMB_COM_LOGOFF_ANDX
    ISrvSmbTreeConnectAndX,         // SMB_COM_TREE_CONNECT_ANDX
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbQueryInformationDisk,    // SMB_COM_QUERY_INFORMATION_DISK
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbNtTransaction,           // SMB_COM_NT_TRANSACT
    ISrvSmbNtTransactionSecondary,  // SMB_COM_NT_TRANSACT_SECONDARY
    ISrvSmbNtCreateAndX,            // SMB_COM_NT_CREATE_ANDX
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbNtCancel,                // SMB_COM_NT_CANCEL
    ISrvSmbRename,                  // SMB_COM_NT_RENAME
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbOpenPrintFile,           // SMB_COM_OPEN_PRINT_FILE
    ISrvSmbWrite,                   // SMB_COM_WRITE_PRINT_FILE
    ISrvSmbClosePrintFile,          // SMB_COM_CLOSE_PRINT_FILE
    ISrvSmbGetPrintQueue,           // SMB_COM_GET_PRINT_QUEUE
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_BROADCAST_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_FORWARD_USER_NAME
    ISrvSmbIllegalCommand,          // SMB_COM_CANCEL_FORWARD
    ISrvSmbIllegalCommand,          // SMB_COM_GET_MACHINE_NAME
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_START_MB_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_END_MB_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_TEXT_MB_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand           // SMB_COM_ILLEGAL_COMMAND
};

//
// SrvSmbDispatchTable is the jump table for processing SMBs.
//

#if DBG
#define SMB_DISPATCH_ENTRY( x )  { x, #x }
#else
#define SMB_DISPATCH_ENTRY( x ) { x }
#endif

SRV_SMB_DISPATCH_TABLE SrvSmbDispatchTable[] = {

    SMB_DISPATCH_ENTRY( SrvSmbIllegalCommand ),
    SMB_DISPATCH_ENTRY( SrvSmbCreateDirectory ),
    SMB_DISPATCH_ENTRY( SrvSmbDeleteDirectory ),
    SMB_DISPATCH_ENTRY( SrvSmbOpen ),
    SMB_DISPATCH_ENTRY( SrvSmbCreate ),
    SMB_DISPATCH_ENTRY( SrvSmbClose ),
    SMB_DISPATCH_ENTRY( SrvSmbFlush ),
    SMB_DISPATCH_ENTRY( SrvSmbDelete ),
    SMB_DISPATCH_ENTRY( SrvSmbRename ),
    SMB_DISPATCH_ENTRY( SrvSmbQueryInformation ),
    SMB_DISPATCH_ENTRY( SrvSmbSetInformation ),
    SMB_DISPATCH_ENTRY( SrvSmbRead ),
    SMB_DISPATCH_ENTRY( SrvSmbWrite ),
    SMB_DISPATCH_ENTRY( SrvSmbLockByteRange ),
    SMB_DISPATCH_ENTRY( SrvSmbUnlockByteRange ),
    SMB_DISPATCH_ENTRY( SrvSmbCreateTemporary ),
    SMB_DISPATCH_ENTRY( SrvSmbCheckDirectory ),
    SMB_DISPATCH_ENTRY( SrvSmbProcessExit ),
    SMB_DISPATCH_ENTRY( SrvSmbSeek ),
    SMB_DISPATCH_ENTRY( SrvSmbLockAndRead ),
    SMB_DISPATCH_ENTRY( SrvSmbSetInformation2 ),
    SMB_DISPATCH_ENTRY( SrvSmbQueryInformation2 ),
    SMB_DISPATCH_ENTRY( SrvSmbLockingAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbTransaction ),
    SMB_DISPATCH_ENTRY( SrvSmbTransactionSecondary ),
    SMB_DISPATCH_ENTRY( SrvSmbIoctl ),
    SMB_DISPATCH_ENTRY( SrvSmbIoctlSecondary ),
    SMB_DISPATCH_ENTRY( SrvSmbMove ),
    SMB_DISPATCH_ENTRY( SrvSmbEcho ),
    SMB_DISPATCH_ENTRY( SrvSmbOpenAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbReadAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbFindClose2 ),
    SMB_DISPATCH_ENTRY( SrvSmbFindNotifyClose ),
    SMB_DISPATCH_ENTRY( SrvSmbTreeConnect ),
    SMB_DISPATCH_ENTRY( SrvSmbTreeDisconnect ),
    SMB_DISPATCH_ENTRY( SrvSmbNegotiate ),
    SMB_DISPATCH_ENTRY( SrvSmbSessionSetupAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbLogoffAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbTreeConnectAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbQueryInformationDisk ),
    SMB_DISPATCH_ENTRY( SrvSmbSearch ),
    SMB_DISPATCH_ENTRY( SrvSmbNtTransaction ),
    SMB_DISPATCH_ENTRY( SrvSmbNtTransactionSecondary ),
    SMB_DISPATCH_ENTRY( SrvSmbNtCreateAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbNtCancel ),
    SMB_DISPATCH_ENTRY( SrvSmbOpenPrintFile ),
    SMB_DISPATCH_ENTRY( SrvSmbClosePrintFile ),
    SMB_DISPATCH_ENTRY( SrvSmbGetPrintQueue ),
    SMB_DISPATCH_ENTRY( SrvSmbReadRaw ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteRaw ),
    SMB_DISPATCH_ENTRY( SrvSmbReadMpx ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteMpx ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteMpxSecondary )
};

//
// Table of WordCount values for all SMBs.
//

SCHAR SrvSmbWordCount[] = {
    0,            // SMB_COM_CREATE_DIRECTORY
    0,            // SMB_COM_DELETE_DIRECTORY
    2,            // SMB_COM_OPEN
    3,            // SMB_COM_CREATE
    3,            // SMB_COM_CLOSE
    1,            // SMB_COM_FLUSH
    1,            // SMB_COM_DELETE
    1,            // SMB_COM_RENAME
    0,            // SMB_COM_QUERY_INFORMATION
    8,            // SMB_COM_SET_INFORMATION
    5,            // SMB_COM_READ
    5,            // SMB_COM_WRITE
    5,            // SMB_COM_LOCK_BYTE_RANGE
    5,            // SMB_COM_UNLOCK_BYTE_RANGE
    3,            // SMB_COM_CREATE_TEMPORARY
    3,            // SMB_COM_CREATE
    0,            // SMB_COM_CHECK_DIRECTORY
    0,            // SMB_COM_PROCESS_EXIT
    4,            // SMB_COM_SEEK
    5,            // SMB_COM_LOCK_AND_READ
    5,            // SMB_COM_WRITE_AND_UNLOCK
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -1,           // SMB_COM_READ_RAW
    8,            // SMB_COM_READ_MPX
    8,            // SMB_COM_READ_MPX_SECONDARY
    -1,           // SMB_COM_WRITE_RAW
    12,           // SMB_COM_WRITE_MPX
    12,           // SMB_COM_WRITE_MPX_SECONDARY
    -2,           // SMB_COM_ILLEGAL_COMMAND
    1,            // SMB_COM_QUERY_INFORMATION_SRV
    7,            // SMB_COM_SET_INFORMATION2
    1,            // SMB_COM_QUERY_INFORMATION2
    8,            // SMB_COM_LOCKING_ANDX
    -1,           // SMB_COM_TRANSACTION
    8,            // SMB_COM_TRANSACTION_SECONDARY
    14,           // SMB_COM_IOCTL
    8,            // SMB_COM_IOCTL_SECONDARY
    3,            // SMB_COM_COPY
    3,            // SMB_COM_MOVE
    1,            // SMB_COM_ECHO
    -1,           // SMB_COM_WRITE_AND_CLOSE
    15,           // SMB_COM_OPEN_ANDX
    -1,           // SMB_COM_READ_ANDX
    -1,           // SMB_COM_WRITE_ANDX
    3,            // SMB_COM_SET_NEW_SIZE
    3,            // SMB_COM_CLOSE_AND_TREE_DISC
    -1,           // SMB_COM_TRANSACTION2
    9,            // SMB_COM_TRANSACTION2_SECONDARY
    1,            // SMB_COM_FIND_CLOSE2
    1,            // SMB_COM_FIND_NOTIFY_CLOSE
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    0,            // SMB_COM_TREE_CONNECT
    0,            // SMB_COM_TREE_DISCONNECT
    0,            // SMB_COM_NEGOTIATE
    -1,           // SMB_COM_SESSION_SETUP_ANDX
    2,            // SMB_COM_LOGOFF_ANDX
    4,            // SMB_COM_TREE_CONNECT_ANDX
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    0,            // SMB_COM_QUERY_INFORMATION_DISK
    2,            // SMB_COM_SEARCH
    2,            // SMB_COM_SEARCH
    2,            // SMB_COM_SEARCH
    2,            // SMB_COM_SEARCH
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -1,           // SMB_COM_NT_TRANSACT
    18,           // SMB_COM_NT_TRANSACT_SECONDARY
    24,           // SMB_COM_NT_CREATE_ANDX
    -2,           // SMB_COM_ILLEGAL_COMMAND
    0,            // SMB_COM_NT_CANCEL
    4,            // SMB_COM_NT_RENAME
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    2,            // SMB_COM_OPEN_PRINT_FILE
    1,            // SMB_COM_WRITE_PRINT_FILE
    1,            // SMB_COM_CLOSE_PRINT_FILE
    2,            // SMB_COM_GET_PRINT_QUEUE
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_SEND_MESSAGE
    -2,           // SMB_COM_SEND_BROADCAST_MESSAGE
    -2,           // SMB_COM_FORWARD_USER_NAME
    -2,           // SMB_COM_CANCEL_FORWARD
    -2,           // SMB_COM_GET_MACHINE_NAME
    -2,           // SMB_COM_SEND_START_MB_MESSAGE
    -2,           // SMB_COM_SEND_END_MB_MESSAGE
    -2,           // SMB_COM_SEND_TEXT_MB_MESSAGE
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
};

//
// SrvCanonicalNamedPipePrefix is "PIPE\".
//

UNICODE_STRING SrvCanonicalNamedPipePrefix = {0};

//
// The following is used to generate NT style pipe paths.
//

UNICODE_STRING SrvNamedPipeRootDirectory = {0};

//
// The following is used to generate NT style mailslot paths.
//

UNICODE_STRING SrvMailslotRootDirectory = {0};

//
// SrvTransaction2DispatchTable is the jump table for processing
// Transaction2 SMBs.
//

PSMB_TRANSACTION_PROCESSOR SrvTransaction2DispatchTable[] = {
    SrvSmbOpen2,
    SrvSmbFindFirst2,
    SrvSmbFindNext2,
    SrvSmbQueryFsInformation,
    SrvSmbSetFsInformation,
    SrvSmbQueryPathInformation,
    SrvSmbSetPathInformation,
    SrvSmbQueryFileInformation,
    SrvSmbSetFileInformation,
    SrvSmbFsctl,
    SrvSmbIoctl2,
    SrvSmbFindNotify,
    SrvSmbFindNotify,
    SrvSmbCreateDirectory2,
    SrvTransactionNotImplemented,                // Can be reused...
    SrvTransactionNotImplemented,
    SrvSmbGetDfsReferral,
    SrvSmbReportDfsInconsistency
};

//
// SrvNtTransactionDispatchTable is the jump table for processing
// NtTransaction SMBs.
//

PSMB_TRANSACTION_PROCESSOR SrvNtTransactionDispatchTable[ NT_TRANSACT_MAX_FUNCTION+1 ] = {
    NULL,
    SrvSmbCreateWithSdOrEa,
    SrvSmbNtIoctl,
    SrvSmbSetSecurityDescriptor,
    SrvSmbNtNotifyChange,
    SrvSmbNtRename,
    SrvSmbQuerySecurityDescriptor,
    SrvSmbQueryQuota,
    SrvSmbSetQuota
};

//
// Global variables for server statistics.
//

SRV_STATISTICS SrvStatistics = {0};

#if SRVDBG_STATS || SRVDBG_STATS2
SRV_STATISTICS_DEBUG SrvDbgStatistics = {0};
#endif

//
// The number of abortive disconnects that the server has gotten
//
ULONG SrvAbortiveDisconnects = 0;

//
// The number of memory retries, and how often they were successful
//
LONG SrvMemoryAllocationRetries = 0;
LONG SrvMemoryAllocationRetriesSuccessful = 0;

//
// Server environment information strings.
//

UNICODE_STRING SrvNativeOS = {0};
OEM_STRING SrvOemNativeOS = {0};
UNICODE_STRING SrvNativeLanMan = {0};
OEM_STRING SrvOemNativeLanMan = {0};
UNICODE_STRING SrvSystemRoot = {0};

//
// The following will be a permanent handle and device object pointer
// to NPFS.
//

HANDLE SrvNamedPipeHandle = NULL;
PDEVICE_OBJECT SrvNamedPipeDeviceObject = NULL;
PFILE_OBJECT SrvNamedPipeFileObject = NULL;

//
// The following are used to converse with the Dfs driver
//
PFAST_IO_DEVICE_CONTROL SrvDfsFastIoDeviceControl = NULL;
PDEVICE_OBJECT SrvDfsDeviceObject = NULL;
PFILE_OBJECT SrvDfsFileObject = NULL;

//
// The following will be a permanent handle and device object pointer
// to MSFS.
//

HANDLE SrvMailslotHandle = NULL;
PDEVICE_OBJECT SrvMailslotDeviceObject = NULL;
PFILE_OBJECT SrvMailslotFileObject = NULL;

//
// Flag indicating XACTSRV whether is active, and resource synchronizing
// access to XACTSRV-related variabled.
//

BOOLEAN SrvXsActive = FALSE;

ERESOURCE SrvXsResource = {0};

//
// Handle to the unnamed shared memory and communication port used for
// communication between the server and XACTSRV.
//

HANDLE SrvXsSectionHandle = NULL;
HANDLE SrvXsPortHandle = NULL;

//
// Pointers to control the unnamed shared memory for the XACTSRV LPC port.
// The port memory heap handle is initialized to NULL to indicate that
// there is no connection with XACTSRV yet.
//

PVOID SrvXsPortMemoryBase = NULL;
ULONG_PTR SrvXsPortMemoryDelta = 0;
PVOID SrvXsPortMemoryHeap = NULL;

//
// Pointer to heap header for the special XACTSRV shared-memory heap.
//

PVOID SrvXsHeap = NULL;

//
// Dispatch table for server APIs.  APIs are dispatched based on the
// control code passed to NtFsControlFile.
//
// *** The order here must match the order of API codes defined in
//     net\inc\srvfsctl.h!

PAPI_PROCESSOR SrvApiDispatchTable[] = {
    SrvNetConnectionEnum,
    SrvNetFileClose,
    SrvNetFileEnum,
    SrvNetServerDiskEnum,
    SrvNetServerSetInfo,
    SrvNetServerTransportAdd,
    SrvNetServerTransportDel,
    SrvNetServerTransportEnum,
    SrvNetSessionDel,
    SrvNetSessionEnum,
    SrvNetShareAdd,
    SrvNetShareDel,
    SrvNetShareEnum,
    SrvNetShareSetInfo,
    SrvNetStatisticsGet
};

//
// Names for the various types of clients.  This array corresponds to
// the SMB_DIALECT enumerated type.
//

UNICODE_STRING SrvClientTypes[LAST_DIALECT] = {0};

//
// All the resumable Enum APIs use ordered lists for context-free
// resume.  All data blocks in the server that correspond to return
// information for Enum APIs are maintained in ordered lists.
//

SRV_LOCK SrvOrderedListLock = {0};

ORDERED_LIST_HEAD SrvEndpointList = {0};
ORDERED_LIST_HEAD SrvRfcbList = {0};
ORDERED_LIST_HEAD SrvSessionList = {0};
ORDERED_LIST_HEAD SrvTreeConnectList = {0};

//
// The DNS name for the domain
//
PUNICODE_STRING SrvDnsDomainName = NULL;

//
// To synchronize server shutdown with API requests handled in the
// server FSD, we track the number of outstanding API requests.  The
// shutdown code waits until all APIs have been completed to start
// termination.
//
// SrvApiRequestCount tracks the active APIs in the FSD.
// SrvApiCompletionEvent is set by the last API to complete, and the
// shutdown code waits on it if there are outstanding APIs.
//

ULONG SrvApiRequestCount = 0;
KEVENT SrvApiCompletionEvent = {0};

//
// Security data for logging on remote users.  SrvLsaHandle is the logon
// process handle that we use in calls to LsaLogonUser.
// SrvSystemSecurityMode contains the secutity mode the system is
// running in.  SrvAuthenticationPackage is a token that describes the
// authentication package being used.  SrvNullSessionToken is a cached
// token handle representing the null session.
//

CtxtHandle SrvNullSessionToken = {0, 0};
CtxtHandle SrvLmLsaHandle = {0, 0};

CtxtHandle SrvExtensibleSecurityHandle = {0, 0};

//
// Security descriptor granting Administrator READ access.
//  Used to see if a client has administrative privileges
//
SECURITY_DESCRIPTOR SrvAdminSecurityDescriptor;

//
// Security descriptor granting Anonymous READ access.
//  Used to see if a client was an anonymous (null session) logon
//
SECURITY_DESCRIPTOR SrvNullSessionSecurityDescriptor;

//
// A list of SMBs waiting for an oplock break to occur, before they can
// proceed, and a lock to protect the list.
//

LIST_ENTRY SrvWaitForOplockBreakList = {0};
SRV_LOCK SrvOplockBreakListLock = {0};

//
// A list of outstanding oplock break requests.  The list is protected by
// SrvOplockBreakListLock.
//

LIST_ENTRY SrvOplockBreaksInProgressList = {0};

//
// Global security context.  Use static tracking.
//

SECURITY_QUALITY_OF_SERVICE SrvSecurityQOS = {0};

//
// A BOOLEAN to indicate whether the server is paused.  If paused, the
// server will not accept new tree connections from non-admin users.
//

BOOLEAN SrvPaused = FALSE;

//
// Alerting information.
//

SRV_ERROR_RECORD SrvErrorRecord = {0};
SRV_ERROR_RECORD SrvNetworkErrorRecord = {0};

BOOLEAN SrvDiskAlertRaised[26] = {0};

//
// Counts of the number of times pool allocations have failed because
// the server was at its configured pool limit.
//

ULONG SrvNonPagedPoolLimitHitCount = 0;
ULONG SrvPagedPoolLimitHitCount = 0;

//
// SrvOpenCount counts the number of active opens of the server device.
// This is used at server shutdown time to determine whether the server
// service should unload the driver.
//

ULONG SrvOpenCount = 0;

//
// Counters for logging resource shortage events during a scavenger pass.
//

ULONG SrvOutOfFreeConnectionCount = 0;
ULONG SrvOutOfRawWorkItemCount = 0;
ULONG SrvFailedBlockingIoCount = 0;

//
// Current core search timeout time in seconds
//

ULONG SrvCoreSearchTimeout = 0;

SRV_LOCK SrvUnlockableCodeLock = {0};
SECTION_DESCRIPTOR SrvSectionInfo[SRV_CODE_SECTION_MAX] = {
    { SrvSmbRead, NULL, 0 },                // pageable code -- locked
                                            //   only and always on NTAS
    { SrvCheckAndReferenceRfcb, NULL, 0 }   // 8FIL section -- locked
                                            //   when files are open
    };

//
// SrvTimerList is a pool of timer/DPC structures available for use by
// code that needs to start a timer.
//

SLIST_HEADER SrvTimerList = {0};

//
// Name that should be displayed when doing a server alert.
//

PWSTR SrvAlertServiceName = NULL;

//
// Variable to store the number of tick counts for 5 seconds
//

ULONG SrvFiveSecondTickCount = 0;

//
// Flag indicating whether or not we need to filter extended characters
//  out of 8.3 names ourselves.
//
BOOLEAN SrvFilterExtendedCharsInPath = FALSE;

//
// Flag indicating if we enforce all logoff times
//
BOOLEAN SrvEnforceLogoffTimes = FALSE;

//
// Holds the TDI PNP notification handle
//
HANDLE SrvTdiNotificationHandle = 0;

//
// Flag indicating whether or not SMB security signatures are enabled.
//
BOOLEAN SrvSmbSecuritySignaturesEnabled = FALSE;

//
// Flag indicating whether or not SMB security signatures are required.  The signature
//   must match between the client and the server for the smb to be accepted.
//
BOOLEAN SrvSmbSecuritySignaturesRequired = FALSE;

//
// Flag indicating whether or not SMB security signatures should be applied to W9x
// clients.
//
BOOLEAN SrvEnableW9xSecuritySignatures = FALSE;

//
// Maximum amount of data that we'll allocate to support a METHOD_NEITHER Fsctl call
//
ULONG SrvMaxFsctlBufferSize = 70*1024;

//
// Maximum NT transaction size which we'll accept.
//
ULONG SrvMaxNtTransactionSize = 70*1024;

//
// Maximum size of large Read&X that we'll allow.  We need to lock down a cache region
//  to service this request, so we don't want it to get too big
//
ULONG SrvMaxReadSize = 64*1024;

//
// Maximum size of a compressed write that we'll allow.  We need to lock down a cache
//  region to service this request, so we dont' want it to get too big.
//
ULONG SrvMaxCompressedDataLength = 64*1024;

//
// When we receive an uncompressed large write from a client, we receive it in chunks,
//  locking & unlocking the file cache as we receive the data.  SrvMaxWriteChunk is the
//  size of this 'chunk'.  There's no magic to this chosen value.
//
ULONG SrvMaxWriteChunk =  64 * 1024;

//
// Handle used for PoRegisterSystemState calls
//
PVOID SrvPoRegistrationState = NULL;
//
// Counter used to suppress extraneous PoRegisterSystemStateCalls
//
ULONG SrvIdleCount = 0;

//
// If a server worker threads remains idle for this many ticks, then it terminate
//
LONGLONG SrvIdleThreadTimeOut = 0;

//
// Denial-of-Service monitoring and logging controls
//
LARGE_INTEGER SrvLastDosAttackTime = {0};
ULONG SrvDOSAttacks = 0;
BOOLEAN SrvLogEventOnDOS = TRUE;


#if SRVNTVERCHK
//
// This is the minimum NT5 client build number that we will allow to connect to the server
//
ULONG SrvMinNT5Client = 0;
BOOLEAN SrvMinNT5ClientIPCToo = FALSE;

//
// To force upgrades of our internal development community, we can set a
//  value in the registry that governs the minimum NT release that we allow
//  people to run to connect to this server.  However, some folks have special
//  needs that preclude a forced upgrade.  Presuming they have a static IP address,
//  you can add their address to the registry to exclude them from the build number
//  checking logic
//
DWORD SrvAllowIPAddress[25];
#endif

//
//  These are used to track persistent connections/handles.  The counters are
//  assigned to RFCBs, connections, and sessions.
//

#ifdef INCLUDE_SMB_PERSISTENT
ULONG   SrvGlobalPersistentSessionId = 0;
ULONG   SrvGlobalPersistentRfcbId = 0;
#endif


VOID
SrvInitializeData (
    VOID
    )

/*++

Routine Description:

    This is the initialization routine for data defined in this module.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i,j;
    ANSI_STRING string;

    PAGED_CODE( );

#if MULTIPROCESSOR
    SrvMultiProcessorDriver = TRUE;
#endif

    //
    // Initialize the statistics database.
    //

    RtlZeroMemory( &SrvStatistics, sizeof(SrvStatistics) );
#if SRVDBG_STATS || SRVDBG_STATS2
    RtlZeroMemory( &SrvDbgStatistics, sizeof(SrvDbgStatistics) );
#endif

    //
    // Store the address of the initial system process for later use.
    //

    SrvServerProcess = IoGetCurrentProcess();

    //
    // Store the number of processors
    //
    SrvNumberOfProcessors = KeNumberProcessors;

    //
    // Initialize the event used to determine when all endpoints have
    // closed.
    //

    KeInitializeEvent( &SrvEndpointEvent, SynchronizationEvent, FALSE );

    //
    // Initialize the event used to deterine when all API requests have
    // completed.
    //

    KeInitializeEvent( &SrvApiCompletionEvent, SynchronizationEvent, FALSE );

    //
    // Allocate the spin lock used to synchronize between the FSD and
    // the FSP.
    //

    INITIALIZE_GLOBAL_SPIN_LOCK( Fsd );

#if SRVDBG || SRVDBG_HANDLES
    INITIALIZE_GLOBAL_SPIN_LOCK( Debug );
#endif

    INITIALIZE_GLOBAL_SPIN_LOCK( Statistics );

    //
    // Initialize various (non-spin) locks.
    //

    INITIALIZE_LOCK(
        &SrvConfigurationLock,
        CONFIGURATION_LOCK_LEVEL,
        "SrvConfigurationLock"
        );
    INITIALIZE_LOCK(
        &SrvStartupShutdownLock,
        STARTUPSHUTDOWN_LOCK_LEVEL,
        "SrvStartupShutdownLock"
        );
    INITIALIZE_LOCK(
        &SrvEndpointLock,
        ENDPOINT_LOCK_LEVEL,
        "SrvEndpointLock"
        );

    for( i=0; i < NMFCB_HASH_TABLE_LOCKS; i++ ) {
        INITIALIZE_LOCK(
            &SrvMfcbHashTableLocks[i],
            MFCB_LIST_LOCK_LEVEL,
            "SrvMfcbListLock"
            );
    }

    INITIALIZE_LOCK(
        &SrvShareLock,
        SHARE_LOCK_LEVEL,
        "SrvShareLock"
        );

    INITIALIZE_LOCK(
        &SrvOplockBreakListLock,
        OPLOCK_LIST_LOCK_LEVEL,
        "SrvOplockBreakListLock"
        );

#if SRVDBG || SRVDBG_HANDLES
    INITIALIZE_LOCK(
        &SrvDebugLock,
        DEBUG_LOCK_LEVEL,
        "SrvDebugLock"
        );
#endif

    //
    // Create the resource serializing access to the XACTSRV port.  This
    // resource protects access to the shared memory reference count and
    // the shared memory heap.
    //

    ExInitializeResourceLite( &SrvXsResource );

    //
    // Initialize the need resource queue
    //

    InitializeListHead( &SrvNeedResourceQueue );

    //
    // Initialize the connection disconnect queue
    //

    InitializeListHead( &SrvDisconnectQueue );

    //
    // Initialize the configuration queue.
    //

    InitializeListHead( &SrvConfigurationWorkQueue );

    //
    // Initialize the orphan queue
    //

    ExInitializeSListHead( &SrvBlockOrphanage );

    //
    // Initialize the Timer List
    //

    ExInitializeSListHead( &SrvTimerList );

    //
    // Initialize the resource thread work item and continuation event.
    // (Note that this is a notification [non-autoclearing] event.)
    //

    ExInitializeWorkItem(
        &SrvResourceThreadWorkItem,
        SrvResourceThread,
        NULL
        );

    //
    // Initialize global lists.
    //
    for( i=j=0; i < NMFCB_HASH_TABLE; i++ ) {
        InitializeListHead( &SrvMfcbHashTable[i].List );
        SrvMfcbHashTable[i].Lock = &SrvMfcbHashTableLocks[ j ];
        if( ++j == NMFCB_HASH_TABLE_LOCKS ) {
            j = 0;
        }
    }

    for( i=0; i < NSHARE_HASH_TABLE; i++ ) {
        InitializeListHead( &SrvShareHashTable[i] );
    }

    //
    // Initialize the ordered list lock.  Indicate that the ordered
    // lists have not yet been initialized, so that TerminateServer can
    // determine whether to delete them.
    //

    INITIALIZE_LOCK(
        &SrvOrderedListLock,
        ORDERED_LIST_LOCK_LEVEL,
        "SrvOrderedListLock"
        );

    SrvEndpointList.Initialized = FALSE;
    SrvRfcbList.Initialized = FALSE;
    SrvSessionList.Initialized = FALSE;
    SrvTreeConnectList.Initialized = FALSE;

    //
    // Initialize the unlockable code package lock.
    //

    INITIALIZE_LOCK(
        &SrvUnlockableCodeLock,
        UNLOCKABLE_CODE_LOCK_LEVEL,
        "SrvUnlockableCodeLock"
        );

    //
    // Initialize the waiting for oplock break to occur list, and the
    // oplock breaks in progress list.
    //

    InitializeListHead( &SrvWaitForOplockBreakList );
    InitializeListHead( &SrvOplockBreaksInProgressList );

    //
    // The default security quality of service for non NT clients.
    //

    SrvSecurityQOS.ImpersonationLevel = SecurityImpersonation;
    SrvSecurityQOS.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SrvSecurityQOS.EffectiveOnly = FALSE;

    //
    // Initialize Unicode strings.
    //

    RtlInitString( &string, StrPipeSlash );
    RtlAnsiStringToUnicodeString(
        &SrvCanonicalNamedPipePrefix,
        &string,
        TRUE
        );

    RtlInitUnicodeString( &SrvNamedPipeRootDirectory, StrNamedPipeDevice );
    RtlInitUnicodeString( &SrvMailslotRootDirectory, StrMailslotDevice );

    //
    // The server's name
    //

    RtlInitUnicodeString( &SrvNativeLanMan, StrNativeLanman );
    RtlInitAnsiString( (PANSI_STRING)&SrvOemNativeLanMan, StrNativeLanmanOem );

    //
    // The system root
    //
#if defined(i386)
    RtlInitUnicodeString( &SrvSystemRoot, SharedUserData->NtSystemRoot );
#endif

    //
    // Debug logic to verify the contents of SrvApiDispatchTable (see
    // inititialization earlier in this module).
    //

    ASSERT( SRV_API_INDEX(FSCTL_SRV_MAX_API_CODE) + 1 ==
                sizeof(SrvApiDispatchTable) / sizeof(PAPI_PROCESSOR) );

    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_CONNECTION_ENUM)] == SrvNetConnectionEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_FILE_CLOSE)] == SrvNetFileClose );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_FILE_ENUM)] == SrvNetFileEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_DISK_ENUM)] == SrvNetServerDiskEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_SET_INFO)] == SrvNetServerSetInfo );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_XPORT_ADD)] == SrvNetServerTransportAdd );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_XPORT_DEL)] == SrvNetServerTransportDel );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_XPORT_ENUM)] == SrvNetServerTransportEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SESSION_DEL)] == SrvNetSessionDel );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SESSION_ENUM)] == SrvNetSessionEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_ADD)] == SrvNetShareAdd );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_DEL)] == SrvNetShareDel );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_ENUM)] == SrvNetShareEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_SET_INFO)] == SrvNetShareSetInfo );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_STATISTICS_GET)] == SrvNetStatisticsGet );

    //
    // Setup error log records
    //

    SrvErrorRecord.AlertNumber = ALERT_ErrorLog;
    SrvNetworkErrorRecord.AlertNumber = ALERT_NetIO;

    //
    // Names for the various types of clients.  This array corresponds
    // to the SMB_DIALECT enumerated type.
    //

    for ( i = 0; i <= SmbDialectMsNet30; i++ ) {
        RtlInitUnicodeString( &SrvClientTypes[i], StrClientTypes[i] );
    }
    for ( ; i < LAST_DIALECT; i++ ) {
        SrvClientTypes[i] = SrvClientTypes[i-1]; // "DOWN LEVEL"
    }

    //
    // Initialize the timer pool.
    //

    INITIALIZE_GLOBAL_SPIN_LOCK( Timer );

    //
    // Initialize the 4 endpoint spinlocks
    //

    for ( i = 0 ; i < ENDPOINT_LOCK_COUNT ; i++ ) {
        INITIALIZE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(0), "endpoint 0    " );
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(1), "endpoint 1    " );
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(2), "endpoint 2    " );
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(3), "endpoint 3    " );

    //
    // Initialize the DMA alignment size
    //

    SrvCacheLineSize = KeGetRecommendedSharedDataAlignment(); // For PERF improvement, get the recommended cacheline
                                                              // alignment, instead of the HAL default

#if SRVDBG
    {
        ULONG cls = SrvCacheLineSize;
        while ( cls > 2 ) {
            ASSERTMSG(
                "SRV: cache line size not a power of two",
                (cls & 1) == 0 );
            cls = cls >> 1;
        }
    }
#endif

    if ( SrvCacheLineSize < 8 ) SrvCacheLineSize = 8;

    SrvCacheLineSize--;

    //
    // Compute the number of tick counts for 5 seconds
    //

    SrvFiveSecondTickCount = 5*10*1000*1000 / KeQueryTimeIncrement();

    return;

} // SrvInitializeData


VOID
SrvTerminateData (
    VOID
    )

/*++

Routine Description:

    This is the rundown routine for data defined in this module.  It is
    called when the server driver is unloaded.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE( );

    //
    // Clean up SmbTrace.
    //

    SmbTraceTerminate( SMBTRACE_SERVER );

    //
    // Terminate various (non-spin) locks.
    //

    DELETE_LOCK( &SrvConfigurationLock );
    DELETE_LOCK( &SrvStartupShutdownLock );
    DELETE_LOCK( &SrvEndpointLock );

    for( i=0; i < NMFCB_HASH_TABLE_LOCKS; i++ ) {
        DELETE_LOCK( &SrvMfcbHashTableLocks[i] );
    }

    DELETE_LOCK( &SrvShareLock );
    DELETE_LOCK( &SrvOplockBreakListLock );

#if SRVDBG || SRVDBG_HANDLES
    DELETE_LOCK( &SrvDebugLock );
#endif

    DELETE_LOCK( &SrvOrderedListLock );
    DELETE_LOCK( &SrvUnlockableCodeLock );

    ExDeleteResourceLite( &SrvXsResource );

    RtlFreeUnicodeString( &SrvCanonicalNamedPipePrefix );

    RtlFreeUnicodeString( &SrvComputerName );

} // SrvTerminateData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvfsd.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvfsd.h

Abstract:

    This module defines routines in the File System Driver for the LAN
    Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVFSD_
#define _SRVFSD_

//#include "srvblock.h"

#include "wmilib.h"

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT pDeviceObject;
    ULONG          TestCounter;
    WMILIB_CONTEXT WmiLibContext;
} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

typedef enum _tagSrvWmiEvents {
    EVENT_TYPE_SMB_CREATE_DIRECTORY,
    EVENT_TYPE_SMB_DELETE_DIRECTORY,
    EVENT_TYPE_SMB_OPEN,
    EVENT_TYPE_SMB_CREATE,
    EVENT_TYPE_SMB_CLOSE,
    EVENT_TYPE_SMB_FLUSH,
    EVENT_TYPE_SMB_DELETE,
    EVENT_TYPE_SMB_RENAME,
    EVENT_TYPE_SMB_QUERY_INFORMATION,
    EVENT_TYPE_SMB_SET_INFORMATION,
    EVENT_TYPE_SMB_READ,
    EVENT_TYPE_SMB_WRITE,
    EVENT_TYPE_SMB_LOCK_BYTE_RANGE,
    EVENT_TYPE_SMB_UNLOCK_BYTE_RANGE,
    EVENT_TYPE_SMB_CREATE_TEMPORARY,
    EVENT_TYPE_SMB_CHECK_DIRECTORY,
    EVENT_TYPE_SMB_PROCESS_EXIT,
    EVENT_TYPE_SMB_SEEK,
    EVENT_TYPE_SMB_LOCK_AND_READ,
    EVENT_TYPE_SMB_SET_INFORMATION2,
    EVENT_TYPE_SMB_QUERY_INFORMATION2,
    EVENT_TYPE_SMB_LOCKING_AND_X,
    EVENT_TYPE_SMB_TRANSACTION,
    EVENT_TYPE_SMB_TRANSACTION_SECONDARY,
    EVENT_TYPE_SMB_IOCTL,
    EVENT_TYPE_SMB_IOCTL_SECONDARY,
    EVENT_TYPE_SMB_MOVE,
    EVENT_TYPE_SMB_ECHO,
    EVENT_TYPE_SMB_OPEN_AND_X,
    EVENT_TYPE_SMB_READ_AND_X,
    EVENT_TYPE_SMB_WRITE_AND_X,
    EVENT_TYPE_SMB_FIND_CLOSE2,
    EVENT_TYPE_SMB_FIND_NOTIFY_CLOSE,
    EVENT_TYPE_SMB_TREE_CONNECT,
    EVENT_TYPE_SMB_TREE_DISCONNECT,
    EVENT_TYPE_SMB_NEGOTIATE,
    EVENT_TYPE_SMB_SESSION_SETUP_AND_X,
    EVENT_TYPE_SMB_LOGOFF_AND_X,
    EVENT_TYPE_SMB_TREE_CONNECT_AND_X,
    EVENT_TYPE_SMB_QUERY_INFORMATION_DISK,
    EVENT_TYPE_SMB_SEARCH,
    EVENT_TYPE_SMB_NT_TRANSACTION,
    EVENT_TYPE_SMB_NT_TRANSACTION_SECONDARY,
    EVENT_TYPE_SMB_NT_CREATE_AND_X,
    EVENT_TYPE_SMB_NT_CANCEL,
    EVENT_TYPE_SMB_OPEN_PRINT_FILE,
    EVENT_TYPE_SMB_CLOSE_PRINT_FILE,
    EVENT_TYPE_SMB_GET_PRINT_QUEUE,
    EVENT_TYPE_SMB_READ_RAW,
    EVENT_TYPE_SMB_WRITE_RAW,
    EVENT_TYPE_SMB_READ_MPX,
    EVENT_TYPE_SMB_WRITE_MPX,
    EVENT_TYPE_SMB_WRITE_MPX_SECONDARY,

    EVENT_TYPE_SMB_OPEN2,
    EVENT_TYPE_SMB_FIND_FIRST2,
    EVENT_TYPE_SMB_FIND_NEXT2,
    EVENT_TYPE_SMB_QUERY_FS_INFORMATION,
    EVENT_TYPE_SMB_SET_FS_INFORMATION,
    EVENT_TYPE_SMB_QUERY_PATH_INFORMATION,
    EVENT_TYPE_SMB_SET_PATH_INFORMATION,
    EVENT_TYPE_SMB_QUERY_FILE_INFORMATION,
    EVENT_TYPE_SMB_SET_FILE_INFORMATION,
    EVENT_TYPE_SMB_FSCTL,
    EVENT_TYPE_SMB_IOCTL2,
    EVENT_TYPE_SMB_FIND_NOTIFY,
    EVENT_TYPE_SMB_CREATE_DIRECTORY2,
    EVENT_TYPE_SMB_GET_DFS_REFERRALS,
    EVENT_TYPE_SMB_REPORT_DFS_INCONSISTENCY,

    EVENT_TYPE_SMB_CREATE_WITH_SD_OR_EA,
    EVENT_TYPE_SMB_NT_IOCTL,
    EVENT_TYPE_SMB_SET_SECURITY_DESCRIPTOR,
    EVENT_TYPE_SMB_NT_NOTIFY_CHANGE,
    EVENT_TYPE_SMB_NT_RENAME,
    EVENT_TYPE_SMB_QUERY_SECURITY_DESCRIPTOR,
    EVENT_TYPE_SMB_QUERY_QUOTA,
    EVENT_TYPE_SMB_SET_QUOTA,

    EVENT_TYPE_SMB_LAST_EVENT
} SrvWmiEvents;

// WMI Dispatch routine
//
void
SrvWmiInitContext(
    PWORK_CONTEXT WorkContext
    );

void
SrvWmiStartContext(
    PWORK_CONTEXT   WorkContext
    );

void
SrvWmiEndContext(
    PWORK_CONTEXT   WorkContext
    );

void
SrvWmiTraceEvent(
    PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvWmiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

//
// FSD dispatch routine.
//

NTSTATUS
SrvFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// FSD I/O completion routine
//

NTSTATUS
SrvFsdIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// FSD TDI send completion routine
//

NTSTATUS
SrvFsdSendCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// FSD Oplock request completion routine
//

NTSTATUS
SrvFsdOplockCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// FSD transport Connect indication handler
//

NTSTATUS
SrvFsdTdiConnectHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

//
// FSD transport Disconnect indication handler
//

NTSTATUS
SrvFsdTdiDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

//
// FSD transport Receive indication handler
//

NTSTATUS
SrvFsdTdiReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

VOID
SrvPnpBindingHandler (
    IN TDI_PNP_OPCODE   PnpOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList
);

NTSTATUS
SrvPnpPowerHandler (
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PnPEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
);

//
// Routine to get a work item from the free list.  Wakes the resource
// thread if the list is getting empty.
//

PWORK_CONTEXT SRVFASTCALL
SrvFsdGetReceiveWorkItem (
    PWORK_QUEUE queue
    );

//
// If a workitem could not be allocated, SrvServiceWorkItemShortage() is called
// when the next workitem is freed
//
VOID SRVFASTCALL
SrvServiceWorkItemShortage (
    IN PWORK_CONTEXT WorkContext
    );

//
// If we have detected a DoS attack, the workitem will trigger a teardown
//
VOID SRVFASTCALL
SrvServiceDoSTearDown (
    IN PWORK_CONTEXT WorkContext
    );

//
// Routine to queue an EX work item to an EX worker thread.
//

#define SrvFsdQueueExWorkItem(_item,_running,_type) {   \
        if ( !*(_running) ) {                           \
            *(_running) = TRUE;                         \
            ObReferenceObject( SrvDeviceObject );      \
            ExQueueWorkItem( (_item), (_type) );        \
        }                                               \
    }

//
// SMB processing support routines.
//

VOID SRVFASTCALL
SrvFsdRequeueReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartSmbComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvFsdServiceNeedResourceQueue (
    IN PWORK_CONTEXT *WorkContext,
    IN PKIRQL OldIrql
    );

//
// SMB processing restart routines referenced by the FSP.
//

VOID SRVFASTCALL
SrvFsdRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartReadAndXCompressed (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
IpxRestartStartSendOnCorrectProcessor (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartLargeReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Resource shortage routines.
//

BOOLEAN
SrvAddToNeedResourceQueue (
    IN PCONNECTION Connection,
    IN RESOURCE_TYPE ResourceType,
    IN PRFCB Rfcb OPTIONAL
    );

VOID
SrvCheckForAndQueueDoS(
    PWORK_QUEUE queue
    );

//
// Send Completion Routines
//

NTSTATUS
SrvFsdRestartSmbAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvQueueWorkToFspAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvFsdRestartSendOplockIItoNone(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RequeueIpxWorkItemAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RestartCopyReadMpxComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RestartCopyReadRawResponse (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvpNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList);

#endif // ndef _SRVFSD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvfsp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvfsp.h

Abstract:

    This module defines main FSP routines for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVFSP_
#define _SRVFSP_

//#include <ntos.h>

//
// Configuration thread routine.  Processes requests from the server
// service.  Runs in an EX worker thread.
//

VOID
SrvConfigurationThread (
    IN PDEVICE_OBJECT pDevice,
    IN PIO_WORKITEM pWorkItem
    );

//
// Thread manager routines
//

NTSTATUS
SrvInitializeScavenger (
    VOID
    );

VOID
SrvResourceThread (
    IN PVOID Parameter
    );

VOID
SrvTerminateScavenger (
    VOID
    );

NTSTATUS
SrvCreateWorkerThreads (
    VOID
    );

VOID SRVFASTCALL
SrvTerminateWorkerThread (
    IN OUT PWORK_CONTEXT SpecialWorkItem
    );

VOID
SrvBalanceLoad (
    IN OUT PCONNECTION connection
    );

//
// Work queue functions.
//

VOID SRVFASTCALL
SrvQueueWorkToBlockingThread (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvQueueWorkToFsp (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// SrvQueueWorkToFspAtDpcLevel was once a different routine than
// SrvQueueWorkToFsp -- the latter routine called KeRaise/LowerIrql.
// With the advent of the kernel queue object, there is no longer a
// difference between the routines.  The calling code has not been
// changed in order to retain the knowledge about which callers can use
// the optimized call if there is ever again a difference between them.
//

#define SrvQueueWorkToFspAtDpcLevel SrvQueueWorkToFsp

#define QUEUE_WORK_TO_FSP(_work) {                  \
    (_work)->ProcessingCount++;                     \
    SrvInsertWorkQueueTail(                         \
        _work->CurrentWorkQueue,                    \
        (PQUEUEABLE_BLOCK_HEADER)(_work)            \
        );                                          \
}

//
// Routine in scavengr.c to store scavenger/alerter timeouts.
//

VOID
SrvCaptureScavengerTimeout (
    IN PLARGE_INTEGER ScavengerTimeout,
    IN PLARGE_INTEGER AlerterTimeout
    );

VOID
SrvUpdateStatisticsFromQueues (
    OUT PSRV_STATISTICS CapturedSrvStatistics OPTIONAL
    );

#endif // ndef _SRVFSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvdebug.h ===
#ifndef _SRVDEBUG_
#define _SRVDEBUG_

#ifdef MEMPRINT
#include <memprint.h>
#endif

//
// Debugging macros
//

#ifndef DBG
#define DBG 0
#endif

#if !DBG

#undef SRVDBG
#define SRVDBG 0
#undef SRVDBG2
#define SRVDBG2 0

#define SRVFASTCALL FASTCALL

#else

#ifndef SRVDBG
#define SRVDBG 0
#endif
#ifndef SRVDBG2
#define SRVDBG2 0
#endif

#define SRVFASTCALL

#endif

#ifndef SRVDBG_LIST
#define SRVDBG_LIST 0
#endif
#ifndef SRVDBG_LOCK
#define SRVDBG_LOCK 0
#endif
#ifndef SRVDBG_STATS
#define SRVDBG_STATS 0
#endif
#ifndef SRVDBG_STATS2
#define SRVDBG_STATS2 0
#endif
#ifndef SRVDBG_HANDLES
#define SRVDBG_HANDLES 0
#endif

#undef IF_DEBUG
#undef IF_SMB_DEBUG

#if 0
#define STATIC static
#else
#define STATIC
#endif

#define DEBUG_TRACE1              (ULONGLONG)0x0000000000000001
#define DEBUG_TRACE2              (ULONGLONG)0x0000000000000002
#define DEBUG_REFCNT              (ULONGLONG)0x0000000000000004
#define DEBUG_HEAP                (ULONGLONG)0x0000000000000008

#define DEBUG_WORKER1             (ULONGLONG)0x0000000000000010
#define DEBUG_WORKER2             (ULONGLONG)0x0000000000000020
#define DEBUG_NET1                (ULONGLONG)0x0000000000000040
#define DEBUG_NET2                (ULONGLONG)0x0000000000000080

#define DEBUG_FSP1                (ULONGLONG)0x0000000000000100
#define DEBUG_FSP2                (ULONGLONG)0x0000000000000200
#define DEBUG_FSD1                (ULONGLONG)0x0000000000000400
#define DEBUG_FSD2                (ULONGLONG)0x0000000000000800

#define DEBUG_SCAV1               (ULONGLONG)0x0000000000001000
#define DEBUG_SCAV2               (ULONGLONG)0x0000000000002000
#define DEBUG_BLOCK1              (ULONGLONG)0x0000000000004000
#define DEBUG_IPX_PIPES           (ULONGLONG)0x0000000000008000

#define DEBUG_HANDLES             (ULONGLONG)0x0000000000010000
#define DEBUG_IPX                 (ULONGLONG)0x0000000000020000
#define DEBUG_TDI                 (ULONGLONG)0x0000000000040000
#define DEBUG_OPLOCK              (ULONGLONG)0x0000000000080000

#define DEBUG_NETWORK_ERRORS      (ULONGLONG)0x0000000000100000
#define DEBUG_FILE_CACHE          (ULONGLONG)0x0000000000200000
#define DEBUG_IPX2                (ULONGLONG)0x0000000000400000
#define DEBUG_LOCKS               (ULONGLONG)0x0000000000800000

#define DEBUG_SEARCH              (ULONGLONG)0x0000000001000000
#define DEBUG_BRUTE_FORCE_REWIND  (ULONGLONG)0x0000000002000000
#define DEBUG_COMM                (ULONGLONG)0x0000000004000000
#define DEBUG_XACTSRV             (ULONGLONG)0x0000000008000000

#define DEBUG_API_ERRORS          (ULONGLONG)0x0000000010000000
#define DEBUG_STOP_ON_ERRORS      (ULONGLONG)0x0000000020000000 // If set, stop on internal errs
#define DEBUG_SMB_ERRORS          (ULONGLONG)0x0000000040000000
#define DEBUG_ERRORS              (ULONGLONG)0x0000000080000000

#define DEBUG_LICENSE             (ULONGLONG)0x0000000100000000
#define DEBUG_WORKITEMS           (ULONGLONG)0x0000000200000000
#define DEBUG_IPXNAMECLAIM        (ULONGLONG)0x0000000400000000

#define DEBUG_SENDS2OTHERCPU      (ULONGLONG)0x0000001000000000
#define DEBUG_REBALANCE           (ULONGLONG)0x0000002000000000
#define DEBUG_PNP                 (ULONGLONG)0x0000004000000000
#define DEBUG_SNAPSHOT            (ULONGLONG)0x0000008000000000

#define DEBUG_DFS                 (ULONGLONG)0x0000010000000000
#define DEBUG_SIPX                (ULONGLONG)0x0000020000000000
#define DEBUG_COMPRESSION         (ULONGLONG)0x0000040000000000
#define DEBUG_CREATE              (ULONGLONG)0x0000080000000000

#define DEBUG_SECSIG              (ULONGLONG)0x0000100000000000
#define DEBUG_STUCK_OPLOCK        (ULONGLONG)0x0000200000000000
#ifdef INCLUDE_SMB_PERSISTENT
#define DEBUG_PERSISTENT          (ULONGLONG)0x0000400000000000
#endif

//
// SMB debug flags.
//

#define DEBUG_SMB_ADMIN1          (ULONGLONG)0x0000000000000001
#define DEBUG_SMB_ADMIN2          (ULONGLONG)0x0000000000000002

#define DEBUG_SMB_TREE1           (ULONGLONG)0x0000000000000004
#define DEBUG_SMB_TREE2           (ULONGLONG)0x0000000000000008

#define DEBUG_SMB_DIRECTORY1      (ULONGLONG)0x0000000000000010
#define DEBUG_SMB_DIRECTORY2      (ULONGLONG)0x0000000000000020

#define DEBUG_SMB_OPEN_CLOSE1     (ULONGLONG)0x0000000000000040
#define DEBUG_SMB_OPEN_CLOSE2     (ULONGLONG)0x0000000000000080

#define DEBUG_SMB_FILE_CONTROL1   (ULONGLONG)0x0000000000000100
#define DEBUG_SMB_FILE_CONTROL2   (ULONGLONG)0x0000000000000200

#define DEBUG_SMB_READ_WRITE1     (ULONGLONG)0x0000000000000400
#define DEBUG_SMB_READ_WRITE2     (ULONGLONG)0x0000000000000800

#define DEBUG_SMB_LOCK1           (ULONGLONG)0x0000000000001000
#define DEBUG_SMB_LOCK2           (ULONGLONG)0x0000000000002000

#define DEBUG_SMB_RAW1            (ULONGLONG)0x0000000000004000
#define DEBUG_SMB_RAW2            (ULONGLONG)0x0000000000008000

#define DEBUG_SMB_MPX1            (ULONGLONG)0x0000000000010000
#define DEBUG_SMB_MPX2            (ULONGLONG)0x0000000000020000

#define DEBUG_SMB_SEARCH1         (ULONGLONG)0x0000000000040000
#define DEBUG_SMB_SEARCH2         (ULONGLONG)0x0000000000080000

#define DEBUG_SMB_TRANSACTION1    (ULONGLONG)0x0000000000100000
#define DEBUG_SMB_TRANSACTION2    (ULONGLONG)0x0000000000200000

#define DEBUG_SMB_PRINT1          (ULONGLONG)0x0000000000400000
#define DEBUG_SMB_PRINT2          (ULONGLONG)0x0000000000800000

#define DEBUG_SMB_MESSAGE1        (ULONGLONG)0x0000000001000000
#define DEBUG_SMB_MESSAGE2        (ULONGLONG)0x0000000002000000

#define DEBUG_SMB_MISC1           (ULONGLONG)0x0000000004000000
#define DEBUG_SMB_MISC2           (ULONGLONG)0x0000000008000000

#define DEBUG_SMB_QUERY_SET1      (ULONGLONG)0x0000000010000000
#define DEBUG_SMB_QUERY_SET2      (ULONGLONG)0x0000000020000000

#define DEBUG_SMB_TRACE           (ULONGLONG)0x0000000100000000

// Which WMI events should be built into the server?
#define BUILD_FLAGS (DEBUG_SMB_ERRORS | DEBUG_ERRORS | DEBUG_NETWORK_ERRORS | DEBUG_SNAPSHOT)
#define BUILD_FLAGS_SMB (0)

#define IF_DEBUG(flag) if (BUILD_FLAGS & DEBUG_ ## flag) \
                            if ( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( ERRORS ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )
#define IF_SMB_DEBUG(flag) if (BUILD_FLAGS_SMB & DEBUG_SMB_ ## flag) \
                            if ( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( ERRORS ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )

#define IF_STRESS() if( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( STRESS ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )

#if !SRVDBG

#define DEBUG if (FALSE)

#define SrvPrint0(fmt)  KdPrint((fmt))
#define SrvPrint1(fmt,v0) KdPrint((fmt,v0))
#define SrvPrint2(fmt,v0,v1) KdPrint((fmt,v0,v1))
#define SrvPrint3(fmt,v0,v1,v2) KdPrint((fmt,v0,v1,v2))
#define SrvPrint4(fmt,v0,v1,v2,v3) KdPrint((fmt,v0,v1,v2,v3))

#define SrvHPrint0(fmt)
#define SrvHPrint1(fmt,v0)
#define SrvHPrint2(fmt,v0,v1)
#define SrvHPrint3(fmt,v0,v1,v2)
#define SrvHPrint4(fmt,v0,v1,v2,v3)

#else

#define SrvHPrint0(fmt) DbgPrint( fmt )
#define SrvHPrint1(fmt,v0) DbgPrint( fmt, v0 )
#define SrvHPrint2(fmt,v0,v1) DbgPrint( fmt, v0, v1 )
#define SrvHPrint3(fmt,v0,v1,v2) DbgPrint( fmt, v0, v1, v2 )
#define SrvHPrint4(fmt,v0,v1,v2,v3) DbgPrint( fmt, v0, v1, v2, v3 )

#define DEBUG if (TRUE)

#define SrvPrint0(fmt) DbgPrint((fmt))
#define SrvPrint1(fmt,v0) DbgPrint((fmt),(v0))
#define SrvPrint2(fmt,v0,v1) DbgPrint((fmt),(v0),(v1))
#define SrvPrint3(fmt,v0,v1,v2) DbgPrint((fmt),(v0),(v1),(v2))
#define SrvPrint4(fmt,v0,v1,v2,v3) DbgPrint((fmt),(v0),(v1),(v2),(v3))

#define PRINT_LITERAL(literal) DbgPrint( #literal" = %lx\n", (literal) )


#endif // else !SRVDBG

//
// Macros for list debugging.  These verify that lists are good whenever
// a list operation is made.
//

#if SRVDBG_LIST || SRVDBG_LOCK
ULONG
SrvCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    );
#endif

#if !SRVDBG_LIST

#define SrvInsertHeadList(head,entry) InsertHeadList(head,entry)
#define SrvInsertTailList(head,entry) InsertTailList(head,entry)
#define SrvRemoveEntryList(head,entry) RemoveEntryList(entry)

#else // !SRVDBG_LIST

VOID
SrvIsEntryInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

VOID
SrvIsEntryNotInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

#define SrvInsertHeadList(head,entry)                        \
            (VOID)SrvCheckListIntegrity( head, 0xFFFFFFFF ); \
            SrvIsEntryNotInList(head,entry);                 \
            InsertHeadList(head,entry)

#define SrvInsertTailList(head,entry)                        \
            (VOID)SrvCheckListIntegrity( head, 0xFFFFFFFF ); \
            SrvIsEntryNotInList(head,entry);                 \
            InsertTailList(head,entry)

#define SrvRemoveEntryList(head,entry)                       \
            (VOID)SrvCheckListIntegrity( head, 0xFFFFFFFF ); \
            SrvIsEntryInList( head, entry );                 \
            RemoveEntryList(entry)

#endif // else !SRVDBG_LIST

//
// Macros for statistics arithmetics.
//

#if !SRVDBG_STATS
#define INCREMENT_DEBUG_STAT( _stat_ )
#define DECREMENT_DEBUG_STAT( _stat_ )
#else // !SRVDBG_STATS
#define INCREMENT_DEBUG_STAT( _stat_ ) (_stat_)++
#define DECREMENT_DEBUG_STAT( _stat_ ) (_stat_)--
#endif // else !SRVDBG_STATS
#if !SRVDBG_STATS2
#define INCREMENT_DEBUG_STAT2( _stat_ )
#define DECREMENT_DEBUG_STAT2( _stat_ )
#else // !SRVDBG_STATS2
#define INCREMENT_DEBUG_STAT2( _stat_ ) (_stat_)++
#define DECREMENT_DEBUG_STAT2( _stat_ ) (_stat_)--
#endif // else !SRVDBG_STATS2

//
// Macros for handle tracing.
//

#if !SRVDBG_HANDLES

#define SRVDBG_CLAIM_HANDLE(_a_,_b_,_c_,_d_)
#define SRVDBG_RELEASE_HANDLE(_a_,_b_,_c_,_d_)

#else

VOID
SrvdbgClaimOrReleaseHandle (
    IN HANDLE Handle,
    IN PSZ HandleType,
    IN ULONG Location,
    IN BOOLEAN Release,
    IN PVOID Data
    );
#define SRVDBG_CLAIM_HANDLE(_a_,_b_,_c_,_d_) SrvdbgClaimOrReleaseHandle((_a_),(_b_),(_c_),FALSE,(_d_))
#define SRVDBG_RELEASE_HANDLE(_a_,_b_,_c_,_d_) SrvdbgClaimOrReleaseHandle((_a_),(_b_),(_c_),TRUE,(_d_))

#endif

#if DBG
//
// Routine to write a server buffer to a log file
//
VOID
SrvLogBuffer( PCHAR msg, PVOID buf, ULONG len );
#endif

#endif // ndef _SRVDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvmacro.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvmacro.h

Abstract:

    This module defines miscellaneous macros for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 2-Mar-90

Revision History:

    19-Nov-1990 mannyw


--*/

#ifndef _SRVMACRO_
#define _SRVMACRO_

#include <limits.h>

//
// For WMI logging
//
extern TRACEHANDLE LoggerHandle;
extern ULONG SrvWmiEnableLevel;
extern ULONG SrvWmiEnableFlags;
#define WPP_GET_LOGGER LoggerHandle

#define SRV_WMI_LEVEL( LVL )  (SrvWmiEnableLevel >= SRV_WMI_LEVEL_ ## LVL )
#define SRV_WMI_FLAGON( FLG ) (SrvWmiEnableFlags & SRV_WMI_FLAG_ ## FLG )

#define SRV_WMI_LEVEL_ALWAYS 0
#define SRV_WMI_LEVEL_SPARSE 1
#define SRV_WMI_LEVEL_VERBOSE 2
#define SRV_WMI_LEVEL_COMPLETE 3


#define SRV_WMI_FLAG_CAPACITY 0x00000000  // Capacity Planning Instrumentation is on if no flag is specified
#define SRV_WMI_FLAG_ERRORS   0x00000001  // Error Tracking Instrumentation
#define SRV_WMI_FLAG_STRESS   0x00000002  // Tracking for IOStress Servers


//
// Simple MIN and MAX macros.  Watch out for side effects!
//

#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
#define MAX(a,b) ( ((a) < (b)) ? (b) : (a) )

#define RNDM_CONSTANT   314159269    /* default scrambling constant */
#define RNDM_PRIME     1000000007    /* prime number for scrambling  */

//
// Used for time conversions
//

#define AlmostTwoSeconds ((2*1000*1000*10)-1)

//
// Used for eventlog throttling
//
#define SRV_ONE_DAY ((LONGLONG)(10*1000*1000)*60*60*24)

//
// Width-agnostic inline to take the difference (in bytes) of two pointer
// values.
//

ULONG_PTR
__inline
PTR_DIFF_FULLPTR(
    IN PVOID Ptr1,
    IN PVOID Ptr2
    )
{
    ULONG_PTR difference;

    difference = (ULONG_PTR)Ptr1 - (ULONG_PTR)Ptr2;

    return difference;
}

ULONG
__inline
PTR_DIFF(
    IN PVOID Ptr1,
    IN PVOID Ptr2
    )
{
    ULONG_PTR difference;

    difference = (ULONG_PTR)Ptr1 - (ULONG_PTR)Ptr2;
    ASSERT( difference < ULONG_MAX );

    return (ULONG)difference;
}

USHORT
__inline
PTR_DIFF_SHORT(
    IN PVOID Ptr1,
    IN PVOID Ptr2
    )
{
    ULONG difference;

    difference = PTR_DIFF(Ptr1, Ptr2);
    ASSERT( difference < USHRT_MAX );

    return (USHORT)difference;
}

//
// Compute a string hash value that is invariant to case
//
#define COMPUTE_STRING_HASH( _pus, _phash ) {                \
    PWCHAR _p = (_pus)->Buffer;                              \
    PWCHAR _ep = _p + ((_pus)->Length/sizeof(WCHAR));        \
    ULONG _chHolder =0;                                      \
    DWORD _ch;                                               \
                                                             \
    while( _p < _ep ) {                                      \
        _ch = RtlUpcaseUnicodeChar( *_p++ );                 \
        _chHolder = 37 * _chHolder + (unsigned int) _ch ;    \
    }                                                        \
                                                             \
    *(_phash) = abs(RNDM_CONSTANT * _chHolder) % RNDM_PRIME; \
}

//
// Convert the output of one of the above hash functions to an index into
//  a hash table
//
#define HASH_TO_MFCB_INDEX( _hash )    ((_hash) % NMFCB_HASH_TABLE)

#define HASH_TO_SHARE_INDEX( _hash )   ((_hash) % NSHARE_HASH_TABLE)

//
// GET_SERVER_TIME retrieves the server's concept of the current system time.
//

#define GET_SERVER_TIME(_queue, a) (*(a) = (_queue)->stats.SystemTime)

//
// SET_SERVER_TIME updates the server's concept of the current system time.
//

#define SET_SERVER_TIME( _queue ) {         \
    LARGE_INTEGER currentTime;              \
    KeQueryTickCount( &currentTime );       \
    (_queue)->stats.SystemTime = currentTime.LowPart; \
}

//++
//
// NTSTATUS
// IMPERSONATE (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This macro calls NtSetInformationThread to impersonate a client.
//     This should be called before attempting any open on behalf of
//     a remote client.
//
// Arguments:
//
//     WorkContext - a pointer to a work context block.  It must have
//         a valid, referenced session pointer, from which the token
//         handle is obtained.
//
// Return Value:
//
//     None.
//
//--

#define IMPERSONATE( WorkContext ) SrvImpersonate( WorkContext )

//++
//
// VOID
// REVERT (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This macro calls NtSetInformationThread with a NULL token in order
//     to revert to a thread's original context.  This should be called
//     after the IMPERSONATE macro and an open attempt.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--

#define REVERT( ) SrvRevert( )

//
// Determine if the security handle has been initialized
//
#define IS_VALID_SECURITY_HANDLE( handle )  ((handle).dwLower || (handle).dwUpper )

//
// Mark this security handle invalid
//
#define INVALIDATE_SECURITY_HANDLE( handle ) (handle).dwLower = (handle).dwUpper = 0

//++
//
// VOID
// CHECK_FUNCTION_ACCESS (
//     IN ACCESS_MASK GrantedAccess,
//     IN UCHAR MajorFunction,
//     IN UCHAR MinorFunction,
//     IN ULONG IoControlCode,
//     OUT PNTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro calls IoCheckFunctionAccess the check the client's
//     access to an I/O function identified by major and minor function
//     codes.
//
//     *** This macro is here only because CHECK_FILE_INFORMATION_ACCESS
//         and CHECK_FS_INFORMATION_ACCESS are here.
//
// Arguments:
//
//     GrantedAccess - The access granted to the client for the target
//         target file object.
//
//     MajorFunction - The major function code of the requested
//         operation.
//
//     MinorFunction - The minor function code of the requested
//         operation.
//
//     IoControlCode - The control code for device or file system control.
//
//     Status - Indicates whether the client has the requested access.
//
// Return Value:
//
//     None.
//
//--

#define CHECK_FUNCTION_ACCESS( GrantedAccess, MajorFunction, MinorFunction, \
                               IoControlCode, Status ) {                    \
            *(Status) = IoCheckFunctionAccess(                              \
                            (GrantedAccess),                                \
                            (MajorFunction),                                \
                            (MinorFunction),                                \
                            IoControlCode,                                  \
                            NULL,                                           \
                            NULL                                            \
                            );                                              \
        }

//++
//
// VOID
// CHECK_PAGING_IO_ACCESS (
//     IN PWORK_CONTEXT WorkContext
//     IN ACCESS_MASK GrantedAccess,
//     OUT PNTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro checks to see if the client opened the file for execute.
//     If so, then we allow the redirector to read the file.  If this is
//     an NT redirector, it must set the FLAGS2_PAGING_IO bit for access
//     to be allowed.
//
// Arguments:
//
//     GrantedAccess - The access granted to the client for the target
//         target file object.
//
//     WorkContext - A pointer to a work context block.
//
//     Status - Indicates whether the client has the requested access.
//
// Return Value:
//
//     None.
//
//--

#define CHECK_PAGING_IO_ACCESS( WorkContext, GrantedAccess, Status ) {           \
                                                                            \
            if ( ((GrantedAccess) & FILE_EXECUTE) &&                        \
                 ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) || \
                   WorkContext->RequestHeader->Flags2 &                     \
                       SMB_FLAGS2_PAGING_IO ) ) {                           \
                *Status = STATUS_SUCCESS;                                   \
            } else {                                                        \
                *Status = STATUS_ACCESS_DENIED;                             \
            }                                                               \
        }

//++
//
// VOID
// CHECK_FILE_INFORMATION_ACCESS (
//     IN ACCESS_MASK GrantedAccess,
//     IN UCHAR MajorFunction,
//     IN FILE_INFORMATION_CLASS FileInformationClass
//     OUT PNTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro calls IoCheckFunctionAccess the check the client's
//     access to a query or set file information function identified by
//     major function code and information class.
//
//     *** This macro is here because IoCheckFunctionAccess takes an
//         OPTIONAL FileInformationClass argument; this is argument is
//         therefore passed by reference.  Rather than force the caller
//         to allocate local storage so that it can pass a constant by
//         reference, we do it in the macro.
//
// Arguments:
//
//     GrantedAccess - The access granted to the client for the target
//         target file object.
//
//     MajorFunction - The major function code of the requested
//         operation.
//
//     FileInformationClass - The type of file information being queried
//         or set.
//
//     Status - Indicates whether the client has the requested access.
//
// Return Value:
//
//     None.
//
//--

#define CHECK_FILE_INFORMATION_ACCESS( GrantedAccess, MajorFunction,        \
                                        FileInformationClass, Status ) {    \
            FILE_INFORMATION_CLASS fileInfoClass = FileInformationClass;    \
            *(Status) = IoCheckFunctionAccess(                              \
                            (GrantedAccess),                                \
                            (MajorFunction),                                \
                            0,                                              \
                            0,                                              \
                            &fileInfoClass,                                 \
                            NULL                                            \
                            );                                              \
        }

//++
//
// PCHAR
// END_OF_REQUEST_SMB (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This routine returns the address of the last valid location in
//     the request SMB associated with the specified work context
//     block.
//
// Arguments:
//
//     WorkContext - Pointer to the work context block that owns the
//         request SMB.
//
// Return Value:
//
//     PCHAR - Address of the last valid location in the request SMB.
//
//--

#define END_OF_REQUEST_SMB( WorkContext )                       \
            ( (PCHAR)( (WorkContext)->RequestBuffer->Buffer ) + \
                (WorkContext)->RequestBuffer->DataLength - 1 )

//++
//
// PCHAR
// END_OF_TRANSACTION_PARAMETERS (
//     IN PTRANSACTION Transaction
//     )
//
// Routine Description:
//
//     This routine returns the address of the last valid location in
//     the InParameters buffer of the transaction block.
//
// Arguments:
//
//     Transaction - a pointer to the transaction block to check.
//
// Return Value:
//
//     PCHAR - Address of the last valid location in the InParameters
//         buffer of the transaction.
//
//--

#define END_OF_TRANSACTION_PARAMETERS( Transaction )   \
            ( (PCHAR)( (Transaction)->InParameters ) + \
                (Transaction)->ParameterCount - 1 )

//++
//
// VOID
// INTERNAL_ERROR (
//     IN ULONG ErrorLevel,
//     IN PSZ Message,
//     IN PVOID Arg1 OPTIONAL,
//     IN PVOID Arg2 OPTIONAL
//     )
//
// Routine Description:
//
//     This routine handles logging of a server internal error.
//
//     *** This macro must be usable in the FSD, at DPC level.
//
// Arguments:
//
//     ErrorLevel - The severity of the error
//
//     Message    - An error message string in DbgPrint() format
//
//     Arg1       - Argument 1 for the error message
//
//     Arg2       - Argument 2 for the error message
//
//--

#define INTERNAL_ERROR( _level, _msg, _arg1, _arg2 ) {          \
    IF_DEBUG(ERRORS) {                                          \
        DbgPrint( (_msg), (_arg1), (_arg2) );                  \
        DbgPrint( "\n" );                                      \
        if ( (_level) >= ERROR_LEVEL_UNEXPECTED ) {             \
            IF_DEBUG(STOP_ON_ERRORS) {                          \
                DbgBreakPoint();                                \
            }                                                   \
        }                                                       \
    }                                                           \
    if ( (_level) == ERROR_LEVEL_EXPECTED ) {                   \
        ;                                                       \
    } else if ( (_level) == ERROR_LEVEL_UNEXPECTED ) {          \
        SrvStatistics.SystemErrors++;                           \
    } else {                                                    \
        ASSERT( (_level) > ERROR_LEVEL_UNEXPECTED );            \
        KeBugCheckEx(                                           \
            LM_SERVER_INTERNAL_ERROR,                           \
            BugCheckFileId | __LINE__,                          \
            (ULONG_PTR)(_arg1),                                 \
            (ULONG_PTR)(_arg2),                                 \
            0                                                   \
            );                                                  \
    }                                                           \
}

#define SRV_FILE_ACCESS     0x00010000
#define SRV_FILE_BLKCOMM    0x00020000
#define SRV_FILE_BLKCONN    0x00030000
#define SRV_FILE_BLKDEBUG   0x00040000
#define SRV_FILE_BLKENDP    0x00050000
#define SRV_FILE_BLKFILE    0x00060000
#define SRV_FILE_BLKSESS    0x00070000
#define SRV_FILE_BLKSHARE   0x00080000
#define SRV_FILE_BLKSRCH    0x00090000
#define SRV_FILE_BLKTABLE   0x000A0000
#define SRV_FILE_BLKTRANS   0x000B0000
#define SRV_FILE_BLKTREE    0x000C0000
#define SRV_FILE_BLKWORK    0x000D0000
#define SRV_FILE_COPY       0x000E0000
#define SRV_FILE_EA         0x000F0000
#define SRV_FILE_ERRORLOG   0x00100000
#define SRV_FILE_FSD        0x00110000
#define SRV_FILE_FSDDISP    0x00120000
#define SRV_FILE_FSDRAW     0x00130000
#define SRV_FILE_FSDSMB     0x00140000
#define SRV_FILE_FSPINIT    0x00150000
#define SRV_FILE_HEAPMGR    0x00160000
#define SRV_FILE_INFO       0x00170000
#define SRV_FILE_IPX        0x00180000
#define SRV_FILE_IO         0x00190000
#define SRV_FILE_LOCK       0x001A0000
#define SRV_FILE_LOCKCODE   0x001B0000
#define SRV_FILE_MOVE       0x001C0000
#define SRV_FILE_NETWORK    0x001D0000
#define SRV_FILE_OPEN       0x001E0000
#define SRV_FILE_OPLOCK     0x001F0000
#define SRV_FILE_PIPE       0x00200000
#define SRV_FILE_PRNSUPP    0x00210000
#define SRV_FILE_SCAVENGR   0x00220000
#define SRV_FILE_SHARE      0x00230000
#define SRV_FILE_SLMCHECK   0x00240000
#define SRV_FILE_SMBADMIN   0x00250000
#define SRV_FILE_SMBATTR    0x00260000
#define SRV_FILE_SMBCLOSE   0x00270000
#define SRV_FILE_SMBDIR     0x00280000
#define SRV_FILE_SMBFILE    0x00290000
#define SRV_FILE_SMBFIND    0x002A0000
#define SRV_FILE_SMBIOCTL   0x002B0000
#define SRV_FILE_SMBLOCK    0x002C0000
#define SRV_FILE_SMBMISC    0x002D0000
#define SRV_FILE_SMBMPX     0x002E0000
#define SRV_FILE_SMBNOTFY   0x002F0000
#define SRV_FILE_SMBOPEN    0x00300000
#define SRV_FILE_SMBPRINT   0x00310000
#define SRV_FILE_SMBPROC    0x00320000
#define SRV_FILE_SMBRAW     0x00330000
#define SRV_FILE_SMBRDWRT   0x00340000
#define SRV_FILE_SMBSRCH    0x00350000
#define SRV_FILE_SMBSUPP    0x00360000
#define SRV_FILE_SMBTRANS   0x00370000
#define SRV_FILE_SMBTREE    0x00380000
#define SRV_FILE_SRVCONFG   0x00390000
#define SRV_FILE_SRVDATA    0x003A0000
#define SRV_FILE_SRVSTAT    0x003B0000
#define SRV_FILE_SRVSTRNG   0x003C0000
#define SRV_FILE_SVCCDEV    0x003D0000
#define SRV_FILE_SVCCDEVQ   0x003E0000
#define SRV_FILE_SVCCONN    0x003F0000
#define SRV_FILE_SVCFILE    0x00400000
#define SRV_FILE_SVCSESS    0x00410000
#define SRV_FILE_SVCSHARE   0x00420000
#define SRV_FILE_SVCSRV     0x00430000
#define SRV_FILE_SVCSTATS   0x00440000
#define SRV_FILE_SVCSUPP    0x00450000
#define SRV_FILE_SVCXPORT   0x00460000
#define SRV_FILE_WORKER     0x00470000
#define SRV_FILE_XSSUPP     0x00480000
#define SRV_FILE_BLKDIR     0x00490000
#define SRV_FILE_DFS        0x004A0000
#ifdef INCLUDE_SMB_PERSISTENT
#define SRV_FILE_BLKLOCK    0x004B0000
#endif

//
// Error levels used with INTERNAL_ERROR
//

#define ERROR_LEVEL_EXPECTED    0
#define ERROR_LEVEL_UNEXPECTED  1
#define ERROR_LEVEL_IMPOSSIBLE  2
#define ERROR_LEVEL_FATAL       3


//
// Helper macros for dealing with unqiue identifiers (UID, PID, TID,
// FID, SID).  In these macros, id, index, and sequence should all be
// USHORTs.
//

#define TID_INDEX(id) (USHORT)( (id) & 0x07FF )
#define TID_SEQUENCE(id) (USHORT)( (id) >> 11 )
#define MAKE_TID(index, sequence) (USHORT)( ((sequence) << 11) | (index) )
#define INCREMENT_TID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x1F);

#define UID_INDEX(id) (USHORT)( (id) & 0x07FF )
#define UID_SEQUENCE(id) (USHORT)( (id) >> 11 )
#define MAKE_UID(index, sequence) (USHORT)(( (sequence) << 11) | (index) )
#define INCREMENT_UID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x1F);

#define FID_INDEX(id) (USHORT)( (id) & 0x03FFF )
#define FID_SEQUENCE(id) (USHORT)( (id) >> 14 )
#define MAKE_FID(index, sequence) (USHORT)( ((sequence) << 14) | (index) )
#define INCREMENT_FID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x3);

//
// *** Note that the macros relating to search IDs are somewhat
//     different from those for other kinds of IDs.  The SID is stored
//     in a Resume Key (see smb.h for its definition), in discontiguous
//     fields.  The macros for getting the SID therefore take a pointer
//     to a resume key.
//

#define SID_INDEX(ResumeKey)                                                 \
            (USHORT)( ( ((ResumeKey)->Reserved & 0x7) << 8 ) |               \
                      (ResumeKey)->Sid )
#define SID_SEQUENCE(ResumeKey)                                              \
            (USHORT)( ((ResumeKey)->Reserved & 0x18) >> 3 )
#define SID(ResumeKey)                                                       \
            (USHORT)( ( ((ResumeKey)->Reserved & 0x1F) << 8 ) |              \
                      (ResumeKey)->Sid )
#define INCREMENT_SID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x3);
#define SET_RESUME_KEY_SEQUENCE(ResumeKey,Sequence) {                       \
            (ResumeKey)->Reserved &= ~0x18;                                 \
            (ResumeKey)->Reserved |= (Sequence) << 3;                       \
        }
#define SET_RESUME_KEY_INDEX(ResumeKey,Index) {                             \
            (ResumeKey)->Reserved = (UCHAR)( (ULONG)(Index) >> 8 );         \
            (ResumeKey)->Reserved &= (UCHAR)0x7;                            \
            (ResumeKey)->Sid = (UCHAR)( (Index) & (USHORT)0xFF );           \
        }

//
// The following SID macros are used in the same way as the macros for
// other IDs (see above, TID, FID, UID).  The Find2 protocols (Transaction2)
// use a USHORT as a SID, rather than various fields in a resume key.
//

#define SID_INDEX2(Sid)                                                      \
            (USHORT)( (Sid) & 0x7FF )
#define SID_SEQUENCE2(Sid)                                                   \
            (USHORT)( ((Sid) & 0x1800) >> 11 )
#define MAKE_SID(Index,Sequence)                                             \
            (USHORT)( ((Sequence) << 11) | (Index) )

//
// InitializeObjectAttributes, with security.
//

#define SrvInitializeObjectAttributes(ObjectAttributes,p1,p2,p3,p4)   \
            InitializeObjectAttributes(ObjectAttributes,p1,p2,p3,p4); \
            (ObjectAttributes)->SecurityQualityOfService = (PVOID)&SrvSecurityQOS;

#define SrvInitializeObjectAttributes_U(ObjectAttributes,p1,p2,p3,p4)   \
            InitializeObjectAttributes(ObjectAttributes,p1,p2,p3,p4); \
            (ObjectAttributes)->SecurityQualityOfService = (PVOID)&SrvSecurityQOS;


//
// Macro used to map from NT attributes to SMB attributes.  The output is placed
//   in *_SmbAttributes
//
#define SRV_NT_ATTRIBUTES_TO_SMB( _NtAttributes, _Directory, _SmbAttributes ) {\
    *(_SmbAttributes) = (USHORT)( (_NtAttributes) &             \
                            ( FILE_ATTRIBUTE_READONLY |         \
                              FILE_ATTRIBUTE_HIDDEN   |         \
                              FILE_ATTRIBUTE_SYSTEM   |         \
                              FILE_ATTRIBUTE_ARCHIVE  |         \
                              FILE_ATTRIBUTE_DIRECTORY )) ;     \
    if ( _Directory ) {                                         \
        *(_SmbAttributes) |= SMB_FILE_ATTRIBUTE_DIRECTORY;      \
    }                                                           \
}


//    This macro converts attributes from SMB format to NT format.
//
//   The attribute bits in the SMB protocol (same as OS/2) have the
//    following meanings:
//
//      bit 0 - read only file
//      bit 1 - hidden file
//      bit 2 - system file
//      bit 3 - reserved
//      bit 4 - directory
//      bit 5 - archive file
//
//    NT file attributes are similar, but have a bit set for a "normal"
//    file (no other bits set) and do not have a bit set for directories.
//    Instead, directory information is passed to and from APIs as a
//    BOOLEAN parameter.

#define SRV_SMB_ATTRIBUTES_TO_NT( _SmbAttributes, _Directory, _NtAttributes ) {\
    ULONG _attr = (_SmbAttributes);                                     \
    *(_NtAttributes) = _attr &                                          \
                            ( SMB_FILE_ATTRIBUTE_READONLY |             \
                              SMB_FILE_ATTRIBUTE_HIDDEN   |             \
                              SMB_FILE_ATTRIBUTE_SYSTEM   |             \
                              SMB_FILE_ATTRIBUTE_ARCHIVE  |             \
                              SMB_FILE_ATTRIBUTE_DIRECTORY );           \
    if ( _attr == 0 ) {                                                 \
        *(_NtAttributes) = FILE_ATTRIBUTE_NORMAL;                       \
    }                                                                   \
    if( _Directory ) {                                                  \
        if ( (_attr & SMB_FILE_ATTRIBUTE_DIRECTORY) != 0 ) {            \
            *(PBOOLEAN)(_Directory) = TRUE;                             \
        } else {                                                        \
            *(PBOOLEAN)(_Directory) = FALSE;                            \
        }                                                               \
    }                                                                   \
}

//
// ULONG
// MAP_SMB_INFO_TYPE_TO_NT (
//     IN PULONG Map,
//     IN ULONG SmbInformationLevel
//     )
//
// Routine description:
//
//     This macro maps SMB_INFO level to Nt info level.
//
// Arguments:
//
//     Map - An array of ULONGS.  The first ulong is the base SMB info level
//          the seconds through Nth are NT mappings of the corresponding
//          SMB info levels.
//
//     Level - The SMB info level to map.
//
// Return Value:
//
//     NtInfoLevel - The NT info level.
//

#define MAP_SMB_INFO_TYPE_TO_NT( Map, Level )   Map[Level - Map[0] + 1]

//
// ULONG
// MAP_SMB_INFO_TO_MIN_NT_SIZE (
//     IN PULONG Map,
//     IN ULONG SmbINformationLevel
//     )
//
// Routine Description:
//
//  This macro maps SMB_INFO level to the minimum buffer size needed to make the
//    NtQueryInformationFile call
//
// Arguments:
//     Map - An array of ULONGS.  The first ulong is the base SMB info level,
//          the second is the NT info level, and the third through Nth are the
//          NT mapings for the sizes of the NT info levels.
//
//     Level - The SMB info level to find the buffer size
//
// Return Value:
//
//    NtMinumumBufferSIze - the minumum buffer size for the request

#define MAP_SMB_INFO_TO_MIN_NT_SIZE( Map, Level )  Map[ Level - Map[0] + 2]

//
// BOOLEAN
// SMB_IS_UNICODE(
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine description:
//
//     This macro discovers whether or not an SMB contains Unicode
//     ANSI strings.
//
// Arguments:
//
//     WorkContext - A pointer to the active work context
//
// Return Value:
//
//     TRUE - The SMB strings are unicode.
//     FALSE - The SMB strings are ANSI.
//

#define SMB_IS_UNICODE( WorkContext )  \
            (BOOLEAN)( ((WorkContext)->RequestHeader->Flags2 & SMB_FLAGS2_UNICODE ) != 0 )

//
// BOOLEAN
// SMB_CONTAINS_DFS_NAME(
//      IN PWORK_CONTEXT WorkContext
//      )
//
// Routine description:
//
//      This macro discovers whether or not an SMB contains a pathname
//      referring to the DFS namespace.
//
// Arguments:
//
//      WorkContext - A pointer to the active work context
//
// Return Value:
//
//      TRUE  - The SMB has a DFS name in it
//      FALSE - The SMB does not have a DFS name in it
//

#define SMB_CONTAINS_DFS_NAME( WorkContext ) \
            (BOOLEAN)( ((WorkContext)->RequestHeader->Flags2 & SMB_FLAGS2_DFS ) != 0 )

//
// BOOLEAN
// SMB_MARK_AS_DFS_NAME(
//      IN PWORK_CONTEXT WorkContext
//      )
//
// Routine description:
//
//      This macro marks the WorkContext as containing a Dfs name. This is
//      used when processing SMBs that contain two path names; after the first
//      path name has been canonicalized, the SMB is marked as being
//      Dfs-Translated by SrvCanonicalizePathName, so the attempt to
//      canonicalize the second path in the SMB will fail to do the
//      Dfs translation. Calling this macro will ensure that the next call
//      to SrvCanonicalizePathName will go through Dfs translation
//
// Arguments:
//
//      WorkContext - A pointer to the active work context
//
// Return Value:
//
//      None
//

#define SMB_MARK_AS_DFS_NAME( WorkContext ) \
        (WorkContext)->RequestHeader->Flags2 |= SMB_FLAGS2_DFS

//
// BOOLEAN
// SMB_MARK_AS_DFS_TRANSLATED(
//      IN PWORK_CONTEXT WorkContext
//      )
//
// Routine description:
//
//      This macro marks the WorkContext as having been through a Dfs
//      translation for the express purpose of preventing a second attempt
//      at Dfs translation on the translated name.
//
// Arguments:
//
//      WorkContext - A pointer to the active work context
//
// Return Value:
//
//      None
//

#define SMB_MARK_AS_DFS_TRANSLATED( WorkContext ) \
        (WorkContext)->RequestHeader->Flags2 &= (~SMB_FLAGS2_DFS)

//
// BOOLEAN
// CLIENT_CAPABLE_OF(
//     IN ULONG Capability,
//     IN PCONNECTION Connection
//     )
//
// Routine description:
//
//     This macro discovers whether or not a client is supports a
//     certain capability.
//
//     *Warning* This macro assumes that only one capability is being tested.
//
// Arguments:
//
//     Connection - A pointer to the active connection
//
// Return Value:
//
//     TRUE - Capability supported.
//     FALSE - otherwise.
//

#define CLIENT_CAPABLE_OF( Capability, Connection ) \
            (BOOLEAN) ( ((Connection)->ClientCapabilities & (CAP_ ## Capability)) != 0 )

//
// BOOLEAN
// SMB_IS_PIPE_PREFIX(
//     IN PWORK_CONTEXT WorkContext
//     IN PVOID Name
//     )
//
// Routine description:
//
//     This macro discovers whether or not a path prefix is named pipe prefix
//     for a transaction SMB.
//
// Arguments:
//
//     WorkContext - A pointer to the active work context
//     Name - A pointer to a name string.  This may be ANSI or Unicode
//
// Return Value:
//
//     TRUE - The name is a pipe prefix.
//     FALSE - The name is not a pipe prefix.
//

#define SMB_NAME_IS_PIPE_PREFIX( WorkContext, Name )                    \
                                                                        \
       ( ( !SMB_IS_UNICODE( WorkContext ) &&                            \
           strnicmp(                                                    \
                (PCHAR)Name,                                            \
                SMB_PIPE_PREFIX,                                        \
                SMB_PIPE_PREFIX_LENGTH                                  \
                ) == 0                                                  \
         )                                                              \
        ||                                                              \
         ( SMB_IS_UNICODE( WorkContext ) &&                             \
           wcsnicmp(                                                    \
                (PWCH)Name,                                             \
                UNICODE_SMB_PIPE_PREFIX,                                \
                UNICODE_SMB_PIPE_PREFIX_LENGTH / sizeof(WCHAR)          \
                ) == 0                                                  \
         )                                                              \
       )

//
// BOOLEAN
// SMB_IS_PIPE_API(
//     IN PWORK_CONTEXT WorkContext
//     IN PVOID Name
//     )
//
// Routine description:
//
//     This macro discovers whether or not a transaction name indicates
//     that the transaction is for a LM remote API request.
//
// Arguments:
//
//     WorkContext - A pointer to the active work context
//     Name - A pointer to a name string.  This may be ANSI or Unicode
//
// Return Value:
//
//     TRUE - The name is a remote API request.
//     FALSE - The name is not a remote API request.
//

#define SMB_NAME_IS_PIPE_API( WorkContext, Name )                       \
                                                                        \
       ( ( !SMB_IS_UNICODE( WorkContext ) &&                            \
           stricmp(                                                     \
                (PCHAR)Name,                                            \
                StrPipeApiOem                                           \
                ) == 0                                                  \
         )                                                              \
                        ||                                              \
         ( SMB_IS_UNICODE( WorkContext ) &&                             \
           wcsicmp(                                                     \
                (PWCH)Name,                                             \
                StrPipeApi                                              \
                ) == 0                                                  \
         )                                                              \
       )

//
// VOID
// SrvReferenceConnection (
//     PCONNECTION Connection
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a connection block.
//
//     !!! Users of this macro must be nonpageable.
//
// Arguments:
//
//     Connection - Address of connection
//
// Return Value:
//
//     None.
//

#define SrvReferenceConnection( _conn_ )    {                           \
            ASSERT( GET_BLOCK_TYPE(_conn_) ==                           \
                                    BlockTypeConnection );              \
            UPDATE_REFERENCE_HISTORY( (_conn_), FALSE );                \
            (VOID) ExInterlockedAddUlong(                               \
                        &(_conn_)->BlockHeader.ReferenceCount,          \
                        1,                                              \
                        (_conn_)->EndpointSpinLock                      \
                        );                                              \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                "Referencing connection %lx; new refcnt %lx\n",         \
                (_conn_), (_conn_)->BlockHeader.ReferenceCount);        \
            }                                                           \
        }

//
// VOID
// SrvReferenceConnectionLocked (
//     PCONNECTION Connection
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a connection block.
//     Invokers of this macro must hold the SrvFsdSpinLock.
//
// Arguments:
//
//     Connection - Address of connection
//
// Return Value:
//
//     None.
//

#define SrvReferenceConnectionLocked( _conn_ )    {                     \
            ASSERT( GET_BLOCK_TYPE(_conn_) ==                           \
                                    BlockTypeConnection );              \
            UPDATE_REFERENCE_HISTORY( (_conn_), FALSE );                \
            (_conn_)->BlockHeader.ReferenceCount++;                     \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing connection %lx; new refcnt %lx\n",     \
                    (_conn_), (_conn_)->BlockHeader.ReferenceCount );   \
            }                                                           \
        }

//
// VOID
// SrvReferenceSession (
//     PSESSION Session
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a session block.
//
// Arguments:
//
//     Session - Address of session
//
// Return Value:
//
//     None.
//

#define SrvReferenceSession( _sess_ )    {                              \
            ASSERT( (_sess_)->NonpagedHeader->ReferenceCount > 0 );     \
            ASSERT( GET_BLOCK_TYPE(_sess_) == BlockTypeSession );       \
            UPDATE_REFERENCE_HISTORY( (_sess_), FALSE );                \
            InterlockedIncrement(                                       \
                &(_sess_)->NonpagedHeader->ReferenceCount               \
                );                                                      \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing session %lx; new refcnt %lx\n",        \
                  (_sess_), (_sess_)->NonpagedHeader->ReferenceCount ); \
            }                                                           \
        }

//
// VOID
// SrvReferenceTransaction (
//     PTRANSACTION Transaction
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a transaction block.
//
// Arguments:
//
//     Transaction - Address of transaction
//
// Return Value:
//
//     None.
//

#define SrvReferenceTransaction( _trans_ )    {                         \
            ASSERT( (_trans_)->NonpagedHeader->ReferenceCount > 0 );    \
            ASSERT( GET_BLOCK_TYPE(_trans_) == BlockTypeTransaction );  \
            UPDATE_REFERENCE_HISTORY( (_trans_), FALSE );               \
            InterlockedIncrement(                                       \
                &(_trans_)->NonpagedHeader->ReferenceCount              \
                );                                                      \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing transaction %lx; new refcnt %lx\n",    \
                (_trans_), (_trans_)->NonpagedHeader->ReferenceCount ); \
            }                                                           \
        }

//
// VOID
// SrvReferenceTreeConnect (
//     PTREE_CONNECT TreeConnect
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a tree connect block.
//     Invokers of this macro must hold TreeConnect->Connection->Lock.
//
// Arguments:
//
//     TreeConnect - Address of tree connect
//
// Return Value:
//
//     None.
//

#define SrvReferenceTreeConnect( _tree_ )    {                          \
            ASSERT( (_tree_)->NonpagedHeader->ReferenceCount > 0 );     \
            ASSERT( GET_BLOCK_TYPE(_tree_) == BlockTypeTreeConnect );   \
            UPDATE_REFERENCE_HISTORY( (_tree_), FALSE );                \
            InterlockedIncrement(                                       \
                &(_tree_)->NonpagedHeader->ReferenceCount               \
                );                                                      \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing tree connect %lx; new refcnt %lx\n",   \
                  (_tree_), (_tree_)->NonpagedHeader->ReferenceCount ); \
            }                                                           \
        }

//
// VOID
// SrvReferenceWorkItem (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This function increments the reference count of a work context block.
//     Invokers of this macro must hold WorkContext->SpinLock.
//
// Arguments:
//
//     WORK_CONTEXT - Pointer to the work context block to reference.
//
// Return Value:
//
//     None.
//

#define SrvReferenceWorkItem( _wc_ ) {                                      \
        ASSERT( (LONG)(_wc_)->BlockHeader.ReferenceCount >= 0 );            \
        ASSERT( (GET_BLOCK_TYPE(_wc_) == BlockTypeWorkContextInitial) ||    \
                (GET_BLOCK_TYPE(_wc_) == BlockTypeWorkContextNormal) ||     \
                (GET_BLOCK_TYPE(_wc_) == BlockTypeWorkContextRaw) );        \
        UPDATE_REFERENCE_HISTORY( (_wc_), FALSE );                          \
        (_wc_)->BlockHeader.ReferenceCount++;                               \
        IF_DEBUG(REFCNT) {                                                  \
            SrvHPrint2(                                                      \
              "Referencing WorkContext 0x%lx; new refcnt 0x%lx\n",          \
              (_wc_), (_wc_)->BlockHeader.ReferenceCount );                 \
        }                                                                   \
    }

//
// VOID
// SRV_START_SEND (
//     IN OUT PWORK_CONTEXT WorkContext,
//     IN PMDL Mdl OPTIONAL,
//     IN ULONG SendOptions,
//     IN PRESTART_ROUTINE FsdRestartRoutine,
//     IN PRESTART_ROUTINE FspRestartRoutine
//     )
//
// Routine Description:
//
//     This macro calls the SrvStartSend routine.  It sets the fsd and
//     fsp restart routines before calling it.
//
// Arguments:
//
//     WorkContext - Supplies a pointer to a Work Context block.
//
//     Mdl - Supplies a pointer to the first (or only) MDL describing the
//         data that is to be sent.
//
//     SendOptions - Supplied TDI send options.
//
//     FsdRestartRoutine - Supplies the address of the FSD routine that is
//         to be called when the I/O completes.  (Often, this is
//         SrvQueueWorkToFspAtDpcLevel.)
//
//     FspRestartRoutine - Supplies the address of the FSP routine that is
//         to be called when the FSD queues the work item to the FSP.
//

#define SRV_START_SEND( _wc, _mdl, _opt, _compl, _fsdRestart, _fspRestart ) { \
        ASSERT( !(_wc)->Endpoint->IsConnectionless );                 \
        if ( (_fspRestart) != NULL ) {                                \
            (_wc)->FspRestartRoutine = (_fspRestart);                 \
        }                                                             \
        if ( (_fsdRestart) != NULL ) {                                \
            (_wc)->FsdRestartRoutine = (_fsdRestart);                 \
        }                                                             \
        SrvStartSend( (_wc), (_compl), (_mdl), (_opt) );              \
    }

#define SRV_START_SEND_2( _wc, _compl, _fsdRestart, _fspRestart ) {   \
        (_wc)->ResponseBuffer->Mdl->ByteCount =                       \
                            (_wc)->ResponseBuffer->DataLength;        \
        if ( (_fspRestart) != NULL ) {                                \
            (_wc)->FspRestartRoutine = (_fspRestart);                 \
        }                                                             \
        if ( (_fsdRestart) != NULL ) {                                \
            (_wc)->FsdRestartRoutine = (_fsdRestart);                 \
        }                                                             \
        if ( !(_wc)->Endpoint->IsConnectionless ) {                   \
            SrvStartSend2( (_wc), (_compl) );                         \
        } else {                                                      \
            SrvIpxStartSend( (_wc), (_compl) );                       \
        }                                                             \
    }

//
// VOID
// SrvUpdateErrorCount(
//     PSRV_ERROR_RECORD ErrorRecord,
//     BOOLEAN IsError
//     )
// /*++
//
// Routine Description:
//
//     This routine updates the server's record of successful / unsuccesful
//     operations.
//
// Arguments:
//
//     IsError - TRUE - A server error occured
//               FALSE - A server operation was attempted
//
// Return Value:
//
//    None.
//

#if 0
#define SrvUpdateErrorCount( ErrorRecord, IsError )                     \
        if ( IsError ) {                                                \
            (ErrorRecord)->FailedOperations++;                          \
        } else {                                                        \
            (ErrorRecord)->SuccessfulOperations++;                      \
        }
#else
#define SrvUpdateErrorCount( ErrorRecord, IsError )
#endif

//
// VOID
// SrvUpdateStatistics (
//     PWORK_CONTEXT WorkContext,
//     ULONG BytesSent,
//     UCHAR SmbCommand
//     )
//
// Routine Description:
//
//     Macro to update the server statistics database to reflect the
//     work item that is being completed.
//
// Arguments:
//
//     WorkContext - Pointer to the workcontext block containing
//         the statistics for this request.
//
//     BytesSent - Supplies a count of the number of bytes of response data
//         sent as a result of the current SMB.
//
//     SmbCommand - The SMB command code of the current operation.
//
//
// Return Value:
//
//    None.
//

#if SRVDBG_STATS
VOID SRVFASTCALL
SrvUpdateStatistics2 (
    PWORK_CONTEXT WorkContext,
    UCHAR SmbCommand
    );
#define UPDATE_STATISTICS2(_work,_cmd) SrvUpdateStatistics2((_work),(_cmd))
#else
#define UPDATE_STATISTICS2(_work,_cmd)
#endif

#define UPDATE_STATISTICS(_work,_sent,_cmd ) {                 \
    _work->CurrentWorkQueue->stats.BytesSent += (_sent);       \
    UPDATE_STATISTICS2((_work),(_cmd));                        \
}

#define UPDATE_READ_STATS( _work, _count) {                    \
    _work->CurrentWorkQueue->stats.ReadOperations++;           \
    _work->CurrentWorkQueue->stats.BytesRead += (_count);      \
}

#define UPDATE_WRITE_STATS(_work, _count) {                    \
    _work->CurrentWorkQueue->stats.WriteOperations++;          \
    _work->CurrentWorkQueue->stats.BytesWritten += (_count);   \
}

//
// VOID
// SrvFsdSendResponse (
//     IN OUT PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This routine is called when all request processing on an SMB is
//     complete and a response is to be sent.  It starts the sending of
//     that response.  The work item will be queued for final cleanup when
//     the send completes.
//
// Arguments:
//
//     WorkContext - Supplies a pointer to the work context block
//         containing information about the SMB.
//
// Return Value:
//
//    None.
//

#define SrvFsdSendResponse( _wc ) {                               \
                                                                  \
    (_wc)->ResponseBuffer->DataLength =                           \
                    (CLONG)( (PCHAR)(_wc)->ResponseParameters -   \
                                (PCHAR)(_wc)->ResponseHeader );   \
    (_wc)->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;    \
    SRV_START_SEND_2( (_wc), SrvFsdRestartSmbAtSendCompletion, NULL, NULL );    \
    }

//
// VOID
// SrvFsdSendResponse2 (
//     IN OUT PWORK_CONTEXT WorkContext,
//     IN PRESTART_ROUTINE FspRestartRoutine
//     )
//
// Routine Description:
//
//     This routine is identical to SrvFsdSendResponse, except that
//     processing restarts after the send in the FSP, not the FSD.
//
//     *** If you change either SrvFsdSendResponse or SrvFsdSendResponse2,
//         CHANGE BOTH OF THEM!
//
// Arguments:
//
//     WorkContext - Supplies a pointer to the work context block
//         containing information about the SMB.
//
//     FspRestartRoutine - Supplies the address of the restart routine in
//         the FSP that is to be called when the TdiSend completes.
//
// Return Value:
//
//     None.
//

#define SrvFsdSendResponse2( _wc, _fspRestart ) {                       \
                                                                        \
    (_wc)->ResponseBuffer->DataLength =                                 \
                    (CLONG)( (PCHAR)(_wc)->ResponseParameters -         \
                                (PCHAR)(_wc)->ResponseHeader );         \
    (_wc)->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;          \
    SRV_START_SEND_2((_wc), SrvQueueWorkToFspAtSendCompletion, NULL, (_fspRestart));\
    }

//
// VOID
// ParseLockData (
//     IN BOOLEAN LargeFileLock,
//     IN PLOCKING_ANDX_RANGE SmallRange,
//     IN PNTLOCKING_ANDX_RANGE LargeRange,
//     OUT PUSHORT Pid,
//     OUT PLARGE_INTEGER Offset,
//     OUT PLARGE_INTEGER Length
//     )
// {
//

#define ParseLockData( _largeLock, _sr, _lr, _pid, _offset, _len ) {    \
                                                                        \
        if ( _largeLock ) {                                             \
            *(_pid) = SmbGetUshort( &(_lr)->Pid );                      \
            (_offset)->LowPart = SmbGetUlong( &(_lr)->OffsetLow );      \
            (_offset)->HighPart = SmbGetUlong( &(_lr)->OffsetHigh );    \
            (_len)->LowPart = SmbGetUlong( &(_lr)->LengthLow );         \
            (_len)->HighPart = SmbGetUlong( &(_lr)->LengthHigh );       \
        } else {                                                        \
            *(_pid) = SmbGetUshort( &(_sr)->Pid );                      \
            (_offset)->QuadPart = SmbGetUlong( &(_sr)->Offset );        \
            (_len)->QuadPart = SmbGetUlong( &(_sr)->Length );           \
        }                                                               \
    }

//
// CHECK_SEND_COMPLETION_STATUS( _status ) will log errors
// that occurs during send completion.
//

#define CHECK_SEND_COMPLETION_STATUS( _status ) {                       \
    InterlockedDecrement( &WorkContext->Connection->OperationsPendingOnTransport ); \
    if ( !NT_SUCCESS( _status ) ) {                                     \
        SrvCheckSendCompletionStatus( _status, __LINE__ );              \
    } else {                                                            \
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );           \
    }                                                                   \
}
#define CHECK_SEND_COMPLETION_STATUS_CONNECTIONLESS( _status ) {                       \
    if ( !NT_SUCCESS( _status ) ) {                                     \
        SrvCheckSendCompletionStatus( _status, __LINE__ );              \
    } else {                                                            \
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );           \
    }                                                                   \
}

//
// Definitions for unlockable code sections.
//

#define SRV_CODE_SECTION_1AS  0
#define SRV_CODE_SECTION_8FIL 1
#define SRV_CODE_SECTION_MAX  2

extern SRV_LOCK SrvUnlockableCodeLock;

typedef struct _SECTION_DESCRIPTOR {
    PVOID Base;
    PVOID Handle;
    ULONG ReferenceCount;
} SECTION_DESCRIPTOR, *PSECTION_DESCRIPTOR;

extern SECTION_DESCRIPTOR SrvSectionInfo[SRV_CODE_SECTION_MAX];

#define UNLOCKABLE_CODE( _section )                                     \
    ASSERTMSG( "Unlockable code called while section not locked",       \
        SrvSectionInfo[SRV_CODE_SECTION_##_section##].Handle != NULL )

VOID
SrvReferenceUnlockableCodeSection (
    IN ULONG CodeSection
    );

VOID
SrvDereferenceUnlockableCodeSection (
    IN ULONG CodeSection
    );

//
// We only need to lock these sections on the workstation product,
//  since we lock them down in InitializeServer() if we're NTAS
//
#define REFERENCE_UNLOCKABLE_CODE( _section ) \
    if( !SrvProductTypeServer ) SrvReferenceUnlockableCodeSection( SRV_CODE_SECTION_##_section## )

#define DEREFERENCE_UNLOCKABLE_CODE( _section ) \
    if( !SrvProductTypeServer) SrvDereferenceUnlockableCodeSection( SRV_CODE_SECTION_##_section## )


//
// VOID
// SrvInsertWorkQueueTail (
//     IN OUT PWORK_QUEUE WorkQueue,
//     IN PQUEUEABLE_BLOCK_HEADER WorkItem
//     )

#if SRVDBG_STATS2
#define SrvInsertWorkQueueTail( _workQ, _workItem ) {                   \
    ULONG depth;                                                        \
    GET_SERVER_TIME( _workQ, &(_workItem)->Timestamp );                 \
    depth = KeInsertQueue( &(_workQ)->Queue, &(_workItem)->ListEntry ); \
    (_workQ)->ItemsQueued++;                                            \
    if ( (LONG)depth > (_workQ)->MaximumDepth ) {                       \
        (_workQ)->MaximumDepth = (LONG)depth;                           \
    }                                                                   \
}
#else
#define SrvInsertWorkQueueTail( _workQ, _workItem ) {                   \
    GET_SERVER_TIME( _workQ, &(_workItem)->Timestamp );                 \
    (VOID)KeInsertQueue( &(_workQ)->Queue, &(_workItem)->ListEntry );   \
}
#endif // SRVDBG_STATS2

//
// VOID
// SrvInsertWorkQueueHead (
//     IN OUT PWORK_QUEUE WorkQueue,
//     IN PQUEUEABLE_BLOCK_HEADER WorkItem
//     )
#define SrvInsertWorkQueueHead( _workQ, _workItem ) {                    \
    GET_SERVER_TIME( _workQ, &(_workItem)->Timestamp );                  \
    (VOID)KeInsertHeadQueue( &(_workQ)->Queue, &(_workItem)->ListEntry );\
}

//
// BOOLEAN
// SrvRetryDueToDismount(
//      IN PSHARE Share,
//      IN NTSTATUS Status
//  )
#define SrvRetryDueToDismount( _share, _status ) \
        ((_status) == STATUS_VOLUME_DISMOUNTED && \
        SrvRefreshShareRootHandle( _share, &(_status) ) )



#if DBG_STUCK
#define SET_OPERATION_START_TIME( _context ) \
    if( *(_context) != NULL ) KeQuerySystemTime( &((*(_context))->OpStartTime) );
#else
#define SET_OPERATION_START_TIME( _context )
#endif

#if DBG
#define CHECKIRP( irp ) {                                                       \
    if( (irp) && (irp)->CurrentLocation != (irp)->StackCount + 1 ) {            \
        DbgPrint( "SRV: IRP %p already in use at %u!\n", irp, __LINE__ );       \
        DbgBreakPoint();                                                        \
    }                                                                           \
}
#else
#define CHECKIRP( irp )
#endif

//
// Allocate a WORK_CONTEXT structure.
//
#define INITIALIZE_WORK_CONTEXT( _queue, _context ) {\
    (_context)->BlockHeader.ReferenceCount = 1; \
    GET_SERVER_TIME( _queue, &(_context)->Timestamp ); \
    RtlZeroMemory( &(_context)->Endpoint, sizeof( struct _WorkContextZeroBeforeReuse ) ); \
    SrvWmiInitContext((_context)); \
}

#define ALLOCATE_WORK_CONTEXT( _queue, _context ) {             \
    *(_context) = NULL;                                         \
    *(_context) = (PWORK_CONTEXT)InterlockedExchangePointer( &(_queue)->FreeContext, (*_context) ); \
    if( *(_context) != NULL ) {                                 \
        INITIALIZE_WORK_CONTEXT( _queue, *(_context) );         \
    } else {                                                    \
        *(_context) = SrvFsdGetReceiveWorkItem( _queue );       \
    }                                                           \
    CHECKIRP( *(_context) ? (*(_context))->Irp : NULL );        \
    SET_OPERATION_START_TIME( _context )                        \
}

//
// Returns the work item to the free list.
//

#define RETURN_FREE_WORKITEM( _wc ) \
    do {                                                                \
        PWORK_QUEUE _queue  = _wc->CurrentWorkQueue;                    \
        ASSERT( _queue >= SrvWorkQueues && _queue < eSrvWorkQueues );   \
        ASSERT( _wc->BlockHeader.ReferenceCount == 0 );                 \
        ASSERT( _wc->FreeList != NULL );                                \
        CHECKIRP( (_wc)->Irp );                                         \
        if( (_wc)->Irp->AssociatedIrp.SystemBuffer &&                   \
            (_wc)->Irp->Flags & IRP_DEALLOCATE_BUFFER ) {               \
                ExFreePool( (_wc)->Irp->AssociatedIrp.SystemBuffer );   \
                (_wc)->Irp->AssociatedIrp.SystemBuffer = NULL;          \
                (_wc)->Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;            \
        }                                                               \
        if( _queue->NeedWorkItem ) {                                    \
            if( InterlockedDecrement( &(_queue->NeedWorkItem) ) >= 0 ){ \
                _wc->FspRestartRoutine = SrvServiceWorkItemShortage;    \
                SrvInsertWorkQueueHead( _queue, _wc );                  \
                break;                                                  \
            } else {                                                    \
                InterlockedIncrement( &(_queue->NeedWorkItem) );        \
            }                                                           \
        }                                                               \
        _wc = (PWORK_CONTEXT)InterlockedExchangePointer( &_queue->FreeContext, _wc ); \
        if( _wc ) {                                                     \
            CHECKIRP( (_wc)->Irp );                                     \
            ExInterlockedPushEntrySList( _wc->FreeList, &_wc->SingleListEntry, &_queue->SpinLock );\
            InterlockedIncrement( &_queue->FreeWorkItems );             \
        }                                                               \
    } while (0);

//
// Our current work queue, based on our current processor
//

#if MULTIPROCESSOR

#define PROCESSOR_TO_QUEUE()  (&SrvWorkQueues[ KeGetCurrentProcessorNumber() ])

#else

#define PROCESSOR_TO_QUEUE() (&SrvWorkQueues[0])

#endif

#define SET_INVALID_CONTEXT_HANDLE(h)   ((h).dwLower = (h).dwUpper = (ULONG)(-1))

#define IS_VALID_CONTEXT_HANDLE(h)      (((h).dwLower != (ULONG) -1) && ((h).dwUpper != (ULONG) -1))

#endif // def _SRVMACRO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvio.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvio.h

Abstract:

    This module defines functions for building I/O request packets for
    the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVIO_
#define _SRVIO_

//#include <ntos.h>

//
// I/O request packet builders
//

PIRP
SrvBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN OUT PMDL Mdl OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    );

VOID
SrvBuildFlushRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL
    );

VOID
SrvBuildLockRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );

VOID
SrvBuildReadOrWriteRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    IN OUT PMDL Mdl OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN ULONG Key OPTIONAL
    );

PIRP
SrvBuildNotifyChangeRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN ULONG CompletionFilter,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WatchTree
    );

VOID
SrvBuildMailslotWriteRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length
    );

NTSTATUS
SrvIssueMdlCompleteRequest (
    IN PWORK_CONTEXT WorkContext OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PMDL Mdl,
    IN UCHAR Function,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG Length
    );

NTSTATUS
SrvIssueAssociateRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN HANDLE AddressFileHandle
    );

NTSTATUS
SrvIssueDisconnectRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG Flags
    );

NTSTATUS
SrvIssueTdiAction (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvIssueTdiQuery (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength,
    IN ULONG QueryType
    );

NTSTATUS
SrvIssueQueryDirectoryRequest (
    IN HANDLE FileHandle,
    IN PCHAR Buffer,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN PULONG FileIndex OPTIONAL,
    IN BOOLEAN RestartScan,
    IN BOOLEAN SingleEntriesOnly
    );

NTSTATUS
SrvIssueQueryEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN BOOLEAN RestartScan,
    OUT PULONG EaErrorOffset OPTIONAL
    );

NTSTATUS
SrvIssueSendDatagramRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PTDI_CONNECTION_INFORMATION SendDatagramInformation,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
SrvIssueSetClientProcessRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCONNECTION Connection,
    IN PVOID ClientSession,
    IN PVOID ClientProcess
    );

NTSTATUS
SrvIssueSetEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EaErrorOffset OPTIONAL
    );

NTSTATUS
SrvIssueSetEventHandlerRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
SrvIssueUnlockRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN UCHAR UnlockOperation,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    );

NTSTATUS
SrvIssueUnlockSingleRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    );

NTSTATUS
SrvIssueWaitForOplockBreak (
    IN HANDLE FileHandle,
    PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

VOID
SrvQuerySendEntryPoint(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID *EntryPoint
    );

#ifdef INCLUDE_SMB_IFMODIFIED
NTSTATUS
SrvIssueQueryUsnInfoRequest (
    IN PRFCB Rfcb,
    IN BOOLEAN SubmitClose,
    OUT PLARGE_INTEGER Usn,
    OUT PLARGE_INTEGER FileRefNumber
    );
#endif
#endif // ndef _SRVIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvnet.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvnet.h

Abstract:

    This module defines types and functions for accessing the network
    for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVNET_
#define _SRVNET_

//#include <ntos.h>

//#include "srvblock.h"


//
// Network manager routines
//

NTSTATUS
SrvAddServedNet (
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN ULONG           Flags,
    IN DWORD           PasswordLength,
    IN PBYTE           Password
    );

NTSTATUS
SrvDoDisconnect (
    IN OUT PCONNECTION Connection
    );

NTSTATUS
SrvDeleteServedNet (
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress
    );

NTSTATUS
SrvOpenConnection (
    IN PENDPOINT Endpoint
    );

VOID
SrvPrepareReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN QueueToFreeList
    );

VOID SRVFASTCALL
SrvRestartAccept (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine,
    IN PMDL Mdl OPTIONAL,
    IN ULONG SendOptions
    );

VOID
SrvStartSend2 (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    );

VOID SRVFASTCALL
RestartStartSend (
    IN OUT PWORK_CONTEXT WorkContext
    );

ULONG
GetIpxMaxBufferSize(
    PENDPOINT Endpoint,
    ULONG AdapterNumber,
    ULONG DefaultMaxBufferSize
    );

#endif // ndef _SRVNET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvnls.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvnls.h

Abstract:

    This module defines string constants used by the LAN Manager server.
    The purpose of this module is to isolate NLS concerns.

Author:

    Chuck Lenzmeier (chuckl) 12-Jun-1990

Revision History:

--*/

#ifndef _SRVNLS_
#define _SRVNLS_


#endif // ndef _SRVNLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvstamp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srvstamp.h

Abstract:

    This module defines the file stamp support routines for the server
Author:

    David Kruse (dkruse) 10-23-2000
    
Revision History:

--*/

#ifndef _SRVSTAMP_
#define _SRVSTAMP_

#ifdef SRVCATCH
void SrvIsMonitoredShare( PSHARE Share );
ULONG SrvFindCatchOffset( OUT PVOID pBuffer, ULONG BufferSize );
void SrvCorrectCatchBuffer( PVOID pBuffer, ULONG CatchOffset );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvstamp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    srvstamp.c

Abstract:

    This module contains routines for supporting the SrvStamp functionality
    
Author:

    David Kruse (dkruse) 23-Oct-2000

Revision History:

--*/

#include "precomp.h"
#include "srvstamp.tmh"
#pragma hdrstop
                    
#ifdef SRVCATCH

//
//  Stupid compiler won't convert memcmp( data, constdata, 8 ) into
//  a single 64-bit compare, so we use 64-bit numeric constants here.
//

#define PVD_SIGNATURE 0x0001313030444301    // 0x01 "CD001" 0x01 0x00
#define TVD_SIGNATURE 0x00013130304443FF    // 0xFF "CD001" 0x01 0x00

#ifdef STATIC_CRC_TABLE
 
const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D};

#else

unsigned long *CrcTable32 = NULL;

#endif

BOOLEAN GenerateCrcTable()
{
#ifndef STATIC_CRC_TABLE

    ULONG i, j, Value;

    if( !CrcTable32 )
    {
        CrcTable32 = ALLOCATE_NONPAGED_POOL( sizeof(ULONG)*256, BlockTypeMisc );
        if( !CrcTable32 )
            return FALSE;
    }

    for ( i = 0; i < 256; i++ ) 
    {
        for ( Value = i, j = 8; j > 0; j-- ) 
        {
            if ( Value & 1 ) 
            {
                Value = ( Value >> 1 ) ^ 0xEDB88320;
            }
            else 
            {
                Value >>= 1;
            }
        }

        CrcTable32[ i ] = Value;
    }

#endif

    return TRUE;
}

BOOLEAN CleanupCrcTable()
{
#ifndef STATIC_CRC_TABLE
    if( CrcTable32 )
    {
        DEALLOCATE_NONPAGED_POOL( CrcTable32 );
        CrcTable32 = NULL;
    }
#endif

    return TRUE;
}

#pragma optimize( "t", on ) // following code should be fast versus small
// (crc loop 40000 times per corrected image)


ULONG
__forceinline               // called from only one location
Crc32(
     ULONG InitialCrc,
     const VOID *Buffer,
     ULONG Bytes
     )
{

    ULONG Crc = InitialCrc;
    const UCHAR *p = Buffer;
    ULONG Count = Bytes;

    while ( Count-- )
    {
        Crc = ( Crc >> 8 ) ^ CrcTable32[ (UCHAR)Crc ^ *p++ ];
    }

    return Crc;
}


ULONG
__fastcall
LocateTvdSectorInIsoFileHeader(
                              PVOID FileHeader,       // should be at least 20 * 2048 (40,960) bytes, but
                              ULONG SizeOfHeader      //  won't search past 24 * 2048 (49,152) bytes
                              )
{
    PBYTE p;
    PBYTE z;

    if ( SizeOfHeader >= ( 20 * 2048 ))
    {   // big enough for ISO-9660 headers

        if ( SizeOfHeader > ( 24 * 2048 ))
        {    // don't bother searching
            SizeOfHeader = ( 24 * 2048 );      // beyond sector 23
        }

        p = (PBYTE)FileHeader + ( 16 * 2048 );  // point at PVD sector
        z = (PBYTE)FileHeader + SizeOfHeader;   // search until p >= z

        //
        //  If FileHeader buffer is guaranteed to be 8-byte aligned, can remove
        //  the UNALIGNED keywords below.
        //

        if ( *(UNALIGNED UINT64 *)p == PVD_SIGNATURE )
        {    // ISO-9660 image

            p += 2048;                          // skip PVD and scan for TVD

            do
            {

                if ( *(UNALIGNED UINT64 *)p == TVD_SIGNATURE )
                {

                    return(ULONG)( p - (PBYTE)FileHeader );   // return offset to TVD
                }

                p += 2048;
            }

            while ( p < z );

        }
    }

    return 0;                               // no TVD, not valid ISO-9660 image
}


VOID
__fastcall
EmbedDataInIsoTvdAndCorrectCrc(
                              PVOID IsoFileHeader,
                              ULONG TvdSectorOffset,
                              PVOID DataToEmbed,
                              ULONG SizeOfData
                              )
{
    //
    //  If IsoFileHeader is 4-byte aligned, can remove UNALIGNED keyword.
    //

    UNALIGNED ULONG *pCrcCorrection;

    ASSERT( SizeOfData <= 1020 );

    memcpy( (PBYTE)IsoFileHeader + TvdSectorOffset + 1024, DataToEmbed, SizeOfData );

    //
    //  We only perform CRC correction if the TVD has been predisposed to
    //  CRC correction (cdimage -xx).  In other words, if the last four
    //  bytes of the TVD already contain a non-zero CRC correction.
    //

    pCrcCorrection = (PULONG)( (PBYTE)IsoFileHeader + TvdSectorOffset + 2048 - 4 );

    if ( *pCrcCorrection )
    {
        *pCrcCorrection = Crc32( 0xFFFFFFFF, IsoFileHeader, TvdSectorOffset + 2048 - 4 );
    }
}

ULONG 
SrvFindCatchOffset( 
    IN OUT PVOID pBuffer, 
    IN ULONG BufferSize
    )
{
    ULONG offset;
    offset = LocateTvdSectorInIsoFileHeader( pBuffer, BufferSize );
    if( offset )
    {
        offset += 1024;
    }
    
    return offset;
}

void
SrvCorrectCatchBuffer(
    IN PVOID pBuffer,
    IN ULONG CatchOffset
    )
{
    UNALIGNED ULONG *pCrcCorrection;

    CatchOffset -= 1024;

    //
    //  We only perform CRC correction if the TVD has been predisposed to
    //  CRC correction (cdimage -xx).  In other words, if the last four
    //  bytes of the TVD already contain a non-zero CRC correction.
    //

    pCrcCorrection = (PULONG)( (PBYTE)pBuffer + CatchOffset + 2048 - 4 );

    if ( *pCrcCorrection )
    {
        *pCrcCorrection = Crc32( 0xFFFFFFFF, pBuffer, CatchOffset + 2048 - 4 );
    }
}

void 
SrvIsMonitoredShare( 
    IN OUT PSHARE Share
    )
{
    int i;
    UNICODE_STRING watchShare;

    if( SrvCatchShares > 0 )
    {
        for( i=0; SrvCatchShareNames[i]; i++ )
        {
            watchShare.Buffer = SrvCatchShareNames[i];
            watchShare.Length = (USHORT)STRLEN( SrvCatchShareNames[i] )*sizeof(WCHAR);
            if( RtlCompareUnicodeString( &watchShare, &Share->ShareName, TRUE ) == 0 )
            {
                Share->IsCatchShare = TRUE;
                break;
            }
        }
    }
}

#endif // SRVCATCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvsnap.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    srvsnap.h

Abstract:

    This module implements making SnapShots availible over the network

Author:

    David Kruse (dkruse) 22-March-2001

Revision History:

--*/

#ifndef _SRVSNAP_
#define _SRVSNAP_

typedef struct _SRV_SNAPSHOT_ARRAY
{
    ULONG NumberOfSnapShots;            // The number of SnapShots for the volume
    ULONG NumberOfSnapShotsReturned;    // The number of SnapShots being returned
    ULONG SnapShotArraySize;            // The size (in bytes) needed for the array
    WCHAR SnapShotMultiSZ[1];           // The multiSZ array of SnapShot names
} SRV_SNAPSHOT_ARRAY, *PSRV_SNAPSHOT_ARRAY;


NTSTATUS
SrvSnapRefreshSnapShotsForShare(
    IN PSHARE Share
    );

NTSTATUS
SrvSnapRemoveShare(
    IN PSHARE_SNAPSHOT SnapShare
    );

NTSTATUS
SrvSnapEnumerateSnapShots(
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvSnapGetRootHandle(
    IN PWORK_CONTEXT WorkContext,
    OUT HANDLE* RootHandle
    );

NTSTATUS
SrvSnapGetNameString(
    IN PWORK_CONTEXT WorkContext,
    OUT PUNICODE_STRING* pathName,
    OUT BOOLEAN* FreePath
    );

BOOLEAN
SrvSnapParseToken(
    IN PWSTR Source,
    OUT PLARGE_INTEGER TimeStamp
    );

#endif // _SRVSNAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvsnap.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    srvsnap.c

Abstract:

    This module contains routines for supporting the SnapShot feature
    that interfaces CIFS with SnapShots

Author:

    David Kruse (dkruse) 22-March-2001

Revision History:

--*/

#include "precomp.h"
#include "srvsupp.h"
#include "ntddsnap.h"
#include "stdarg.h"
#include "stdio.h"
#include "srvsnap.tmh"
#pragma hdrstop

// Function Declaractions
NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
SrvSnapGetNames(
    IN HANDLE hFile,
    IN OUT PVOID pBuffer,
    IN OUT LPDWORD lpdwBufSize
    );

NTSTATUS
SrvSnapGetNamesForVolume(
    IN HANDLE hFile,
    OUT PVOLSNAP_NAMES* Names
    );

NTSTATUS
SrvSnapFillConfigInfo(
    IN PSHARE_SNAPSHOT SnapShare,
    IN PUNICODE_STRING SnapShotPath
    );

BOOLEAN
SrvParseMultiSZ(
    IN OUT PUNICODE_STRING mszString
    );

NTSTATUS
SrvSnapInsertSnapIntoShare(
    IN PSHARE Share,
    IN PSHARE_SNAPSHOT SnapShot
    );

NTSTATUS
SrvSnapAddShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapPath
    );

NTSTATUS
SrvSnapRemoveShare(
    IN PSHARE_SNAPSHOT SnapShare
    );

NTSTATUS
SrvSnapCheckForAndCreateSnapShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapShotName
    );

NTSTATUS
SrvSnapRefreshSnapShotsForShare(
    IN PSHARE Share
    );

NTSTATUS
SrvSnapEnumerateSnapShots(
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvSnapGetRootHandle(
    IN PWORK_CONTEXT WorkContext,
    OUT HANDLE* RootHandle
    );

NTSTATUS
SrvSnapGetNameString(
    IN PWORK_CONTEXT WorkContext,
    OUT PUNICODE_STRING* ShareName,
    OUT PBOOLEAN AllocatedShareName
    );

BOOLEAN
ExtractNumber(
    IN PWSTR psz,
    IN ULONG Count,
    OUT PLONG value
    );

BOOLEAN
SrvSnapParseToken(
    IN PWSTR Source,
    OUT PLARGE_INTEGER TimeStamp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSnapGetNames )
#pragma alloc_text( PAGE, SrvSnapGetNamesForVolume )
#pragma alloc_text( PAGE, SrvSnapFillConfigInfo )
#pragma alloc_text( PAGE, SrvParseMultiSZ )
#pragma alloc_text( PAGE, SrvSnapInsertSnapIntoShare )
#pragma alloc_text( PAGE, SrvSnapAddShare )
#pragma alloc_text( PAGE, SrvSnapRemoveShare )
#pragma alloc_text( PAGE, SrvSnapCheckForAndCreateSnapShare )
#pragma alloc_text( PAGE, SrvSnapRefreshSnapShotsForShare )
#pragma alloc_text( PAGE, SrvSnapEnumerateSnapShots )
#pragma alloc_text( PAGE, SrvSnapGetRootHandle )
#pragma alloc_text( PAGE, SrvSnapGetNameString )
#pragma alloc_text( PAGE, ExtractNumber )
#pragma alloc_text( PAGE, SrvSnapParseToken )
#endif

//
// Helper Functions
//

NTSTATUS
SrvSnapGetNames(
    IN HANDLE hFile,
    IN OUT PVOID pBuffer,
    IN OUT LPDWORD lpdwBufSize
    )
/*++

Routine Description:

    This function takes a volume handle and attempts to enumerate all the
    SnapShots on that volume into the given buffer

Arguments:

    hFile - The handle to the volume

    pBuffer - A pointer to the output buffer

    lpdwBufSize - Pointer to the size of passed in buffer.  Set to the
    required size if STATUS_BUFFER_OVERFLOW is returned

Return Value:

    NTSTATUS - Expected return codes are STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW.
      Any other response is an unexpected error code and the request should be
      failed

--*/

{
    PIRP Irp = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    KEVENT CompletionEvent;
    PDEVICE_OBJECT DeviceObject = NULL;
    PIO_STACK_LOCATION IrpSp;

    ASSERT( (*lpdwBufSize) > sizeof(VOLSNAP_NAMES) );

    // Initialize the variables
    KeInitializeEvent( &CompletionEvent, SynchronizationEvent, FALSE );

    // Create the IRP
    Irp = BuildCoreOfSyncIoRequest(
                        hFile,
                        NULL,
                        &CompletionEvent,
                        &IoStatus,
                        &DeviceObject );
    if( !Irp )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the other IRP fields
    Irp->Flags = (LONG)IRP_BUFFERED_IO;
    Irp->AssociatedIrp.SystemBuffer = pBuffer;
    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpSp->MinorFunction = 0;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = *lpdwBufSize;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS;
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    // Issue the IO
    Status = StartIoAndWait( Irp, DeviceObject, &CompletionEvent, &IoStatus );

    // If this was a buffer overflow, update the value
    if( (Status == STATUS_BUFFER_OVERFLOW) &&
        (*lpdwBufSize >= sizeof(VOLSNAP_NAMES)) )
    {
        *lpdwBufSize = ((PVOLSNAP_NAMES)pBuffer)->MultiSzLength + sizeof(VOLSNAP_NAMES);
    }

    return Status;
}


NTSTATUS
SrvSnapGetNamesForVolume(
    IN HANDLE hFile,
    OUT PVOLSNAP_NAMES* Names
    )
/*++

Routine Description:

    This function takes a volume handle and returns the list of SnapShots for that
    volume.  If an error occurs, or no SnapShots exist, the returned pointer is
    NULL.   NOTE: The caller is responsible for freeing the returned pointer via
    DEALLOCATE_NONPAGED_POOL

Arguments:

    hFile - The handle to the volume

    Names - A pointer to the pointer where we will store the volume name list

Return Value:

    NTSTATUS - Expected return code is STATUS_SUCCESS . Any other response is an
    unexpected error code and the request should be failed

--*/
{
    NTSTATUS Status;
    VOLSNAP_NAMES VolNamesBase;
    PVOLSNAP_NAMES pNames = NULL;
    DWORD dwSize = sizeof(VOLSNAP_NAMES);

    // Initialize the values
    *Names = NULL;

    // Find out how big it should be
    Status = SrvSnapGetNames( hFile, &VolNamesBase, &dwSize );

    if( Status != STATUS_BUFFER_OVERFLOW )
    {
        return Status;
    }

    // Allocate the correct size block
    pNames = (PVOLSNAP_NAMES)ALLOCATE_NONPAGED_POOL( dwSize, BlockTypeSnapShot );
    if( !pNames )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Build up the IRP to be used for the query
    Status = SrvSnapGetNames( hFile, pNames, &dwSize );

    // Save the output if we're successful, or else deallocate
    if( !NT_SUCCESS(Status) )
    {
        if( pNames )
        {
            DEALLOCATE_NONPAGED_POOL( pNames );
            pNames = NULL;
            *Names = NULL;
        }
    }
    else
    {
        ASSERT(pNames);
        *Names = pNames;
    }

    return Status;
}

NTSTATUS
SrvSnapFillConfigInfo(
    IN PSHARE_SNAPSHOT SnapShare,
    IN PUNICODE_STRING SnapShotPath
    )
/*++

Routine Description:

    This function takes a SnapShare with existing names filled in and
    queries the extra config info (the timestamp) for that SnapShot

Arguments:

    SnapShare - Pointer to the SnapShot share to be filled in

Return Value:

    NTSTATUS - Expected return code is STATUS_SUCCESS . Any other response is an
    unexpected error code and the request should be failed

--*/
{
    HANDLE hVolume;
    DWORD dwBytes;
    NTSTATUS Status;
    PIRP Irp = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    VOLSNAP_CONFIG_INFO ConfigInfo;
    IO_STATUS_BLOCK IoStatus;
    KEVENT CompletionEvent;
    PDEVICE_OBJECT DeviceObject;
    PIO_STACK_LOCATION IrpSp;

    // Now open the SnapShot handle
    KeInitializeEvent( &CompletionEvent, SynchronizationEvent, FALSE );
    InitializeObjectAttributes(
        &objectAttributes,
        SnapShotPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtOpenFile(
                &hVolume,
                FILE_TRAVERSE|FILE_GENERIC_READ,
                &objectAttributes,
                &IoStatus,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                0
                );
    if( !NT_SUCCESS(Status) )
    {
        return Status;
    }

    // Create the IRP
    Irp = BuildCoreOfSyncIoRequest(
                        hVolume,
                        NULL,
                        &CompletionEvent,
                        &IoStatus,
                        &DeviceObject );
    if( !Irp )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the other IRP fields
    Irp->Flags = (LONG)IRP_BUFFERED_IO;
    Irp->AssociatedIrp.SystemBuffer = &ConfigInfo;
    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpSp->MinorFunction = 0;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(VOLSNAP_CONFIG_INFO);
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_VOLSNAP_QUERY_CONFIG_INFO;
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    // Issue the IO
    Status = StartIoAndWait( Irp, DeviceObject, &CompletionEvent, &IoStatus );

    if( !NT_SUCCESS( Status ) )
    {
        NtClose( hVolume );
        return Status;
    }

    // Fill in the info and return success
    SnapShare->Timestamp = ConfigInfo.SnapshotCreationTime;
    NtClose( hVolume );
    return STATUS_SUCCESS;
}

BOOLEAN
SrvParseMultiSZ(
    IN OUT PUNICODE_STRING mszString
    )
/*++

Routine Description:

    This function takes a UNICODE_STRING that points to a MultiSZ value, and
    parses it with each iteration (similar to strtok( psz, "\0" )).  For every
    iteration this returns TRUE, the string will point to the next SZ in the
    MultiSZ

Arguments:

    mszString - Pointer to the MultiSZ string.  For the first iteration, set the
    MaximumLength to the length of the MultiSZ, and the Length to 0.  For all
    other iterations, simply pass in the string from the previous iteration

Return Value:

    BOOLEAN - If TRUE, this is a valid SZ.  If FALSE, all have been parsed

--*/
{
    USHORT Count;

    ASSERT( mszString->Length <= mszString->MaximumLength );

    if( mszString->Length > 0 )
    {
        // Move the pointer past the string and the NULL
        mszString->Buffer += (mszString->Length/2)+1;
        mszString->MaximumLength -= (mszString->Length+2);
    }

    for( Count=0; Count<mszString->MaximumLength; Count++ )
    {
        if( mszString->Buffer[Count] == (WCHAR)'\0' )
        {
            mszString->Length = Count*2;
            if( Count > 0 )
                return TRUE;
            else
                return FALSE;
        }
    }

    // The starting data was bad!
    ASSERT(FALSE);

    return FALSE;
}

NTSTATUS
SrvSnapInsertSnapIntoShare(
    IN PSHARE Share,
    IN PSHARE_SNAPSHOT SnapShot
    )
{
    PLIST_ENTRY ListEntry = Share->SnapShots.Flink;

    // Walk the SnapShot share list and see if this is a duplicate
    while( ListEntry != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( ListEntry, SHARE_SNAPSHOT, SnapShotList );
        if( RtlEqualUnicodeString( &SnapShot->SnapShotName, &snapShare->SnapShotName, TRUE ) )
        {
            return STATUS_DUPLICATE_NAME;
        }
        ListEntry = ListEntry->Flink;
    }


    InsertTailList( &Share->SnapShots, &SnapShot->SnapShotList );
    return STATUS_SUCCESS;
}


NTSTATUS
SrvSnapAddShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapPath
    )
/*++

Routine Description:

    This function allocates a SnapShot Share that is being added to the system and
    initializes it

Arguments:

    Share - Pointer to the parent share

    SnapPath - UNICODE_STRING name of the SnapShot (\\Device\\HardDiskSnap1)

    NOTE: Caller must have the SnapShotLock acquired

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES

--*/
{
#define SHARE_DEVICE_HEADER 6
    NTSTATUS Status;
    PSHARE_SNAPSHOT snapShare = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK IoStatus;
    ULONG AllocSize;
    TIME_FIELDS rtlTime;

    IF_DEBUG( SNAPSHOT) KdPrint(( "SrvSnapAddShare %p %wZ\n", Share, SnapPath ));

    // Calculate the size to allocate
    // sizeof(SNAP_STRUCT) + (Length of SnapShotName) + (Max Length of SnapShot Path)
    AllocSize = sizeof(SHARE_SNAPSHOT) + SNAPSHOT_NAME_LENGTH + (SnapPath->Length + Share->NtPathName.Length);

    snapShare = ALLOCATE_HEAP( AllocSize, BlockTypeSnapShot );
    if( !snapShare )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the SnapShot-share structure
    RtlZeroMemory( snapShare, sizeof(SHARE_SNAPSHOT) );
    snapShare->SnapShotName.MaximumLength = SNAPSHOT_NAME_LENGTH;
    snapShare->SnapShotName.Length = 0;
    snapShare->SnapShotName.Buffer = (PWCHAR)(snapShare+1);

    // This is only valid on shares who's NT Path is \??\X:\ where X is a logical drive
    // Don't allow any others
    if( Share->NtPathName.Length < (SHARE_DEVICE_HEADER+1)*sizeof(WCHAR) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Build the new SnapShot-relative path
    snapShare->SnapShotPath.MaximumLength = SnapPath->Length + Share->NtPathName.Length;
    snapShare->SnapShotPath.Length = 0;
    snapShare->SnapShotPath.Buffer = snapShare->SnapShotName.Buffer + (snapShare->SnapShotName.MaximumLength/sizeof(WCHAR));

    // Create it by using the SnapShot device and the Share NtPath
    RtlCopyUnicodeString( &snapShare->SnapShotPath, SnapPath );
    RtlCopyMemory( snapShare->SnapShotPath.Buffer + (snapShare->SnapShotPath.Length/2), Share->NtPathName.Buffer + SHARE_DEVICE_HEADER, Share->NtPathName.Length-SHARE_DEVICE_HEADER*sizeof(WCHAR) );
    snapShare->SnapShotPath.Length += (Share->NtPathName.Length-SHARE_DEVICE_HEADER*sizeof(WCHAR));

    //IF_DEBUG( SNAPSHOT ) KdPrint(( "%wZ -> %wZ\n", &Share->NtPathName, &snapShare->SnapShotPath ));

    // Now open the relative handle
    InitializeObjectAttributes(
        &objectAttributes,
        &snapShare->SnapShotPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtOpenFile(
                &snapShare->SnapShotRootDirectoryHandle,
                FILE_TRAVERSE,
                &objectAttributes,
                &IoStatus,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                0
                );
    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    // Fill in the configuration information
    Status = SrvSnapFillConfigInfo( snapShare, SnapPath );
    if( !NT_SUCCESS(Status) )
    {
        NtClose( snapShare->SnapShotRootDirectoryHandle );
        goto Cleanup;
    }

    // Generate the SnapShot name
    snapShare->SnapShotName.Length = SNAPSHOT_NAME_LENGTH-sizeof(WCHAR);
    RtlTimeToTimeFields( &snapShare->Timestamp, &rtlTime );
    rtlTime.Milliseconds = 0;
    rtlTime.Weekday = 0;
    _snwprintf( snapShare->SnapShotName.Buffer, SNAPSHOT_NAME_LENGTH, SNAPSHOT_NAME_FORMAT, rtlTime.Year, rtlTime.Month, rtlTime.Day, rtlTime.Hour, rtlTime.Minute, rtlTime.Second );
    RtlTimeFieldsToTime( &rtlTime, &snapShare->Timestamp );
    ASSERT( wcslen( snapShare->SnapShotName.Buffer ) == snapShare->SnapShotName.Length );


    // Insert it into the list, and return Success
    Status = SrvSnapInsertSnapIntoShare( Share, snapShare );

    if( !NT_SUCCESS(Status) ) {
        NtClose( snapShare->SnapShotRootDirectoryHandle );
        goto Cleanup;
    }

    //IF_DEBUG( SNAPSHOT ) KdPrint(( "%wZ Handle=%p\n", &snapShare->SnapShotPath, snapShare->SnapShotRootDirectoryHandle ));

Cleanup:
    // Cleanup
    if( !NT_SUCCESS(Status) )
    {
        if( snapShare ) FREE_HEAP( snapShare );
    }

    return Status;
}

NTSTATUS
SrvSnapRemoveShare(
    IN PSHARE_SNAPSHOT SnapShare
    )
/*++

Routine Description:

    This function deallocates a SnapShot Share after it has been removed from
    the underlying disk

    NOTE: Caller must have the SnapShotLock acquired

Arguments:

    SnapShare - Pointer to the SnapShot Share to remove.  It will be removed and
      deallocated.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS

--*/
{
    IF_DEBUG( SNAPSHOT ) KdPrint(( "SrvSnapRemoveShare %p %wZ\n", SnapShare, &SnapShare->SnapShotName ));

    if( SnapShare->SnapShotRootDirectoryHandle )
    {
        NtClose( SnapShare->SnapShotRootDirectoryHandle );
        SnapShare->SnapShotRootDirectoryHandle = NULL;
    }

    RemoveEntryList( &SnapShare->SnapShotList );
    FREE_HEAP( SnapShare );

    return STATUS_SUCCESS;
}

NTSTATUS
SrvSnapCheckForAndCreateSnapShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapShotName
    )
/*++

Routine Description:

    This function checks to see if a given SnapShot share exists on the given
    share, and if it does not it creates one.  If it does, it removes the NOT_FOUND
    flag to signify this share still exists

    NOTE: Caller must have the SnapShotLock acquired

Arguments:

    Share - The parent share of the SnapShot
    SnapShotName - The UNICODE_STRING name of the SnapShot (\\Device\\HardDiskSnap1)

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS or an unexpected error

--*/
{
    PLIST_ENTRY snapList;
    UNICODE_STRING SnapPartialName;

    //IF_DEBUG( SNAPSHOT ) KdPrint(( "Share %x, Name %wZ\n", Share, SnapShotName ));

    snapList = Share->SnapShots.Flink;
    SnapPartialName.Length = SnapPartialName.MaximumLength = SnapShotName->Length;

    while( snapList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( snapList, SHARE_SNAPSHOT, SnapShotList );
        snapList = snapList->Flink;
        if( snapShare->SnapShotPath.Length < SnapPartialName.Length )
        {
            return STATUS_INTERNAL_ERROR;
        }
        SnapPartialName.Buffer = snapShare->SnapShotPath.Buffer;

        if( RtlEqualUnicodeString( SnapShotName, &SnapPartialName, TRUE ) )
        {
            ClearFlag( snapShare->Flags, SRV_SNAP_SHARE_NOT_FOUND );
            return STATUS_SUCCESS;
        }
    }

    return SrvSnapAddShare( Share, SnapShotName );
}

NTSTATUS
SrvSnapRefreshSnapShotsForShare(
    IN PSHARE Share
    )
/*++

Routine Description:

    This function takes a share and refreshes the SnapShot views on the share
    so that only currently existing SnapShots are listed

Arguments:

    Share - The share we are examining

Return Value:

    NTSTATUS - STATUS_SUCCESS if all went well, otherwise the appropriate error
      code (and the request should be failed)

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    OBJECT_HANDLE_INFORMATION HandleInfo;
    PVOLSNAP_NAMES pNames = NULL;
    UNICODE_STRING VolumeName;
    UNICODE_STRING RootVolume;
    HANDLE VolumeHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PLIST_ENTRY shareList;

    // Validate we can do SnapShots
    if( Share->Removable )
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    // Get a handle to the root volume
    RootVolume.MaximumLength = Share->NtPathName.Length;
    RootVolume.Buffer = Share->NtPathName.Buffer;
    RootVolume.Length = 12;
    if( (Share->NtPathName.Length < 12) ||
        (RootVolume.Buffer[5] != L':') )
    {
        IF_DEBUG( SNAPSHOT ) KdPrint(( "Bad NtPathName on Share (%wZ)\n", &Share->NtPathName ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        &RootVolume,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &VolumeHandle,
                FILE_TRAVERSE,
                &objectAttributes,
                &iosb,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                0
                );
    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    // Get the NamesArray for the volume
    Status = SrvSnapGetNamesForVolume( VolumeHandle, &pNames );

    NtClose( VolumeHandle );

    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }
    else if( !pNames )
    {
        ACQUIRE_LOCK( Share->SnapShotLock );

        // No SnapShots were found, so delete any that exist
        shareList = Share->SnapShots.Flink;
        while( shareList != &Share->SnapShots )
        {
            PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
            shareList = shareList->Flink;
            SrvSnapRemoveShare( snapShare );
        }

        RELEASE_LOCK( Share->SnapShotLock );

        return STATUS_SUCCESS;
    }

    if( pNames->MultiSzLength > 0xFFFF )
    {
        Status = STATUS_BUFFER_OVERFLOW;
        goto Cleanup;
    }

    VolumeName.MaximumLength = (USHORT)pNames->MultiSzLength;
    VolumeName.Length = 0;
    VolumeName.Buffer = pNames->Names;

    ACQUIRE_LOCK( Share->SnapShotLock );

    // Mark all the snap-shares as "not-found"
    shareList = Share->SnapShots.Flink;
    while( shareList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
        snapShare->Flags |= SRV_SNAP_SHARE_NOT_FOUND;
        shareList = shareList->Flink;
    }

    // Walk the name list and create a SnapShot for any volumes we don't currently have
    while( SrvParseMultiSZ( &VolumeName ) )
    {
        Status = SrvSnapCheckForAndCreateSnapShare( Share, &VolumeName );
        if( !NT_SUCCESS(Status) )
        {
            IF_DEBUG( SNAPSHOT ) KdPrint(( "Failed to Add share %wZ (%x).  Continuing..\n", &VolumeName, Status ));
            Status = STATUS_SUCCESS;
        }
    }

    // Any shares that are still marked as "not-found" are no longer availibe,
    // so we need to remove them
    shareList = Share->SnapShots.Flink;
    while( shareList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
        shareList = shareList->Flink;

        if( snapShare->Flags & SRV_SNAP_SHARE_NOT_FOUND )
        {
            SrvSnapRemoveShare( snapShare );
        }
    }

    RELEASE_LOCK( Share->SnapShotLock );

Cleanup:

    // Release the memory associated with the enumeration
    if( pNames )
    {
        DEALLOCATE_NONPAGED_POOL( pNames );
        pNames = NULL;
    }

    return Status;
}

NTSTATUS
SrvSnapEnumerateSnapShots(
    IN PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This function handles a transaction that wants to enumerate the availible
    SnapShots for a given share

Arguments:

    WorkContext - The context for the transaction

Return Value:

    NTSTATUS - STATUS_SUCCESS and STATUS_BUFFER_OVERFLOW are expected, and should
       be returned with data.  Any other status code should be returned without data

--*/
{
    NTSTATUS Status;
    ULONG SnapShotCount;
    PLIST_ENTRY listEntry;
    PSHARE Share = WorkContext->TreeConnect->Share;
    PTRANSACTION transaction = WorkContext->Parameters.Transaction;
    PSRV_SNAPSHOT_ARRAY SnapShotArray = (PSRV_SNAPSHOT_ARRAY)transaction->OutData;

    ASSERT(WorkContext->TreeConnect);

    // Check the buffer
    if( transaction->MaxDataCount < sizeof(SRV_SNAPSHOT_ARRAY) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Refresh the SnapShot share list
    Status = SrvSnapRefreshSnapShotsForShare( Share );
    if( !NT_SUCCESS(Status) )
    {
        return Status;
    }

    // Lock the share
    ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

    // Check the buffer size
    SnapShotCount = 0;
    listEntry = Share->SnapShots.Blink;
    while( listEntry != &(Share->SnapShots) )
    {
        SnapShotCount++;
        listEntry = listEntry->Blink;
    }

    // Set the value and check if we will overflow
    SnapShotArray->NumberOfSnapShots = SnapShotCount;
    SnapShotArray->SnapShotArraySize = SNAPSHOT_NAME_LENGTH*SnapShotArray->NumberOfSnapShots+sizeof(WCHAR);
    if( (SnapShotCount == 0) || (transaction->MaxDataCount < SnapShotArray->SnapShotArraySize) )
    {
        // The buffer is not big enough.  Return the required size
        SnapShotArray->NumberOfSnapShotsReturned = 0;
        transaction->DataCount = sizeof(SRV_SNAPSHOT_ARRAY);
        Status = STATUS_SUCCESS;
    }
    else
    {
        // The buffer is big enough.  Fill it in and return it
        PBYTE nameLocation = (PBYTE)SnapShotArray->SnapShotMultiSZ;

        SnapShotCount = 0;
        listEntry = Share->SnapShots.Blink;
        RtlZeroMemory( SnapShotArray->SnapShotMultiSZ, SnapShotArray->SnapShotArraySize );
        while( listEntry != &(Share->SnapShots) )
        {
            PSHARE_SNAPSHOT SnapShot = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            RtlCopyMemory( nameLocation, SnapShot->SnapShotName.Buffer, SNAPSHOT_NAME_LENGTH );
            nameLocation += SNAPSHOT_NAME_LENGTH;
            SnapShotCount++;
            listEntry = listEntry->Blink;
        }

        SnapShotArray->NumberOfSnapShotsReturned = SnapShotArray->NumberOfSnapShots;
        transaction->DataCount = sizeof(SRV_SNAPSHOT_ARRAY)+SnapShotArray->SnapShotArraySize;
        Status = STATUS_SUCCESS;
    }


    // Release the lock
    RELEASE_LOCK( Share->SnapShotLock );

    return Status;
}

NTSTATUS
SrvSnapGetRootHandle(
    IN PWORK_CONTEXT WorkContext,
    OUT HANDLE* RootHandle
    )
/*++

Routine Description:

    This function retrieves the correct Root Handle for an operation given the
    parsed SnapShot timestamp on the WORK_CONTEXT

Arguments:

    WorkContext - The context for the transaction
    RootHandle  - Where to store the resulting handle

Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_NOT_FOUND if the SnapShot is not found

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PSHARE Share;
    PLIST_ENTRY listEntry;
    PSHARE_SNAPSHOT SnapShare;

    ASSERT( WorkContext );
    ASSERT( WorkContext->TreeConnect );
    ASSERT( WorkContext->TreeConnect->Share );
    Share = WorkContext->TreeConnect->Share;

    if( WorkContext->SnapShotTime.QuadPart != 0 )
    {
        //IF_DEBUG( SNAPSHOT ) KdPrint(( "Looking for %x%x\n", WorkContext->SnapShotTime.HighPart, WorkContext->SnapShotTime.LowPart ));

        // Acquire the shared lock
        ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

        // Walk the list and look for the entry
        listEntry = Share->SnapShots.Flink;
        while( listEntry != &Share->SnapShots )
        {
            SnapShare = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            if( SnapShare->Timestamp.QuadPart == WorkContext->SnapShotTime.QuadPart )
            {
                //IF_DEBUG( SNAPSHOT ) KdPrint((" Found %wZ\n", &SnapShare->SnapShotName ));
                *RootHandle = SnapShare->SnapShotRootDirectoryHandle;
                Status = STATUS_SUCCESS;
                break;
            }

            listEntry = listEntry->Flink;
        }

        RELEASE_LOCK( Share->SnapShotLock );
    }
    else
    {
        *RootHandle = Share->RootDirectoryHandle;
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
SrvSnapGetNameString(
    IN PWORK_CONTEXT WorkContext,
    OUT PUNICODE_STRING* ShareName,
    OUT PBOOLEAN AllocatedShareName
    )
/*++

Routine Description:

    This function retrieves the correct Root Handle for an operation given the
    parsed SnapShot timestamp on the WORK_CONTEXT

Arguments:

    WorkContext - The context for the transaction
    ShareName   - The Name of the share
    AllocatedShareName - Whether the ShareName should be freed after use (via FREE_HEAP)

Return Value:

    PUNICODE_STRING - pointer to existing string or NULL
    BUGBUG = Have to take a reference or copy at this point!

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PSHARE Share;
    PLIST_ENTRY listEntry;
    PSHARE_SNAPSHOT SnapShare;
    PUNICODE_STRING SnapShareName;

    ASSERT( WorkContext );
    ASSERT( WorkContext->TreeConnect );
    ASSERT( WorkContext->TreeConnect->Share );
    Share = WorkContext->TreeConnect->Share;

    if( WorkContext->SnapShotTime.QuadPart != 0 )
    {
        //IF_DEBUG( SNAPSHOT ) KdPrint(( "Looking for %x%x\n", WorkContext->SnapShotTime.HighPart, WorkContext->SnapShotTime.LowPart ));

        // Acquire the shared lock
        ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

        // Walk the list and look for the entry
        listEntry = Share->SnapShots.Flink;
        while( listEntry != &Share->SnapShots )
        {
            SnapShare = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            if( SnapShare->Timestamp.QuadPart == WorkContext->SnapShotTime.QuadPart )
            {
                SnapShareName = ALLOCATE_HEAP( sizeof(UNICODE_STRING)+SnapShare->SnapShotPath.Length, BlockTypeSnapShot );
                if( !SnapShareName )
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    *AllocatedShareName = FALSE;
                }
                else
                {
                    SnapShareName->Length = 0;
                    SnapShareName->MaximumLength = SnapShare->SnapShotPath.Length;
                    SnapShareName->Buffer = (PWCHAR)(SnapShareName+1);
                    RtlCopyUnicodeString( SnapShareName, &SnapShare->SnapShotPath );
                    *AllocatedShareName = TRUE;
                    *ShareName = SnapShareName;
                    Status = STATUS_SUCCESS;
                }

                RELEASE_LOCK( Share->SnapShotLock );

                return Status;
            }

            listEntry = listEntry->Flink;
        }

        RELEASE_LOCK( Share->SnapShotLock );

        return Status;
    }
    else
    {
        *ShareName = &WorkContext->TreeConnect->Share->NtPathName;
        *AllocatedShareName = FALSE;
        return STATUS_SUCCESS;
    }
}

BOOLEAN
ExtractNumber(
    IN PWSTR psz,
    IN ULONG Count,
    OUT PLONG value
    )
/*++

Routine Description:

    This function takes a string of characters and parses out a <Count> length decimal
    number.  If it returns TRUE, value has been set and the string was parsed correctly.
    FALSE indicates an error in parsing.

Arguments:

    psz - String pointer
    Count - Number of characters to pull off
    value - pointer to output parameter where value is stored

Return Value:

    BOOLEAN - See description

--*/
{
    *value = 0;

    while( Count )
    {
        if( (*psz == L'\0') ||
            IS_UNICODE_PATH_SEPARATOR( *psz ) )
        {
            //IF_DEBUG( SNAPSHOT ) KdPrint(( "Path Seperator found %d\n", Count ));
            return FALSE;
        }

        if( (*psz < '0') || (*psz > '9') )
        {
            //IF_DEBUG( SNAPSHOT ) KdPrint(( "Non-digit found %x\n", *psz ));
            return FALSE;
        }

        *value = (*value)*10+(*psz-L'0');
        Count--;
        psz++;
    }

    return TRUE;
}


BOOLEAN
SrvSnapParseToken(
    IN PWSTR Source,
    OUT PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:

    This function parses a null-terminated UNICODE file path name string to see if the
    current token is a Snap-designator

Arguments:

    Source - Pointer to the string
    TimeStamp - If this is a SnapShot, this is set to the time value designated by the string

Return Value:

    PUNICODE_STRING - pointer to existing string or NULL

--*/
{
    PWSTR psz = Source;
    UNICODE_STRING NameString;
    ULONG Count = 0;
#define SNAPSHOT_HEADER L"@GMT-"
    PWSTR header = SNAPSHOT_HEADER;
    TIME_FIELDS rtlTime;
    LONG value;

    // Check the SNAP. header
    for( Count=0; Count<wcslen(SNAPSHOT_HEADER); Count++,psz++ )
    {
        if( (toupper(*psz) != header[Count]) ||
            (*psz == L'\0') ||
            IS_UNICODE_PATH_SEPARATOR( *psz ) )
        {
            //IF_DEBUG( SNAPSHOT ) KdPrint(("Count %d (%x != %x)\n", Count, *psz, header[Count] ));
            goto NoMatch;
        }
    }

    // Prepare to parse
    RtlZeroMemory( &rtlTime, sizeof(TIME_FIELDS) );

    // Extract the Year
    if( !ExtractNumber( psz, 4, &value ) )
        goto NoMatch;
    if( psz[4] != L'.' )
        goto NoMatch;
    rtlTime.Year = (CSHORT)value;
    psz += 5;

    // Extract the Month
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'.' )
        goto NoMatch;
    rtlTime.Month = (CSHORT)value;
    psz += 3;

    // Extract the Day
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'-' )
        goto NoMatch;
    rtlTime.Day = (CSHORT)value;
    psz += 3;

    // Extract the Hour
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'.' )
        goto NoMatch;
    rtlTime.Hour = (CSHORT)value;
    psz += 3;

    // Extract the Minutes
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'.' )
        goto NoMatch;
    rtlTime.Minute = (CSHORT)value;
    psz += 3;

    // Extract the Seconds
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( !IS_UNICODE_PATH_SEPARATOR( psz[2] ) &&
        (psz[2] != L'\0') )
        goto NoMatch;
    rtlTime.Second = (CSHORT)value;
    psz += 3;

    RtlTimeFieldsToTime( &rtlTime, TimeStamp );

    return TRUE;

NoMatch:
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvstrng.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    srvstrng.h

Abstract:

    This module defines global string data for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl)    6-Oct-1993

Revision History:

--*/

#ifndef _SRVSTRNG_
#define _SRVSTRNG_

//
// Device prefix strings.
//

extern PWSTR StrNamedPipeDevice;
extern PWSTR StrMailslotDevice;

extern PWSTR StrSlashPipe;
extern PSTR StrSlashPipeAnsi;
extern PWSTR StrSlashPipeSlash;
extern PSTR StrPipeSlash;
extern PWSTR StrSlashMailslot;

//
// Pipe name for remote down-level API requests.
//

extern PWSTR StrPipeApi;
extern PSTR StrPipeApiOem;

extern PWSTR StrNull;
extern PSTR StrNullAnsi;

extern PWSTR StrUnknownClient;

extern PWSTR StrServerDevice;

extern PSTR StrLogonProcessName;
extern PSTR StrLogonPackageName;

extern WCHAR StrStarDotStar[];

extern PSTR StrTransportAddress;
extern PSTR StrConnectionContext;

extern PWSTR StrUserAlertEventName;
extern PWSTR StrAdminAlertEventName;
extern PWSTR StrDefaultSrvDisplayName;
extern PWSTR StrNoNameTransport;

extern PWSTR StrAlerterMailslot;

//
// Registry paths.
//

extern PWSTR StrRegServerPath;
extern PWSTR StrRegSrvDisplayName;
extern PWSTR StrRegOsVersionPath;
extern PWSTR StrRegVersionKeyName;

extern UNICODE_STRING StrRegSrvPnpClientName;

extern PWSTR StrRegSrvParameterPath;
extern PWSTR StrRegExtendedCharsInPath;
extern PWSTR StrRegExtendedCharsInPathValue;
extern PWSTR StrRegNullSessionPipes;
extern PWSTR StrRegNullSessionShares;
extern PWSTR StrRegPipesNeedLicense;
extern PWSTR StrRegNoRemapPipes;
extern PWSTR StrRegEnforceLogoffTimes;
extern PWSTR StrRegDisableDosChecking;

extern PWSTR StrRegErrorLogIgnore;

#if SRVNTVERCHK
extern PWSTR StrRegInvalidDomainNames;
extern PWSTR StrRegAllowedIPAddresses;
#endif

//
// Pipes and shares that are accessible by the NULL session.
//

extern PWSTR StrDefaultNullSessionPipes[];
extern PWSTR StrDefaultNullSessionShares[];

//
// Pipes that are not remapped, even in cluster environments
//
extern PWSTR StrDefaultNoRemapPipeNames[];

//
// DOS device names that can not be accessed by clients
//
extern UNICODE_STRING SrvDosDevices[];

//
// Name of the EA file on FAT
//
extern UNICODE_STRING SrvEaFileName;

//
// Pipes that require a license for access
//
extern PWSTR StrDefaultPipesNeedLicense[];

//
// Error codes that should not be logged
//
extern PWSTR StrDefaultErrorLogIgnore[];

extern PSTR StrDialects[];
extern PWSTR StrClientTypes[];

#if DBG
extern PWSTR StrWriteAndX;
#endif

extern WCHAR StrQuestionMarks[];

#define FS_CDFS L"CDFS"
#define FS_FAT L"FAT"

extern PWSTR StrFsCdfs;
extern PWSTR StrFsFat;

extern PWSTR StrNativeOsPrefix;

extern PWSTR StrDefaultNativeOs;
extern PSTR  StrDefaultNativeOsOem;

extern PWSTR StrNativeLanman;
extern PSTR StrNativeLanmanOem;

//
// Table of service name strings.  This table corresponds to the
// enumerated type SHARE_TYPE.  Keep the two in sync.
//

extern PSTR StrShareTypeNames[];

#endif // ndef _SRVSTRNG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvsupp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvsupp.h

Abstract:

    This module defines support routines for SMB processors for the LAN
    Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989
    David Treadwell (davidtr)

Revision History:

--*/

#ifndef _SRVSUPP_
#define _SRVSUPP_

//#include <ntos.h>

//#include <smb.h>
//#include "smbtypes.h"
//#include "srvblock.h"

//
// Use the same directory separator as the object system uses.
//

// Status code used to signal the need for reauthentication
#define SESSION_EXPIRED_STATUS_CODE STATUS_NETWORK_SESSION_EXPIRED

#define DIRECTORY_SEPARATOR_CHAR ((UCHAR)(OBJ_NAME_PATH_SEPARATOR))
#define UNICODE_DIR_SEPARATOR_CHAR ((WCHAR)(OBJ_NAME_PATH_SEPARATOR))
#define RELATIVE_STREAM_INITIAL_CHAR ((UCHAR)':')

#define IS_ANSI_PATH_SEPARATOR(character) \
            ( character == DIRECTORY_SEPARATOR_CHAR || character == '\0' )
#define IS_UNICODE_PATH_SEPARATOR(character) \
            ( character == UNICODE_DIR_SEPARATOR_CHAR || character == L'\0' )

//
// Access necessary for copying a file.  DO NOT use generic bits here;
// these are used in calls to IoCheckDesiredAccess, which cannot accept
// generic bits for the DesiredAccess.
//

#define SRV_COPY_SOURCE_ACCESS READ_CONTROL | \
                               FILE_READ_DATA | \
                               FILE_READ_ATTRIBUTES | \
                               FILE_READ_EA

#define SRV_COPY_TARGET_ACCESS WRITE_DAC | \
                               WRITE_OWNER | \
                               FILE_WRITE_DATA | \
                               FILE_APPEND_DATA | \
                               FILE_WRITE_ATTRIBUTES | \
                               FILE_WRITE_EA

//
// This type is used to determine the size of the largest directory query
// information structure.
//

typedef union _SRV_QUERY_DIRECTORY_INFORMATION {
    FILE_DIRECTORY_INFORMATION Directory;
    FILE_FULL_DIR_INFORMATION FullDir;
    FILE_BOTH_DIR_INFORMATION BothDir;
    FILE_NAMES_INFORMATION Names;
} SRV_QUERY_DIRECTORY_INFORMATION, *PSRV_QUERY_DIRECTORY_INFORMATION;

//
// Type definition for the structure used by SrvQueryDirectoryFile
// to do its work.  Calling routines must set up a buffer in nonpaged
// pool with enough room for this structure plus other things.  (See
// MIN_SEARCH_BUFFER_SIZE.)
//

typedef struct _SRV_DIRECTORY_INFORMATION {
    HANDLE DirectoryHandle;
    PFILE_DIRECTORY_INFORMATION CurrentEntry;
    ULONG BufferLength;
    struct {
        BOOLEAN Wildcards : 1;
        BOOLEAN ErrorOnFileOpen : 1;
        BOOLEAN OnlySingleEntries : 1;
    };
    LONG Buffer[1];
} SRV_DIRECTORY_INFORMATION, *PSRV_DIRECTORY_INFORMATION;

//
// Type definition for the structure used by SrvQueryEaFile to do its
// work.  Calling routines must set up a buffer in nonpaged pool with
// enough room for this structure and at least a single EA.  An EA may
// be as large as sizeof(FILE_FULL_EA_INFORMATION) +
// (2 ^ (sizeof(UCHAR)*8)) + (2 ^ (sizeof(USHORT)*8)) ~= 65k, so
// calling routines should first query the size of the EAs, then allocate
// a buffer big enough for either all the EAs or a single maximum-sized
// EA.
//

typedef struct _SRV_EA_INFORMATION {
    PFILE_FULL_EA_INFORMATION CurrentEntry;
    ULONG BufferLength;
    ULONG GetEaListOffset;
    LONG Buffer[1];
} SRV_EA_INFORMATION, *PSRV_EA_INFORMATION;

#define MAX_SIZE_OF_SINGLE_EA ( sizeof(FILE_FULL_EA_INFORMATION) + 257 + 65536 )

//
// The directory cache structure used to maintain information about
// core searches between requests.  One of these structures is maintained
// for each file returned.
//

typedef struct _DIRECTORY_CACHE {
    ULONG FileIndex;
    WCHAR UnicodeResumeName[ 12 ];
    USHORT UnicodeResumeNameLength;
} DIRECTORY_CACHE, *PDIRECTORY_CACHE;

//
// Limit the number of files that may be returned on a core search.
//

#define MAX_DIRECTORY_CACHE_SIZE 10

//
// Macros used to determine the search buffer size.  The first three are
// possible buffer sizes, the second two are numbers of files to be returned
// that represent cutoff points for using the different search buffer
// sizes.
//
// An approximate formula for determining the size of the search buffer is:
//
// (maxCount+2) * (sizeof(SRV_QUERY_DIRECTORY_INFORMATION)+13) +
// sizeof(SRV_DIRECTORY_INFORMATION)
//
// where maxCount is the maximum number of files to return.  The +2 is
// a slop factor to account for the possibility of files that to not
// match the search attributes, and the +13 accounts for the size of
// FAT filenames.
//
// Note that the minimum buffer size must include the following factors in
// order to avoid the possibility of not even being able to hold one entry
// with the longest legal filename:
//
//    sizeof(SRV_DIRECTORY_INFORMATION)
//    sizeof(SRV_QUERY_DIRECTORY_INFORMATION) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))
//    sizeof(UNICODE_STRING) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)) + 3
//
// The last factor is needed because SrvIssueQueryDirectoryRequest puts
// the search filename at the end of the buffer.  (The +3 is necessary to
// allow for aligning the UNICODE_STRING on a ULONG boundary.)
//

#define MAX_SEARCH_BUFFER_SIZE 4096
#define MED_SEARCH_BUFFER_SIZE 2048
#define MIN_SEARCH_BUFFER_SIZE                                                                  \
        (sizeof(SRV_DIRECTORY_INFORMATION) +                                                    \
        (sizeof(SRV_QUERY_DIRECTORY_INFORMATION) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))) + \
        (sizeof(UNICODE_STRING) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)) + 3))

#define MAX_FILES_FOR_MED_SEARCH 20
#define MAX_FILES_FOR_MIN_SEARCH 10

//
// The macros for FIND2 have the same meaning as the SEARCH macros except
// that they are used in the FIND2 protocols.
//

#define MAX_FILES_FOR_MED_FIND2 16
#define MAX_FILES_FOR_MIN_FIND2 8

//
// Macros to check context handles for equality and for NULLness
//

#define CONTEXT_EQUAL(x,y)  (((x).dwLower == (y).dwLower) && ((x).dwUpper == (y).dwUpper))
#define CONTEXT_NULL(x)     (((x).dwLower == 0) && ((x).dwUpper == 0))


//
// SMB processing support routines.
//

VOID
SrvAllocateAndBuildPathName(
    IN PUNICODE_STRING Path1,
    IN PUNICODE_STRING Path2,
    IN PUNICODE_STRING Path3 OPTIONAL,
    OUT PUNICODE_STRING BuiltPath
    );

NTSTATUS
SrvCanonicalizePathName(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    );

NTSTATUS
SrvCanonicalizePathNameWithReparse(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    );

VOID
SrvCloseQueryDirectory(
    PSRV_DIRECTORY_INFORMATION DirectoryInformation
    );

NTSTATUS
SrvCheckSearchAttributesForHandle(
    IN HANDLE FileHandle,
    IN USHORT SmbSearchAttributes
    );

NTSTATUS SRVFASTCALL
SrvCheckSearchAttributes(
    IN USHORT FileAttributes,
    IN USHORT SmbSearchAttributes
    );

NTSTATUS
SrvCopyFile(
    IN HANDLE SourceHandle,
    IN HANDLE TargetHandle,
    IN USHORT SmbOpenFunction,
    IN USHORT SmbFlags,
    IN ULONG ActionTaken
    );

NTSTATUS
SrvCreateFile(
    IN PWORK_CONTEXT WorkContext,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PCHAR SmbFileName,
    IN PCHAR EndOfSmbFileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN PULONG EaErrorOffset OPTIONAL,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    );

NTSTATUS
SrvNtCreateFile(
    IN OUT PWORK_CONTEXT WorkContext,
    IN ULONG RootDirectoryFid,
    IN ACCESS_MASK DesiredAccess,
    IN LARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptorBuffer OPTIONAL,
    IN PUNICODE_STRING FileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    ULONG OptionFlags,
    PSECURITY_QUALITY_OF_SERVICE QualityOfService,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    );

VOID
SrvDosTimeToTime(
    OUT PLARGE_INTEGER Time,
    IN SMB_DATE DosDate,
    IN SMB_TIME DosTime
    );

PSHARE
SrvFindShare(
    IN PUNICODE_STRING ShareName
    );

VOID
SrvGetBaseFileName (
    IN PUNICODE_STRING InputName,
    OUT PUNICODE_STRING OutputName
    );

CLONG
SrvGetNumberOfEasInList (
    IN PVOID List
    );

USHORT
SrvGetSubdirectoryLength (
    IN PUNICODE_STRING InputName
    );

NTSTATUS
SrvMakeUnicodeString (
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PUSHORT SourceLength OPTIONAL
    );

USHORT
SrvGetString (
    OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode
    );

USHORT
SrvGetStringLength (
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN IncludeNullTerminator
    );

NTSTATUS
SrvMoveFile(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags,
    IN USHORT SmbSearchAttributes,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount,
    IN PUNICODE_STRING Source,
    IN OUT PUNICODE_STRING Target
    );

VOID
SrvNtAttributesToSmb(
    IN ULONG NtAttributes,
    IN BOOLEAN Directory OPTIONAL,
    OUT PUSHORT SmbAttributes
    );

NTSTATUS
SrvQueryDirectoryFile (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN BOOLEAN FilterLongNames,
    IN BOOLEAN FindWithBackupIntent,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG SearchStorageType,
    IN PUNICODE_STRING FilePathName,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT SmbSearchAttributes,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferLength
    );

NTSTATUS
SrvQueryEaFile (
    IN BOOLEAN IsFirstCall,
    IN HANDLE FileHandle,
    IN PFILE_GET_EA_INFORMATION EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PSRV_EA_INFORMATION EaInformation,
    IN CLONG BufferLength,
    OUT PULONG EaErrorOffset
    );

NTSTATUS
SrvQueryInformationFile (
    IN HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    OUT PSRV_FILE_INFORMATION SrvFileInformation,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN QueryEaSize
    );

NTSTATUS
SrvQueryInformationFileAbbreviated (
    IN HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    OUT PSRV_FILE_INFORMATION_ABBREVIATED SrvFileInformation,
    IN BOOLEAN AdditionalInformation,
    IN SHARE_TYPE ShareType
    );

NTSTATUS
SrvQueryNtInformationFile (
    IN HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN AdditionalInformation,
    OUT PSRV_NT_FILE_INFORMATION SrvFileInformation
    );

NTSTATUS
SrvQueryBasicAndStandardInformation(
    HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    PFILE_BASIC_INFORMATION FileBasicInfo,
    PFILE_STANDARD_INFORMATION FileStandardInfo OPTIONAL
    );

NTSTATUS
SrvQueryNetworkOpenInformation(
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSRV_NETWORK_OPEN_INFORMATION SrvNetworkOpenInformation,
    IN BOOLEAN QueryEaSize
    );

VOID
SrvReleaseContext (
    IN PWORK_CONTEXT WorkContext
    );

BOOLEAN
SrvSetFileWritethroughMode (
    IN PLFCB Lfcb,
    IN BOOLEAN Writethrough
    );

#define SrvSetSmbError( _wc, _status )  { \
    _SrvSetSmbError2( (_wc), (_status), FALSE, __LINE__, __FILE__ );                        \
    }

#define SrvSetSmbError2( _wc, _status, HeaderOnly )  {                  \
    _SrvSetSmbError2( (_wc), (_status), HeaderOnly, __LINE__, __FILE__ );                   \
    }

VOID
_SrvSetSmbError2 (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN BOOLEAN HeaderOnly,
    IN ULONG LineNumber,
    IN PCHAR FileName
    );

VOID
SrvSetBufferOverflowError (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvSmbAttributesToNt (
    IN USHORT SmbAttributes,
    OUT PBOOLEAN Directory,
    OUT PULONG NtAttributes
    );

VOID
SrvTimeToDosTime (
    IN PLARGE_INTEGER Time,
    OUT PSMB_DATE DosDate,
    OUT PSMB_TIME DosTime
    );

USHORT
SrvGetOs2TimeZone(
    IN PLARGE_INTEGER SystemTime
    );

#define SrvVerifyFid(_wc,_fid,_fail,_ser,_status)                 \
    ((_wc)->Rfcb != NULL ?                                                  \
        (_wc)->Rfcb : SrvVerifyFid2(_wc,_fid,_fail,_ser,_status))

PRFCB
SrvVerifyFid2 (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    IN BOOLEAN FailOnSavedError,
    IN PRESTART_ROUTINE SerializeWithRawRestartRoutine OPTIONAL,
    OUT PNTSTATUS NtStatus
    );

#define SRV_INVALID_RFCB_POINTER    ((PRFCB)-1)

PRFCB
SrvVerifyFidForRawWrite (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    OUT PNTSTATUS NtStatus
    );

PSEARCH
SrvVerifySid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Index,
    IN USHORT Sequence,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize
    );

PTREE_CONNECT
SrvVerifyTid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Tid
    );

PSESSION
SrvVerifyUid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Uid
    );

NTSTATUS
SrvVerifyUidAndTid (
    IN PWORK_CONTEXT WorkContext,
    OUT PSESSION *Session,
    OUT PTREE_CONNECT *TreeConnect,
    IN SHARE_TYPE ShareType
    );

NTSTATUS
SrvWildcardRename(
    IN PUNICODE_STRING FileSpec,
    IN PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING TargetString
    );


//
// Security routines.
//

NTSTATUS
SrvValidateUser (
    OUT CtxtHandle *Token,
    IN PSESSION Session OPTIONAL,
    IN PCONNECTION Connection OPTIONAL,
    IN PUNICODE_STRING UserName OPTIONAL,
    IN PCHAR CaseInsensitivePassword,
    IN CLONG CaseInsensitivePasswordLength,
    IN PCHAR CaseSensitivePassword OPTIONAL,
    IN CLONG CaseSensitivePasswordLength,
    IN BOOLEAN SmbSecuritySignatureRequired,
    OUT PUSHORT Action OPTIONAL
    );

NTSTATUS
SrvValidateSecurityBuffer(
    IN PCONNECTION Connection,
    IN OUT PCtxtHandle Handle,
    IN PSESSION Session,
    IN PCHAR Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN SecuritySignaturesRequired,
    OUT PCHAR ReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PLARGE_INTEGER Expiry,
    OUT PCHAR NtUserSessionKey,
    OUT PLUID LogonId,
    OUT PBOOLEAN IsGuest
    );

NTSTATUS
SrvGetExtensibleSecurityNegotiateBuffer(
    OUT PCtxtHandle Token,
    OUT PCHAR Buffer,
    OUT USHORT *BufferLength
    );

NTSTATUS
SrvFreeSecurityContexts (
    IN PSESSION Session
    );

NTSTATUS
AcquireLMCredentials (
    VOID
    );

NTSTATUS
SrvGetUserAndDomainName (
    IN PSESSION Session,
    OUT PUNICODE_STRING UserName OPTIONAL,
    OUT PUNICODE_STRING DomainName OPTIONAL
    );

VOID
SrvReleaseUserAndDomainName (
    IN PSESSION Session,
    IN OUT PUNICODE_STRING UserName OPTIONAL,
    IN OUT PUNICODE_STRING DomainName OPTIONAL
    );

VOID
SrvAddSecurityCredentials(
    IN PANSI_STRING ComputerName,
    IN PUNICODE_STRING DomainName,
    IN DWORD PasswordLength,
    IN PBYTE Password
);

BOOLEAN
SrvIsAdmin(
    CtxtHandle  Handle
    );

BOOLEAN
SrvIsNullSession(
    CtxtHandle  Handle
    );

NTSTATUS
SrvIsAllowedOnAdminShare(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share
    );

NTSTATUS
SrvCheckShareFileAccess(
    IN PWORK_CONTEXT WorkContext,
    IN ACCESS_MASK FileDesiredAccess
    );

NTSTATUS
SrvRetrieveMaximalAccessRightsForUser(
    CtxtHandle              *pUserHandle,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PGENERIC_MAPPING        pMapping,
    PACCESS_MASK            pMaximalAccessRights);

NTSTATUS
SrvRetrieveMaximalAccessRights(
    IN  OUT PWORK_CONTEXT WorkContext,
    OUT     PACCESS_MASK  pMaximalAccessRights,
    OUT     PACCESS_MASK  pGuestMaximalAccessRights);

NTSTATUS
SrvRetrieveMaximalShareAccessRights(
    IN PWORK_CONTEXT WorkContext,
    OUT PACCESS_MASK pMaximalAccessRights,
    OUT PACCESS_MASK pGuestMaximalAccessRights);

NTSTATUS
SrvUpdateMaximalAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    );

NTSTATUS
SrvUpdateMaximalShareAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    );

//
// Share handling routines.
//

PSHARE
SrvVerifyShare (
    IN PWORK_CONTEXT WorkContext,
    IN PSZ ShareName,
    IN PSZ ShareTypeString,
    IN BOOLEAN ShareNameIsUnicode,
    IN BOOLEAN IsNullSession,
    OUT PNTSTATUS Status,
    OUT PUNICODE_STRING ServerName
    );

VOID
SrvRemoveShare(
    PSHARE Share
);

VOID
SrvAddShare(
    PSHARE Share
);

NTSTATUS
SrvShareEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    );

SMB_PROCESSOR_RETURN_TYPE
SrvConsumeSmbData(
    IN OUT PWORK_CONTEXT WorkContext
);

BOOLEAN
SrvIsDottedQuadAddress(
    IN PUNICODE_STRING ServerName
);

//
// Fat name routines.
//

VOID
Srv8dot3ToUnicodeString (
    IN PSZ Input8dot3,
    OUT PUNICODE_STRING OutputString
    );

BOOLEAN SRVFASTCALL
SrvIsLegalFatName (
    IN PWSTR InputName,
    IN CLONG InputNameLength
    );

VOID
SrvOemStringTo8dot3 (
    IN POEM_STRING InputString,
    OUT PSZ Output8dot3
    );

VOID
SrvUnicodeStringTo8dot3 (
    IN PUNICODE_STRING InputString,
    OUT PSZ Output8dot3,
    IN BOOLEAN Upcase
    );

//
// EA conversion support routines.
//

BOOLEAN
SrvAreEasNeeded (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

USHORT
SrvGetOs2FeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEALIST FeaList
    );

USHORT
SrvGetOs2GeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEALIST GeaList
    );

NTSTATUS
SrvOs2FeaListToNt (
    IN PFEALIST FeaList,
    OUT PFILE_FULL_EA_INFORMATION *NtFullEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

ULONG
SrvOs2FeaListSizeToNt (
    IN PFEALIST FeaList
    );

PVOID
SrvOs2FeaToNt (
    OUT PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEA Fea
    );

NTSTATUS
SrvOs2GeaListToNt (
    IN PGEALIST GeaList,
    OUT PFILE_GET_EA_INFORMATION *NtGetEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

ULONG
SrvOs2GeaListSizeToNt (
    IN PGEALIST GeaList
    );

PVOID
SrvOs2GeaToNt (
    OUT PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEA Gea
    );

PVOID
SrvNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

PVOID
SrvNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    );

CLONG
SrvNumberOfEasInList (
    IN PVOID List
    );

NTSTATUS
SrvQueryOs2FeaList (
    IN HANDLE FileHandle,
    IN PGEALIST GeaList OPTIONAL,
    IN PFILE_GET_EA_INFORMATION NtGetEaList OPTIONAL,
    IN ULONG GeaListLength OPTIONAL,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

NTSTATUS
SrvSetOs2FeaList (
    IN HANDLE FileHandle,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

NTSTATUS
SrvConstructNullOs2FeaList (
    IN PFILE_GET_EA_INFORMATION NtGeaList,
    OUT PFEALIST FeaList,
    IN ULONG BufferLength
    );

//
// Named pipe worker functions.
//

SMB_TRANS_STATUS
SrvCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvQueryStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvQueryInformationNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSetStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN
SrvFastTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext,
    OUT SMB_STATUS *SmbStatus
    );

SMB_TRANS_STATUS
SrvRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Transaction worker functions.
//

VOID
SrvCompleteExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_TRANS_STATUS ResultStatus
    );

VOID SRVFASTCALL
SrvRestartExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// XACTSRV support routines.
//

PVOID
SrvXsAllocateHeap(
    IN ULONG SizeOfAllocation OPTIONAL,
    OUT PNTSTATUS Status
    );

NTSTATUS
SrvXsConnect (
    IN PUNICODE_STRING PortName
    );

VOID
SrvXsFreeHeap(
    IN PVOID MemoryToFree OPTIONAL
    );

SMB_TRANS_STATUS
SrvXsRequest (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvXsLSOperation (
    IN PSESSION Session,
    IN ULONG Type
    );

VOID
SrvXsPnpOperation(
    IN PUNICODE_STRING DeviceName,
    IN BOOLEAN Bind
    );

VOID
SrvXsDisconnect();

//
// Oplock support routines.
//

VOID SRVFASTCALL
SrvOplockBreakNotification (
    IN PWORK_CONTEXT WorkContext            // actually, a PRFCB
    );

VOID
SrvFillOplockBreakRequest (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvRestartOplockBreakSend(
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvAcknowledgeOplockBreak (
    IN PRFCB Rfcb,
    IN UCHAR NewOplockLevel
    );

BOOLEAN
SrvRequestOplock (
    IN PWORK_CONTEXT WorkContext,
    IN POPLOCK_TYPE OplockType,
    IN BOOLEAN RequestIIOnFailure
    );

LARGE_INTEGER
SrvGetOplockBreakTimeout (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvSendOplockRequest(
    IN PCONNECTION Connection,
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

VOID SRVFASTCALL
SrvCheckDeferredOpenOplockBreak(
    IN PWORK_CONTEXT WorkContext
    );

//
// Buffer management support
//

BOOLEAN
SrvReceiveBufferShortage(
    VOID
    );

NTSTATUS
SrvIoCreateFile (
    IN PWORK_CONTEXT WorkContext,
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PSHARE Share OPTIONAL
    );

NTSTATUS
SrvNtClose (
    IN HANDLE Handle,
    IN BOOLEAN QuotaCharged
    );

NTSTATUS
SrvVerifyDeviceStackSize(
    IN HANDLE FileHandle,
    IN BOOLEAN ReferenceFileObject,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL
    );

VOID
SrvCheckForBadSlm (
    IN PRFCB Rfcb,
    IN ULONG StartOffset,
    IN PCONNECTION Connection,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Routines used to go to XACTSRV through LPC to issue user-mode APIs.
//

NTSTATUS
SrvOpenPrinter (
    IN PWCH PrinterName,
    OUT PHANDLE phPrinter,
    OUT PULONG Error
    );

NTSTATUS
SrvAddPrintJob (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE Handle,
    OUT PUNICODE_STRING FileName,
    OUT PULONG JobId,
    OUT PULONG Error
    );

NTSTATUS
SrvSchedulePrintJob (
    IN HANDLE PrinterHandle,
    IN ULONG JobId
    );

NTSTATUS
SrvClosePrinter (
    OUT HANDLE Handle
    );

//
// Routines for handling impersonation of remote clients.
//

NTSTATUS
SrvImpersonate (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvRevert (
    VOID
    );

//
// Routine for setting the last write time on a file given the last
// write time in seconds since 1970.
//

#ifdef INCLUDE_SMB_IFMODIFIED
NTSTATUS
SrvSetLastWriteTime (
    IN PRFCB Rfcb,
    IN ULONG LastWriteTimeInSeconds,
    IN ACCESS_MASK GrantedAccess,
    IN BOOLEAN ForceChanges
    );
#else
NTSTATUS
SrvSetLastWriteTime (
    IN PRFCB Rfcb,
    IN ULONG LastWriteTimeInSeconds,
    IN ACCESS_MASK GrantedAccess
    );
#endif

ULONG
SrvLengthOfStringInApiBuffer (
    IN PUNICODE_STRING UnicodeString
    );

//
// Routine for updating quality of service information for a vc
//

VOID
SrvUpdateVcQualityOfService(
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime OPTIONAL
    );

//
// Routines for obtaining and releasing share root directory handles
// for removable devices
//


VOID
SrvFillInFileSystemName(
            IN PSHARE Share,
            IN PWSTR FileSystemName,
            IN ULONG FileSystemNameLength
            );

NTSTATUS
SrvGetShareRootHandle(
    IN PSHARE Share
    );

BOOLEAN
SrvRefreshShareRootHandle (
    IN PSHARE Share,
    OUT PNTSTATUS Status
    );

VOID
SrvReleaseShareRootHandle(
    IN PSHARE Share
    );

//
// SMB validation routine.
//

BOOLEAN SRVFASTCALL
SrvValidateSmb (
    IN PWORK_CONTEXT WorkContext
    );

//
// Check on saved error.
//

NTSTATUS
SrvCheckForSavedError(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    );

//
// Read registry parameters.
//

VOID
SrvGetMultiSZList(
    PWSTR **ListPointer,
    PWSTR BaseKeyName,
    PWSTR ParameterKeyName,
    PWSTR *DefaultPointerValue
    );

//
// Read server display name from the registry.
//

VOID
SrvGetAlertServiceName(
    VOID
    );

//
// Read OS version string from registry.
//

VOID
SrvGetOsVersionString(
    VOID
    );

//
// Queues up blocks for later cleanup
//

VOID
DispatchToOrphanage(
    IN PQUEUEABLE_BLOCK_HEADER Block
    );

#ifdef INCLUDE_SMB_IFMODIFIED
NTSTATUS
SrvGetUsnInfoForFile(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb,
    IN BOOLEAN SubmitClose,
    OUT PLARGE_INTEGER Usn,
    OUT PLARGE_INTEGER FileRefNumber
    );

#define QuadAlign(P) (             \
    ((((P)) + 7) & (-8)) \
)
#endif

#ifdef INCLUDE_SMB_PERSISTENT
NTSTATUS
SrvSetupPersistentShare (
    IN OUT PSHARE Share,
    IN BOOLEAN Restore
    );

NTSTATUS
SrvClosePersistentShare (
    IN OUT PSHARE Share,
    IN BOOLEAN ClearState
    );

SMB_STATUS
SrvPostPersistentOpen (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_STATUS SmbStatus
    );
#endif
#endif // def _SRVSUPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvstat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvstat.c

Abstract:

    Contains data and modules for error handling.

Author:

    David Treadwell (davidtr)    10-May-1990

Revision History:

--*/

#include "precomp.h"
#include "srvstat.tmh"
#pragma hdrstop

#define DISK_HARD_ERROR 0x38

VOID
MapErrorForDosClient (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG Error,
    OUT PUSHORT DosError,
    OUT PUCHAR DosErrorClass
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _SrvSetSmbError2 )
#pragma alloc_text( PAGE, MapErrorForDosClient )
#pragma alloc_text( PAGE8FIL, SrvSetBufferOverflowError )

#if DBG
#pragma alloc_text( PAGE, SrvLogBuffer )
#endif

#endif


VOID
_SrvSetSmbError2 (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN BOOLEAN HeaderOnly,
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    Loads error information into a response SMB.  If the client is
    NT, the status is placed directly into the outgoing SMB.  If
    the client is DOS or OS/2 and this is a special status code that
    has the DOS/OS|2/SMB error code embedded, put the code and class
    from the status code into the outgoing SMB.  If that doesn't work,
    use RtlNtStatusToDosError to try to map the status to an OS/2
    error code, then map to DOS if necessary.  If we still haven't
    mapped it, use our own array to try to find a mapping.  And,
    finally, if that doesn't work, return the generic error code.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the negotiated dialect for the connection, and
        the ResponseHeader and ResponseParameter pointers are used
        to determine where to write the error information.

    Status - Supplies an NT status code.

Return Value:

    None.

--*/

{
    PSMB_HEADER header = WorkContext->ResponseHeader;
    PSMB_PARAMS params = WorkContext->ResponseParameters;
    SMB_DIALECT smbDialect;

    ULONG error;
    CCHAR errorClass;
    USHORT errorCode;
    USHORT flags;

    PAGED_CODE( );

    IF_DEBUG( ERRORS ) {                                                \
        KdPrint(( "SrvSetSmbError %X (%s,%d)\n",Status,File,Line )); \
    }                                                                   

    smbDialect = WorkContext->Connection->SmbDialect;

    //
    // Update the SMB body, if necessary.
    //

    if ( !HeaderOnly ) {
        params->WordCount = 0;
        SmbPutUshort( &params->ByteCount, 0 );
        WorkContext->ResponseParameters = (PVOID)(params + 1);
    }

    //
    // If the status code is a real NT status, then either return it
    // directly to the client or map it to a Win32 error code.
    //

    if ( !SrvIsSrvStatus( Status ) ) {

        //
        // Map STATUS_INSUFFICIENT_RESOURCES to the server form.  If we
        // get an insufficient resources error from the system, we
        // report it as a server shortage.  This helps keep things
        // clearer for the client.
        //

        if ( Status == STATUS_INSUFFICIENT_RESOURCES ) {
            Status = STATUS_INSUFF_SERVER_RESOURCES;
        }

        if ( CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) ) {

            //
            // The client understands NT status codes.  Load the status
            // directly into the SMB header.
            //

            SmbPutUlong( (PULONG)&header->ErrorClass, Status );

            flags = SmbGetAlignedUshort( &header->Flags2 ) | SMB_FLAGS2_NT_STATUS;
            SmbPutAlignedUshort( &header->Flags2, flags );

            return;

        }

        //
        // This is an NT status, but the client doesn't understand them.
        // Indicate that we're not returning an NT status code.  Then
        // map the NT status to a Win32 status.  Some NT status codes
        // require special mapping.
        //

        flags = SmbGetAlignedUshort( &header->Flags2 ) & ~SMB_FLAGS2_NT_STATUS;
        SmbPutAlignedUshort( &header->Flags2, flags );

        switch ( Status ) {

        case STATUS_TIMEOUT:
            header->ErrorClass = SMB_ERR_CLASS_SERVER;
            SmbPutUshort( &header->Error, SMB_ERR_TIMEOUT );
            return;

        case STATUS_INVALID_SYSTEM_SERVICE:

            //
            // This status code is returned by XACTSRV when an invalid API
            // number is specified.
            //

            header->ErrorClass = SMB_ERR_CLASS_DOS;
            SmbPutUshort( &header->Error, NERR_InvalidAPI );
            return;

        case STATUS_PATH_NOT_COVERED:
            //
            // This code indicates that the server does not cover this part
            // of the DFS namespace.
            //
            header->ErrorClass = SMB_ERR_CLASS_SERVER;
            SmbPutUshort( &header->Error, SMB_ERR_BAD_PATH );
            return;

        default:

            //
            // This is not a special status code.  Map the NT status
            // code to a Win32 error code.  If there is no mapping,
            // return the generic SMB error.
            //

            error = RtlNtStatusToDosErrorNoTeb( Status );

            if ( error == ERROR_MR_MID_NOT_FOUND || error == (ULONG)Status ) {
                header->ErrorClass = SMB_ERR_CLASS_HARDWARE;
                SmbPutUshort( &header->Error, SMB_ERR_GENERAL );
                return;
            }

            //
            // We now have a Win32 error.  Drop through to the code
            // that maps Win32 errors for downlevel clients.
            //

            break;

        }

    } else {

        //
        // The status code is not an NT status.  Deal with it based on
        // the error class.
        //

        errorClass = SrvErrorClass( Status );

        //
        // Clear the FLAGS2_NT_STATUS bit to indicate that this is *not* an
        // NT_STATUS
        //

        flags = SmbGetAlignedUshort( &header->Flags2 ) & ~SMB_FLAGS2_NT_STATUS;
        SmbPutAlignedUshort( &header->Flags2, flags );

        switch ( errorClass ) {

        case SMB_ERR_CLASS_DOS:
        case SMB_ERR_CLASS_SERVER:
        case SMB_ERR_CLASS_HARDWARE:

            //
            // The status code has the SMB error class and code
            // embedded.
            //

            header->ErrorClass = errorClass;

            //
            // Because SMB_ERR_NO_SUPPORT in the SERVER class is 0xFFFF
            // (16 bits), we must special-case for it.  The code
            // SMB_ERR_NO_SUPPORT_INTERNAL in the error code field of
            // the status, along with class = 2 (SERVER), indicates that
            // we should use SMB_ERR_NO_SUPPORT.
            //

            if ( errorClass == SMB_ERR_CLASS_SERVER &&
                 SrvErrorCode( Status ) == SMB_ERR_NO_SUPPORT_INTERNAL ) {
                SmbPutUshort( &header->Error, SMB_ERR_NO_SUPPORT );
            } else {
                SmbPutUshort( &header->Error, SrvErrorCode( Status ) );
            }

            return;

        case 0xF:

            //
            // The error code is defined in OS/2 but not in the SMB
            // protocol.  If the client is speaking a dialect after
            // LanMan 1.0 and is not a DOS client, send the OS/2 error
            // code.  Otherwise, send the generic SMB error code.
            //

            if ( smbDialect <= SmbDialectLanMan10 &&
                 !IS_DOS_DIALECT(smbDialect) ) {
                header->ErrorClass = SMB_ERR_CLASS_DOS;
                SmbPutUshort( &header->Error, SrvErrorCode( Status ) );
            } else {
                header->ErrorClass = SMB_ERR_CLASS_HARDWARE;
                SmbPutUshort( &header->Error, SMB_ERR_GENERAL );
            }

            return;

        case 0xE:

            //
            // This is a Win32 error.  Drop through to the code that
            // maps Win32 errors for downlevel clients.
            //

            error = SrvErrorCode( Status );

            break;

        case 0x0:
        default:

            //
            // This is an internal server error (class 0) or some other
            // undefined class.  We should never get here.  But since we
            // did, return the generic error.
            //

            KdPrint(( "SRV: Unmapped error: %lx\n", Status ));
            header->ErrorClass = SMB_ERR_CLASS_HARDWARE;
            SmbPutUshort( &header->Error, SMB_ERR_GENERAL );

            return;

        }

    }

    //
    // At this point we have a Win32 error code and need to map it for
    // the downlevel client.  Some errors need to be specially mapped.
    //

    errorClass = SMB_ERR_CLASS_DOS;

    switch ( error ) {

    case ERROR_NOT_ENOUGH_SERVER_MEMORY:
        error = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        error = ERROR_BUFFER_OVERFLOW;
        break;

    case ERROR_ACCOUNT_LOCKED_OUT:
    case ERROR_PRIVILEGE_NOT_HELD:
    case ERROR_NO_SUCH_USER:
    case ERROR_LOGON_FAILURE:
    case ERROR_LOGON_TYPE_NOT_GRANTED:
    case ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
    case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
    case ERROR_NOLOGON_SERVER_TRUST_ACCOUNT:
    case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
    case ERROR_TRUSTED_DOMAIN_FAILURE:
    case ERROR_TRUST_FAILURE:
    case ERROR_NO_TRUST_SAM_ACCOUNT:
    case ERROR_NO_TRUST_LSA_SECRET:
        error = ERROR_ACCESS_DENIED;
        break;

    //
    // For the following four errors, we return an ERROR_ACCESS_DENIED
    // for clients older than doslm20.  The error class for these
    // must be SMB_ERR_CLASS_SERVER.
    //

    case ERROR_INVALID_LOGON_HOURS:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_InvalidLogonHours;
        }
        break;

    case ERROR_INVALID_WORKSTATION:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_InvalidWorkstation;
        }
        break;

    case ERROR_ACCOUNT_DISABLED:
    case ERROR_ACCOUNT_EXPIRED:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_AccountExpired;
        }
        break;

    case ERROR_PASSWORD_MUST_CHANGE:
    case ERROR_PASSWORD_EXPIRED:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_PasswordExpired;
        }
        break;

    //
    // The only NERR codes that DOSLM20 understands are the 4 above.
    // According to larryo, the rest of the NERR codes have to be
    // mapped to ERROR_ACCESS_DENIED.
    //

    case ERROR_NETLOGON_NOT_STARTED:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan21) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            error = NERR_NetlogonNotStarted;
        }
        break;

    case ERROR_NO_LOGON_SERVERS:
        if ( IS_DOS_DIALECT(smbDialect) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            error = NERR_LogonServerNotFound;
        }
        break;

    case ERROR_DIR_NOT_EMPTY:
        if ( IS_DOS_DIALECT(smbDialect) ) {
            error = ERROR_ACCESS_DENIED;
        }
        break;

    default:
        break;

    }

    //
    // Now map the error to a DOS or OS/2 error code.
    //

    if ( error == ERROR_ACCESS_DENIED &&
         smbDialect == SmbDialectDosLanMan21 &&
         WorkContext->ShareAclFailure ) {

        //
        // WfW & DOS LM2.1 want SMB_ERR_ACCESS to be in the server
        // error class when it's due to ACL restrictions, but in the
        // DOS class otherwise.
        //
        errorClass = SMB_ERR_CLASS_SERVER;
        errorCode = SMB_ERR_ACCESS;

    } else if ( smbDialect > SmbDialectLanMan10 ) {

        MapErrorForDosClient(
            WorkContext,
            error,
            &errorCode,
            &errorClass
            );

    } else if ( (error > ERROR_ARITHMETIC_OVERFLOW) &&
                ((error < NERR_BASE) || (error > MAX_NERR)) ) {

        //
        // Win32 errors above ERROR_ARITHMETIC_OVERFLOW (but not in the
        // NERR_xxx range) do not map to DOS or OS/2 errors, so we
        // return the generic error for those.
        //

        errorClass = SMB_ERR_CLASS_HARDWARE;
        errorCode = SMB_ERR_GENERAL;

    } else {

        errorCode = (USHORT)error;

    }

    header->ErrorClass = errorClass;
    SmbPutUshort( &header->Error, errorCode );

    return;

} // _SrvSetSmbError2


VOID
MapErrorForDosClient (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG Error,
    OUT PUSHORT DosError,
    OUT PUCHAR DosErrorClass
    )

/*++

Routine Description:

    Maps an Win32 error to a DOS error.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.

    Error - the Win32 error code to map.

    DosError - the corresponding DOS error.

    DosErrorClass - the error class to put in the outgoing SMB.

Return Value:

    None.

--*/

{
    PSMB_HEADER header = WorkContext->ResponseHeader;

    PAGED_CODE( );

    //
    // Default to using the initial error code and the win32 error.
    //

    *DosError = (USHORT)Error;
    *DosErrorClass = SMB_ERR_CLASS_DOS;

    //
    // If the error is more recent and not part of the set of DOS errors
    // (value greater than ERROR_NET_WRITE_FAULT) and the SMB command is
    // not a newer SMB (errors for these get mapped by the newer DOS
    // redir that sent them), then map the OS/2 error to the DOS range.
    // This code was lifted from the ring 3 OS/2 server.
    //

    if ( Error > ERROR_NET_WRITE_FAULT &&
         !( header->Command == SMB_COM_COPY ||
            header->Command == SMB_COM_MOVE ||
            header->Command == SMB_COM_TRANSACTION ||
            header->Command == SMB_COM_TRANSACTION_SECONDARY ) ) {

        switch( Error ) {

        case ERROR_OPEN_FAILED:

            *DosError = ERROR_FILE_NOT_FOUND;
            break;

        case ERROR_BUFFER_OVERFLOW:
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_INVALID_NAME:
        case ERROR_INVALID_LEVEL:
        case ERROR_SEEK_ON_DEVICE:

            //
            // These don't get mapped to anything.  No explanation was
            // given in the ring 3 code.
            //

            break;

        case ERROR_BAD_EXE_FORMAT:
        case ERROR_INVALID_STARTING_CODESEG:
        case ERROR_INVALID_STACKSEG:
        case ERROR_INVALID_MODULETYPE:
        case ERROR_INVALID_EXE_SIGNATURE:
        case ERROR_EXE_MARKED_INVALID:
        case ERROR_ITERATED_DATA_EXCEEDS_64k:
        case ERROR_INVALID_MINALLOCSIZE:
        case ERROR_DYNLINK_FROM_INVALID_RING:
        case ERROR_IOPL_NOT_ENABLED:
        case ERROR_INVALID_SEGDPL:
        case ERROR_AUTODATASEG_EXCEEDS_64k:
        case ERROR_RING2SEG_MUST_BE_MOVABLE:
        case ERROR_RELOC_CHAIN_XEEDS_SEGLIM:
        case ERROR_INFLOOP_IN_RELOC_CHAIN:
        //case ERROR_BAD_DYNALINK:
        case ERROR_TOO_MANY_MODULES:

            //
            // About these, the ring 3 server code says "map to bad
            // format errors." Whatever that means.  It doesn't do
            // anything with them, so we don't either.
            //

            break;

        case ERROR_DISK_CHANGE:

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = ERROR_WRONG_DISK;
            break;

        case ERROR_DRIVE_LOCKED:

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = ERROR_NOT_READY;
            break;

        case ERROR_ALREADY_EXISTS:

            *DosError = ERROR_FILE_EXISTS;
            break;

        case ERROR_DISK_FULL:

            //
            // Per LarryO, map to the "old" disk full error code.
            //

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = ERROR_HANDLE_DISK_FULL;
            break;

        case ERROR_NO_MORE_SEARCH_HANDLES:

            *DosError = ERROR_OUT_OF_STRUCTURES;
            break;

        case ERROR_INVALID_TARGET_HANDLE:

            *DosError = ERROR_INVALID_HANDLE;
            break;

        case ERROR_BROKEN_PIPE:
        case ERROR_BAD_PIPE:
        case ERROR_PIPE_BUSY:
        case ERROR_NO_DATA:
        case ERROR_PIPE_NOT_CONNECTED:
        case ERROR_MORE_DATA:

            //
            // If this is a pipe share, return these unmolested.  If
            // it's not a pipe share, so map to the generic error.
            //

            if ( (WorkContext->Rfcb != NULL &&
                  WorkContext->Rfcb->ShareType == ShareTypePipe)
                               ||
                 (WorkContext->TreeConnect != NULL &&
                  WorkContext->TreeConnect->Share->ShareType == ShareTypePipe) ) {

                break;

            } else {

                *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
                *DosError = SMB_ERR_GENERAL;
            }

            break;

        case ERROR_BAD_PATHNAME:
            break;

        //
        // The following error mappings (not including default) were not
        // copied from the OS/2 server mapping.
        //

        case ERROR_LOCK_FAILED:
        case ERROR_NOT_LOCKED:
            *DosError = ERROR_LOCK_VIOLATION;
            break;

        case NERR_InvalidLogonHours:
        case NERR_InvalidWorkstation:
        case NERR_PasswordExpired:
        case NERR_AccountUndefined:
        case ERROR_ACCESS_DENIED:
            *DosError = ERROR_ACCESS_DENIED;
            break;

        default:

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = SMB_ERR_GENERAL;
        }
    }

    //
    // The DOS redirector uses the reserved field for the hard error action.
    // Set it now.
    //

    if ( *DosErrorClass == SMB_ERR_CLASS_HARDWARE ) {
        WorkContext->ResponseHeader->Reserved = DISK_HARD_ERROR;
    }

} // MapErrorForDosClient


VOID
SrvSetBufferOverflowError (
    IN PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header = WorkContext->ResponseHeader;
    USHORT flags = SmbGetAlignedUshort( &header->Flags2 );

    UNLOCKABLE_CODE( 8FIL );

    if ( CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) ) {
        SmbPutUlong(
            (PULONG)&header->ErrorClass,
            (ULONG)STATUS_BUFFER_OVERFLOW
            );
        flags |= SMB_FLAGS2_NT_STATUS;
    } else {
        header->ErrorClass = SMB_ERR_CLASS_DOS;
        SmbPutUshort( &header->Error, ERROR_MORE_DATA );
        flags &= ~SMB_FLAGS2_NT_STATUS;
    }
    SmbPutAlignedUshort( &header->Flags2, flags );

    return;

} // SrvSetBufferOverflowError


#if DBG
VOID
SrvLogBuffer( PCHAR msg, PVOID buf, ULONG len )
{
    NTSTATUS status;
    HANDLE handle;
    IO_STATUS_BLOCK iosb;
    OBJECT_ATTRIBUTES objectAttributes;
    PUCHAR buffer;
    ULONG n = 0;
    ULONG i;
    UNICODE_STRING name;

    PAGED_CODE();

    if( msg ) {
        n = strlen( msg );
    }

    buffer = ALLOCATE_HEAP( 4*len + n, BlockTypeDataBuffer );
    if( buffer == NULL ) {
        return;
    }

    buffer[ 0 ] = '\n';

    if( msg ) {
        RtlCopyMemory( &buffer[1], msg, n );
        n++;
        buffer[ n++ ] = '\n';
    }

    for( i=0; i < len && n < 4*len; ) {

        UCHAR c = ((PUCHAR)buf)[ i ];

/*
        if( (c >= 'A' && c <= 'Z') ||
            (c >= 'a' && c <= 'z') ||
            ( c == ' ' || c == ';' || c == ':' || c == ',' || c == '.' ) ||
            ( c >= '0' && c <= '9' ) ) {
            buffer[ n++ ] = c;
            buffer[ n++ ] = ' ';
        }
        else
*/
        {
            buffer[n++] = "0123456789abcdef"[ (c>>4) & 0xf ];
            buffer[n++] = "0123456789abcdef"[ c & 0xf ];
        }

        buffer[n++] = ' ';

        ++i;

        if( (i%16) == 0 ) {
            buffer[ n++ ] = '\n';
        }
    }

    if( n < 4*len ) {
        buffer[ n++ ] = '\n';
        buffer[ n++ ] = '\n';
    }

    name.Length = 44;
    name.MaximumLength = name.Length;
    name.Buffer = L"\\DosDevices\\C:\\Srv.Log";

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        &handle,
        FILE_APPEND_DATA,                   // desired access
        &objectAttributes,
        &iosb,
        NULL,                               // AllocationSize OPTIONAL
        FILE_ATTRIBUTE_NORMAL,              // FileAttributes
        FILE_SHARE_WRITE | FILE_SHARE_READ, // ShareAccess
        FILE_OPEN_IF,                       // Create dispisition
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,            // Create options
        NULL,                               // EaBuffer
        0                                   // EaLength
        );

    if( NT_SUCCESS( status ) ) {

        NtWriteFile( handle,
                     NULL,
                     NULL,
                     NULL,
                     &iosb,
                     buffer,
                     n,
                     NULL,
                     NULL
                   );

        NtClose( handle );
    }

    FREE_HEAP( buffer );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvstrng.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    srvstrng.c

Abstract:

    This module defines global string data for the LAN Manager server.
    The globals defined herein are part of the server driver image, and
    are therefore loaded into the system address space and are
    nonpageable.

Author:

    Chuck Lenzmeier (chuckl)    6-Oct-1993

Revision History:

--*/

#include "precomp.h"
#include "srvstrng.tmh"
#pragma hdrstop

//
// Device prefix strings.
//

PWSTR StrNamedPipeDevice = L"\\Device\\NamedPipe\\";
PWSTR StrMailslotDevice = L"\\Device\\Mailslot\\";

PWSTR StrSlashPipe = UNICODE_SMB_PIPE_PREFIX;
PSTR StrSlashPipeAnsi = SMB_PIPE_PREFIX;
PWSTR StrSlashPipeSlash = L"\\PIPE\\";
PSTR StrPipeSlash = CANONICAL_PIPE_PREFIX;
PWSTR StrSlashMailslot = UNICODE_SMB_MAILSLOT_PREFIX;

//
// Pipe name for remote down-level API requests.
//

PWSTR StrPipeApi = L"\\PIPE\\LANMAN";
PSTR StrPipeApiOem = "\\PIPE\\LANMAN";

PWSTR StrNull = L"";
PSTR StrNullAnsi = "";

PWSTR StrUnknownClient = L"(?)";

PWSTR StrServerDevice = SERVER_DEVICE_NAME;

PSTR StrLogonProcessName = "LAN Manager Server";
PSTR StrLogonPackageName = MSV1_0_PACKAGE_NAME;

WCHAR StrStarDotStar[] = L"*.*";

PSTR StrTransportAddress = TdiTransportAddress;
PSTR StrConnectionContext = TdiConnectionContext;

PWSTR StrUserAlertEventName = ALERT_USER_EVENT;
PWSTR StrAdminAlertEventName = ALERT_ADMIN_EVENT;
PWSTR StrDefaultSrvDisplayName = SERVER_DISPLAY_NAME;
PWSTR StrNoNameTransport = L"<No Name>";

PWSTR StrAlerterMailslot = L"\\Device\\Mailslot\\Alerter";

//
// Registry paths.
//

PWSTR StrRegServerPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer";
PWSTR StrRegSrvDisplayName = L"DisplayName";

PWSTR StrRegOsVersionPath = L"\\Registry\\Machine\\Software\\Microsoft\\Windows Nt\\CurrentVersion";
PWSTR StrRegVersionKeyName = L"CurrentVersion";

PWSTR StrRegSrvParameterPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
PWSTR StrRegExtendedCharsInPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem";
PWSTR StrRegExtendedCharsInPathValue = L"NtfsAllowExtendedCharacterIn8dot3Name";
PWSTR StrRegNullSessionPipes = L"NullSessionPipes";
PWSTR StrRegNullSessionShares = L"NullSessionShares";
PWSTR StrRegPipesNeedLicense = L"PipesNeedLicense";
PWSTR StrRegNoRemapPipes = L"NoRemapPipes";
PWSTR StrRegEnforceLogoffTimes = L"EnforceLogoffTimes";
PWSTR StrRegDisableDosChecking = L"DisableDoS";

UNICODE_STRING StrRegSrvPnpClientName = { 24, 24, L"LanManServer" };

PWSTR StrRegErrorLogIgnore = L"ErrorLogIgnore";

#if SRVNTVERCHK
PWSTR StrRegInvalidDomainNames = L"InvalidDomainsForNt5Clients";
PWSTR StrRegAllowedIPAddresses = L"ValidNT5IPAddr";
#endif

//
// Pipes that are never remapped, even when running on clusters (see open.c::RemapPipeName())
//
STATIC
PWSTR StrDefaultNoRemapPipeNames[] = {
    L"netlogon",
    L"lsarpc",
    L"samr",
    L"browser",
    L"srvsvc",
    L"wkssvc",
    NULL
};

//
// Pipes that are accessible by the NULL session.
//

STATIC
PWSTR StrDefaultNullSessionPipes[] = {
    L"netlogon",
    L"lsarpc",
    L"samr",
    L"browser",
    L"srvsvc",
    L"wkssvc",
    NULL
};

//
// Shares that are accessible by the NULL session.
//

STATIC
PWSTR StrDefaultNullSessionShares[] = {
    NULL
};

//
// DOS device names that can not be accessed by clients
//
UNICODE_STRING SrvDosDevices[] = {
    { 8, 8, L"LPT1"},
    { 8, 8, L"LPT2"},
    { 8, 8, L"LPT3"},
    { 8, 8, L"LPT4"},
    { 8, 8, L"LPT5"},
    { 8, 8, L"LPT6"},
    { 8, 8, L"LPT7"},
    { 8, 8, L"LPT8"},
    { 8, 8, L"LPT9"},
    { 8, 8, L"COM1"},
    { 8, 8, L"COM2"},
    { 8, 8, L"COM3"},
    { 8, 8, L"COM4"},
    { 8, 8, L"COM5"},
    { 8, 8, L"COM6"},
    { 8, 8, L"COM7"},
    { 8, 8, L"COM8"},
    { 8, 8, L"COM9"},
    { 6, 6, L"PRN" },
    { 6, 6, L"AUX" },
    { 6, 6, L"NUL" },
    { 6, 6, L"CON" },
    { 12, 12, L"CLOCK$" },
    {0}
};

//
// Name of EA data file on FAT
//
UNICODE_STRING SrvEaFileName = { 22, 22, L"EA DATA. SF" };

//
// Pipes that require a license from the license server.
//
STATIC
PWSTR StrDefaultPipesNeedLicense[] = {
    L"spoolss",
    NULL
};

//
// Error codes that should not be logged
//
STATIC
PWSTR StrDefaultErrorLogIgnore[] = {
    L"C0000001",    //STATUS_UNSUCCESSFUL
    L"C000013B",    //STATUS_LOCAL_DISCONNECT
    L"C000013C",    //STATUS_REMOTE_DISCONNECT
    L"C000013E",    //STATUS_LINK_FAILED
    L"C000013F",    //STATUS_LINK_TIMEOUT
    L"C00000B0",    //STATUS_PIPE_DISCONNECTED
    L"C00000B1",    //STATUS_PIPE_CLOSING
    L"C0000121",    //STATUS_CANNOT_DELETE
    L"C00000B5",    //STATUS_IO_TIMEOUT
    L"C0000120",    //STATUS_CANCELLED
    L"C0000034",    //STATUS_OBJECT_NAME_NOT_FOUND
    L"C000003A",    //STATUS_OBJECT_PATH_NOT_FOUND
    L"C0000022",    //STATUS_ACCESS_DENIED
    L"C000013B",    //STATUS_LOCAL_DISCONNECT
    L"C000013C",    //STATUS_REMOTE_DISCONNECT
    L"C000013E",    //STATUS_LINK_FAILED
    L"C000020C",    //STATUS_CONNECTION_DISCONNECTED
    L"C0000241",    //STATUS_CONNECTION_ABORTED
    L"C0000140",    //STATUS_INVALID_CONNECTION
    L"C000023A",    //STATUS_CONNECTION_INVALID
    L"C000020D",    //STATUS_CONNECTION_RESET
    L"C00000B5",    //STATUS_IO_TIMEOUT
    L"C000023C",    //STATUS_NETWORK_UNREACHABLE
    L"C0000120",    //STATUS_CANCELLED
    L"C000013F",    //STATUS_LINK_TIMEOUT
    L"C0000008",    //STATUS_INVALID_HANDLE
    L"C000009A",    //STATUS_INSUFFICIENT_RESOURCES
    0
};

//
// StrDialects[] holds ASCII strings corresponding to the dialects
// that the NT LanMan server can speak.  They are listed in descending
// order of preference, so the first listed is the one we'd most like to
// use.  This array should match the SMB_DIALECT enum in inc\smbtypes.h
//

STATIC
PSTR StrDialects[] = {
    CAIROX,                         // Cairo
#ifdef INCLUDE_SMB_IFMODIFIED
    NTLANMAN2,                      // NT LanMan2
#endif
    NTLANMAN,                       // NT LanMan
    LANMAN21,                       // OS/2 LanMan 2.1
    DOSLANMAN21,                    // DOS LanMan 2.1
    LANMAN12,                       // OS/2 1.2 LanMan 2.0
    DOSLANMAN12,                    // DOS LanMan 2.0
    LANMAN10,                       // 1st version of full LanMan extensions
    MSNET30,                        // Larger subset of LanMan extensions
    MSNET103,                       // Limited subset of LanMan extensions
    PCLAN1,                         // Alternate original protocol
    PCNET1,                         // Original protocol
    "ILLEGAL",
};

//
// StrClientTypes[] holds strings mapping dialects to client versions.
//

STATIC
PWSTR StrClientTypes[] = {
    L"Cairo",
#ifdef INCLUDE_SMB_IFMODIFIED
    L"NT2",
#endif
    L"NT",
    L"OS/2 LM 2.1",
    L"DOS LM 2.1",
    L"OS/2 LM 2.0",
    L"DOS LM 2.0",
    L"OS/2 LM 1.0",
    L"DOS LM",
    L"DOWN LEVEL"
};

#if DBG
PWSTR StrWriteAndX = L"WriteAndX";
#endif

WCHAR StrQuestionMarks[] = L"????????.???";

PWSTR StrFsCdfs = FS_CDFS;
PWSTR StrFsFat = FS_FAT;

PWSTR StrNativeOsPrefix =         L"Windows ";

PWSTR StrDefaultNativeOs =        L"Windows 2000";
PSTR  StrDefaultNativeOsOem =      "Windows 2000";

PWSTR StrNativeLanman =         L"Windows 2000 LAN Manager";
PSTR  StrNativeLanmanOem =       "Windows 2000 LAN Manager";

//
// Table of service name strings.  This table corresponds to the
// enumerated type SHARE_TYPE.  Keep the two in sync.
//

PSTR StrShareTypeNames[] = {
    SHARE_TYPE_NAME_DISK,
    SHARE_TYPE_NAME_PRINT,
    SHARE_TYPE_NAME_PIPE,
    SHARE_TYPE_NAME_WILD,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvtyp32.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvtyp32.h

Abstract:

    This module defines data structures for thunking to 32-bit on Win64
    
Author:

    David Kruse (dkruse)    29-Nov 2000

Revision History:

--*/

#ifndef _SRVTYP32_
#define _SRVTYP32_

// Thunking structure for rename info
typedef struct _FILE_RENAME_INFORMATION32
{
    BOOLEAN ReplaceIfExists;
    ULONG RootDirectory; // Is HANDLE in real structure
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION32, *PFILE_RENAME_INFORMATION32;

// For remote link tracking code

typedef struct _REMOTE_LINK_TRACKING_INFORMATION32_ {
    ULONG       TargetFileObject;
    ULONG   TargetLinkTrackingInformationLength;
    UCHAR   TargetLinkTrackingInformationBuffer[1];
} REMOTE_LINK_TRACKING_INFORMATION32,
 *PREMOTE_LINK_TRACKING_INFORMATION32;

typedef struct _FILE_TRACKING_INFORMATION32 {
    ULONG DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION32, *PFILE_TRACKING_INFORMATION32;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvtypes.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvtypes.h

Abstract:

    This module defines data structures and other types for the LAN
    Manager server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

#ifndef _SRVTYPES_
#define _SRVTYPES_

#include "srvtyp32.h"

//#include <nt.h>

//#include <smbtypes.h>

//
// REFERENCE_HISTORY is used to trace references and dereferences to
// a block when SRVDBG2 is defined.
//
// WARNING:  When using a srv.sys with SRVDBG2 enabled, you must also
//           use a srvsvc.dll and xactsrv.dll with SRVDBG2 enabled.
//           This is because they share the TRANSACTION structure.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE WITHOUT CHANGING THE CORRESPONDING *
// * STRUCTURE IN net\inc\xstypes.h!                                 *
// *                                                                 *
// *******************************************************************
//

#if SRVDBG2

typedef struct _REFERENCE_HISTORY_ENTRY {
    ULONG NewReferenceCount;
    ULONG IsDereference;
    PVOID Caller;
    PVOID CallersCaller;
} REFERENCE_HISTORY_ENTRY, *PREFERENCE_HISTORY_ENTRY;

typedef struct _REFERENCE_HISTORY {
    ULONG TotalReferences;
    ULONG TotalDereferences;
    ULONG NextEntry;
    PREFERENCE_HISTORY_ENTRY HistoryTable;
} REFERENCE_HISTORY, *PREFERENCE_HISTORY;

#define REFERENCE_HISTORY_LENGTH 256

#endif


//
// BLOCK_HEADER is the standard block header that appears at the
// beginning of most server-private data structures.  This header is
// used primarily for debugging and tracing.  The Type and State fields
// are described above.  The Size field indicates how much space was
// allocated for the block.  ReferenceCount indicates the number of
// reasons why the block should not be deallocated.  The count is set to
// 2 by the allocation routine, to account for 1) the fact that the
// block is "open" and 2) the pointer returned to the caller.  When the
// block is closed, State is set to Closing, and the ReferenceCount is
// decremented.  When all references (pointers) to the block are
// deleted, and the reference count reaches 0, the block is deleted.
//
// WARNING:  When using a srv.sys with SRVDBG2 enabled, you must also
//           use a srvsvc.dll and xactsrv.dll with SRVDBG2 enabled.
//           This is because they share the TRANSACTION structure.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE WITHOUT CHANGING THE CORRESPONDING *
// * STRUCTURE IN net\inc\xstypes.h!                                 *
// *                                                                 *
// *******************************************************************
//

typedef struct _BLOCK_HEADER {
    union {
        struct {
            UCHAR Type;
            UCHAR State;
            USHORT Size;
        };
        ULONG TypeStateSize;
    };
    ULONG ReferenceCount;
#if SRVDBG2
    REFERENCE_HISTORY History;
#endif
} BLOCK_HEADER, *PBLOCK_HEADER;

//
// CLONG_PTR is used to aid the 64-bit porting effort.
//

typedef ULONG_PTR CLONG_PTR;

//
// Work restart routine.  This routine is invoked when a previously
// started operation completes.  In the FSD, the restart routine is
// invoked by the I/O completion routine.  In the FSP, the restart
// routine is invoked by the worker thread when it retrieves a work item
// from the work queue.
//

typedef
VOID
( SRVFASTCALL *PRESTART_ROUTINE) (
    IN OUT struct _WORK_CONTEXT *WorkContext
    );

//
// QUEUEABLE_BLOCK_HEADER is a BLOCK_HEADER followed by a LIST_ENTRY.
// This header is used when more than one type of block needs to be
// queue to the same list -- it ensures that the linkage fields are at
// the same offset in each type of block.  The timestamp can be used to
// measure how long a block has been in the queue.
//
// FspRestartRoutine is the address of the routine that the worker thread
// is to call when the work item is dequeued from the work queue.
//

typedef struct _QUEUEABLE_BLOCK_HEADER {
    BLOCK_HEADER BlockHeader;
    union {
        LIST_ENTRY ListEntry;
        DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) SINGLE_LIST_ENTRY SingleListEntry;
    };
    ULONG Timestamp;
    ULONG UsingBlockingThread;                      // Is the current thread a blocking thread?
    PRESTART_ROUTINE FspRestartRoutine;
} QUEUEABLE_BLOCK_HEADER, *PQUEUEABLE_BLOCK_HEADER;

//
// The nonpaged header is used for blocks that are allocated from paged
// pool so that the reference count can be kept in nonpaged pool, thus
// allowing the use of interlocked operations.
//

typedef struct _NONPAGED_HEADER {
    ULONG Type;
    LONG ReferenceCount;
    PVOID PagedBlock;
    SINGLE_LIST_ENTRY ListEntry;
} NONPAGED_HEADER, *PNONPAGED_HEADER;

//
// The paged header is used for the paged portions of a block.
//

typedef struct _PAGED_HEADER {
    ULONG Type;
    PVOID NonPagedBlock;
} PAGED_HEADER, *PPAGED_HEADER;

//
// Macros for accessing the block header structure.
//
// *** Note that the existing usage of these macros assumes that the block
//     header is the first element in the block!
//

#define GET_BLOCK_STATE(block) ( ((PBLOCK_HEADER)(block))->State )
#define SET_BLOCK_STATE(block,state) \
            ( ((PBLOCK_HEADER)(block))->State = (UCHAR)(state) )

#define GET_BLOCK_TYPE(block) ( ((PBLOCK_HEADER)(block))->Type )
#define SET_BLOCK_TYPE(block,type) \
            ( ((PBLOCK_HEADER)(block))->Type = (UCHAR)(type) )

#define GET_BLOCK_SIZE(block) ( ((PBLOCK_HEADER)(block))->Size )
#define SET_BLOCK_SIZE(block, size )\
            ( ((PBLOCK_HEADER)(block))->Size = (USHORT)(size) )

//
// Most efficient way to set the block header up.  Compiler will generally turn this
// into a single write of a single constant
//
#define SET_BLOCK_TYPE_STATE_SIZE( block, type,state,size ) \
            ( ((PBLOCK_HEADER)(block))->TypeStateSize = (ULONG)(((USHORT)size<<16) | \
                                                         ((UCHAR)state<<8) | \
                                                          (UCHAR)type ))

//
// A POOL_HEADER is placed on the front of all pool allocations by the
// server
//
typedef struct _POOL_HEADER {

    //
    // This is the number of bytes in the original allocation for this block
    //
    ULONG RequestedSize;

    //
    // This is the base of a vector of LOOK_ASIDE_MAX_ELEMENTS length where
    // this block of memory might be freed to.  If NULL, this block should
    // be returned directly to the appropriate system heap.
    //
    struct _POOL_HEADER **FreeList;

} POOL_HEADER, *PPOOL_HEADER;


//
// SRV_FILE_INFORMATION holds file information in SMB-compatible format,
// as opposed to native NT format.  Creation, last access, and last
// write times are stored in OS/2 format.  Creation time is also stored
// in seconds-since-1970 format, as in the core protocol.  File
// allocation and data sizes are stored as longwords, as opposed to
// LARGE_INTEGERS.
//
// *** Note that files whose size is too large to fit in a longword
//     cannot properly be respresented in the SMB protocol.
//
// *** The fields in this structure are stored in native-endian format,
//     and must be converted to/from little-ending in an actual SMB.
//

typedef struct _SRV_FILE_INFORMATION_ABBREVIATED {
    LARGE_INTEGER DataSize;
    USHORT Attributes;
    ULONG LastWriteTimeInSeconds;
    USHORT Type;
    USHORT HandleState;
} SRV_FILE_INFORMATION_ABBREVIATED, *PSRV_FILE_INFORMATION_ABBREVIATED;

typedef struct _SRV_FILE_INFORMATION {
    SRV_FILE_INFORMATION_ABBREVIATED;
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    ULONG EaSize;
    LARGE_INTEGER AllocationSize;
} SRV_FILE_INFORMATION, *PSRV_FILE_INFORMATION;




typedef struct {
    FILE_NETWORK_OPEN_INFORMATION;
    ULONG EaSize;
} SRV_NETWORK_OPEN_INFORMATION, *PSRV_NETWORK_OPEN_INFORMATION;

//
// SRV_FILE_INFORMATION holds file information in NT SMB-compatible format,
// It is used to support NT protocol SMB such as NtCreateAndX and
// NtTransactCreate.
//
typedef struct {
    SRV_NETWORK_OPEN_INFORMATION   NwOpenInfo;
    USHORT Type;
    USHORT HandleState;
} SRV_NT_FILE_INFORMATION, *PSRV_NT_FILE_INFORMATION;


//
// Various blocks get a unique identifier (UID, PID, TID, FID, SID).
// This is a typically 16-bit value, the higher bits being the sequence
// number (used to check validity of an ID) and the lower bits being an
// index into an array that contains elements of type TABLE_ENTRY.
// These elements contain the sequence number of the ID and a pointer to
// the block that 'owns' the ID.  Free table elements are joined in a
// singly-linked list.
//
// *** For now, the table entry struct is flat -- the in-use and free
//     fields are not defined in a union.  This is because the flat size
//     of the struct is eight bytes, which is how big the compiler will
//     make it anyway to ensure alignment.  If this changes, consider
//     using a union.
//

typedef struct _TABLE_ENTRY {
    PVOID Owner;
    USHORT SequenceNumber;
    SHORT NextFreeEntry;            // index of next free entry, or -1
} TABLE_ENTRY, *PTABLE_ENTRY;

//
// Information about tables is stored in TABLE_HEADER.  This structure
// has a pointer to the first entry in the table, the size of the table,
// and indices of the first and last free entries.
//

typedef struct _TABLE_HEADER {
    PTABLE_ENTRY Table;
    USHORT TableSize;
    SHORT FirstFreeEntry;
    SHORT LastFreeEntry;
    BOOLEAN Nonpaged;
    UCHAR Reserved;
} TABLE_HEADER, *PTABLE_HEADER;

//
// Typedefs for check-state-and-reference and dereference routines.  All
// server check-state-and-reference and dereference routines follow this
// general format, though the actual pointer they take is not a PVOID
// but rather a pointer to the block type they deal with, so a typecast
// is necessary when assigning these routines.
//
// The check-state-and-reference routine checks the state of the block
// and if the state is "active", references the block.  This must be
// done as an atomic operation.
//

typedef
BOOLEAN
(SRVFASTCALL * PREFERENCE_ROUTINE) (
    IN PVOID Block
    );

typedef
VOID
(SRVFASTCALL * PDEREFERENCE_ROUTINE) (
    IN PVOID Block
    );

//
// Structures used for ordered lists in the server.  Ordered lists
// allow an easy mechanism for walking instances of data blocks and
// include a sort of handle for easily finding the block again, or
// determining if the block has been deleted.
//
// The way they work is to have a global doubly linked list of all the
// relevant data blocks.  The list is stored in order of time of
// allocation, and each block has a ULONG associated with it.  This
// ULONG, called the ResumeHandle, is monotonically increasing starting
// at 1.  (It starts at 1 rather than 0 so that it is simple to write
// code to start a search at the beginning of the list.)  The ResumeHandle
// is all that is necessary to find the next entry in the list.
//

typedef struct _ORDERED_LIST_HEAD {
    LIST_ENTRY ListHead;
    PSRV_LOCK Lock;
    ULONG CurrentResumeHandle;
    ULONG ListEntryOffset;
    PREFERENCE_ROUTINE ReferenceRoutine;
    PDEREFERENCE_ROUTINE DereferenceRoutine;
    BOOLEAN Initialized;
} ORDERED_LIST_HEAD, *PORDERED_LIST_HEAD;

typedef struct _ORDERED_LIST_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG ResumeHandle;
} ORDERED_LIST_ENTRY, *PORDERED_LIST_ENTRY;

//
// Type of resource shortages
//

typedef enum _RESOURCE_TYPE {
    ReceivePending,
    OplockSendPending
} RESOURCE_TYPE, *PRESOURCE_TYPE;

//
// Oplocks types.  Currently one the first 2 will ever be requested
// by a client.
//

typedef enum _OPLOCK_TYPE {
    OplockTypeNone,
    OplockTypeBatch,
    OplockTypeExclusive,
    OplockTypeShareRead,
    OplockTypeServerBatch
} OPLOCK_TYPE, *POPLOCK_TYPE;

//
// The oplock states of an RFCB.
//

typedef enum _OPLOCK_STATE {
    OplockStateNone = 0,
    OplockStateOwnExclusive,
    OplockStateOwnBatch,
    OplockStateOwnLevelII,
    OplockStateOwnServerBatch
} OPLOCK_STATE, *POPLOCK_STATE;

//
// The state of a wait for oplock break.  This is used to mark the state
// of a client that is waiting for another client to break its oplock.
//

typedef enum _WAIT_STATE {
    WaitStateNotWaiting,
    WaitStateWaitForOplockBreak,
    WaitStateOplockWaitTimedOut,
    WaitStateOplockWaitSucceeded
} WAIT_STATE, *PWAIT_STATE;

//
// The reason a connection is being disconnected
typedef enum _DISCONNECT_REASON {
    DisconnectIdleConnection=0,
    DisconnectEndpointClosing,
    DisconnectNewSessionSetupOnConnection,
    DisconnectTransportIssuedDisconnect,
    DisconnectSessionDeleted,
    DisconnectBadSMBPacket,
    DisconnectSuspectedDOSConnection,
    DisconnectAcceptFailedOrCancelled,
    DisconnectStaleIPXConnection,
    DisconnectReasons
} DISCONNECT_REASON, *PDISCONNECT_REASON;

//
// Per-queue variables for server statistics.
//

typedef struct _SRV_STATISTICS_QUEUE {

    ULONGLONG BytesReceived;
    ULONGLONG BytesSent;
    ULONGLONG ReadOperations;
    ULONGLONG BytesRead;
    ULONGLONG WriteOperations;
    ULONGLONG BytesWritten;
    SRV_TIMED_COUNTER WorkItemsQueued;

    //
    // System time, as maintained by the server.  This
    // is the low part of the system tick count.  The
    // server samples it periodically, so the time is
    // not exactly accurate.  It is monotontically increasing,
    // except that it wraps every 74 days or so.
    //

    ULONG     SystemTime;

} SRV_STATISTICS_QUEUE, *PSRV_STATISTICS_QUEUE;

//
// Structure used to keep internal statistics in the server. Mainly used
// for servicing the NetStatisticsGet API.
//

typedef struct _SRV_ERROR_RECORD {

    ULONG SuccessfulOperations;
    ULONG FailedOperations;

    ULONG AlertNumber;

    ULONG ErrorThreshold;

} SRV_ERROR_RECORD, *PSRV_ERROR_RECORD;

//
// This looks enough like a WORK_CONTEXT structure to allow queueing to
// a work queue, and dispatching to the FspRestartRoutine.  Its blocktype
// is BlockTypeWorkContextSpecial.  It must not be freed to the free lists.
//
typedef struct _SPECIAL_WORK_ITEM {
    QUEUEABLE_BLOCK_HEADER ;
    struct _WORK_QUEUE *CurrentWorkQueue;
} SPECIAL_WORK_ITEM, *PSPECIAL_WORK_ITEM;

//
// This structure holds a vector of PPOOL_HEADERs in lists which are set and
//  retrieved with ExInterlockedExchange() for fast allocation and deallocation.
//
typedef struct {

    //
    // SmallFreeList is a look aside vector of recently freed PPOOL_HEADERs
    //  which are <= LOOK_ASIDE_SWITCHOVER bytes.
    //
    PPOOL_HEADER SmallFreeList[ LOOK_ASIDE_MAX_ELEMENTS ];

    //
    // LargeFreeList is a look aside vector of recently freed PPOOL_HEADERs
    //  which are greater than LOOK_ASIDE_SWITCHOVER bytes,
    //  but less than MaxSize bytes.
    //
    PPOOL_HEADER LargeFreeList[ LOOK_ASIDE_MAX_ELEMENTS ];

    //
    // This is the maximum size that we'll save in the LargeFreeList
    //
    CLONG MaxSize;

    //
    // This is the number of times we allocated from either list
    //
    CLONG AllocHit;

    //
    // This is the number of times we failed to allocate from either list
    //
    CLONG AllocMiss;

} LOOK_ASIDE_LIST, *PLOOK_ASIDE_LIST;

//
// WORK_QUEUE describes a work queue.
//

typedef struct _WORK_QUEUE {

    union {

        //
        // Since this is an unnamed structure inside of an unnamed union, we
        // can just directly name the members elsewhere in the code.
        //
        struct _QUEUE {
            //
            // The mode we use to wait
            //
            KPROCESSOR_MODE WaitMode;

            //
            // The kernel queue that is holding the requests for this processor
            //
            KQUEUE Queue;

            //
            // This is how long a kernel worker threads hangs around looking for work.
            //  If it doesn't find work, it will voluntarily terminate
            //
            LARGE_INTEGER IdleTimeOut;

            //
            // Number of threads currently NOT running on this queue
            //
            ULONG AvailableThreads;

            //
            // Spin lock that protects list manipulation and various items in
            // this structure
            //
            KSPIN_LOCK SpinLock;

            //
            //  Possibly one free WORK_CONTEXT structure.  Use InterlockedExchange
            //   to see if you can get it.
            //
            struct _WORK_CONTEXT *FreeContext;

            //
            // InitialWorkItemList is the free list of work items that
            //  were preallocated at startup
            //
            SLIST_HEADER InitialWorkItemList;

            //
            // NormalWorkItemList is the free list of work items that are
            //  allocated as needed as we go
            //
            SLIST_HEADER NormalWorkItemList;

            //
            // RawModeWorkItemList is the free list of raw mode work items
            //   and are allocated as needed as we go
            //
            SLIST_HEADER RawModeWorkItemList;

            //
            // How many clients have this as their CurrentWorkQueue
            //
            ULONG CurrentClients;

            //
            // The number of work items on either of the above lists
            //
            LONG FreeWorkItems;

            //
            // The maximum number of WorkItems we're allowed to have
            //
            LONG MaximumWorkItems;

            //
            // The minimum number of free work items we'd like to have on the lists
            //
            LONG MinFreeWorkItems;

            //
            // The number of work items that we need to recycle due to shortage
            //
            LONG NeedWorkItem;

            //
            // The number of work items stolen from us by other processors
            //
            LONG StolenWorkItems;

            //
            // The number of free RawModeWorkItems
            //
            LONG FreeRawModeWorkItems;

            //
            // RfcbFreeList is a free list of RFCB structures, used to cut
            //  down on the number of pool allocations
            //
            struct _RFCB      *CachedFreeRfcb;
            SLIST_HEADER      RfcbFreeList;

            //
            // The number of entries in the RfcbFreeList
            //
            LONG FreeRfcbs;

            //
            // The maximum number we'll allow in the RfcbFreeList
            //
            LONG MaxFreeRfcbs;

            //
            // MfcbFreeList is a free list of NONPAGED_MFCB structures, used
            //  to reduce the number of pool allocations
            //
            struct _NONPAGED_MFCB    *CachedFreeMfcb;
            SLIST_HEADER             MfcbFreeList;

            //
            // The number of entries in the MfcbFreeList
            //
            LONG FreeMfcbs;

            //
            // The maximum number we'll allow in the MfcbFreeList
            //
            LONG MaxFreeMfcbs;

            //
            // These two lists hold recently freed blocks of memory.
            //
            LOOK_ASIDE_LIST   PagedPoolLookAsideList;

            LOOK_ASIDE_LIST   NonPagedPoolLookAsideList;

            //
            // The number of allocated RawModeWorkItems
            //
            LONG AllocatedRawModeWorkItems;

            //
            // The number of threads servicing this queue
            //
            ULONG Threads;

            //
            // The maximum number of threads we'll allow on this queue
            //
            ULONG MaxThreads;

            //
            // The number of WorkItems that we have allocated for this workqueue
            //
            LONG AllocatedWorkItems;

            //
            // A pointer to one of our threads, needed for irps
            //
            PETHREAD IrpThread;

            //
            // Data used to compute average queue depth...
            //
            // A vector of depth samples
            //
            ULONG DepthSamples[ QUEUE_SAMPLES ];

            //
            // Position of next sample update.  This is set to NULL when we're
            //  trying to terminate the computation dpc
            //
            PULONG NextSample;

            //
            // Time of next sample update
            //
            LARGE_INTEGER NextAvgUpdateTime;

            //
            // The sum of the samples in the DepthSamples vector
            //
            ULONG AvgQueueDepthSum;

            //
            // Event used to synchronize termination of the avg queue
            //  depth computation dpc
            //
            KEVENT AvgQueueDepthTerminationEvent;

            //
            // DPC object used to schedule the depth computation
            //
            KDPC QueueAvgDpc;

            //
            // Timer object for running QueueAvgDpc
            //
            KTIMER QueueAvgTimer;

            //
            // Per-queue statistics
            //
            SRV_STATISTICS_QUEUE stats;

            //
            // When we update the Io counters for operations, we need to know
            //  the number of operations that have been processed since the last update.
            //  'saved' stores the values which were given last time -- the difference between
            //  the statistics in 'stats' and the corresponding member in 'saved' is the
            //  number which should be given to the Io counters.  (see scavengr.c)
            //
            struct {
                ULONGLONG ReadOperations;
                ULONGLONG BytesRead;
                ULONGLONG WriteOperations;
                ULONGLONG BytesWritten;
            } saved;

            //
            // This work item is queued on the Queue above to cause
            //  more work items to be allocated
            //
            SPECIAL_WORK_ITEM   CreateMoreWorkItems;

        };

        //
        // Since we are allocating an array of these (one per processor), it
        // would cause interprocessor cache sloshing if a WORK_QUEUE structure
        // was not a multiple of the CACHE_LINE_SIZE.  The following pad is
        // set to round up the size of the above struct to the next cache line size.
        //
        ULONG _pad[ (sizeof(struct _QUEUE)+CACHE_LINE_SIZE-1) / CACHE_LINE_SIZE * ULONGS_IN_CACHE ];

    };
} WORK_QUEUE, *PWORK_QUEUE;

//
//
// PERSISTENT_RECORD tracks persistent information for different types of
// internal server structures.
//

#ifdef INCLUDE_SMB_PERSISTENT
typedef struct _PERSISTENT_INFO {
    USHORT      PersistentState;
    ULONG       PersistentFileOffset;
    ULONG       PersistentId;
    LIST_ENTRY  PersistentListEntry;
} PERSISTENT_INFO, *PPERSISTENT_INFO;
#endif

#endif // ndef _SRVTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvsvc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvsvc.h

Abstract:

    This module defines prototypes for the API processors.  These
    routines are called in response to an FSCTL from the server
    service.

Author:

    David Treadwell (davidtr) 20-Jan-1991

Revision History:

--*/

#ifndef _SRVSVC_
#define _SRVSVC_

//
// Standard prototype for all API processors.
//

typedef
NTSTATUS
(*PAPI_PROCESSOR) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Prototypes for filter, size, and buffer filling routines used by Enum
// APIs.  SrvEnumApiHandler calls these routines when it has found a
// block to determine whether the block should actually be put in the
// output buffer.
//

typedef
BOOLEAN
(*PENUM_FILTER_ROUTINE) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

typedef
ULONG
(*PENUM_SIZE_ROUTINE) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

typedef
VOID
(*PENUM_FILL_ROUTINE) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructurePointer,
    IN OUT LPWSTR *EndOfVariableData
    );

//
// Prototype for filter routine for SrvMatchEntryInOrderedList.
//

typedef
BOOLEAN
(*PFILTER_ROUTINE) (
    IN PVOID Context,
    IN PVOID Block
    );

//
// Connection APIs.
//

NTSTATUS
SrvNetConnectionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// File APIs.
//

NTSTATUS
SrvNetFileClose (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetFileEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Server APIs.
//

NTSTATUS
SrvNetServerDiskEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetServerSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Transport routines.
//

NTSTATUS
SrvNetServerTransportAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetServerTransportDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetServerTransportEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Session APIs.
//

NTSTATUS
SrvNetSessionDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetSessionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Share APIs.
//

NTSTATUS
SrvNetShareAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetShareDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetShareEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetShareSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Statistics routine.
//

NTSTATUS
SrvNetStatisticsGet (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// API support routines.
//

VOID
SrvCopyUnicodeStringToBuffer (
    IN PUNICODE_STRING String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

VOID
SrvDeleteOrderedList (
    IN PORDERED_LIST_HEAD ListHead
    );

NTSTATUS
SrvEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PORDERED_LIST_HEAD ListHead,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    );

PVOID
SrvFindEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PFILTER_ROUTINE FilterRoutine OPTIONAL,
    IN PVOID Context OPTIONAL,
    IN ULONG ResumeHandle,
    IN BOOLEAN ExactHandleMatch,
    IN PLIST_ENTRY StartLocation OPTIONAL
    );

PVOID
SrvFindNextEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

PSESSION
SrvFindUserOnConnection (
    IN PCONNECTION Connection
    );

ULONG
SrvGetResumeHandle (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

VOID
SrvInitializeOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN ULONG ListEntryOffset,
    IN PREFERENCE_ROUTINE ReferenceRoutine,
    IN PDEREFERENCE_ROUTINE DereferenceRoutine,
    IN PSRV_LOCK Lock
    );

VOID
SrvInsertEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

VOID
SrvRemoveEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

NTSTATUS
SrvSendDatagram (
    IN PANSI_STRING Domain,
    IN PUNICODE_STRING Transport OPTIONAL,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

#ifdef SLMDBG
VOID
SrvSendSecondClassMailslot (
    IN PVOID Message,
    IN ULONG MessageLength,
    IN PCHAR Domain,
    IN PSZ UserName
    );
#endif

//
// Macro to convert an offset in an API data structure to a pointer
// meaningful to the server.
//

#define OFFSET_TO_POINTER(val,start)                                 \
    {                                                                \
        if ( (val) != NULL ) {                                       \
            (val) = (PVOID)( (PCHAR)(start) + (ULONG_PTR)(val) );    \
        }                                                            \
    }
//
// Macro to determine whether a pointer is within a certain range.
//

#define POINTER_IS_VALID(val,start,len)                      \
    ( (val) == NULL ||                                       \
      ( (ULONG_PTR)(val) > (ULONG_PTR)(start) &&             \
          (ULONG_PTR)(val) < ((ULONG_PTR)(start) + (len)) ) )
#endif // _SRVSVC_

//
// Ensure that the system will not go into a power-down idle standby mode
//
VOID SrvInhibitIdlePowerDown();

//
// Allow the system to go into a power-down idle standby mode
//
VOID SrvAllowIdlePowerDown();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcconn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcconn.c

Abstract:

    This module contains routines for supporting the connection APIs in
    the server service, SrvNetConnectionEnum.

Author:

    David Treadwell (davidtr) 23-Feb-1991

Revision History:

--*/

#include "precomp.h"
#include "svcconn.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCCONN

//
// Forward declarations.
//

VOID
FillConnectionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructurePointer,
    IN OUT LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetConnectionEnum )
#pragma alloc_text( PAGE, FillConnectionInfoBuffer )
#pragma alloc_text( PAGE, FilterConnections )
#pragma alloc_text( PAGE, SizeConnections )
#endif

//
// Macros to determine the size a share would take up at one of the
// levels of share information.
//

#define TOTAL_SIZE_OF_CONNECTION(treeConnect,level,user,netname)         \
    ( (level) == 0 ? sizeof(CONNECTION_INFO_0) :                         \
                     sizeof(CONNECTION_INFO_1) +                         \
                         SrvLengthOfStringInApiBuffer((user)) +         \
                         SrvLengthOfStringInApiBuffer((netname)) )

#define FIXED_SIZE_OF_CONNECTION(level)                  \
    ( (level) == 0 ? sizeof(CONNECTION_INFO_0) :         \
                     sizeof(CONNECTION_INFO_1) )


NTSTATUS
SrvNetConnectionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetConnectionEnum API in the server FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - qualifier for determining the basis for the search.  It
            is either a computer name, in which case information about
            tree connects from the specified client is returned, or
            a share name, in which case information about tree connects
            to the specified share is returned.

        Level - level of information to return, 0 or 1.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvTreeConnectList,
               FilterConnections,
               SizeConnections,
               FillConnectionInfoBuffer
               );

} // SrvNetConnectionEnum


STATIC
VOID
FillConnectionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed session structure and, if it fits,
    associated variable data, into a buffer.  Fixed data goes at the
    beginning of the buffer, variable data at the end.

    *** This routine must be called with Connection->Lock held!

Arguments:

    Level - the level of information to copy from the connection.

    Connection - the tree connect from which to get information.

    FixedStructure - where the ine buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PTREE_CONNECT treeConnect = Block;
    PSESSION session;
    PCONNECTION_INFO_1 coni1;

    LARGE_INTEGER currentTime;
    ULONG currentSecondsSince1980;
    ULONG startTimeInSecondsSince1980;
    ULONG secondsAlive;

    PAGED_CODE();

    //
    // Get the current time and use this to determine how long the
    // tree connection has been alive.
    //

    KeQuerySystemTime( &currentTime );

    RtlTimeToSecondsSince1980(
        &currentTime,
        &currentSecondsSince1980
        );

    RtlTimeToSecondsSince1980(
        &treeConnect->StartTime,
        &startTimeInSecondsSince1980
        );

    secondsAlive = currentSecondsSince1980 - startTimeInSecondsSince1980;

    //
    // Set up the fixed structure pointer and find out where the fixed
    // structure ends.
    //

    coni1 = *FixedStructure;

    *FixedStructure = (PCHAR)*FixedStructure +
                          FIXED_SIZE_OF_CONNECTION( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** This routine assumes that the fixed structure will fit in the
    //     buffer!
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different session structures are
    //     identical.
    //

    switch( Srp->Level ) {

    case 1:

        //
        // Convert the server's internal representation of share types
        // to the expected format.
        //

        switch ( treeConnect->Share->ShareType ) {

        case ShareTypeDisk:

            coni1->coni1_type = STYPE_DISKTREE;
            break;

        case ShareTypePrint:

            coni1->coni1_type = STYPE_PRINTQ;
            break;

#if SRV_COMM_DEVICES
        case ShareTypeComm:

            coni1->coni1_type = STYPE_DEVICE;
            break;
#endif
        case ShareTypePipe:

            coni1->coni1_type = STYPE_IPC;
            break;

        default:

            //
            // This should never happen.  It means that somebody
            // stomped on the share block.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "FillConnectionInfoBuffer: invalid share type in share: %ld",
                treeConnect->Share->ShareType,
                NULL
                );

            SrvLogInvalidSmb( NULL );
            return;
        }

        //
        // Set up the count of opens done on this tree connect.  Do not include
        //  cached opens, as they are transparent to users and administrators
        //

        coni1->coni1_num_opens = treeConnect->CurrentFileOpenCount;

        if( coni1->coni1_num_opens > 0 ) {

            ULONG count = SrvCountCachedRfcbsForTid(
                                     treeConnect->Connection,
                                     treeConnect->Tid );

            if( coni1->coni1_num_opens > count ) {
                coni1->coni1_num_opens -= count;
            } else {
                coni1->coni1_num_opens = 0;
            }

        }

        //
        // There is always exactly one user on a tree connect.
        //
        // !!! Is this correct???

        coni1->coni1_num_users = 1;

        //
        // Set up the alive time.
        //

        coni1->coni1_time = secondsAlive;

        //
        // Attempt to find a reasonable user name.  Since the SMB
        // protocol does not link tree connects with users, only with
        // sessions, it may not be possible to return a user name.
        //

        ACQUIRE_LOCK( &treeConnect->Connection->Lock );

        session = treeConnect->Session;

        if ( session != NULL ) {
            UNICODE_STRING userName;

            SrvGetUserAndDomainName( session, &userName, NULL );

            SrvCopyUnicodeStringToBuffer(
                &userName,
                *FixedStructure,
                EndOfVariableData,
                &coni1->coni1_username
                );

            if( userName.Buffer ) {
                SrvReleaseUserAndDomainName( session, &userName, NULL );
            }

        } else {

            coni1->coni1_username = NULL;
        }

        RELEASE_LOCK( &treeConnect->Connection->Lock );

        //
        // Set up the net name.  If the qualifier passed in the
        // SRP is a computer name, then the net name is the share
        // name.  If the qualifier is a share name, the net name
        // is a computer name.
        //

        if ( Srp->Name1.Length > 2 && *Srp->Name1.Buffer == '\\' &&
                 *(Srp->Name1.Buffer+1) == '\\' ) {

            SrvCopyUnicodeStringToBuffer(
                &treeConnect->Share->ShareName,
                *FixedStructure,
                EndOfVariableData,
                &coni1->coni1_netname
                );

        } else {

            UNICODE_STRING clientName;
            PUNICODE_STRING clientMachineName;

            clientMachineName =
                &treeConnect->Connection->PagedConnection->ClientMachineNameString;

            //
            // Make a string that does not contain the leading
            // backslashes.
            //

            clientName.Buffer = clientMachineName->Buffer + 2;
            clientName.Length =
                (USHORT) (clientMachineName->Length - 2 * sizeof(WCHAR));
            clientName.MaximumLength = clientName.Length;

            SrvCopyUnicodeStringToBuffer(
                &clientName,
                *FixedStructure,
                EndOfVariableData,
                &coni1->coni1_netname
                );
        }

        // *** Lack of break is intentional!

    case 0:

        //
        // Set up the tree connect ID.
        //

        coni1->coni1_id = SrvGetResumeHandle( &SrvTreeConnectList, treeConnect );

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillConnectionInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

        SrvLogInvalidSmb( NULL );
    }

    return;

} // FillConnectionInfoBuffer


BOOLEAN
FilterConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular tree connect should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  Name1 ("qualifier"
        on NetConnectionEnum) is used to do the filtering.

    Block - a pointer to the tree connect to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PTREE_CONNECT treeConnect = Block;
    PUNICODE_STRING compareName;

    PAGED_CODE( );

    //
    // We're going to compare the Name1 field against the share name
    // if a computer name is the qualifier or against the computer
    // name if the share name was the qualifier.
    //

    if ( Srp->Name1.Length > 2*sizeof(WCHAR) && *Srp->Name1.Buffer == '\\' &&
             *(Srp->Name1.Buffer+1) == '\\' ) {
        compareName =
            &treeConnect->Connection->PagedConnection->ClientMachineNameString;
    } else {
        compareName = &treeConnect->Share->ShareName;
    }

    return RtlEqualUnicodeString(
               &Srp->Name1,
               compareName,
               TRUE
               );

} // FilterConnections


ULONG
SizeConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in tree connect would take
    up in an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  The level and Name1
        ("qualifier" on NetConnectionEnum) are used.

    Block - a pointer to the tree connect to size.

Return Value:

    ULONG - The number of bytes the tree connect would take up in the
        output buffer.

--*/

{
    PTREE_CONNECT treeConnect = Block;
    PUNICODE_STRING netName;
    UNICODE_STRING userName;
    PSESSION session;
    ULONG size;

    PAGED_CODE( );

    if ( Srp->Name1.Length > 2 && *Srp->Name1.Buffer == '\\' &&
             *(Srp->Name1.Buffer+1) == '\\' ) {
        netName = &treeConnect->Share->ShareName;
    } else {
        netName =
            &treeConnect->Connection->PagedConnection->ClientMachineNameString;
    }

    //
    // Attempt to find a reasonable user name.  Since the SMB protocol
    // does not link tree connects with users, only with sessions, it
    // may not be possible to return a user name.
    //

    ACQUIRE_LOCK( &treeConnect->Connection->Lock );

    session = treeConnect->Session;

    if ( (session != NULL) && (GET_BLOCK_STATE(session) == BlockStateActive) ) {
        SrvGetUserAndDomainName( session, &userName, NULL );
    } else {
        userName.Buffer = NULL;
    }

    size = TOTAL_SIZE_OF_CONNECTION( treeConnect,
                                     Srp->Level,
                                     userName.Buffer ? &userName : NULL,
                                     netName
                                   );

    if( userName.Buffer ) {
        SrvReleaseUserAndDomainName( session, &userName, NULL );
    }

    RELEASE_LOCK( &treeConnect->Connection->Lock );

    return size;

} // SizeConnections
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcfile.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcfile.c

Abstract:

    This module contains routines for supporting the file APIs in the
    server service, SrvNetFileClose, SrvNetFileEnum, and
    SrvNetFileGetInfo,

Author:

    David Treadwell (davidtr) 31-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcfile.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCFILE

//
// Forward declarations.
//

VOID
FillFileInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetFileClose )
#pragma alloc_text( PAGE, SrvNetFileEnum )
#pragma alloc_text( PAGE, FillFileInfoBuffer )
#pragma alloc_text( PAGE, FilterFiles )
#pragma alloc_text( PAGE, SizeFiles )
#endif

//
// Macros to determine the size an RFCB would take up at one of the
// levels of file information.
//
// *** Note that the zero terminator on the path name is accounted for by
//     the leading backslash, which is not returned.
//

#define TOTAL_SIZE_OF_FILE(lfcb,level, user)                                   \
    ( (level) == 2 ? sizeof(FILE_INFO_2) :                                     \
                     sizeof(FILE_INFO_3) +                                     \
                         SrvLengthOfStringInApiBuffer(                         \
                             &(lfcb)->Mfcb->FileName) +                        \
                         SrvLengthOfStringInApiBuffer( user ) )

#define FIXED_SIZE_OF_FILE(level)                  \
    ( (level) == 2 ? sizeof(FILE_INFO_2) :         \
                     sizeof(FILE_INFO_3) )

NTSTATUS
SrvNetFileClose (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetFileClose API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Parameters.Get.ResumeHandle - the file ID to close.

      OUTPUT:

        None.

    Buffer - unused.

    BufferLength - unused.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PRFCB rfcb;

    PAGED_CODE( );

    Buffer, BufferLength;

    //
    // Try to find a file that matches the file ID.  Only an exact
    // match will work.
    //

    rfcb = SrvFindEntryInOrderedList(
               &SrvRfcbList,
               NULL,
               NULL,
               Srp->Parameters.Get.ResumeHandle,
               TRUE,
               NULL
               );

    if ( rfcb == NULL ) {
        Srp->ErrorCode = NERR_FileIdNotFound;
        return STATUS_SUCCESS;
    }

    //
    // Close this RFCB.
    //

    SrvCloseRfcb( rfcb );

    //
    // SrvFindEntryInOrderedList referenced the RFCB; dereference it
    // now.
    //

    SrvDereferenceRfcb( rfcb );

    return STATUS_SUCCESS;

} // SrvNetFileClose


NTSTATUS
SrvNetFileEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetFileEnum API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - basename for limiting search--only files whose path name
            begin with this string are returned.

        Level - level of information to return, 2 or 3.

        Flags - if SRP_RETURN_SINGLE_ENTRY is set, then this is a
            NetFileGetInfo, so behave accordingly.

        Parameters.Get.ResumeHandle - a handle to the last file that was
            returned, or 0 if this is the first call.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

        Parameters.Get.ResumeHandle - a handle to the last file
            returned.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    //
    // If this is a GetInfo API, we really want to start with the file
    // corresponding to the resume handle, not the one after it.
    // Decrement the resume handle.
    //

    if ( (Srp->Flags & SRP_RETURN_SINGLE_ENTRY) != 0 ) {
        Srp->Parameters.Get.ResumeHandle--;
    }

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvRfcbList,
               FilterFiles,
               SizeFiles,
               FillFileInfoBuffer
               );

} // SrvNetFileEnum


VOID
FillFileInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed file structure and associated
    variable data, into a buffer.  Fixed data goes at the beginning of
    the buffer, variable data at the end.

    *** This routine assumes that ALL the data, both fixed and variable,
        will fit.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the Level
        field is used.

    Block - the RFCB from which to get information.

    FixedStructure - where the ine buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PFILE_INFO_3 fi3 = *FixedStructure;
    PRFCB rfcb;
    PLFCB lfcb;
    UNICODE_STRING userName;

    PAGED_CODE( );

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure + FIXED_SIZE_OF_FILE( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    rfcb = Block;
    lfcb = rfcb->Lfcb;

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different file structures are
    //     identical.
    //

    switch( Srp->Level ) {

    case 3:

        //
        // Set level 3 specific fields in the buffer.  Convert the
        // permissions (granted access) stored in the LFCB to the format
        // expected by the API.
        //

        fi3->fi3_permissions = 0;

        if ( (lfcb->GrantedAccess & FILE_READ_DATA) != 0 ) {
            fi3->fi3_permissions |= ACCESS_READ;
        }

        if ( (lfcb->GrantedAccess & FILE_WRITE_DATA) != 0 ) {
            fi3->fi3_permissions |= ACCESS_WRITE;
        }

        if ( (lfcb->GrantedAccess & FILE_EXECUTE) != 0 ) {
            fi3->fi3_permissions |= ACCESS_EXEC;
        }

        if ( (lfcb->GrantedAccess & DELETE) != 0 ) {
            fi3->fi3_permissions |= ACCESS_DELETE;
        }

        if ( (lfcb->GrantedAccess & FILE_WRITE_ATTRIBUTES) != 0 ) {
            fi3->fi3_permissions |= ACCESS_ATRIB;
        }

        if ( (lfcb->GrantedAccess & WRITE_DAC) != 0 ) {
            fi3->fi3_permissions |= ACCESS_PERM;
        }

        //
        // Set count of locks on the RFCB.
        //

        fi3->fi3_num_locks = rfcb->NumberOfLocks;

        //
        // Set up the pathname and username of the RFCB.  Note that we
        // don't return the leading backslash on file names.
        //

        SrvCopyUnicodeStringToBuffer(
            &lfcb->Mfcb->FileName,
            *FixedStructure,
            EndOfVariableData,
            &fi3->fi3_pathname
            );

        ASSERT( fi3->fi3_pathname != NULL );

        SrvGetUserAndDomainName( lfcb->Session, &userName, NULL );

        SrvCopyUnicodeStringToBuffer(
            &userName,
            *FixedStructure,
            EndOfVariableData,
            &fi3->fi3_username
            );

        if( userName.Buffer ) {
            SrvReleaseUserAndDomainName( lfcb->Session, &userName, NULL );
        }

        //ASSERT( fi3->fi3_username != NULL );

        // *** Lack of break is intentional!

    case 2:

        //
        // Set up the file ID.  Note that it is the same value as is
        // used for the resume handle, so it is possible to use this
        // value for rewindability.
        //

        fi3->fi3_id = rfcb->GlobalRfcbListEntry.ResumeHandle;

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillFileInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

        return;
    }

    return;

} // FillFileInfoBuffer


BOOLEAN
FilterFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular RFCB should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  ResumeHandle is
        used if this is a NetFileGetInfo; Name1 is used as the path
        name and Name2 is used as the user name if this is a
        NetFileEnum.

    Block - a pointer to the RFCB to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PRFCB rfcb = Block;
    PLFCB lfcb = rfcb->Lfcb;
    PMFCB mfcb = lfcb->Mfcb;
    UNICODE_STRING pathName;
    UNICODE_STRING userName;

    PAGED_CODE( );

    //
    // Check if this is an Enum or GetInfo command.  The SRP_RETURN_SINGLE_ENTRY
    // flag is set if this is a get info.
    //

    if ( (Srp->Flags & SRP_RETURN_SINGLE_ENTRY) == 0 ) {

        //
        // If a user name was specified, the user name on the session
        // must match the user name in the SRP exactly.
        //

        if ( Srp->Name2.Length != 0 ) {

            //
            // Get the user name for the owning session
            //
            SrvGetUserAndDomainName( lfcb->Session, &userName, NULL );

            if( userName.Buffer == NULL ) {
                //
                // Since we don't know who owns the session, we can't match
                //   the username
                //
                return FALSE;
            }

            if ( !RtlEqualUnicodeString(
                      &Srp->Name2,
                      &userName,
                      TRUE ) ) {

                //
                // The names don't match.  Don't put this RFCB in the
                // output buffer.
                //

                SrvReleaseUserAndDomainName( lfcb->Session, &userName, NULL );
                return FALSE;
            }

            SrvReleaseUserAndDomainName( lfcb->Session, &userName, NULL );
        }

        //
        // See if the names match to as many digits of precision as are in
        // the specified base name.  Note that if no base name was
        // specified, then the length = 0 and the file path will always
        // match.  Also note that the path name stored in the MFCB has a
        // leading backslash, while the passed-in path name will never have
        // this leading slash, hence the increment of the MFCB file name
        // buffer.
        //

        pathName.Buffer = mfcb->FileName.Buffer;
        pathName.Length =
            MIN( Srp->Name1.Length, mfcb->FileName.Length );
        pathName.MaximumLength = mfcb->FileName.MaximumLength;

        return RtlEqualUnicodeString(
                   &Srp->Name1,
                   &pathName,
                   TRUE
                   );
    }

    //
    // It's a GetInfo, so just see if the ResumeHandle in the SRP
    // matches the ResumeHandle on the RFCB.  We increment the value in
    // the SRP because it was decremented before calling
    // SrvEnumApiHandler.
    //

    return (BOOLEAN)( Srp->Parameters.Get.ResumeHandle + 1==
                          SrvGetResumeHandle( &SrvRfcbList, rfcb ) );

} // FilterFiles


ULONG
SizeFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in RFCB would take up
    in an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the level
        parameter is used.

    Block - a pointer to the RFCB to size.

Return Value:

    ULONG - The number of bytes the file would take up in the output
        buffer.

--*/

{
    PRFCB rfcb = Block;
    UNICODE_STRING userName;
    ULONG size;

    PAGED_CODE( );

    SrvGetUserAndDomainName( rfcb->Lfcb->Session, &userName, NULL );

    size = TOTAL_SIZE_OF_FILE( rfcb->Lfcb, Srp->Level, &userName );

    SrvReleaseUserAndDomainName( rfcb->Lfcb->Session, &userName, NULL );

    return size;

} // SizeFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcstats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcstats.c

Abstract:

    This module contains routines for supporting the NetStatisticsGet.

Author:

    David Treadwell (davidtr) 12-Apr-1991

Revision History:

--*/

#include "precomp.h"
#include "svcstats.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetStatisticsGet )
#endif


NTSTATUS
SrvNetStatisticsGet (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the server half of NetStatisticsGet in
    the server FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Flags - MBZ

      OUTPUT:

        Not used.

    Buffer - a pointer to a STAT_SERVER_0 structure for the new share.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    SRV_STATISTICS capturedStats;
    PSTAT_SERVER_0 sts0 = Buffer;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Make sure that the user's buffer is large enough.
    //

    if ( BufferLength < sizeof(STAT_SERVER_0) ) {
        Srp->ErrorCode = NERR_BufTooSmall;
        return STATUS_SUCCESS;
    }

    //
    // Indicate in the SRP that we read one stucture.  We always read
    // exactly one structure for this API.
    //

    Srp->Parameters.Get.EntriesRead = 1;

    //
    // Get a copy of the latest server statistics.
    //

    SrvUpdateStatisticsFromQueues( &capturedStats );

    //
    // Fill in the fields in the statistics structure.
    //

    try {

        RtlTimeToSecondsSince1970(
            &capturedStats.StatisticsStartTime,
            &sts0->sts0_start
            );

        sts0->sts0_fopens = capturedStats.TotalFilesOpened;
        sts0->sts0_devopens = 0;
        sts0->sts0_jobsqueued = 0;
        sts0->sts0_sopens = capturedStats.CurrentNumberOfSessions;
        sts0->sts0_stimedout = capturedStats.SessionsTimedOut;
        sts0->sts0_serrorout = capturedStats.SessionsErroredOut;
        sts0->sts0_pwerrors = capturedStats.LogonErrors;
        sts0->sts0_permerrors = capturedStats.AccessPermissionErrors;
        sts0->sts0_syserrors = capturedStats.SystemErrors;
        sts0->sts0_bytessent_low = capturedStats.TotalBytesSent.LowPart;
        sts0->sts0_bytessent_high = capturedStats.TotalBytesSent.HighPart;
        sts0->sts0_bytesrcvd_low = capturedStats.TotalBytesReceived.LowPart;
        sts0->sts0_bytesrcvd_high = capturedStats.TotalBytesReceived.HighPart;

        //
        // Calculate the average response time by finding the total number
        // of SMBs we have received, the total time we have spent processing
        // them, and dividing to get the average.
        //

        sts0->sts0_avresponse = 0;

        //
        // Since we autotune the buffer counts, we never say that we had to
        // add more of them.  These are supposed to flag an admin that
        // parameters need adjustment, but we do it ourselves.
        //
        // !!! We probably won't really autotune them!

        sts0->sts0_reqbufneed = 0;
        sts0->sts0_bigbufneed = 0;

        status = STATUS_SUCCESS;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();
    }

    return status;

} // SrvNetStatisticsGet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcsrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcsrv.c

Abstract:

    This module contains routines for supporting the server APIs in the
    server service, SrvNetServerDiskEnum, and SrvNetServerSetInfo.

Author:

    David Treadwell (davidtr) 31-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcsrv.tmh"
#pragma hdrstop

//
// Forward declarations.
//

LARGE_INTEGER
SecondsToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    );

LARGE_INTEGER
MinutesToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    );

ULONG
MultipleOfProcessors (
    IN ULONG value
    );

BOOL
IsSuiteVersion(
    IN USHORT Version
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetServerDiskEnum )
#pragma alloc_text( PAGE, SrvNetServerSetInfo )
#pragma alloc_text( PAGE, SecondsToTime )
#pragma alloc_text( PAGE, MinutesToTime )
#pragma alloc_text( PAGE, MultipleOfProcessors )
#pragma alloc_text( PAGE, IsSuiteVersion )
#endif

#define IsWebBlade() IsSuiteVersion(VER_SUITE_BLADE)
#define IsPersonal() IsSuiteVersion(VER_SUITE_PERSONAL)
#define IsEmbedded() IsSuiteVersion(VER_SUITE_EMBEDDEDNT)

BOOL
IsSuiteVersion(USHORT Version)
{
    OSVERSIONINFOEX Osvi;
    DWORD TypeMask;
    DWORDLONG ConditionMask;

    memset(&Osvi, 0, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.wSuiteMask = Version;
    TypeMask = VER_SUITENAME;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
    return(NT_SUCCESS(RtlVerifyVersionInfo(&Osvi, TypeMask, ConditionMask)));
}




NTSTATUS
SrvNetServerDiskEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
{
    PAGED_CODE( );

    Srp, Buffer, BufferLength;
    return STATUS_NOT_IMPLEMENTED;

} // SrvNetServerDiskEnum


NTSTATUS
SrvNetServerSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerSetInfo API in the server FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        None.

      OUTPUT:

        None.

    Buffer - a pointer to a SERVER_INFO_102, followed immediately by a
        SERVER_INFO_599 structure, followed by a SERVER_INFO_559a
        structure.  All information is always reset in this routine; the
        server service also tracks this data, so when it gets a
        NetServerSetInfo it overwrites the appropriate fields and sends
        all the data.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    PSERVER_INFO_102 sv102;
    PSERVER_INFO_599 sv599;
    PSERVER_INFO_598 sv598;

    LARGE_INTEGER scavengerTimeout;
    LARGE_INTEGER alerterTimeout;

    ULONG ipxdisc;
    LARGE_INTEGER li;
    ULONG bufferOffset;
    ULONG keTimeIncrement;

    PAGED_CODE( );

    //
    // Make sure that the input buffer length is correct.
    //
    if ( BufferLength < sizeof(SERVER_INFO_102) +
                        sizeof(SERVER_INFO_599) + sizeof(SERVER_INFO_598) ) {
        return status;
    }

    //
    // Set up buffer pointers as appropriate.  The SERVER_INFO_599
    // structure must immediately follow the SERVER_INFO_102 structure
    // in the buffer.
    //

    sv102 = Buffer;
    sv599 = (PSERVER_INFO_599)(sv102 + 1);
    sv598 = (PSERVER_INFO_598)(sv599 + 1);

    //
    // store the time increment count
    //

    keTimeIncrement = KeQueryTimeIncrement();

    //
    // Grab the lock that protects configuration changes.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    //
    // Set all configuration information in the server.
    //

    try {

        SrvMaxUsers = sv102->sv102_users;

        //
        // The autodisconnect timeout must be converted from minutes to NT
        // time, which has a base of 100s of nanoseconds.  If the specified
        // value is negative (top bit set), set the timeout to 0, indicating
        // that no autodisconnect should be done.  If the specified value is
        // 0, meaning to autodisconnect immediately, set the timeout to a
        // small value, but not 0.
        //

        if ( (sv102->sv102_disc & 0x80000000) == 0 ) {
            if ( sv102->sv102_disc != 0 ) {
                SrvAutodisconnectTimeout.QuadPart =
                    Int32x32To64( sv102->sv102_disc, 10*1000*1000*60 );
            } else {
                SrvAutodisconnectTimeout.QuadPart = 1;
            }
        } else {
            SrvAutodisconnectTimeout.QuadPart = 0;
        }

        SrvInitialSessionTableSize = (USHORT)sv599->sv599_initsesstable;
        SrvInitialTreeTableSize = (USHORT)sv599->sv599_initconntable;
        SrvInitialFileTableSize = (USHORT)sv599->sv599_initfiletable;
        SrvInitialSearchTableSize = (USHORT)sv599->sv599_initsearchtable;
        SrvMaxFileTableSize = (USHORT)sv599->sv599_sessopens;
        SrvMaxNumberVcs = sv599->sv599_sessvcs;
        SrvMaxSearchTableSize = (USHORT)sv599->sv599_opensearch;
        SrvReceiveBufferLength = sv599->sv599_sizreqbuf;
        SrvReceiveBufferSize = (SrvReceiveBufferLength + SrvCacheLineSize) & ~SrvCacheLineSize;
        SrvReceiveMdlSize = (ULONG)(MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), SrvReceiveBufferSize ) + 7) & ~7;
        SrvMaxMdlSize = (ULONG)(MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), MAX_PARTIAL_BUFFER_SIZE ) + 7) & ~7;
        SrvInitialReceiveWorkItemCount = sv599->sv599_initworkitems;
        SrvMaxReceiveWorkItemCount = sv599->sv599_maxworkitems;
        SrvInitialRawModeWorkItemCount = sv599->sv599_rawworkitems;
        SrvReceiveIrpStackSize = (CCHAR)sv599->sv599_irpstacksize;
        SrvReceiveIrpSize = (IoSizeOfIrp( SrvReceiveIrpStackSize ) + 7) & ~7;
        SrvMaxSessionTableSize = (USHORT)sv599->sv599_sessusers;
        SrvMaxTreeTableSize = (USHORT)sv599->sv599_sessconns;
        SrvMaxPagedPoolUsage = sv599->sv599_maxpagedmemoryusage;
        SrvMaxNonPagedPoolUsage = sv599->sv599_maxnonpagedmemoryusage;
        SrvEnableSoftCompatibility = (BOOLEAN)sv599->sv599_enablesoftcompat;
        SrvEnableForcedLogoff = (BOOLEAN)sv599->sv599_enableforcedlogoff;
        SrvCoreSearchTimeout = sv599->sv599_maxkeepsearch;
        SrvSearchMaxTimeout = SecondsToTime( SrvCoreSearchTimeout, FALSE );
        SrvScavengerTimeoutInSeconds = sv599->sv599_scavtimeout;
        scavengerTimeout = SecondsToTime( SrvScavengerTimeoutInSeconds, FALSE );
        SrvMaxMpxCount = (USHORT)sv599->sv599_maxmpxct;
        SrvWaitForOplockBreakTime = SecondsToTime( sv599->sv599_oplockbreakwait, FALSE );
        SrvWaitForOplockBreakRequestTime = SecondsToTime( sv599->sv599_oplockbreakresponsewait, FALSE );
        SrvMinReceiveQueueLength = sv599->sv599_minrcvqueue;
        SrvMinFreeWorkItemsBlockingIo = sv599->sv599_minfreeworkitems;
        SrvXsSectionSize.QuadPart = sv599->sv599_xactmemsize;
        SrvThreadPriority = (KPRIORITY)sv599->sv599_threadpriority;
        SrvEnableOplockForceClose = (BOOLEAN)sv599->sv599_enableoplockforceclose;
        SrvEnableFcbOpens = (BOOLEAN)sv599->sv599_enablefcbopens;
        SrvEnableRawMode = (BOOLEAN)sv599->sv599_enableraw;
        SrvFreeConnectionMinimum = sv599->sv599_minfreeconnections;
        SrvFreeConnectionMaximum = sv599->sv599_maxfreeconnections;

        //
        // Max work item idle time is in ticks
        //

        li =  SecondsToTime( sv599->sv599_maxworkitemidletime, FALSE );
        li.QuadPart /= keTimeIncrement;
        if ( li.HighPart != 0 ) {
            li.LowPart = 0xffffffff;
        }
        SrvWorkItemMaxIdleTime = li.LowPart;

        //
        // Oplocks should not be enabled if SrvMaxMpxCount == 1
        //

        if ( SrvMaxMpxCount > 1 ) {
            SrvEnableOplocks = (BOOLEAN)sv599->sv599_enableoplocks;
        } else {
            SrvEnableOplocks = FALSE;
        }

        SrvProductTypeServer = MmIsThisAnNtAsSystem( );

        SrvServerSize = sv598->sv598_serversize;

        SrvMaxRawModeWorkItemCount = sv598->sv598_maxrawworkitems;
        SrvMaxThreadsPerQueue = sv598->sv598_maxthreadsperqueue;
        ipxdisc = sv598->sv598_connectionlessautodisc;
        SrvConnectionNoSessionsTimeout = sv598->sv598_ConnectionNoSessionsTimeout;

        SrvRemoveDuplicateSearches =
                (BOOLEAN)sv598->sv598_removeduplicatesearches;
        SrvMaxOpenSearches = sv598->sv598_maxglobalopensearch;
        SrvSharingViolationRetryCount = sv598->sv598_sharingviolationretries;
        SrvSharingViolationDelay.QuadPart =
            Int32x32To64( sv598->sv598_sharingviolationdelay, -1*10*1000 );

        SrvLockViolationDelay = sv598->sv598_lockviolationdelay;

        SrvLockViolationOffset = sv598->sv598_lockviolationoffset;

        SrvCachedOpenLimit = sv598->sv598_cachedopenlimit;
        SrvMdlReadSwitchover = sv598->sv598_mdlreadswitchover;
        SrvEnableWfW311DirectIpx =
                    (BOOLEAN)sv598->sv598_enablewfw311directipx;
        SrvRestrictNullSessionAccess =
                    (BOOLEAN)sv598->sv598_restrictnullsessaccess;

        SrvQueueCalc = SecondsToTime( sv598->sv598_queuesamplesecs, FALSE );
        SrvPreferredAffinity = sv598->sv598_preferredaffinity;
        SrvOtherQueueAffinity = sv598->sv598_otherqueueaffinity;
        SrvBalanceCount = sv598->sv598_balancecount;

        SrvMaxFreeRfcbs = sv598->sv598_maxfreerfcbs;
        SrvMaxFreeMfcbs = sv598->sv598_maxfreemfcbs;
        SrvMaxPagedPoolChunkSize = sv598->sv598_maxpagedpoolchunksize;

        SrvMaxCachedDirectory = sv598->sv598_cacheddirectorylimit;

        SrvMaxCopyLength = sv598->sv598_maxcopylength;

        SrvMinClientBufferSize = sv598->sv598_minclientbuffersize;
        SrvMinClientBufferSize &= ~03;

        SrvSupportsCompression = (sv598->sv598_enablecompression != FALSE);

        SrvSmbSecuritySignaturesEnabled  = (sv598->sv598_enablesecuritysignature != FALSE);
        SrvSmbSecuritySignaturesRequired = (sv598->sv598_requiresecuritysignature != FALSE);
        SrvEnableW9xSecuritySignatures   = (sv598->sv598_enableW9xsecuritysignature != FALSE);

        ServerGuid = sv598->sv598_serverguid;

        SrvEnforceLogoffTimes = (sv598->sv598_enforcekerberosreauthentication != FALSE);
        SrvDisableDoSChecking = (sv598->sv598_disabledos != FALSE);
        SrvDisableStrictNameChecking = (sv598->sv598_disablestrictnamechecking != FALSE);
        SrvFreeDiskSpaceCeiling = sv598->sv598_lowdiskspaceminimum;

        //
        // Make sure the settings are consistent!
        //
        if( SrvSmbSecuritySignaturesEnabled == FALSE ) {
            SrvSmbSecuritySignaturesRequired = FALSE;
        }

        SrvMaxNonPagedPoolChunkSize = SrvMaxPagedPoolChunkSize;

        SrvLockViolationDelayRelative.QuadPart =
            Int32x32To64( sv598->sv598_lockviolationdelay, -1*10*1000 );

        //
        // Convert the idle thread timeout from seconds to ticks
        //
        SrvIdleThreadTimeOut =
            Int32x32To64( sv598->sv598_IdleThreadTimeOut, -1*10*1000*1000 );

        //
        // Calculate switchover number for mpx
        //

        bufferOffset = (sizeof(SMB_HEADER) + sizeof(RESP_READ_MPX) - 1 + 3) & ~3;

        if ( SrvMdlReadSwitchover > (SrvReceiveBufferLength - bufferOffset) ) {

            SrvMpxMdlReadSwitchover = SrvReceiveBufferLength - bufferOffset;

        } else {

            SrvMpxMdlReadSwitchover = SrvMdlReadSwitchover;
        }

        //
        // The IPX autodisconnect timeout must be converted from minutes to
        // ticks.  If 0 is specified, use 15 minutes.
        //

        if ( ipxdisc == 0 ) {
            ipxdisc = 15;
        }
        li.QuadPart = Int32x32To64( ipxdisc, 10*1000*1000*60 );
        li.QuadPart /= keTimeIncrement;
        if ( li.HighPart != 0 ) {
            li.LowPart = 0xffffffff;
        }
        SrvIpxAutodisconnectTimeout = li.LowPart;

        //
        // The "idle connection without sessions" timeout must be converted from
        //  minutes to ticks.
        //
        li.QuadPart = Int32x32To64( SrvConnectionNoSessionsTimeout, 10*1000*1000*60 );
        li.QuadPart /= keTimeIncrement;
        if( li.HighPart != 0 ) {
            li.LowPart = 0xffffffff;
        }
        SrvConnectionNoSessionsTimeout = li.LowPart;

        //
        // Event logging and alerting information.
        //

        alerterTimeout = MinutesToTime( sv599->sv599_alertschedule, FALSE );
        SrvAlertMinutes = sv599->sv599_alertschedule;
        SrvErrorRecord.ErrorThreshold = sv599->sv599_errorthreshold;
        SrvNetworkErrorRecord.ErrorThreshold =
                            sv599->sv599_networkerrorthreshold;
        SrvFreeDiskSpaceThreshold = sv599->sv599_diskspacethreshold;

        SrvCaptureScavengerTimeout( &scavengerTimeout, &alerterTimeout );

        //
        // Link Speed Parameters
        //

        SrvMaxLinkDelay = SecondsToTime( sv599->sv599_maxlinkdelay, FALSE );

        SrvMinLinkThroughput.QuadPart = sv599->sv599_minlinkthroughput;

        SrvLinkInfoValidTime =
                SecondsToTime ( sv599->sv599_linkinfovalidtime, FALSE );

        SrvScavengerUpdateQosCount =
            sv599->sv599_scavqosinfoupdatetime / sv599->sv599_scavtimeout;

        //
        // Override parameters that cannot be set on WinNT (vs. NTAS).
        //
        // We override the parameters passed by the service in case somebody
        // figures out the FSCTL that changes parameters.  We also override
        // in the service in order to keep the service's view consistent
        // with the server's.  If you make any changes here, also make them
        // in srvsvc\server\registry.c.
        //

        //
        // For Embedded systems, just take the registry value.  They do their own
        // validation of settings.
        //
        if( !IsEmbedded() )
        {
            if ( !SrvProductTypeServer ) {

                //
                // On WinNT, the maximum value of certain parameters is fixed at
                // build time.  These include: concurrent users, SMB buffers,
                //

    #define MINIMIZE(_param,_max) _param = MIN( _param, _max );

                MINIMIZE( SrvMaxUsers, MAX_USERS_WKSTA );
                MINIMIZE( SrvMaxReceiveWorkItemCount, MAX_MAXWORKITEMS_WKSTA );
                MINIMIZE( SrvMaxThreadsPerQueue, MAX_THREADS_WKSTA );

                if( IsPersonal() )
                {
                    MINIMIZE( SrvMaxUsers, MAX_USERS_PERSONAL );
                }

                //
                // On WinNT, we do not cache the following:
                //

                SrvCachedOpenLimit = 0;         // don't cache close'd files
                SrvMaxCachedDirectory = 0;      // don't cache directory names
                SrvMaxFreeRfcbs = 0;            // don't cache free'd RFCB structs
                SrvMaxFreeMfcbs = 0;            // don't cache free'd NONPAGED_MFCB structs
            }

            if( IsWebBlade() )
            {
                MINIMIZE( SrvMaxUsers, MAX_USERS_WEB_BLADE );
                MINIMIZE( SrvMaxReceiveWorkItemCount, MAX_MAXWORKITEMS_WKSTA );
                MINIMIZE( SrvMaxThreadsPerQueue, MAX_THREADS_WKSTA );
            }
        }

        if( (SrvMaxUsers < UINT_MAX) && (SrvMaxUsers > 0) )
        {
            // Increment by 1 to allow the "emergency admin" user.  Essentially, the final user
            // to connect must be an administrator in case something is going wrong, such as DoS
            SrvMaxUsers += 1;
        }

        //
        // The following items are generally per-processor.  Ensure they
        // are a multiple of the number of processors in the system.
        //
        SrvMaxReceiveWorkItemCount =
            MultipleOfProcessors( SrvMaxReceiveWorkItemCount );

        SrvInitialReceiveWorkItemCount =
            MultipleOfProcessors( SrvInitialReceiveWorkItemCount );

        SrvMinReceiveQueueLength =
            MultipleOfProcessors( SrvMinReceiveQueueLength );

        SrvMaxRawModeWorkItemCount =
            MultipleOfProcessors( SrvMaxRawModeWorkItemCount );

        SrvInitialRawModeWorkItemCount =
            MultipleOfProcessors( SrvInitialRawModeWorkItemCount );


        status = STATUS_SUCCESS;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();
    }

    RELEASE_LOCK( &SrvConfigurationLock );

    return status;

} // SrvNetServerSetInfo


LARGE_INTEGER
SecondsToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    )

/*++

Routine Description:

    This routine converts a time interval specified in seconds to
    the NT time base in 100s on nanoseconds.

Arguments:

    Seconds - the interval in seconds.

    MakeNegative - if TRUE, the time returned is a negative, i.e. relative
        time.

Return Value:

    LARGE_INTEGER - the interval in NT time.

--*/

{
    LARGE_INTEGER ntTime;

    PAGED_CODE( );

    if ( MakeNegative ) {
        ntTime.QuadPart = Int32x32To64( Seconds, -1*10*1000*1000 );
    } else {
        ntTime.QuadPart = Int32x32To64( Seconds, 1*10*1000*1000 );
    }

    return ntTime;

} // SecondsToTime


LARGE_INTEGER
MinutesToTime (
    IN ULONG Minutes,
    IN BOOLEAN MakeNegative
    )

/*++

Routine Description:

    This routine converts a time interval specified in minutes to
    the NT time base in 100s on nanoseconds.

Arguments:

    Minutes - the interval in minutes.

    MakeNegative - if TRUE, the time returned is a negative, i.e. relative
        time.

Return Value:

    LARGE_INTEGER - the interval in NT time.

--*/

{
    PAGED_CODE( );

    return SecondsToTime( 60*Minutes, MakeNegative );

} // MinutesToTime

ULONG
MultipleOfProcessors(
    IN ULONG value
    )
/*++

Routine Description:

    This routine ensures the passed in value is a multiple of the number
    of processors in the system.  The value will be adjusted upward if
    necessary.

Arguments:

    value - the value to be adjusted

Return Value:

    the adjusted value

--*/
{
    value += SrvNumberOfProcessors - 1;
    value /= SrvNumberOfProcessors;
    value *= SrvNumberOfProcessors;

    return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcshare.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcshare.c

Abstract:

    This module contains routines for supporting the share APIs in the
    server service, NetShareAdd, NetShareCheck, NetShareDel,
    NetShareEnum, NetShareGetInfo, and NetShareSetInfo.

Author:

    David Treadwell (davidtr) 15-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcshare.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCSHARE

#define DISK_ROOT_NAME_TEMPLATE L"\\DosDevices\\X:\\"

//
// Forward declarations.
//

STATIC
VOID
FillShareInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

STATIC
BOOLEAN
FilterShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

STATIC
ULONG
SizeShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetShareAdd )
#pragma alloc_text( PAGE, SrvNetShareDel )
#pragma alloc_text( PAGE, SrvNetShareEnum )
#pragma alloc_text( PAGE, SrvNetShareSetInfo )
#pragma alloc_text( PAGE, FillShareInfoBuffer )
#pragma alloc_text( PAGE, FilterShares )
#pragma alloc_text( PAGE, SizeShares )
#endif


#define FIXED_SIZE_OF_SHARE(level)                      \
    ( (level) == 0    ? sizeof(SHARE_INFO_0) :          \
      (level) == 1    ? sizeof(SHARE_INFO_1) :          \
      (level) == 2    ? sizeof(SHARE_INFO_2) :          \
      (level) == 501  ? sizeof(SHARE_INFO_501) :        \
      (level) == 502  ? sizeof(SHARE_INFO_502) :        \
                        sizeof(SHARE_INFO_1005) )


NTSTATUS
SrvNetShareAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareAdd API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - the NT path name of the share.

      OUTPUT:

        Parameters.Set.ErrorParameter - if STATUS_INVALID_PARAMETER is
            returned, this contains the index of the parameter in error.

    Buffer - a pointer to a SHARE_INFO2 structure for the new share.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
#ifdef INCLUDE_SMB_PERSISTENT
    ULONG strippedType;
    BOOLEAN allowPersistentHandles;
#endif
    NTSTATUS status;
    PSHARE share;
    SHARE_TYPE shareType;
    BOOLEAN isSpecial;
    BOOLEAN isRemovable;
    BOOLEAN isCdrom;
    UNICODE_STRING shareName;
    UNICODE_STRING ntPath;
    UNICODE_STRING dosPath;
    UNICODE_STRING remark;
    PSHARE_INFO_502 shi502;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;
    PSECURITY_DESCRIPTOR fileSecurityDescriptor = NULL;

    PAGED_CODE( );

    //
    // We usually don't return any information about the parameter in
    // error.
    //

    Srp->Parameters.Set.ErrorParameter = 0;

    //
    // Convert the offsets in the share data structure to pointers.  Also
    // make sure that all the pointers are within the specified buffer.
    //

    shi502 = Buffer;

    OFFSET_TO_POINTER( shi502->shi502_netname, shi502 );
    OFFSET_TO_POINTER( shi502->shi502_remark, shi502 );
    OFFSET_TO_POINTER( shi502->shi502_path, shi502 );
    OFFSET_TO_POINTER( shi502->shi502_security_descriptor, shi502 );

    //
    // Construct the security descriptor pointer by hand, because
    // shi502_permissions is only 32 bits in width.
    //

    if( shi502->shi502_permissions ) {
        securityDescriptor =
            (PSECURITY_DESCRIPTOR)((PCHAR)shi502 + shi502->shi502_permissions);
    }
    else
    {
        // Connect securityDescriptor is REQUIRED!
        return STATUS_INVALID_PARAMETER;
    }

    if ( !POINTER_IS_VALID( shi502->shi502_netname, shi502, BufferLength ) ||
         !POINTER_IS_VALID( shi502->shi502_remark, shi502, BufferLength ) ||
         !POINTER_IS_VALID( shi502->shi502_path, shi502, BufferLength ) ||
         !POINTER_IS_VALID( securityDescriptor, shi502, BufferLength ) ||
         !POINTER_IS_VALID( shi502->shi502_security_descriptor, shi502, BufferLength ) ) {

        return STATUS_ACCESS_VIOLATION;
    }


    //
    // Check the share type
    //

    isSpecial = (BOOLEAN)((shi502->shi502_type & STYPE_SPECIAL) != 0);

    isRemovable = FALSE;
    isCdrom = FALSE;

#ifdef INCLUDE_SMB_PERSISTENT
    allowPersistentHandles = (BOOLEAN)((shi502->shi502_type & STYPE_PERSISTENT) != 0);

    strippedType = shi502->shi502_type & ~(STYPE_TEMPORARY|STYPE_SPECIAL);
    strippedType = strippedType & ~STYPE_PERSISTENT;

    if (strippedType == STYPE_DISKTREE) {

        // for now, hardcode in that all disk shares are persistent.
        // need to fix this for persistent handles.
        allowPersistentHandles = TRUE;
    }

    switch ( strippedType ) {
#else
    switch ( shi502->shi502_type & ~(STYPE_TEMPORARY|STYPE_SPECIAL) ) {
#endif
    case STYPE_CDROM:

        isCdrom = TRUE;         // lack of break is intentional

    case STYPE_REMOVABLE:

        isRemovable = TRUE;     // lack of break is intentional

    case STYPE_DISKTREE:

        shareType = ShareTypeDisk;
        break;

    case STYPE_PRINTQ:

        shareType = ShareTypePrint;
        break;

    case STYPE_IPC:

        shareType = ShareTypePipe;
        break;

    default:

        //
        // An illegal share type was passed in.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvNetShareAdd: illegal share type: %ld\n",
                          shi502->shi502_type ));
        }

        Srp->Parameters.Set.ErrorParameter = SHARE_TYPE_PARMNUM;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get pointers to the share name, path, remark, and security
    // descriptor.
    //

    RtlInitUnicodeString( &shareName, (PWCH)shi502->shi502_netname );
    ntPath = Srp->Name1;
    RtlInitUnicodeString( &dosPath, (PWCH)shi502->shi502_path );
    RtlInitUnicodeString( &remark, (PWCH)shi502->shi502_remark );

    //
    // If this is level 502, get the file security descriptor
    //

    if ( Srp->Level == 502 ) {

        fileSecurityDescriptor = shi502->shi502_security_descriptor;

        //
        // if the sd is invalid, quit.
        //

        if ( fileSecurityDescriptor != NULL &&
             !RtlValidSecurityDescriptor( fileSecurityDescriptor) ) {

            Srp->Parameters.Set.ErrorParameter = SHARE_FILE_SD_PARMNUM;
            return STATUS_INVALID_PARAMETER;
        }

    }

    //
    // Allocate a share block.
    //

    SrvAllocateShare(
        &share,
        &shareName,
        &ntPath,
        &dosPath,
        &remark,
        securityDescriptor,
        fileSecurityDescriptor,
        shareType
        );

    if ( share == NULL ) {
        DEBUG KdPrint(( "SrvNetShareAdd: unable to allocate share block\n" ));
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    share->SpecialShare = isSpecial;
    share->Removable = isRemovable;
#ifdef INCLUDE_SMB_PERSISTENT
    share->AllowPersistentHandles = allowPersistentHandles;
#endif

    //
    // Set the MaxUses field in the share.  The CurrentUses field was
    // zeroed by SrvAllocateShare.
    //

    share->MaxUses = shi502->shi502_max_uses;

    if ( shareType == ShareTypePrint ) {

        status = SrvOpenPrinter((PWCH)shi502->shi502_path,
                     &share->Type.hPrinter,
                     &Srp->ErrorCode
                     );

        if ( !NT_SUCCESS(status) ) {
            SrvFreeShare( share );
            return status;
        }

        if ( Srp->ErrorCode != NO_ERROR ) {
            SrvFreeShare( share );
            return STATUS_SUCCESS;
        }
    }

    //
    // Mark the share if it is in the DFS
    //
    SrvIsShareInDfs( share, &share->IsDfs, &share->IsDfsRoot );

    //
    // Ensure that another share with the same name doesn't already
    // exist.  Insert the share block in the global share list.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    if ( SrvFindShare( &share->ShareName ) != NULL ) {

        //
        // A share with the same name exists.  Clean up and return an
        // error.
        //
        // *** Note that SrvFindShare ignores existing shares that are
        //     closing.  This allows a new share to be created even if
        //     and old share with the same name is in the "twilight
        //     zone" between existence and nonexistence because of a
        //     stray reference.
        //

        RELEASE_LOCK( &SrvShareLock );

        SrvFreeShare( share );

        Srp->ErrorCode = NERR_DuplicateShare;
        return STATUS_SUCCESS;
    }

    //
    // Insert the share on the global ordered list.
    //

    SrvAddShare( share );

    RELEASE_LOCK( &SrvShareLock );

    //
    // Is this is a removable type e.g. Floppy or CDROM, fill up the
    // file system name.
    //

    if ( isRemovable ) {

        PWSTR fileSystemName;
        ULONG fileSystemNameLength;

        if ( isCdrom ) {

            //
            // uses cdfs
            //

            fileSystemName = StrFsCdfs;
            fileSystemNameLength = sizeof( FS_CDFS ) - sizeof(WCHAR);

        } else {

            //
            // assume it's fat
            //

            fileSystemName = StrFsFat;
            fileSystemNameLength = sizeof( FS_FAT ) - sizeof(WCHAR);
        }


        SrvFillInFileSystemName(
                            share,
                            fileSystemName,
                            fileSystemNameLength
                            );

    }

    //
    // If this is an administrative disk share, update SrvDiskConfiguration
    // to cause the scavenger thread to check the disk free space.  The server
    // service has already verified that the format of the pathname is valid
    // before it allowed the ShareAdd to get this far.
    //
    // We want to skip this if its a \\?\ name
    //
    if( share->SpecialShare && share->ShareType == ShareTypeDisk &&
        share->ShareName.Buffer[1] == L'$' &&
        share->DosPathName.Buffer[0] != L'\\' ) {

        ACQUIRE_LOCK( &SrvConfigurationLock );
        SrvDiskConfiguration |= (0x80000000 >> (share->DosPathName.Buffer[0] - L'A'));
        RELEASE_LOCK( &SrvConfigurationLock );
    }

    //
    // Dereference the share block, because we're going to forget
    // its address.  (The initial reference count is 2.)
    //

    SrvDereferenceShare( share );

    return STATUS_SUCCESS;

} // SrvNetShareAdd


NTSTATUS
SrvNetShareDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareDel API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - name of the share to delete.

      OUTPUT:

        None.

    Buffer - unused.

    BufferLength - unused.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PSHARE share;
    DWORD AdministrativeDiskBit = 0;

    PAGED_CODE( );

    Buffer, BufferLength;

    //
    // Find the share with the specified name.  Note that if a share
    // with the specified name exists but is closing, it will not be
    // found.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    share = SrvFindShare( &Srp->Name1 );

    if ( share == NULL ) {

        //
        // No share with the specified name exists.  Return an error.
        //

        RELEASE_LOCK( &SrvShareLock );

        Srp->ErrorCode = NERR_NetNameNotFound;
        return STATUS_SUCCESS;

    }

    //
    // Make sure the DFS state for this share is accurate
    //
    SrvIsShareInDfs( share, &share->IsDfs, &share->IsDfsRoot );

    //
    // If the share really is in the DFS, then do not allow it to be deleted
    //
    if( share->IsDfs == TRUE ) {

        RELEASE_LOCK( &SrvShareLock );

        IF_DEBUG( DFS ) {
            KdPrint(("NetShareDel attempted on share in DFS!\n" ));
        }

        Srp->ErrorCode = NERR_IsDfsShare;

        return STATUS_SUCCESS;
    }

    // Don't allow the deletion of IPC$, as behavior is very bad with it gone
    // (Named-pipe traffic doesn't work, so NetAPI's and RPC don't work..)
    if( share->SpecialShare )
    {
        UNICODE_STRING Ipc = { 8, 8, L"IPC$" };

        if( RtlCompareUnicodeString( &Ipc, &share->ShareName, TRUE ) == 0 )
        {
            RELEASE_LOCK( &SrvShareLock );

            Srp->ErrorCode = ERROR_ACCESS_DENIED;

            return STATUS_SUCCESS;
        }
    }


    switch( share->ShareType ) {
    case ShareTypePrint:
        //
        // This is a print share: close the printer.
        //
        SrvClosePrinter( share->Type.hPrinter );
        break;

    case ShareTypeDisk:
        //
        // See if this was an administrative disk share
        //
        if( share->SpecialShare && share->DosPathName.Buffer[1] == L'$' ) {
            AdministrativeDiskBit = (0x80000000 >> (share->DosPathName.Buffer[0] - L'A'));
        }

        break;
    }

    //
    // Close the share, then release the lock.
    //
    // *** Note that this places a requirement on lock levels!  See
    //     lock.h .
    //
#ifdef INCLUDE_SMB_PERSISTENT
    if (share->AllowPersistentHandles) {

        // clean up state file here...
    }
#endif

    SrvCloseShare( share );

    RELEASE_LOCK( &SrvShareLock );

    //
    // If this was an administrative disk share, update SrvDiskConfiguration
    // to cause the scavenger thread to ignore this disk.
    //
    if( AdministrativeDiskBit ) {
        ACQUIRE_LOCK( &SrvConfigurationLock );
        SrvDiskConfiguration &= ~AdministrativeDiskBit;
        RELEASE_LOCK( &SrvConfigurationLock );
    }

    return STATUS_SUCCESS;

} // SrvNetShareDel


NTSTATUS
SrvNetShareEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareEnum API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Level - level of information to return, 0, 1, or 2.

        Parameters.Get.ResumeHandle - share ID to determine where to
            start returning info.  We start with the first share with an
            ID greater than this value.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

        Parameters.Get.ResumeHandle - share ID of last share returned.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    return SrvShareEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               FilterShares,
               SizeShares,
               FillShareInfoBuffer
               );

} // SrvNetShareEnum


NTSTATUS
SrvNetShareSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareSetInfo API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - name of the share to set information on.

        Parameters.Set.Api.ShareInfo.MaxUses - if not 0, a new maximum
            user count.  If the current count of users on the share
            exceeds the new value, no check is made, but no new
            tree connects are allowed.

      OUTPUT:

        Parameters.Set.ErrorParameter - if ERROR_INVALID_PARAMETER is
            returned, this contains the index of the parameter in error.

    Buffer - a pointer to a SHARE_INFO_502 structure.

    BufferLength - length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the user.

--*/

{
    PSHARE share;
    UNICODE_STRING remark;
    PWCH newRemarkBuffer = NULL;
    ULONG maxUses;
    ULONG level;
    PSHARE_INFO_502 shi502;
    PSECURITY_DESCRIPTOR fileSD;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;

    PAGED_CODE( );

    //
    // Convert the offsets in the share data structure to pointers.  Also
    // make sure that all the pointers are within the specified buffer.
    //

    level = Srp->Level;

    switch( level ) {
    default:

        shi502 = Buffer;

        if( shi502->shi502_permissions ) {
            securityDescriptor =
                (PSECURITY_DESCRIPTOR)((PCHAR)shi502 + shi502->shi502_permissions);
        }

        OFFSET_TO_POINTER( shi502->shi502_netname, shi502 );
        OFFSET_TO_POINTER( shi502->shi502_remark, shi502 );
        OFFSET_TO_POINTER( shi502->shi502_path, shi502 );
        OFFSET_TO_POINTER( shi502->shi502_security_descriptor, shi502 );

        if ( !POINTER_IS_VALID( shi502->shi502_netname, shi502, BufferLength ) ||
             !POINTER_IS_VALID( shi502->shi502_remark, shi502, BufferLength ) ||
             !POINTER_IS_VALID( shi502->shi502_path, shi502, BufferLength ) ||
             !POINTER_IS_VALID( securityDescriptor, shi502, BufferLength ) ||
             !POINTER_IS_VALID( shi502->shi502_security_descriptor, shi502, BufferLength ) ) {

            return STATUS_ACCESS_VIOLATION;
        }

        break;

    case 1005:
        break;
    }

    //
    // Acquire the lock that protects the share list and attempt to find
    // the correct share.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    share = SrvFindShare( &Srp->Name1 );

    if ( share == NULL ) {
        IF_DEBUG(API_ERRORS) {
            KdPrint(( "SrvNetShareSetInfo: share %wZ not found.\n",
                          &Srp->Name1 ));
        }
        RELEASE_LOCK( &SrvShareLock );
        Srp->ErrorCode = NERR_NetNameNotFound;
        return STATUS_SUCCESS;
    }

    if( level == 1005 ) {

        if( share->ShareType != ShareTypeDisk ) {
            Srp->Parameters.Set.ErrorParameter = 0;
            Srp->ErrorCode = ERROR_BAD_DEV_TYPE;
        } else {
            PSHARE_INFO_1005 shi1005 = Buffer;

            share->CSCState = shi1005->shi1005_flags & CSC_MASK;

            Srp->ErrorCode = 0;
        }

        RELEASE_LOCK( &SrvShareLock );
        return STATUS_SUCCESS;
    }

    //
    // Set up local variables.
    //

    maxUses = Srp->Parameters.Set.Api.ShareInfo.MaxUses;

    //
    // If a remark was specified, allocate space for a new remark and
    // copy over the remark.
    //

    if ( ARGUMENT_PRESENT( shi502->shi502_remark ) ) {

        RtlInitUnicodeString( &remark, shi502->shi502_remark );

        newRemarkBuffer = ALLOCATE_HEAP_COLD(
                            remark.MaximumLength,
                            BlockTypeDataBuffer
                            );

        if ( newRemarkBuffer == NULL ) {

            RELEASE_LOCK( &SrvShareLock );

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvNetShareSetInfo: unable to allocate %ld bytes of heap.\n",
                remark.MaximumLength,
                NULL
                );

            Srp->Parameters.Set.ErrorParameter = SHARE_REMARK_PARMNUM;
            return STATUS_INSUFF_SERVER_RESOURCES;
        }
    }

    //
    // If a file security descriptor was specified, allocate space for a
    // new SD and copy over the new SD.  We do this before setting the
    // MaxUses in case the allocation fails and we have to back out.
    //
    // Don't let a file ACL be specified for admin shares.
    //

    fileSD = shi502->shi502_security_descriptor;

    if ( ((level == 502) || (level == SHARE_FILE_SD_INFOLEVEL)) &&
            ARGUMENT_PRESENT( fileSD ) ) {

        PSECURITY_DESCRIPTOR newFileSD;
        ULONG newFileSDLength;

        if ( share->SpecialShare || !RtlValidSecurityDescriptor( fileSD ) ) {
            RELEASE_LOCK( &SrvShareLock );
            if ( newRemarkBuffer != NULL) {
                FREE_HEAP( newRemarkBuffer );
            }
            Srp->Parameters.Set.ErrorParameter = SHARE_FILE_SD_PARMNUM;
            return STATUS_INVALID_PARAMETER;
        }

        newFileSDLength = RtlLengthSecurityDescriptor( fileSD );

        newFileSD = ALLOCATE_HEAP_COLD(
                            newFileSDLength,
                            BlockTypeDataBuffer
                            );

        if ( newFileSD == NULL ) {

            RELEASE_LOCK( &SrvShareLock );

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvNetShareSetInfo: unable to allocate %ld bytes of heap.\n",
                newFileSDLength,
                NULL
                );

            Srp->Parameters.Set.ErrorParameter = SHARE_FILE_SD_PARMNUM;

            //
            // Free the remarks buffer allocated
            //

            if ( newRemarkBuffer != NULL) {
                FREE_HEAP( newRemarkBuffer );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        ACQUIRE_LOCK( share->SecurityDescriptorLock );

        //
        // Free the old security descriptor
        //

        if ( share->FileSecurityDescriptor != NULL ) {
            FREE_HEAP( share->FileSecurityDescriptor );
        }

        //
        // And set up the new one.
        //

        share->FileSecurityDescriptor = newFileSD;
        RtlCopyMemory(
                share->FileSecurityDescriptor,
                fileSD,
                newFileSDLength
                );

        RELEASE_LOCK( share->SecurityDescriptorLock );
    }

    //
    // Replace the old remark if a new one was specified.
    //

    if ( newRemarkBuffer != NULL ) {

        //
        // Free the old remark buffer.
        //

        if ( share->Remark.Buffer != NULL ) {
            FREE_HEAP( share->Remark.Buffer );
        }

        //
        // And set up the new one.
        //

        share->Remark.Buffer = newRemarkBuffer;
        share->Remark.MaximumLength = remark.MaximumLength;
        RtlCopyUnicodeString( &share->Remark, &remark );

    }

#ifdef INCLUDE_SMB_PERSISTENT
    if ((shi502->shi502_type != 0) &&
        (share->ShareType == ShareTypeDisk)) {

        if ((BOOLEAN)((shi502->shi502_type & STYPE_PERSISTENT) != 0)) {

            if (! share->AllowPersistentHandles) {

                // init persistent handles here
            }

            share->AllowPersistentHandles = TRUE;

        } else if (share->AllowPersistentHandles ) {

            share->AllowPersistentHandles = FALSE;

            // clean up persistent handle state here.
        }
    }
#endif

    //
    // If MaxUses was specified, set the new value.
    //

    if ( maxUses != 0 ) {
        share->MaxUses = maxUses;
    }

    //
    // Release the share lock.
    //

    RELEASE_LOCK( &SrvShareLock );

    //
    // Set up the error parameter to 0 (no error) and return.
    //

    Srp->Parameters.Set.ErrorParameter = 0;

    return STATUS_SUCCESS;

} // SrvNetShareSetInfo


VOID
FillShareInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed share structure and, if it fits,
    associated variable data, into a buffer.  Fixed data goes at the
    beginning of the buffer, variable data at the end.

Arguments:

    Level - the level of information to copy from the share.

    Block - the share from which to get information.

    FixedStructure - where the ine buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{

    PSHARE share = Block;
    PSHARE_INFO_501 shi501 = *FixedStructure;
    PSHARE_INFO_502 shi502 = *FixedStructure;
    PSHARE_INFO_1005 shi1005 = *FixedStructure;

    PAGED_CODE( );

    //
    // Update FixedStructure to point to the next structure
    // location.
    //

    *FixedStructure = (PCHAR)*FixedStructure + FIXED_SIZE_OF_SHARE( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** This routine assumes that the fixed structure will fit in the
    //     buffer!
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different share structures are
    //     identical.
    //

    switch( Srp->Level ) {
    case 1005:
        shi1005->shi1005_flags = 0;

        SrvIsShareInDfs( share, &share->IsDfs, &share->IsDfsRoot );

        if( share->IsDfs ) {
            shi1005->shi1005_flags |= SHI1005_FLAGS_DFS;
        }
        if( share->IsDfsRoot ) {
            shi1005->shi1005_flags |= SHI1005_FLAGS_DFS_ROOT;
        }
        shi1005->shi1005_flags |= share->CSCState;
        break;

    case 502:

        ACQUIRE_LOCK_SHARED( share->SecurityDescriptorLock );

        if ( share->FileSecurityDescriptor != NULL ) {

            ULONG fileSDLength;
            fileSDLength =
                RtlLengthSecurityDescriptor( share->FileSecurityDescriptor );


            //
            // DWord Align
            //

            *EndOfVariableData = (LPWSTR) ( (ULONG_PTR) ((PCHAR) *EndOfVariableData -
                            fileSDLength ) & ~3 );

            shi502->shi502_security_descriptor = *EndOfVariableData;
            shi502->shi502_reserved  = fileSDLength;

            RtlCopyMemory(
                    shi502->shi502_security_descriptor,
                    share->FileSecurityDescriptor,
                    fileSDLength
                    );

        } else {
            shi502->shi502_security_descriptor = NULL;
            shi502->shi502_reserved = 0;
        }

        RELEASE_LOCK( share->SecurityDescriptorLock );

    case 2:

        //
        // Set level 2 specific fields in the buffer.  Since this server
        // can only have user-level security, share permissions are
        // meaningless.
        //

        shi502->shi502_permissions = 0;
        shi502->shi502_max_uses = share->MaxUses;
        shi502->shi502_current_uses = share->CurrentUses;

        //
        // Copy the DOS path name to the buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &share->DosPathName,
            *FixedStructure,
            EndOfVariableData,
            &shi502->shi502_path
            );

        //
        // We don't have per-share passwords (share-level security)
        // so set the password pointer to NULL.
        //

        shi502->shi502_passwd = NULL;

        // *** Lack of break is intentional!

    case 501:

        if( Srp->Level == 501 ) {
            shi501->shi501_flags = share->CSCState;
        }

        // *** Lack of break is intentional!

    case 1:

        //
        // Convert the server's internal representation of share types
        // to the expected format.
        //

        switch ( share->ShareType ) {

        case ShareTypeDisk:

            shi502->shi502_type = STYPE_DISKTREE;
            break;

        case ShareTypePrint:

            shi502->shi502_type = STYPE_PRINTQ;
            break;

        case ShareTypePipe:

            shi502->shi502_type = STYPE_IPC;
            break;

        default:

            //
            // This should never happen.  It means that somebody
            // stomped on the share block.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "FillShareInfoBuffer: invalid share type in share: %ld",
                share->ShareType,
                NULL
                );

            shi502->shi502_type = 0;

        }

        if ( share->SpecialShare ) {
            shi502->shi502_type |= STYPE_SPECIAL;
        }
#ifdef INCLUDE_SMB_PERSISTENT
        if ( share->AllowPersistentHandles ) {
            shi502->shi502_type |= STYPE_PERSISTENT;
        }
#endif

        //
        // Copy the remark to the buffer.  The routine will handle the
        // case where there is no remark on the share and put a pointer
        // to a zero terminator in the buffer.
        //
        // *** We hold the share lock to keep SrvNetShareSetInfo from
        //     changing the remark during the copy.  (Changing the
        //     remark can result in different storage being allocated.)
        //

        SrvCopyUnicodeStringToBuffer(
            &share->Remark,
            *FixedStructure,
            EndOfVariableData,
            &shi502->shi502_remark
            );

        // *** Lack of break is intentional!

    case 0:

        //
        // Copy the share name to the buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &share->ShareName,
            *FixedStructure,
            EndOfVariableData,
            &shi502->shi502_netname
            );

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillShareInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

    }

    return;

} // FillShareInfoBuffer


BOOLEAN
FilterShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular share should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  Name1 ("netname"
        on NetShareGetInfo) is used to do the filtering.

    Block - a pointer to the share to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PSHARE share = Block;

    PAGED_CODE( );

    //
    // If this is an Enum, then we definitely want the share.  An Enum
    // leaves the net name blank; a get info sets the name to the share
    // name on which to return info.
    //

    if ( Srp->Name1.Length == 0 ) {
        return TRUE;
    }

    //
    // This is a get info; use the share only if the share name matches
    // the Name1 field of the SRP.
    //

    return RtlEqualUnicodeString(
               &Srp->Name1,
               &share->ShareName,
               TRUE
               );

} // FilterShares


ULONG
SizeShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in share would take up in
    an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the Level
        parameter is used.

    Block - a pointer to the share to size.

Return Value:

    ULONG - The number of bytes the share would take up in the
        output buffer.

--*/

{
    PSHARE share = Block;
    ULONG shareSize = 0;

    PAGED_CODE( );

    switch ( Srp->Level ) {
    case 502:
        ACQUIRE_LOCK_SHARED( share->SecurityDescriptorLock );

        if ( share->FileSecurityDescriptor != NULL ) {

            //
            // add 4 bytes for possible padding
            //

            shareSize = sizeof( ULONG ) +
                RtlLengthSecurityDescriptor( share->FileSecurityDescriptor );
        }

        RELEASE_LOCK( share->SecurityDescriptorLock );

    case 2:
        shareSize += SrvLengthOfStringInApiBuffer(&share->DosPathName);

    case 501:
    case 1:
        shareSize += SrvLengthOfStringInApiBuffer(&share->Remark);

    case 0:
        shareSize += SrvLengthOfStringInApiBuffer(&share->ShareName);

    }

    return ( shareSize + FIXED_SIZE_OF_SHARE( Srp->Level ) );

} // SizeShares
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcsess.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcsess.c

Abstract:

    This module contains routines for supporting the session APIs in the
    server service, SrvNetSessionDel, SrvNetSessionEnum and
    SrvNetSessionGetInfo.

Author:

    David Treadwell (davidtr) 31-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcsess.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCSESS

//
// defined in scavengr.c
//

VOID
UpdateSessionLastUseTime(
    IN PLARGE_INTEGER CurrentTime
    );

//
// Forward declarations.
//

VOID
FillSessionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetSessionDel )
#pragma alloc_text( PAGE, SrvNetSessionEnum )
#pragma alloc_text( PAGE, FillSessionInfoBuffer )
#pragma alloc_text( PAGE, FilterSessions )
#pragma alloc_text( PAGE, SizeSessions )
#endif

//
// Macros to determine the size a session would take up at one of the
// levels of session information.
//

#define FIXED_SIZE_OF_SESSION(level)                  \
    ( (level) == 0  ? sizeof(SESSION_INFO_0)  :       \
      (level) == 1  ? sizeof(SESSION_INFO_1)  :       \
      (level) == 2  ? sizeof(SESSION_INFO_2)  :       \
      (level) == 10 ? sizeof(SESSION_INFO_10) :       \
                      sizeof(SESSION_INFO_502) )

NTSTATUS
SrvNetSessionDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine processes the NetSessionEnum API in the server FSP.
    It must run in the FSP because in order to close the session it must
    use the endpoint handle to force the TDI connection closed.

    Either the client name or user name must be specified, and it is
    legal to specify both.  If only the computer name is specified, then
    the VC gets closed.  If only the user name is specified, then all
    that users sessions are closed.  If both are specified, then the
    particular user session is closed.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - name of the client computer whose session we should
            delete.

        Name2 - name of the user whose session we should delete.

      OUTPUT:

        None.

    Buffer - unused.

    BufferLength - unused.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    BOOLEAN foundSession = FALSE;
    PSESSION session;

    PAGED_CODE( );

    Buffer, BufferLength;

    //
    // Walk the ordered list, finding matching entries.
    //

    session = SrvFindEntryInOrderedList(
                &SrvSessionList,
                (PFILTER_ROUTINE)FilterSessions,
                Srp,
                (ULONG)-1,
                FALSE,
                NULL );

    while ( session != NULL ) {

        foundSession = TRUE;

        //
        // If a computer name was specified but not a user name, then
        // we're supposed to blow away the VC.  Close the connection.
        //

        if ( Srp->Name1.Buffer != NULL && Srp->Name2.Buffer == NULL ) {

#if SRVDBG29
            UpdateConnectionHistory( "SDL1", session->Connection->Endpoint, session->Connection );
#endif
            session->Connection->DisconnectReason = DisconnectSessionDeleted;
            SrvCloseConnection( session->Connection, FALSE );

        } else {

            //
            // We want to close a user on the connection.  Close that
            // session, then if there are no longer any sessions on the
            // connection, close the connection.
            //
            // Increment the count of sessions that have been logged off
            // normally.
            //

            SrvStatistics.SessionsLoggedOff++;
            SrvCloseSession( session );
            if ( session->Connection->PagedConnection->CurrentNumberOfSessions == 0 ) {
#if SRVDBG29
                UpdateConnectionHistory( "SDL2", session->Connection->Endpoint, session->Connection );
#endif
                session->Connection->DisconnectReason = DisconnectSessionDeleted;
                SrvCloseConnection( session->Connection, FALSE );
            }

        }

        //
        // Find the next session that matches.  This will dereference the
        // current session.
        //

        do {

            session =
                SrvFindNextEntryInOrderedList( &SrvSessionList, session );

        } while ( (session != NULL) && !FilterSessions( Srp, session ) );

    }

    if ( foundSession ) {
        return STATUS_SUCCESS;
    }

    Srp->ErrorCode = NERR_ClientNameNotFound;
    return STATUS_SUCCESS;

} // SrvNetSessionDel


NTSTATUS
SrvNetSessionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetSessionEnum API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Level - level of information to return, 0, 1, or 2.

        Name1 - a client machine name to filter on, if any.

        Name2 - a user name to filter on, if any.


      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    LARGE_INTEGER currentTime;

    PAGED_CODE( );

    //
    // See if we need to update the session last use time
    //

    KeQuerySystemTime( &currentTime );
    UpdateSessionLastUseTime( &currentTime );

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvSessionList,
               FilterSessions,
               SizeSessions,
               FillSessionInfoBuffer
               );

} // SrvNetSessionEnum


VOID
FillSessionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed file structure and associated
    variable data, into a buffer.  Fixed data goes at the beginning of
    the buffer, variable data at the end.

    *** This routine assumes that ALL the data, both fixed and variable,
        will fit.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the Level
        field is used.

    Block - the Session from which to get information.

    FixedStructure - where the in the buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PSESSION_INFO_502 sesi502 = *FixedStructure;
    PSESSION_INFO_2 sesi2 = *FixedStructure;
    PSESSION_INFO_10 sesi10 = *FixedStructure;
    PSESSION session = Block;
    UNICODE_STRING machineNameString;
    UNICODE_STRING userName;
    PPAGED_CONNECTION pagedConnection;

    LARGE_INTEGER currentTime;
    ULONG currentSecondsSince1980;
    ULONG startTimeInSecondsSince1980;
    ULONG secondsAlive;
    ULONG lastUseTimeInSecondsSince1980;
    ULONG secondsIdle;

    PAGED_CODE();

    //
    // Get the current time and use this to determine how long the
    // connection has been alive and how long it has been idle.
    //

    KeQuerySystemTime( &currentTime );

    RtlTimeToSecondsSince1980(
        &currentTime,
        &currentSecondsSince1980
        );

    RtlTimeToSecondsSince1980(
        &session->StartTime,
        &startTimeInSecondsSince1980
        );

    RtlTimeToSecondsSince1980(
        &session->LastUseTime,
        &lastUseTimeInSecondsSince1980
        );

    secondsAlive = currentSecondsSince1980 - startTimeInSecondsSince1980;
    secondsIdle = currentSecondsSince1980 - lastUseTimeInSecondsSince1980;

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure +
                          FIXED_SIZE_OF_SESSION( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // We'll return a machine name that does not contain the leading
    // backslashes.
    //
    pagedConnection = session->Connection->PagedConnection;

    machineNameString.Buffer = pagedConnection->ClientMachineName;
    machineNameString.Length =
        (USHORT)( pagedConnection->ClientMachineNameString.Length -
                    (sizeof(WCHAR) * 2) );

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different session structures are
    //     identical (with the exception of level 10, which is handled
    //     separately).
    //

    switch( Srp->Level ) {

    case 502:

        //
        // Copy the transport string to the output buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &session->Connection->Endpoint->TransportName,
            *FixedStructure,
            EndOfVariableData,
            &sesi502->sesi502_transport
            );

        // *** lack of break is intentional!

    case 2:

        //
        // Copy the client type string to the output buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            session->Connection->ClientOSType.Buffer != NULL ?
                &session->Connection->ClientOSType :
                &SrvClientTypes[session->Connection->SmbDialect],
            *FixedStructure,
            EndOfVariableData,
            &sesi2->sesi2_cltype_name
            );

        // *** lack of break is intentional!

    case 1:

        //
        // Copy the user name to the output buffer.
        //

        SrvGetUserAndDomainName( session, &userName, NULL );

        SrvCopyUnicodeStringToBuffer(
            &userName,
            *FixedStructure,
            EndOfVariableData,
            &sesi2->sesi2_username
            );

        if( userName.Buffer ) {
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }

        //
        // Set up other fields.
        //

        //
        // Return the number of files open over this session, taking care
        //  not to count those in the RFCB cache (since the RFCB cache should
        //  be transparent to users and administrators.
        //

        sesi2->sesi2_num_opens = session->CurrentFileOpenCount;

        if( sesi2->sesi2_num_opens > 0 ) {

            ULONG count = SrvCountCachedRfcbsForUid( session->Connection, session->Uid );

            if( sesi2->sesi2_num_opens > count ) {
                sesi2->sesi2_num_opens -= count;
            } else {
                sesi2->sesi2_num_opens = 0;
            }
        }

        sesi2->sesi2_time = secondsAlive;
        sesi2->sesi2_idle_time = secondsIdle;

        //
        // Set up the user flags.
        //

        sesi2->sesi2_user_flags = 0;

        if ( session->GuestLogon ) {
            sesi2->sesi2_user_flags |= SESS_GUEST;
        }

        if ( !session->EncryptedLogon ) {
            sesi2->sesi2_user_flags |= SESS_NOENCRYPTION;
        }

        // *** lack of break is intentional!

    case 0:

        //
        // Set up the client machine name in the output buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &machineNameString,
            *FixedStructure,
            EndOfVariableData,
            &sesi2->sesi2_cname
            );

        break;

    case 10:

        //
        // Set up the client machine name and user name in the output
        // buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &machineNameString,
            *FixedStructure,
            EndOfVariableData,
            &sesi10->sesi10_cname
            );

        SrvGetUserAndDomainName( session, &userName, NULL );

        SrvCopyUnicodeStringToBuffer(
            &userName,
            *FixedStructure,
            EndOfVariableData,
            &sesi10->sesi10_username
            );

        if( userName.Buffer ) {
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }

        //
        // Set up other fields.
        //

        sesi10->sesi10_time = secondsAlive;
        sesi10->sesi10_idle_time = secondsIdle;

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillSessionInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

        SrvLogInvalidSmb( NULL );
    }

    return;

} // FillSessionInfoBuffer


BOOLEAN
FilterSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular session should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  Name1 is the client
        name, Name2 is the user name.

    Block - a pointer to the session to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PSESSION session = Block;
    UNICODE_STRING userName;

    PAGED_CODE( );

    //
    // If there was a client name passed in the NetSessionEnum API,
    // check whether it matches the client name on the connection
    // corresponding to the session.
    //

    if ( Srp->Name1.Length > 0 ) {

        if ( !RtlEqualUnicodeString(
                  &Srp->Name1,
                  &session->Connection->PagedConnection->ClientMachineNameString,
                  TRUE ) ) {

            return FALSE;
        }
    }

    //
    // If there was a user name passed in the NetSessionEnum API,
    // check whether it matches the user name on the session.
    //

    if ( Srp->Name2.Length > 0 ) {

        SrvGetUserAndDomainName( session, &userName, NULL );
        if( userName.Buffer == NULL ) {
            return FALSE;
        }

        if ( !RtlEqualUnicodeString(
                  &Srp->Name2,
                  &userName,
                  TRUE ) ) {

            SrvReleaseUserAndDomainName( session, &userName, NULL );
            return FALSE;
        }

        SrvReleaseUserAndDomainName( session, &userName, NULL );
    }

    //
    // The session passed both tests.  Put it in the output buffer.
    //

    return TRUE;

} // FilterSessions


ULONG
SizeSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in session would take up
    in an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the level
        parameter is used.

    Block - a pointer to the session to size.

Return Value:

    ULONG - The number of bytes the session would take up in the output
        buffer.

--*/

{
    PSESSION session = Block;
    PCONNECTION connection = session->Connection;
    ULONG size;
    UNICODE_STRING userName;

    PAGED_CODE( );

    size = SrvLengthOfStringInApiBuffer(
                    &connection->PagedConnection->ClientMachineNameString
                    );

    if ( Srp->Level > 0 ) {
        SrvGetUserAndDomainName( session, &userName, NULL );
        if( userName.Buffer != NULL ) {
            size += SrvLengthOfStringInApiBuffer(&userName);
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }
    }

    switch ( Srp->Level ) {
    case 0:
        size += sizeof(SESSION_INFO_0);
        break;

    case 1:
        size += sizeof(SESSION_INFO_1);
        break;

    case 2:
        size += sizeof( SESSION_INFO_2 );

        if( connection->ClientOSType.Buffer != NULL ) {
            size += SrvLengthOfStringInApiBuffer( &connection->ClientOSType );
        } else {
            size += SrvLengthOfStringInApiBuffer( &SrvClientTypes[ connection->SmbDialect ] );
        }

        break;

    case 10:
        size += sizeof(SESSION_INFO_10);
        break;

    case 502:
        size += sizeof(SESSION_INFO_502) +
                SrvLengthOfStringInApiBuffer(
                    &connection->Endpoint->TransportName
                    );

        if( connection->ClientOSType.Buffer != NULL ) {
            size += SrvLengthOfStringInApiBuffer( &connection->ClientOSType );
        } else {
            size += SrvLengthOfStringInApiBuffer( &SrvClientTypes[ connection->SmbDialect ] );
        }

        break;

    }

    return size;

} // SizeSessions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcsupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcshare.c

Abstract:

    This module contains support routines for the server service.

Author:

    David Treadwell (davidtr) 13-Feb-1991

Revision History:

--*/

#include "precomp.h"
#include "svcsupp.tmh"
#pragma hdrstop


BOOLEAN
FilterTransportName (
    IN PVOID Context,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCopyUnicodeStringToBuffer )
#pragma alloc_text( PAGE, SrvDeleteOrderedList )
#pragma alloc_text( PAGE, SrvEnumApiHandler )
#pragma alloc_text( PAGE, SrvFindEntryInOrderedList )
#pragma alloc_text( PAGE, SrvFindNextEntryInOrderedList )
#pragma alloc_text( PAGE, SrvFindUserOnConnection )
#pragma alloc_text( PAGE, SrvGetResumeHandle )
#pragma alloc_text( PAGE, SrvInitializeOrderedList )
#pragma alloc_text( PAGE, SrvInsertEntryOrderedList )
#pragma alloc_text( PAGE, SrvRemoveEntryOrderedList )
#pragma alloc_text( PAGE, SrvSendDatagram )
#pragma alloc_text( PAGE, FilterTransportName )
#ifdef SLMDBG
#pragma alloc_text( PAGE, SrvSendSecondClassMailslot )
#endif
#pragma alloc_text( PAGE, SrvLengthOfStringInApiBuffer )
#pragma alloc_text( PAGE, SrvInhibitIdlePowerDown )
#pragma alloc_text( PAGE, SrvAllowIdlePowerDown )
#endif


VOID
SrvCopyUnicodeStringToBuffer (
    IN PUNICODE_STRING String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length Unicode string into a
    buffer.  The string data is converted to ANSI as it is copied.  The
    string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    String - a pointer to the string to copy into the buffer.  If String
        is null (Length == 0 || Buffer == NULL) then a pointer to a
        zero terminator is inserted.

    FixedStructure - a pointer to the end of the last fixed
        structure in the buffer.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.

    VariableDataPointer - a pointer to the place in the buffer where
        a pointer to the variable data should be written.

Return Value:

    None.

--*/

{
    ULONG length;
    ULONG i;
    PWCH src;
    LPWSTR dest;

    PAGED_CODE( );

    //
    // Determine where in the buffer the string will go, allowing for a
    // zero-terminator.
    //

    if ( String->Buffer != NULL ) {
        length = String->Length >> 1;
        *EndOfVariableData -= (length + 1);
    } else {
        length = 0;
        *EndOfVariableData -= 1;
    }

    //
    // Will the string fit?  If no, just set the pointer to NULL.
    //

    if ( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)FixedStructure ) {

        //
        // It fits.  Set up the pointer to the place in the buffer where
        // the string will go.
        //

        *VariableDataPointer = *EndOfVariableData;

        //
        // Copy the string to the buffer if it is not null.
        //

        dest = *EndOfVariableData;

        for ( i = 0, src = String->Buffer; i < length; i++ ) {
            *dest++ = (TCHAR)*src++;
        }

        //
        // Set the zero terminator.
        //

        *dest = (TCHAR)(L'\0');

    } else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

    }

    return;

} // SrvCopyUnicodeStringToBuffer


VOID
SrvDeleteOrderedList (
    IN PORDERED_LIST_HEAD ListHead
    )

/*++

Routine Description:

    "Deinitializes" or deletes an ordered list head.

Arguments:

    ListHead - a pointer to the list head to delete.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( ListHead->Initialized ) {

        ASSERT( IsListEmpty( &ListHead->ListHead ) );

        //
        // Indicate that the ordered list has been "deleted".
        //

        ListHead->Initialized = FALSE;

    }

    return;

} // SrvDeleteOrderedList


NTSTATUS
SrvEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PORDERED_LIST_HEAD ListHead,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    )

/*++

Routine Description:

    All Enum and GetInfo APIs are handled by this routine in the server
    FSD.  It takes the ResumeHandle in the SRP to find the first
    appropriate block, then calls the passed-in filter routine to check
    if the block should be filled in.  If it should, we call the filter
    routine, then try to get another block.  This continues until tyhe
    entire list has been walked.

Arguments:

    Srp - a pointer to the SRP for the operation.

    OutputBuffer - the buffer in which to fill output information.

    BufferLength - the length of the buffer.

    ListHead - the head of the ordered list to walk.

    FilterRoutine - a pointer to a function that will check a block
        against information in the SRP to determine whether the
        information in the block should be placed in the output
        buffer.

    SizeRoutine - a pointer to a function that will find the total size
        a single block will take up in the output buffer.  This routine
        is used to check whether we should bother to call the fill
        routine.

    FillRoutine - a pointer to a function that will fill in the output
        buffer with information from a block.

Return Value:

    NTSTATUS - results of operation.

--*/

{
    PVOID block;
    PVOID lastBlockRead;
    ULONG totalEntries;
    ULONG entriesRead;
    ULONG bytesRequired;
    ULONG newResumeHandle;

    PCHAR fixedStructurePointer;
    PCHAR variableData;
    ULONG level;
    ULONG maxResumeHandle;

    BOOLEAN bufferOverflow = FALSE;

    PAGED_CODE( );

    //
    // Set up local variables.
    //

    fixedStructurePointer = OutputBuffer;
    variableData = fixedStructurePointer + BufferLength;
    variableData = (PCHAR)((ULONG_PTR)variableData & ~1);
    level = Srp->Level;

    lastBlockRead = NULL;
    entriesRead = 0;
    totalEntries = 0;
    bytesRequired = 0;
    newResumeHandle = 0;

    //
    // Grab the current resume handle in the list we're
    // enumerating.  This allows us to return only blocks that existed
    // when the enumeration started, thereby avoiding problems with
    // blocks created after the enumeration distorting the data.
    //

    maxResumeHandle = ListHead->CurrentResumeHandle;

    //
    // Get blocks from the global list by using the ordered list
    // routines.  We pass resume handle +1 to get the next block after
    // the last one returned.  If the passed-in resume handle is 0, this
    // will return the first valid block in the list.
    //

    block = SrvFindEntryInOrderedList(
                ListHead,
                NULL,
                NULL,
                Srp->Parameters.Get.ResumeHandle + 1,
                FALSE,
                NULL
                );

    while ( block != NULL &&
                SrvGetResumeHandle( ListHead, block ) < maxResumeHandle ) {

        ULONG blockSize;

        //
        // Call the filter routine to determine whether we should
        // return this block.
        //

        if ( FilterRoutine( Srp, block ) ) {

            blockSize = SizeRoutine( Srp, block );

            totalEntries++;
            bytesRequired += blockSize;

            //
            // If all the information in the block will fit in the
            // output buffer, write it.  Otherwise, indicate that there
            // was an overflow.  As soon as an entry doesn't fit, stop
            // putting them in the buffer.  This ensures that the resume
            // mechanism will work--retuning partial entries would make
            // it nearly impossible to use the resumability of the APIs,
            // since the caller would have to resume from an imcomplete
            // entry.
            //

            if ( (ULONG_PTR)fixedStructurePointer + blockSize <=
                     (ULONG_PTR)variableData && !bufferOverflow ) {

                FillRoutine(
                    Srp,
                    block,
                    (PVOID *)&fixedStructurePointer,
                    (LPWSTR *)&variableData
                    );

                entriesRead++;
                lastBlockRead = block;
                newResumeHandle = SrvGetResumeHandle( ListHead, lastBlockRead );
            } else {

                bufferOverflow = TRUE;
            }
        }

        //
        // Get the next block in the list.  This routine will dereference
        // the block we have been looking at and get a new block if a valid
        // one exists.
        //

        block = SrvFindNextEntryInOrderedList( ListHead, block );
    }

    //
    // Dereference this last one.
    //

    if ( block != NULL ) {

        ListHead->DereferenceRoutine( block );

    }

    //
    // Set the information to pass back to the server service.
    //

    Srp->Parameters.Get.EntriesRead = entriesRead;
    Srp->Parameters.Get.TotalEntries = totalEntries;
    Srp->Parameters.Get.TotalBytesNeeded = bytesRequired;

    //
    // If we found at least one block, return the resume handle for it.
    // If we didn't find any blocks, don't modify the resume handle.
    //

    if ( lastBlockRead != NULL ) {
        Srp->Parameters.Get.ResumeHandle = newResumeHandle;
    }

    //
    // Return appropriate status.
    //

    if ( entriesRead == 0 && totalEntries > 0 ) {

        //
        // Not even a single entry fit.
        //

        Srp->ErrorCode = NERR_BufTooSmall;
        return STATUS_SUCCESS;

    } else if ( bufferOverflow ) {

        //
        // At least one entry fit, but not all of them.
        //

        Srp->ErrorCode = ERROR_MORE_DATA;
        return STATUS_SUCCESS;

    } else {

        //
        // All entries fit.
        //

        Srp->ErrorCode = NO_ERROR;
        return STATUS_SUCCESS;
    }

} // SrvEnumApiHandler


PVOID
SrvFindEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PFILTER_ROUTINE FilterRoutine OPTIONAL,
    IN PVOID Context OPTIONAL,
    IN ULONG ResumeHandle,
    IN BOOLEAN ExactHandleMatch,
    IN PLIST_ENTRY StartLocation OPTIONAL
    )

/*++

Routine Description:

    This routine uses a filter routine or resume handle to find an entry
    in an ordered list.  It walks the list, looking for a block with a
    resume handle less than or equal to the specified resume handle, or
    a block that passes the filter routine's tests.  If a matching
    handle or passing block is found, the block is referenced and a
    pointer to it is returned.  If ExactHandleMatch is FALSE and there
    is no exact match of the handle, then the first block with a resume
    handle greater than the one specified is referenced and returned.

Arguments:

    ListHead - a pointer to the list head to search.

    FilterRoutine - a routine that will check whether a block is valid
        for the purposes of the calling routine.

    Context - a pointer to pass to the filter routine.

    ResumeHandle - the resume handle to look for.  If a filter routine
        is specified, this parameter should be -1.

    ExactHandleMatch - if TRUE, only an exact match is returned.  If there
        is no exact match, return NULL.  If a filter routine is specified
        this should be FALSE.

    StartLocation - if specified, start looking at this location in
        the list.  This is used by SrvFindNextEntryInOrderedList to
        speed up finding a valid block.

Return Value:

    PVOID - NULL if no block matched or if the handle is beyond the end of
       the list.  A pointer to a block if a valid block is found.  The
       block is referenced.

--*/

{
    PLIST_ENTRY listEntry;
    PVOID block;

    PAGED_CODE( );

    //
    // Acquire the lock that protects the ordered list.
    //

    ACQUIRE_LOCK( ListHead->Lock );

    //
    // Find the starting location for the search.  If a start was
    // specified, start there; otherwise, start at the beginning of the
    // list.
    //

    if ( ARGUMENT_PRESENT( StartLocation ) ) {
        listEntry = StartLocation;
    } else {
        listEntry = ListHead->ListHead.Flink;
    }

    //
    // Walk the list of blocks until we find one with a resume handle
    // greater than or equal to the specified resume handle.
    //

    for ( ; listEntry != &ListHead->ListHead; listEntry = listEntry->Flink ) {

        ULONG currentResumeHandle;

        currentResumeHandle = ((PORDERED_LIST_ENTRY)listEntry)->ResumeHandle;

        //
        // Get a pointer to the actual block.
        //

        block = (PCHAR)listEntry - ListHead->ListEntryOffset;

        //
        // Determine whether we've reached the specified handle, or
        // whether the block passes the filter routine's tests.
        //

        if ( currentResumeHandle >= ResumeHandle ||
             ( ARGUMENT_PRESENT( FilterRoutine ) &&
               FilterRoutine( Context, block ) ) ) {

            if ( ExactHandleMatch && currentResumeHandle != ResumeHandle ) {

                //
                // We have passed the specified resume handle without
                // finding an exact match.  Return NULL, indicating that
                // no exact match exists.
                //

                RELEASE_LOCK( ListHead->Lock );

                return NULL;
            }

            //
            // Check the state of the block and if it is active,
            // reference it.  This must be done as an atomic operation
            // order to prevent the block from being deleted.
            //

            if ( ListHead->ReferenceRoutine( block ) ) {

                //
                // Release the list lock and return a pointer to the
                // block to the caller.
                //

                RELEASE_LOCK( ListHead->Lock );

                return block;

            }

        }

    } // walk list

    //
    // If we are here, it means that we walked the entire list without
    // finding a valid match.  Release the list lock and return NULL.
    //

    RELEASE_LOCK( ListHead->Lock );

    return NULL;

} // SrvFindEntryInOrderedList


PVOID
SrvFindNextEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine finds the next valid block after the one passed in.
    It calls SrvFindEntryInOrderedList to do most of the work.  It
    also handles dereferencing the passed-in block and referencing the
    returned block.  The passed-in block is dereferenced regardless
    of whether a block is returned, so calling routines must be careful
    to obtain all the information they need from the block before
    calling this routine.

Arguments:

    ListHead - a pointer to the list head to search.

    Block - a pointer to the block after which we should look for
        the next block.

Return Value:

    PVOID - NULL if no block matched or if the handle is beyond the end of
       the list.  A pointer to a block if a valid block is found.

--*/

{
    PVOID returnBlock;
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    //
    // Find the ordered list entry in the block.  We need this to pass
    // the start location and resume handle to
    // SrvFindEntryInOrderedList.
    //

    listEntry =
        (PORDERED_LIST_ENTRY)( (PCHAR)Block + ListHead->ListEntryOffset );

    //
    // Call SrvFindEntryInOrderedList with a start location.  This will
    // find the block to return, if any.
    //
    // This adds one to the resume handle because we want the *next*
    // block, not this one, to be returned.
    //

    returnBlock = SrvFindEntryInOrderedList(
                      ListHead,
                      NULL,
                      NULL,
                      listEntry->ResumeHandle + 1,
                      FALSE,
                      &listEntry->ListEntry
                      );

    //
    // Dereference the passed-in block.
    //

    ListHead->DereferenceRoutine( Block );

    //
    // Return what we got from SrvFindEntryInOrderedList.
    //

    return returnBlock;

} // SrvFindNextEntryInOrderedList


PSESSION
SrvFindUserOnConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    Finds a "legitimate" user on a virtual circuit.  This routine is
    an attempt to find a good username to return even though there
    may be multiple users on a VC.  Some of the APIs assume that there
    will be one user per VC, and this is an attempt to support that
    bahavior.

    The following rules are used:

    0 users--return NULL.

    1 user--return a pointer to that session block.

    2 users--if one matches the computer name, return the other.  This
        is because RIPL sessions have a session name matching the
        client name, and this is probably not a useful user.  If both
        usernames differ from the computer name, return NULL.

    3 or more users--return NULL.

    *** THIS ROUTINE MUST BE CALLED WITH THE CONNECTION LOCK HELD.  It
        remains held on exit.

Arguments:

    Connection - a pointer to the connection block to search for a user.

Return Value:

    NULL or a pointer to a session.

--*/

{
    PSESSION matchingSession = NULL;
    PSESSION nonMatchingSession = NULL;
    USHORT i;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

    PAGED_CODE( );

    //
    // Walk the connection's session table looking for valid sessions.
    //

    for ( i = 0; i < pagedConnection->SessionTable.TableSize; i++ ) {

        PSESSION session;

        session = pagedConnection->SessionTable.Table[i].Owner;

        //
        // Determine whether this is a valid session.
        //

        if ( session != NULL && GET_BLOCK_STATE(session) == BlockStateActive ) {

            //
            // It is a valid session.  Determine whether the name matches
            // the connection's client name.
            //

            UNICODE_STRING computerName, userName;

            computerName.Buffer = pagedConnection->ClientMachineName;
            computerName.Length =
                (USHORT)( Connection->PagedConnection->ClientMachineNameString.Length -
                            sizeof(WCHAR) * 2 );

            SrvGetUserAndDomainName( session, &userName, NULL );

            if( userName.Buffer && userName.Length != 0 ) {

                if ( RtlCompareUnicodeString(
                         &computerName,
                         &userName,
                         TRUE ) == 0 ) {

                    //
                    // The user name and machine name are the same.
                    //

                    matchingSession = session;

                } else {

                    //
                    // If we already found another user name that doesn't match
                    // the client computer name, we're hosed.  Return NULL.
                    //

                    if ( nonMatchingSession != NULL ) {
                        SrvReleaseUserAndDomainName( session, &userName, NULL );
                        return NULL;
                    }

                    nonMatchingSession = session;

                }  // does session user name match computer name?

                SrvReleaseUserAndDomainName( session, &userName, NULL );
            }

        } // valid session?

    } // walk session table

    //
    // If only one non-matching name was found, we got here, so return
    // that session.
    //

    if ( nonMatchingSession != NULL ) {
        return nonMatchingSession;
    }

    //
    // If a matching session was found return it, or return NULL if
    // no sessions matched.
    //

    return matchingSession;

} // SrvFindUserOnConnection


ULONG
SrvGetResumeHandle (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )
{
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    // !!! make this a macro?

    listEntry =
        (PORDERED_LIST_ENTRY)( (PCHAR)Block + ListHead->ListEntryOffset );

    return listEntry->ResumeHandle;

} // SrvGetResumeHandle


VOID
SrvInitializeOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN ULONG ListEntryOffset,
    IN PREFERENCE_ROUTINE ReferenceRoutine,
    IN PDEREFERENCE_ROUTINE DereferenceRoutine,
    IN PSRV_LOCK Lock
    )

/*++

Routine Description:

    This routine initializes an ordered list.  It initializes the list
    head and lock and sets up other header fields from the information
    passed in.

Arguments:

    ListHead - a pointer to the list head to initialize.

    ListEntryOffset - the offset into a data block in the list to the
        ORDERED_LIST_ENTRY field.  This is used to find the start of
        the block from the list entry field.

    ReferenceRoutine - a pointer to the routine to call to reference
        a data block stored in the list.  This is done to prevent the
        data block from going away between when we find it and when
        higher-level routines start using it.

    DereferenceRoutine - a pointer to the routine to call to dereference
       a data block stored in the list.

    Lock - a pointer to a lock to use for synchronization.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ASSERT( !ListHead->Initialized );

    //
    // Initialize the head of the doubly linked list.
    //

    InitializeListHead( &ListHead->ListHead );

    //
    // Save the address of the list lock.
    //

    ASSERT( ARGUMENT_PRESENT(Lock) );
    ListHead->Lock = Lock;

    //
    // Initialize other fields in the header.
    //

    ListHead->CurrentResumeHandle = 1;
    ListHead->ListEntryOffset = ListEntryOffset;
    ListHead->ReferenceRoutine = ReferenceRoutine,
    ListHead->DereferenceRoutine = DereferenceRoutine;

    ListHead->Initialized = TRUE;

    return;

} // SrvInitializeOrderedList


VOID
SrvInsertEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine inserts an entry in an ordered list.  The entry is
    placed on the doubly linked list and the resume handle is set.

    *** It is the responsibility of that calling routine to ensure that
        the block does not go away while this routine executes.

Arguments:

    ListHead - a pointer to the list head on which to put the block.

    Block - a pointer to the data block to place on the list.

Return Value:

    None.

--*/

{
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    //
    // Determine where the list entry field is.
    //

    listEntry = (PORDERED_LIST_ENTRY)
                    ( (PCHAR)Block + ListHead->ListEntryOffset );

    //
    // Acquire the lock that protects the ordered list.
    //

    ACQUIRE_LOCK( ListHead->Lock );

    //
    // Insert the entry in the doubly linked list.
    //

    SrvInsertTailList( &ListHead->ListHead, &listEntry->ListEntry );

    //
    // Set up the resume handle in the block and update the current
    // handle in the header.
    //

    listEntry->ResumeHandle = ListHead->CurrentResumeHandle;
    ListHead->CurrentResumeHandle++;

    //
    // Release the lock and return.
    //

    RELEASE_LOCK( ListHead->Lock );

    return;

} // SrvInsertEntryOrderedList


VOID
SrvRemoveEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine removes an entry from an ordered list.

    *** It is the responsibility of that calling routine to ensure that
        the block does not go away while this routine executes.

Arguments:

    ListHead - a pointer to the list head on which to put the block.

    Block - a pointer to the data block to place on the list.

Return Value:

    None.

--*/

{
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    //
    // Determine where the list entry field is.
    //

    listEntry = (PORDERED_LIST_ENTRY)
                    ( (PCHAR)Block + ListHead->ListEntryOffset );

    //
    // Acquire the lock that protects the ordered list.
    //

    ACQUIRE_LOCK( ListHead->Lock );

    //
    // Remove the entry from the doubly linked list.
    //

    SrvRemoveEntryList( &ListHead->ListHead, &listEntry->ListEntry );

    //
    // Release the lock and return.
    //

    RELEASE_LOCK( ListHead->Lock );

    return;

} // SrvRemoveEntryOrderedList


NTSTATUS
SrvSendDatagram (
    IN PANSI_STRING Domain,
    IN PUNICODE_STRING Transport OPTIONAL,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine sends a datagram to the specified domain.

    !!! Temporary--should go away when we have real 2nd-class mailslot
        support.

Arguments:

    Domain - the name of the domain to send to.  Note that the domain
        name must be padded with spaces and terminated with the
        appropriate signature byte (00 or 07) by the caller.

    Transport - the name of the transport to send to.  If not present, then
        the datagram is sent on all transports.

    Buffer - the message to send.

    BufferLength - the length of the buffer,

Return Value:

    NTSTATUS - results of operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG connectionInformationSize;
    PTDI_CONNECTION_INFORMATION connectionInformation;
    PTA_NETBIOS_ADDRESS taNetbiosAddress;
    PENDPOINT endpoint;

    PAGED_CODE( );

    connectionInformationSize = sizeof(TDI_CONNECTION_INFORMATION) +
                                                sizeof(TA_NETBIOS_ADDRESS);
    connectionInformation = ALLOCATE_NONPAGED_POOL(
                                connectionInformationSize,
                                BlockTypeDataBuffer
                                );

    if ( connectionInformation == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    connectionInformation->UserDataLength = 0;
    connectionInformation->UserData = NULL;
    connectionInformation->OptionsLength = 0;
    connectionInformation->Options = NULL;
    connectionInformation->RemoteAddressLength = sizeof(TA_NETBIOS_ADDRESS);

    taNetbiosAddress = (PTA_NETBIOS_ADDRESS)(connectionInformation + 1);
    connectionInformation->RemoteAddress = taNetbiosAddress;
    taNetbiosAddress->TAAddressCount = 1;
    taNetbiosAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    taNetbiosAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    taNetbiosAddress->Address[0].Address[0].NetbiosNameType = 0;     

    RtlCopyMemory(
        taNetbiosAddress->Address[0].Address[0].NetbiosName,
        Domain->Buffer,
        MIN( Domain->Length, COMPUTER_NAME_LENGTH + 1 )
        );

    endpoint = SrvFindEntryInOrderedList(
                  &SrvEndpointList,
                  FilterTransportName,
                  Transport,
                  (ULONG)-1,
                  FALSE,
                  NULL
                  );

    while ( endpoint != NULL ) {

        if ( !endpoint->IsConnectionless ) {

            if( endpoint->IsNoNetBios ) {
                //
                // Make mailslot sends over this transport "always work"
                //
                status = STATUS_SUCCESS;

            } else {
                status = SrvIssueSendDatagramRequest(
                         endpoint->FileObject,
                         &endpoint->DeviceObject,
                         connectionInformation,
                         Buffer,
                         BufferLength
                         );
            }

        } else {
            //
            //  Dereference the endpoint if this was targetted to a specific
            //  transport, and return an error.
            //

            if (Transport != NULL) {

                DEALLOCATE_NONPAGED_POOL( connectionInformation );
                SrvDereferenceEndpoint( endpoint );

                return STATUS_REQUEST_NOT_ACCEPTED;
            }
        }


        if (Transport == NULL) {

            //
            // Find the next endpoint.  This will dereference the current
            // endpoint.
            //

            endpoint = SrvFindNextEntryInOrderedList( &SrvEndpointList, endpoint );

        } else {

            //
            // This datagram was destined to a specific endpoint.  Do not
            // look for the next endpoint.
            //

            SrvDereferenceEndpoint( endpoint );
            endpoint = NULL;
        }

    }

    DEALLOCATE_NONPAGED_POOL( connectionInformation );

    return status;

} // SrvSendDatagram


BOOLEAN
FilterTransportName (
    IN PVOID Context,
    IN PVOID Block
    )
{
    PENDPOINT endpoint = Block;

    PAGED_CODE( );

    if ( Context == NULL ) {
        return( TRUE );
    }

    return ( RtlEqualUnicodeString ( &endpoint->TransportName, (PUNICODE_STRING)Context, TRUE ) );
}

#ifdef SLMDBG
#define toupper(a) ( (a <= 'a' || a >= 'z') ? (ULONG)a : (a - ('a' - 'A')) )

VOID
SrvSendSecondClassMailslot (
    IN PVOID Message,
    IN ULONG MessageLength,
    IN PCHAR Domain,
    IN PSZ UserName
    )
{
    ULONG dataSize;
    ULONG transactionDataSize;
    ULONG smbSize;
    PSMB_HEADER header;
    PSMB_TRANSACT_MAILSLOT parameters;
    PSZ mailslotNameData = "\\MAILSLOT\\MESSNGR";
    PSZ mailslotName;
    ULONG mailslotNameLength;
    PSZ userName;
    PSZ domainInData;
    ULONG userNameLength;
    PVOID message;
    STRING domain;
    ULONG domainLength;
    CHAR domainName[COMPUTER_NAME_LENGTH+1];

    PAGED_CODE( );

    //
    // Upcase the domain and find the domain length.
    //

    for ( domainLength = 0; Domain[domainLength] != 0; domainLength++ ) {
        domainName[domainLength] = (CHAR)toupper( Domain[domainLength] );
    }

    //
    // Now fill the remaining domain anme with spaces.
    //

    for ( ; domainLength < COMPUTER_NAME_LENGTH ; domainLength++ ) {
        domainName[domainLength] = ' ';
    }

    domainName[++domainLength] = '\0';

    ASSERT( domainLength == COMPUTER_NAME_LENGTH + 1);

    domain.Buffer = domainName;
    domain.Length = domain.MaximumLength = (USHORT)domainLength;

    //
    // Determine the sizes of various fields that will go in the SMB
    // and the total size of the SMB.
    //

    mailslotNameLength = strlen( mailslotNameData );
    userNameLength = strlen( UserName );

    transactionDataSize = userNameLength + 1 + domainLength + 1 + MessageLength;
    dataSize = mailslotNameLength + 1 + transactionDataSize;
    smbSize = sizeof(SMB_HEADER) + sizeof(SMB_TRANSACT_MAILSLOT) - 1 + dataSize;

    header = ALLOCATE_HEAP_COLD( smbSize, BlockTypeDataBuffer );
    if ( header == NULL ) {
        return;
    }

    //
    // Fill in the header.  Most of the fields don't matter and are
    // zeroed.
    //

    RtlZeroMemory( header, smbSize );

    header->Protocol[0] = 0xFF;
    header->Protocol[1] = 'S';
    header->Protocol[2] = 'M';
    header->Protocol[3] = 'B';
    header->Command = SMB_COM_TRANSACTION;

    //
    // Get the pointer to the params and fill them in.
    //

    parameters = (PSMB_TRANSACT_MAILSLOT)( header + 1 );
    mailslotName = (PSZ)( parameters + 1 ) - 1;
    userName = mailslotName + mailslotNameLength + 1;
    domainInData = userName + userNameLength + 1;
    message = domainInData + domainLength + 1;

    parameters->WordCount = 0x11;
    SmbPutUshort( &parameters->TotalDataCount, (USHORT)transactionDataSize );
    SmbPutUlong( &parameters->Timeout, 0x3E8 );                // !!! fix
    SmbPutUshort( &parameters->DataCount, (USHORT)transactionDataSize );
    SmbPutUshort(
        &parameters->DataOffset,
        (USHORT)( (ULONG)userName - (ULONG)header )
        );
    parameters->SetupWordCount = 3;
    SmbPutUshort( &parameters->Opcode, MS_WRITE_OPCODE );
    SmbPutUshort( &parameters->Class, 2 );
    SmbPutUshort( &parameters->ByteCount, (USHORT)dataSize );

    RtlCopyMemory( mailslotName, mailslotNameData, mailslotNameLength + 1 );
    RtlCopyMemory( userName, UserName, userNameLength + 1 );
    RtlCopyMemory( domainInData, Domain, domainLength + 1 );
    RtlCopyMemory( message, Message, MessageLength );

    //
    // Send the actual mailslot message.
    //

    SrvSendDatagram( &domain, NULL, header, smbSize );

    FREE_HEAP( header );

    return;

} // SrvSendSecondClassMailslot
#endif


ULONG
SrvLengthOfStringInApiBuffer (
    IN PUNICODE_STRING UnicodeString
    )
{
    PAGED_CODE( );

    if ( UnicodeString == NULL ) {
        return 0;
    }

    return UnicodeString->Length + sizeof(UNICODE_NULL);

} // SrvLengthOfStringInApiBuffer

//
// Ensure that the system will not go into a power-down idle standby mode
//
VOID
SrvInhibitIdlePowerDown()
{
    PAGED_CODE();

    if( SrvPoRegistrationState != NULL &&
        InterlockedIncrement( &SrvIdleCount ) == 1 ) {

        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: Calling PoRegisterSystemState to inhibit idle standby\n" ));
        }

        PoRegisterSystemState( SrvPoRegistrationState, ES_SYSTEM_REQUIRED | ES_CONTINUOUS );

    }
}

//
// Allow the system to go into a power-down idle standby mode
//
VOID
SrvAllowIdlePowerDown()
{
    PAGED_CODE();

    if( SrvPoRegistrationState != NULL &&
        InterlockedDecrement( &SrvIdleCount ) == 0 ) {

        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: Calling PoRegisterSystemState to allow idle standby\n" ));
        }

        PoRegisterSystemState( SrvPoRegistrationState, ES_CONTINUOUS );
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\worker.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    This module implements the LAN Manager server FSP worker thread
    function.  It also implements routines for managing (i.e., starting
    and stopping) worker threads, and balancing load.

Author:

    Chuck Lenzmeier (chuckl)    01-Oct-1989
    David Treadwell (davidtr)

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#include "worker.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_WORKER

//
// Local declarations
//

NTSTATUS
CreateQueueThread (
    IN PWORK_QUEUE Queue
    );

VOID
InitializeWorkerThread (
    IN PWORK_QUEUE WorkQueue,
    IN KPRIORITY ThreadPriority
    );

VOID
WorkerThread (
    IN PWORK_QUEUE WorkQueue
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCreateWorkerThreads )
#pragma alloc_text( PAGE, CreateQueueThread )
#pragma alloc_text( PAGE, InitializeWorkerThread )
#pragma alloc_text( PAGE, WorkerThread )
#endif
#if 0
NOT PAGEABLE -- SrvQueueWorkToBlockingThread
NOT PAGEABLE -- SrvQueueWorkToFsp
NOT PAGEABLE -- SrvQueueWorkToFspAtSendCompletion
NOT PAGEABLE -- SrvBalanceLoad
#endif


NTSTATUS
SrvCreateWorkerThreads (
    VOID
    )

/*++

Routine Description:

    This function creates the worker threads for the LAN Manager server
    FSP.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of thread creation

--*/

{
    NTSTATUS status;
    PWORK_QUEUE queue;

    PAGED_CODE( );

    //
    // Create the nonblocking worker threads.
    //
    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
        status = CreateQueueThread( queue );
        if( !NT_SUCCESS( status ) ) {
            return status;
        }
    }

    //
    // Create the blocking worker threads
    //
    return CreateQueueThread( &SrvBlockingWorkQueue );

} // SrvCreateWorkerThreads


NTSTATUS
CreateQueueThread (
    IN PWORK_QUEUE Queue
    )
/*++

Routine Description:

    This function creates a worker thread to service a queue.

    NOTE:  The scavenger occasionally kills off threads on a queue.  If logic
        here is modified, you may need to look there too.

Arguments:

    Queue - the queue to service

Return Value:

    NTSTATUS - Status of thread creation

--*/
{
    HANDLE threadHandle;
    LARGE_INTEGER interval;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Another thread is coming into being.  Keep the counts up to date
    //
    InterlockedIncrement( &Queue->Threads );
    InterlockedIncrement( &Queue->AvailableThreads );

    status = PsCreateSystemThread(
                &threadHandle,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                NULL,
                WorkerThread,
                Queue
                );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "CreateQueueThread: PsCreateSystemThread for "
                "queue %X returned %X",
            Queue,
            status
            );

        InterlockedDecrement( &Queue->Threads );
        InterlockedDecrement( &Queue->AvailableThreads );

        SrvLogServiceFailure( SRV_SVC_PS_CREATE_SYSTEM_THREAD, status );
        return status;
    }

    //
    // Close the handle so the thread can die when needed
    //

    SrvNtClose( threadHandle, FALSE );

    //
    // If we just created the first queue thread, wait for it
    // to store its thread pointer in IrpThread.  This pointer is
    // stored in all IRPs issued for this queue by the server.
    //
    while ( Queue->IrpThread == NULL ) {
        interval.QuadPart = -1*10*1000*10; // .01 second
        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    return STATUS_SUCCESS;

} // CreateQueueThread


VOID
InitializeWorkerThread (
    IN PWORK_QUEUE WorkQueue,
    IN KPRIORITY ThreadPriority
    )
{
    NTSTATUS status;
    KPRIORITY basePriority;

    PAGED_CODE( );


#if SRVDBG_LOCK
{
    //
    // Create a special system thread TEB.  The size of this TEB is just
    // large enough to accommodate the first three user-reserved
    // longwords.  These three locations are used for lock debugging.  If
    // the allocation fails, then no lock debugging will be performed
    // for this thread.
    //
    //

    PETHREAD Thread = PsGetCurrentThread( );
    ULONG TebSize = FIELD_OFFSET( TEB, UserReserved[0] ) + SRV_TEB_USER_SIZE;

    Thread->Tcb.Teb = ExAllocatePoolWithTag( NonPagedPool, TebSize, BlockTypeMisc );

    if ( Thread->Tcb.Teb != NULL ) {
        RtlZeroMemory( Thread->Tcb.Teb, TebSize );
    }
}
#endif // SRVDBG_LOCK

    //
    // Set this thread's priority.
    //

    basePriority = ThreadPriority;

    status = NtSetInformationThread (
                 NtCurrentThread( ),
                 ThreadBasePriority,
                 &basePriority,
                 sizeof(basePriority)
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "InitializeWorkerThread: NtSetInformationThread failed: %X\n",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_THREAD, status );
    }

#if MULTIPROCESSOR
    //
    // If this is a nonblocking worker thread, set its ideal processor affinity.  Setting
    //  ideal affinity informs ntos that the thread would rather run on its ideal
    //  processor if reasonable, but if ntos can't schedule it on that processor then it is
    //  ok to schedule it on a different processor.
    //
    if( SrvNumberOfProcessors > 1 && WorkQueue >= SrvWorkQueues && WorkQueue < eSrvWorkQueues ) {
        KeSetIdealProcessorThread( KeGetCurrentThread(), (CCHAR)(WorkQueue - SrvWorkQueues) );
    }
#endif

    //
    // Disable hard error popups for this thread.
    //

    IoSetThreadHardErrorMode( FALSE );

    return;

} // InitializeWorkerThread


VOID
WorkerThread (
    IN PWORK_QUEUE WorkQueue
    )
{
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    ULONG timeDifference;
    ULONG updateSmbCount = 0;
    ULONG updateTime = 0;
    ULONG iAmBlockingThread = (WorkQueue == &SrvBlockingWorkQueue);
    PLARGE_INTEGER Timeout = NULL;

    PAGED_CODE();

    //
    // If this is the first worker thread, save the thread pointer.
    //
    if( WorkQueue->IrpThread == NULL ) {
        WorkQueue->IrpThread = PsGetCurrentThread( );
    }

    InitializeWorkerThread( WorkQueue, SrvThreadPriority );

    //
    // If we are the IrpThread, we don't want to die 
    //
    if( WorkQueue->IrpThread != PsGetCurrentThread( ) ) {
        Timeout = &WorkQueue->IdleTimeOut;
    }

    //
    // Loop infinitely dequeueing and processing work items.
    //

    while ( TRUE ) {

        listEntry = KeRemoveQueue(
                        &WorkQueue->Queue,
                        WorkQueue->WaitMode,
                        Timeout
                        );

        if( (ULONG_PTR)listEntry == STATUS_TIMEOUT ) {
            //
            // We have a non critical thread that hasn't gotten any work for
            //  awhile.  Time to die.
            //
            InterlockedDecrement( &WorkQueue->AvailableThreads );
            InterlockedDecrement( &WorkQueue->Threads );
            SrvTerminateWorkerThread( NULL );
        }

        if( InterlockedDecrement( &WorkQueue->AvailableThreads ) == 0 &&
            !SrvFspTransitioning &&
            WorkQueue->Threads < WorkQueue->MaxThreads ) {

            //
            // We are running low on threads for this queue.  Spin up
            // another one before handling this request
            //
            CreateQueueThread( WorkQueue );
        }

        //
        // Get the address of the work item.
        //

        workContext = CONTAINING_RECORD(
                        listEntry,
                        WORK_CONTEXT,
                        ListEntry
                        );

        ASSERT( KeGetCurrentIrql() == 0 );

        //
        // There is work available.  It may be a work contect block or
        // an RFCB.  (Blocking threads won't get RFCBs.)
        //

        ASSERT( (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextInitial) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextNormal) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextRaw) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextSpecial) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeRfcb) );

#if DBG
        if ( GET_BLOCK_TYPE( workContext ) == BlockTypeRfcb ) {
            ((PRFCB)workContext)->ListEntry.Flink =
                                ((PRFCB)workContext)->ListEntry.Blink = NULL;
        }
#endif

        IF_DEBUG(WORKER1) {
            KdPrint(( "WorkerThread working on work context %p", workContext ));
        }

        //
        // Make sure we have a resaonable idea of the system time
        //
        if( ++updateTime == TIME_SMB_INTERVAL ) {
            updateTime = 0;
            SET_SERVER_TIME( WorkQueue );
        }

        //
        // Update statistics.
        //
        if ( ++updateSmbCount == STATISTICS_SMB_INTERVAL ) {

            updateSmbCount = 0;

            GET_SERVER_TIME( WorkQueue, &timeDifference );
            timeDifference = timeDifference - workContext->Timestamp;

            ++(WorkQueue->stats.WorkItemsQueued.Count);
            WorkQueue->stats.WorkItemsQueued.Time.QuadPart += timeDifference;
        }

        {
        //
        // Put the workContext out relative to bp so we can find it later if we need
        //  to debug.  The block of memory we're writing to is likely already in cache,
        //  so this should be relatively cheap.
        //
        PWORK_CONTEXT volatile savedWorkContext;
        savedWorkContext = workContext;

        }

        //
        // Make sure the WorkContext knows if it is on the blocking work queue
        //
        workContext->UsingBlockingThread = iAmBlockingThread;

        //
        // Call the restart routine for the work item.
        //

        IF_SMB_DEBUG( TRACE ) {
            KdPrint(( "Blocking %d, Count %d -> %p( %p )\n",
                        iAmBlockingThread,
                        workContext->ProcessingCount,
                        workContext->FspRestartRoutine,
                        workContext
            ));
        }

        workContext->FspRestartRoutine( workContext );

        //
        // Make sure we are still at normal level.
        //

        ASSERT( KeGetCurrentIrql() == 0 );

        //
        // We're getting ready to be available (i.e. waiting on the queue)
        //
        InterlockedIncrement( &WorkQueue->AvailableThreads );

    }

} // WorkerThread

VOID SRVFASTCALL
SrvQueueWorkToBlockingThread (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine queues a work item to a blocking thread.  These threads
    are used to service requests that may block for a long time, so we
    don't want to tie up our normal worker threads.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item at the tail of the blocking work queue.
    //

    SrvInsertWorkQueueTail(
        &SrvBlockingWorkQueue,
        (PQUEUEABLE_BLOCK_HEADER)WorkContext
    );

    return;

} // SrvQueueWorkToBlockingThread


VOID SRVFASTCALL
SrvQueueWorkToFsp (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for work items that are to be queued to
    a nonblocking worker thread in the FSP.  This function is also
    called from elsewhere in the server to transfer work to the FSP.
    This function should not be called at dispatch level -- use
    SrvQueueWorkToFspAtDpcLevel instead.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item at the tail of the nonblocking work queue.
    //

    if( WorkContext->QueueToHead ) {

        SrvInsertWorkQueueHead(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    } else {

        SrvInsertWorkQueueTail(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    }

} // SrvQueueWorkToFsp


NTSTATUS
SrvQueueWorkToFspAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Send completion handler for  work items that are to be queued to
    a nonblocking worker thread in the FSP.  This function is also
    called from elsewhere in the server to transfer work to the FSP.
    This function should not be called at dispatch level -- use
    SrvQueueWorkToFspAtDpcLevel instead.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item on the nonblocking work queue.
    //

    if( WorkContext->QueueToHead ) {

        SrvInsertWorkQueueHead(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    } else {

        SrvInsertWorkQueueTail(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvQueueWorkToFspAtSendCompletion


VOID SRVFASTCALL
SrvTerminateWorkerThread (
    IN OUT PWORK_CONTEXT WorkItem OPTIONAL
    )
/*++

Routine Description:

    This routine is called when a thread is being requested to terminate.  There
        are two cases when this happens.  One is at server shutdown -- in this
        case we need to keep requeueing the termination request until all the
        threads on the queue have terminated.  The other time is if a thread has
        not received work for some amount of time.
--*/
{
    LONG priority = 16;


    //
    // Raise our priority to ensure that this thread has a chance to get completely
    //  done before the main thread causes the driver to unload or something
    //
    NtSetInformationThread (
                    NtCurrentThread( ),
                    ThreadBasePriority,
                    &priority,
                    sizeof(priority)
                    );

    if( ARGUMENT_PRESENT( WorkItem ) &&
        InterlockedDecrement( &WorkItem->CurrentWorkQueue->Threads ) != 0 ) {

        //
        // We are being asked to terminate all of the worker threads on this queue.
        //  So, if we're not the last thread, we should requeue the workitem so
        //  the other threads will terminate
        //

        //
        // There are still other threads servicing this queue, so requeue
        //  the workitem
        //
        SrvInsertWorkQueueTail( WorkItem->CurrentWorkQueue,
                                (PQUEUEABLE_BLOCK_HEADER)WorkItem );
    }

    PsTerminateSystemThread( STATUS_SUCCESS ); // no return;
}


#if MULTIPROCESSOR

VOID
SrvBalanceLoad(
    IN PCONNECTION connection
    )
/*++

Routine Description:

    Ensure that the processor handling 'connection' is the best one
     for the job.  This routine is called periodically per connection from
     DPC level.  It can not be paged.

Arguments:

    connection - the connection to inspect

Return Value:

    none.

--*/
{
    ULONG MyQueueLength, OtherQueueLength;
    ULONG i;
    PWORK_QUEUE tmpqueue;
    PWORK_QUEUE queue = connection->CurrentWorkQueue;

    ASSERT( queue >= SrvWorkQueues );
    ASSERT( queue < eSrvWorkQueues );

    //
    // Reset the countdown.  After the client performs BalanceCount
    //   more operations, we'll call this routine again.
    //
    connection->BalanceCount = SrvBalanceCount;

    //
    // Figure out the load on the current work queue.  The load is
    //  the sum of the average work queue depth and the current work
    //  queue depth.  This gives us some history mixed in with the
    //  load *right now*
    //
    MyQueueLength = queue->AvgQueueDepthSum >> LOG2_QUEUE_SAMPLES;
    MyQueueLength += KeReadStateQueue( &queue->Queue );

    //
    // If we are not on our preferred queue, look to see if we want to
    //  go back to it.  The preferred queue is the queue for the processor
    //  handling this client's network card DPCs.  We prefer to run on that
    //  processor to avoid sloshing data between CPUs in an MP system.
    //
    tmpqueue = connection->PreferredWorkQueue;

    ASSERT( tmpqueue >= SrvWorkQueues );
    ASSERT( tmpqueue < eSrvWorkQueues );

    if( tmpqueue != queue ) {

        //
        // We are not queueing to our preferred queue.  See if we
        // should go back to our preferred queue
        //

        ULONG PreferredQueueLength;

        PreferredQueueLength = tmpqueue->AvgQueueDepthSum >> LOG2_QUEUE_SAMPLES;
        PreferredQueueLength += KeReadStateQueue( &tmpqueue->Queue );

        if( PreferredQueueLength <= MyQueueLength + SrvPreferredAffinity ) {

            //
            // We want to switch back to our preferred processor!
            //

            IF_DEBUG( REBALANCE ) {
                KdPrint(( "%p C%d(%p) > P%p(%d)\n",
                    connection,
                    MyQueueLength,
                    (PVOID)(connection->CurrentWorkQueue - SrvWorkQueues),
                    (PVOID)(tmpqueue - SrvWorkQueues),
                    PreferredQueueLength ));
            }

            InterlockedDecrement( &queue->CurrentClients );
            InterlockedExchangePointer( &connection->CurrentWorkQueue, tmpqueue );
            InterlockedIncrement( &tmpqueue->CurrentClients );
            SrvReBalanced++;
            return;
        }
    }

    //
    // We didn't hop to the preferred processor, so let's see if
    // another processor looks more lightly loaded than we are.
    //

    //
    // SrvNextBalanceProcessor is the next processor we should consider
    //  moving to.  It is a global to ensure everybody doesn't pick the
    //  the same processor as the next candidate.
    //
    tmpqueue = &SrvWorkQueues[ SrvNextBalanceProcessor ];

    //
    // Advance SrvNextBalanceProcessor to the next processor in the system
    //
    i = SrvNextBalanceProcessor + 1;

    if( i >= SrvNumberOfProcessors )
        i = 0;

    SrvNextBalanceProcessor = i;

    //
    // Look at the other processors, and pick the next one which is doing
    // enough less work than we are to make the jump worthwhile
    //

    for( i = SrvNumberOfProcessors; i > 1; --i ) {

        ASSERT( tmpqueue >= SrvWorkQueues );
        ASSERT( tmpqueue < eSrvWorkQueues );

        OtherQueueLength = tmpqueue->AvgQueueDepthSum >> LOG2_QUEUE_SAMPLES;
        OtherQueueLength += KeReadStateQueue( &tmpqueue->Queue );

        if( OtherQueueLength + SrvOtherQueueAffinity < MyQueueLength ) {

            //
            // This processor looks promising.  Switch to it
            //

            IF_DEBUG( REBALANCE ) {
                KdPrint(( "%p %c%p(%d) > %c%p(%d)\n",
                    connection,
                    queue == connection->PreferredWorkQueue ? 'P' : 'C',
                    (PVOID)(queue - SrvWorkQueues),
                    MyQueueLength,
                    tmpqueue == connection->PreferredWorkQueue ? 'P' : 'C',
                    (PVOID)(tmpqueue - SrvWorkQueues),
                    OtherQueueLength ));
            }

            InterlockedDecrement( &queue->CurrentClients );
            InterlockedExchangePointer( &connection->CurrentWorkQueue, tmpqueue );
            InterlockedIncrement( &tmpqueue->CurrentClients );
            SrvReBalanced++;
            return;
        }

        if( ++tmpqueue == eSrvWorkQueues )
            tmpqueue = SrvWorkQueues;
    }

    //
    // No rebalancing necessary
    //
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\daytonam\makefile.inc ===
MOF: srv.bmf

srv.bmf: ..\srv.mof
    mofcomp -B:srv.bmf ..\srv.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\svcxport.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcxport.c

Abstract:

    This module contains routines for supporting the transport APIs in the
    server service, NetServerTransportAdd, NetServerTransportDel,
    and NetServerTransportEnum.

Author:

    David Treadwell (davidtr) 6-Mar-1991

Revision History:

--*/

#include "precomp.h"
#include "svcxport.tmh"
#pragma hdrstop

//
// Forward declarations.
//

VOID
FillTransportInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetServerTransportAdd )
#pragma alloc_text( PAGE, SrvNetServerTransportDel )
#pragma alloc_text( PAGE, SrvNetServerTransportEnum )
#pragma alloc_text( PAGE, FillTransportInfoBuffer )
#pragma alloc_text( PAGE, FilterTransports )
#pragma alloc_text( PAGE, SizeTransports )
#endif


NTSTATUS
SrvNetServerTransportAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerTransportAdd API in the server
    FSP.  Because it opens an object (the transport device object) it
    must be done in the server FSP, not the FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        None.

      OUTPUT:

        None.

    Buffer - a pointer to a TRANSPORT_INFO_0 structure for the new
        transport.  All pointers should have been changed to offsets
        within the buffer.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status;
    PSERVER_TRANSPORT_INFO_3 svti3;
    UNICODE_STRING transportName;
    UNICODE_STRING domainName;
    ANSI_STRING transportAddress;
    UNICODE_STRING netName;

    PAGED_CODE( );

    //
    // Convert the offsets in the transport data structure to pointers.
    // Also make sure that all the pointers are within the specified
    // buffer.
    //

    svti3 = Buffer;

    OFFSET_TO_POINTER( svti3->svti3_transportname, svti3 );
    OFFSET_TO_POINTER( svti3->svti3_transportaddress, svti3 );
    OFFSET_TO_POINTER( svti3->svti3_domain, svti3 );

    if ( !POINTER_IS_VALID( svti3->svti3_transportname, svti3, BufferLength ) ||
         !POINTER_IS_VALID( svti3->svti3_transportaddress, svti3, BufferLength ) ||
         !POINTER_IS_VALID( svti3->svti3_domain, svti3, BufferLength ) ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvNetServerTransportAdd: Bad pointers\n" ));
        }

        return STATUS_ACCESS_VIOLATION;
    }

    if( svti3->svti3_passwordlength > sizeof( svti3->svti3_password ) ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvNetServerTransportAdd: svti3_passwordlength %d\n", svti3->svti3_passwordlength ));
        }

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set up the transport name, server name, domain name, and net name.
    //

    RtlInitUnicodeString( &transportName, (PWCH)svti3->svti3_transportname );

    netName.Buffer = NULL;
    netName.Length = 0;
    netName.MaximumLength = 0;

    RtlInitUnicodeString( &domainName, (PWCH)svti3->svti3_domain );

    transportAddress.Buffer = svti3->svti3_transportaddress;
    transportAddress.Length = (USHORT)svti3->svti3_transportaddresslength;
    transportAddress.MaximumLength = (USHORT)svti3->svti3_transportaddresslength;

    //
    // Attempt to add the new transport to the server.
    //

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: SrvNetServerTransportAdd: %wZ\n", &transportName ));
    }

    status = SrvAddServedNet( &netName,
                              &transportName,
                              &transportAddress,
                              &domainName,
                              Srp->Flags & SRP_XADD_FLAGS,
                              svti3->svti3_passwordlength,
                              svti3->svti3_password
                             );

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: SrvNetServerTransportAdd: %wZ, status %X\n", &transportName, status ));
    }

    return status;

} // SrvNetServerTransportAdd


NTSTATUS
SrvNetServerTransportDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerTransportEnum API in the server
    FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

    Buffer - a pointer to a TRANSPORT_INFO_0 structure for the
        transport.  All pointers should have been changed to offsets
        within the buffer.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status;
    PSERVER_TRANSPORT_INFO_3 svti3;
    UNICODE_STRING transportName;
    ANSI_STRING transportAddress;

    PAGED_CODE( );

    Srp;

    //
    // Convert the offsets in the transport data structure to pointers.
    // Also make sure that all the pointers are within the specified
    // buffer.
    //

    svti3 = Buffer;

    OFFSET_TO_POINTER( svti3->svti3_transportname, svti3 );

    if ( !POINTER_IS_VALID( svti3->svti3_transportname, svti3, BufferLength ) ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(("SrvNetServerTransportDel: STATUS_ACCESS_VIOLATION at %u\n", __LINE__ ));
        }
        return STATUS_ACCESS_VIOLATION;
    }


    RtlInitUnicodeString( &transportName, (PWCH)svti3->svti3_transportname );

    transportAddress.Length = (USHORT)svti3->svti3_transportaddresslength;
    transportAddress.MaximumLength = (USHORT)svti3->svti3_transportaddresslength;

    if( transportAddress.Length != 0 ) {

        OFFSET_TO_POINTER( svti3->svti3_transportaddress, svti3 );

        if( !POINTER_IS_VALID( svti3->svti3_transportaddress, svti3, BufferLength ) ) {
            IF_DEBUG( ERRORS ) {
                KdPrint(("SrvNetServerTransportDel: STATUS_ACCESS_VIOLATION at %u\n", __LINE__ ));
            }
            return STATUS_ACCESS_VIOLATION;
        }

        transportAddress.Buffer = svti3->svti3_transportaddress;
    }

    //
    // Attempt to delete the transport endpoint from the server.
    //
    status = SrvDeleteServedNet( &transportName, &transportAddress );

    IF_DEBUG( ERRORS ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "SrvNetServerTransportDel: SrvDeleteServedNet status %X\n", status ));
        }
    }

    return status;

} // SrvNetServerTransportDel


NTSTATUS
SrvNetServerTransportEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerTransportEnum API in the server
    FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        None.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

    Buffer - a pointer to a TRANSPORT_INFO_0 structure for the new
        transport.  All pointers should have been changed to offsets
        within the buffer.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvEndpointList,
               FilterTransports,
               SizeTransports,
               FillTransportInfoBuffer
               );

} // SrvNetServerTransportEnum


VOID
FillTransportInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed transport structure and, if it fits,
    associated variable data, into a buffer.  Fixed data goes at the
    beginning of the buffer, variable data at the end.

Arguments:

    Endpoint - the endpoint from which to get information.

    FixedStructure - where the in the buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PENDPOINT endpoint = Block;
    PSERVER_TRANSPORT_INFO_1 svti1 = *FixedStructure;
    ULONG TransportAddressLength;

    PAGED_CODE( );

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure +
        (Srp->Level ? sizeof( SERVER_TRANSPORT_INFO_1 ) : sizeof( SERVER_TRANSPORT_INFO_0 ));

    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // The number of VCs on the endpoint is equal to the total number
    // of connections on the endpoint less the free connections.
    //

    ACQUIRE_LOCK_SHARED( &SrvEndpointLock );

    svti1->svti1_numberofvcs =
        endpoint->TotalConnectionCount - endpoint->FreeConnectionCount;

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // Copy over the transport name.
    //

    SrvCopyUnicodeStringToBuffer(
        &endpoint->TransportName,
        *FixedStructure,
        EndOfVariableData,
        &svti1->svti1_transportname
        );

    //
    // Copy over the network name.
    //

    SrvCopyUnicodeStringToBuffer(
        &endpoint->NetworkAddress,
        *FixedStructure,
        EndOfVariableData,
        &svti1->svti1_networkaddress
        );

    //
    // Copy over the domain name
    //
    if( Srp->Level > 0 ) {

        SrvCopyUnicodeStringToBuffer(
            &endpoint->DomainName,
            *FixedStructure,
            EndOfVariableData,
            &svti1->svti1_domain
            );

    }

    //
    // Copy over the transport address.  We have to manually check here
    // whether it will fit in the output buffer.
    //
    //
    // Don't copy the trailing blanks of the transport address.
    //

    for ( TransportAddressLength = endpoint->TransportAddress.Length;
          TransportAddressLength > 0 && endpoint->TransportAddress.Buffer[TransportAddressLength-1] == ' ' ;
          TransportAddressLength-- ) ;

    *EndOfVariableData = (LPWSTR)( (PCHAR)*EndOfVariableData - TransportAddressLength );

    //
    // Ensure we remain byte aligned, so knock off the low bit if necessary.  Remember, we
    //  are filling backwards from the end of the buffer so we want to round the address down
    //
    *EndOfVariableData = (LPWSTR)( (ULONG_PTR)*EndOfVariableData & ~1 );

    if ( (ULONG_PTR)*EndOfVariableData > (ULONG_PTR)*FixedStructure ) {

        //
        // The address will fit.  Copy it over to the output buffer.
        //

        RtlCopyMemory(
            *EndOfVariableData,
            endpoint->TransportAddress.Buffer,
            TransportAddressLength
            );

        svti1->svti1_transportaddress = (LPBYTE)*EndOfVariableData;
        svti1->svti1_transportaddresslength = TransportAddressLength;

    } else {

        svti1->svti1_transportaddress = NULL;
        svti1->svti1_transportaddresslength = 0;
    }

    return;

} // FillTransportInfoBuffer


BOOLEAN
FilterTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine just returns TRUE since we always want to place
    information about all transports in the output buffer for a
    NetServerTransportEnum.

Arguments:

    Srp - not used.

    Block - not used.

Return Value:

    TRUE.

--*/

{
    PENDPOINT endpoint = Block;

    PAGED_CODE( );

    Srp, Block;

    //
    //  We filter out AlternateEndpoint since they are endpoints we've
    //  created ourselves.
    //

    if (endpoint->AlternateAddressFormat) {

        return FALSE;
    }

    //
    // We always return information about all transports.
    //

    return TRUE;

} // FilterFiles


ULONG
SizeTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in endpoint would take up
    in an API output buffer.

Arguments:

    Srp - not used.

    Block - a pointer to the endpoint to size.

Return Value:

    ULONG - The number of bytes the endpoint would take up in the
        output buffer.

--*/

{
    PENDPOINT endpoint = Block;
    ULONG size;

    PAGED_CODE( );

    size = Srp->Level ? sizeof( SERVER_TRANSPORT_INFO_1 ) : sizeof( SERVER_TRANSPORT_INFO_0 );

    size += SrvLengthOfStringInApiBuffer(&(endpoint)->TransportName);
    size += (endpoint)->TransportAddress.Length + sizeof(TCHAR);
    size += SrvLengthOfStringInApiBuffer(&(endpoint)->NetworkAddress);

    if( Srp->Level ) {
        size += SrvLengthOfStringInApiBuffer( &(endpoint)->DomainName );
    }

    return size;

} // SizeTransports
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\srvkd\srvkd.c ===
#ifndef DBG
#define DBG 1
#endif
#define SRVDBG 1

#define SRVKD 1
#include "precomp.h"

#include <ntverp.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#ifndef MIN
#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
#endif

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?

/*
 * The help strings printed out
 */
static LPSTR Extensions[] = {
    "Lan Manager Server Debugger Extensions:\n",
    "buffer address                                  Dump the BUFFER structure",
    "client                                          Dump the clients + CONNECTION structs",
    "connection address                              Dump the CONNECTION structure",
    "context address                                 Dump the WORK_CONTEXT structure",
    "df address                                      Follow an entire LIST_ENTRY to end",
    "endpoint [ address ]                            Dump the ENDPOINT structure(s)",
    "errcodes                                        Dump the error log code filter",
    "globals                                         Print out srv's global variables",
    "help",
    "lfcb address                                    Dump the LFCB structure",
    "lock [ address ]                                Dump the ERESOURCE structure(s)",
    "mfcb address                                    Dump the LFCB structure",
    "pagedconnection address                         Dump the PAGED_CONNECTION structure",
    "queue [ address ]                               Dump the WORK_QUEUE structure",
    "rfcb [ address ]                                Dump the RFCB structure(s)",
    "scavenger                                       Dump scavenger info",
    "search address                                  Dump the SEARCH structure",
    "session address                                 Dump the SESSION structure",
    "share [ address | disk | print | comm | pipe ]  Dump the SHARE structure(s)",
    "share =name                                     Dump the SHARE structure for 'name'",
    "smb address                                     Dump the SMB_HEADER",
#if SRVDBG == 1
    "smbdebug [ t | f | #'s ]                        Get or set SMB debug flags",
#endif
    "srv                                             Turn target into a Server",
#if SRVDBG == 1
    "srvdebug [ t | f | #'s ]                        Get or set server debug flags",
#endif
    "statistics                                      Dump the SrvStatistics structure",
    "tcon address                                    Dump the TREE_CONNECT structure",
    "transaction address                             Dump the TRANSACTION structure",
    "version",
    "wksta                                           Turn target into a Workstation",
    0
};

static LPSTR BlockState[] = {
    "BlockStateDead",
    "BlockStateInitializing",
    "BlockStateActive",
    "BlockStateClosing"
};

static LPSTR BlockType[] = {
    "BlockTypeGarbage",
    "BlockTypeBuffer",
    "BlockTypeConnection",
    "BlockTypeEndpoint",
    "BlockTypeLfcb",
    "BlockTypeMfcb",
    "BlockTypeRfcb",
    "BlockTypeSearch",
    "BlockTypeSearchCore",
    "BlockTypeByteRangeLock",
    "BlockTypeSession",
    "BlockTypeShare",
    "BlockTypeTransaction",
    "BlockTypeTreeConnect",
    "BlockTypeWaitForOplockBreak",
    "BlockTypeCommDevice",
    "BlockTypeWorkContextInitial",
    "BlockTypeWorkContextNormal",
    "BlockTypeWorkContextRaw",
    "BlockTypeDataBuffer",
    "BlockTypeTable",
    "BlockTypeNonpagedHeader",
    "BlockTypePagedConnection",
    "BlockTypePagedRfcb",
    "BlockTypeNonpagedMfcb",
    "BlockTypeTimer",
    "BlockTypeAdminCheck",
    "BlockTypeWorkQueue",
#ifdef INCLUDE_SMB_PERSISTENT
    "BlockTypeDfs",
    "BlockTypePersistentState",
    "BlockTypePersistentBitMap",
    "BlockTypePersistentShareState",
#else
    "BlockTypeDfs"
#endif
};

/*
 * The locks that we'd like to dump
 */
static LPSTR SrvLocks[] = {
    "SrvConfigurationLock",
    "SrvEndpointLock",
    "SrvShareLock",
    "SrvOrderedListLock",
    "SrvOplockBreakListLock",
    "SrvUnlockableCodeLock",
    0
};

/*
 * The globals that we'd like to dump
 */
static LPSTR GlobalBool[] = {
    "SrvProductTypeServer",
    "SrvMultiProcessorDriver",
    "SrvEnableOplocks",
    "SrvEnableFcbOpens",
    "SrvEnableSoftCompatibility",
    "SrvEnableRawMode",
    "SrvSmbSecuritySignaturesRequired",
    "SrvSmbSecuritySignaturesEnabled",
    "SrvEnableW9xSecuritySignatures",
    "SrvSupportsCompression",
    "SrvRemoveDuplicateSearches",
    "SrvRestrictNullSessionAccess",
    "SrvEnableWfW311DirectIpx",
    "SrvEnableOplockForceClose",
    "SrvEnableForcedLogoff",
    "SrvFspActive",
    "SrvXsActive",
    "SrvPaused",
    "SrvCompletedPNPRegistration",
    "SrvFspTransitioning",
    "SrvResourceThreadRunning",
    "SrvResourceDisconnectPending",
    "SrvResourceFreeConnection",
    "SrvResourceOrphanedBlocks",
    0
};

static LPSTR GlobalShort[] = {
    "SrvInitialSessionTableSize",
    "SrvMaxSessionTableSize",
    "SrvInitialTreeTableSize",
    "SrvInitialTreeTableSize",
    "SrvMaxTreeTableSize",
    "SrvInitialFileTableSize",
    "SrvMaxFileTableSize",
    "SrvInitialSearchTableSize",
    "SrvMaxSearchTableSize",
    "SrvMaxMpxCount",
    0
};

static LPSTR GlobalLong[] = {
    "SrvServerSize",
    "SrvNumberOfProcessors",
    "SrvMinNT5Client",
    "SrvAbortiveDisconnects",
    "SrvBalanceCount",
    "SrvReBalanced",
    "SrvOtherQueueAffinity",
    "SrvPreferredAffinity",
    "SrvMaxFreeRfcbs",
    "SrvMaxFreeMfcbs",
    "SrvReceiveBufferLength",
    "SrvInitialReceiveWorkItemCount",
    "SrvMaxReceiveWorkItemCount",
    "SrvInitialRawModeWorkItemCount",
    "SrvMaxRawModeWorkItemCount",
    "SrvFreeConnectionMinimum",
    "SrvFreeConnectionMaximum",
    "SrvScavengerTimeoutInSeconds",
    "SrvMaxNumberVcs",
    "SrvMinReceiveQueueLength",
    "SrvMinFreeWorkItemsBlockingIo",
    "SrvIpxAutodisconnectTimeout",
    "SrvConnectionNoSessionsTimeout",
    "SrvMaxUsers",
    "SrvMaxPagedPoolUsage",
    "SrvMaxNonPagedPoolUsage",
    "SrvScavengerUpdateQosCount",
    "SrvWorkItemMaxIdleTime",
    "SrvAlertMinutes",
    "SrvFreeDiskSpaceThreshold",
    "SrvSharingViolationRetryCount",
    "SrvLockViolationDelay",
    "SrvLockViolationOffset",
    "SrvMaxOpenSearches",
    "SrvMaxFsctlBufferSize",
    "SrvMdlReadSwitchover",
    "SrvMpxMdlReadSwitchover",
    "SrvCachedOpenLimit",
    "SrvXsSharedMemoryReference",
    "SrvEndpointCount",
    "SrvBlockingOpsInProgress",
    "SrvFastWorkAllocation",
    "SrvSlowWorkAllocation",
    "SrvMinClientBufferSize",
    "SrvMaxFsctlBufferSize",
    "SrvMaxReadSize",
    "SrvMaxCompressedDataLength",
    "SrvMaxWriteChunk",
    "SrvNT5SecuritySigBuildNumber",
    0
};

static LPSTR GlobalLongHex[] = {
    "SrvNamedPipeHandle",
    "SrvNamedPipeDeviceObject",
    "SrvNamedPipeFileObject",
    "SrvDfsDeviceObject",
    "SrvDfsFileObject",
    "SrvDfsFastIoDeviceControl",
    "SrvDiskConfiguration",
    "SrvSvcProcess",
//  "SrvWorkQueuesBase",
    "SrvWorkQueues",
    "eSrvWorkQueues",
    "SrvIpxSmartCard",
    0
};

static LPSTR GlobalStringVector[] = {
    "SrvNullSessionPipes",
    "SrvNullSessionShares",
    "SrvPipesNeedLicense",
    "SrvNoRemapPipeNames",
    0
};

static LPSTR GlobalStrings[] = {
    "SrvComputerName",
    "SrvNativeOS",
    "SrvNativeLanMan",
    "SrvSystemRoot",
    0
};

static LPSTR ScavengerLong[] = {
    "LastNonPagedPoolLimitHitCount",
    "LastNonPagedPoolFailureCount",
    "LastPagedPoolLimitHitCount",
    "LastPagedPoolFailureCount",
    "SrvScavengerCheckRfcbActive",
    "ScavengerUpdateQosCount",
    "ScavengerCheckRfcbActive",
    "FailedWorkItemAllocations",
    0
};

static LPSTR ScavengerBool[] = {
    "RunShortTermAlgorithm",
    "RunScavengerAlgorithm",
    "RunAlerterAlgorithm",
    "EventSwitch",
    0
};

struct BitFields {
    PCSTR name;
    ULONGLONG value;
};

#if defined( SRVDBG ) && SRVDBG == 1

#define    DF( name )    { #name, DEBUG_ ## name }
struct BitFields SrvDebugFlags[] = {
    DF( TRACE1 ),
    DF( TRACE2 ),
    DF( REFCNT ),
    DF( HEAP ),
    DF( WORKER1 ),
    DF( WORKER2 ),
    DF( NET1 ),
    DF( NET2 ),
    DF( FSP1 ),
    DF( FSP2 ),
    DF( FSD1 ),
    DF( FSD2 ),
    DF( SCAV1 ),
    DF( SCAV2 ),
    DF( BLOCK1 ),
    DF( IPX_PIPES ),
    DF( HANDLES ),
    DF( IPX ),
    DF( TDI ),
    DF( OPLOCK ),
    DF( NETWORK_ERRORS ),
    DF( FILE_CACHE ),
    DF( IPX2 ),
    DF( LOCKS ),
    DF( SEARCH ),
    DF( BRUTE_FORCE_REWIND ),
    DF( COMM ),
    DF( XACTSRV ),
    DF( LICENSE ),
    DF( API_ERRORS ),
    DF( STOP_ON_ERRORS ),
    DF( ERRORS ),
    DF( SMB_ERRORS ),
    DF( WORKITEMS ),
    DF( IPXNAMECLAIM ),
    DF( SENDS2OTHERCPU ),
    DF( REBALANCE ),
    DF( PNP ),
    DF( DFS ),
    DF( SIPX ),
    DF( COMPRESSION ),
    DF( CREATE ),
    DF( SECSIG ),
    DF( STUCK_OPLOCK ),
    0
};

#undef DF
#define    DF( name )    { #name, DEBUG_SMB_ ## name }

struct BitFields SmbDebugFlags[] = {
    DF( ERRORS ),
    DF( ADMIN1 ),
    DF( ADMIN2 ),
    DF( TREE1 ),
    DF( TREE2 ),
    DF( DIRECTORY1 ),
    DF( DIRECTORY2 ),
    DF( OPEN_CLOSE1 ),
    DF( OPEN_CLOSE2 ),
    DF( FILE_CONTROL1 ),
    DF( FILE_CONTROL2 ),
    DF( READ_WRITE1 ),
    DF( READ_WRITE2 ),
    DF( LOCK1 ),
    DF( LOCK2 ),
    DF( RAW1 ),
    DF( RAW2 ),
    DF( MPX1 ),
    DF( MPX2 ),
    DF( SEARCH1 ),
    DF( SEARCH2 ),
    DF( TRANSACTION1 ),
    DF( TRANSACTION2 ),
    DF( PRINT1 ),
    DF( PRINT2 ),
    DF( MESSAGE1 ),
    DF( MESSAGE2 ),
    DF( MISC1 ),
    DF( MISC2 ),
    DF( QUERY_SET1 ),
    DF( QUERY_SET2 ),
    DF( TRACE ),
    0
};

#endif // SRVDBG

/*
 * The MEMBERLIST structure, and the macros that follow, give an easy way to declare
 * the members of a structure to be printed.  Once you set up a MEMBERLIST[] for a
 * particular structure, you call PrintMemberList() to do a formatted dump of the struct
 */
typedef struct _MEMBERLIST {
    LPSTR name;                  // The name of the field
    ULONG offset;                // The offset of the field in the structure
    UCHAR type;                  // The type of variable to be printed
    LONG extra;                  // Any other extra info needed for this type
} MEMBERLIST;

// BE -> BOOL
// HE -> HEX ULONG
// PE -> POINTER
// UE -> Unsigned ULONG
// HC -> Unsigned char as hex
// DE -> Decimal Long
// SE -> Decimal Short
// WE -> UNICODE_STRING
// AE -> ANSI_STRING
// IE -> Symbol Address
// CE -> Character
// TE -> TABLE_HEADER structure, and follow the table
// LE -> LIST_ENTRY list
// BT -> BLOCK_HEADER 'Type' field
// BS -> BLOCK_HEADER 'State' field
// BC -> BLOCK_HEADER 'ReferenceCount' field
// U64-> LONGLONG
// IA -> IP Address

#define    ROOT( StructureName ) { "@" #StructureName, 0, 'R' }
#define    BE( StructureName, FieldName ) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'B' }
#define    CE( StructureName, FieldName ) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'C' }
#define    HE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'H' }
#define    PE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'P' }
#define    UE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'U' }
#define    U64( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), '6' }
#define    DE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'L' }
#define    SE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'S' }
#define    WE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'W' }
#define    AE( StructureName, FieldName) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'A' }
#define    IE( StructureName, FieldName) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'I' }
#define    TE( StructureName, FieldName) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'T' }
#define    LE( StructureName, FieldName, PointedToStructure, PointedToMemberName ) \
                            { #FieldName, FIELD_OFFSET( StructureName, FieldName##.Flink ), 'Z', \
                              FIELD_OFFSET( PointedToStructure, PointedToMemberName ## .Flink ) }
#define    BT() { "BlockHeader.Type", FIELD_OFFSET( BLOCK_HEADER, Type) , 'K' }
#define    BS() { "BlockHeader.State", FIELD_OFFSET( BLOCK_HEADER, State), 'Q' }
#define    BC() { "BlockHeader.ReferenceCount", FIELD_OFFSET( BLOCK_HEADER, ReferenceCount), 'L' }
#define    IA( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'N' }

/*
 * The members of an SMB_HEADER
 */
MEMBERLIST ML_SMB_HEADER[] = {
    CE( NT_SMB_HEADER, Command ),
    HE( NT_SMB_HEADER, Status.NtStatus ),
    CE( NT_SMB_HEADER, Flags ),
    SE( NT_SMB_HEADER, Flags2 ),
    SE( NT_SMB_HEADER, Tid ),
    SE( NT_SMB_HEADER, Pid ),
    SE( NT_SMB_HEADER, Uid ),
    SE( NT_SMB_HEADER, Mid ),
    0
};


/*
 * The members in an MFCB
 */
MEMBERLIST ML_MFCB[] = {
    PE( MFCB, NonpagedMfcb ),
    UE( MFCB, ActiveRfcbCount ),
    BE( MFCB, CompatibilityOpen ),
    HE( MFCB, FileNameHashValue ),
    WE( MFCB, FileName ),
    PE( MFCB, MfcbHashTableEntry.Flink ),
    LE( MFCB, LfcbList, LFCB, MfcbListEntry ),
    0
};

/*
 * The members in the SrvStatistics structure
 */
MEMBERLIST ML_SRV_STATISTICS[] = {
    U64( SRV_STATISTICS, TotalBytesReceived ),
    U64( SRV_STATISTICS, TotalBytesSent ),
    DE( SRV_STATISTICS, SessionLogonAttempts ),
    DE( SRV_STATISTICS, SessionsTimedOut ),
    DE( SRV_STATISTICS, SessionsErroredOut ),
    DE( SRV_STATISTICS, SessionsLoggedOff ),
    DE( SRV_STATISTICS, SessionsForcedLogOff ),
    DE( SRV_STATISTICS, LogonErrors ),
    DE( SRV_STATISTICS, AccessPermissionErrors ),
    DE( SRV_STATISTICS, GrantedAccessErrors ),
    DE( SRV_STATISTICS, SystemErrors ),
    DE( SRV_STATISTICS, BlockingSmbsRejected ),
    DE( SRV_STATISTICS, WorkItemShortages ),
    DE( SRV_STATISTICS, TotalFilesOpened ),
    DE( SRV_STATISTICS, CurrentNumberOfOpenFiles ),
    DE( SRV_STATISTICS, CurrentNumberOfSessions ),
    DE( SRV_STATISTICS, CurrentNumberOfOpenSearches ),
    DE( SRV_STATISTICS, CurrentNonPagedPoolUsage ),
    DE( SRV_STATISTICS, NonPagedPoolFailures ),
    DE( SRV_STATISTICS, PeakNonPagedPoolUsage ),
    DE( SRV_STATISTICS, CurrentPagedPoolUsage ),
    DE( SRV_STATISTICS, PagedPoolFailures ),
    DE( SRV_STATISTICS, PeakPagedPoolUsage ),
    DE( SRV_STATISTICS, CompressedReads ),
    DE( SRV_STATISTICS, CompressedReadsRejected ),
    DE( SRV_STATISTICS, CompressedReadsFailed ),
    DE( SRV_STATISTICS, CompressedWrites ),
    DE( SRV_STATISTICS, CompressedWritesRejected ),
    DE( SRV_STATISTICS, CompressedWritesFailed ),
    DE( SRV_STATISTICS, CompressedWritesExpanded ),
    0
};

/*
 * The members in a NONPAGED_MFCB
 */
MEMBERLIST ML_NONPAGED_MFCB[] = {
    UE( NONPAGED_MFCB, Type ),
    PE( NONPAGED_MFCB, PagedBlock ),
    PE( NONPAGED_MFCB, Lock ),
    HE( NONPAGED_MFCB, OpenFileAttributes ),
    0
};

/*
 * The members in an LFCB
 */
MEMBERLIST ML_LFCB[] = {
    UE( LFCB, HandleCount ),
    PE( LFCB, Mfcb ),
    PE( LFCB, Connection ),
    PE( LFCB, Session ),
    PE( LFCB, TreeConnect ),
    HE( LFCB, GrantedAccess ),
    HE( LFCB, FileHandle ),
    PE( LFCB, FileObject ),
    PE( LFCB, DeviceObject ),
    HE( LFCB, FileMode ),
    HE( LFCB, JobId ),
    IE( LFCB, FastIoRead ),
    IE( LFCB, FastIoWrite ),
    IE( LFCB, FastIoUnlockSingle ),
    BE( LFCB, CompatibilityOpen ),
    0
};

/*
 * The members in an RFCB
 */
MEMBERLIST ML_RFCB[] = {
    BE( RFCB, BlockingModePipe ),
    BE( RFCB, ByteModePipe ),
    BE( RFCB, CachedOpen ),
    PE( RFCB, CachedOpenListEntry ),
    PE( RFCB, Connection ),
    BE( RFCB, DeferredOplockBreak ),
    SE( RFCB, Fid ),
    HE( RFCB, FileMode ),
    PE( RFCB, GlobalRfcbListEntry ),
    HE( RFCB, GrantedAccess ),
    PE( RFCB, Irp ),
    BE( RFCB, IsActive ),
    BE( RFCB, IsCacheable ),
    PE( RFCB, Lfcb ),
    BE( RFCB, LockAccessGranted ),
    PE( RFCB, Mfcb ),
    BE( RFCB, MpxGlommingAllowed ),
    CE( RFCB, NewOplockLevel ),
    DE( RFCB, NumberOfLocks ),
    BE( RFCB, OnOplockBreaksInProgressList ),
    BE( RFCB, OpenResponseSent ),
    UE( RFCB, OplockState ),
    PE( RFCB, PagedRfcb ),
    SE( RFCB, Pid ),
    UE( RFCB, RawWriteCount ),
    LE( RFCB, RawWriteSerializationList, WORK_CONTEXT, ListEntry ),
    BE( RFCB, ReadAccessGranted ),
    PE( RFCB, RetryOplockRequest ),
    HE( RFCB, SavedError ),
    HE( RFCB, ShareAccess ),
    HE( RFCB, ShiftedFid ),
    SE( RFCB, Tid ),
    SE( RFCB, Uid ),
    BE( RFCB, UnlockAccessGranted ),
    BE( RFCB, WriteAccessGranted ),
    BE( RFCB, AppendAccessGranted ),
    BE( RFCB, WrittenTo ),
    DE( RFCB, WriteMpx.ReferenceCount ),
    HE( RFCB, WriteMpx.Mask ),
    PE( RFCB, WriteMpx.FileObject ),
    SE( RFCB, WriteMpx.Mid ),
    SE( RFCB, WriteMpx.PreviousMid ),
    SE( RFCB, WriteMpx.SequenceNumber ),
    BE( RFCB, WriteMpx.Glomming ),
    BE( RFCB, WriteMpx.GlomPending ),
    PE( RFCB, WriteMpx.GlomDelayList ),
    DE( RFCB, WriteMpx.StartOffset ),
    SE( RFCB, WriteMpx.Length ),
    BE( RFCB, WriteMpx.GlomComplete ),
    BE( RFCB, WriteMpx.MpxGlommingAllowed ),
    PE( RFCB, WriteMpx.MdlChain ),
    DE( RFCB, WriteMpx.NumberOfRuns ),
    0
};
/*
 * The members in a PAGED_RFCB
 */
MEMBERLIST ML_PAGED_RFCB[] = {
    UE( PAGED_RFCB, FcbOpenCount ),
    HE( PAGED_RFCB, IpxSmartCardContext ),
    PE( PAGED_RFCB, LfcbListEntry.Flink ),
    0
};

/*
 * The members in an RFCB for quick display
 */
MEMBERLIST ML_RFCB_QUICK[] = {
    ROOT( RFCB ),
    PE( RFCB, Connection ),
    HE( RFCB, GlobalRfcbListEntry.ResumeHandle ),
    0
};

/*
 * The members in a SESSION
 */
MEMBERLIST ML_SESSION[] = {
    ROOT( SESSION ),
    WE( SESSION, NtUserName ),
    WE( SESSION, NtUserDomain ),
    UE( SESSION, CurrentFileOpenCount ),
    UE( SESSION, CurrentSearchOpenCount ),
    HE( SESSION, UserHandle.dwUpper ),
    HE( SESSION, UserHandle.dwLower ),
    PE( SESSION, Connection ),
    PE( SESSION, GlobalSessionListEntry.ListEntry.Flink ),
    SE( SESSION, MaxBufferSize ),
    SE( SESSION, MaxMpxCount ),
    SE( SESSION, Uid ),
    BE( SESSION, UsingUppercasePaths ),
    BE( SESSION, GuestLogon ),
    BE( SESSION, EncryptedLogon ),
    BE( SESSION, LogoffAlertSent ),
    BE( SESSION, TwoMinuteWarningSent ),
    BE( SESSION, FiveMinuteWarningSent ),
    BE( SESSION, IsNullSession ),
    BE( SESSION, IsAdmin ),
    BE( SESSION, IsLSNotified ),
    PE( SESSION, hLicense ),
    BE( SESSION, LogonSequenceInProgress ),
    0
};

/*
 * The members in a TRANSACTION
 */
MEMBERLIST ML_TRANSACTION[] = {
    BT(),
    BS(),
    BC(),
    PE( TRANSACTION, NonpagedHeader ),
    PE( TRANSACTION, Connection ),
    PE( TRANSACTION, Session ),
    PE( TRANSACTION, TreeConnect ),
    UE( TRANSACTION, StartTime ),
    UE( TRANSACTION, Timeout ),
    UE( TRANSACTION, cMaxBufferSize ),
    PE( TRANSACTION, InSetup ),
    PE( TRANSACTION, OutSetup ),
    PE( TRANSACTION, InParameters ),
    PE( TRANSACTION, OutParameters ),
    PE( TRANSACTION, InData ),
    PE( TRANSACTION, OutData ),
    UE( TRANSACTION, SetupCount ),
    UE( TRANSACTION, MaxSetupCount ),
    UE( TRANSACTION, ParameterCount ),
    UE( TRANSACTION, TotalParameterCount ),
    UE( TRANSACTION, MaxParameterCount ),
    UE( TRANSACTION, DataCount ),
    UE( TRANSACTION, TotalDataCount ),
    UE( TRANSACTION, MaxDataCount ),
    SE( TRANSACTION, Category ),
    SE( TRANSACTION, Function ),
    BE( TRANSACTION, InputBufferCopied ),
    BE( TRANSACTION, OutputBufferCopied ),
    BE( TRANSACTION, OutDataAllocated ),
    SE( TRANSACTION, Flags ),
    SE( TRANSACTION, Tid ),
    SE( TRANSACTION, Pid ),
    SE( TRANSACTION, Uid ),
    SE( TRANSACTION, OtherInfo ),
    UE( TRANSACTION, FileHandle ),
    PE( TRANSACTION, FileObject ),
    UE( TRANSACTION, ParameterDisplacement ),
    UE( TRANSACTION, DataDisplacement ),
    BE( TRANSACTION, PipeRequest ),
    BE( TRANSACTION, RemoteApiRequest ),
    BE( TRANSACTION, Inserted ),
    BE( TRANSACTION, MultipieceIpxSend ),
    BE( TRANSACTION, Executing ),
    0
};

/*
 * The members in a WORK_CONTEXT
 */
MEMBERLIST ML_WORK_CONTEXT[] = {
    BT(),
    BS(),
    BC(),
    PE( WORK_CONTEXT, Endpoint ),
    PE( WORK_CONTEXT, Connection ),
    PE( WORK_CONTEXT, Rfcb ),
    PE( WORK_CONTEXT, Share ),
    PE( WORK_CONTEXT, Session ),
    PE( WORK_CONTEXT, TreeConnect ),
    PE( WORK_CONTEXT, Irp ),
    UE( WORK_CONTEXT, SpinLock ),
    PE( WORK_CONTEXT, RequestBuffer ),
    PE( WORK_CONTEXT, ResponseBuffer ),
    PE( WORK_CONTEXT, RequestHeader ),
    PE( WORK_CONTEXT, RequestParameters ),
    PE( WORK_CONTEXT, ResponseHeader ),
    PE( WORK_CONTEXT, ResponseParameters ),
    CE( WORK_CONTEXT, NextCommand ),
    UE( WORK_CONTEXT, ProcessingCount ),
    IE( WORK_CONTEXT, FsdRestartRoutine ),
    IE( WORK_CONTEXT, FspRestartRoutine ),
    LE( WORK_CONTEXT, InProgressListEntry, WORK_CONTEXT, InProgressListEntry ),
    UE( WORK_CONTEXT, PartOfInitialAllocation ),
//    BE( WORK_CONTEXT, BlockingOperation ),
//   BE( WORK_CONTEXT, UsingExtraSmbBuffer ),
//  BE( WORK_CONTEXT, OplockOpen ),
    PE( WORK_CONTEXT, ClientAddress ),
    PE( WORK_CONTEXT, WaitForOplockBreak ),
    UE( WORK_CONTEXT, BytesAvailable ),
    0
};

/*
 * The members in a BUFFER
 */
MEMBERLIST ML_BUFFER[] = {
    PE( BUFFER, Buffer ),
    UE( BUFFER, BufferLength ),
    PE( BUFFER, Mdl ),
    PE( BUFFER, PartialMdl ),
    UE( BUFFER, DataLength ),
    0
};

/*
 * The members in an ENDPOINT
 */
MEMBERLIST ML_ENDPOINT[] = {
    WE( ENDPOINT, NetworkName ),
    WE( ENDPOINT, TransportName ),
    AE( ENDPOINT, TransportAddress ),
    WE( ENDPOINT, ServerName ),
    WE( ENDPOINT, DomainName ),
    WE( ENDPOINT, NetworkAddress ),
    PE( ENDPOINT, EndpointHandle ),
    PE( ENDPOINT, FileObject ),
    PE( ENDPOINT, DeviceObject ),
    PE( ENDPOINT, IpxMaxPacketSizeArray ),
    UE( ENDPOINT, MaxAdapters ),
    HE( ENDPOINT, NameSocketHandle ),
    PE( ENDPOINT, NameSocketFileObject ),
    PE( ENDPOINT, NameSocketDeviceObject ),
    UE( ENDPOINT, FreeConnectionCount ),
    UE( ENDPOINT, TotalConnectionCount ),
    TE( ENDPOINT, ConnectionTable ),
    PE( ENDPOINT, FreeConnectionList ),
    0
};

/*
 * The members in a SEARCH
 */
MEMBERLIST ML_SEARCH[] = {
    WE( SEARCH, SearchName ),
    WE( SEARCH, LastFileNameReturned ),
    HE( SEARCH, DirectoryHandle ),
    PE( SEARCH, LastUseListEntry.Flink ),
    PE( SEARCH, HashTableEntry.Flink ),
    PE( SEARCH, Session ),
    PE( SEARCH, TreeConnect ),
//  UE( SEARCH, SearchStorageType ),
    PE( SEARCH, DirectoryCache ),
    SE( SEARCH, NumberOfCachedFiles ),
    SE( SEARCH, SearchAttributes ),
    SE( SEARCH, CoreSequence ),
    SE( SEARCH, TableIndex ),
    SE( SEARCH, HashTableIndex ),
    SE( SEARCH, Pid ),
    SE( SEARCH, Flags2 ),
    BE( SEARCH, Wildcards ),
    BE( SEARCH, InUse ),
    0
};

/*
 * The members in a CONNECTION
 */
MEMBERLIST ML_CONNECTION[] = {
    WE( CONNECTION, ClientOSType ),
    WE( CONNECTION, ClientLanManType ),
    IA( CONNECTION, ClientIPAddress ),
    UE( CONNECTION, SmbDialect ),
    UE( CONNECTION, SpinLock ),
    UE( CONNECTION, Interlock ),
    UE( CONNECTION, BalanceCount ),
    UE( CONNECTION, LastRequestTime ),
    UE( CONNECTION, Lock ),
    UE( CONNECTION, LicenseLock ),
    PE( CONNECTION, EndpointSpinLock ),
    PE( CONNECTION, CachedRfcb ),
    UE( CONNECTION, CachedFid ),
    BE( CONNECTION, BreakIIToNoneJustSent ),
    BE( CONNECTION, EnableRawIo ),
    UE( CONNECTION, Sid ),
    PE( CONNECTION, Endpoint ),
    DE( CONNECTION, MaximumSendSize ),
    PE( CONNECTION, NegotiateHandle ),
    PE( CONNECTION, FileObject ),
    PE( CONNECTION, DeviceObject ),
    PE( CONNECTION, InProgressWorkItemList.Flink ),
    UE( CONNECTION, LatestOplockBreakResponse ),
    UE( CONNECTION, OplockBreaksInProgress ),
    PE( CONNECTION, CurrentWorkQueue ),
    PE( CONNECTION, PreferredWorkQueue ),
    UE( CONNECTION, RawReadsInProgress ),
    BE( CONNECTION, OplocksAlwaysDisabled ),
    BE( CONNECTION, EnableOplocks ),
    PE( CONNECTION, EndpointFreeListEntry.Flink ),
    PE( CONNECTION, OplockWorkList ),
    UE( CONNECTION, CachedOpenCount ),
    LE( CONNECTION, CachedOpenList, RFCB, CachedOpenListEntry ),
    UE( CONNECTION, CachedDirectoryCount ),
    LE( CONNECTION, CachedDirectoryList, CACHED_DIRECTORY, ListEntry ),
    HE( CONNECTION, ClientCapabilities ),
    UE( CONNECTION, CachedTransactionCount ),
    BE( CONNECTION, OnNeedResourceQueue ),
    BE( CONNECTION, NotReusable ),
    BE( CONNECTION, DisconnectPending ),
    BE( CONNECTION, ReceivePending ),
    PE( CONNECTION, PagedConnection ),
    UE( CONNECTION, BytesAvailable ),
    0
};

MEMBERLIST ML_CONNECTION_IPX[] = {
    SE( CONNECTION, SequenceNumber ),
    SE( CONNECTION, LastResponseLength ),
    SE( CONNECTION, LastResponseBufferLength ),
    SE( CONNECTION, LastUid ),
    SE( CONNECTION, LastTid ),
    HE( CONNECTION, LastResponseStatus ),
    UE( CONNECTION, StartupTime ),
    PE( CONNECTION, LastResponse ),
    SE( CONNECTION, IpxAddress.Socket ),
    UE( CONNECTION, IpxDuplicateCount ),
    UE( CONNECTION, IpxDropDuplicateCount ),
    0
};

MEMBERLIST ML_CONNECTION_VC[] = {
    BE( CONNECTION, SmbSecuritySignatureActive ),
    UE( CONNECTION, SmbSecuritySignatureIndex ),
    BE( CONNECTION, NoResponseSignatureIndex ),
    0
};

/*
 * The members in a PAGED_CONNECTION
 */
MEMBERLIST ML_PAGED_CONNECTION[] = {
    WE( PAGED_CONNECTION, ClientMachineNameString ),
    BE( PAGED_CONNECTION, LoggedInvalidSmb ),
//  BE( PAGED_CONNECTION, ClientTooOld ),
    UE( PAGED_CONNECTION, ClientBuildNumber ),
    PE( PAGED_CONNECTION, TransactionList.Flink ),
    PE( PAGED_CONNECTION, CoreSearchList.Flink ),
    HE( PAGED_CONNECTION, ConnectionHandle ),
    SE( PAGED_CONNECTION, CurrentNumberOfSessions ),
    SE( PAGED_CONNECTION, CurrentNumberOfCoreSearches ),
    0
};

/*
 * The members in a TREE_CONNECT
 */
MEMBERLIST ML_TREE_CONNECT[] = {
    PE( TREE_CONNECT, Connection ),
    PE( TREE_CONNECT, Share ),
    WE( TREE_CONNECT, ServerName ),
    LE( TREE_CONNECT, GlobalTreeConnectListEntry.ListEntry, TREE_CONNECT, GlobalTreeConnectListEntry.ListEntry ),
    UE( TREE_CONNECT, CurrentFileOpenCount ),
    LE( TREE_CONNECT, ShareListEntry, SHARE, TreeConnectList ),
    PE( TREE_CONNECT, PrintFileList.Flink ),
    SE( TREE_CONNECT, Tid ),
    BE( TREE_CONNECT, RemapPipeNames ),
    0
};

/*
 * The members in a WORK_QUEUE
 */
MEMBERLIST ML_WORK_QUEUE[] = {
    UE( WORK_QUEUE, Queue.MaximumCount ),
    UE( WORK_QUEUE, Queue.CurrentCount ),
    UE( WORK_QUEUE, Queue.Header.SignalState ),
    UE( WORK_QUEUE, CurrentClients ),
    UE( WORK_QUEUE, AvgQueueDepthSum ),
    UE( WORK_QUEUE, Threads ),
    UE( WORK_QUEUE, AvailableThreads ),
    UE( WORK_QUEUE, MaxThreads ),
    UE( WORK_QUEUE, FreeWorkItems ),
    UE( WORK_QUEUE, AllocatedWorkItems ),
    UE( WORK_QUEUE, MaximumWorkItems ),
    UE( WORK_QUEUE, MinFreeWorkItems ),
    UE( WORK_QUEUE, NeedWorkItem ),
    UE( WORK_QUEUE, StolenWorkItems ),
    UE( WORK_QUEUE, FreeRawModeWorkItems ),
    UE( WORK_QUEUE, AllocatedRawModeWorkItems ),
    UE( WORK_QUEUE, PagedPoolLookAsideList.MaxSize ),
    UE( WORK_QUEUE, NonPagedPoolLookAsideList.MaxSize ),
    UE( WORK_QUEUE, PagedPoolLookAsideList.AllocHit ),
    UE( WORK_QUEUE, PagedPoolLookAsideList.AllocMiss ),
    UE( WORK_QUEUE, NonPagedPoolLookAsideList.AllocHit ),
    UE( WORK_QUEUE, NonPagedPoolLookAsideList.AllocMiss ),
    PE( WORK_QUEUE, CachedFreeRfcb ),
    UE( WORK_QUEUE, FreeRfcbs ),
    UE( WORK_QUEUE, MaxFreeRfcbs ),
    PE( WORK_QUEUE, CachedFreeMfcb ),
    UE( WORK_QUEUE, FreeMfcbs ),
    UE( WORK_QUEUE, MaxFreeMfcbs ),
    HE( WORK_QUEUE, SpinLock ),
    PE( WORK_QUEUE, IrpThread ),
    CE( WORK_QUEUE, CreateMoreWorkItems.BlockHeader.Type ),
    U64( WORK_QUEUE, IdleTimeOut ),
    U64( WORK_QUEUE, stats.BytesReceived ),
    U64( WORK_QUEUE, stats.BytesSent ),
    U64( WORK_QUEUE, stats.ReadOperations ),
    U64( WORK_QUEUE, stats.BytesRead ),
    U64( WORK_QUEUE, stats.WriteOperations ),
    U64( WORK_QUEUE, stats.BytesWritten ),
    U64( WORK_QUEUE, saved.ReadOperations ),
    U64( WORK_QUEUE, saved.BytesRead ),
    U64( WORK_QUEUE, saved.WriteOperations ),
    U64( WORK_QUEUE, saved.BytesWritten ),
    UE( WORK_QUEUE, stats.WorkItemsQueued.Count ),
    UE( WORK_QUEUE, stats.SystemTime ),
    0
};

/*
 * The members in a TABLE_HEADER
 */
MEMBERLIST ML_TABLE_HEADER[] = {
    SE( TABLE_HEADER, TableSize ),
    SE( TABLE_HEADER, FirstFreeEntry ),
    SE( TABLE_HEADER, LastFreeEntry ),
    BE( TABLE_HEADER, Nonpaged ),
    PE( TABLE_HEADER, Table ),
    0
};

/*
 * The members in a TABLE_ENTRY
 */
MEMBERLIST ML_TABLE_ENTRY[] = {
    PE( TABLE_ENTRY, Owner ),
//  SE( TABLE_ENTRY, SequenceNumber ),
//  SE( TABLE_ENTRY, NextFreeEntry ),
    0
};

/*
 * The members in a SHARE
 */
MEMBERLIST ML_SHARE[] = {
    WE( SHARE, ShareName ),
    WE( SHARE, NtPathName ),
    WE( SHARE, DosPathName ),
    WE( SHARE, Remark ),
    UE( SHARE, MaxUses ),
    UE( SHARE, CurrentUses ),
    HE( SHARE, RootDirectoryHandle ),
    UE( SHARE, CurrentRootHandleReferences ),
    DE( SHARE, QueryNamePrefixLength ),
    PE( SHARE, SecurityDescriptor ),
    PE( SHARE, FileSecurityDescriptor ),
    BE( SHARE, PotentialSystemFile ),
    BE( SHARE, Removable ),
    BE( SHARE, SpecialShare ),
    BE( SHARE, IsDfs ),
    BE( SHARE, IsDfsRoot ),
    HE( SHARE, CSCState ),
    LE( SHARE, TreeConnectList, TREE_CONNECT, ShareListEntry ),
    0
};

/*
 * Forward References...
 */
BOOL DumpTable( IN PTABLE_HEADER pt );

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
PrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING puStr, IN BOOL nl )
{
    PWCHAR    StringData;
    ULONG BytesRead;

    if( ARGUMENT_PRESENT(msg) )
        dprintf( msg );

    if( puStr->Length == 0 ) {
        dprintf( "<Length == 0>" );
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    if( puStr->Buffer == NULL ) {
        dprintf( "<Buffer == 0>" );
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        StringData[ puStr->Length / sizeof( WCHAR ) ] = '\0';
        dprintf("%ws%s", StringData, nl ? "\n" : "" );
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG_PTR) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = MIN( size, 3000 );

        b = ReadMemory( dwAddress, ptr, count, &BytesRead );

        if 