ectChanged )( 
            INotifyUI * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        END_INTERFACE
    } INotifyUIVtbl;

    interface INotifyUI
    {
        CONST_VTBL struct INotifyUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotifyUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotifyUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotifyUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INotifyUI_ObjectChanged(This,cookieIn)	\
    (This)->lpVtbl -> ObjectChanged(This,cookieIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INotifyUI_ObjectChanged_Proxy( 
    INotifyUI * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB INotifyUI_ObjectChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INotifyUI_INTERFACE_DEFINED__ */


#ifndef __IDoTask_INTERFACE_DEFINED__
#define __IDoTask_INTERFACE_DEFINED__

/* interface IDoTask */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDoTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0230C9F8-EE7F-4307-98DB-726EBCAE55D6")
    IDoTask : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginTask( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopTask( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDoTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDoTask * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDoTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDoTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            IDoTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            IDoTask * This);
        
        END_INTERFACE
    } IDoTaskVtbl;

    interface IDoTask
    {
        CONST_VTBL struct IDoTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDoTask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDoTask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDoTask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDoTask_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define IDoTask_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDoTask_BeginTask_Proxy( 
    IDoTask * This);


void __RPC_STUB IDoTask_BeginTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDoTask_StopTask_Proxy( 
    IDoTask * This);


void __RPC_STUB IDoTask_StopTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDoTask_INTERFACE_DEFINED__ */


#ifndef __INotificationManager_INTERFACE_DEFINED__
#define __INotificationManager_INTERFACE_DEFINED__

/* interface INotificationManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INotificationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95531501-8782-4845-901D-312F36BA6C6E")
    INotificationManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddConnectionPoint( 
            /* [in] */ REFIID riidIn,
            /* [in] */ IConnectionPoint *pcpIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INotificationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INotificationManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INotificationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INotificationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddConnectionPoint )( 
            INotificationManager * This,
            /* [in] */ REFIID riidIn,
            /* [in] */ IConnectionPoint *pcpIn);
        
        END_INTERFACE
    } INotificationManagerVtbl;

    interface INotificationManager
    {
        CONST_VTBL struct INotificationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotificationManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotificationManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotificationManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INotificationManager_AddConnectionPoint(This,riidIn,pcpIn)	\
    (This)->lpVtbl -> AddConnectionPoint(This,riidIn,pcpIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INotificationManager_AddConnectionPoint_Proxy( 
    INotificationManager * This,
    /* [in] */ REFIID riidIn,
    /* [in] */ IConnectionPoint *pcpIn);


void __RPC_STUB INotificationManager_AddConnectionPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INotificationManager_INTERFACE_DEFINED__ */


#ifndef __IConnectionManager_INTERFACE_DEFINED__
#define __IConnectionManager_INTERFACE_DEFINED__

/* interface IConnectionManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConnectionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0017768-1BF3-4352-8D6C-3A8C1D0FB477")
    IConnectionManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionToObject( 
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [out] */ IUnknown **ppunkOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConnectionManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConnectionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConnectionManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionToObject )( 
            IConnectionManager * This,
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [out] */ IUnknown **ppunkOut);
        
        END_INTERFACE
    } IConnectionManagerVtbl;

    interface IConnectionManager
    {
        CONST_VTBL struct IConnectionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnectionManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConnectionManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConnectionManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConnectionManager_GetConnectionToObject(This,cookieIn,ppunkOut)	\
    (This)->lpVtbl -> GetConnectionToObject(This,cookieIn,ppunkOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConnectionManager_GetConnectionToObject_Proxy( 
    IConnectionManager * This,
    /* [in] */ OBJECTCOOKIE cookieIn,
    /* [out] */ IUnknown **ppunkOut);


void __RPC_STUB IConnectionManager_GetConnectionToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConnectionManager_INTERFACE_DEFINED__ */


#ifndef __ITaskManager_INTERFACE_DEFINED__
#define __ITaskManager_INTERFACE_DEFINED__

/* interface ITaskManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16116694-DFC5-470b-AC12-46FBB01CEF10")
    ITaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateTask( 
            /* [in] */ REFIID clsidIn,
            /* [out] */ IUnknown **ppunkOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubmitTask( 
            /* [in] */ IDoTask *pTask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTask )( 
            ITaskManager * This,
            /* [in] */ REFIID clsidIn,
            /* [out] */ IUnknown **ppunkOut);
        
        HRESULT ( STDMETHODCALLTYPE *SubmitTask )( 
            ITaskManager * This,
            /* [in] */ IDoTask *pTask);
        
        END_INTERFACE
    } ITaskManagerVtbl;

    interface ITaskManager
    {
        CONST_VTBL struct ITaskManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskManager_CreateTask(This,clsidIn,ppunkOut)	\
    (This)->lpVtbl -> CreateTask(This,clsidIn,ppunkOut)

#define ITaskManager_SubmitTask(This,pTask)	\
    (This)->lpVtbl -> SubmitTask(This,pTask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskManager_CreateTask_Proxy( 
    ITaskManager * This,
    /* [in] */ REFIID clsidIn,
    /* [out] */ IUnknown **ppunkOut);


void __RPC_STUB ITaskManager_CreateTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskManager_SubmitTask_Proxy( 
    ITaskManager * This,
    /* [in] */ IDoTask *pTask);


void __RPC_STUB ITaskManager_SubmitTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskManager_INTERFACE_DEFINED__ */


#ifndef __IObjectManager_INTERFACE_DEFINED__
#define __IObjectManager_INTERFACE_DEFINED__

/* interface IObjectManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D51351DF-6394-4236-9783-65ED05631068")
    IObjectManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindObject( 
            /* [in] */ REFCLSID rclsidTypeIn,
            /* [in] */ OBJECTCOOKIE cookieClusterIn,
            /* [unique][in] */ LPCWSTR pcszNameIn,
            /* [in] */ REFCLSID rclsidFormatIn,
            /* [out] */ OBJECTCOOKIE *pcookieOut,
            /* [out] */ LPUNKNOWN *ppunkOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ REFCLSID rclsidFormatIn,
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [out] */ LPUNKNOWN *ppunkOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObject( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectStatus( 
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [in] */ HRESULT hrIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindObject )( 
            IObjectManager * This,
            /* [in] */ REFCLSID rclsidTypeIn,
            /* [in] */ OBJECTCOOKIE cookieClusterIn,
            /* [unique][in] */ LPCWSTR pcszNameIn,
            /* [in] */ REFCLSID rclsidFormatIn,
            /* [out] */ OBJECTCOOKIE *pcookieOut,
            /* [out] */ LPUNKNOWN *ppunkOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IObjectManager * This,
            /* [in] */ REFCLSID rclsidFormatIn,
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [out] */ LPUNKNOWN *ppunkOut);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObject )( 
            IObjectManager * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectStatus )( 
            IObjectManager * This,
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [in] */ HRESULT hrIn);
        
        END_INTERFACE
    } IObjectManagerVtbl;

    interface IObjectManager
    {
        CONST_VTBL struct IObjectManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectManager_FindObject(This,rclsidTypeIn,cookieClusterIn,pcszNameIn,rclsidFormatIn,pcookieOut,ppunkOut)	\
    (This)->lpVtbl -> FindObject(This,rclsidTypeIn,cookieClusterIn,pcszNameIn,rclsidFormatIn,pcookieOut,ppunkOut)

#define IObjectManager_GetObject(This,rclsidFormatIn,cookieIn,ppunkOut)	\
    (This)->lpVtbl -> GetObject(This,rclsidFormatIn,cookieIn,ppunkOut)

#define IObjectManager_RemoveObject(This,cookieIn)	\
    (This)->lpVtbl -> RemoveObject(This,cookieIn)

#define IObjectManager_SetObjectStatus(This,cookieIn,hrIn)	\
    (This)->lpVtbl -> SetObjectStatus(This,cookieIn,hrIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectManager_FindObject_Proxy( 
    IObjectManager * This,
    /* [in] */ REFCLSID rclsidTypeIn,
    /* [in] */ OBJECTCOOKIE cookieClusterIn,
    /* [unique][in] */ LPCWSTR pcszNameIn,
    /* [in] */ REFCLSID rclsidFormatIn,
    /* [out] */ OBJECTCOOKIE *pcookieOut,
    /* [out] */ LPUNKNOWN *ppunkOut);


void __RPC_STUB IObjectManager_FindObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectManager_GetObject_Proxy( 
    IObjectManager * This,
    /* [in] */ REFCLSID rclsidFormatIn,
    /* [in] */ OBJECTCOOKIE cookieIn,
    /* [out] */ LPUNKNOWN *ppunkOut);


void __RPC_STUB IObjectManager_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectManager_RemoveObject_Proxy( 
    IObjectManager * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB IObjectManager_RemoveObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectManager_SetObjectStatus_Proxy( 
    IObjectManager * This,
    /* [in] */ OBJECTCOOKIE cookieIn,
    /* [in] */ HRESULT hrIn);


void __RPC_STUB IObjectManager_SetObjectStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectManager_INTERFACE_DEFINED__ */


#ifndef __ITaskLoginDomain_INTERFACE_DEFINED__
#define __ITaskLoginDomain_INTERFACE_DEFINED__

/* interface ITaskLoginDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskLoginDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76AD8E51-53C3-4347-895D-6C30F4139374")
    ITaskLoginDomain : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ ITaskLoginDomainCallback *punkIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDomain( 
            /* [unique][in] */ LPCWSTR pcszDomainIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskLoginDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskLoginDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskLoginDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskLoginDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskLoginDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskLoginDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            ITaskLoginDomain * This,
            /* [in] */ ITaskLoginDomainCallback *punkIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetDomain )( 
            ITaskLoginDomain * This,
            /* [unique][in] */ LPCWSTR pcszDomainIn);
        
        END_INTERFACE
    } ITaskLoginDomainVtbl;

    interface ITaskLoginDomain
    {
        CONST_VTBL struct ITaskLoginDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskLoginDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskLoginDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskLoginDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskLoginDomain_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskLoginDomain_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskLoginDomain_SetCallback(This,punkIn)	\
    (This)->lpVtbl -> SetCallback(This,punkIn)

#define ITaskLoginDomain_SetDomain(This,pcszDomainIn)	\
    (This)->lpVtbl -> SetDomain(This,pcszDomainIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskLoginDomain_SetCallback_Proxy( 
    ITaskLoginDomain * This,
    /* [in] */ ITaskLoginDomainCallback *punkIn);


void __RPC_STUB ITaskLoginDomain_SetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskLoginDomain_SetDomain_Proxy( 
    ITaskLoginDomain * This,
    /* [unique][in] */ LPCWSTR pcszDomainIn);


void __RPC_STUB ITaskLoginDomain_SetDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskLoginDomain_INTERFACE_DEFINED__ */


#ifndef __ITaskLoginDomainCallback_INTERFACE_DEFINED__
#define __ITaskLoginDomainCallback_INTERFACE_DEFINED__

/* interface ITaskLoginDomainCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskLoginDomainCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EFAF3C43-7A8F-469b-B8BB-C80C5747CE05")
    ITaskLoginDomainCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReceiveLoginResult( 
            /* [in] */ HRESULT hrIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskLoginDomainCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskLoginDomainCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskLoginDomainCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskLoginDomainCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveLoginResult )( 
            ITaskLoginDomainCallback * This,
            /* [in] */ HRESULT hrIn);
        
        END_INTERFACE
    } ITaskLoginDomainCallbackVtbl;

    interface ITaskLoginDomainCallback
    {
        CONST_VTBL struct ITaskLoginDomainCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskLoginDomainCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskLoginDomainCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskLoginDomainCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskLoginDomainCallback_ReceiveLoginResult(This,hrIn)	\
    (This)->lpVtbl -> ReceiveLoginResult(This,hrIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskLoginDomainCallback_ReceiveLoginResult_Proxy( 
    ITaskLoginDomainCallback * This,
    /* [in] */ HRESULT hrIn);


void __RPC_STUB ITaskLoginDomainCallback_ReceiveLoginResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskLoginDomainCallback_INTERFACE_DEFINED__ */


#ifndef __ITaskGetDomains_INTERFACE_DEFINED__
#define __ITaskGetDomains_INTERFACE_DEFINED__

/* interface ITaskGetDomains */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskGetDomains;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DFCB4ACD-C4DB-4db4-8EBB-1DD07A9D5B82")
    ITaskGetDomains : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ ITaskGetDomainsCallback *pResultsCallbackIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskGetDomainsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskGetDomains * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskGetDomains * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskGetDomains * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskGetDomains * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskGetDomains * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            ITaskGetDomains * This,
            /* [in] */ ITaskGetDomainsCallback *pResultsCallbackIn);
        
        END_INTERFACE
    } ITaskGetDomainsVtbl;

    interface ITaskGetDomains
    {
        CONST_VTBL struct ITaskGetDomainsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskGetDomains_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskGetDomains_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskGetDomains_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskGetDomains_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskGetDomains_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskGetDomains_SetCallback(This,pResultsCallbackIn)	\
    (This)->lpVtbl -> SetCallback(This,pResultsCallbackIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskGetDomains_SetCallback_Proxy( 
    ITaskGetDomains * This,
    /* [in] */ ITaskGetDomainsCallback *pResultsCallbackIn);


void __RPC_STUB ITaskGetDomains_SetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskGetDomains_INTERFACE_DEFINED__ */


#ifndef __ITaskGetDomainsCallback_INTERFACE_DEFINED__
#define __ITaskGetDomainsCallback_INTERFACE_DEFINED__

/* interface ITaskGetDomainsCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskGetDomainsCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85402E44-6834-41df-8590-01827D124E1B")
    ITaskGetDomainsCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReceiveDomainResult( 
            /* [in] */ HRESULT hrIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveDomainName( 
            /* [unique][in] */ LPCWSTR pcszDomainIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskGetDomainsCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskGetDomainsCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskGetDomainsCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskGetDomainsCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveDomainResult )( 
            ITaskGetDomainsCallback * This,
            /* [in] */ HRESULT hrIn);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveDomainName )( 
            ITaskGetDomainsCallback * This,
            /* [unique][in] */ LPCWSTR pcszDomainIn);
        
        END_INTERFACE
    } ITaskGetDomainsCallbackVtbl;

    interface ITaskGetDomainsCallback
    {
        CONST_VTBL struct ITaskGetDomainsCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskGetDomainsCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskGetDomainsCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskGetDomainsCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskGetDomainsCallback_ReceiveDomainResult(This,hrIn)	\
    (This)->lpVtbl -> ReceiveDomainResult(This,hrIn)

#define ITaskGetDomainsCallback_ReceiveDomainName(This,pcszDomainIn)	\
    (This)->lpVtbl -> ReceiveDomainName(This,pcszDomainIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskGetDomainsCallback_ReceiveDomainResult_Proxy( 
    ITaskGetDomainsCallback * This,
    /* [in] */ HRESULT hrIn);


void __RPC_STUB ITaskGetDomainsCallback_ReceiveDomainResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskGetDomainsCallback_ReceiveDomainName_Proxy( 
    ITaskGetDomainsCallback * This,
    /* [unique][in] */ LPCWSTR pcszDomainIn);


void __RPC_STUB ITaskGetDomainsCallback_ReceiveDomainName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskGetDomainsCallback_INTERFACE_DEFINED__ */


#ifndef __ITaskAnalyzeCluster_INTERFACE_DEFINED__
#define __ITaskAnalyzeCluster_INTERFACE_DEFINED__

/* interface ITaskAnalyzeCluster */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskAnalyzeCluster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("795737A1-E13A-45eb-8DFD-8185C4B7AD4E")
    ITaskAnalyzeCluster : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJoiningMode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClusterCookie( 
            /* [in] */ OBJECTCOOKIE cookieClusterIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskAnalyzeClusterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskAnalyzeCluster * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskAnalyzeCluster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskAnalyzeCluster * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskAnalyzeCluster * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskAnalyzeCluster * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJoiningMode )( 
            ITaskAnalyzeCluster * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookie )( 
            ITaskAnalyzeCluster * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetClusterCookie )( 
            ITaskAnalyzeCluster * This,
            /* [in] */ OBJECTCOOKIE cookieClusterIn);
        
        END_INTERFACE
    } ITaskAnalyzeClusterVtbl;

    interface ITaskAnalyzeCluster
    {
        CONST_VTBL struct ITaskAnalyzeClusterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskAnalyzeCluster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskAnalyzeCluster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskAnalyzeCluster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskAnalyzeCluster_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskAnalyzeCluster_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskAnalyzeCluster_SetJoiningMode(This)	\
    (This)->lpVtbl -> SetJoiningMode(This)

#define ITaskAnalyzeCluster_SetCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCookie(This,cookieIn)

#define ITaskAnalyzeCluster_SetClusterCookie(This,cookieClusterIn)	\
    (This)->lpVtbl -> SetClusterCookie(This,cookieClusterIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskAnalyzeCluster_SetJoiningMode_Proxy( 
    ITaskAnalyzeCluster * This);


void __RPC_STUB ITaskAnalyzeCluster_SetJoiningMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskAnalyzeCluster_SetCookie_Proxy( 
    ITaskAnalyzeCluster * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskAnalyzeCluster_SetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskAnalyzeCluster_SetClusterCookie_Proxy( 
    ITaskAnalyzeCluster * This,
    /* [in] */ OBJECTCOOKIE cookieClusterIn);


void __RPC_STUB ITaskAnalyzeCluster_SetClusterCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskAnalyzeCluster_INTERFACE_DEFINED__ */


#ifndef __ITaskCommitClusterChanges_INTERFACE_DEFINED__
#define __ITaskCommitClusterChanges_INTERFACE_DEFINED__

/* interface ITaskCommitClusterChanges */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskCommitClusterChanges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BF12DDE-F8B0-49b1-A458-6747DB788A47")
    ITaskCommitClusterChanges : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClusterCookie( 
            /* [in] */ OBJECTCOOKIE cookieClusterIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJoining( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskCommitClusterChangesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskCommitClusterChanges * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskCommitClusterChanges * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskCommitClusterChanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskCommitClusterChanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskCommitClusterChanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookie )( 
            ITaskCommitClusterChanges * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetClusterCookie )( 
            ITaskCommitClusterChanges * This,
            /* [in] */ OBJECTCOOKIE cookieClusterIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetJoining )( 
            ITaskCommitClusterChanges * This);
        
        END_INTERFACE
    } ITaskCommitClusterChangesVtbl;

    interface ITaskCommitClusterChanges
    {
        CONST_VTBL struct ITaskCommitClusterChangesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskCommitClusterChanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskCommitClusterChanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskCommitClusterChanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskCommitClusterChanges_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskCommitClusterChanges_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskCommitClusterChanges_SetCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCookie(This,cookieIn)

#define ITaskCommitClusterChanges_SetClusterCookie(This,cookieClusterIn)	\
    (This)->lpVtbl -> SetClusterCookie(This,cookieClusterIn)

#define ITaskCommitClusterChanges_SetJoining(This)	\
    (This)->lpVtbl -> SetJoining(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskCommitClusterChanges_SetCookie_Proxy( 
    ITaskCommitClusterChanges * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskCommitClusterChanges_SetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskCommitClusterChanges_SetClusterCookie_Proxy( 
    ITaskCommitClusterChanges * This,
    /* [in] */ OBJECTCOOKIE cookieClusterIn);


void __RPC_STUB ITaskCommitClusterChanges_SetClusterCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskCommitClusterChanges_SetJoining_Proxy( 
    ITaskCommitClusterChanges * This);


void __RPC_STUB ITaskCommitClusterChanges_SetJoining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskCommitClusterChanges_INTERFACE_DEFINED__ */


#ifndef __IStandardInfo_INTERFACE_DEFINED__
#define __IStandardInfo_INTERFACE_DEFINED__

/* interface IStandardInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStandardInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1D9C1A5-9589-40dd-B63D-9BB0B38A1022")
    IStandardInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ CLSID *pclsidTypeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrNameOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [unique][in] */ LPCWSTR pcszNameIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ OBJECTCOOKIE *pcookieOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ HRESULT *phrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ HRESULT hrIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStandardInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStandardInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStandardInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStandardInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IStandardInfo * This,
            /* [out] */ CLSID *pclsidTypeOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IStandardInfo * This,
            /* [out] */ BSTR *pbstrNameOut);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IStandardInfo * This,
            /* [unique][in] */ LPCWSTR pcszNameIn);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IStandardInfo * This,
            /* [out] */ OBJECTCOOKIE *pcookieOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IStandardInfo * This,
            /* [out] */ HRESULT *phrOut);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IStandardInfo * This,
            /* [in] */ HRESULT hrIn);
        
        END_INTERFACE
    } IStandardInfoVtbl;

    interface IStandardInfo
    {
        CONST_VTBL struct IStandardInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStandardInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStandardInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStandardInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStandardInfo_GetType(This,pclsidTypeOut)	\
    (This)->lpVtbl -> GetType(This,pclsidTypeOut)

#define IStandardInfo_GetName(This,pbstrNameOut)	\
    (This)->lpVtbl -> GetName(This,pbstrNameOut)

#define IStandardInfo_SetName(This,pcszNameIn)	\
    (This)->lpVtbl -> SetName(This,pcszNameIn)

#define IStandardInfo_GetParent(This,pcookieOut)	\
    (This)->lpVtbl -> GetParent(This,pcookieOut)

#define IStandardInfo_GetStatus(This,phrOut)	\
    (This)->lpVtbl -> GetStatus(This,phrOut)

#define IStandardInfo_SetStatus(This,hrIn)	\
    (This)->lpVtbl -> SetStatus(This,hrIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStandardInfo_GetType_Proxy( 
    IStandardInfo * This,
    /* [out] */ CLSID *pclsidTypeOut);


void __RPC_STUB IStandardInfo_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStandardInfo_GetName_Proxy( 
    IStandardInfo * This,
    /* [out] */ BSTR *pbstrNameOut);


void __RPC_STUB IStandardInfo_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStandardInfo_SetName_Proxy( 
    IStandardInfo * This,
    /* [unique][in] */ LPCWSTR pcszNameIn);


void __RPC_STUB IStandardInfo_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStandardInfo_GetParent_Proxy( 
    IStandardInfo * This,
    /* [out] */ OBJECTCOOKIE *pcookieOut);


void __RPC_STUB IStandardInfo_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStandardInfo_GetStatus_Proxy( 
    IStandardInfo * This,
    /* [out] */ HRESULT *phrOut);


void __RPC_STUB IStandardInfo_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStandardInfo_SetStatus_Proxy( 
    IStandardInfo * This,
    /* [in] */ HRESULT hrIn);


void __RPC_STUB IStandardInfo_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStandardInfo_INTERFACE_DEFINED__ */


#ifndef __ITaskVerifyIPAddress_INTERFACE_DEFINED__
#define __ITaskVerifyIPAddress_INTERFACE_DEFINED__

/* interface ITaskVerifyIPAddress */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskVerifyIPAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c95e1b1-0cff-4740-8abd-69912d105bd1")
    ITaskVerifyIPAddress : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIPAddress( 
            /* [in] */ DWORD dwIPAddressIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskVerifyIPAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskVerifyIPAddress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskVerifyIPAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskVerifyIPAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskVerifyIPAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskVerifyIPAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPAddress )( 
            ITaskVerifyIPAddress * This,
            /* [in] */ DWORD dwIPAddressIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookie )( 
            ITaskVerifyIPAddress * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        END_INTERFACE
    } ITaskVerifyIPAddressVtbl;

    interface ITaskVerifyIPAddress
    {
        CONST_VTBL struct ITaskVerifyIPAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskVerifyIPAddress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskVerifyIPAddress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskVerifyIPAddress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskVerifyIPAddress_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskVerifyIPAddress_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskVerifyIPAddress_SetIPAddress(This,dwIPAddressIn)	\
    (This)->lpVtbl -> SetIPAddress(This,dwIPAddressIn)

#define ITaskVerifyIPAddress_SetCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCookie(This,cookieIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskVerifyIPAddress_SetIPAddress_Proxy( 
    ITaskVerifyIPAddress * This,
    /* [in] */ DWORD dwIPAddressIn);


void __RPC_STUB ITaskVerifyIPAddress_SetIPAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskVerifyIPAddress_SetCookie_Proxy( 
    ITaskVerifyIPAddress * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskVerifyIPAddress_SetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskVerifyIPAddress_INTERFACE_DEFINED__ */


#ifndef __IConfigurationConnection_INTERFACE_DEFINED__
#define __IConfigurationConnection_INTERFACE_DEFINED__

/* interface IConfigurationConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigurationConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDAD8191-66C5-4a30-A4DF-CB6C216704CA")
    IConfigurationConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectTo( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectToObject( 
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [in] */ REFIID riidIn,
            /* [in] */ LPUNKNOWN *ppunkOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigurationConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigurationConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigurationConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigurationConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectTo )( 
            IConfigurationConnection * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectToObject )( 
            IConfigurationConnection * This,
            /* [in] */ OBJECTCOOKIE cookieIn,
            /* [in] */ REFIID riidIn,
            /* [in] */ LPUNKNOWN *ppunkOut);
        
        END_INTERFACE
    } IConfigurationConnectionVtbl;

    interface IConfigurationConnection
    {
        CONST_VTBL struct IConfigurationConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigurationConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConfigurationConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConfigurationConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConfigurationConnection_ConnectTo(This,cookieIn)	\
    (This)->lpVtbl -> ConnectTo(This,cookieIn)

#define IConfigurationConnection_ConnectToObject(This,cookieIn,riidIn,ppunkOut)	\
    (This)->lpVtbl -> ConnectToObject(This,cookieIn,riidIn,ppunkOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigurationConnection_ConnectTo_Proxy( 
    IConfigurationConnection * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB IConfigurationConnection_ConnectTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigurationConnection_ConnectToObject_Proxy( 
    IConfigurationConnection * This,
    /* [in] */ OBJECTCOOKIE cookieIn,
    /* [in] */ REFIID riidIn,
    /* [in] */ LPUNKNOWN *ppunkOut);


void __RPC_STUB IConfigurationConnection_ConnectToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigurationConnection_INTERFACE_DEFINED__ */


#ifndef __IConnectionInfo_INTERFACE_DEFINED__
#define __IConnectionInfo_INTERFACE_DEFINED__

/* interface IConnectionInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConnectionInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15182CE3-82D7-473f-92DE-706E2BCEA902")
    IConnectionInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [out] */ IConfigurationConnection **pccOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnection( 
            /* [in] */ IConfigurationConnection *pccIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ OBJECTCOOKIE *pcookieOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectionInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConnectionInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConnectionInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConnectionInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IConnectionInfo * This,
            /* [out] */ IConfigurationConnection **pccOut);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnection )( 
            IConnectionInfo * This,
            /* [in] */ IConfigurationConnection *pccIn);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IConnectionInfo * This,
            /* [out] */ OBJECTCOOKIE *pcookieOut);
        
        END_INTERFACE
    } IConnectionInfoVtbl;

    interface IConnectionInfo
    {
        CONST_VTBL struct IConnectionInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnectionInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConnectionInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConnectionInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConnectionInfo_GetConnection(This,pccOut)	\
    (This)->lpVtbl -> GetConnection(This,pccOut)

#define IConnectionInfo_SetConnection(This,pccIn)	\
    (This)->lpVtbl -> SetConnection(This,pccIn)

#define IConnectionInfo_GetParent(This,pcookieOut)	\
    (This)->lpVtbl -> GetParent(This,pcookieOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConnectionInfo_GetConnection_Proxy( 
    IConnectionInfo * This,
    /* [out] */ IConfigurationConnection **pccOut);


void __RPC_STUB IConnectionInfo_GetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConnectionInfo_SetConnection_Proxy( 
    IConnectionInfo * This,
    /* [in] */ IConfigurationConnection *pccIn);


void __RPC_STUB IConnectionInfo_SetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConnectionInfo_GetParent_Proxy( 
    IConnectionInfo * This,
    /* [out] */ OBJECTCOOKIE *pcookieOut);


void __RPC_STUB IConnectionInfo_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConnectionInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumCookies_INTERFACE_DEFINED__
#define __IEnumCookies_INTERFACE_DEFINED__

/* interface IEnumCookies */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumCookies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5E3E482E-3C22-482c-B664-693051AD0A5D")
    IEnumCookies : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celtIn,
            /* [length_is][size_is][out] */ OBJECTCOOKIE *rgcookieOut,
            /* [out] */ ULONG *pceltFetchedOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celtIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCookies **ppenumOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [ref][out] */ DWORD *pnCountOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCookiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCookies * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCookies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCookies * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCookies * This,
            /* [in] */ ULONG celtIn,
            /* [length_is][size_is][out] */ OBJECTCOOKIE *rgcookieOut,
            /* [out] */ ULONG *pceltFetchedOut);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCookies * This,
            /* [in] */ ULONG celtIn);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCookies * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCookies * This,
            /* [out] */ IEnumCookies **ppenumOut);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IEnumCookies * This,
            /* [ref][out] */ DWORD *pnCountOut);
        
        END_INTERFACE
    } IEnumCookiesVtbl;

    interface IEnumCookies
    {
        CONST_VTBL struct IEnumCookiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCookies_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCookies_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCookies_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCookies_Next(This,celtIn,rgcookieOut,pceltFetchedOut)	\
    (This)->lpVtbl -> Next(This,celtIn,rgcookieOut,pceltFetchedOut)

#define IEnumCookies_Skip(This,celtIn)	\
    (This)->lpVtbl -> Skip(This,celtIn)

#define IEnumCookies_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCookies_Clone(This,ppenumOut)	\
    (This)->lpVtbl -> Clone(This,ppenumOut)

#define IEnumCookies_Count(This,pnCountOut)	\
    (This)->lpVtbl -> Count(This,pnCountOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCookies_Next_Proxy( 
    IEnumCookies * This,
    /* [in] */ ULONG celtIn,
    /* [length_is][size_is][out] */ OBJECTCOOKIE *rgcookieOut,
    /* [out] */ ULONG *pceltFetchedOut);


void __RPC_STUB IEnumCookies_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCookies_Skip_Proxy( 
    IEnumCookies * This,
    /* [in] */ ULONG celtIn);


void __RPC_STUB IEnumCookies_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCookies_Reset_Proxy( 
    IEnumCookies * This);


void __RPC_STUB IEnumCookies_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCookies_Clone_Proxy( 
    IEnumCookies * This,
    /* [out] */ IEnumCookies **ppenumOut);


void __RPC_STUB IEnumCookies_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCookies_Count_Proxy( 
    IEnumCookies * This,
    /* [ref][out] */ DWORD *pnCountOut);


void __RPC_STUB IEnumCookies_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCookies_INTERFACE_DEFINED__ */


#ifndef __IEnumNodes_INTERFACE_DEFINED__
#define __IEnumNodes_INTERFACE_DEFINED__

/* interface IEnumNodes */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNodes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C477E363-AF0A-4203-A604-45CD607DD710")
    IEnumNodes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celtIn,
            /* [length_is][size_is][out] */ IClusCfgNodeInfo **rgccniOut,
            /* [out] */ ULONG *pceltFetchedOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celtIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNodes **ppenumOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [ref][out] */ DWORD *pnCountOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumNodes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumNodes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumNodes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumNodes * This,
            /* [in] */ ULONG celtIn,
            /* [length_is][size_is][out] */ IClusCfgNodeInfo **rgccniOut,
            /* [out] */ ULONG *pceltFetchedOut);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumNodes * This,
            /* [in] */ ULONG celtIn);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumNodes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumNodes * This,
            /* [out] */ IEnumNodes **ppenumOut);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IEnumNodes * This,
            /* [ref][out] */ DWORD *pnCountOut);
        
        END_INTERFACE
    } IEnumNodesVtbl;

    interface IEnumNodes
    {
        CONST_VTBL struct IEnumNodesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNodes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNodes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNodes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNodes_Next(This,celtIn,rgccniOut,pceltFetchedOut)	\
    (This)->lpVtbl -> Next(This,celtIn,rgccniOut,pceltFetchedOut)

#define IEnumNodes_Skip(This,celtIn)	\
    (This)->lpVtbl -> Skip(This,celtIn)

#define IEnumNodes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNodes_Clone(This,ppenumOut)	\
    (This)->lpVtbl -> Clone(This,ppenumOut)

#define IEnumNodes_Count(This,pnCountOut)	\
    (This)->lpVtbl -> Count(This,pnCountOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNodes_Next_Proxy( 
    IEnumNodes * This,
    /* [in] */ ULONG celtIn,
    /* [length_is][size_is][out] */ IClusCfgNodeInfo **rgccniOut,
    /* [out] */ ULONG *pceltFetchedOut);


void __RPC_STUB IEnumNodes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodes_Skip_Proxy( 
    IEnumNodes * This,
    /* [in] */ ULONG celtIn);


void __RPC_STUB IEnumNodes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodes_Reset_Proxy( 
    IEnumNodes * This);


void __RPC_STUB IEnumNodes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodes_Clone_Proxy( 
    IEnumNodes * This,
    /* [out] */ IEnumNodes **ppenumOut);


void __RPC_STUB IEnumNodes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodes_Count_Proxy( 
    IEnumNodes * This,
    /* [ref][out] */ DWORD *pnCountOut);


void __RPC_STUB IEnumNodes_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNodes_INTERFACE_DEFINED__ */


#ifndef __ITaskGatherClusterInfo_INTERFACE_DEFINED__
#define __ITaskGatherClusterInfo_INTERFACE_DEFINED__

/* interface ITaskGatherClusterInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskGatherClusterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E167965C-C5D6-493c-A343-4C105C01DDE7")
    ITaskGatherClusterInfo : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompletionCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskGatherClusterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskGatherClusterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskGatherClusterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskGatherClusterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskGatherClusterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskGatherClusterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookie )( 
            ITaskGatherClusterInfo * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompletionCookie )( 
            ITaskGatherClusterInfo * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        END_INTERFACE
    } ITaskGatherClusterInfoVtbl;

    interface ITaskGatherClusterInfo
    {
        CONST_VTBL struct ITaskGatherClusterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskGatherClusterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskGatherClusterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskGatherClusterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskGatherClusterInfo_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskGatherClusterInfo_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskGatherClusterInfo_SetCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCookie(This,cookieIn)

#define ITaskGatherClusterInfo_SetCompletionCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCompletionCookie(This,cookieIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskGatherClusterInfo_SetCookie_Proxy( 
    ITaskGatherClusterInfo * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskGatherClusterInfo_SetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskGatherClusterInfo_SetCompletionCookie_Proxy( 
    ITaskGatherClusterInfo * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskGatherClusterInfo_SetCompletionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskGatherClusterInfo_INTERFACE_DEFINED__ */


#ifndef __IGatherData_INTERFACE_DEFINED__
#define __IGatherData_INTERFACE_DEFINED__

/* interface IGatherData */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGatherData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65318F4A-B63C-4e21-ADDC-BDCFB969E181")
    IGatherData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Gather( 
            /* [in] */ OBJECTCOOKIE cookieParentIn,
            /* [in] */ IUnknown *punkIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGatherDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGatherData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGatherData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGatherData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Gather )( 
            IGatherData * This,
            /* [in] */ OBJECTCOOKIE cookieParentIn,
            /* [in] */ IUnknown *punkIn);
        
        END_INTERFACE
    } IGatherDataVtbl;

    interface IGatherData
    {
        CONST_VTBL struct IGatherDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGatherData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGatherData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGatherData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGatherData_Gather(This,cookieParentIn,punkIn)	\
    (This)->lpVtbl -> Gather(This,cookieParentIn,punkIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGatherData_Gather_Proxy( 
    IGatherData * This,
    /* [in] */ OBJECTCOOKIE cookieParentIn,
    /* [in] */ IUnknown *punkIn);


void __RPC_STUB IGatherData_Gather_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGatherData_INTERFACE_DEFINED__ */


#ifndef __ITaskGatherNodeInfo_INTERFACE_DEFINED__
#define __ITaskGatherNodeInfo_INTERFACE_DEFINED__

/* interface ITaskGatherNodeInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskGatherNodeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F19A2E01-2CB3-47b4-8F5D-B977176B45C8")
    ITaskGatherNodeInfo : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompletionCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskGatherNodeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskGatherNodeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskGatherNodeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskGatherNodeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskGatherNodeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskGatherNodeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookie )( 
            ITaskGatherNodeInfo * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompletionCookie )( 
            ITaskGatherNodeInfo * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        END_INTERFACE
    } ITaskGatherNodeInfoVtbl;

    interface ITaskGatherNodeInfo
    {
        CONST_VTBL struct ITaskGatherNodeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskGatherNodeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskGatherNodeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskGatherNodeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskGatherNodeInfo_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskGatherNodeInfo_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskGatherNodeInfo_SetCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCookie(This,cookieIn)

#define ITaskGatherNodeInfo_SetCompletionCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCompletionCookie(This,cookieIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskGatherNodeInfo_SetCookie_Proxy( 
    ITaskGatherNodeInfo * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskGatherNodeInfo_SetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskGatherNodeInfo_SetCompletionCookie_Proxy( 
    ITaskGatherNodeInfo * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskGatherNodeInfo_SetCompletionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskGatherNodeInfo_INTERFACE_DEFINED__ */


#ifndef __ITaskCompareAndPushInformation_INTERFACE_DEFINED__
#define __ITaskCompareAndPushInformation_INTERFACE_DEFINED__

/* interface ITaskCompareAndPushInformation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskCompareAndPushInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4F1C2AF-B370-49de-8768-4010B568636C")
    ITaskCompareAndPushInformation : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNodeCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompletionCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskCompareAndPushInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskCompareAndPushInformation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskCompareAndPushInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskCompareAndPushInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskCompareAndPushInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskCompareAndPushInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNodeCookie )( 
            ITaskCompareAndPushInformation * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompletionCookie )( 
            ITaskCompareAndPushInformation * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        END_INTERFACE
    } ITaskCompareAndPushInformationVtbl;

    interface ITaskCompareAndPushInformation
    {
        CONST_VTBL struct ITaskCompareAndPushInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskCompareAndPushInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskCompareAndPushInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskCompareAndPushInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskCompareAndPushInformation_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskCompareAndPushInformation_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskCompareAndPushInformation_SetNodeCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetNodeCookie(This,cookieIn)

#define ITaskCompareAndPushInformation_SetCompletionCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCompletionCookie(This,cookieIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskCompareAndPushInformation_SetNodeCookie_Proxy( 
    ITaskCompareAndPushInformation * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskCompareAndPushInformation_SetNodeCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskCompareAndPushInformation_SetCompletionCookie_Proxy( 
    ITaskCompareAndPushInformation * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskCompareAndPushInformation_SetCompletionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskCompareAndPushInformation_INTERFACE_DEFINED__ */


#ifndef __ITaskGatherInformation_INTERFACE_DEFINED__
#define __ITaskGatherInformation_INTERFACE_DEFINED__

/* interface ITaskGatherInformation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskGatherInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9AAF3F8-238E-4993-BA31-14859804F92C")
    ITaskGatherInformation : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNodeCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompletionCookie( 
            /* [in] */ OBJECTCOOKIE cookieIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJoining( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskGatherInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskGatherInformation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskGatherInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskGatherInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskGatherInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskGatherInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNodeCookie )( 
            ITaskGatherInformation * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompletionCookie )( 
            ITaskGatherInformation * This,
            /* [in] */ OBJECTCOOKIE cookieIn);
        
        HRESULT ( STDMETHODCALLTYPE *SetJoining )( 
            ITaskGatherInformation * This);
        
        END_INTERFACE
    } ITaskGatherInformationVtbl;

    interface ITaskGatherInformation
    {
        CONST_VTBL struct ITaskGatherInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskGatherInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskGatherInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskGatherInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskGatherInformation_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskGatherInformation_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskGatherInformation_SetNodeCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetNodeCookie(This,cookieIn)

#define ITaskGatherInformation_SetCompletionCookie(This,cookieIn)	\
    (This)->lpVtbl -> SetCompletionCookie(This,cookieIn)

#define ITaskGatherInformation_SetJoining(This)	\
    (This)->lpVtbl -> SetJoining(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskGatherInformation_SetNodeCookie_Proxy( 
    ITaskGatherInformation * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskGatherInformation_SetNodeCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskGatherInformation_SetCompletionCookie_Proxy( 
    ITaskGatherInformation * This,
    /* [in] */ OBJECTCOOKIE cookieIn);


void __RPC_STUB ITaskGatherInformation_SetCompletionCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskGatherInformation_SetJoining_Proxy( 
    ITaskGatherInformation * This);


void __RPC_STUB ITaskGatherInformation_SetJoining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskGatherInformation_INTERFACE_DEFINED__ */


#ifndef __ITaskPollingCallback_INTERFACE_DEFINED__
#define __ITaskPollingCallback_INTERFACE_DEFINED__

/* interface ITaskPollingCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITaskPollingCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49E92395-66AF-4add-A41E-43512CB519B3")
    ITaskPollingCallback : public IDoTask
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetServerGITCookie( 
            /* [in] */ DWORD dwGITCookieIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskPollingCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITaskPollingCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITaskPollingCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITaskPollingCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTask )( 
            ITaskPollingCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopTask )( 
            ITaskPollingCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetServerGITCookie )( 
            ITaskPollingCallback * This,
            /* [in] */ DWORD dwGITCookieIn);
        
        END_INTERFACE
    } ITaskPollingCallbackVtbl;

    interface ITaskPollingCallback
    {
        CONST_VTBL struct ITaskPollingCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskPollingCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskPollingCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskPollingCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskPollingCallback_BeginTask(This)	\
    (This)->lpVtbl -> BeginTask(This)

#define ITaskPollingCallback_StopTask(This)	\
    (This)->lpVtbl -> StopTask(This)


#define ITaskPollingCallback_SetServerGITCookie(This,dwGITCookieIn)	\
    (This)->lpVtbl -> SetServerGITCookie(This,dwGITCookieIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskPollingCallback_SetServerGITCookie_Proxy( 
    ITaskPollingCallback * This,
    /* [in] */ DWORD dwGITCookieIn);


void __RPC_STUB ITaskPollingCallback_SetServerGITCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskPollingCallback_INTERFACE_DEFINED__ */


#ifndef __IClusCfgAsyncEvictCleanup_INTERFACE_DEFINED__
#define __IClusCfgAsyncEvictCleanup_INTERFACE_DEFINED__

/* interface IClusCfgAsyncEvictCleanup */
/* [unique][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IClusCfgAsyncEvictCleanup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52C80B95-C1AD-4240-8D89-72E9FA84025E")
    IClusCfgAsyncEvictCleanup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CleanupNode( 
            /* [unique][in] */ LPCWSTR pcszEvictedNodeNameIn,
            /* [in] */ DWORD dwDelayIn,
            /* [in] */ DWORD dwTimeoutIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClusCfgAsyncEvictCleanupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClusCfgAsyncEvictCleanup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClusCfgAsyncEvictCleanup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClusCfgAsyncEvictCleanup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CleanupNode )( 
            IClusCfgAsyncEvictCleanup * This,
            /* [unique][in] */ LPCWSTR pcszEvictedNodeNameIn,
            /* [in] */ DWORD dwDelayIn,
            /* [in] */ DWORD dwTimeoutIn);
        
        END_INTERFACE
    } IClusCfgAsyncEvictCleanupVtbl;

    interface IClusCfgAsyncEvictCleanup
    {
        CONST_VTBL struct IClusCfgAsyncEvictCleanupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClusCfgAsyncEvictCleanup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClusCfgAsyncEvictCleanup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClusCfgAsyncEvictCleanup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClusCfgAsyncEvictCleanup_CleanupNode(This,pcszEvictedNodeNameIn,dwDelayIn,dwTimeoutIn)	\
    (This)->lpVtbl -> CleanupNode(This,pcszEvictedNodeNameIn,dwDelayIn,dwTimeoutIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClusCfgAsyncEvictCleanup_CleanupNode_Proxy( 
    IClusCfgAsyncEvictCleanup * This,
    /* [unique][in] */ LPCWSTR pcszEvictedNodeNameIn,
    /* [in] */ DWORD dwDelayIn,
    /* [in] */ DWORD dwTimeoutIn);


void __RPC_STUB IClusCfgAsyncEvictCleanup_CleanupNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClusCfgAsyncEvictCleanup_INTERFACE_DEFINED__ */


#ifndef __ILogManager_INTERFACE_DEFINED__
#define __ILogManager_INTERFACE_DEFINED__

/* interface ILogManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ILogManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4759DC11-8DA0-4261-BBFB-EC321911D1C9")
    ILogManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartLogging( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopLogging( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartLogging )( 
            ILogManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopLogging )( 
            ILogManager * This);
        
        END_INTERFACE
    } ILogManagerVtbl;

    interface ILogManager
    {
        CONST_VTBL struct ILogManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogManager_StartLogging(This)	\
    (This)->lpVtbl -> StartLogging(This)

#define ILogManager_StopLogging(This)	\
    (This)->lpVtbl -> StopLogging(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILogManager_StartLogging_Proxy( 
    ILogManager * This);


void __RPC_STUB ILogManager_StartLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILogManager_StopLogging_Proxy( 
    ILogManager * This);


void __RPC_STUB ILogManager_StopLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogManager_INTERFACE_DEFINED__ */


#ifndef __ILogger_INTERFACE_DEFINED__
#define __ILogger_INTERFACE_DEFINED__

/* interface ILogger */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ILogger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9598418-304E-4f94-B6A1-E642FE95ED57")
    ILogger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LogMsg( 
            /* [unique][in] */ LPCWSTR pcszMsgIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILoggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogger * This);
        
        HRESULT ( STDMETHODCALLTYPE *LogMsg )( 
            ILogger * This,
            /* [unique][in] */ LPCWSTR pcszMsgIn);
        
        END_INTERFACE
    } ILoggerVtbl;

    interface ILogger
    {
        CONST_VTBL struct ILoggerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogger_LogMsg(This,pcszMsgIn)	\
    (This)->lpVtbl -> LogMsg(This,pcszMsgIn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILogger_LogMsg_Proxy( 
    ILogger * This,
    /* [unique][in] */ LPCWSTR pcszMsgIn);


void __RPC_STUB ILogger_LogMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogger_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\clustdi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clustdi.h

Abstract:

    TDI definitions for the Cluster Network Protocol suite.

Author:

    Mike Massa (mikemas)  21-Feb-1997

Environment:

    User Mode.

Revision History:

--*/


#ifndef _CLUSTDI_INCLUDED
#define _CLUSTDI_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#define TDI_ADDRESS_TYPE_CLUSTER  ((USHORT) 24)

#include <packon.h>

typedef struct _TDI_ADDRESS_CLUSTER {
    USHORT   Port;
    ULONG    Node;
    ULONG    ReservedMBZ;
} TDI_ADDRESS_CLUSTER, *PTDI_ADDRESS_CLUSTER;

#define TDI_ADDRESS_LENGTH_CLUSTER  sizeof(TDI_ADDRESS_CLUSTER)


typedef struct _TA_ADDRESS_CLUSTER {
    LONG TAAddressCount;
    struct _AddrCluster {
        USHORT AddressLength;       // length in bytes of this address == 8
        USHORT AddressType;         // this will == TDI_ADDRESS_TYPE_CLUSTER
        TDI_ADDRESS_CLUSTER Address[1];
    } Address [1];
} TA_CLUSTER_ADDRESS, *PTA_CLUSTER_ADDRESS;

#include <packoff.h>


#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // ifndef _CLUSTDI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\clusstor.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clusstor.h

Abstract:


Revision History:

--*/

#ifndef _CLUS_STOR_
#define _CLUS_STOR_

#include <clusapi.h>

//
// Storage Resource DLL Extension info
//

typedef DWORD ( * lpPassThruFunc)( IN LPSTR lpDeviceName,   // Single-byte Character Set string
                                   IN LPSTR lpContextStr,   // Single-byte Character Set string
                                   OUT LPVOID lpOutBuffer,
                                   IN DWORD nOutBufferSize,
                                   OUT LPDWORD lpBytesReturned );

typedef struct DISK_DLL_EXTENSION_INFO {
    WORD    MajorVersion;
    WORD    MinorVersion;
    CHAR    DllModuleName[MAX_PATH];        // Single-byte Character Set string
    CHAR    DllProcName[MAX_PATH];          // Single-byte Character Set string
    CHAR    ContextStr[MAX_PATH];           // Single-byte Character Set string
} DISK_DLL_EXTENSION_INFO, *PDISK_DLL_EXTENSION_INFO;


#define CLCTL_STORAGE_DLL_EXTENSION \
            CLCTL_EXTERNAL_CODE( 9500, CLUS_ACCESS_READ, CLUS_NO_MODIFY )

#define CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION \
            CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_DLL_EXTENSION )


#endif // _CLUS_STOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\comp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    comp.h

Abstract:

    This file defines the data structures
    and interfaces for compatibility plug
    in dlls for winnt32.

Author:

    Wesley Witt (wesw) 6-Mar-1998

Environment:

    User Mode

--*/


#ifndef _WINNT32COMP_
#define _WINNT32COMP_

#ifdef __cplusplus
extern "C" {
#endif

#define COMP_ERR_DESC_NOT_UNICODE           (ULONG)0xc00000001
#define COMP_ERR_TEXTNAME_NOT_UNICODE       (ULONG)0xc00000002
#define COMP_ERR_HTMLNAME_NOT_UNICODE       (ULONG)0xc00000003
#define COMP_ERR_REGKEYNAME_NOT_UNICODE     (ULONG)0xc00000004
#define COMP_ERR_REGVALNAME_NOT_UNICODE     (ULONG)0xc00000005
#define COMP_ERR_REGVALNAME_MISSING         (ULONG)0xc00000006
#define COMP_ERR_REGVALDATA_MISSING         (ULONG)0xc00000007
#define COMP_ERR_TEXTNAME_MISSING           (ULONG)0xc00000008
#define COMP_ERR_DESC_MISSING               (ULONG)0xc00000009
#define COMP_ERR_INFNAME_NOT_UNICODE        (ULONG)0xc0000000A
#define COMP_ERR_INFSECTION_NOT_UNICODE     (ULONG)0xc0000000B
#define COMP_ERR_INFSECTION_MISSING         (ULONG)0xc0000000C



typedef struct _COMPATIBILITY_ENTRY {
    LPTSTR  Description;
    LPTSTR  HtmlName;
    LPTSTR  TextName;
    LPTSTR  RegKeyName;
    LPTSTR  RegValName;
    DWORD   RegValDataSize;
    LPVOID  RegValData;
    LPVOID  SaveValue;
    DWORD   Flags;
    LPTSTR  InfName;
    LPTSTR  InfSection;
} COMPATIBILITY_ENTRY, *PCOMPATIBILITY_ENTRY;

typedef BOOL
(CALLBACK *PCOMPAIBILITYCALLBACK)(
    PCOMPATIBILITY_ENTRY CompEntry,
    LPVOID Context
    );

typedef BOOL
(WINAPI *PCOMPAIBILITYCHECK)(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    );


typedef DWORD
(WINAPI *PCOMPAIBILITYHAVEDISK)(
    HWND hwndParent,
    LPVOID SaveValue
    );

#define COMPFLAG_USE_HAVEDISK   0x00000001
#define COMPFLAG_HIDE           0x00000002
#define COMPFLAG_STOPINSTALL    0x00000004
#define COMPFLAG_DELETE_INF     0x00000008
#define COMPFLAG_SKIPNT40CHECK   0x00000010
#define COMPFLAG_SKIPNT50CHECK   0x00000020
#define COMPFLAG_SKIPNT51CHECK   0x00000040
#define COMPFLAG_SKIPNTCHECK     0xfffffff0


typedef struct _COMPATIBILITY_CONTEXT {
    DWORD                   Count;
    HMODULE                 hModDll;
    PCOMPAIBILITYHAVEDISK   CompHaveDisk;
} COMPATIBILITY_CONTEXT, *PCOMPATIBILITY_CONTEXT;


BOOLEAN
CheckForFileVersion(
    LPCTSTR FileName, 
    LPCTSTR FileVer
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\cscapi.h ===
#ifndef _INC_CSCAPI
#define _INC_CSCAPI

#ifdef  __cplusplus
extern "C" {
#endif
// flags returned in the status field for files and folders.
// NB!!!! these bit definitions match exactly with those in shdcom.h


#define  FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED     0x0001
#define  FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED   0x0002
#define  FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED     0x0004
#define  FLAG_CSC_COPY_STATUS_STALE                     0x0008
#define  FLAG_CSC_COPY_STATUS_LOCALLY_DELETED           0x0010
#define  FLAG_CSC_COPY_STATUS_SPARSE                    0x0020

#define  FLAG_CSC_COPY_STATUS_ORPHAN                    0x0100
#define  FLAG_CSC_COPY_STATUS_SUSPECT                   0x0200
#define  FLAG_CSC_COPY_STATUS_LOCALLY_CREATED           0x0400

#define  FLAG_CSC_COPY_STATUS_IS_FILE                   0x80000000
#define  FLAG_CSC_COPY_STATUS_FILE_IN_USE               0x40000000

// Flags returned in the status field for shares

#define FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE          0x0001
#define FLAG_CSC_SHARE_STATUS_CONNECTED                 0x0800
#define FLAG_CSC_SHARE_STATUS_FILES_OPEN                0x0400
#define FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS         0x0200
#define FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP           0x8000
#define FLAG_CSC_SHARE_MERGING                          0x4000

#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000  // No automatic file by file reint  (Persistent)
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040  // File by file reint is OK         (Persistent)
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080  // no need to flow opens            (Persistent)
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0  // client should not cache this share (Persistent)

#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0  // type of caching

#define FLAG_CSC_ACCESS_MASK                            0x003F0000
#define FLAG_CSC_USER_ACCESS_MASK                       0x00030000
#define FLAG_CSC_GUEST_ACCESS_MASK                      0x000C0000
#define FLAG_CSC_OTHER_ACCESS_MASK                      0x00300000

#define FLAG_CSC_USER_ACCESS_SHIFT_COUNT                16
#define FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT               18
#define FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT               20

#define FLAG_CSC_READ_ACCESS                            0x00000001
#define FLAG_CSC_WRITE_ACCESS                           0x00000002

// Hint flags Definitions:
#define FLAG_CSC_HINT_PIN_USER                  0x01    // When this bit is set, the item is being pinned for the user
                                                        // Note that there is only one pincount allotted for user.
#define FLAG_CSC_HINT_PIN_INHERIT_USER          0x02    // When this flag is set on a folder, all  descendents subsequently
                                                        // Created in this folder get pinned for the user
#define FLAG_CSC_HINT_PIN_INHERIT_SYSTEM        0x04    // When this flag is set on a folder, all descendents
                                                        // Subsequently  created in this folder get pinned for the
                                                        // system
#define FLAG_CSC_HINT_CONSERVE_BANDWIDTH        0x08    // When this flag is set on a folder,  for executables and
                                                        // Other related file, CSC tries to conserver bandwidth
                                                        // By not flowing opens when these files are fully


#define FLAG_CSC_HINT_PIN_SYSTEM                0x10    // This flag indicates it is pinned for the system

#define FLAG_CSC_HINT_COMMAND_MASK                      0xf0000000
#define FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT           0x80000000  // Increments/decrements pin count


// Database status bits

#define FLAG_DATABASESTATUS_DIRTY                   0x00000001

#define FLAG_DATABASESTATUS_ENCRYPTION_MASK         0x00000006

#define FLAG_DATABASESTATUS_UNENCRYPTED             0x00000000 // new fileinodes will NOT be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED   0x00000004

#define FLAG_DATABASESTATUS_ENCRYPTED               0x00000002 // new fileinodes will be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED     0x00000006


// definitions for callback reason

#define CSCPROC_REASON_BEGIN        1
#define CSCPROC_REASON_MORE_DATA    2
#define CSCPROC_REASON_END          3


// Definitions for callback return values:

#define CSCPROC_RETURN_CONTINUE         1
#define CSCPROC_RETURN_SKIP             2
#define CSCPROC_RETURN_ABORT            3
#define CSCPROC_RETURN_FORCE_INWARD     4        // applies only while merging
#define CSCPROC_RETURN_FORCE_OUTWARD    5    // applies only while merging
#define CSCPROC_RETURN_RETRY            6



typedef DWORD   (WINAPI *LPCSCPROCW)(
                LPCWSTR             lpszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                WIN32_FIND_DATAW    *lpFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext
                );

typedef DWORD   (WINAPI *LPCSCPROCA)(
                LPCSTR              lpszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                WIN32_FIND_DATAA    *lpFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext
                );



BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
);


BOOL
WINAPI
CSCFindClose(
    IN  HANDLE    hFind
);

BOOL
WINAPI
CSCPinFileA(
    IN  LPCSTR      lpszFileName,
    IN  DWORD       dwHintFlags,
    OUT LPDWORD     lpdwStatus,
    OUT LPDWORD     lpdwPinCount,
    OUT LPDWORD     lpdwHintFlags
    );

BOOL
WINAPI
CSCUnpinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags
    );

BOOL
WINAPI
CSCQueryFileStatusA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags
);

BOOL
WINAPI
CSCQueryFileStatusExA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags,
    OUT LPDWORD lpdwUserPerms,
    OUT LPDWORD lpdwOtherPerms
);

BOOL
WINAPI
CSCQueryShareStatusA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags,
    OUT LPDWORD lpdwUserPerms,
    OUT LPDWORD lpdwOtherPerms
);

HANDLE
WINAPI
CSCFindFirstFileA(
    IN  LPCSTR          lpszFileName,    // if NULL, returns the shares cached
    OUT WIN32_FIND_DATA *lpFind32,
    OUT LPDWORD         lpdwStatus,        // returns FLAG_CSC_SHARE_STATUS_XXX for shares
                                            // FLAG_CSC_STATUS_XXX for the rest
    OUT LPDWORD         lpdwPinCount,
    OUT LPDWORD         lpdwHintFlags,
    OUT FILETIME        *lpOrgFileTime
);

BOOL
WINAPI
CSCFindNextFileA(
    IN  HANDLE          hFind,
    OUT WIN32_FIND_DATA *lpFind32,
    OUT LPDWORD         lpdwStatus,
    OUT LPDWORD         lpdwPinCount,
    OUT LPDWORD         lpdwHintFlags,
    OUT FILETIME        *lpOrgFileTime
);

BOOL
WINAPI
CSCDeleteA(
    IN  LPCSTR    lpszFileName
);


BOOL
WINAPI
CSCFillSparseFilesA(
    IN    LPCSTR        lpszShareName,
    IN    BOOL          fFullSync,
    IN    LPCSCPROCA    lpprocFillProgress,
    IN    DWORD_PTR     dwContext
);



BOOL
WINAPI
CSCMergeShareA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
);


BOOL
WINAPI
CSCCopyReplicaA(
    IN  LPCSTR  lpszFullPath,
    OUT LPSTR   *lplpszLocalName
);


BOOL
WINAPI
CSCEnumForStatsA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCEnumForStatsExA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCPinFileW(
    LPCWSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
);

BOOL
WINAPI
CSCUnpinFileW(
    LPCWSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
    );

BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
);

BOOL
WINAPI
CSCQueryFileStatusExW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
);

BOOL
WINAPI
CSCQueryShareStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
);

HANDLE
WINAPI
CSCFindFirstFileW(
    LPCWSTR             lpszFileName,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);

HANDLE
WINAPI
CSCFindFirstFileForSidW(
    LPCWSTR             lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);
BOOL
WINAPI
CSCFindNextFileW(
    HANDLE              hFind,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);

BOOL
WINAPI
CSCDeleteW(
    IN  LPCWSTR    lpszFileName
);

BOOL
WINAPI
CSCFillSparseFilesW(
    IN    LPCWSTR       lpszShareName,
    IN    BOOL          fFullSync,
    IN    LPCSCPROCW    lpprocFillProgress,
    IN    DWORD_PTR     dwContext
);



BOOL
WINAPI
CSCMergeShareW(
    IN  LPCWSTR         lpszShareName,
    IN  LPCSCPROCW      lpfnMergeProgress,
    IN  DWORD_PTR       dwContext
);


BOOL
WINAPI
CSCCopyReplicaW(
    IN  LPCWSTR lpszFullPath,
    OUT LPWSTR  *lplpszLocalName
);

BOOL
WINAPI
CSCEnumForStatsW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCEnumForStatsExW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCFreeSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
    );

BOOL
WINAPI
CSCIsServerOfflineA(
    IN  LPCSTR     lpszServerName,
    OUT BOOL        *lpfOffline
    );

BOOL
WINAPI
CSCIsServerOfflineW(
    IN  LPCWSTR     lpszServerName,
    OUT BOOL        *lpfOffline
    );

BOOL
WINAPI
CSCGetSpaceUsageA(
    OUT LPSTR   lptzLocation,
    IN  DWORD   dwSize,
    OUT LPDWORD lpdwMaxSpaceHigh,
    OUT LPDWORD lpdwMaxSpaceLow,
    OUT LPDWORD lpdwCurrentSpaceHigh,
    OUT LPDWORD lpdwCurrentSpaceLow,
    OUT LPDWORD lpcntTotalFiles,
    OUT LPDWORD lpcntTotalDirs
);

BOOL
WINAPI
CSCGetSpaceUsageW(
    OUT LPWSTR  lptzLocation,
    IN  DWORD   dwSize,
    OUT LPDWORD lpdwMaxSpaceHigh,
    OUT LPDWORD lpdwMaxSpaceLow,
    OUT LPDWORD lpdwCurrentSpaceHigh,
    OUT LPDWORD lpdwCurrentSpaceLow,
    OUT LPDWORD lpcntTotalFiles,
    OUT LPDWORD lpcntTotalDirs
);

BOOL
WINAPI
CSCSetMaxSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
);

BOOL
WINAPI
CSCTransitionServerOnlineW(
    IN  LPCWSTR     lpszServerName
    );

BOOL
WINAPI
CSCTransitionServerOnlineA(
    IN  LPCSTR     lpszServerName
    );

BOOL
WINAPI
CSCCheckShareOnlineW(
    IN  LPCWSTR     lpszShareName
    );

BOOL
WINAPI
CSCCheckShareOnlineExW(
    IN  LPCWSTR     lpszShareName,
    IN  DWORD       *lpdwSpeed
    );

BOOL
WINAPI
CSCCheckShareOnlineA(
    IN  LPCSTR     lpszShareName
    );

BOOL
WINAPI
CSCDoLocalRenameW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  BOOL        fReplaceFile
    );

BOOL
WINAPI
CSCDoLocalRenameA(
    IN  LPCSTR      lpszSource,
    IN  LPCSTR      lpszDestination,
    IN  BOOL        fReplaceFile
    );

BOOL
WINAPI
CSCDoLocalRenameExA(
    IN  LPCSTR     lpszSource,
    IN  LPCSTR     lpszDestination,
    IN  WIN32_FIND_DATAA    *lpFin32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    );

BOOL
WINAPI
CSCDoLocalRenameExW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  WIN32_FIND_DATAW    *lpFin32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    );

BOOL
WINAPI
CSCDoEnableDisable(
    BOOL    fEnable
    );


BOOL
WINAPI
CSCBeginSynchronizationW(
    IN  LPCWSTR     lpszShareName,
    LPDWORD         lpdwSpeed,
    LPDWORD         lpdwContext
    );


BOOL
WINAPI
CSCEndSynchronizationW(
    IN  LPCWSTR     lpszShareName,
    DWORD           dwContext
    );

BOOL
WINAPI
CSCEncryptDecryptDatabase(
    IN  BOOL        fEncrypt,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
    );

BOOL
WINAPI
CSCQueryDatabaseStatus(
    ULONG   *pulStatus,
    ULONG   *pulErrors
    );

BOOL
WINAPI
CSCPurgeUnpinnedFiles(
    ULONG   Timeout,
    ULONG   *pulnFiles,
    ULONG   *pulnYoungFiles
    );

BOOL
WINAPI
CSCShareIdToShareName(
    ULONG ShareId,
    PBYTE Buffer,
    PDWORD pdwBufSize
    );

#ifdef UNICODE

#define CSCPinFile          CSCPinFileW
#define CSCUnpinFile        CSCUnpinFileW
#define CSCQueryFileStatus  CSCQueryFileStatusW
#define CSCQueryFileStatusEx  CSCQueryFileStatusExW
#define CSCQueryShareStatus  CSCQueryShareStatusW
#define CSCFindFirstFile    CSCFindFirstFileW
#define CSCFindFirstFileForSid    CSCFindFirstFileForSidW
#define CSCFindNextFile     CSCFindNextFileW
#define CSCDelete           CSCDeleteW
#define CSCFillSparseFiles  CSCFillSparseFilesW
#define CSCMergeShare       CSCMergeShareW
#define CSCCopyReplica      CSCCopyReplicaW
#define CSCEnumForStats     CSCEnumForStatsW
#define CSCIsServerOffline  CSCIsServerOfflineW
#define LPCSCPROC           LPCSCPROCW
#define CSCGetSpaceUsage    CSCGetSpaceUsageW
#define CSCTransitionServerOnline   CSCTransitionServerOnlineW
#define CSCCheckShareOnline         CSCCheckShareOnlineW
#define CSCCheckShareOnlineEx         CSCCheckShareOnlineExW
#define CSCDoLocalRename            CSCDoLocalRenameW
#define CSCDoLocalRenameEx            CSCDoLocalRenameExW
#define CSCEnumForStatsEx     CSCEnumForStatsExW
#define CSCBeginSynchronization    CSCBeginSynchronizationW
#define CSCEndSynchronization   CSCEndSynchronizationW
#else

#define CSCPinFile          CSCPinFileA
#define CSCUnpinFile        CSCUnpinFileA
#define CSCQueryFileStatus  CSCQueryFileStatusA
#define CSCQueryFileStatusEx  CSCQueryFileStatusExA
#define CSCQueryShareStatus  CSCQueryShareStatusA
#define CSCFindFirstFile    CSCFindFirstFileA
#define CSCFindFirstFileForSid    CSCFindFirstFileForSidA
#define CSCFindNextFile     CSCFindNextFileA
#define CSCDelete           CSCDeleteA
#define CSCFillSparseFiles  CSCFillSparseFilesA
#define CSCMergeShare       CSCMergeShareA
#define CSCCopyReplica      CSCCopyReplicaA
#define CSCEnumForStats     CSCEnumForStatsA
#define CSCIsServerOffline  CSCIsServerOfflineA
#define LPCSCPROC           LPCSCPROCA
#define CSCGetSpaceUsage    CSCGetSpaceUsageA
#define CSCTransitionServerOnline   CSCTransitionServerOnlineA
#define CSCCheckShareOnline        CSCCheckShareOnlineA
#define CSCCheckShareOnlineEx         CSCCheckShareOnlineExA
#define CSCDoLocalRename            CSCDoLocalRenameA
#define CSCEnumForStatsEx     CSCEnumForStatsExA
#define CSCDoLocalRenameEx            CSCDoLocalRenameExA
#endif

#ifdef __cplusplus
}   /* ... extern "C" */
#endif


#endif  // _INC_CSCAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\dloadexcept.h ===
#pragma once

// Our primary client is kernel32.dll.  Because we use APIs exported
// by kernel32.dll, we need to build this static library as if we
// are kernel32.dll.  If we don't we get link warnings like:
// warning LNK4049: locally defined symbol "_OutputDebugStringA@4" imported
// warning LNK4049: locally defined symbol "_SetLastError@4" imported
//
// Other clients of this library will just go through the import thunk
// instead of doing a call indirect for these APIs.
//
#define _KERNEL32_

// "Build as if we are advapi32.dll. If we don't we get" compiler errors like:
// advapi.c : error C2491: 'RegCreateKeyExW' : definition of dllimport function not allowed
#define _ADVAPI32_
// same problem..
#define _RPCRT4_
#define _USER32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <delayimp.h>
#include <stdio.h>
#include <wtypes.h>

#include <dloaddef.h>

#if DBG

//
// DelayLoadAssertFailed/MYASSERT used instead of RtlAssert/ASSERT
// as dload is also compiled to run on Win95
//

VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    );

VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted(
    VOID
    );

#define MYASSERT(x)     if(!(x)) { DelayLoadAssertFailed(#x,__FILE__,__LINE__,NULL); }

#else

#define MYASSERT(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\dloaddef.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dloaddef.w

Abstract:

    This header defines the basic data types and macros needed to support
    building delay-load stubs to be linked into kernel32.
    See nt/base/dload where dload.lib is built.
    See nt/net/published/lib/dload where dloadnet.lib is built.
    Both are linked into kernel32 and provide the failure hooks which support
    delay loading (via /DELAYLOAD linker switch) various DLLs in the system.
   
Author:

    Shaun Cox (shaunco) 10-Mar-2000

Environment:

    User mode only.

Revision History:

--*/

#pragma once

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))


typedef struct _DLOAD_PROCNAME_ENTRY
{
    LPCSTR  pszProcName;
    FARPROC pfnProc;
} DLOAD_PROCNAME_ENTRY;

#define DLPENTRY(_fcn)  { #_fcn, (FARPROC)_fcn },

#define DEFINE_PROCNAME_ENTRIES(_dllbasename) \
    const DLOAD_PROCNAME_ENTRY c_PmapEntries_##_dllbasename [] =


typedef struct _DLOAD_PROCNAME_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_PROCNAME_ENTRY* pProcNameEntry;
} DLOAD_PROCNAME_MAP;

#define DECLARE_PROCNAME_MAP(_dllbasename) \
    extern const DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename;

#define DEFINE_PROCNAME_MAP(_dllbasename) \
    const DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename = \
    { \
        celems(c_PmapEntries_##_dllbasename), \
        c_PmapEntries_##_dllbasename \
    };




typedef struct _DLOAD_ORDINAL_ENTRY
{
    DWORD   dwOrdinal;
    FARPROC pfnProc;
} DLOAD_ORDINAL_ENTRY;

#define DLOENTRY(_ord, _fcn)  { _ord, (FARPROC)_fcn },

#define DEFINE_ORDINAL_ENTRIES(_dllbasename) \
    const DLOAD_ORDINAL_ENTRY c_OmapEntries_##_dllbasename [] =


typedef struct _DLOAD_ORDINAL_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_ORDINAL_ENTRY*  pOrdinalEntry;
} DLOAD_ORDINAL_MAP;

#define DECLARE_ORDINAL_MAP(_dllbasename) \
    extern const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename;

#define DEFINE_ORDINAL_MAP(_dllbasename) \
    const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename = \
    { \
        celems(c_OmapEntries_##_dllbasename), \
        c_OmapEntries_##_dllbasename \
    };


typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\dfspriv.h ===
#ifndef _XHDFSH_
#define _XHDFSH_

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif // __LPGUID_DEFINED__

#include <dfsfsctl.h>

#ifdef __cplusplus
extern "C" {
#endif


//
// These internal only calls are used to manage DFS.  They should be called only
//  by the DFS manager service.
//

NET_API_STATUS NET_API_FUNCTION
I_NetDfsGetVersion (
    IN  LPWSTR                          ServerName,
    IN  LPDWORD                         Version
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsCreateLocalPartition (
    IN  LPWSTR                          ServerName,
    IN  LPWSTR                          ShareName,
    IN  LPGUID                          EntryUid,
    IN  LPWSTR                          EntryPrefix,
    IN  LPWSTR                          ShortName,
    IN  LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo,
    IN  BOOL                            Force
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsDeleteLocalPartition (
    IN  LPWSTR                      ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsSetLocalVolumeState (
    IN  LPWSTR                      ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       State
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsSetServerInfo (
    IN  LPWSTR                      ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsCreateExitPoint (
    IN  LPWSTR                      ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type,
    IN  ULONG                       ShortPrefixSize,    // In Bytes
    OUT LPWSTR                      ShortPrefix
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsDeleteExitPoint (
    IN  LPWSTR                      ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsModifyPrefix (
    IN  LPWSTR                      ServerName,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsFixLocalVolume (
    IN  LPWSTR                          ServerName,
    IN  LPWSTR                          VolumeName,
    IN  ULONG                           EntryType,
    IN  ULONG                           ServiceType,
    IN  LPWSTR                          StgId,
    IN  LPGUID                          EntryUid,       // unique id for this partition
    IN  LPWSTR                          EntryPrefix,    // path prefix for this partition
    IN  LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo,
    IN  ULONG                           CreateDisposition
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsGetFtServers(
    IN PVOID  LdapInputArg OPTIONAL,
    IN LPWSTR wszDomainName OPTIONAL,
    IN LPWSTR wszDfsName OPTIONAL,
    OUT LPWSTR **List
    );

DWORD
I_NetDfsIsThisADomainName(
    IN  LPWSTR                      wszName
    );

NET_API_STATUS NET_API_FUNCTION
I_NetDfsManagerReportSiteInfo (
    IN  LPWSTR                          ServerName,
    OUT LPDFS_SITELIST_INFO             *ppSiteInfo
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\csr.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csr.h

Abstract:

    Include file that defines all the common data types and constants for
    the Client-Server Runtime (CSR) SubSystem

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/


//
// Include NT Definitions.
//

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "string.h"

#define GetModuleHandle GetModuleHandleA

//
// Define debugging flag as false if not defined already.
//

#ifndef DBG
#define DBG 0
#endif


//
// Define IF_DEBUG macro that can be used to enable debugging code that is
// optimized out if the debugging flag is false.
//

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

//
// Common types and constant definitions
//

typedef enum _CSRP_API_NUMBER {
    CsrpClientConnect = 0, // CSRSRV_FIRST_API_NUMBER defined in ntcsrmsg.h
    CsrpThreadConnect,
    CsrpProfileControl,
    CsrpIdentifyAlertable,
    CsrpSetPriorityClass,
    CsrpMaxApiNumber
} CSRP_API_NUMBER, *PCSRP_API_NUMBER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\elfkrnl.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfkrnl.h

Abstract:

    This file contains defines for kernel->elf data structures

Author:

    Mark Zbikowski 4/27/98

Revision History:

--*/

#ifndef _ELFKRNL_
#define _ELFKRNL_

#define     ELF_PORT_NAME	    "\\ErrorLogPort"
#define     ELF_PORT_NAME_U	    L"\\ErrorLogPort"

//
//  Type discriminator
//

typedef enum {
    IO_ERROR_LOG = 0,
    SM_ERROR_LOG,
} ELF_MESSAGE_TYPE;


//
//  SM event structure
//

typedef struct {
    LARGE_INTEGER TimeStamp;
    NTSTATUS Status;
    ULONG StringOffset;
    ULONG StringLength;
} SM_ERROR_LOG_MESSAGE, *PSM_ERROR_LOG_MESSAGE;


//
// Max size of data sent to the eventlogging service through the LPC port.
//

#define     ELF_PORT_MAX_MESSAGE_LENGTH PORT_MAXIMUM_MESSAGE_LENGTH


//
// Structure that is passed in from the system thread to the LPC port
//

typedef struct  {
   PORT_MESSAGE PortMessage;
   ULONG MessageType;
   union {
       IO_ERROR_LOG_MESSAGE IoErrorLogMessage;
       SM_ERROR_LOG_MESSAGE SmErrorLogMessage;
   } u;
} ELF_PORT_MSG, *PELF_PORT_MSG;


//
// Structure for the message as a reply from the eventlogging service to
// the LPC client.
//

typedef struct _ELF_REPLY_MESSAGE {
    PORT_MESSAGE PortMessage;
    NTSTATUS Status;
} ELF_REPLY_MESSAGE, *PELF_REPLY_MESSAGE;

#endif // ifndef _ELFLPC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\emulate.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    emulate.h

Abstract:

    This module contains the private header file for the x86 bios
    emulation.

Author:

    David N. Cutler (davec) 2-Sep-1994

Revision History:

--*/

#ifndef _EMULATE_
#define _EMULATE_

#include "setjmp.h"
#include "xm86.h"
#include "x86new.h"

//
// Define debug tracing flags.
//

//#define XM_DEBUG 1  // ****** temp ******

#define TRACE_INSTRUCTIONS 0x1
#define TRACE_OPERANDS 0x2
#define TRACE_GENERAL_REGISTERS 0x4
#define TRACE_OVERRIDE 0x8
#define TRACE_JUMPS 0x10
#define TRACE_SPECIFIERS 0x20
#define TRACE_SINGLE_STEP 0x40

//
// Define opcode function table indexes.
//
// N.B. This values must correspond exactly one for one with the function
//      table entries. If the C language had indexed initializers this
//      type would not be necessary.
//

typedef enum _XM_FUNCTION_TABLE_INDEX {

    //
    // ASCII operators.
    //

    X86_AAA_OP,
    X86_AAD_OP,
    X86_AAM_OP,
    X86_AAS_OP,
    X86_DAA_OP,
    X86_DAS_OP,

    //
    // Group 1 operators.
    //

    X86_ADD_OP,
    X86_OR_OP,
    X86_ADC_OP,
    X86_SBB_OP,
    X86_AND_OP,
    X86_SUB_OP,
    X86_XOR_OP,
    X86_CMP_OP,

    //
    // Group 2 operators.
    //

    X86_ROL_OP,
    X86_ROR_OP,
    X86_RCL_OP,
    X86_RCR_OP,
    X86_SHL_OP,
    X86_SHR_OP,
    X86_FILL0_OP,
    X86_SAR_OP,

    //
    // Group 3 operators.
    //

    X86_TEST_OP,
    X86_FILL1_OP,
    X86_NOT_OP,
    X86_NEG_OP,
    X86_MUL_OP,
    X86_IMULX_OP,
    X86_DIV_OP,
    X86_IDIV_OP,

    //
    // Group 4 and 5 operators.
    //

    X86_INC_OP,
    X86_DEC_OP,
    X86_CALL_OP,
    X86_FILL2_OP,
    X86_JMP_OP,
    X86_FILL3_OP,
    X86_PUSH_OP,
    X86_FILL4_OP,

    //
    // Group 8 operators.
    //

    X86_BT_OP,
    X86_BTS_OP,
    X86_BTR_OP,
    X86_BTC_OP,

    //
    // Stack push and pop operators.
    //

    X86_POP_OP,
    X86_PUSHA_OP,
    X86_POPA_OP,

    //
    // Jump operators.
    //

    X86_JXX_OP,
    X86_LOOP_OP,
    X86_JCXZ_OP,

    //
    // Control operators.
    //

    X86_ENTER_OP,
    X86_HLT_OP,
    X86_INT_OP,
    X86_IRET_OP,
    X86_LEAVE_OP,
    X86_RET_OP,

    //
    // Set boolean byte value based on condition.
    //

    X86_SXX_OP,

    //
    // Condition code operators.
    //

    X86_CMC_OP,
    X86_CLC_OP,
    X86_STC_OP,
    X86_CLI_OP,
    X86_STI_OP,
    X86_CLD_OP,
    X86_STD_OP,
    X86_LAHF_OP,
    X86_SAHF_OP,

    //
    // General move operators.
    //

    X86_MOV_OP,
    X86_XCHG_OP,

    //
    // Convert operations.
    //

    X86_CBW_OP,
    X86_CWD_OP,

    //
    // Single multiply operator.
    //

    X86_IMUL_OP,

    //
    // String operators.
    //

    X86_CMPS_OP,
    X86_INS_OP,
    X86_LODS_OP,
    X86_MOVS_OP,
    X86_OUTS_OP,
    X86_SCAS_OP,
    X86_STOS_OP,

    //
    // Effective address operators.
    //

    X86_BOUND_OP,
    X86_LEA_OP,

    //
    // Double shift operators.
    //

    X86_SHLD_OP,
    X86_SHRD_OP,

    //
    // I/O operators.
    //

    X86_IN_OP,
    X86_OUT_OP,

    //
    // Bit scan operators.
    //

    X86_BSF_OP,
    X86_BSR_OP,

    //
    // Byte swap operators.
    //

    X86_BSWAP_OP,

    //
    // Add/compare and exchange operators.
    //

    X86_XADD_OP,
    X86_CMPXCHG_OP,

    //
    // No operation.
    //

    X86_NOP_OP,

    //
    // Illegal opcode.
    //

    X86_ILL_OP,
    X86_MAXIMUM_INDEX
} XM_FUNCTION_TABLE_INDEX;

//
// Define 8-bit register numbers.
//

typedef enum _X86_8BIT_REGISTER {
    AL,
    CL,
    DL,
    BL,
    AH,
    CH,
    DH,
    BH
} X86_8BIT_REGISTER;

//
// Define 16-bit register numbers.
//

typedef enum _X86_16BIT_REGISTER {
    AX,
    CX,
    DX,
    BX,
    SP,
    BP,
    SI,
    DI
} X86_16BIT_REGISTER;

//
// Define 32-bit register numbers.
//

typedef enum _X86_32BIT_REGISTER {
    EAX,
    ECX,
    EDX,
    EBX,
    ESP,
    EBP,
    ESI,
    EDI
} X86_32BIT_REGISTER;

//
// Define general register structure.
//

typedef union _X86_GENERAL_REGISTER {
    ULONG Exx;
    union {
        USHORT Xx;
        struct {
            UCHAR Xl;
            UCHAR Xh;
        };
    };
} X86_GENERAL_REGISTER, *PX86_GENERAL_REGISTER;

//
// Define segment register numbers.
//

typedef enum _X86_SEGMENT_REGISTER {
    ES,
    CS,
    SS,
    DS,
    FS,
    GS
} X86_SEGMENT_REGISTER;

//
// Define instruction format types.
//

typedef enum _XM_FORMAT_TYPE {

    //
    // N.B. These format codes MUST be the first codes and MUST be
    //      exactly in this order since the ordering corresponds to
    //      segment numbers.
    //

    FormatSegmentES,
    FormatSegmentCS,
    FormatSegmentSS,
    FormatSegmentDS,
    FormatSegmentFS,
    FormatSegmentGS,

    //
    // N.B. These format codes MUST be the second codes and MUST be
    //      exactly in this order since the ordering corresponds to
    //      biased segment number. The entry for the code segment is
    //      a dummy entry to make the indexing work right.
    //

    FormatLoadSegmentES,
    FormatLoadSegmentCS,
    FormatLoadSegmentSS,
    FormatLoadSegmentDS,
    FormatLoadSegmentFS,
    FormatLoadSegmentGS,

    //
    // The following codes can be in any order.
    //

    FormatGroup1General,
    FormatGroup1Immediate,
    FormatGroup2By1,
    FormatGroup2ByCL,
    FormatGroup2ByByte,
    FormatGroup3General,
    FormatGroup4General,
    FormatGroup5General,
    FormatGroup8BitOffset,
    FormatOpcodeRegister,
    FormatLongJump,
    FormatShortJump,
    FormatSetccByte,
    FormatAccumImmediate,
    FormatAccumRegister,
    FormatMoveGeneral,
    FormatMoveImmediate,
    FormatMoveRegImmediate,
    FormatSegmentOffset,
    FormatMoveSegment,
    FormatMoveXxGeneral,
    FormatFlagsRegister,
    FormatPushImmediate,
    FormatPopGeneral,
    FormatImulImmediate,
    FormatStringOperands,
    FormatEffectiveOffset,
    FormatImmediateJump,
    FormatImmediateEnter,
    FormatGeneralBitOffset,
    FormatShiftDouble,
    FormatPortImmediate,
    FormatPortDX,
    FormatBitScanGeneral,
    FormatByteImmediate,
    FormatXlatOpcode,
    FormatGeneralRegister,
    FormatNoOperands,
    FormatOpcodeEscape,
    FormatPrefixOpcode
} XM_FORMAT_TYPE;

//
// Defined opcode modifier bit masks.
//

#define WIDTH_BIT 0x1                   // operand size control
#define DIRECTION_BIT 0x2               // direction of operation
#define SIGN_BIT 0x2                    // sign extended byte

//
// Define prefix opcode function index values.
//

typedef enum _XM_PREFIX_FUNCTION_INDEX {
    X86_ES_OP = ES,
    X86_CS_OP = CS,
    X86_SS_OP = SS,
    X86_DS_OP = DS,
    X86_FS_OP = FS,
    X86_GS_OP = GS,
    X86_LOCK_OP,
    X86_ADSZ_OP,
    X86_OPSZ_OP,
    X86_REPZ_OP,
    X86_REPNZ_OP
} XM_PREFIX_FUNCTION_INDEX;

//
// Define two byte opcode escape.
//

#define TWO_BYTE_ESCAPE 0x0f

//
// Define opcode control table structure.
//
// This table controls the decoding of instructions and there operands.
//

typedef struct _OPCODE_CONTROL {
    UCHAR FunctionIndex;
    UCHAR FormatType;
} OPCODE_CONTROL, *POPCODE_CONTROL;

//
// Define emulator context structure.
//
// This structure holds the global emulator state.
//

typedef struct _XM_CONTEXT {

    //
    // Pointers to the opcode control table and the opcode name table.
    //

    const OPCODE_CONTROL *OpcodeControlTable;
    const CHAR **OpcodeNameTable;

    //
    // x86 extended flags register.
    //

    union {
        UCHAR AhFlags;
        USHORT Flags;
        ULONG AllFlags;
        struct {
            ULONG EFLAG_CF : 1;
            ULONG EFLAG_MBO : 1;
            ULONG EFLAG_PF : 1;
            ULONG EFLAG_SBZ0 : 1;
            ULONG EFLAG_AF : 1;
            ULONG EFLAG_SBZ1 : 1;
            ULONG EFLAG_ZF : 1;
            ULONG EFLAG_SF : 1;
            ULONG EFLAG_TF : 1;
            ULONG EFLAG_IF : 1;
            ULONG EFLAG_DF : 1;
            ULONG EFLAG_OF : 1;
            ULONG EFLAG_IOPL : 2;
            ULONG EFLAG_NT : 1;
            ULONG EFLAG_SBZ2 : 1;
            ULONG EFLAG_RF : 1;
            ULONG EFLAG_VM : 1;
            ULONG EFLAG_AC : 1;
            ULONG EFLAG_SBZ3 : 13;
        } Eflags;
    };

    //
    // x86 instruction pointer.
    //

    union {
        USHORT Ip;
        ULONG Eip;
    };

    //
    // x86 general registers.
    //

    X86_GENERAL_REGISTER Gpr[8];

    //
    // x86 segment registers.
    //

    USHORT SegmentRegister[6];

    //
    // Emulator segment descriptors.
    //

    USHORT SegmentLimit[6];

    //
    // Instruction opcode control information read from the opcode
    // control table.
    //

    OPCODE_CONTROL OpcodeControl;

    //
    // Call or jmp destination segment segment.
    //

    USHORT DstSegment;

    //
    // Source and destination address and value.
    //

    union {
        UCHAR UNALIGNED *DstByte;
        USHORT UNALIGNED *DstWord;
        ULONG UNALIGNED *DstLong;
    };

    union {
        UCHAR UNALIGNED *SrcByte;
        USHORT UNALIGNED *SrcWord;
        ULONG UNALIGNED *SrcLong;
    };

    union {
        UCHAR Byte;
        ULONG Long;
        USHORT Word;
    } DstValue;

    union {
        UCHAR Byte;
        ULONG Long;
        USHORT Word;
    } SrcValue;

    //
    // Current opcode, data segment register to be used to access
    // data operands, function index, and operand data type, and
    // effective address offset.
    //

    ULONG CurrentOpcode;
    ULONG DataSegment;
    ULONG DataType;
    ULONG FunctionIndex;
    ULONG Offset;

    //
    // Prefix control information.
    //

    BOOLEAN LockPrefixActive;
    BOOLEAN OpaddrPrefixActive;
    BOOLEAN OpsizePrefixActive;
    BOOLEAN RepeatPrefixActive;
    BOOLEAN SegmentPrefixActive;
    UCHAR RepeatZflag;

    //
    // Effective address computation control.
    //

    BOOLEAN RegisterOffsetAddress;
    BOOLEAN ComputeOffsetAddress;

    //
    // Shift count.
    //

    UCHAR Shift;

    //
    // Jump buffer.
    //

    _JBTYPE JumpBuffer[_JBLEN];

    //
    // Address of read I/O space, write I/O space, and translation address
    // routines.
    //

    PXM_READ_IO_SPACE ReadIoSpace;
    PXM_WRITE_IO_SPACE WriteIoSpace;
    PXM_TRANSLATE_ADDRESS TranslateAddress;
} XM_CONTEXT, *PXM_CONTEXT, *RESTRICTED_POINTER PRXM_CONTEXT;

//
// Define opcode function and decode operand types.
//

typedef
ULONG
(*POPERAND_DECODE) (
    IN PRXM_CONTEXT P
    );

typedef
VOID
(*POPCODE_FUNCTION) (
    IN PRXM_CONTEXT P
    );

//
// Operand decode prototypes.
//

ULONG
XmPushPopSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmLoadSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup1General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup1Immediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2By1 (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2ByCL (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2ByByte (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup3General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup45General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup8BitOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmOpcodeRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmLongJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmShortJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmSetccByte (
    IN PRXM_CONTEXT P
    );

ULONG
XmAccumImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmAccumRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveRegImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmSegmentOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveXxGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmFlagsRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmPushImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPopGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmImulImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmStringOperands (
    IN PRXM_CONTEXT P
    );

ULONG
XmEffectiveOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmImmediateJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmImmediateEnter (
    IN PRXM_CONTEXT P
    );

ULONG
XmGeneralBitOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmShiftDouble (
    IN PRXM_CONTEXT P
    );

ULONG
XmPortImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPortDX (
    IN PRXM_CONTEXT P
    );

ULONG
XmBitScanGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmByteImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmXlatOpcode (
    IN PRXM_CONTEXT P
    );

ULONG
XmGeneralRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmOpcodeEscape (
    IN PRXM_CONTEXT P
    );

ULONG
XmPrefixOpcode (
    IN PRXM_CONTEXT P
    );

ULONG
XmNoOperands (
    IN PRXM_CONTEXT P
    );

//
// Define miscellaneous prototypes.
//

ULONG
XmComputeParity (
    IN ULONG Result
    );

XM_STATUS
XmEmulateStream (
    IN PRXM_CONTEXT P,
    USHORT Segment,
    USHORT Offset,
    PXM86_CONTEXT Context
    );

UCHAR
XmGetCodeByte (
    IN PRXM_CONTEXT P
    );

UCHAR
XmGetByteImmediate (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetByteImmediateToWord (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetByteImmediateToLong (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetSignedByteImmediateToWord (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetSignedByteImmediateToLong (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetWordImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetLongImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPopStack (
    IN PRXM_CONTEXT P
    );

VOID
XmPushStack (
    IN PRXM_CONTEXT P,
    IN ULONG Value
    );

VOID
XmSetDataType (
    IN PRXM_CONTEXT P
    );

VOID
XmStoreResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

//
// Define operand specifier prototypes.
//

PVOID
XmEvaluateAddressSpecifier (
    IN PRXM_CONTEXT P,
    OUT PLONG Register
    );

PVOID
XmGetOffsetAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Offset
    );

PVOID
XmGetRegisterAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Number
    );

PVOID
XmGetStringAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Segment,
    IN ULONG Register
    );

VOID
XmSetDestinationValue (
    IN PRXM_CONTEXT P,
    IN PVOID Destination
    );

VOID
XmSetSourceValue (
    IN PRXM_CONTEXT P,
    IN PVOID Source
    );

ULONG
XmGetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG ByteFlag
    );

VOID
XmSetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    );

//
// ASCII operators.
//

VOID
XmAaaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAadOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAamOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAasOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDaaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDasOp (
    IN PRXM_CONTEXT P
    );

//
// Group 1 operations.
//

VOID
XmAddOp (
    IN PRXM_CONTEXT P
    );

VOID
XmOrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAdcOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSbbOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAndOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSubOp (
    IN PRXM_CONTEXT P
    );

VOID
XmXorOp (
    IN PRXM_CONTEXT P
    );

VOID
XmCmpOp (
    IN PRXM_CONTEXT P
    );

//
// Group 2 operations.
//

VOID
XmRolOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRorOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRclOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRcrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmShlOp (
    IN PRXM_CONTEXT P
    );

VOID
XmShrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSarOp (
    IN PRXM_CONTEXT P
    );

//
// Group 3 operations.
//

VOID
XmTestOp (
    IN PRXM_CONTEXT P
    );

VOID
XmNotOp (
    IN PRXM_CONTEXT P
    );

VOID
XmNegOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDivOp (
    IN PRXM_CONTEXT P
    );

VOID
XmIdivOp (
    IN PRXM_CONTEXT P
    );

VOID
XmImulOp (
    IN PRXM_CONTEXT P
    );

VOID
XmImulxOp (
    IN PRXM_CONTEXT P
    );

VOID
XmMulOp (
    IN PRXM_CONTEXT P
    );

//
// Group 4 and 5 operators.
//

VOID
XmIncOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDecOp (
    IN PRXM_CONTEXT P
    );

VOID
XmCallOp (
    PRXM_CONTEXT P
    );

VOID
XmJmpOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPushOp (
    IN PRXM_CONTEXT P
    );

//
// Group 8 operators.
//

VOID
XmBtOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtsOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtcOp (
    IN PRXM_CONTEXT P
    );

//
// Stack operations.
//

VOID
XmPopOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPushaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPopaOp (
    IN PRXM_CONTEXT P
    );

//
// Conditional jump and set conditional operations.
//

VOID
XmJxxOp (
    IN PRXM_CONTEXT P
    );

VOID
XmLoopOp (
    IN PRXM_CONTEXT P
    );

VOID
XmJcxzOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSxxOp (
    IN PRXM_CONTEXT P
    );

//
// Condition code operations.
//

VOID
XmClcOp (
    PRXM_CONTEXT P
    );

VOID
XmCldOp (
    PRXM_CONTEXT P
    );

VOID
XmCliOp (
    PRXM_CONTEXT P
    );

VOID
XmCmcOp (
    PRXM_CONTEXT P
    );

VOID
XmStcOp (
    PRXM_CONTEXT P
    );

VOID
XmStdOp (
    PRXM_CONTEXT P
    );

VOID
XmStiOp (
    PRXM_CONTEXT P
    );

VOID
XmLahfOp (
    PRXM_CONTEXT P
    );

VOID
XmSahfOp (
    PRXM_CONTEXT P
    );

//
// Move operations.
//

VOID
XmMovOp (
    PRXM_CONTEXT P
    );

VOID
XmXchgOp (
    PRXM_CONTEXT P
    );

//
// Convert operations.
//

VOID
XmCbwOp (
    PRXM_CONTEXT P
    );

VOID
XmCwdOp (
    PRXM_CONTEXT P
    );

//
// Control operations.
//

VOID
XmEnterOp (
    PRXM_CONTEXT P
    );

VOID
XmHltOp (
    PRXM_CONTEXT P
    );

VOID
XmIntOp (
    PRXM_CONTEXT P
    );

VOID
XmIretOp (
    PRXM_CONTEXT P
    );

VOID
XmLeaveOp (
    PRXM_CONTEXT P
    );

VOID
XmRetOp (
    PRXM_CONTEXT P
    );

//
// String operations.
//

VOID
XmCmpsOp (
    PRXM_CONTEXT P
    );

VOID
XmInsOp (
    PRXM_CONTEXT P
    );

VOID
XmLodsOp (
    PRXM_CONTEXT P
    );

VOID
XmMovsOp (
    PRXM_CONTEXT P
    );

VOID
XmOutsOp (
    PRXM_CONTEXT P
    );

VOID
XmScasOp (
    PRXM_CONTEXT P
    );

VOID
XmStosOp (
    PRXM_CONTEXT P
    );

//
// Shift double operators.
//

VOID
XmShldOp (
    PRXM_CONTEXT P
    );

VOID
XmShrdOp (
    PRXM_CONTEXT P
    );

//
// I/O operators.
//

VOID
XmInOp (
    PRXM_CONTEXT P
    );

VOID
XmOutOp (
    PRXM_CONTEXT P
    );

//
// Bit scan operators.
//

VOID
XmBsfOp (
    PRXM_CONTEXT P
    );

VOID
XmBsrOp (
    PRXM_CONTEXT P
    );

//
// MIscellaneous operations.
//

VOID
XmXaddOp (
    PRXM_CONTEXT P
    );

VOID
XmBoundOp (
    PRXM_CONTEXT P
    );

VOID
XmBswapOp (
    PRXM_CONTEXT P
    );

VOID
XmCmpxchgOp (
    PRXM_CONTEXT P
    );

VOID
XmIllOp (
    PRXM_CONTEXT P
    );

VOID
XmNopOp (
    PRXM_CONTEXT P
    );

//
// PCI Bios emulation routines.
//

#if !defined(_PURE_EMULATION_)

BOOLEAN
XmExecuteInt1a (
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aPciBiosPresent(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aFindPciClassCode(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aFindPciDevice(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aGenerateSpecialCycle(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aGetRoutingOptions(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aSetPciIrq(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aReadConfigRegister(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aWriteConfigRegister(
    IN OUT PRXM_CONTEXT Context
    );

#endif

//
// Debug routines.
//

#if XM_DEBUG

#include "stdio.h"
//#define DEBUG_PRINT(_X_) DbgPrint _X_
#define DEBUG_PRINT(_X_) printf _X_

VOID
XmTraceDestination (
    IN PRXM_CONTEXT P,
    IN ULONG Destination
    );

VOID
XmTraceFlags (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceInstruction (
    IN XM_OPERATION_DATATYPE DataType,
    IN ULONG Instruction
    );

VOID
XmTraceJumps (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceOverride (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceRegisters (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

VOID
XmTraceSpecifier (
    IN UCHAR Specifier
    );

VOID
XmTraceSource (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    );

#else

#define XmTraceDestination(P, Destination)
#define XmTraceInstruction(DataType, Instruction)
#define XmTraceFlags(P)
#define XmTraceJumps(P)
#define XmTraceOverride(P)
#define XmTraceRegisters(P)
#define XmTraceResult(P, Result)
#define XmTraceSpecifier(Specifier)
#define XmTraceSource(P, Source)

#endif

//
// Define global data.
//

extern XM_CONTEXT XmContext;
extern BOOLEAN XmEmulatorInitialized;
extern const OPCODE_CONTROL XmOpcodeControlTable1[];
extern const OPCODE_CONTROL XmOpcodeControlTable2[];
extern const POPCODE_FUNCTION XmOpcodeFunctionTable[];
extern const POPERAND_DECODE XmOperandDecodeTable[];

#if !defined(_PURE_EMULATION)

extern UCHAR XmNumberPciBusses;
extern BOOLEAN XmPciBiosPresent;
extern PGETSETPCIBUSDATA XmGetPciData;
extern PGETSETPCIBUSDATA XmSetPciData;

#endif

#if XM_DEBUG

extern ULONG XmDebugFlags;
extern const PCHAR XmOpcodeNameTable1[];
extern const PCHAR XmOpcodeNameTable2[];

#endif

#endif // _EMULATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\dfsfsctl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       dfsfsctl.h
//
//  Contents:   The FsControl codes, data structures, and names needed for
//              communication between user-level code and the Dfs kernel
//              driver.
//
//  Classes:    None
//
//  Functions:
//
//-----------------------------------------------------------------------------

#ifndef _DFSFSCTL_
#define _DFSFSCTL_
//
//  Distributed file service file control code and structure declarations
//

//
// The name of the Dfs driver file system device for server and client
//
#define DFS_DRIVER_NAME L"\\Dfs"
#define DFS_SERVER_NAME L"\\DfsServer"

//
// The name of the NT object directory under which Dfs creates its own
// devices.
//

#define DD_DFS_DEVICE_DIRECTORY L"\\Device\\WinDfs"

//
// The canonical device Dfs creates for fielding file open requests.
//

#define DD_DFS_DEVICE_NAME      L"Root"

// The following three context definitions are values that are used by the
// DFS driver to distinguish opens to the underlying provider.
// The first two DFS_OPEN_CONTEXT,DFS_DOWNLEVEL_OPEN_CONTEXT are passed in the
// the FsContext2 field while the DFS_NAME_CONTEXT pointer is passed in the
// FsContext field of the FILE_OBJECT
//
// Sundown Notes: Because these values are stored in PVOID, the way these 
//                values are defined and how the compiler extends them to PVOIDs
//                should be considered. They are now considered as const unsigned int. 
//                Note also that these values are unaligned and cannot be returned by 
//                any memory allocator or coming from the stack. If the "unaligned" point
//                becomes incorrect in the future or if FsContext2 or FsContext fields are
//                tested in any way in terms of pointer address range validity, we should 
//                revisit the following statement:
//                These values should be zero-extended when stored to PVOIDs.
//

#define DFS_OPEN_CONTEXT                        0xFF444653
#define DFS_DOWNLEVEL_OPEN_CONTEXT              0x11444653
#define DFS_CSCAGENT_NAME_CONTEXT               0xaaaaaaaa
#define DFS_USER_NAME_CONTEXT                   0xbbbbbbbb
#define DFS_FLAG_LAST_ALTERNATE                 0x00000001


typedef struct _DFS_NAME_CONTEXT_ {
    UNICODE_STRING  UNCFileName;
    LONG            NameContextType;
    ULONG           Flags;
    PVOID           pDfsTargetInfo;     // Pointer to dfs crafted target info
    PVOID           pLMRTargetInfo;     // pointer to lmr crafted target info
} DFS_NAME_CONTEXT, *PDFS_NAME_CONTEXT;

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define FSCTL_DFS_BASE                  FILE_DEVICE_DFS

//
//  DFS FSCTL operations.  When a passed-in buffer contains pointers, and the caller
//   is not KernelMode, the passed-in pointer value is set relative to the beginning of
//   the buffer.  They must be adjusted before use.  If the caller mode was KernelMode,
//   pointers should be used as is.
//
//

//
// These are the fsctl codes used by the srvsvc to implement the I_NetDfsXXX
// calls.
//

#define FSCTL_DFS_CREATE_LOCAL_PARTITION    CTL_CODE(FSCTL_DFS_BASE, 8, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DELETE_LOCAL_PARTITION    CTL_CODE(FSCTL_DFS_BASE, 9, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_SET_LOCAL_VOLUME_STATE    CTL_CODE(FSCTL_DFS_BASE, 10, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_SET_SERVER_INFO           CTL_CODE(FSCTL_DFS_BASE, 24, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_CREATE_EXIT_POINT         CTL_CODE(FSCTL_DFS_BASE, 29, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DELETE_EXIT_POINT         CTL_CODE(FSCTL_DFS_BASE, 30, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_MODIFY_PREFIX             CTL_CODE(FSCTL_DFS_BASE, 38, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_FIX_LOCAL_VOLUME          CTL_CODE(FSCTL_DFS_BASE, 39, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_FLUSH_CACHE           CTL_CODE(FSCTL_DFS_BASE, 2044, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_FLUSH_SPC_CACHE       CTL_CODE(FSCTL_DFS_BASE, 2051, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_GET_PKT_ENTRY_STATE       CTL_CODE(FSCTL_DFS_BASE, 2031, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_SET_PKT_ENTRY_STATE       CTL_CODE(FSCTL_DFS_BASE, 2032, METHOD_BUFFERED, FILE_WRITE_DATA)

//
// These are the fsctl codes used by the SMB server to support shares in the
// Dfs
//

#define FSCTL_DFS_TRANSLATE_PATH            CTL_CODE(FSCTL_DFS_BASE, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_REFERRALS             CTL_CODE(FSCTL_DFS_BASE, 101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_REPORT_INCONSISTENCY      CTL_CODE(FSCTL_DFS_BASE, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_IS_SHARE_IN_DFS           CTL_CODE(FSCTL_DFS_BASE, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_IS_ROOT                   CTL_CODE(FSCTL_DFS_BASE, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_VERSION               CTL_CODE(FSCTL_DFS_BASE, 105, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_FIND_SHARE                CTL_CODE(FSCTL_DFS_BASE, 108, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These are the fsctl codes supported by the Dfs client to identify quickly
// whether paths are in the Dfs or not.
//

#define FSCTL_DFS_IS_VALID_PREFIX           CTL_CODE(FSCTL_DFS_BASE, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_IS_VALID_LOGICAL_ROOT     CTL_CODE(FSCTL_DFS_BASE, 107, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These are the fsctl codes used by the Dfs Manager / Dfs Service to
// manipulate the Dfs.
//

#define FSCTL_DFS_STOP_DFS                  CTL_CODE(FSCTL_DFS_BASE, 3, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_START_DFS                 CTL_CODE(FSCTL_DFS_BASE, 6, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_INIT_LOCAL_PARTITIONS     CTL_CODE(FSCTL_DFS_BASE, 7, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_SET_SERVICE_STATE         CTL_CODE(FSCTL_DFS_BASE, 11, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DC_SET_VOLUME_STATE       CTL_CODE(FSCTL_DFS_BASE, 12, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_SET_VOLUME_TIMEOUT        CTL_CODE(FSCTL_DFS_BASE, 13, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_IS_CHILDNAME_LEGAL        CTL_CODE(FSCTL_DFS_BASE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_CREATE_ENTRY          CTL_CODE(FSCTL_DFS_BASE, 16, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_CREATE_SUBORDINATE_ENTRY  CTL_CODE(FSCTL_DFS_BASE, 17, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_CHECK_STGID_IN_USE        CTL_CODE(FSCTL_DFS_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_SET_RELATION_INFO     CTL_CODE(FSCTL_DFS_BASE, 22, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_GET_SERVER_INFO           CTL_CODE(FSCTL_DFS_BASE, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PKT_DESTROY_ENTRY         CTL_CODE(FSCTL_DFS_BASE, 26, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_GET_RELATION_INFO     CTL_CODE(FSCTL_DFS_BASE, 27, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_CHECK_REMOTE_PARTITION    CTL_CODE(FSCTL_DFS_BASE, 34, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_VERIFY_REMOTE_VOLUME_KNOWLEDGE CTL_CODE(FSCTL_DFS_BASE, 35, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_VERIFY_LOCAL_VOLUME_KNOWLEDGE CTL_CODE(FSCTL_DFS_BASE, 36, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_PRUNE_LOCAL_PARTITION     CTL_CODE(FSCTL_DFS_BASE, 37, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_SET_DC_NAME           CTL_CODE(FSCTL_DFS_BASE, 41, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_CREATE_SITE_INFO          CTL_CODE(FSCTL_DFS_BASE, 56, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DELETE_SITE_INFO          CTL_CODE(FSCTL_DFS_BASE, 57, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SRV_DFSSRV_CONNECT            CTL_CODE(FSCTL_DFS_BASE, 58, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SRV_DFSSRV_IPADDR             CTL_CODE(FSCTL_DFS_BASE, 59, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_CREATE_IP_INFO            CTL_CODE(FSCTL_DFS_BASE, 60, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DELETE_IP_INFO            CTL_CODE(FSCTL_DFS_BASE, 61, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_CREATE_SPECIAL_INFO       CTL_CODE(FSCTL_DFS_BASE, 62, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DELETE_SPECIAL_INFO       CTL_CODE(FSCTL_DFS_BASE, 63, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_CREATE_FTDFS_INFO         CTL_CODE(FSCTL_DFS_BASE, 64, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_DELETE_FTDFS_INFO         CTL_CODE(FSCTL_DFS_BASE, 66, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_ISDC                      CTL_CODE(FSCTL_DFS_BASE, 67, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_ISNOTDC                   CTL_CODE(FSCTL_DFS_BASE, 68, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_RESET_PKT                 CTL_CODE(FSCTL_DFS_BASE, 69, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_SET_DOMAINNAMEFLAT    CTL_CODE(FSCTL_DFS_BASE, 71, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_PKT_SET_DOMAINNAMEDNS     CTL_CODE(FSCTL_DFS_BASE, 72, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_SPECIAL_SET_DC            CTL_CODE(FSCTL_DFS_BASE, 74, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_REREAD_REGISTRY           CTL_CODE(FSCTL_DFS_BASE, 75, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_GET_CONNECTION_PERF_INFO  CTL_CODE(FSCTL_DFS_BASE, 76, METHOD_BUFFERED, FILE_ANY_ACCESS)

// this fsctl tells the DFS that a server has gone offline or come online
// At present, it is issued by the CSC agent thread in winlogon
#define FSCTL_DFS_CSC_SERVER_OFFLINE        CTL_CODE(FSCTL_DFS_BASE, 77, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_CSC_SERVER_ONLINE         CTL_CODE(FSCTL_DFS_BASE, 78, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_SPC_REFRESH               CTL_CODE(FSCTL_DFS_BASE, 79, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_DFS_MARK_STALE_PKT_ENTRIES    CTL_CODE(FSCTL_DFS_BASE, 80, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_FLUSH_STALE_PKT_ENTRIES   CTL_CODE(FSCTL_DFS_BASE, 81, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_GET_NEXT_LONG_DOMAIN_NAME CTL_CODE(FSCTL_DFS_BASE, 82, METHOD_BUFFERED, FILE_WRITE_DATA)
//
// These are the fsctl codes used by the Dfs WNet provider to support the
// WNet APIs for Dfs
//

#define FSCTL_DFS_DEFINE_LOGICAL_ROOT       CTL_CODE(FSCTL_DFS_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_DELETE_LOGICAL_ROOT       CTL_CODE(FSCTL_DFS_BASE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_LOGICAL_ROOT_PREFIX   CTL_CODE(FSCTL_DFS_BASE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_CONNECTED_RESOURCES   CTL_CODE(FSCTL_DFS_BASE, 47, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_SERVER_NAME           CTL_CODE(FSCTL_DFS_BASE, 48, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_DEFINE_ROOT_CREDENTIALS   CTL_CODE(FSCTL_DFS_BASE, 49, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These are fsctl codes used by the Dfs Perfmon DLL
//

#define FSCTL_DFS_READ_METERS               CTL_CODE(FSCTL_DFS_BASE, 50, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These are fsctls useful for testing Dfs
//

#define FSCTL_DFS_SHUFFLE_ENTRY             CTL_CODE(FSCTL_DFS_BASE, 51, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_DFS_GET_FIRST_SVC             CTL_CODE(FSCTL_DFS_BASE, 52, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_NEXT_SVC              CTL_CODE(FSCTL_DFS_BASE, 53, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_ENTRY_TYPE            CTL_CODE(FSCTL_DFS_BASE, 54, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_PKT                   CTL_CODE(FSCTL_DFS_BASE, 70, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_GET_SPC_TABLE             CTL_CODE(FSCTL_DFS_BASE, 73, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These are the fsctl codes that might be useful in the future.
//

#define FSCTL_DFS_NAME_RESOLVE          CTL_CODE(FSCTL_DFS_BASE, 25, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFS_SET_DOMAIN_GLUON      CTL_CODE(FSCTL_DFS_BASE, 20, METHOD_BUFFERED, FILE_WRITE_DATA)

//
// Registry key/value for site coverage
//
#define REG_KEY_COVERED_SITES   L"SYSTEM\\CurrentControlSet\\Services\\DfsDriver\\CoveredSites"
#define REG_VALUE_COVERED_SITES L"CoveredSites"

typedef struct _DFS_IPADDRESS {
    USHORT  IpFamily;        // probably AF_INET == 2
    USHORT  IpLen;           // # bytes that count in IpData
    CHAR    IpData[14];      // IpLen bytes used
} DFS_IPADDRESS, *PDFS_IPADDRESS;

#ifdef  MIDL_PASS
#define DFSMIDLSTRING  [string] LPWSTR
#define DFSSIZEIS      [size_is(Count)]
#else
#define DFSMIDLSTRING  LPWSTR
#define DFSSIZEIS
#endif

//  FSCTL_DFS_IS_VALID_PREFIX    Input Buffer
//  The length values are in bytes.
typedef struct {
    BOOLEAN                         CSCAgentCreate;
    SHORT                           RemoteNameLen;
    WCHAR                           RemoteName[1];
} DFS_IS_VALID_PREFIX_ARG, *PDFS_IS_VALID_PREFIX_ARG;

//  FSCTL_DFS_GET_PKT_ENTRY_STATE Input Buffer
//  All the strings appear in Buffer in the same order as the length fields. The strings
//  are not NULL terminated. The length values are in bytes.
typedef struct {
    SHORT                           DfsEntryPathLen;
    SHORT                           ServerNameLen;
    SHORT                           ShareNameLen;
    ULONG                           Level;
    WCHAR                           Buffer[1];
} DFS_GET_PKT_ENTRY_STATE_ARG, *PDFS_GET_PKT_ENTRY_STATE_ARG;

//  FSCTRL_DFS_SET_PKT_ENTRY_STATE Input Buffer
//  All the strings appear in Buffer in the same order as the length fields. The strings
//  are not NULL terminated. The length values are in bytes.
typedef struct {
    SHORT                           DfsEntryPathLen;
    SHORT                           ServerNameLen;
    SHORT                           ShareNameLen;
    ULONG                           Level;
    union {
        ULONG                           State;          // DFS_INFO_101
        ULONG                           Timeout;        // DFS_INFL_102
    };
    WCHAR                           Buffer[1];
} DFS_SET_PKT_ENTRY_STATE_ARG, *PDFS_SET_PKT_ENTRY_STATE_ARG;

// FSCTL_DFS_PKT_CREATE_SPECIAL_NAMES Input Buffer:
typedef struct {
    ULONG                           Count;
    LPWSTR                          SpecialName;
    LPWSTR                          *ExpandedNames;
} DFS_SPECIAL_NAME_CONTAINER, *PDFS_SPECIAL_NAME_CONTAINER;

typedef struct {
    ULONG Count;
    PDFS_SPECIAL_NAME_CONTAINER     *SpecialNameContainers;
} DFS_PKT_CREATE_SPECIAL_NAMES_ARG, *PDFS_PKT_CREATE_SPECIAL_NAMES_ARG;

typedef struct {
    GUID            Uid;
    DFSMIDLSTRING   Prefix;
} NET_DFS_ENTRY_ID, *LPNET_DFS_ENTRY_ID;

typedef struct {
    ULONG Count;
    DFSSIZEIS LPNET_DFS_ENTRY_ID Buffer;
} NET_DFS_ENTRY_ID_CONTAINER, *LPNET_DFS_ENTRY_ID_CONTAINER;


// FSCTL_DFS_CREATE_LOCAL_PARTITION Input Buffer:
typedef struct {
    LPWSTR                          ShareName;
    LPWSTR                          SharePath;
    GUID                            EntryUid;
    LPWSTR                          EntryPrefix;
    LPWSTR                          ShortName;
    LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo;
    BOOLEAN                         Force;
} *PDFS_CREATE_LOCAL_PARTITION_ARG;


// FSCTL_DFS_DELETE_LOCAL_PARTITION Input Buffer:
typedef struct {
    GUID    Uid;
    LPWSTR  Prefix;
} *PDFS_DELETE_LOCAL_PARTITION_ARG;


// FSCTL_DFS_SET_LOCAL_VOLUME_STATE Input Buffer
typedef struct {
    GUID    Uid;
    LPWSTR  Prefix;
    ULONG   State;
} *PDFS_SET_LOCAL_VOLUME_STATE_ARG;

// FSCTL_DFS_SET_SERVER_INFO Input Buffer
typedef struct {
    GUID    Uid;
    LPWSTR  Prefix;
} *PDFS_SET_SERVER_INFO_ARG;


// FSCTL_DFS_CREATE_EXIT_POINT Input Buffer
typedef struct {
    GUID    Uid;
    LPWSTR  Prefix;
    ULONG   Type;
} *PDFS_CREATE_EXIT_POINT_ARG;


// FSCTL_DFS_DELETE_EXIT_POINT Input Buffer
typedef struct {
    GUID    Uid;
    LPWSTR  Prefix;
    ULONG   Type;
} *PDFS_DELETE_EXIT_POINT_ARG;


// FSCTL_DFS_MODIFY_PREFIX Input Buffer
typedef struct {
    GUID    Uid;
    LPWSTR  Prefix;
} *PDFS_MODIFY_PREFIX_ARG;


// FSCTL_DFS_FIX_LOCAL_VOLUME Input Buffer
typedef struct {
    LPWSTR                          VolumeName;
    ULONG                           EntryType;
    ULONG                           ServiceType;
    LPWSTR                          StgId;
    GUID                            EntryUid;
    LPWSTR                          EntryPrefix;
    LPWSTR                          ShortPrefix;
    LPNET_DFS_ENTRY_ID_CONTAINER    RelationInfo;
    ULONG                           CreateDisposition;
} *PDFS_FIX_LOCAL_VOLUME_ARG;


// FSCTL_DFS_TRANSLATE_PATH Input Buffer
typedef struct {
    ULONG                           Flags;
    UNICODE_STRING                  SubDirectory;
    UNICODE_STRING                  ParentPathName;
    UNICODE_STRING                  DfsPathName;
} DFS_TRANSLATE_PATH_ARG, *PDFS_TRANSLATE_PATH_ARG;

#define DFS_TRANSLATE_STRIP_LAST_COMPONENT      1

// FSCTL_DFS_FIND_SHARE Input Buffer
typedef struct {
    UNICODE_STRING                  ShareName;
} DFS_FIND_SHARE_ARG, *PDFS_FIND_SHARE_ARG;

// FSCTL_DFS_CREATE_SITE_INFO Input Buffer:
typedef struct {
    UNICODE_STRING                  ServerName;
    ULONG                           SiteCount;
    UNICODE_STRING                  SiteName[1];    // actually SiteCount
} DFS_CREATE_SITE_INFO_ARG, *PDFS_CREATE_SITE_INFO_ARG;

// FSCTL_DFS_DELETE_SITE_INFO Input Buffer:
typedef struct {
    UNICODE_STRING                  ServerName;
} DFS_DELETE_SITE_INFO_ARG, *PDFS_DELETE_SITE_INFO_ARG;

// FSCTL_DFS_CREATE_IP_INFO Input Buffer:
typedef struct {
    DFS_IPADDRESS                   IpAddress;
    UNICODE_STRING                  SiteName;
} DFS_CREATE_IP_INFO_ARG, *PDFS_CREATE_IP_INFO_ARG;

// FSCTL_DFS_DELETE_IP_INFO Input Buffer:
typedef struct {
    DFS_IPADDRESS                   IpAddress;
} DFS_DELETE_IP_INFO_ARG, *PDFS_DELETE_IP_INFO_ARG;

// FSCTL_DFS_CREATE_SPECIAL_INFO Input Buffer:
typedef struct {
    UNICODE_STRING                  SpecialName;
    ULONG                           Flags;
    ULONG                           TrustDirection;
    ULONG                           TrustType;
    ULONG                           Timeout;
    LONG                            NameCount;
    UNICODE_STRING                  Name[1];    // actually NameCount
} DFS_CREATE_SPECIAL_INFO_ARG, *PDFS_CREATE_SPECIAL_INFO_ARG;

// Flags for FSCTL_DFS_CREATE_SPECIAL_INFO
#define DFS_SPECIAL_INFO_PRIMARY      0x00000001
#define DFS_SPECIAL_INFO_NETBIOS      0x00000002

// FSCTL_DFS_DELETE_SPECIAL_INFO Input Buffer:
typedef struct {
    UNICODE_STRING                  SpecialName;
} DFS_DELETE_SPECIAL_INFO_ARG, *PDFS_DELETE_SPECIAL_INFO_ARG;

// FSCTL_SRV_DFSSRV_CONNECT Input Buffer:
typedef struct {
    UNICODE_STRING                  PortName;
} DFS_SRV_DFSSRV_CONNECT_ARG, *PDFS_SRV_DFSSRV_CONNECT_ARG;

// FSCTL_SRV_DFSSRV_IPADDR Input Buffer:
typedef struct {
    DFS_IPADDRESS                   IpAddress;
} DFS_SRV_DFSSRV_IPADDR_ARG, *PDFS_SRV_DFSSRV_IPADDR_ARG;

// FSCTL_DFS_GET_REFERRALS Input Buffer
typedef struct {
    UNICODE_STRING                  DfsPathName;
    ULONG                           MaxReferralLevel;
    DFS_IPADDRESS                   IpAddress;
} DFS_GET_REFERRALS_INPUT_ARG, *PDFS_GET_REFERRALS_INPUT_ARG;

// FSCTL_DFS_SPECIAL_SET_DC Input Buffer
typedef struct {
    UNICODE_STRING                  SpecialName;
    UNICODE_STRING                  DcName;
} DFS_SPECIAL_SET_DC_INPUT_ARG, *PDFS_SPECIAL_SET_DC_INPUT_ARG;

// FSCTL_DFS_GET_REFERRALS Output Buffer
// IoStatus.Information contains the amount of data returned
//
// The format of the Output Buffer is simply that of RESP_GET_DFS_REFERRAL,
// described in smbtrans.h
//

// FSCTL_DFS_REPORT_INCONSISTENCY Input Buffer
typedef struct {
    UNICODE_STRING DfsPathName;         // DFS path having inconsistency
    PCHAR Ref;                          // Actually, pointer to a DFS_REFERRAL_V1
} DFS_REPORT_INCONSISTENCY_ARG, *PDFS_REPORT_INCONSISTENCY_ARG;

// FSCTL_DFS_IS_SHARE_IN_DFS Input Buffer
typedef struct {
    union {
        USHORT  ServerType;                     // 0 == Don't know, 1 == SMB, 2 == Netware
        USHORT  ShareType;                      // On return, 0x1 == share is root of a Dfs
    };                                          // 0x2 == share is participating in Dfs
    UNICODE_STRING ShareName;           // Name of share
    UNICODE_STRING SharePath;           // Path of the share
} DFS_IS_SHARE_IN_DFS_ARG, *PDFS_IS_SHARE_IN_DFS_ARG;

#define DFS_SHARE_TYPE_ROOT             0x1
#define DFS_SHARE_TYPE_DFS_VOLUME       0x2

typedef struct {
    ULONG  EventType;
    LPWSTR DomainName;               // Name of domain
    LPWSTR DCName;                   // Path of the share
} DFS_SPC_REFRESH_INFO, *PDFS_SPC_REFRESH_INFO;


//
//FSCTL_DFS_GET_VERSION Input Buffer:
// This fsctl returns the version number of the Dfs driver installed on the
// machine.
typedef struct {
    ULONG Version;
} DFS_GET_VERSION_ARG, *PDFS_GET_VERSION_ARG;

//
// FSCTRL_DFS_GET_PKT address object
//
typedef struct {
    USHORT State;        // See below
    WCHAR ServerShare[1];    // Really a WSTR, UNICODE_NULL terminated
} DFS_PKT_ADDRESS_OBJECT, *PDFS_PKT_ADDRESS_OBJECT;

#define DFS_PKT_ADDRESS_OBJECT_ACTIVE   0x001
#define DFS_PKT_ADDRESS_OBJECT_OFFLINE  0x002

//
// FSCTRL_DFS_GET_PKT object
//
typedef struct {
    LPWSTR Prefix;
    LPWSTR ShortPrefix;
    ULONG Type;
    ULONG USN;
    ULONG ExpireTime;
    ULONG UseCount;
    GUID Uid;
    ULONG ServiceCount;
    PDFS_PKT_ADDRESS_OBJECT *Address;       // Array of DFS_PKT_ADDRESS_OBJECTS's, len ServiceCount
} DFS_PKT_ENTRY_OBJECT, *PDFS_PKT_ENTRY_OBJECT;

//
// FSCTRL_DFS_GET_PKT Output Buffer:
// This fsctl returns what is in the PKT
//
typedef struct {
    ULONG EntryCount;   
    DFS_PKT_ENTRY_OBJECT EntryObject[1];        // Really EntryCount
} DFS_GET_PKT_ARG, *PDFS_GET_PKT_ARG;


//  Standardized provider IDs as given in eProviderId

#define PROV_ID_LOCAL_FS        0x101   // generic local file system
#define PROV_ID_DFS_RDR         0x201   // Uplevel LanMan redirector
#define PROV_ID_MUP_RDR         0x202   // Mup
#define PROV_ID_LM_RDR          0x202   // Compatability
#define PROV_ID_LANM_RDR        0x203   // Downlevel LanMan redirector

//  Provider capabilities as given in fRefCapability and fProvCapability
#define PROV_DFS_RDR      2     // accepts NtCreateFile with EA Principal
#define PROV_STRIP_PREFIX 4     // strip file name prefix before redispatching
#define PROV_UNAVAILABLE  8     // provider unavailable - try to reattach.

//[ dfs_define_logical_root
//
//  Control structure for FSCTL_DFS_DEFINE_LOGICAL_ROOT

#define MAX_LOGICAL_ROOT_NAME   16

typedef struct _FILE_DFS_DEF_LOGICAL_ROOT_BUFFER {
    BOOLEAN     fForce;
    WCHAR       LogicalRoot[MAX_LOGICAL_ROOT_NAME];
    WCHAR       RootPrefix[1];
} FILE_DFS_DEF_ROOT_BUFFER, *PFILE_DFS_DEF_ROOT_BUFFER;

//
// FORCE definition needed for NetrDfsRemoveFtRoot
//

#define DFS_FORCE_REMOVE    0x80000000

//]

//[ dfs_define_root_credentials
//
//  Control structure for FSCTL_DFS_DEFINE_ROOT_CREDENTIALS. All the strings
//  appear in Buffer in the same order as the length fields. The strings
//  are not NULL terminated. The length values are in bytes.
//

typedef struct _FILE_DFS_DEF_ROOT_CREDENTIALS {
    BOOLEAN     CSCAgentCreate;
    USHORT      Flags;
    USHORT      DomainNameLen;
    USHORT      UserNameLen;
    USHORT      PasswordLen;
    USHORT      ServerNameLen;
    USHORT      ShareNameLen;
    USHORT      RootPrefixLen;
    WCHAR       LogicalRoot[MAX_LOGICAL_ROOT_NAME];
    WCHAR       Buffer[1];
} FILE_DFS_DEF_ROOT_CREDENTIALS, *PFILE_DFS_DEF_ROOT_CREDENTIALS;

#define DFS_DEFERRED_CONNECTION         1
#define DFS_USE_NULL_PASSWORD           2

//]

//----------------------------------------------------------------------------
//
// Everything below here is to support the old Dfs design.
//

#define EA_NAME_OPENIFJP        ".OpenIfJP"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\encrypt.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    encrypt.c

Abstract:

    Helper functions to work with string representations of OWF hashed passwords.

Author:

    Ovidiu Temereanca (ovidiut) 27-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#pragma once

typedef struct {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} ENCRYPT_UNICODE_STRING, *PENCRYPT_UNICODE_STRING;

#define UNICODE_STRING      ENCRYPT_UNICODE_STRING
#define PUNICODE_STRING     PENCRYPT_UNICODE_STRING
#define NTSTATUS            LONG

#include <crypt.h>

#undef NTSTATUS
#undef UNICODE_STRING
#undef PUNICODE_STRING

#include <lmcons.h>

//
// Strings
//

// None

//
// Constants
//

//
// maximum length in Tchars of a LM password
//
#define LM_PASSWORD_SIZE_MAX            (LM20_PWLEN + 1)

//
// length in Tchars of the string-encoded format of *_OWF_PASSWORD
//
#define STRING_ENCODED_LM_OWF_PWD_LENGTH    (sizeof(LM_OWF_PASSWORD) * 2)
#define STRING_ENCODED_NT_OWF_PWD_LENGTH    (sizeof(NT_OWF_PASSWORD) * 2)
#define STRING_ENCODED_PASSWORD_LENGTH      (STRING_ENCODED_LM_OWF_PWD_LENGTH + STRING_ENCODED_NT_OWF_PWD_LENGTH)
//
// size in Tchars of the string-encoded format of *_OWF_PASSWORD
// may be used for static allocations
//
#define STRING_ENCODED_LM_OWF_PWD_SIZE      (STRING_ENCODED_LM_OWF_PWD_LENGTH + 1)
#define STRING_ENCODED_NT_OWF_PWD_SIZE      (STRING_ENCODED_NT_OWF_PWD_LENGTH + 1)
//
// size in Tchars of the string-encoded format of
// LM_OWF_PASSWORD joined with NT_OWF_PASSWORD
// may be used for static allocations
//
#define STRING_ENCODED_PASSWORD_SIZE        (STRING_ENCODED_PASSWORD_LENGTH + 1)

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

DWORD
SetLocalUserEncryptedPassword (
    IN      PCWSTR User,
    IN      PCWSTR OldPassword,
    IN      BOOL OldIsEncrypted,
    IN      PCWSTR NewPassword,
    IN      BOOL NewIsEncrypted
    );

BOOL
CalculateLmOwfPassword (
    IN      PLM_PASSWORD LmPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword
    );

BOOL
CalculateNtOwfPassword (
    IN      PNT_PASSWORD NtPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword
    );

INT
CompareNtPasswords (
    IN      PNT_OWF_PASSWORD NtOwfPassword1,
    IN      PNT_OWF_PASSWORD NtOwfPassword2
    );

INT
CompareLmPasswords (
    IN      PLM_OWF_PASSWORD LmOwfPassword1,
    IN      PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOL
EncodeLmOwfPasswordA (
    IN      PCSTR AnsiPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    );

BOOL
EncodeLmOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PLM_OWF_PASSWORD OwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    );

BOOL
EncodeNtOwfPasswordA (
    IN      PCSTR Password,
    OUT     PNT_OWF_PASSWORD OwfPassword
    );

BOOL
EncodeNtOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PNT_OWF_PASSWORD OwfPassword
    );

BOOL
StringEncodeOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    );

BOOL
StringEncodeOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    );

BOOL
StringEncodeLmOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    );

BOOL
StringEncodeLmOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    );

BOOL
StringEncodeNtOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword
    );

BOOL
StringEncodeNtOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword
    );

BOOL
StringDecodeOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword,
    OUT     PBOOL ComplexNtPassword                 OPTIONAL
    );

BOOL
StringDecodeOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword,
    OUT     PBOOL ComplexNtPassword                 OPTIONAL
    );

BOOL
StringDecodeLmOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword
    );

BOOL
StringDecodeLmOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword
    );

BOOL
StringDecodeNtOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PNT_OWF_PASSWORD OwfPassword
    );

BOOL
StringDecodeNtOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PNT_OWF_PASSWORD OwfPassword
    );

//
// Function name macros
//

#ifndef UNICODE

#define EncodeLmOwfPassword             EncodeLmOwfPasswordA
#define EncodeNtOwfPassword             EncodeNtOwfPasswordA
#define StringEncodeOwfPassword         StringEncodeOwfPasswordA
#define StringEncodeLmOwfPassword       StringEncodeLmOwfPasswordA
#define StringEncodeNtOwfPassword       StringEncodeNtOwfPasswordA
#define StringDecodeOwfPassword         StringDecodeOwfPasswordA
#define StringDecodeLmOwfPassword       StringDecodeLmOwfPasswordA
#define StringDecodeNtOwfPassword       StringDecodeNtOwfPasswordA

#else

#define EncodeLmOwfPassword             EncodeLmOwfPasswordW
#define EncodeNtOwfPassword             EncodeNtOwfPasswordW
#define StringEncodeOwfPassword         StringEncodeOwfPasswordW
#define StringEncodeLmOwfPassword       StringEncodeLmOwfPasswordW
#define StringEncodeNtOwfPassword       StringEncodeNtOwfPasswordW
#define StringDecodeOwfPassword         StringDecodeOwfPasswordW
#define StringDecodeLmOwfPassword       StringDecodeLmOwfPasswordW
#define StringDecodeNtOwfPassword       StringDecodeNtOwfPasswordW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\halamd64.inc ===
include kxamd64.inc

;
;  Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00000H

;
;  Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 00001H
ATTEMPTED_SWITCH_FROM_DPC equ 000B8H
DATA_BUS_ERROR equ 0002EH
DATA_COHERENCY_EXCEPTION equ 00055H
HAL1_INITIALIZATION_FAILED equ 00061H
INSTRUCTION_BUS_ERROR equ 0002FH
INSTRUCTION_COHERENCY_EXCEPTION equ 00056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 0003DH
INTERRUPT_UNWIND_ATTEMPTED equ 0003CH
INVALID_AFFINITY_SET equ 00003H
INVALID_DATA_ACCESS_TRAP equ 00004H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 0004AH
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
KMODE_EXCEPTION_NOT_HANDLED equ 0001EH
NMI_HARDWARE_FAILURE equ 00080H
NO_USER_MODE_CONTEXT equ 0000EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 00049H
PANIC_STACK_SWITCH equ 0002BH
SPIN_LOCK_INIT_FAILURE equ 00081H
SYSTEM_EXIT_OWNED_MUTEX equ 00039H
SYSTEM_SERVICE_EXCEPTION equ 0003BH
SYSTEM_UNWIND_PREVIOUS_USER equ 0003AH
TRAP_CAUSE_UNKNOWN equ 00012H
UNEXPECTED_KERNEL_MODE_TRAP equ 0007FH
HARDWARE_INTERRUPT_STORM equ 000F2H

;
;  Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 00001H

;
;  Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 00001H
EXCEPTION_UNWINDING equ 00002H
EXCEPTION_EXIT_UNWIND equ 00004H
EXCEPTION_STACK_INVALID equ 00008H
EXCEPTION_NESTED_CALL equ 00010H
EXCEPTION_TARGET_UNWIND equ 00020H
EXCEPTION_COLLIDED_UNWIND equ 00040H
EXCEPTION_UNWIND equ 00066H
EXCEPTION_EXECUTE_HANDLER equ 00001H
EXCEPTION_CONTINUE_SEARCH equ 00000H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH

ExceptionContinueExecution equ 00000H
ExceptionContinueSearch equ 00001H
ExceptionNestedException equ 00002H
ExceptionCollidedUnwind equ 00003H

ErExceptionCode equ 00000H
ErExceptionFlags equ 00004H
ErExceptionRecord equ 00008H
ErExceptionAddress equ 00010H
ErNumberParameters equ 00018H
ErExceptionInformation equ 00020H
ExceptionRecordLength equ 000A0H

;
;  Fast Mutex Structure Offset Definitions
;

FmCount equ 00000H
FmOwner equ 00008H
FmContention equ 00010H
FmEvent equ 00018H
FmOldIrql equ 00030H

;
;  Interrupt Priority Request Level Definitions
;

PASSIVE_LEVEL equ 00000H
APC_LEVEL equ 00001H
DISPATCH_LEVEL equ 00002H
CLOCK_LEVEL equ 0000DH
IPI_LEVEL equ 0000EH
POWER_LEVEL equ 0000EH
PROFILE_LEVEL equ 0000FH
HIGH_LEVEL equ 0000FH
SYNCH_LEVEL equ 00002H

;
;  Large Integer Structure Offset Definitions
;

LiLowPart equ 00000H
LiHighPart equ 00004H

;
;  List Entry Structure Offset Definitions
;

LsFlink equ 00000H
LsBlink equ 00008H

;
;  String Structure Offset Definitions
;

StrLength equ 00000H
StrMaximumLength equ 00002H
StrBuffer equ 00008H

;
;  Time Structure Offset Definitions
;

TmLowTime equ 00000H
TmHighTime equ 00004H

;
;  DPC object Structure Offset Definitions
;

DpType equ 00000H
DpNumber equ 00002H
DpImportance equ 00003H
DpDpcListEntry equ 00008H
DpDeferredRoutine equ 00018H
DpDeferredContext equ 00020H
DpSystemArgument1 equ 00028H
DpSystemArgument2 equ 00030H
DpLock equ 00038H
DpcObjectLength equ 00040H

;
;  Interrupt Object Structure Offset Definitions
;

InLevelSensitive equ 00000H
InLatched equ 00001H

InType equ 00000H
InSize equ 00002H
InInterruptListEntry equ 00008H
InServiceRoutine equ 00018H
InServiceContext equ 00020H
InSpinLock equ 00028H
InTickCount equ 00030H
InActualLock equ 00038H
InDispatchAddress equ 00040H
InVector equ 00048H
InIrql equ 0004CH
InSynchronizeIrql equ 0004DH
InFloatingSave equ 0004EH
InConnected equ 0004FH
InNumber equ 00050H
InShareVector equ 00051H
InMode equ 00054H
InServiceCount equ 00058H
InDispatchCount equ 0005CH
InTrapFrame equ 00060H
InDispatchCode equ 00068H
InterruptObjectLength equ 00210H

;
;  Special Register Structure Offset Definition
;

SrKernelDr0 equ 00020H
SrKernelDr1 equ 00028H
SrKernelDr2 equ 00030H
SrKernelDr3 equ 00038H
SrKernelDr6 equ 00040H
SrKernelDr7 equ 00048H
SrGdtr equ 00050H
SrIdtr equ 00060H
SrTr equ 00070H
SrMxCsr equ 00074H

;
;  Processor Control Region Structure Offset Definitions
;

PcTeb equ 00030H
PcCurrentPrcb equ 00038H
PcSavedRcx equ 00040H
PcSavedR11 equ 00048H
PcIrql equ 00050H
PcNumber equ 00052H
PcIrr equ 00054H
PcIrrActive equ 00058H
PcIdr equ 0005CH
PcStallScaleFactor equ 00064H
PcIdt equ 00068H
PcGdt equ 00070H
PcTss equ 00078H
PcKernel equ 00080H
PcHal equ 000C0H
PcSelf equ 00110H
PcPrcb equ 00180H
PcCurrentThread equ 00188H
PcNextThread equ 00190H
PcIdleThread equ 00198H
PcSetMember equ 001A0H
PcNotSetMember equ 001A8H
PcCr0 equ 001B0H
PcCr2 equ 001B8H
PcCr3 equ 001C0H
PcCr4 equ 001C8H
PcKernelDr0 equ 001D0H
PcKernelDr1 equ 001D8H
PcKernelDr2 equ 001E0H
PcKernelDr3 equ 001E8H
PcKernelDr7 equ 001F8H
PcGdtrLimit equ 00206H
PcGdtrBase equ 00208H
PcIdtrLimit equ 00216H
PcIdtrBase equ 00218H
PcTr equ 00220H
PcLdtr equ 00222H
PcMxCsr equ 00224H
PcCpuType equ 004A0H
PcCpuID equ 004A1H
PcCpuStep equ 004A2H
PcInterruptCount equ 00E80H
PcSystemCalls equ 00F38H
PcDpcRoutineActive equ 00DA8H
PcSkipTick equ 00E9CH

;
;  Defines for user shared data
;

USER_SHARED_DATA equ 0FFFFF78000000000H
MM_SHARED_USER_DATA_VA equ 07FFE0000H
UsTickCountLow equ 00000H
UsTickCountMultiplier equ 00004H
UsInterruptTime equ 00008H
UsSystemTime equ 00014H

;
;  Tss Structure Offset Definitions
;

TssRsp0 equ 00004H
TssRsp1 equ 0000CH
TssRsp2 equ 00014H
TssIoMapBase equ 00064H
TssIoMapEnd equ 02068H
TssPanicStack equ 00024H
TssMcaStack equ 0002CH
TssLength equ 02070H

;
;  Gdt Descriptor Offset Definitions
;

KGDT64_NULL equ 00000H
KGDT64_R0_CODE equ 00010H
KGDT64_R0_DATA equ 00018H
KGDT64_R3_CMCODE equ 00020H
KGDT64_R3_DATA equ 00028H
KGDT64_R3_CODE equ 00030H
KGDT64_SYS_TSS equ 00040H
KGDT64_R3_CMTEB equ 00050H

;
;  GDT Entry Offset Definitions
;

KgdtBaseLow equ 00002H
KgdtBaseMiddle equ 00004H
KgdtBaseHigh equ 00007H
KgdtBaseUpper equ 00008H
KgdtLimitHigh equ 00006H
KgdtLimitLow equ 00000H


;
;  Processor Block Structure Offset Definitions
;

PbMinorVersion equ 00000H
PbMajorVersion equ 00002H
PbNumber equ 00004H
PbBuildType equ 00006H
PbCurrentThread equ 00008H
PbNextThread equ 00010H
PbIdleThread equ 00018H
PbSetMember equ 00020H
PbNotSetMember equ 00028H
PbProcessorState equ 00030H
PbCpuType equ 00320H
PbCpuID equ 00321H
PbCpuStep equ 00322H
PbKernelReserved equ 00364H
PbHalReserved equ 00364H

;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0000AH
TfMinute equ 00008H
TfHour equ 00006H
TfWeekday equ 0000EH
TfDay equ 00004H
TfMonth equ 00002H
TfYear equ 00000H
TfMilliseconds equ 0000CH


;
;  Define constants for system IRQL and IDT vector conversion
;

MAXIMUM_IDTVECTOR equ 000FFH
MAXIMUM_PRIMARY_VECTOR equ 000FFH
PRIMARY_VECTOR_BASE equ 00030H
RPL_MASK equ 00003H
MODE_BIT equ 00000H
MODE_MASK equ 00001H

;
;  Flags in the CR0 register
;

CR0_PG equ 080000000H
CR0_ET equ 00010H
CR0_TS equ 00008H
CR0_EM equ 00004H
CR0_MP equ 00002H
CR0_PE equ 00001H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 00020H

;
;  Flags in the CR4 register
;

CR4_VME equ 00001H
CR4_PVI equ 00002H
CR4_TSD equ 00004H
CR4_DE equ 00008H
CR4_PSE equ 00010H
CR4_PAE equ 00020H
CR4_MCE equ 00040H
CR4_PGE equ 00080H
CR4_FXSR equ 00200H
CR4_XMMEXCPT equ 00400H

;
;  Legacy Floating Status Bit Masks
;

FSW_INVALID_OPERATION equ 00001H
FSW_DENORMAL equ 00002H
FSW_ZERO_DIVIDE equ 00004H
FSW_OVERFLOW equ 00008H
FSW_UNDERFLOW equ 00010H
FSW_PRECISION equ 00020H
FSW_STACK_FAULT equ 00040H
FSW_CONDITION_CODE_0 equ 00100H
FSW_CONDITION_CODE_1 equ 00200H
FSW_CONDITION_CODE_2 equ 00400H
FSW_CONDITION_CODE_3 equ 04000H
FSW_ERROR_MASK equ 0007FH

;
;  MXCSR Floating Control/Status Bit Masks
;

XSW_INVALID_OPERATION equ 00001H
XSW_DENORMAL equ 00002H
XSW_ZERO_DIVIDE equ 00004H
XSW_OVERFLOW equ 00008H
XSW_UNDERFLOW equ 00010H
XSW_PRECISION equ 00020H
XSW_ERROR_MASK equ 0003FH
XSW_ERROR_SHIFT equ 00007H
XCW_INVALID_OPERATION equ 00080H
XCW_DENORMAL equ 00100H
XCW_ZERO_DIVIDE equ 00200H
XCW_OVERFLOW equ 00400H
XCW_UNDERFLOW equ 00800H
XCW_PRECISION equ 01000H
XCW_ROUND_CONTROL equ 06000H
XCW_FLUSH_ZERO equ 08000H
INITIAL_MXCSR equ 01F80H

;
;  Machine Specific Register Numbers
;

MSR_EFER equ 0C0000080H
MSR_FS_BASE equ 0C0000100H
MSR_GS_BASE equ 0C0000101H
MSR_GS_SWAP equ 0C0000102H

;
;  Flags within MSR_EFER
;

MSR_LMA equ 00400H

;
;  Miscellaneous Definitions
;

MAXIMUM_PROCESSORS equ 00040H
INITIAL_STALL_COUNT equ 00064H
IRQL_NOT_GREATER_OR_EQUAL equ 00009H
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
MUTEX_ALREADY_OWNED equ 000BFH
THREAD_NOT_MUTEX_OWNER equ 00011H
SPIN_LOCK_ALREADY_OWNED equ 0000FH
SPIN_LOCK_NOT_OWNED equ 00010H
Executive equ 00000H
KernelMode equ 00000H
UserMode equ 00001H
FALSE equ 00000H
TRUE equ 00001H

;
;  Exception Frame Offset Definitions and Length
;

ExP1Home equ 00000H
ExP2Home equ 00008H
ExP3Home equ 00010H
ExP4Home equ 00018H
ExP5 equ 00020H
ExXmm6 equ 00030H
ExXmm7 equ 00040H
ExXmm8 equ 00050H
ExXmm9 equ 00060H
ExXmm10 equ 00070H
ExXmm11 equ 00080H
ExXmm12 equ 00090H
ExXmm13 equ 000A0H
ExXmm14 equ 000B0H
ExXmm15 equ 000C0H
ExRbp equ 000F8H
ExRbx equ 00100H
ExRdi equ 00108H
ExRsi equ 00110H
ExR12 equ 00118H
ExR13 equ 00120H
ExR14 equ 00128H
ExR15 equ 00130H
ExReturn equ 00138H

KEXCEPTION_FRAME_LENGTH equ 00140H

;
;  Jump Offset Definitions and Length
;

JbFrame equ 00000H
JbRbx equ 00008H
JbRsp equ 00010H
JbRbp equ 00018H
JbRsi equ 00020H
JbRdi equ 00028H
JbR12 equ 00030H
JbR13 equ 00038H
JbR14 equ 00040H
JbR15 equ 00048H
JbRip equ 00050H
JbXmm6 equ 00060H
JbXmm7 equ 00070H
JbXmm8 equ 00080H
JbXmm9 equ 00090H
JbXmm10 equ 000A0H
JbXmm11 equ 000B0H
JbXmm12 equ 000C0H
JbXmm13 equ 000D0H
JbXmm14 equ 000E0H
JbXmm15 equ 000F0H

;
;  Switch Frame Offset Definitions and Length
;

SwMxCsr equ 00008H
SwApcBypass equ 0000CH
SwNpxSave equ 0000DH
SwRbp equ 00010H
SwReturn equ 00018H

KSWITCH_FRAME_LENGTH equ 00020H

;
;  Trap Frame Offset and EFLAG Definitions and Length
;

EFLAGS_TF_MASK equ 00100H
EFLAGS_TF_SHIFT equ 00008H
EFLAGS_IF_MASK equ 00200H
EFLAGS_IF_SHIFT equ 00009H
EFLAGS_USER_SANITIZE equ 040DD5H

TrP1Home equ 0FFFFFF80H
TrP2Home equ 0FFFFFF88H
TrP3Home equ 0FFFFFF90H
TrP4Home equ 0FFFFFF98H
TrP5 equ 0FFFFFFA0H
TrPreviousMode equ 0FFFFFFA8H
TrPreviousIrql equ 0FFFFFFA9H
TrMxCsr equ 0FFFFFFACH
TrRax equ 0FFFFFFB0H
TrRcx equ 0FFFFFFB8H
TrRdx equ 0FFFFFFC0H
TrR8 equ 0FFFFFFC8H
TrR9 equ 0FFFFFFD0H
TrR10 equ 0FFFFFFD8H
TrR11 equ 0FFFFFFE0H
TrXmm0 equ 0FFFFFFF0H
TrXmm1 equ 00000H
TrXmm2 equ 00010H
TrXmm3 equ 00020H
TrXmm4 equ 00030H
TrXmm5 equ 00040H
TrDr0 equ 00050H
TrDr1 equ 00058H
TrDr2 equ 00060H
TrDr3 equ 00068H
TrDr6 equ 00070H
TrDr7 equ 00078H
TrSegDs equ 00080H
TrSegEs equ 00082H
TrSegFs equ 00084H
TrSegGs equ 00086H
TrTrapFrame equ 00088H
TrExceptionRecord equ 00090H
TrRbx equ 00130H
TrRdi equ 00138H
TrRsi equ 00140H
TrRbp equ 00148H
TrErrorCode equ 00150H
TrRip equ 00158H
TrSegCs equ 00160H
TrEFlags equ 00168H
TrRsp equ 00170H
TrSegSs equ 00178H

KTRAP_FRAME_LENGTH equ 00200H

;
;  CPU information structure offset definitions
;

CpuEax equ 00000H
CpuEbx equ 00004H
CpuEcx equ 00008H
CpuEdx equ 0000CH

;
;  Usermode Callout User Frame Definitions
;

CkBuffer equ 00020H
CkLength equ 00028H
CkApiNumber equ 0002CH
CkRsp equ 00048H
CkRip equ 00030H
CalloutFrameLength equ 00058H

;
;  Machine Frame Offset Definitions
;

MfRip equ 00000H
MfSegCs equ 00008H
MfEFlags equ 00010H
MfRsp equ 00018H
MfSegSs equ 00020H
MachineFrameLength equ 00028H

;
;  Floating Save Offset Definitions
;

FsMxCsr equ 00000H

;
;  LPC Structure Offset Definitions
;

PmLength equ 00000H
PmZeroInit equ 00004H
PmClientId equ 00008H
PmProcess equ 00008H
PmThread equ 00010H
PmMessageId equ 00018H
PmClientViewSize equ 00020H
PortMessageLength equ 00028H

;
;  Client Id Structure Offset Definitions
;

CidUniqueProcess equ 00000H
CidUniqueThread equ 00008H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010000BH
CONTEXT_CONTROL equ 0100001H
CONTEXT_INTEGER equ 0100002H
CONTEXT_SEGMENTS equ 0100004H
CONTEXT_FLOATING_POINT equ 0100008H
CONTEXT_DEBUG_REGISTERS equ 0100010H

CxP1Home equ 00000H
CxP2Home equ 00008H
CxP3Home equ 00010H
CxP4Home equ 00018H
CxP5Home equ 00020H
CxP6Home equ 00028H
CxContextFlags equ 00030H
CxMxCsr equ 00034H
CxSegCs equ 00038H
CxSegDs equ 0003AH
CxSegEs equ 0003CH
CxSegFs equ 0003EH
CxSegGs equ 00040H
CxSegSs equ 00042H
CxEFlags equ 00044H
CxDr0 equ 00048H
CxDr1 equ 00050H
CxDr2 equ 00058H
CxDr3 equ 00060H
CxDr6 equ 00068H
CxDr7 equ 00070H
CxRax equ 00078H
CxRcx equ 00080H
CxRdx equ 00088H
CxRbx equ 00090H
CxRsp equ 00098H
CxRbp equ 000A0H
CxRsi equ 000A8H
CxRdi equ 000B0H
CxR8 equ 000B8H
CxR9 equ 000C0H
CxR10 equ 000C8H
CxR11 equ 000D0H
CxR12 equ 000D8H
CxR13 equ 000E0H
CxR14 equ 000E8H
CxR15 equ 000F0H
CxRip equ 000F8H
CxXmm0 equ 00100H
CxXmm1 equ 00110H
CxXmm2 equ 00120H
CxXmm3 equ 00130H
CxXmm4 equ 00140H
CxXmm5 equ 00150H
CxXmm6 equ 00160H
CxXmm7 equ 00170H
CxXmm8 equ 00180H
CxXmm9 equ 00190H
CxXmm10 equ 001A0H
CxXmm11 equ 001B0H
CxXmm12 equ 001C0H
CxXmm13 equ 001D0H
CxXmm14 equ 001E0H
CxXmm15 equ 001F0H
CxFltSave equ 00200H
CONTEXT_FRAME_LENGTH equ 00270H
DR7_ACTIVE equ 00055H

;
;  Dispatcher Context Structure Offset Definitions
;

DcControlPc equ 00000H
DcImageBase equ 00008H
DcFunctionEntry equ 00010H
DcEstablisherFrame equ 00018H
DcTargetIp equ 00020H
DcContextRecord equ 00028H
DcLanguageHandler equ 00030H
DcHandlerData equ 00038H

;
;  Legacy Floating save area field offset definitions
;

LfControlWord equ 00000H
LfStatusWord equ 00004H
LfTagWord equ 00008H
LfErrorOffset equ 0000CH
LfErrorOpcode equ 00012H
LfErrorSelector equ 00010H
LfDataOffset equ 00014H
LfDataSelector equ 00018H
LfFloatRegisters equ 0001CH

LEGACY_SAVE_AREA_LENGTH equ 00070H

;
;  Processor State Frame Offset Definitions
;

PsSpecialRegisters equ 00000H
PsCr0 equ 00000H
PsCr2 equ 00008H
PsCr3 equ 00010H
PsCr4 equ 00018H
PsKernelDr0 equ 00020H
PsKernelDr1 equ 00028H
PsKernelDr2 equ 00030H
PsKernelDr3 equ 00038H
PsKernelDr6 equ 00040H
PsKernelDr7 equ 00048H
PsGdtr equ 00056H
PsIdtr equ 00066H
PsTr equ 00070H
PsLdtr equ 00072H
PsContextFrame equ 00080H
ProcessorStateLength equ 002F0H

;
;  Processor Start Block Offset Definitions
;

PsbCompletionFlag equ 00004H
PsbGdt32 equ 00008H
PsbIdt32 equ 0000EH
PsbGdt equ 00018H
PsbTiledCr3 equ 00058H
PsbPmTarget equ 00060H
PsbLmTarget equ 00066H
PsbSelfMap equ 00070H
PsbProcessorState equ 00080H
ProcessorStartBlockLength equ 00370H

;
;  Machine type definitions (Temporarily)
;

MACHINE_TYPE_ISA equ 00000H
MACHINE_TYPE_EISA equ 00001H
MACHINE_TYPE_MCA equ 00002H

;
;  LoaderParameterBlock offsets relative to base
;

LpbLoadOrderListHead equ 00000H
LpbMemoryDescriptorListHead equ 00010H
LpbKernelStack equ 00030H
LpbPrcb equ 00038H
LpbProcess equ 00040H
LpbThread equ 00048H
LpbI386 equ 000B8H
LpbRegistryLength equ 00050H
LpbRegistryBase equ 00058H
LpbConfigurationRoot equ 00060H
LpbArcBootDeviceName equ 00068H
LpbArcHalDeviceName equ 00070H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\fmifs.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fmifs.h

Abstract:

    This header file contains the specification of the interface
    between the file manager and fmifs.dll for the purposes of
    accomplishing IFS functions.

Author:

    Norbert P. Kusters (norbertk) 6-Mar-92

--*/

#if !defined( _FMIFS_DEFN_ )

#define _FMIFS_DEFN_

typedef LONG    *PNTSTATUS;

//
// These are the defines for 'PacketType'.
// Revisions: 02/03/98: Dave Sheldon - Added FmIfsNoMediaInDevice
//

typedef enum _FMIFS_PACKET_TYPE {
    FmIfsPercentCompleted           = 0,
    FmIfsFormatReport               = 1,
    FmIfsInsertDisk                 = 2,
    FmIfsIncompatibleFileSystem     = 3,
    FmIfsFormattingDestination      = 4,
    FmIfsIncompatibleMedia          = 5,
    FmIfsAccessDenied               = 6,
    FmIfsMediaWriteProtected        = 7,
    FmIfsCantLock                   = 8,
    FmIfsCantQuickFormat            = 9,
    FmIfsIoError                    = 10,
    FmIfsFinished                   = 11,
    FmIfsBadLabel                   = 12,
    FmIfsCheckOnReboot              = 13,
    FmIfsTextMessage                = 14,
    FmIfsHiddenStatus               = 15,
    FmIfsClusterSizeTooSmall        = 16,
    FmIfsClusterSizeTooBig          = 17,
    FmIfsVolumeTooSmall             = 18,
    FmIfsVolumeTooBig               = 19,
    FmIfsNoMediaInDevice            = 20,
    FmIfsClustersCountBeyond32bits  = 21,
    FmIfsCantChkMultiVolumeOfSameFS = 22,
    FmIfsFormatFatUsing64KCluster   = 23
} FMIFS_PACKET_TYPE, *PFMIFS_PACKET_TYPE;

typedef struct _FMIFS_PERCENT_COMPLETE_INFORMATION {
    ULONG   PercentCompleted;
} FMIFS_PERCENT_COMPLETE_INFORMATION, *PFMIFS_PERCENT_COMPLETE_INFORMATION;

//
// These couple of bits are used in the ValuesInMB field of the structure
// FMIFS_FORMAT_REPORT_INFORMATION.  When set, the corresponding
// ULONG value becomes in units of megabytes.  If not set, the corresponding
// ULONG value is in units of kilobytes.
//
#define TOTAL_DISK_SPACE_IN_MB      1
#define BYTES_AVAILABLE_IN_MB       2

typedef struct _FMIFS_FORMAT_REPORT_INFORMATION {
    ULONG   KiloBytesTotalDiskSpace;
    ULONG   KiloBytesAvailable;
    ULONG   ValuesInMB;
} FMIFS_FORMAT_REPORT_INFORMATION, *PFMIFS_FORMAT_REPORT_INFORMATION;

// The packet for FmIfsDblspaceCreated is a Unicode string
// giving the name of the Compressed Volume File; it is not
// necessarily zero-terminated.
//

#define DISK_TYPE_GENERIC           0
#define DISK_TYPE_SOURCE            1
#define DISK_TYPE_TARGET            2
#define DISK_TYPE_SOURCE_AND_TARGET 3

typedef struct _FMIFS_INSERT_DISK_INFORMATION {
    ULONG   DiskType;
} FMIFS_INSERT_DISK_INFORMATION, *PFMIFS_INSERT_DISK_INFORMATION;

typedef struct _FMIFS_IO_ERROR_INFORMATION {
    ULONG   DiskType;
    ULONG   Head;
    ULONG   Track;
} FMIFS_IO_ERROR_INFORMATION, *PFMIFS_IO_ERROR_INFORMATION;

typedef struct _FMIFS_FINISHED_INFORMATION {
    BOOLEAN Success;
} FMIFS_FINISHED_INFORMATION, *PFMIFS_FINISHED_INFORMATION;

typedef struct _FMIFS_CHECKONREBOOT_INFORMATION {
    OUT BOOLEAN QueryResult; // TRUE for "yes", FALSE for "no"
} FMIFS_CHECKONREBOOT_INFORMATION, *PFMIFS_CHECKONREBOOT_INFORMATION;

typedef enum _TEXT_MESSAGE_TYPE {
    MESSAGE_TYPE_PROGRESS,
    MESSAGE_TYPE_RESULTS,
    MESSAGE_TYPE_FINAL
} TEXT_MESSAGE_TYPE, *PTEXT_MESSAGE_TYPE;

typedef struct _FMIFS_TEXT_MESSAGE {
    IN TEXT_MESSAGE_TYPE    MessageType;
    IN PSTR                 Message;
} FMIFS_TEXT_MESSAGE, *PFMIFS_TEXT_MESSAGE;


#define FMIFS_SONY_MS_MASK                            0x00000001        // mask for all types of memory stick
#define FMIFS_SONY_MS                                 0x00000001        // device is a memory stick
#define FMIFS_SONY_MS_FMT_CMD_CAPABLE                 0x00000010        // reader supports fmt cmd
#define FMIFS_SONY_MS_PROGRESS_INDICATOR_CAPABLE      0x00000020        // reader supports progress indicator
#define FMIFS_NTFS_NOT_SUPPORTED                      0x00000040        // ntfs should not be used on this device

typedef struct _FMIFS_DEVICE_INFORMATION {
    ULONG       Flags;
} FMIFS_DEVICE_INFORMATION, *PFMIFS_DEVICE_INFORMATION;

//
// This is a list of supported floppy media types for format.
//

typedef enum _FMIFS_MEDIA_TYPE {
    FmMediaUnknown,
    FmMediaF5_160_512,      // 5.25", 160KB,  512 bytes/sector
    FmMediaF5_180_512,      // 5.25", 180KB,  512 bytes/sector
    FmMediaF5_320_512,      // 5.25", 320KB,  512 bytes/sector
    FmMediaF5_320_1024,     // 5.25", 320KB,  1024 bytes/sector
    FmMediaF5_360_512,      // 5.25", 360KB,  512 bytes/sector
    FmMediaF3_720_512,      // 3.5",  720KB,  512 bytes/sector
    FmMediaF5_1Pt2_512,     // 5.25", 1.2MB,  512 bytes/sector
    FmMediaF3_1Pt44_512,    // 3.5",  1.44MB, 512 bytes/sector
    FmMediaF3_2Pt88_512,    // 3.5",  2.88MB, 512 bytes/sector
    FmMediaF3_20Pt8_512,    // 3.5",  20.8MB, 512 bytes/sector
    FmMediaRemovable,       // Removable media other than floppy
    FmMediaFixed,
    FmMediaF3_120M_512,     // 3.5", 120M Floppy
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_640_512,      // 3.5" ,  640KB,  512 bytes/sector
    FmMediaF5_640_512,      // 5.25",  640KB,  512 bytes/sector
    FmMediaF5_720_512,      // 5.25",  720KB,  512 bytes/sector
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_1Pt2_512,     // 3.5" , 1.2Mb,   512 bytes/sector
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_1Pt23_1024,   // 3.5" , 1.23Mb, 1024 bytes/sector
    FmMediaF5_1Pt23_1024,   // 5.25", 1.23MB, 1024 bytes/sector
    FmMediaF3_128Mb_512,    // 3.5" , 128MB,  512 bytes/sector  3.5"MO
    FmMediaF3_230Mb_512,    // 3.5" , 230MB,  512 bytes/sector  3.5"MO
    FmMediaF3_200Mb_512,    // 3.5" , 200MB,  512 bytes/sector  HiFD (200MB Floppy)
    FmMediaF3_240Mb_512,    // 3.5" , 240MB,  512 bytes/sector  HiFD (240MB Floppy)
    FmMediaEndOfData        // Total data count.
} FMIFS_MEDIA_TYPE, *PFMIFS_MEDIA_TYPE;

//
// The structure below defines information to be passed into ChkdskEx.
// When new fields are added, the version number will have to be upgraded
// so that only new code will reference those new fields.
//
typedef struct {
    UCHAR   Major;      // initial version is 1.0
    UCHAR   Minor;
    ULONG   Flags;
} FMIFS_CHKDSKEX_PARAM, *PFMIFS_CHKDSKEX_PARAM;

//
// Internal definitions for Flags field in FMIFS_CHKDSKEX_PARAM
//
#define FMIFS_CHKDSK_RECOVER_FREE_SPACE       0x00000002UL
#define FMIFS_CHKDSK_RECOVER_ALLOC_SPACE      0x00000004UL

//
// External definitions for Flags field in FMIFS_CHKDSKEX_PARAM
//

// FMIFS_CHKDSK_VERBOSE
//  - For FAT, chkdsk will print every filename being processed
//  - For NTFS, chkdsk will print clean up messages
// FMIFS_CHKDSK_RECOVER
//  - Perform sector checking on free and allocated space
// FMIFS_CHKDSK_EXTEND
//  - For NTFS, chkdsk will extend a volume
// FMIFS_CHKDSK_DOWNGRADE (for NT5 or later but obsolete anyway)
//  - For NTFS, this downgrade a volume from most recent NTFS version
// FMIFS_CHKDSK_ENABLE_UPGRADE (for NT5 or later but obsolete anyway)
//  - For NTFS, this upgrades a volume to most recent NTFS version
// FMIFS_CHKDSK_CHECK_IF_DIRTY
//  - Perform consistency check only if the volume is dirty
// FMIFS_CHKDSK_FORCE (for NT5 or later)
//  - Forces the volume to dismount first if necessary
// FMIFS_CHKDSK_SKIP_INDEX_SCAN
//  - Skip the scanning of each index entry
// FMIFS_CHKDSK_SKIP_CYCLE_SCAN
//  - Skip the checking of cycles within the directory tree

#define FMIFS_CHKDSK_VERBOSE                  0x00000001UL
#define FMIFS_CHKDSK_RECOVER                  (FMIFS_CHKDSK_RECOVER_FREE_SPACE | \
                                               FMIFS_CHKDSK_RECOVER_ALLOC_SPACE)
#define FMIFS_CHKDSK_EXTEND                   0x00000008UL
#define FMIFS_CHKDSK_DOWNGRADE                0x00000010UL
#define FMIFS_CHKDSK_ENABLE_UPGRADE           0x00000020UL
#define FMIFS_CHKDSK_CHECK_IF_DIRTY           0x00000080UL
#define FMIFS_CHKDSK_FORCE                    0x00000100UL
#define FMIFS_CHKDSK_SKIP_INDEX_SCAN          0x00000200UL
#define FMIFS_CHKDSK_SKIP_CYCLE_SCAN          0x00000400UL

//
// The structure below defines information to be passed into FormatEx2.
// When new fields are added, the version number will have to be upgraded
// so that only new code will reference those new fields.
//
typedef struct {
    UCHAR       Major;          // initial version is 1.0
    UCHAR       Minor;
    ULONG       Flags;
    PWSTR       LabelString;    // supplies the volume's label
    ULONG       ClusterSize;    // supplies the cluster size for the volume
} FMIFS_FORMATEX2_PARAM, *PFMIFS_FORMATEX2_PARAM;

//
// External definitions for Flags field in FMIFS_FORMATEX2_PARAM
//

// FMIFS_FORMAT_QUICK
//  - Performs a quick format
// FMIFS_FORMAT_BACKWARD_COMPATIBLE
//  - Formats a volume to be backward compatible to an older version of NTFS volume
// FMIFS_FORMAT_FORCE
//  - Forces the volume to dismount first if necessary

#define FMIFS_FORMAT_QUICK                    0x00000001UL
#define FMIFS_FORMAT_BACKWARD_COMPATIBLE      0x00000002UL
#define FMIFS_FORMAT_FORCE                    0x00000004UL

//
// Maximum length of file system format name string including version number in it
// (e.g. FAT32, NTFS 5.0, NTFS 4.0, FAT, etc)
//
#define MAX_FILE_SYSTEM_FORMAT_VERSION_NAME_LEN       16

//
// Maximum length of file system name string (e.g. NTFS, FAT32, FAT, etc)
//
#define MAX_FILE_SYSTEM_FORMAT_NAME_LEN                9

//
// Function types/interfaces.
//

typedef BOOLEAN
(*FMIFS_CALLBACK)(
    IN  FMIFS_PACKET_TYPE   PacketType,
    IN  ULONG               PacketLength,
    IN  PVOID               PacketData
    );

typedef
VOID
(*PFMIFS_FORMAT_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_FORMATEX_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  ULONG               ClusterSize,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_FORMATEX2_ROUTINE)(
    IN  PWSTR                   DriveName,
    IN  FMIFS_MEDIA_TYPE        MediaType,
    IN  PWSTR                   FileSystemName,
    IN  PFMIFS_FORMATEX2_PARAM  Param,
    IN  FMIFS_CALLBACK          Callback
    );

typedef
BOOLEAN
(*PFMIFS_ENABLECOMP_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  USHORT              CompressionFormat
    );

typedef
VOID
(*PFMIFS_CHKDSK_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  PWSTR               FileSystemName,
    IN  BOOLEAN             Fix,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             OnlyIfDirty,
    IN  BOOLEAN             Recover,
    IN  PWSTR               PathToCheck,
    IN  BOOLEAN             Extend,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_CHKDSKEX_ROUTINE)(
    IN  PWSTR                   DriveName,
    IN  PWSTR                   FileSystemName,
    IN  BOOLEAN                 Fix,
    IN  PFMIFS_CHKDSKEX_PARAM   Param,
    IN  FMIFS_CALLBACK          Callback
    );

typedef
VOID
(*PFMIFS_EXTEND_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  BOOLEAN             Verify,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_DISKCOPY_ROUTINE)(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    );

typedef
BOOLEAN
(*PFMIFS_SETLABEL_ROUTINE)(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    );

typedef
BOOLEAN
(*PFMIFS_QSUPMEDIA_ROUTINE)(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray  OPTIONAL,
    IN  ULONG               NumberOfArrayEntries,
    OUT PULONG              NumberOfMediaTypes
    );

typedef
BOOLEAN
(*PFMIFS_QUERY_DEVICE_INFO_BY_HANDLE_ROUTINE)(
    IN  HANDLE                      DriveHandle,
    OUT PFMIFS_DEVICE_INFORMATION   DevInfo,
    IN  ULONG                       DevInfoSize
    );

typedef
BOOLEAN
(*PFMIFS_QUERY_DEVICE_INFO_ROUTINE)(
    IN  PWSTR                       DriveName,
    OUT PFMIFS_DEVICE_INFORMATION   DevInfo,
    IN  ULONG                       DevInfoSize
    );

typedef
VOID
(*PFMIFS_DOUBLESPACE_CREATE_ROUTINE)(
    IN PWSTR           HostDriveName,
    IN ULONG           Size,
    IN PWSTR           Label,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

#if defined( DBLSPACE_ENABLED )
typedef
VOID
(*PFMIFS_DOUBLESPACE_DELETE_ROUTINE)(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

typedef
VOID
(*PFMIFS_DOUBLESPACE_MOUNT_ROUTINE)(
    IN PWSTR           HostDriveName,
    IN PWSTR           CvfName,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

typedef
VOID
(*PFMIFS_DOUBLESPACE_DISMOUNT_ROUTINE)(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

typedef
BOOLEAN
(*PFMIFS_DOUBLESPACE_QUERY_INFO_ROUTINE)(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    );

typedef
BOOLEAN
(*PFMIFS_DOUBLESPACE_SET_AUTMOUNT_ROUTINE)(
    IN  BOOLEAN EnableAutomount
    );

#endif // DBLSPACE_ENABLED

FMIFS_MEDIA_TYPE
ComputeFmMediaType(
    IN  MEDIA_TYPE  MediaType
    );

VOID
Format(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
FormatEx(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  ULONG               ClusterSize,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
FormatEx2(
    IN  PWSTR                   DriveName,
    IN  FMIFS_MEDIA_TYPE        MediaType,
    IN  PWSTR                   FileSystemName,
    IN  PFMIFS_FORMATEX2_PARAM  Param,
    IN  FMIFS_CALLBACK          Callback
    );

BOOLEAN
EnableVolumeCompression(
    IN  PWSTR               DriveName,
    IN  USHORT              CompressionFormat
    );

VOID
Chkdsk(
    IN  PWSTR               DriveName,
    IN  PWSTR               FileSystemName,
    IN  BOOLEAN             Fix,
    IN  BOOLEAN             Verbose,
    IN  BOOLEAN             OnlyIfDirty,
    IN  BOOLEAN             Recover,
    IN  PWSTR               PathToCheck,
    IN  BOOLEAN             Extend,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
ChkdskEx(
    IN  PWSTR                   DriveName,
    IN  PWSTR                   FileSystemName,
    IN  BOOLEAN                 Fix,
    IN  PFMIFS_CHKDSKEX_PARAM   Param,
    IN  FMIFS_CALLBACK          Callback
    );

VOID
Extend(
    IN  PWSTR               DriveName,
    IN  BOOLEAN             Verify,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
DiskCopy(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    );

BOOLEAN
SetLabel(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    );

BOOLEAN
QuerySupportedMedia(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray  OPTIONAL,
    IN  ULONG               NumberOfArrayEntries,
    OUT PULONG              NumberOfMediaTypes
    );

BOOLEAN
QueryAvailableFileSystemFormat(
    IN     ULONG            Index,
    OUT    PWSTR            FileSystemName,
    OUT    PUCHAR           MajorVersion,
    OUT    PUCHAR           MinorVersion,
    OUT    PBOOLEAN         Latest
);

BOOLEAN
QueryFileSystemName(
    IN     PWSTR        DriveName,
    OUT    PWSTR        FileSystemName,
    OUT    PUCHAR       MajorVersion,
    OUT    PUCHAR       MinorVersion,
    OUT    PNTSTATUS    ErrorCode
);

BOOLEAN
QueryLatestFileSystemVersion(
    IN  PWSTR   FileSystemName,
    OUT PUCHAR  MajorVersion,
    OUT PUCHAR  MinorVersion
);

BOOLEAN
QueryDeviceInformation(
    IN     PWSTR                                DriveName,
       OUT PFMIFS_DEVICE_INFORMATION            DevInfo,
    IN     ULONG                                DevInfoSize
);

BOOLEAN
QueryDeviceInformationByHandle(
    IN     HANDLE                               DriveHandle,
       OUT PFMIFS_DEVICE_INFORMATION            DevInfo,
    IN     ULONG                                DevInfoSize
);

VOID
DoubleSpaceCreate(
    IN PWSTR           HostDriveName,
    IN ULONG           Size,
    IN PWSTR           Label,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

#if defined( DBLSPACE_ENABLED )

VOID
DoubleSpaceDelete(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

VOID
DoubleSpaceMount(
    IN PWSTR           HostDriveName,
    IN PWSTR           CvfName,
    IN PWSTR           NewDriveName,
    IN FMIFS_CALLBACK  Callback
    );

VOID
DoubleSpaceDismount(
    IN PWSTR           DblspaceDriveName,
    IN FMIFS_CALLBACK  Callback
    );

// Miscellaneous prototypes:
//
BOOLEAN
FmifsQueryDriveInformation(
    IN  PWSTR       DosDriveName,
    OUT PBOOLEAN    IsRemovable,
    OUT PBOOLEAN    IsFloppy,
    OUT PBOOLEAN    IsCompressed,
    OUT PBOOLEAN    Error,
    OUT PWSTR       NtDriveName,
    IN  ULONG       MaxNtDriveNameLength,
    OUT PWSTR       CvfFileName,
    IN  ULONG       MaxCvfFileNameLength,
    OUT PWSTR       HostDriveName,
    IN  ULONG       MaxHostDriveNameLength
    );

BOOLEAN
FmifsSetAutomount(
    IN  BOOLEAN EnableAutomount
    );

#endif


#endif // _FMIFS_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\halia64.h ===
#include "kxia64.h"
#include "regia64.h"

//
// Wait Reason and Wait Type Enumerated Type Values
//

#define WrExecutive 0x0

//
// Bug Check Code Definitions
//

#define APC_INDEX_MISMATCH 0x1
#define ATTEMPTED_SWITCH_FROM_DPC 0xb8
#define DATA_BUS_ERROR 0x2e
#define DATA_COHERENCY_EXCEPTION 0x55
#define HAL1_INITIALIZATION_FAILED 0x61
#define INSTRUCTION_BUS_ERROR 0x2f
#define INSTRUCTION_COHERENCY_EXCEPTION 0x56
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_AFFINITY_SET 0x3
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_GT_ZERO_AT_SYSTEM_SERVICE 0x4a
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define KMODE_EXCEPTION_NOT_HANDLED 0x1e
#define NMI_HARDWARE_FAILURE 0x80
#define NO_USER_MODE_CONTEXT 0xe
#define PAGE_FAULT_WITH_INTERRUPTS_OFF 0x49
#define PANIC_STACK_SWITCH 0x2b
#define SPIN_LOCK_INIT_FAILURE 0x81
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12
#define UNEXPECTED_KERNEL_MODE_TRAP 0x7f
#define HARDWARE_INTERRUPT_STORM 0xf2

//
// Breakpoint type definitions
//

#define DBG_STATUS_CONTROL_C 0x1

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66
#define EXCEPTION_EXECUTE_HANDLER 0x1
#define EXCEPTION_CONTINUE_SEARCH 0x0
#define EXCEPTION_CONTINUE_EXECUTION 0xffffffff

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0x10
#define ErNumberParameters 0x18
#define ErExceptionInformation 0x20
#define ExceptionRecordLength 0xa0

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x8
#define FmContention 0x10
#define FmEvent 0x18
#define FmOldIrql 0x30

//
// Interrupt Priority Request Level Definitions
//

#define PASSIVE_LEVEL 0x0
#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0xe
#define POWER_LEVEL 0xf
#define PROFILE_LEVEL 0xf
#define HIGH_LEVEL 0xf
#ifdef NT_UP
#define SYNCH_LEVEL 0x2
#else
#define SYNCH_LEVEL 0xd
#endif

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x8

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x8

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpNumber 0x2
#define DpImportance 0x3
#define DpDpcListEntry 0x8
#define DpDeferredRoutine 0x18
#define DpDeferredContext 0x20
#define DpSystemArgument1 0x28
#define DpSystemArgument2 0x30
#define DpLock 0x38
#define DpcObjectLength 0x40

//
// Interrupt Object Structure Offset Definitions
//

#define InLevelSensitive 0x0
#define InLatched 0x1

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x8
#define InServiceRoutine 0x18
#define InServiceContext 0x20
#define InSpinLock 0x28
#define InTickCount 0x30
#define InActualLock 0x38
#define InDispatchAddress 0x40
#define InVector 0x48
#define InIrql 0x4c
#define InSynchronizeIrql 0x4d
#define InFloatingSave 0x4e
#define InConnected 0x4f
#define InNumber 0x50
#define InShareVector 0x51
#define InMode 0x54
#define InServiceCount 0x58
#define InDispatchCount 0x5c
#define InDispatchCode 0x60
#define InterruptObjectLength 0x70

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x1
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x8
#define PbNextThread 0x10
#define PbIdleThread 0x18
#define PbNumber 0x20
#define PbBuildType 0x22
#define PbSetMember 0x28
#define PbRestartBlock 0x30
#define PbPcrPage 0x38
#define PbProcessorModel 0x50
#define PbProcessorRevision 0x54
#define PbProcessorFamily 0x58
#define PbProcessorSerialNumber 0x60
#define PbProcessorFeatureBits 0x68
#define PbProcessorVendorString 0x70
#define PbSystemReserved 0x80
#define PbHalReserved 0xc0

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x8002f
#define CONTEXT_CONTROL 0x80001
#define CONTEXT_INTEGER 0x80008
#define CONTEXT_LOWER_FLOATING_POINT 0x80002
#define CONTEXT_HIGHER_FLOATING_POINT 0x80004
#define CONTEXT_FLOATING_POINT 0x80006
#define CONTEXT_DEBUG 0x80010
#define CONTEXT_IA32_CONTROL 0x80020

#define CxContextFlags 0x0

#define CxDbI0 0x10
#define CxDbI1 0x18
#define CxDbI2 0x20
#define CxDbI3 0x28
#define CxDbI4 0x30
#define CxDbI5 0x38
#define CxDbI6 0x40
#define CxDbI7 0x48

#define CxDbD0 0x50
#define CxDbD1 0x58
#define CxDbD2 0x60
#define CxDbD3 0x68
#define CxDbD4 0x70
#define CxDbD5 0x78
#define CxDbD6 0x80
#define CxDbD7 0x88

#define CxFltS0 0x90
#define CxFltS1 0xa0
#define CxFltS2 0xb0
#define CxFltS3 0xc0

#define CxFltT0 0xd0
#define CxFltT1 0xe0
#define CxFltT2 0xf0
#define CxFltT3 0x100
#define CxFltT4 0x110
#define CxFltT5 0x120
#define CxFltT6 0x130
#define CxFltT7 0x140
#define CxFltT8 0x150
#define CxFltT9 0x160

#define CxFltS4 0x170
#define CxFltS5 0x180
#define CxFltS6 0x190
#define CxFltS7 0x1a0
#define CxFltS8 0x1b0
#define CxFltS9 0x1c0
#define CxFltS10 0x1d0
#define CxFltS11 0x1e0
#define CxFltS12 0x1f0
#define CxFltS13 0x200
#define CxFltS14 0x210
#define CxFltS15 0x220
#define CxFltS16 0x230
#define CxFltS17 0x240
#define CxFltS18 0x250
#define CxFltS19 0x260

#define CxFltF32 0x270
#define CxFltF33 0x280
#define CxFltF34 0x290
#define CxFltF35 0x2a0
#define CxFltF36 0x2b0
#define CxFltF37 0x2c0
#define CxFltF38 0x2d0
#define CxFltF39 0x2e0

#define CxFltF40 0x2f0
#define CxFltF41 0x300
#define CxFltF42 0x310
#define CxFltF43 0x320
#define CxFltF44 0x330
#define CxFltF45 0x340
#define CxFltF46 0x350
#define CxFltF47 0x360
#define CxFltF48 0x370
#define CxFltF49 0x380

#define CxFltF50 0x390
#define CxFltF51 0x3a0
#define CxFltF52 0x3b0
#define CxFltF53 0x3c0
#define CxFltF54 0x3d0
#define CxFltF55 0x3e0
#define CxFltF56 0x3f0
#define CxFltF57 0x400
#define CxFltF58 0x410
#define CxFltF59 0x420

#define CxFltF60 0x430
#define CxFltF61 0x440
#define CxFltF62 0x450
#define CxFltF63 0x460
#define CxFltF64 0x470
#define CxFltF65 0x480
#define CxFltF66 0x490
#define CxFltF67 0x4a0
#define CxFltF68 0x4b0
#define CxFltF69 0x4c0

#define CxFltF70 0x4d0
#define CxFltF71 0x4e0
#define CxFltF72 0x4f0
#define CxFltF73 0x500
#define CxFltF74 0x510
#define CxFltF75 0x520
#define CxFltF76 0x530
#define CxFltF77 0x540
#define CxFltF78 0x550
#define CxFltF79 0x560

#define CxFltF80 0x570
#define CxFltF81 0x580
#define CxFltF82 0x590
#define CxFltF83 0x5a0
#define CxFltF84 0x5b0
#define CxFltF85 0x5c0
#define CxFltF86 0x5d0
#define CxFltF87 0x5e0
#define CxFltF88 0x5f0
#define CxFltF89 0x600

#define CxFltF90 0x610
#define CxFltF91 0x620
#define CxFltF92 0x630
#define CxFltF93 0x640
#define CxFltF94 0x650
#define CxFltF95 0x660
#define CxFltF96 0x670
#define CxFltF97 0x680
#define CxFltF98 0x690
#define CxFltF99 0x6a0

#define CxFltF100 0x6b0
#define CxFltF101 0x6c0
#define CxFltF102 0x6d0
#define CxFltF103 0x6e0
#define CxFltF104 0x6f0
#define CxFltF105 0x700
#define CxFltF106 0x710
#define CxFltF107 0x720
#define CxFltF108 0x730
#define CxFltF109 0x740

#define CxFltF110 0x750
#define CxFltF111 0x760
#define CxFltF112 0x770
#define CxFltF113 0x780
#define CxFltF114 0x790
#define CxFltF115 0x7a0
#define CxFltF116 0x7b0
#define CxFltF117 0x7c0
#define CxFltF118 0x7d0
#define CxFltF119 0x7e0

#define CxFltF120 0x7f0
#define CxFltF121 0x800
#define CxFltF122 0x810
#define CxFltF123 0x820
#define CxFltF124 0x830
#define CxFltF125 0x840
#define CxFltF126 0x850
#define CxFltF127 0x860

#define CxStFPSR 0x870

#define CxIntGp 0x878
#define CxIntT0 0x880
#define CxIntT1 0x888
#define CxIntS0 0x890
#define CxIntS1 0x898
#define CxIntS2 0x8a0
#define CxIntS3 0x8a8
#define CxIntV0 0x8b0
#define CxIntT2 0x8b8
#define CxIntT3 0x8c0
#define CxIntT4 0x8c8
#define CxIntSp 0x8d0
#define CxIntTeb 0x8d8
#define CxIntT5 0x8e0
#define CxIntT6 0x8e8
#define CxIntT7 0x8f0
#define CxIntT8 0x8f8
#define CxIntT9 0x900

#define CxIntT10 0x908
#define CxIntT11 0x910
#define CxIntT12 0x918
#define CxIntT13 0x920
#define CxIntT14 0x928
#define CxIntT15 0x930
#define CxIntT16 0x938
#define CxIntT17 0x940
#define CxIntT18 0x948
#define CxIntT19 0x950
#define CxIntT20 0x958
#define CxIntT21 0x960
#define CxIntT22 0x968

#define CxIntNats 0x970
#define CxPreds 0x978

#define CxBrRp 0x980
#define CxBrS0 0x988
#define CxBrS1 0x990
#define CxBrS2 0x998
#define CxBrS3 0x9a0
#define CxBrS4 0x9a8
#define CxBrT0 0x9b0
#define CxBrT1 0x9b8

#define CxApUNAT 0x9c0
#define CxApLC 0x9c8
#define CxApEC 0x9d0
#define CxApCCV 0x9d8
#define CxApDCR 0x9e0
#define CxRsPFS 0x9e8
#define CxRsBSP 0x9f0
#define CxRsBSPSTORE 0x9f8
#define CxRsRSC 0xa00
#define CxRsRNAT 0xa08
#define CxStIPSR 0xa10
#define CxStIIP 0xa18
#define CxStIFS 0xa20

#define CxStFCR 0xa28
#define CxEflag 0xa30
#define CxSegCSD 0xa38
#define CxSegSSD 0xa40
#define CxCflag 0xa48
#define CxStFSR 0xa50
#define CxStFIR 0xa58
#define CxStFDR 0xa60

#define ContextFrameLength 0xa70


//
// Dispatcher Context Structure Offset Definitions
//

#define DcControlPc 0x10
#define DcFunctionEntry 0x20
#define DcEstablisherFrame 0x0
#define DcContextRecord 0x28

//
// Debug Register Offset Definitions and Length
//

#define TsAr21 0x0
#define TsAr24 0x8
#define TsAr25 0x10
#define TsAr26 0x18
#define TsAr27 0x20
#define TsAr28 0x28
#define TsAr29 0x30
#define TsAr30 0x38

//
// Higher FP Volatile Offset Definitions and Length
//

#define HiFltF32 0x0
#define HiFltF33 0x10
#define HiFltF34 0x20
#define HiFltF35 0x30
#define HiFltF36 0x40
#define HiFltF37 0x50
#define HiFltF38 0x60
#define HiFltF39 0x70

#define HiFltF40 0x80
#define HiFltF41 0x90
#define HiFltF42 0xa0
#define HiFltF43 0xb0
#define HiFltF44 0xc0
#define HiFltF45 0xd0
#define HiFltF46 0xe0
#define HiFltF47 0xf0
#define HiFltF48 0x100
#define HiFltF49 0x110

#define HiFltF50 0x120
#define HiFltF51 0x130
#define HiFltF52 0x140
#define HiFltF53 0x150
#define HiFltF54 0x160
#define HiFltF55 0x170
#define HiFltF56 0x180
#define HiFltF57 0x190
#define HiFltF58 0x1a0
#define HiFltF59 0x1b0

#define HiFltF60 0x1c0
#define HiFltF61 0x1d0
#define HiFltF62 0x1e0
#define HiFltF63 0x1f0
#define HiFltF64 0x200
#define HiFltF65 0x210
#define HiFltF66 0x220
#define HiFltF67 0x230
#define HiFltF68 0x240
#define HiFltF69 0x250

#define HiFltF70 0x260
#define HiFltF71 0x270
#define HiFltF72 0x280
#define HiFltF73 0x290
#define HiFltF74 0x2a0
#define HiFltF75 0x2b0
#define HiFltF76 0x2c0
#define HiFltF77 0x2d0
#define HiFltF78 0x2e0
#define HiFltF79 0x2f0

#define HiFltF80 0x300
#define HiFltF81 0x310
#define HiFltF82 0x320
#define HiFltF83 0x330
#define HiFltF84 0x340
#define HiFltF85 0x350
#define HiFltF86 0x360
#define HiFltF87 0x370
#define HiFltF88 0x380
#define HiFltF89 0x390

#define HiFltF90 0x3a0
#define HiFltF91 0x3b0
#define HiFltF92 0x3c0
#define HiFltF93 0x3d0
#define HiFltF94 0x3e0
#define HiFltF95 0x3f0
#define HiFltF96 0x400
#define HiFltF97 0x410
#define HiFltF98 0x420
#define HiFltF99 0x430

#define HiFltF100 0x440
#define HiFltF101 0x450
#define HiFltF102 0x460
#define HiFltF103 0x470
#define HiFltF104 0x480
#define HiFltF105 0x490
#define HiFltF106 0x4a0
#define HiFltF107 0x4b0
#define HiFltF108 0x4c0
#define HiFltF109 0x4d0

#define HiFltF110 0x4e0
#define HiFltF111 0x4f0
#define HiFltF112 0x500
#define HiFltF113 0x510
#define HiFltF114 0x520
#define HiFltF115 0x530
#define HiFltF116 0x540
#define HiFltF117 0x550
#define HiFltF118 0x560
#define HiFltF119 0x570

#define HiFltF120 0x580
#define HiFltF121 0x590
#define HiFltF122 0x5a0
#define HiFltF123 0x5b0
#define HiFltF124 0x5c0
#define HiFltF125 0x5d0
#define HiFltF126 0x5e0
#define HiFltF127 0x5f0


//
// Debug Register Offset Definitions and Length
//

#define DrDbI0 0x0
#define DrDbI1 0x8
#define DrDbI2 0x10
#define DrDbI3 0x18
#define DrDbI4 0x20
#define DrDbI5 0x28
#define DrDbI6 0x30
#define DrDbI7 0x38

#define DrDbD0 0x40
#define DrDbD1 0x48
#define DrDbD2 0x50
#define DrDbD3 0x58
#define DrDbD4 0x60
#define DrDbD5 0x68
#define DrDbD6 0x70
#define DrDbD7 0x78

#define TsAppRegisters 0x0
#define TsPerfRegisters 0x40
#define TsHigherFPVolatile 0x80
#define TsDebugRegisters 0x680
#define ThreadStateSaveAreaLength 0x700

//
// Exception Frame Offset Definitions and Length
//

#define ExFltS0 0x60
#define ExFltS1 0x70
#define ExFltS2 0x80
#define ExFltS3 0x90
#define ExFltS4 0xa0
#define ExFltS5 0xb0
#define ExFltS6 0xc0
#define ExFltS7 0xd0
#define ExFltS8 0xe0
#define ExFltS9 0xf0
#define ExFltS10 0x100
#define ExFltS11 0x110
#define ExFltS12 0x120
#define ExFltS13 0x130
#define ExFltS14 0x140
#define ExFltS15 0x150
#define ExFltS16 0x160
#define ExFltS17 0x170
#define ExFltS18 0x180
#define ExFltS19 0x190

#define ExIntS0 0x18
#define ExIntS1 0x20
#define ExIntS2 0x28
#define ExIntS3 0x30
#define ExIntNats 0x10

#define ExBrS0 0x38
#define ExBrS1 0x40
#define ExBrS2 0x48
#define ExBrS3 0x50
#define ExBrS4 0x58

#define ExApEC 0x0
#define ExApLC 0x8

#define ExceptionFrameLength 0x1a0

//
// Switch Frame Offset Definitions and Length
//

#define SwExFrame 0x30
#define SwPreds 0x0
#define SwRp 0x8
#define SwPFS 0x10
#define SwFPSR 0x18
#define SwBsp 0x20
#define SwRnat 0x28

#define SwitchFrameLength 0x1d0

//
// Plabel structure offset definitions
//

#define PlEntryPoint 0x0
#define PlGlobalPointer 0x8

//
// Trap Frame Offset Definitions and Length
//

#define TrFltT0 0x50
#define TrFltT1 0x60
#define TrFltT2 0x70
#define TrFltT3 0x80
#define TrFltT4 0x90
#define TrFltT5 0xa0
#define TrFltT6 0xb0
#define TrFltT7 0xc0
#define TrFltT8 0xd0
#define TrFltT9 0xe0

#define TrIntGp 0xf0
#define TrIntT0 0xf8
#define TrIntT1 0x100

#define TrApUNAT 0x108
#define TrApCCV 0x110
#define TrApDCR 0x118
#define TrPreds 0x120

#define TrIntV0 0x128
#define TrIntT2 0x130
#define TrIntT3 0x138
#define TrIntT4 0x140
#define TrIntSp 0x148
#define TrIntTeb 0x150
#define TrIntT5 0x158
#define TrIntT6 0x160
#define TrIntT7 0x168
#define TrIntT8 0x170
#define TrIntT9 0x178

#define TrIntT10 0x180
#define TrIntT11 0x188
#define TrIntT12 0x190
#define TrIntT13 0x198
#define TrIntT14 0x1a0
#define TrIntT15 0x1a8
#define TrIntT16 0x1b0
#define TrIntT17 0x1b8
#define TrIntT18 0x1c0
#define TrIntT19 0x1c8
#define TrIntT20 0x1d0
#define TrIntT21 0x1d8
#define TrIntT22 0x1e0

#define TrIntNats 0x1e8

#define TrBrRp 0x1f0
#define TrBrT0 0x1f8
#define TrBrT1 0x200

#define TrRsPFS 0x228
#define TrRsBSP 0x210
#define TrRsRSC 0x208
#define TrRsRNAT 0x220
#define TrRsBSPSTORE 0x218

#define TrStIPSR 0x230
#define TrStISR 0x250
#define TrStIFA 0x258
#define TrStIIP 0x238
#define TrStIIPA 0x260
#define TrStIFS 0x240
#define TrStIIM 0x268
#define TrStIHA 0x270
#define TrStFPSR 0x248

#define TrOldIrql 0x278
#define TrPreviousMode 0x27c
#define TrTrapFrame 0x280
#define TrHandler 0x328
#define TrEOFMarker 0x330
#define TrExceptionRecord 0x288

#define TrapFrameLength 0x340
#define TrapFrameArguments 0x40
#define KTRAP_FRAME_EOF 0xe0f0e0f0e0f0e000

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x10
#define LpbKernelStack 0x30
#define LpbPrcb 0x38
#define LpbProcess 0x40
#define LpbThread 0x48
#define LpbAcpiRsdt 0x108
#define LpbKernelPhysicalBase 0xc0
#define LpbKernelVirtualBase 0xc8
#define LpbInterruptStack 0xd0
#define LpbPanicStack 0xd8
#define LpbPcrPage 0xe0
#define LpbPdrPage 0xe8
#define LpbPcrPage2 0xf0
#define LpbMachineType 0xb8

//
// Address Space Layout Definitions
//

#define UREGION_INDEX 0x0
#define KSEG0_BASE 0xe000000080000000
#define KSEG2_BASE 0xe0000000a0000000
#define KADDRESS_BASE 0xe000000000000000
#define UADDRESS_BASE 0x0
#define SADDRESS_BASE 0x2000000000000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x17
#define PTI_SHIFT 0xd
#define PTE_SHIFT 0x3
#define VHPT_PDE_BITS 0x28

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x80002
#define KERNEL_BREAKPOINT 0x80001
#define BREAKPOINT_BREAKIN 0x80019

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define UserMode 0x1
#define FALSE 0x0
#define TRUE 0x1
#define KiPcr 0xe0000000ffff0000
#define KiPcr2 0xe0000000fffe0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\hal386.inc ===
;
;  Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00000H

;
;  Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 00001H
ATTEMPTED_SWITCH_FROM_DPC equ 000B8H
DATA_BUS_ERROR equ 0002EH
DATA_COHERENCY_EXCEPTION equ 00055H
HAL1_INITIALIZATION_FAILED equ 00061H
INSTRUCTION_BUS_ERROR equ 0002FH
INSTRUCTION_COHERENCY_EXCEPTION equ 00056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 0003DH
INTERRUPT_UNWIND_ATTEMPTED equ 0003CH
INVALID_AFFINITY_SET equ 00003H
INVALID_DATA_ACCESS_TRAP equ 00004H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 0004AH
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
KMODE_EXCEPTION_NOT_HANDLED equ 0001EH
NMI_HARDWARE_FAILURE equ 00080H
NO_USER_MODE_CONTEXT equ 0000EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 00049H
PANIC_STACK_SWITCH equ 0002BH
SPIN_LOCK_INIT_FAILURE equ 00081H
SYSTEM_EXIT_OWNED_MUTEX equ 00039H
SYSTEM_SERVICE_EXCEPTION equ 0003BH
SYSTEM_UNWIND_PREVIOUS_USER equ 0003AH
TRAP_CAUSE_UNKNOWN equ 00012H
UNEXPECTED_KERNEL_MODE_TRAP equ 0007FH
HARDWARE_INTERRUPT_STORM equ 000F2H

;
;  Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 00001H

;
;  Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 00001H
EXCEPTION_UNWINDING equ 00002H
EXCEPTION_EXIT_UNWIND equ 00004H
EXCEPTION_STACK_INVALID equ 00008H
EXCEPTION_NESTED_CALL equ 00010H
EXCEPTION_TARGET_UNWIND equ 00020H
EXCEPTION_COLLIDED_UNWIND equ 00040H
EXCEPTION_UNWIND equ 00066H
EXCEPTION_EXECUTE_HANDLER equ 00001H
EXCEPTION_CONTINUE_SEARCH equ 00000H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH
EXCEPTION_CHAIN_END equ 0FFFFFFFFH
FIXED_NTVDMSTATE_LINEAR equ 00714H

ExceptionContinueExecution equ 00000H
ExceptionContinueSearch equ 00001H
ExceptionNestedException equ 00002H
ExceptionCollidedUnwind equ 00003H

ErExceptionCode equ 00000H
ErExceptionFlags equ 00004H
ErExceptionRecord equ 00008H
ErExceptionAddress equ 0000CH
ErNumberParameters equ 00010H
ErExceptionInformation equ 00014H
ExceptionRecordLength equ 00050H

;
;  Fast Mutex Structure Offset Definitions
;

FmCount equ 00000H
FmOwner equ 00004H
FmContention equ 00008H
FmEvent equ 0000CH
FmOldIrql equ 0001CH

;
;  Interrupt Priority Request Level Definitions
;

PASSIVE_LEVEL equ 00000H
APC_LEVEL equ 00001H
DISPATCH_LEVEL equ 00002H
CLOCK1_LEVEL equ 0001CH
CLOCK2_LEVEL equ 0001CH
IPI_LEVEL equ 0001DH
POWER_LEVEL equ 0001EH
PROFILE_LEVEL equ 0001BH
HIGH_LEVEL equ 0001FH
ifdef NT_UP
SYNCH_LEVEL equ 00002H
else
SYNCH_LEVEL equ 0001CH
endif

;
;  Large Integer Structure Offset Definitions
;

LiLowPart equ 00000H
LiHighPart equ 00004H

;
;  List Entry Structure Offset Definitions
;

LsFlink equ 00000H
LsBlink equ 00004H

;
;  String Structure Offset Definitions
;

StrLength equ 00000H
StrMaximumLength equ 00002H
StrBuffer equ 00004H

;
;  System Time Structure Offset Definitions
;

StLowTime equ 00000H
StHigh1Time equ 00004H
StHigh2Time equ 00008H

;
;  Time Structure Offset Definitions
;

TmLowTime equ 00000H
TmHighTime equ 00004H

;
;  DPC object Structure Offset Definitions
;

DpType equ 00000H
DpNumber equ 00002H
DpImportance equ 00003H
DpDpcListEntry equ 00004H
DpDeferredRoutine equ 0000CH
DpDeferredContext equ 00010H
DpSystemArgument1 equ 00014H
DpSystemArgument2 equ 00018H
DpLock equ 0001CH
DpcObjectLength equ 00020H

;
;  Lock Queue Structure Offset Definitions
;

LOCK_QUEUE_WAIT equ 00001H
LOCK_QUEUE_OWNER equ 00002H
LOCK_QUEUE_HEADER_SIZE equ 00008H

LockQueueDispatcherLock equ 00000H
LockQueueContextSwapLock equ 00001H

LqNext equ 00000H
LqLock equ 00004H

LqhNext equ 00000H
LqhLock equ 00004H
LqhOldIrql equ 00008H

;
;  Processor Control Registers Structure Offset Definitions
;

KI_BEGIN_KERNEL_RESERVED equ 0FFDF0000H
ifdef NT_UP
    P0PCRADDRESS equ 0FFDFF000H
    PCR equ ds:[0FFDFF000H]
else
    PCR equ fs:
endif

PcExceptionList equ 00000H
PcInitialStack equ 00004H
PcStackLimit equ 00008H
PcSelfPcr equ 0001CH
PcPrcb equ 00020H
PcTeb equ 00018H
PcIrql equ 00024H
PcIRR equ 00028H
PcIrrActive equ 0002CH
PcIDR equ 00030H
PcIdt equ 00038H
PcGdt equ 0003CH
PcTss equ 00040H
PcDebugActive equ 00050H
PcNumber equ 00051H
PcVdmAlert equ 00054H
PcSetMember equ 00048H
PcStallScaleFactor equ 0004CH
PcHal equ 00094H

;
;  Defines for user shared data
;

USER_SHARED_DATA equ 0FFDF0000H
MM_SHARED_USER_DATA_VA equ 07FFE0000H
USERDATA equ ds:[0FFDF0000H]
UsTickCountLow equ 00000H
UsTickCountMultiplier equ 00004H
UsInterruptTime equ 00008H
UsSystemTime equ 00014H
UsSystemCall equ 00300H

;
;  Tss Structure Offset Definitions
;

TssEsp0 equ 00004H
TssCR3 equ 0001CH
TssEip equ 00020H
TssEFlags equ 00024H
TssEax equ 00028H
TssEbx equ 00034H
TssEcx equ 0002CH
TssEdx equ 00030H
TssEsp equ 00038H
TssEbp equ 0003CH
TssEsi equ 00040H
TssEdi equ 00044H
TssEs equ 00048H
TssCs equ 0004CH
TssSs equ 00050H
TssDs equ 00054H
TssFs equ 00058H
TssGs equ 0005CH
TssIoMapBase equ 00066H
TssIoMaps equ 00068H
TssLength equ 020ACH

;
;  Gdt Descriptor Offset Definitions
;

KGDT_R3_DATA equ 00020H
KGDT_R3_CODE equ 00018H
KGDT_R0_CODE equ 00008H
KGDT_R0_DATA equ 00010H
KGDT_R0_PCR equ 00030H
KGDT_STACK16 equ 000F8H
KGDT_CODE16 equ 000F0H
KGDT_TSS equ 00028H

;
;  GdtEntry Offset Definitions
;

KgdtBaseLow equ 00002H
KgdtBaseMid equ 00004H
KgdtBaseHi equ 00007H
KgdtLimitHi equ 00006H
KgdtLimitLow equ 00000H


;
;  Processor Block Structure Offset Definitions
;

PbCurrentThread equ 00004H
PbNextThread equ 00008H
PbIdleThread equ 0000CH
PbNumber equ 00010H
PbSetMember equ 00014H
PbCpuID equ 00019H
PbCpuType equ 00018H
PbCpuStep equ 0001AH
PbProcessorState equ 0001CH
PbHalReserved equ 0037CH
PbLockQueue equ 00418H

;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0000AH
TfMinute equ 00008H
TfHour equ 00006H
TfWeekday equ 0000EH
TfDay equ 00004H
TfMonth equ 00002H
TfYear equ 00000H
TfMilliseconds equ 0000CH


;
;  constants for system irql and IDT vector conversion
;

MAXIMUM_IDTVECTOR equ 000FFH
MAXIMUM_PRIMARY_VECTOR equ 000FFH
PRIMARY_VECTOR_BASE equ 00030H
RPL_MASK equ 00003H
MODE_MASK equ 00001H

;
;  Flags in the CR0 register
;

CR0_PG equ 080000000H
CR0_ET equ 00010H
CR0_TS equ 00008H
CR0_EM equ 00004H
CR0_MP equ 00002H
CR0_PE equ 00001H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 00020H

;
;  Flags in the CR4 register
;

CR4_VME equ 00001H
CR4_PVI equ 00002H
CR4_TSD equ 00004H
CR4_DE equ 00008H
CR4_PSE equ 00010H
CR4_PAE equ 00020H
CR4_MCE equ 00040H
CR4_PGE equ 00080H
CR4_FXSR equ 00200H
CR4_XMMEXCPT equ 00400H

;
;  Miscellaneous Definitions
;

MAXIMUM_PROCESSORS equ 00020H
INITIAL_STALL_COUNT equ 00064H
IRQL_NOT_GREATER_OR_EQUAL equ 00009H
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
MUTEX_ALREADY_OWNED equ 000BFH
THREAD_NOT_MUTEX_OWNER equ 00011H
SPIN_LOCK_ALREADY_OWNED equ 0000FH
SPIN_LOCK_NOT_OWNED equ 00010H

;
;  Trap Frame Offset Definitions and Length
;

TsExceptionList equ 0004CH
TsPreviousPreviousMode equ 00048H
TsSegGs equ 00030H
TsSegFs equ 00050H
TsSegEs equ 00034H
TsSegDs equ 00038H
TsEdi equ 00054H
TsEsi equ 00058H
TsEbp equ 00060H
TsEbx equ 0005CH
TsEdx equ 0003CH
TsEcx equ 00040H
TsEax equ 00044H
TsErrCode equ 00064H
TsEip equ 00068H
TsSegCs equ 0006CH
TsEflags equ 00070H
TsHardwareEsp equ 00074H
TsHardwareSegSs equ 00078H
TsTempSegCs equ 00010H
TsTempEsp equ 00014H
TsDbgEbp equ 00000H
TsDbgEip equ 00004H
TsDbgArgMark equ 00008H
TsDbgArgPointer equ 0000CH
TsDr0 equ 00018H
TsDr1 equ 0001CH
TsDr2 equ 00020H
TsDr3 equ 00024H
TsDr6 equ 00028H
TsDr7 equ 0002CH
TsV86Es equ 0007CH
TsV86Ds equ 00080H
TsV86Fs equ 00084H
TsV86Gs equ 00088H
KTRAP_FRAME_LENGTH equ 0008CH
KTRAP_FRAME_ALIGN equ 00004H
FRAME_EDITED equ 0FFF8H
EFLAGS_ALIGN_CHECK equ 040000H
EFLAGS_V86_MASK equ 020000H
EFLAGS_INTERRUPT_MASK equ 00200H
EFLAGS_TF equ 00100H
EFLAGS_VIF equ 080000H
EFLAGS_VIP equ 0100000H
EFLAGS_USER_SANITIZE equ 03E0DD7H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010007H
CONTEXT_DEBUG_REGISTERS equ 010010H
CONTEXT_CONTROL equ 010001H
CONTEXT_FLOATING_POINT equ 010008H
CONTEXT_INTEGER equ 010002H
CONTEXT_SEGMENTS equ 010004H

CsContextFlags equ 00000H
CsDr0 equ 00004H
CsDr1 equ 00008H
CsDr2 equ 0000CH
CsDr3 equ 00010H
CsDr6 equ 00014H
CsDr7 equ 00018H
CsFloatSave equ 0001CH
CsSegGs equ 0008CH
CsSegFs equ 00090H
CsSegEs equ 00094H
CsSegDs equ 00098H
CsEdi equ 0009CH
CsEsi equ 000A0H
CsEbx equ 000A4H
CsEdx equ 000A8H
CsEcx equ 000ACH
CsEax equ 000B0H
CsEbp equ 000B4H
CsEip equ 000B8H
CsSegCs equ 000BCH
CsEflags equ 000C0H
CsEsp equ 000C4H
CsSegSs equ 000C8H
CsExtendedRegisters equ 000CCH
ContextFrameLength equ 002D0H
DR6_LEGAL equ 0E00FH
DR7_LEGAL equ 0FFFF0155H
DR7_ACTIVE equ 00055H
ErrHandler equ 00004H
ErrNext equ 00000H

;
;  Floating save area field offset definitions
;

FpControlWord equ 00000H
FpStatusWord equ 00004H
FpTagWord equ 00008H
FpErrorOffset equ 0000CH
FpErrorSelector equ 00010H
FpDataOffset equ 00014H
FpDataSelector equ 00018H
FpRegisterArea equ 0001CH
FpCtxtCr0NpxState equ 0006CH

;
;  FX Floating save area field offset definitions
;

FxControlWord equ 00000H
FxStatusWord equ 00002H
FxTagWord equ 00004H
FxErrorOpcode equ 00006H
FxErrorOffset equ 00008H
FxErrorSelector equ 0000CH
FxDataOffset equ 00010H
FxDataSelector equ 00014H
FxMXCsr equ 00018H
FxFpRegisterArea equ 00020H
FpNpxSavedCpu equ 00208H
FpCr0NpxState equ 0020CH

NPX_FRAME_LENGTH equ 00210H

;
;  Processor State Frame Offset Definitions

;

PsContextFrame equ 00000H
PsSpecialRegisters equ 002CCH
SrCr0 equ 00000H
SrCr2 equ 00004H
SrCr3 equ 00008H
SrCr4 equ 0000CH
SrKernelDr0 equ 00010H
SrKernelDr1 equ 00014H
SrKernelDr2 equ 00018H
SrKernelDr3 equ 0001CH
SrKernelDr6 equ 00020H
SrKernelDr7 equ 00024H
SrGdtr equ 0002AH
SrIdtr equ 00032H
SrTr equ 00038H
SrLdtr equ 0003AH
ProcessorStateLength equ 00320H

;
;  Machine type definitions (Temporarily)
;

MACHINE_TYPE_ISA equ 00000H
MACHINE_TYPE_EISA equ 00001H
MACHINE_TYPE_MCA equ 00002H

;
;  LoaderParameterBlock offsets relative to base
;

LpbLoadOrderListHead equ 00000H
LpbMemoryDescriptorListHead equ 00008H
LpbKernelStack equ 00018H
LpbPrcb equ 0001CH
LpbProcess equ 00020H
LpbThread equ 00024H
LpbI386 equ 0005CH
LpbRegistryLength equ 00028H
LpbRegistryBase equ 0002CH
LpbConfigurationRoot equ 00030H
LpbArcBootDeviceName equ 00034H
LpbArcHalDeviceName equ 00038H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\halpalpha.h ===
#include "kxalpha.h"

//
// Wait Reason and Wait Type Enumerated Type Values
//

#define WrExecutive 0x0

//
// Bug Check Code Definitions
//

#define APC_INDEX_MISMATCH 0x1
#define ATTEMPTED_SWITCH_FROM_DPC 0xb8
#define DATA_BUS_ERROR 0x2e
#define DATA_COHERENCY_EXCEPTION 0x55
#define HAL1_INITIALIZATION_FAILED 0x61
#define INSTRUCTION_BUS_ERROR 0x2f
#define INSTRUCTION_COHERENCY_EXCEPTION 0x56
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_AFFINITY_SET 0x3
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_GT_ZERO_AT_SYSTEM_SERVICE 0x4a
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define KMODE_EXCEPTION_NOT_HANDLED 0x1e
#define NMI_HARDWARE_FAILURE 0x80
#define NO_USER_MODE_CONTEXT 0xe
#define PAGE_FAULT_WITH_INTERRUPTS_OFF 0x49
#define PANIC_STACK_SWITCH 0x2b
#define SPIN_LOCK_INIT_FAILURE 0x81
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12
#define UNEXPECTED_KERNEL_MODE_TRAP 0x7f

//
// Breakpoint type definitions
//

#define DBG_STATUS_CONTROL_C 0x1

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66
#define EXCEPTION_EXECUTE_HANDLER 0x1
#define EXCEPTION_CONTINUE_SEARCH 0x0
#define EXCEPTION_CONTINUE_EXECUTION 0xffffffff

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0xc
#define ErNumberParameters 0x10
#define ErExceptionInformation 0x14
#define ExceptionRecordLength 0x50

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x4
#define FmContention 0x8
#define FmEvent 0xc
#define FmOldIrql 0x1c

//
// Interrupt Priority Request Level Definitions
//

#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0x6
#define POWER_LEVEL 0x7
#define PROFILE_LEVEL 0x3
#define HIGH_LEVEL 0x7
#define SYNCH_LEVEL 0x5

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x4

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x4

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpNumber 0x2
#define DpImportance 0x3
#define DpDpcListEntry 0x4
#define DpDeferredRoutine 0xc
#define DpDeferredContext 0x10
#define DpSystemArgument1 0x14
#define DpSystemArgument2 0x18
#define DpLock 0x1c
#define DpcObjectLength 0x20

//
// Interrupt Object Structure Offset Definitions
//

#define InLevelSensitive 0x0
#define InLatched 0x1

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x4
#define InServiceRoutine 0xc
#define InServiceContext 0x10
#define InSpinLock 0x14
#define InActualLock 0x1c
#define InDispatchAddress 0x20
#define InVector 0x24
#define InIrql 0x28
#define InSynchronizeIrql 0x29
#define InFloatingSave 0x2a
#define InConnected 0x2b
#define InNumber 0x2c
#define InMode 0x30
#define InShareVector 0x2d
#define InDispatchCode 0x3c
#define InterruptObjectLength 0x4c

//
// Processor Control Registers Structure Offset Definitions
//

#define PCR_MINOR_VERSION 0x1
#define PCR_MAJOR_VERSION 0x1
#define PcMinorVersion 0x0
#define PcMajorVersion 0x4
#define PcPalBaseAddress 0x8
#define PcPalMajorVersion 0x10
#define PcPalMinorVersion 0x14
#define PcPalSequenceVersion 0x18
#define PcPalMajorSpecification 0x1c
#define PcPalMinorSpecification 0x20
#define PcFirmwareRestartAddress 0x28
#define PcRestartBlock 0x30
#define PcPalReserved 0x38
#define PcPalAlignmentFixupCount 0xc30
#define PcPanicStack 0xc38
#define PcProcessorType 0xc3c
#define PcProcessorRevision 0xc40
#define PcPhysicalAddressBits 0xc44
#define PcMaximumAddressSpaceNumber 0xc48
#define PcPageSize 0xc4c
#define PcFirstLevelDcacheSize 0xc50
#define PcFirstLevelDcacheFillSize 0xc54
#define PcFirstLevelIcacheSize 0xc58
#define PcFirstLevelIcacheFillSize 0xc5c
#define PcFirmwareRevisionId 0xc60
#define PcSystemType 0xc64
#define PcSystemVariant 0xc6c
#define PcSystemRevision 0xc70
#define PcSystemSerialNumber 0xc74
#define PcCycleClockPeriod 0xc84
#define PcSecondLevelCacheSize 0xc88
#define PcSecondLevelCacheFillSize 0xc8c
#define PcThirdLevelCacheSize 0xc90
#define PcThirdLevelCacheFillSize 0xc94
#define PcFourthLevelCacheSize 0xc98
#define PcFourthLevelCacheFillSize 0xc9c
#define PcPrcb 0xca0
#define PcNumber 0xca4
#define PcSetMember 0xca8
#define PcHalReserved 0xcb0
#define PcIrqlTable 0xeb0
#define PcIrqlMask 0xed0
#define PcInterruptRoutine 0x10e0
#define PcReservedVectors 0x14e0
#define PcMachineCheckError 0x14f0
#define PcDpcStack 0x14f4
#define PcNotMember 0x14e4
#define PcCurrentPid 0x14fc
#define PcSystemServiceDispatchStart 0x1504
#define PcSystemServiceDispatchEnd 0x1508
#define PcIdleThread 0x150c
#define ProcessorControlRegisterLength 0x1510
#define SharedUserData 0xff000000
#define UsTickCountLow 0x0
#define UsTickCountMultiplier 0x4
#define UsInterruptTime 0x8
#define UsSystemTime 0x10

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x2
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x4
#define PbNextThread 0x8
#define PbIdleThread 0xc
#define PbNumber 0x10
#define PbBuildType 0x12
#define PbSetMember 0x14
#define PbRestartBlock 0x18
#define PbPowerState 0x648
#define ProcessorBlockLength 0x6d0

//
// Processor Power State Offset Definitions
//

#define PpIdleFunction 0x0

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x20007
#define CONTEXT_CONTROL 0x20001
#define CONTEXT_FLOATING_POINT 0x20002
#define CONTEXT_INTEGER 0x20004

#define CxFltF0 0x0
#define CxFltF1 0x8
#define CxFltF2 0x10
#define CxFltF3 0x18
#define CxFltF4 0x20
#define CxFltF5 0x28
#define CxFltF6 0x30
#define CxFltF7 0x38
#define CxFltF8 0x40
#define CxFltF9 0x48
#define CxFltF10 0x50
#define CxFltF11 0x58
#define CxFltF12 0x60
#define CxFltF13 0x68
#define CxFltF14 0x70
#define CxFltF15 0x78
#define CxFltF16 0x80
#define CxFltF17 0x88
#define CxFltF18 0x90
#define CxFltF19 0x98
#define CxFltF20 0xa0
#define CxFltF21 0xa8
#define CxFltF22 0xb0
#define CxFltF23 0xb8
#define CxFltF24 0xc0
#define CxFltF25 0xc8
#define CxFltF26 0xd0
#define CxFltF27 0xd8
#define CxFltF28 0xe0
#define CxFltF29 0xe8
#define CxFltF30 0xf0
#define CxFltF31 0xf8
#define CxIntV0 0x100
#define CxIntT0 0x108
#define CxIntT1 0x110
#define CxIntT2 0x118
#define CxIntT3 0x120
#define CxIntT4 0x128
#define CxIntT5 0x130
#define CxIntT6 0x138
#define CxIntT7 0x140
#define CxIntS0 0x148
#define CxIntS1 0x150
#define CxIntS2 0x158
#define CxIntS3 0x160
#define CxIntS4 0x168
#define CxIntS5 0x170
#define CxIntFp 0x178
#define CxIntA0 0x180
#define CxIntA1 0x188
#define CxIntA2 0x190
#define CxIntA3 0x198
#define CxIntA4 0x1a0
#define CxIntA5 0x1a8
#define CxIntT8 0x1b0
#define CxIntT9 0x1b8
#define CxIntT10 0x1c0
#define CxIntT11 0x1c8
#define CxIntRa 0x1d0
#define CxIntT12 0x1d8
#define CxIntAt 0x1e0
#define CxIntGp 0x1e8
#define CxIntSp 0x1f0
#define CxIntZero 0x1f8
#define CxFpcr 0x200
#define CxSoftFpcr 0x208
#define CxFir 0x210
#define CxPsr 0x218
#define CxContextFlags 0x21c
#define ContextFrameLength 0x230

//
// Exception Frame Offset Definitions and Length
//

#define ExFltF2 0x8
#define ExFltF3 0x10
#define ExFltF4 0x18
#define ExFltF5 0x20
#define ExFltF6 0x28
#define ExFltF7 0x30
#define ExFltF8 0x38
#define ExFltF9 0x40
#define ExIntS0 0x48
#define ExIntS1 0x50
#define ExIntS2 0x58
#define ExIntS3 0x60
#define ExIntS4 0x68
#define ExIntS5 0x70
#define ExIntFp 0x78
#define ExPsr 0x88
#define ExSwapReturn 0x80
#define ExIntRa 0x0
#define ExceptionFrameLength 0xa0

//
// Jump Offset Definitions and Length
//

#define JbFp 0x0
#define JbPc 0x4
#define JbSeb 0x8
#define JbType 0xc
#define JbFltF2 0x10
#define JbFltF3 0x18
#define JbFltF4 0x20
#define JbFltF5 0x28
#define JbFltF6 0x30
#define JbFltF7 0x38
#define JbFltF8 0x40
#define JbFltF9 0x48
#define JbIntS0 0x50
#define JbIntS1 0x58
#define JbIntS2 0x60
#define JbIntS3 0x68
#define JbIntS4 0x70
#define JbIntS5 0x78
#define JbIntS6 0x80
#define JbIntSp 0x88
#define JbFir 0x90

//
// Trap Frame Offset Definitions and Length
//

#define TrFltF0 0x128
#define TrFltF1 0x138
#define TrFltF10 0x140
#define TrFltF11 0x148
#define TrFltF12 0x150
#define TrFltF13 0x158
#define TrFltF14 0x160
#define TrFltF15 0x168
#define TrFltF16 0x170
#define TrFltF17 0x178
#define TrFltF18 0x180
#define TrFltF19 0x188
#define TrFltF20 0x190
#define TrFltF21 0x198
#define TrFltF22 0x1a0
#define TrFltF23 0x1a8
#define TrFltF24 0x1b0
#define TrFltF25 0x1b8
#define TrFltF26 0x1c0
#define TrFltF27 0x1c8
#define TrFltF28 0x1d0
#define TrFltF29 0x1d8
#define TrFltF30 0x1e0
#define TrIntV0 0xa0
#define TrIntT0 0xa8
#define TrIntT1 0xb0
#define TrIntT2 0xb8
#define TrIntT3 0xc0
#define TrIntT4 0xc8
#define TrIntT5 0xd0
#define TrIntT6 0xd8
#define TrIntT7 0xe0
#define TrIntFp 0x18
#define TrIntA0 0x20
#define TrIntA1 0x28
#define TrIntA2 0x30
#define TrIntA3 0x38
#define TrIntA4 0x118
#define TrIntA5 0x120
#define TrIntT8 0xe8
#define TrIntT9 0xf0
#define TrIntT10 0xf8
#define TrIntT11 0x100
#define TrIntT12 0x108
#define TrIntAt 0x110
#define TrIntGp 0x48
#define TrIntSp 0x0
#define TrFpcr 0x130
#define TrPsr 0x10
#define TrFir 0x8
#define TrExceptionRecord 0x50
#define TrOldIrql 0x1e8
#define TrPreviousMode 0x1ec
#define TrIntRa 0x40
#define TrTrapFrame 0x1f0
#define TrapFrameLength 0x200

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x8
#define LpbKernelStack 0x18
#define LpbPrcb 0x1c
#define LpbProcess 0x20
#define LpbThread 0x24
#define LpbRegistryLength 0x28
#define LpbRegistryBase 0x2c
#define LpbDpcStack 0x60
#define LpbFirstLevelDcacheSize 0x64
#define LpbFirstLevelDcacheFillSize 0x68
#define LpbFirstLevelIcacheSize 0x6c
#define LpbFirstLevelIcacheFillSize 0x70
#define LpbGpBase 0x74
#define LpbPanicStack 0x78
#define LpbPcrPage 0x7c
#define LpbPdrPage 0x80
#define LpbSecondLevelDcacheSize 0x84
#define LpbSecondLevelDcacheFillSize 0x88
#define LpbSecondLevelIcacheSize 0x8c
#define LpbSecondLevelIcacheFillSize 0x90
#define LpbPhysicalAddressBits 0x94
#define LpbMaximumAddressSpaceNumber 0x98
#define LpbSystemSerialNumber 0x9c
#define LpbSystemType 0xac
#define LpbSystemVariant 0xb4
#define LpbSystemRevision 0xb8
#define LpbProcessorType 0xbc
#define LpbProcessorRevision 0xc0
#define LpbCycleClockPeriod 0xc4
#define LpbPageSize 0xc8
#define LpbRestartBlock 0xcc
#define LpbFirmwareRestartAddress 0xd0
#define LpbFirmwareRevisionId 0xd8
#define LpbPalBaseAddress 0xdc

//
// Restart Block Structure Definitions
//

#define RbSignature 0x0
#define RbLength 0x4
#define RbVersion 0x8
#define RbRevision 0xa
#define RbNextRestartBlock 0xc
#define RbRestartAddress 0x10
#define RbBootMasterId 0x14
#define RbProcessorId 0x18
#define RbBootStatus 0x1c
#define RbCheckSum 0x20
#define RbSaveAreaLength 0x24
#define RbSaveArea 0x28
#define RbHaltReason 0x28
#define RbLogoutFrame 0x2c
#define RbPalBase 0x30
#define RbIntV0 0x38
#define RbIntT0 0x40
#define RbIntT1 0x48
#define RbIntT2 0x50
#define RbIntT3 0x58
#define RbIntT4 0x60
#define RbIntT5 0x68
#define RbIntT6 0x70
#define RbIntT7 0x78
#define RbIntS0 0x80
#define RbIntS1 0x88
#define RbIntS2 0x90
#define RbIntS3 0x98
#define RbIntS4 0xa0
#define RbIntS5 0xa8
#define RbIntFp 0xb0
#define RbIntA0 0xb8
#define RbIntA1 0xc0
#define RbIntA2 0xc8
#define RbIntA3 0xd0
#define RbIntA4 0xd8
#define RbIntA5 0xe0
#define RbIntT8 0xe8
#define RbIntT9 0xf0
#define RbIntT10 0xf8
#define RbIntT11 0x100
#define RbIntRa 0x108
#define RbIntT12 0x110
#define RbIntAT 0x118
#define RbIntGp 0x120
#define RbIntSp 0x128
#define RbIntZero 0x130
#define RbFpcr 0x138
#define RbFltF0 0x140
#define RbFltF1 0x148
#define RbFltF2 0x150
#define RbFltF3 0x158
#define RbFltF4 0x160
#define RbFltF5 0x168
#define RbFltF6 0x170
#define RbFltF7 0x178
#define RbFltF8 0x180
#define RbFltF9 0x188
#define RbFltF10 0x190
#define RbFltF11 0x198
#define RbFltF12 0x1a0
#define RbFltF13 0x1a8
#define RbFltF14 0x1b0
#define RbFltF15 0x1b8
#define RbFltF16 0x1c0
#define RbFltF17 0x1c8
#define RbFltF18 0x1d0
#define RbFltF19 0x1d8
#define RbFltF20 0x1e0
#define RbFltF21 0x1e8
#define RbFltF22 0x1f0
#define RbFltF23 0x1f8
#define RbFltF24 0x200
#define RbFltF25 0x208
#define RbFltF26 0x210
#define RbFltF27 0x218
#define RbFltF28 0x220
#define RbFltF29 0x228
#define RbFltF30 0x230
#define RbFltF31 0x238
#define RbAsn 0x240
#define RbGeneralEntry 0x244
#define RbIksp 0x248
#define RbInterruptEntry 0x24c
#define RbKgp 0x250
#define RbMces 0x254
#define RbMemMgmtEntry 0x258
#define RbPanicEntry 0x25c
#define RbPcr 0x260
#define RbPdr 0x264
#define RbPsr 0x268
#define RbReiRestartAddress 0x26c
#define RbSirr 0x270
#define RbSyscallEntry 0x274
#define RbTeb 0x278
#define RbThread 0x27c
#define RbPerProcessorState 0x280

//
// Address Space Layout Definitions
//

#define KSEG0_BASE 0x80000000
#define KSEG2_BASE 0xc0000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x18
#define PTI_SHIFT 0xd

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x0
#define KERNEL_BREAKPOINT 0x1
#define BREAKIN_BREAKPOINT 0x19
#define DEBUG_PRINT_BREAKPOINT 0x14
#define DEBUG_PROMPT_BREAKPOINT 0x15
#define DEBUG_STOP_BREAKPOINT 0x16
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 0x17
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 0x18

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define FALSE 0x0
#define TRUE 0x1
#define PROCESSOR_ALPHA_21064 0x5248
#define PROCESSOR_ALPHA_21164 0x52ac
#define PROCESSOR_ALPHA_21066 0x524a
#define PROCESSOR_ALPHA_21068 0x524c
#define PROCESSOR_ALPHA_21164PC 0x52ad
#define PROCESSOR_ALPHA_21264 0x5310
#define MCHK_CORRECTABLE_MASK 0x1
#define MCHK_CORRECTABLE 0x0
#define MCHK_RETRYABLE_MASK 0x2
#define MCHK_RETRYABLE 0x1
#define MCES_MCK_MASK 0x1
#define MCES_MCK 0x0
#define MCES_SCE_MASK 0x2
#define MCES_SCE 0x1
#define MCES_PCE_MASK 0x4
#define MCES_PCE 0x2
#define MCES_DPC_MASK 0x8
#define MCES_DPC 0x3
#define MCES_DSC_MASK 0x10
#define MCES_DSC 0x4
#define MCES_DMCK_MASK 0x20
#define MCES_DMCK 0x5

//
// Call PAL Mnemonics
//

// begin callpal

#define bpt 0x80
#define callsys 0x83
#define imb 0x86
#define gentrap 0xaa
#define rdteb 0xab
#define kbpt 0xac
#define callkd 0xad
#define halt 0x0
#define restart 0x1
#define draina 0x2
#define reboot 0x3
#define initpal 0x4
#define wrentry 0x5
#define swpirql 0x6
#define rdirql 0x7
#define di 0x8
#define ei 0x9
#define swppal 0xa
#define ssir 0xc
#define csir 0xd
#define rfe 0xe
#define retsys 0xf
#define swpctx 0x10
#define swpprocess 0x11
#define rdmces 0x12
#define wrmces 0x13
#define tbia 0x14
#define tbis 0x15
#define tbisasn 0x17
#define dtbis 0x16
#define rdksp 0x18
#define swpksp 0x19
#define rdpsr 0x1a
#define rdpcr 0x1c
#define rdthread 0x1e
#define tbim 0x20
#define tbimasn 0x21
#define tbim64 0x22
#define tbis64 0x23
#define ealnfix 0x24
#define dalnfix 0x25
#define rdcounters 0x30
#define rdstate 0x31
#define wrperfmon 0x32
#define cp_sleep 0x39
#define initpcr 0x38

// end callpal


//
// Bios Argument Structure Definitions
//

#define BaEax 0x0
#define BaEbx 0x4
#define BaEcx 0x8
#define BaEdx 0xc
#define BaEsi 0x10
#define BaEdi 0x14
#define BaEbp 0x18
#define BiosArgumentLength 0x1c

//
// Define Vendor Callback Read/Write Error Frame Operation Types
//

#define ReadFrame 0x1
#define WriteFrame 0x2

//
// Define Vendor Callback Vector Base Address
//

#define SYSTEM_VECTOR_BASE 0x806fe028

//
// Define Vendor Callback Offsets
//

#define VnCallBiosRoutine 0x38
#define VnReadWriteErrorFrameRoutine 0x98
#define VnVideoDisplayInitializeRoutine 0x10
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\inbv.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    inbv.h

Abstract:

    This module contains the public header information (function prototypes,
    data and type declarations) for the Initialization Boot Video component.

Author:

    Erick Smith (ericks) 23-Mar-1998

Revision History:

--*/

#ifndef _INBV_
#define _INBV_

typedef enum _INBV_DISPLAY_STATE
{
    INBV_DISPLAY_STATE_OWNED,     // we own the display
    INBV_DISPLAY_STATE_DISABLED,  // we own but should not use
    INBV_DISPLAY_STATE_LOST       // we lost ownership
} INBV_DISPLAY_STATE;

typedef
BOOLEAN
(*INBV_RESET_DISPLAY_PARAMETERS)(
    ULONG Cols,
    ULONG Rows
    );

typedef
VOID
(*INBV_DISPLAY_STRING_FILTER)(
    PUCHAR *Str
    );

VOID
InbvNotifyDisplayOwnershipLost(
    INBV_RESET_DISPLAY_PARAMETERS ResetDisplayParameters
    );

VOID
InbvInstallDisplayStringFilter(
    INBV_DISPLAY_STRING_FILTER DisplayStringFilter
    );

VOID
InbvAcquireDisplayOwnership(
    VOID
    );

BOOLEAN
InbvDriverInitialize(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG Count
    );

BOOLEAN
InbvResetDisplay(
    );

VOID
InbvBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    );

VOID
InbvSolidColorFill(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2,
    ULONG color
    );

BOOLEAN
InbvDisplayString(
    PUCHAR Str
    );

VOID
InbvUpdateProgressBar(
    ULONG Percentage
    );

VOID
InbvSetProgressBarSubset(
    ULONG   Floor,
    ULONG   Ceiling
    );

VOID
InbvSetBootDriverBehavior(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
InbvIndicateProgress(
    VOID
    );

VOID
InbvSetProgressBarCoordinates(
    ULONG x,
    ULONG y
    );

VOID
InbvEnableBootDriver(
    BOOLEAN bEnable
    );

BOOLEAN
InbvEnableDisplayString(
    BOOLEAN bEnable
    );

BOOLEAN
InbvIsBootDriverInstalled(
    VOID
    );

PUCHAR
InbvGetResourceAddress(
    IN ULONG ResourceNumber
    );

VOID
InbvBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    );

VOID
InbvScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    );

BOOLEAN
InbvTestLock(
    VOID
    );

VOID
InbvAcquireLock(
    VOID
    );

VOID
InbvReleaseLock(
    VOID
    );

BOOLEAN
InbvCheckDisplayOwnership(
    VOID
    );

VOID
InbvSetScrollRegion(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2
    );

ULONG
InbvSetTextColor(
    ULONG Color
    );

VOID
InbvSetDisplayOwnership(
    BOOLEAN DisplayOwned
    );

INBV_DISPLAY_STATE
InbvGetDisplayState(
    VOID
    );

//
// Functions defined in port.c
//
BOOLEAN
InbvPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress,
    OUT PULONG BlFileId,
    IN BOOLEAN IsMMIOAddress
    );
    
BOOLEAN
InbvPortTerminate(
    IN ULONG BlFileId
    );

VOID
InbvPortPutString (
    IN ULONG BlFileId,
    IN PUCHAR Output
    );
    
VOID
InbvPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    );

BOOLEAN
InbvPortPollOnly (
    IN ULONG BlFileId
    );

BOOLEAN
InbvPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    );

VOID
InbvPortEnableFifo(
    IN ULONG 	DeviceId,
    IN BOOLEAN	bEnable
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\genxx.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    genxx.h

Abstract:

    This file contains macros (some of them destined for the M4 preprocessor)
    to aid in the generation of ks & hal header files.  This is used by
    ke\xxx\genxxx.c, as well as sdktools\genxx.

Author:

    Forrest C. Foltz (forrestf) 23-Jan-1998

Revision History:

--*/



//
// Structure element definitions.
//

#define MAX_ELEMENT_NAME_LEN 127    // big enough for comments too
typedef struct _STRUC_ELEMENT {

//
// Flags is one or more SEF_xxx, defined below.
//

    UINT64 Flags;

//
// Note that Equate is used to store a pointer in the case of bitfield
// processing.
//

    UINT64 Equate;

//
// Name should be quite long, as it is used to hold comments as well.
//

    CHAR Name[ MAX_ELEMENT_NAME_LEN + 1 ];
} STRUC_ELEMENT, *PSTRUC_ELEMENT;

#define SEF_ENABLE_MASK     0x0000FF00
#define SEF_HAL             0x00000100
#define SEF_KERNEL          0x00000200

#define SEF_INC_FORMAT_MASK 0x00010000
#define SEF_H_FORMAT        0x00000000
#define SEF_INC_FORMAT      0x00010000

//
// Types.  Note that SETMASK, CLRMASK has no effect on te BITFLD types.  BITFLD
// types have SEF_HAL | SEF_KERNEL set in the type.
//

#define SEF_TYPE_MASK       0x000000FF
#define SEF_EQUATE          0x00000000
#define SEF_EQUATE64        0x00000001
#define SEF_COMMENT         0x00000002
#define SEF_STRING          0x00000003      // Equate is vararg to printf
#define SEF_BITFLD          0x00000004
#define SEF_BITALIAS        0x00000005
#define SEF_STRUCTURE       0x00000006
#define SEF_SETMASK         0x00000010      // Equate is the mask
#define SEF_CLRMASK         0x00000011      // Equate is the mask
#define SEF_END             0x00000012
#define SEF_START           0x00000013
#define SEF_PATH            0x00000014

//
// Note that BITFLD entries have per-entry hal|kernel flags
//


//
// Define architecture specific generation macros.
//

#define SEF_FLAGS 0
#define HAL SEF_HAL
#define KERNEL SEF_KERNEL

#ifndef ULONG_MAX
#define ULONG_MAX 0xFFFFFFFF
#endif

#ifndef LONG_MAX
#define LONG_MAX ((LONG)0x7FFFFFFF)
#endif

#ifndef LONG_MIN
#define LONG_MIN ((LONG)0x80000000)
#endif


#ifdef _WIN64_
#define SEF_UINT SEF_EQUATE64
#else
#define SEF_UINT SEF_EQUATE
#endif

//
// genDef(Pc, KPCR, MinorVersion)
//
// -> #define PcMinorVersion 0x0
//

#define genDef(Prefix, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Prefix #Member },

//
// genOff(Pc, KPCR, MinorVersion, 128)
//
// -> #define PcMinorVersion 0xffffff80
//

#define genOff(Prefix, Type, Member, Offset) \
    { SEF_EQUATE, OFFSET(Type, Member) - Offset, #Prefix #Member },

//
// genAlt( PbAlignmentFixupCount, KPRCB, KeAlignmentFixupCount )
//
// -> #define PbAlignmentFixupCount 0x2f4
//

#define genAlt(Name, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Name },

//
// genCom("This is a comment")
//
//    //
// -> // This is a comment
//    //
//

#define genCom(Comment) \
    { SEF_COMMENT, 0, Comment },

//
// genNam(PCR_MINOR_VERSION)
//
// -> #define PCR_MINOR_VERSION 0x1
//

#define genNam(Name) \
    { SEF_EQUATE, (ULONG)(Name), #Name },

//
// genNamUint(KSEG0_BASE)
//
// -> #define KSE0_BASE 0xffffffff80000000
//

#define genNamUint(Name) \
    { SEF_UINT, (UINT64)(Name), #Name },

//
// genVal(FirmwareFrameLength, FIRMWARE_FRAME_LENGTH)
//
// -> #define FirmwareFrameLength 0x250
//
// Note: if the value is 64-bit when _WIN64_ is enabled, use genValUint()
//

#define genVal(Name, Value) \
    { SEF_EQUATE, (ULONG)(Value), #Name },

//
// genValUint(KiPcr, KIPCR)
//
// -> #define KiPcr 0xe0000000ffffe000
//

#define genValUint(Name, Value) \
    { SEF_UINT, (UINT64)(Value), #Name },

//
// genSpc()
//
// ->
//

#define genSpc() \
    { SEF_STRING, 0, "\n" },

//
// genStr("    PCR equ ds:[0%lXH]\n", KIP0PCRADDRESS)
//
// ->     PCR equ ds:[0FFDFF000H]
//

#define genStr(String, Value) \
    { SEF_STRING, (ULONG_PTR)(Value), String },

//
// genTxt("ifdef NT_UP\n")
//
// -> ifdef NT_UP
//

#define genTxt(String) \
    { SEF_STRING, 0, String },

#define DisableInc( x ) \
    { SEF_CLRMASK, x, "" },

#define EnableInc( x ) \
    { SEF_SETMASK, x, "" },

#define MARKER_STRING "This is the genxx marker string."

//
// Source file can specify the _NTDRIVE\_NTROOT - relative output path.
// 'f' is the set of enable-flags that should be routed to this file.
// Use '0' if there is only a single output file.
//
// 'f' should also contain one of SEF_H_FORMAT or SEF_INC_FORMAT to
// indicate whether the generated file is in 'header file' or 'include file'
// format.
//

#define setPath( p, f ) \
    { SEF_PATH | f, 0, p },

//
// START_LIST defines the first element in ElementList.  This element contains
// a (possibly truncated) pointer to the ElementList array.  This is used to
// determine the fixup RA bias.
//

#define START_LIST \
    { SEF_START, (ULONG_PTR)ElementList, MARKER_STRING },

#define END_LIST \
    { SEF_END, 0, "" }

//
// Preprocessor assertion.  Do something here to make the compiler generate
// an error if x != y.
//

#define ASSERT_SAME( x, y )

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#ifndef OFFSET

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif

//
// Following are some M4 macros to help with bitfields.
//

#ifndef SKIP_M4

//
// First, define the makezeros(n) macro that will generate a string with
// n pairs of ',0'.  This is a recursively defined macro.
//

define(`makezeros',`ifelse(eval($1),0,,`0,makezeros(eval($1-1))')')

//
// Define a concatenation macro.
//

define(`cat',`$1$2')

//
// The following example bitfield declaration uses HARDWARE_PTE as an
// example, which is declared (for alpha) as follows:
//
// typedef struct _HARDWARE_PTE {
//     ULONG Valid: 1;
//     ULONG Owner: 1;
//     ULONG Dirty: 1;
//     ULONG reserved: 1;
//     ULONG Global: 1;
//     ULONG GranularityHint: 2;
//     ULONG Write: 1;
//     ULONG CopyOnWrite: 1;
//     ULONG PageFrameNumber: 23;
// } HARDWARE_PTE, *PHARDWARE_PTE;
//
//
// // First, startBitStruc() is invoked with the structure name.
//
// startBitStruc( HARDWARE_PTE, SEF_HAL | SEF_KERNEL )
//
// //
// // Now, suppose we wanted to expose seven of the fields in an assembly
// // include file:
// //
//
// genBitField( Valid, PTE_VALID )
// genBitField( Owner, PTE_OWNER )
// genBitField( Dirty, PTE_DIRTY )
// genBitField( reserved )
// genBitField( Global, PTE_GLOBAL )
// genBitField( GranularityHint )
// genBitField( Write, PTE_WRITE )
// genBitField( CopyOnWrite, PTE_COPYONWRITE )
// genBitField( PageFrameNumber, PTE_PFN )
//
// Note that fields that are not used (in this case 'reserved' and
// 'GranularityHint') must still appear in the list.
//
// The above will generate a bunch of static, initialized copies of HARDWARE_PTE
// like so:
//
// HARDWARE_PTE HARDWARE_PTE_Valid = {
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Owner = {
//     0,   // Valid
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Dirty = {
//     0,   // Valid
//     0,   // Owner
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Global = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Write = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_CopyOnWrite = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_PageFrameNumber = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0,   // CopyOnWrite
//     0xFFFFFFFF };
//
// Then, as part of processing the END_LIST macro, these structures are
// generated:
//
// { SEF_BITFLD, &HARDWARE_PTE_Valid,           "PTE_VALID" },
// { SEF_BITFLD, &HARDWARE_PTE_Owner,           "PTE_OWNER" },
// { SEF_BITFLD, &HARDWARE_PTE_Dirty,           "PTE_DIRTY" },
// { SEF_BITFLD, &HARDWARE_PTE_Global,          "PTE_GLOBAL" },
// { SEF_BITFLD, &HARDWARE_PTE_Write,           "PTE_WRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_CopyOnWrite,     "PTE_COPYONWRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_PageFrameNumber, "PTE_PFN" },
// { SEF_END,    0,                             "" }
//
//
// ... and that's what gets compiled by the target compiler into the .obj.
// Now, the final stage: genxx.exe is run against this target .obj, and
// would generate the following:
//
// #define PTE_VALID_MASK 0x1
// #define PTE_VALID 0x0
// #define PTE_OWNER_MASK 0x2
// #define PTE_OWNER 0x1
// #define PTE_DIRTY_MASK 0x4
// #define PTE_DIRTY 0x2
// #define PTE_GLOBAL_MASK 0x10
// #define PTE_GLOBAL 0x4
// #define PTE_WRITE_MASK 0x80
// #define PTE_WRITE 0x7
// #define PTE_COPYONWRITE_MASK 0x100
// #define PTE_COPYONWRITE 0x8
// #define PTE_PFN_MASK 0xfffffe00
// #define PTE_PFN 0x9
//

//
// BITFIELD_STRUCS accumulates array element initializations.  END_LIST will
// dump these into the definition array.
//

define(`BITFIELD_STRUCS',`')

//
// startBitStruc( <strucname>, <whichfile> )
// sets BIT_STRUC_NAME = <strucname> and resets the ZERO_FIELDS count to 0.
// It also sets the WHICH_FILE macro.
//

define(`startBitStruc', `define(`BIT_STRUC_NAME',`$1')
                         define(`BITFIELD_STRUCS',
                                 BITFIELD_STRUCS
                                 )
                         define(`ZERO_FIELDS',0)
                         define(`SEF_TYPE',$2)
                        ')

//
// genBitField( <fldname>, <generatedname> ) declares a structure of type
// <strucname> and initializes the <fldname> bitfield within it.
//
// Note that I used "cma" instead of an actual comma, this gets changed to
// a comma by DUMP_BITFIELDS, below.  If I were more proficient with M4 I
// would know how to get around this.
//

define(`genBitField', `define(`VAR_NAME', cat(cat(BIT_STRUC_NAME,`_'),$1))
                      `#'define `def_'VAR_NAME
                      BIT_STRUC_NAME VAR_NAME = {'
                      `makezeros(ZERO_FIELDS)'
                      `(ULONG_PTR)-1 };'
                      `define(`PAD_VAR_NAME', cat(cat(BIT_STRUC_NAME,`p'),$1))'
                      `ULONG64 PAD_VAR_NAME = 0x8000000000000000UI64;'
                      `define(`ZERO_FIELDS',incr(ZERO_FIELDS))'
                      `define(`FIELD_NAME', $1)'
                      `define(`FIELD_ASMNAME', $2)'
                      `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `dec_'VAR_NAME
                               `#de'fine `dec_'VAR_NAME
                               { SEF_BITFLD | SEF_TYPE cma (ULONG_PTR)&VAR_NAME cma "FIELD_ASMNAME" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                      )

define(`genBitAlias', `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `deca_'VAR_NAME
                               `#de'fine `deca_'VAR_NAME
                               { SEF_BITALIAS | SEF_TYPE cma 0 cma "$1" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                    )

//
// DUMP_BITFIELDS dumps the array initializers accumulated by BITFIELD_STRUCS,
// after replacing each 'cma' with an actual comma.
//

define(`DUMP_BITFIELDS',`define(`cma',`,') BITFIELD_STRUCS')

#endif  // SKIP_M4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\faultrep.h ===
/******************************************************************************

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:
    faultrep.h

Abstract:
    header for fault reporting for unhandled exceptions

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#ifndef FAULTREP_H
#define FAULTREP_H

#include "errorrep.h"

///////////////////////////////////////////////////////////////////////////////
// structs

typedef enum tagEFaultRepOptions
{
    froNoDebugWait = (DWORD)-1,
    froNoDebug     = 0,
    froDebug       = 1,
} EFaultRepOptions;

typedef enum tagEDumpFlags
{
    dfFilterThread   = 0x1,
    dfFilterThreadEx = 0x2,
    dfCollectSig     = 0x4,
} EDumpFlags;

typedef struct tagSMDumpOptions
{
    DWORD       cbSMDO;
    ULONG       ulThread;
    ULONG       ulThreadEx;
    ULONG       ulMod;
    DWORD       dwThreadID;
    DWORD       dfOptions;
    UINT64      pvFaultAddr;
    WCHAR       wszAppFullPath[MAX_PATH];
    WCHAR       wszApp[MAX_PATH];
    WORD        rgAppVer[4];
    WCHAR       wszMod[MAX_PATH];
    WCHAR       wszModFullPath[MAX_PATH];
    WORD        rgModVer[4];
    UINT64      pvOffset;
    UINT64      pEP;
    BOOL        fEPClient;
    BOOL        fIncludeHeap;  // Include heap in minidump
} SMDumpOptions;

typedef struct tagSFaultRepManifest
{
    DWORD       pidReqProcess;
    BOOL        fIs64bit;
    DWORD       thidFault;
    UINT64      pvFaultAddr;
    LPWSTR      wszExe;
    UINT64      pEP;
} SFaultRepManifest;

typedef enum tagEEventType
{
    eetKernelFault = 0,
    eetShutdown,
    eetUseEventInfo,
} EEventType;

typedef struct tagSEventInfoW
{
    DWORD   cbSEI;
    LPWSTR  wszEventName;
    LPWSTR  wszErrMsg;
    LPWSTR  wszHdr;
    LPWSTR  wszTitle;
    LPWSTR  wszStage1;
    LPWSTR  wszStage2;
    LPWSTR  wszFileList;
    LPWSTR  wszEventSrc;
    LPWSTR  wszCorpPath;
    LPWSTR  wszPlea;
    LPWSTR  wszSendBtn;
    LPWSTR  wszNoSendBtn;
    BOOL    fUseLitePlea;
    BOOL    fUseIEForURLs;
    BOOL    fNoBucketLogs;
    BOOL    fNoDefCabLimit;
} SEventInfoW;

///////////////////////////////////////////////////////////////////////////////
// function prototypes

EFaultRepRetVal APIENTRY ReportFaultDWM(SFaultRepManifest *pfrm,
                                        LPCWSTR wszDir, HANDLE hToken,
                                        LPVOID pvEnv, PROCESS_INFORMATION *ppi,
                                        LPWSTR wszDumpFile);
EFaultRepRetVal APIENTRY ReportFaultToQueue(SFaultRepManifest *pfrm);
EFaultRepRetVal APIENTRY ReportFaultFromQueue(LPWSTR wszDump, BYTE *pbData,
                                              DWORD cbData);

EFaultRepRetVal APIENTRY ReportKernelFaultA(LPCSTR szDump);
EFaultRepRetVal APIENTRY ReportKernelFaultW(LPCWSTR wszDump);
EFaultRepRetVal APIENTRY ReportKernelFaultDWW(LPCWSTR wszDump);

EFaultRepRetVal APIENTRY ReportEREvent(EEventType eet, LPCWSTR wszDump,
                                        SEventInfoW *pei);
EFaultRepRetVal APIENTRY ReportEREventDW(EEventType eet, LPCWSTR wszDump,
                                          SEventInfoW *pei);

EFaultRepRetVal APIENTRY ReportHang(DWORD dwpid, DWORD dwtid, BOOL f64bit,
                                     HANDLE hNotify);

BOOL APIENTRY CreateMinidumpA(DWORD dwpid, LPCSTR szDump, SMDumpOptions *psmdo);
BOOL APIENTRY CreateMinidumpW(DWORD dwpid, LPCWSTR wszDump, SMDumpOptions *psmdo);


///////////////////////////////////////////////////////////////////////////////
// function pointer typedefs

typedef EFaultRepRetVal (APIENTRY *pfn_REPORTFAULTDWM)(SFaultRepManifest *,
                                                       LPCWSTR, HANDLE, LPVOID,
                                                       PROCESS_INFORMATION *,
                                                       LPWSTR);
typedef EFaultRepRetVal (APIENTRY *pfn_REPORTFAULTTOQ)(SFaultRepManifest *);
typedef EFaultRepRetVal (APIENTRY *pfn_REPORTFAULTFROMQ)(LPWSTR, BYTE *, DWORD);

typedef EFaultRepRetVal (APIENTRY *pfn_REPORTKERNELFAULTA)(LPCSTR);
typedef EFaultRepRetVal (APIENTRY *pfn_REPORTKERNELFAULTW)(LPCWSTR);
typedef EFaultRepRetVal (APIENTRY *pfn_REPORTKERNELFAULTDWW)(LPCWSTR);

typedef EFaultRepRetVal (APIENTRY *pfn_REPORTEREVENT)(EEventType, LPCWSTR, SEventInfoW *);
typedef EFaultRepRetVal (APIENTRY *pfn_REPORTEREVENTDW)(EEventType, LPCWSTR, SEventInfoW *);


typedef EFaultRepRetVal (APIENTRY *pfn_REPORTHANG)(DWORD, DWORD, BOOL, HANDLE);

typedef BOOL (APIENTRY *pfn_CREATEMINIDUMPA)(DWORD, LPCSTR, SMDumpOptions *);
typedef BOOL (APIENTRY *pfn_CREATEMINIDUMPW)(DWORD, LPCWSTR, SMDumpOptions *);


///////////////////////////////////////////////////////////////////////////////
// UNICODE stuff

#ifdef UNICODE

#define ReportKernelFault ReportKernelFaultW
#define CreateMinidump CreateMinidumpW
#define pfn_REPORTKERNELFAULT pfn_REPORTKERNELFAULTW
#define pfn_CREATEMINIDUMP pfn_CREATEMINIDUMPW

#else // not UNICODE

#define ReportKernelFault ReportKernelFaultA
#define CreateMinidump CreateMinidumpA
#define pfn_REPORTKERNELFAULT pfn_REPORTKERNELFAULTA
#define pfn_CREATEMINIDUMP pfn_CREATEMINIDUMPA

#endif // UNICODE

#endif // FAULTREP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\halpaxp64.h ===
#include "kxalpha.h"

//
// Wait Reason and Wait Type Enumerated Type Values
//

#define WrExecutive 0x0

//
// Bug Check Code Definitions
//

#define APC_INDEX_MISMATCH 0x1
#define ATTEMPTED_SWITCH_FROM_DPC 0xb8
#define DATA_BUS_ERROR 0x2e
#define DATA_COHERENCY_EXCEPTION 0x55
#define HAL1_INITIALIZATION_FAILED 0x61
#define INSTRUCTION_BUS_ERROR 0x2f
#define INSTRUCTION_COHERENCY_EXCEPTION 0x56
#define INTERRUPT_EXCEPTION_NOT_HANDLED 0x3d
#define INTERRUPT_UNWIND_ATTEMPTED 0x3c
#define INVALID_AFFINITY_SET 0x3
#define INVALID_DATA_ACCESS_TRAP 0x4
#define IRQL_GT_ZERO_AT_SYSTEM_SERVICE 0x4a
#define IRQL_NOT_LESS_OR_EQUAL 0xa
#define KMODE_EXCEPTION_NOT_HANDLED 0x1e
#define NMI_HARDWARE_FAILURE 0x80
#define NO_USER_MODE_CONTEXT 0xe
#define PAGE_FAULT_WITH_INTERRUPTS_OFF 0x49
#define PANIC_STACK_SWITCH 0x2b
#define SPIN_LOCK_INIT_FAILURE 0x81
#define SYSTEM_EXIT_OWNED_MUTEX 0x39
#define SYSTEM_SERVICE_EXCEPTION 0x3b
#define SYSTEM_UNWIND_PREVIOUS_USER 0x3a
#define TRAP_CAUSE_UNKNOWN 0x12
#define UNEXPECTED_KERNEL_MODE_TRAP 0x7f

//
// Breakpoint type definitions
//

#define DBG_STATUS_CONTROL_C 0x1

//
// Exception Record Offset, Flag, and Enumerated Type Definitions
//

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_UNWINDING 0x2
#define EXCEPTION_EXIT_UNWIND 0x4
#define EXCEPTION_STACK_INVALID 0x8
#define EXCEPTION_NESTED_CALL 0x10
#define EXCEPTION_TARGET_UNWIND 0x20
#define EXCEPTION_COLLIDED_UNWIND 0x40
#define EXCEPTION_UNWIND 0x66
#define EXCEPTION_EXECUTE_HANDLER 0x1
#define EXCEPTION_CONTINUE_SEARCH 0x0
#define EXCEPTION_CONTINUE_EXECUTION 0xffffffff

#define ExceptionContinueExecution 0x0
#define ExceptionContinueSearch 0x1
#define ExceptionNestedException 0x2
#define ExceptionCollidedUnwind 0x3

#define ErExceptionCode 0x0
#define ErExceptionFlags 0x4
#define ErExceptionRecord 0x8
#define ErExceptionAddress 0x10
#define ErNumberParameters 0x18
#define ErExceptionInformation 0x20
#define ExceptionRecordLength 0xa0

//
// Fast Mutex Structure Offset Definitions
//

#define FmCount 0x0
#define FmOwner 0x8
#define FmContention 0x10
#define FmEvent 0x18
#define FmOldIrql 0x30

//
// Interrupt Priority Request Level Definitions
//

#define APC_LEVEL 0x1
#define DISPATCH_LEVEL 0x2
#define IPI_LEVEL 0x6
#define POWER_LEVEL 0x7
#define PROFILE_LEVEL 0x3
#define HIGH_LEVEL 0x7
#define SYNCH_LEVEL 0x5

//
// Large Integer Structure Offset Definitions
//

#define LiLowPart 0x0
#define LiHighPart 0x4

//
// List Entry Structure Offset Definitions
//

#define LsFlink 0x0
#define LsBlink 0x8

//
// String Structure Offset Definitions
//

#define StrLength 0x0
#define StrMaximumLength 0x2
#define StrBuffer 0x8

//
// Time Structure Offset Definitions
//

#define TmLowTime 0x0
#define TmHighTime 0x4

//
// DPC object Structure Offset Definitions
//

#define DpType 0x0
#define DpNumber 0x2
#define DpImportance 0x3
#define DpDpcListEntry 0x8
#define DpDeferredRoutine 0x18
#define DpDeferredContext 0x20
#define DpSystemArgument1 0x28
#define DpSystemArgument2 0x30
#define DpLock 0x38
#define DpcObjectLength 0x40

//
// Interrupt Object Structure Offset Definitions
//

#define InLevelSensitive 0x0
#define InLatched 0x1

#define InType 0x0
#define InSize 0x2
#define InInterruptListEntry 0x8
#define InServiceRoutine 0x18
#define InServiceContext 0x20
#define InSpinLock 0x28
#define InTickCount 0x30
#define InActualLock 0x38
#define InDispatchAddress 0x40
#define InVector 0x48
#define InIrql 0x4c
#define InSynchronizeIrql 0x4d
#define InFloatingSave 0x4e
#define InConnected 0x4f
#define InNumber 0x50
#define InMode 0x54
#define InShareVector 0x51
#define InDispatchCount 0x5c
#define InDispatchCode 0x60
#define InServiceCount 0x58
#define InterruptObjectLength 0x70

//
// Processor Control Registers Structure Offset Definitions
//

#define PCR_MINOR_VERSION 0x1
#define PCR_MAJOR_VERSION 0x1
#define PcMinorVersion 0x0
#define PcMajorVersion 0x4
#define PcPalBaseAddress 0x8
#define PcPalMajorVersion 0x10
#define PcPalMinorVersion 0x14
#define PcPalSequenceVersion 0x18
#define PcPalMajorSpecification 0x1c
#define PcPalMinorSpecification 0x20
#define PcFirmwareRestartAddress 0x28
#define PcRestartBlock 0x30
#define PcPalReserved 0x38
#define PcPalAlignmentFixupCount 0xc30
#define PcPanicStack 0xc38
#define PcProcessorType 0xc40
#define PcProcessorRevision 0xc44
#define PcPhysicalAddressBits 0xc48
#define PcMaximumAddressSpaceNumber 0xc4c
#define PcPageSize 0xc50
#define PcFirstLevelDcacheSize 0xc54
#define PcFirstLevelDcacheFillSize 0xc58
#define PcFirstLevelIcacheSize 0xc5c
#define PcFirstLevelIcacheFillSize 0xc60
#define PcFirmwareRevisionId 0xc64
#define PcSystemType 0xc68
#define PcSystemVariant 0xc70
#define PcSystemRevision 0xc74
#define PcSystemSerialNumber 0xc78
#define PcCycleClockPeriod 0xc88
#define PcSecondLevelCacheSize 0xc8c
#define PcSecondLevelCacheFillSize 0xc90
#define PcThirdLevelCacheSize 0xc94
#define PcThirdLevelCacheFillSize 0xc98
#define PcFourthLevelCacheSize 0xc9c
#define PcFourthLevelCacheFillSize 0xca0
#define PcPrcb 0xca8
#define PcNumber 0xcb0
#define PcSetMember 0xcb4
#define PcHalReserved 0xcb8
#define PcIrqlTable 0xeb8
#define PcIrqlMask 0xed8
#define PcInterruptRoutine 0x10e8
#define PcReservedVectors 0x18e8
#define PcMachineCheckError 0x18f8
#define PcDpcStack 0x1900
#define PcNotMember 0x18ec
#define PcCurrentPid 0x190c
#define PcSystemServiceDispatchStart 0x1918
#define PcSystemServiceDispatchEnd 0x1920
#define PcIdleThread 0x1928
#define ProcessorControlRegisterLength 0x1930
#define SharedUserData 0xffffffffff000000
#define UsTickCountLow 0x0
#define UsTickCountMultiplier 0x4
#define UsInterruptTime 0x8
#define UsSystemTime 0x14

//
// Processor Block Structure Offset Definitions
//

#define PRCB_MINOR_VERSION 0x1
#define PRCB_MAJOR_VERSION 0x2
#define PbMinorVersion 0x0
#define PbMajorVersion 0x2
#define PbCurrentThread 0x8
#define PbNextThread 0x10
#define PbIdleThread 0x18
#define PbNumber 0x20
#define PbBuildType 0x22
#define PbSetMember 0x24
#define PbRestartBlock 0x28
#define PbPowerState 0x8b0
#define ProcessorBlockLength 0x940

//
// Processor Power State Offset Definitions
//

#define PpIdleFunction 0x0

//
// Context Frame Offset and Flag Definitions
//

#define CONTEXT_FULL 0x20007
#define CONTEXT_CONTROL 0x20001
#define CONTEXT_FLOATING_POINT 0x20002
#define CONTEXT_INTEGER 0x20004

#define CxFltF0 0x0
#define CxFltF1 0x8
#define CxFltF2 0x10
#define CxFltF3 0x18
#define CxFltF4 0x20
#define CxFltF5 0x28
#define CxFltF6 0x30
#define CxFltF7 0x38
#define CxFltF8 0x40
#define CxFltF9 0x48
#define CxFltF10 0x50
#define CxFltF11 0x58
#define CxFltF12 0x60
#define CxFltF13 0x68
#define CxFltF14 0x70
#define CxFltF15 0x78
#define CxFltF16 0x80
#define CxFltF17 0x88
#define CxFltF18 0x90
#define CxFltF19 0x98
#define CxFltF20 0xa0
#define CxFltF21 0xa8
#define CxFltF22 0xb0
#define CxFltF23 0xb8
#define CxFltF24 0xc0
#define CxFltF25 0xc8
#define CxFltF26 0xd0
#define CxFltF27 0xd8
#define CxFltF28 0xe0
#define CxFltF29 0xe8
#define CxFltF30 0xf0
#define CxFltF31 0xf8
#define CxIntV0 0x100
#define CxIntT0 0x108
#define CxIntT1 0x110
#define CxIntT2 0x118
#define CxIntT3 0x120
#define CxIntT4 0x128
#define CxIntT5 0x130
#define CxIntT6 0x138
#define CxIntT7 0x140
#define CxIntS0 0x148
#define CxIntS1 0x150
#define CxIntS2 0x158
#define CxIntS3 0x160
#define CxIntS4 0x168
#define CxIntS5 0x170
#define CxIntFp 0x178
#define CxIntA0 0x180
#define CxIntA1 0x188
#define CxIntA2 0x190
#define CxIntA3 0x198
#define CxIntA4 0x1a0
#define CxIntA5 0x1a8
#define CxIntT8 0x1b0
#define CxIntT9 0x1b8
#define CxIntT10 0x1c0
#define CxIntT11 0x1c8
#define CxIntRa 0x1d0
#define CxIntT12 0x1d8
#define CxIntAt 0x1e0
#define CxIntGp 0x1e8
#define CxIntSp 0x1f0
#define CxIntZero 0x1f8
#define CxFpcr 0x200
#define CxSoftFpcr 0x208
#define CxFir 0x210
#define CxPsr 0x218
#define CxContextFlags 0x21c
#define ContextFrameLength 0x230

//
// Exception Frame Offset Definitions and Length
//

#define ExFltF2 0x8
#define ExFltF3 0x10
#define ExFltF4 0x18
#define ExFltF5 0x20
#define ExFltF6 0x28
#define ExFltF7 0x30
#define ExFltF8 0x38
#define ExFltF9 0x40
#define ExIntS0 0x48
#define ExIntS1 0x50
#define ExIntS2 0x58
#define ExIntS3 0x60
#define ExIntS4 0x68
#define ExIntS5 0x70
#define ExIntFp 0x78
#define ExPsr 0x88
#define ExSwapReturn 0x80
#define ExIntRa 0x0
#define ExceptionFrameLength 0xa0

//
// Jump Offset Definitions and Length
//

#define JbFp 0x0
#define JbPc 0x8
#define JbSeb 0x10
#define JbType 0x18
#define JbFltF2 0x20
#define JbFltF3 0x28
#define JbFltF4 0x30
#define JbFltF5 0x38
#define JbFltF6 0x40
#define JbFltF7 0x48
#define JbFltF8 0x50
#define JbFltF9 0x58
#define JbIntS0 0x60
#define JbIntS1 0x68
#define JbIntS2 0x70
#define JbIntS3 0x78
#define JbIntS4 0x80
#define JbIntS5 0x88
#define JbIntS6 0x90
#define JbIntSp 0x98
#define JbFir 0xa0

//
// Trap Frame Offset Definitions and Length
//

#define TrFltF0 0x178
#define TrFltF1 0x188
#define TrFltF10 0x190
#define TrFltF11 0x198
#define TrFltF12 0x1a0
#define TrFltF13 0x1a8
#define TrFltF14 0x1b0
#define TrFltF15 0x1b8
#define TrFltF16 0x1c0
#define TrFltF17 0x1c8
#define TrFltF18 0x1d0
#define TrFltF19 0x1d8
#define TrFltF20 0x1e0
#define TrFltF21 0x1e8
#define TrFltF22 0x1f0
#define TrFltF23 0x1f8
#define TrFltF24 0x200
#define TrFltF25 0x208
#define TrFltF26 0x210
#define TrFltF27 0x218
#define TrFltF28 0x220
#define TrFltF29 0x228
#define TrFltF30 0x230
#define TrIntV0 0xf0
#define TrIntT0 0xf8
#define TrIntT1 0x100
#define TrIntT2 0x108
#define TrIntT3 0x110
#define TrIntT4 0x118
#define TrIntT5 0x120
#define TrIntT6 0x128
#define TrIntT7 0x130
#define TrIntFp 0x18
#define TrIntA0 0x20
#define TrIntA1 0x28
#define TrIntA2 0x30
#define TrIntA3 0x38
#define TrIntA4 0x168
#define TrIntA5 0x170
#define TrIntT8 0x138
#define TrIntT9 0x140
#define TrIntT10 0x148
#define TrIntT11 0x150
#define TrIntT12 0x158
#define TrIntAt 0x160
#define TrIntGp 0x48
#define TrIntSp 0x0
#define TrFpcr 0x180
#define TrPsr 0x10
#define TrFir 0x8
#define TrExceptionRecord 0x50
#define TrOldIrql 0x238
#define TrPreviousMode 0x23c
#define TrIntRa 0x40
#define TrTrapFrame 0x240
#define TrapFrameLength 0x260

//
// Loader Parameter Block Offset Definitions
//

#define LpbLoadOrderListHead 0x0
#define LpbMemoryDescriptorListHead 0x10
#define LpbKernelStack 0x30
#define LpbPrcb 0x38
#define LpbProcess 0x40
#define LpbThread 0x48
#define LpbRegistryLength 0x50
#define LpbRegistryBase 0x58
#define LpbDpcStack 0xb8
#define LpbFirstLevelDcacheSize 0xc0
#define LpbFirstLevelDcacheFillSize 0xc4
#define LpbFirstLevelIcacheSize 0xc8
#define LpbFirstLevelIcacheFillSize 0xcc
#define LpbGpBase 0xd0
#define LpbPanicStack 0xd8
#define LpbPcrPage 0xe0
#define LpbPdrPage 0xe4
#define LpbSecondLevelDcacheSize 0xe8
#define LpbSecondLevelDcacheFillSize 0xec
#define LpbSecondLevelIcacheSize 0xf0
#define LpbSecondLevelIcacheFillSize 0xf4
#define LpbPhysicalAddressBits 0xf8
#define LpbMaximumAddressSpaceNumber 0xfc
#define LpbSystemSerialNumber 0x100
#define LpbSystemType 0x110
#define LpbSystemVariant 0x118
#define LpbSystemRevision 0x11c
#define LpbProcessorType 0x120
#define LpbProcessorRevision 0x124
#define LpbCycleClockPeriod 0x128
#define LpbPageSize 0x12c
#define LpbRestartBlock 0x130
#define LpbFirmwareRestartAddress 0x138
#define LpbFirmwareRevisionId 0x140
#define LpbPalBaseAddress 0x148

//
// Restart Block Structure Definitions
//

#define RbSignature 0x0
#define RbLength 0x4
#define RbVersion 0x8
#define RbRevision 0xa
#define RbNextRestartBlock 0xc
#define RbRestartAddress 0x10
#define RbBootMasterId 0x14
#define RbProcessorId 0x18
#define RbBootStatus 0x1c
#define RbCheckSum 0x20
#define RbSaveAreaLength 0x24
#define RbSaveArea 0x28
#define RbHaltReason 0x28
#define RbLogoutFrame 0x2c
#define RbPalBase 0x30
#define RbIntV0 0x38
#define RbIntT0 0x40
#define RbIntT1 0x48
#define RbIntT2 0x50
#define RbIntT3 0x58
#define RbIntT4 0x60
#define RbIntT5 0x68
#define RbIntT6 0x70
#define RbIntT7 0x78
#define RbIntS0 0x80
#define RbIntS1 0x88
#define RbIntS2 0x90
#define RbIntS3 0x98
#define RbIntS4 0xa0
#define RbIntS5 0xa8
#define RbIntFp 0xb0
#define RbIntA0 0xb8
#define RbIntA1 0xc0
#define RbIntA2 0xc8
#define RbIntA3 0xd0
#define RbIntA4 0xd8
#define RbIntA5 0xe0
#define RbIntT8 0xe8
#define RbIntT9 0xf0
#define RbIntT10 0xf8
#define RbIntT11 0x100
#define RbIntRa 0x108
#define RbIntT12 0x110
#define RbIntAT 0x118
#define RbIntGp 0x120
#define RbIntSp 0x128
#define RbIntZero 0x130
#define RbFpcr 0x138
#define RbFltF0 0x140
#define RbFltF1 0x148
#define RbFltF2 0x150
#define RbFltF3 0x158
#define RbFltF4 0x160
#define RbFltF5 0x168
#define RbFltF6 0x170
#define RbFltF7 0x178
#define RbFltF8 0x180
#define RbFltF9 0x188
#define RbFltF10 0x190
#define RbFltF11 0x198
#define RbFltF12 0x1a0
#define RbFltF13 0x1a8
#define RbFltF14 0x1b0
#define RbFltF15 0x1b8
#define RbFltF16 0x1c0
#define RbFltF17 0x1c8
#define RbFltF18 0x1d0
#define RbFltF19 0x1d8
#define RbFltF20 0x1e0
#define RbFltF21 0x1e8
#define RbFltF22 0x1f0
#define RbFltF23 0x1f8
#define RbFltF24 0x200
#define RbFltF25 0x208
#define RbFltF26 0x210
#define RbFltF27 0x218
#define RbFltF28 0x220
#define RbFltF29 0x228
#define RbFltF30 0x230
#define RbFltF31 0x238
#define RbAsn 0x240
#define RbGeneralEntry 0x244
#define RbIksp 0x248
#define RbInterruptEntry 0x24c
#define RbKgp 0x250
#define RbMces 0x254
#define RbMemMgmtEntry 0x258
#define RbPanicEntry 0x25c
#define RbPcr 0x260
#define RbPdr 0x264
#define RbPsr 0x268
#define RbReiRestartAddress 0x26c
#define RbSirr 0x270
#define RbSyscallEntry 0x274
#define RbTeb 0x278
#define RbThread 0x27c
#define RbPerProcessorState 0x280

//
// Address Space Layout Definitions
//

#define KSEG0_BASE 0xffffffff80000000
#define KSEG2_BASE 0xffffffffc0000000

//
// Page Table and Directory Entry Definitions
//

#define PAGE_SIZE 0x2000
#define PAGE_SHIFT 0xd
#define PDI_SHIFT 0x17
#define PTI_SHIFT 0xd

//
// Breakpoint Definitions
//

#define USER_BREAKPOINT 0x0
#define KERNEL_BREAKPOINT 0x1
#define BREAKIN_BREAKPOINT 0x19
#define DEBUG_PRINT_BREAKPOINT 0x14
#define DEBUG_PROMPT_BREAKPOINT 0x15
#define DEBUG_STOP_BREAKPOINT 0x16
#define DEBUG_LOAD_SYMBOLS_BREAKPOINT 0x17
#define DEBUG_UNLOAD_SYMBOLS_BREAKPOINT 0x18

//
// Miscellaneous Definitions
//

#define Executive 0x0
#define KernelMode 0x0
#define FALSE 0x0
#define TRUE 0x1
#define PROCESSOR_ALPHA_21064 0x5248
#define PROCESSOR_ALPHA_21164 0x52ac
#define PROCESSOR_ALPHA_21066 0x524a
#define PROCESSOR_ALPHA_21068 0x524c
#define PROCESSOR_ALPHA_21164PC 0x52ad
#define PROCESSOR_ALPHA_21264 0x5310
#define MCHK_CORRECTABLE_MASK 0x1
#define MCHK_CORRECTABLE 0x0
#define MCHK_RETRYABLE_MASK 0x2
#define MCHK_RETRYABLE 0x1
#define MCES_MCK_MASK 0x1
#define MCES_MCK 0x0
#define MCES_SCE_MASK 0x2
#define MCES_SCE 0x1
#define MCES_PCE_MASK 0x4
#define MCES_PCE 0x2
#define MCES_DPC_MASK 0x8
#define MCES_DPC 0x3
#define MCES_DSC_MASK 0x10
#define MCES_DSC 0x4
#define MCES_DMCK_MASK 0x20
#define MCES_DMCK 0x5

//
// Call PAL Mnemonics
//

// begin callpal

#define bpt 0x80
#define callsys 0x83
#define imb 0x86
#define gentrap 0xaa
#define rdteb 0xab
#define kbpt 0xac
#define callkd 0xad
#define rdteb64 0xae
#define halt 0x0
#define restart 0x1
#define draina 0x2
#define reboot 0x3
#define initpal 0x4
#define wrentry 0x5
#define swpirql 0x6
#define rdirql 0x7
#define di 0x8
#define ei 0x9
#define swppal 0xa
#define ssir 0xc
#define csir 0xd
#define rfe 0xe
#define retsys 0xf
#define swpctx 0x10
#define swpprocess 0x11
#define rdmces 0x12
#define wrmces 0x13
#define tbia 0x14
#define tbis 0x15
#define tbisasn 0x17
#define dtbis 0x16
#define rdksp 0x18
#define swpksp 0x19
#define rdpsr 0x1a
#define rdpcr 0x1c
#define rdthread 0x1e
#define tbim 0x20
#define tbimasn 0x21
#define tbim64 0x22
#define tbis64 0x23
#define ealnfix 0x24
#define dalnfix 0x25
#define rdcounters 0x30
#define rdstate 0x31
#define wrperfmon 0x32
#define cp_sleep 0x39
#define initpcr 0x38

// end callpal


//
// Bios Argument Structure Definitions
//

#define BaEax 0x0
#define BaEbx 0x4
#define BaEcx 0x8
#define BaEdx 0xc
#define BaEsi 0x10
#define BaEdi 0x14
#define BaEbp 0x18
#define BiosArgumentLength 0x1c

//
// Define Vendor Callback Read/Write Error Frame Operation Types
//

#define ReadFrame 0x1
#define WriteFrame 0x2

//
// Define Vendor Callback Vector Base Address
//

#define SYSTEM_VECTOR_BASE 0xffffffff806fe028

//
// Define Vendor Callback Offsets
//

#define VnCallBiosRoutine 0x38
#define VnReadWriteErrorFrameRoutine 0x98
#define VnVideoDisplayInitializeRoutine 0x10

//
// Define Firmware Callback Vector Base Address
//

#define FIRMWARE_VECTOR_BASE 0xffffffff806fe020

//
// Define Firmware Callback Offsets
//

#define FwGetEnvironmentRoutine 0x78
#define FwSetEnvironmentRoutine 0x7c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\hdlsterm.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    hdlsterm.h

Abstract:

    This module contains the public header information (function prototypes,
    data and type declarations) for the Headless Terminal effort.

Author:

    Sean Selitrennikoff (v-seans) Oct, 1999

Revision History:

--*/

#ifndef _HDLSTERM_
#define _HDLSTERM_

//
// Defines for string codes that can be passed to HeadlessAddLogEntry()
//
#define HEADLESS_LOG_LOADING_FILENAME                0x01 // expects parameter.
#define HEADLESS_LOG_LOAD_SUCCESSFUL                 0x02
#define HEADLESS_LOG_LOAD_FAILED                     0x03
#define HEADLESS_LOG_EVENT_CREATE_FAILED             0x04
#define HEADLESS_LOG_OBJECT_TYPE_CREATE_FAILED       0x05
#define HEADLESS_LOG_ROOT_DIR_CREATE_FAILED          0x06
#define HEADLESS_LOG_PNP_PHASE0_INIT_FAILED          0x07
#define HEADLESS_LOG_PNP_PHASE1_INIT_FAILED          0x08
#define HEADLESS_LOG_BOOT_DRIVERS_INIT_FAILED        0x09
#define HEADLESS_LOG_LOCATE_SYSTEM_DLL_FAILED        0x0A
#define HEADLESS_LOG_SYSTEM_DRIVERS_INIT_FAILED      0x0B
#define HEADLESS_LOG_ASSIGN_SYSTEM_ROOT_FAILED       0x0C
#define HEADLESS_LOG_PROTECT_SYSTEM_ROOT_FAILED      0x0D
#define HEADLESS_LOG_UNICODE_TO_ANSI_FAILED          0x0E
#define HEADLESS_LOG_ANSI_TO_UNICODE_FAILED          0x0F
#define HEADLESS_LOG_FIND_GROUPS_FAILED              0x10
#define HEADLESS_LOG_OUT_OF_MEMORY                   0x11
#define HEADLESS_LOG_WAIT_BOOT_DEVICES_DELETE_FAILED 0x12
#define HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED  0x13
#define HEADLESS_LOG_WAIT_BOOT_DEVICES_REINIT_FAILED 0x14
#define HEADLESS_LOG_MARK_BOOT_PARTITION_FAILED      0x15

//
// Global defines for a default vt100 terminal.  May be used by clients to size the 
// local monitor to match the headless monitor.
//
#define HEADLESS_TERM_DEFAULT_BKGD_COLOR 40
#define HEADLESS_TERM_DEFAULT_TEXT_COLOR 37
#define HEADLESS_SCREEN_HEIGHT 24

//
// Commands that can be submitted to HeadlessDispatch.
// 
typedef enum _HEADLESS_CMD {
    HeadlessCmdEnableTerminal = 1,
    HeadlessCmdCheckForReboot,
    HeadlessCmdPutString,
    HeadlessCmdClearDisplay,
    HeadlessCmdClearToEndOfDisplay,
    HeadlessCmdClearToEndOfLine,
    HeadlessCmdDisplayAttributesOff,
    HeadlessCmdDisplayInverseVideo,
    HeadlessCmdSetColor,
    HeadlessCmdPositionCursor,
    HeadlessCmdTerminalPoll,
    HeadlessCmdGetByte,
    HeadlessCmdGetLine,
    HeadlessCmdStartBugCheck,
    HeadlessCmdDoBugCheckProcessing,
    HeadlessCmdQueryInformation,
    HeadlessCmdAddLogEntry,
    HeadlessCmdDisplayLog,
    HeadlessCmdSetBlueScreenData,
    HeadlessCmdSendBlueScreenData,
    HeadlessCmdQueryGUID,
    HeadlessCmdPutData
} HEADLESS_CMD, *PHEADLESS_CMD;




//
//
// Structure definitions for the input buffer for each command type.
//
//


//
// HeadlessCmdEnableTerminal:
//   Input structure: Enable, TRUE if to attempt to enable, FALSE if attempt to disable.
//
typedef struct _HEADLESS_CMD_ENABLE_TERMINAL {
    BOOLEAN Enable;
} HEADLESS_CMD_ENABLE_TERMINAL, *PHEADLESS_CMD_ENABLE_TERMINAL;


//
// HeadlessCmdCheckForReboot:
//    Response structure: Reboot, TRUE if user typed reboot command on the terminal.
//
typedef struct _HEADLESS_RSP_REBOOT {
    BOOLEAN Reboot;
} HEADLESS_RSP_REBOOT, *PHEADLESS_RSP_REBOOT;


//
// HeadlessCmdPutString:
//   Input structure: String, A NULL-terminated string.
//
typedef struct _HEADLESS_CMD_PUT_STRING {
    UCHAR String[1];
} HEADLESS_CMD_PUT_STRING, *PHEADLESS_CMD_PUT_STRING;


//
// HeadlessCmdClearDisplay:
// HeadlessCmdClearToEndOfDisplay:
// HeadlessCmdClearToEndOfLine:
// HeadlessCmdDisplayAttributesOff:
// HeadlessCmdDisplayInverseVideo:
// HeadlessCmdStartBugCheck:
// HeadlessCmdDoBugCheckProcessing:
//     No Input nor Output parameters expected.
//


//
// HeadlessCmdSetColor:
//   Input structure: FgColor, BkgColor: Both colors set according to ANSI terminal 
//                       definitons. 
//
typedef struct _HEADLESS_CMD_SET_COLOR {
    ULONG FgColor;
    ULONG BkgColor;
} HEADLESS_CMD_SET_COLOR, *PHEADLESS_CMD_SET_COLOR;

//
// HeadlessCmdPositionCursor:
//   Input structure: X, Y: Both values are zero base, with upper left being (0, 0).
//
typedef struct _HEADLESS_CMD_POSITION_CURSOR {
    ULONG X;
    ULONG Y;
} HEADLESS_CMD_POSITION_CURSOR, *PHEADLESS_CMD_POSITION_CURSOR;

//
// HeadlessCmdTerminalPoll:
//    Response structure: QueuedInput, TRUE if input is available, else FALSE.
//
typedef struct _HEADLESS_RSP_POLL {
    BOOLEAN QueuedInput;
} HEADLESS_RSP_POLL, *PHEADLESS_RSP_POLL;

//
// HeadlessCmdGetByte:
//    Response structure: Value, 0 if no input is available, else a single byte of input.
//
typedef struct _HEADLESS_RSP_GET_BYTE {
    UCHAR Value;
} HEADLESS_RSP_GET_BYTE, *PHEADLESS_RSP_GET_BYTE;

//
// HeadlessCmdGetLine:
//    Response structure: LineComplete, TRUE if the string is filled in, else FALSE becuase
//                           the user has not yet pressed enter.
//                     String, the string entered by the user, NULL terminated, with
//                           leading and trailing whitespace removed.
//
typedef struct _HEADLESS_RSP_GET_LINE {
    BOOLEAN LineComplete;
    UCHAR Buffer[1];
} HEADLESS_RSP_GET_LINE, *PHEADLESS_RSP_GET_LINE;

//
// HeadlessCmdQueryInformation:
//    Response structure: 
//
//    PortType - Determines what kind of connection is being used to connect the
//              headless terminal to the machine.
//
//         If SerialPort, then
//                    TerminalAttached, TRUE if there is a terminal connected.
//                    TerminalPort, the port settings used by headless.
//
typedef enum _HEADLESS_TERM_PORT_TYPE {
    HeadlessUndefinedPortType = 0,
    HeadlessSerialPort
} HEADLESS_TERM_PORT_TYPE, *PHEADLESS_TERM_PORT_TYPE;

typedef enum _HEADLESS_TERM_SERIAL_PORT {
    SerialPortUndefined = 0,
    ComPort1,
    ComPort2,
    ComPort3,
    ComPort4
} HEADLESS_TERM_SERIAL_PORT, *PHEADLESS_TERM_SERIAL_PORT;

typedef struct _HEADLESS_RSP_QUERY_INFO {
    
    HEADLESS_TERM_PORT_TYPE PortType;

    //
    // All the possible parameters for each connection type.
    //
    union {
    
        struct {
            BOOLEAN TerminalAttached;
            BOOLEAN UsedBiosSettings;
            HEADLESS_TERM_SERIAL_PORT TerminalPort;
            PUCHAR TerminalPortBaseAddress;
            ULONG TerminalBaudRate;
            UCHAR TerminalType;
        } Serial;

    };

} HEADLESS_RSP_QUERY_INFO, *PHEADLESS_RSP_QUERY_INFO;


//
// HeadlessCmdAddLogEntry:
//   Input structure: String, A NULL-terminated string.
//
typedef struct _HEADLESS_CMD_ADD_LOG_ENTRY {
    WCHAR String[1];
} HEADLESS_CMD_ADD_LOG_ENTRY, *PHEADLESS_CMD_ADD_LOG_ENTRY;


//
// HeadlessCmdDisplayLog:
//    Response structure: Paging, TRUE if paging is to be applied, else FALSE.
//
typedef struct _HEADLESS_CMD_DISPLAY_LOG {
    BOOLEAN Paging;
} HEADLESS_CMD_DISPLAY_LOG, *PHEADLESS_CMD_DISPLAY_LOG;

//
// HeadlessCmdSetBlueScreenData 
//
// External structure from the API. 
//    ValueIndex is the index into the data where the XML Data is
//            located. Strings are null terminated. 
//
// For cross checking, the UCHAR in the Data array before the ValueIndex 
// must be a null character. Similarly the last character in the 
// entire data buffer passed in must be a null character. 
//

typedef struct _HEADLESS_CMD_SET_BLUE_SCREEN_DATA {
        ULONG ValueIndex;
        UCHAR Data[1];
} HEADLESS_CMD_SET_BLUE_SCREEN_DATA, *PHEADLESS_CMD_SET_BLUE_SCREEN_DATA;

//
// HeadlessCmdSendBlueScreenData
//    The only parameter is the bugcheck code
//
typedef struct _HEADLESS_CMD_SEND_BLUE_SCREEN_DATA {
        ULONG BugcheckCode;
} HEADLESS_CMD_SEND_BLUE_SCREEN_DATA, *PHEADLESS_CMD_SEND_BLUE_SCREEN_DATA;




//
// Headless routines
//
VOID
HeadlessInit(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HeadlessTerminalAddResources(
    PCM_RESOURCE_LIST Resources,
    ULONG ResourceListSize,
    BOOLEAN TranslatedList,
    PCM_RESOURCE_LIST *NewList,
    PULONG NewListSize
    );

VOID
HeadlessKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    );

NTSTATUS
HeadlessDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID InputBuffer OPTIONAL,
    IN  SIZE_T InputBufferSize OPTIONAL,
    OUT PVOID OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    );

#endif // _HDLSTERM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\mce.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    mce.h

Abstract:

    This header file defines the Machine Check Errors definitions.

Author:

    David N. Cutler (davec) 


Revision History:

    Creation: 04-Apr-2001

--*/

#ifndef _MCE_
#define _MCE_

//
// HalMcaLogInformation
//

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// ADDR register for each MCA bank
//

typedef union _MCI_ADDR{
    struct {
        ULONG Address;
        ULONG Reserved;
    };

    ULONGLONG   QuadPart;
} MCI_ADDR, *PMCI_ADDR;


typedef enum {
    HAL_MCE_RECORD,
    HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE;


#if defined(_AMD64_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#endif // _AMD64_

#if defined(_X86_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // _X86_

//
// MCA exception log entry
// Defined as a union to contain MCA specific log or Pentium style MCE info.
//

#define MCA_EXTREG_V2MAX       24  // X86: Max. Number of extended registers

#if defined(_X86_) || defined(_AMD64_)

typedef struct _MCA_EXCEPTION {

    // Begin Version 1 stuff
    ULONG               VersionNumber;      // Version number of this record type
    MCA_EXCEPTION_TYPE  ExceptionType;      // MCA or MCE
    LARGE_INTEGER       TimeStamp;          // exception recording timestamp
    ULONG               ProcessorNumber;
    ULONG               Reserved1;

    union {
        struct {
            UCHAR           BankNumber;
            UCHAR           Reserved2[7];
            MCI_STATS       Status;
            MCI_ADDR        Address;
            ULONGLONG       Misc;
        } Mca;

        struct {
            ULONGLONG       Address;        // physical addr of cycle causing the error
            ULONGLONG       Type;           // cycle specification causing the error
        } Mce;
    } u;
    // End   Version 1 stuff
    // Begin Version 2 stuff
    ULONG                   ExtCnt;
    ULONG                   Reserved3;
    ULONGLONG               ExtReg[MCA_EXTREG_V2MAX];
    // End   Version 2 stuff

} MCA_EXCEPTION, *PMCA_EXCEPTION;

typedef MCA_EXCEPTION CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef MCA_EXCEPTION CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#define MCA_EXCEPTION_V1_SIZE FIELD_OFFSET(MCA_EXCEPTION, ExtCnt)
#define MCA_EXCEPTION_V2_SIZE sizeof(struct _MCA_EXCEPTION)

#endif // _X86_ || _AMD64_

#if defined(_IA64_)

#if 0
// FIXFIX: This should not be required for IA64.
//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // 0

//
// IA64 ERRORS: ERROR_REVISION definitions
//

typedef union _ERROR_REVISION {
    USHORT      Revision;           // Major and Minor revision number of the record:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} ERROR_REVISION, *PERROR_REVISION;

// For Info:
#define ERROR_REVISION_SAL_03_00 { 2, 0 }

//
// IA64 ERRORS: ERROR_SEVERITY definitions
//
// One day the MS compiler will support typed enums with type != int so this
// type of enums (UCHAR, __int64) could be defined...
//

typedef UCHAR ERROR_SEVERITY, *PERROR_SEVERITY;

typedef enum _ERROR_SEVERITY_VALUE  {
    ErrorRecoverable = 0,
    ErrorFatal       = 1,
    ErrorCorrected   = 2,
    ErrorOthers      = 3,   // [3,...] values are reserved
} ERROR_SEVERITY_VALUE;

//
// IA64 ERRORS: ERROR_TIMESTAMP definitions
//

typedef union _ERROR_TIMESTAMP  {
    ULONGLONG   TimeStamp;
    struct  {
        UCHAR   Seconds;  // Byte0: Seconds
        UCHAR   Minutes;  // Byte1: Minutes
        UCHAR   Hours;    // Byte2: Hours
        UCHAR   Reserved; // Byte3: Reserved
        UCHAR   Day;      // Byte4: Day
        UCHAR   Month;    // Byte5: Month
        UCHAR   Year;     // Byte6: Year
        UCHAR   Century;  // Byte7: Century
    };
} ERROR_TIMESTAMP, *PERROR_TIMESTAMP;

//
// IA64 ERRORS: ERROR_GUID definitions
//

typedef struct _ERROR_GUID   {
    ULONG   Data1;
    USHORT  Data2;
    USHORT  Data3;
    UCHAR   Data4[8];
} ERROR_GUID, *PERROR_GUID;

//
// IA64 ERRORS: ERROR GUIDs definitions
//

typedef ERROR_GUID            _ERROR_DEVICE_GUID;
typedef _ERROR_DEVICE_GUID    ERROR_DEVICE_GUID, *PERROR_DEVICE_GUID;

typedef ERROR_GUID            _ERROR_PLATFORM_GUID;
typedef _ERROR_PLATFORM_GUID  ERROR_PLATFORM_GUID, *PERROR_PLATFORM_GUID;

//
// IA64 ERRORS: ERROR_RECORD_HEADER definitions
//

typedef union _ERROR_RECORD_VALID   {
    UCHAR     Valid;
    struct {                        // Bits
        UCHAR OemPlatformID:1;      //    0: OEM Platform Id is present in the record header
        UCHAR Reserved:7;           //  1-7: Reserved 
    };
} ERROR_RECORD_VALID, *PERROR_RECORD_VALID;

typedef struct _ERROR_RECORD_HEADER { // Offsets:
    ULONGLONG          Id;                //   0: Unique identifier
    ERROR_REVISION     Revision;          //   8: Major and Minor revision number of the record
    ERROR_SEVERITY     ErrorSeverity;     //  10: Error Severity
    ERROR_RECORD_VALID Valid;             //  11: Validation bits
    ULONG              Length;            //  12: Length of this record in bytes, including the header
    ERROR_TIMESTAMP    TimeStamp;         //  16: Timestamp recorded when event occured
    UCHAR              OemPlatformId[16]; //  24: Unique platform identifier. OEM defined.
} ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;

//
// IA64 ERRORS: ERROR_SECTION_HEADER definitions
//

typedef union _ERROR_RECOVERY_INFO  {
    UCHAR RecoveryInfo;
    struct  {                 // Bits:
        UCHAR Corrected:1;    //    0: Corrected
        UCHAR NotContained:1; //    1: Containment Warning
        UCHAR Reset:1;        //    2: Reset
        UCHAR Reserved:4;     //  6-3: Reserved
        UCHAR Valid:1;        //    7: Valid Recovery Information
    };
} ERROR_RECOVERY_INFO, *PERROR_RECOVERY_INFO;

typedef struct _ERROR_SECTION_HEADER    {
    ERROR_DEVICE_GUID   Guid;         // Unique identifier
    ERROR_REVISION      Revision;     // Major and Minor revision number of the section
    ERROR_RECOVERY_INFO RecoveryInfo; // Recovery Information
    UCHAR               Reserved;
    ULONG               Length;       // Length of this error device section in bytes, 
                                      // including the header.
} ERROR_SECTION_HEADER, *PERROR_SECTION_HEADER;

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//

#if !defined(__midl)
__inline
USHORT
GetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    USHORT lid = (USHORT)((UCHAR)(section->Reserved));
    lid |= (USHORT)((UCHAR)(Log->TimeStamp.Reserved) << 8);
    return( lid );
} // GetFwMceLogProcessorNumber()
#endif // !__midl

//
// IA64 ERRORS: ERROR_PROCESSOR device definitions
//
// The MCA architecture supports five different types of error reporting functional units
// with the associated error records and its error severity. 
// At any point in time, a processor could encounter an MCA/CMC event due to errors detected 
// in one or more of the following units:
//  - Cache Check
//  - TLB   Check
//  - Bus   Check
//  - Register File
//  - Micro Architectural
//
// Terminology:
//
//  - Target Address:
//      64-bit integer containing the physical address where the data was to be delivered or
//      obtained. This could also be the incoming address for external snoops and TLB shoot-downs.
//
//  - Requestor Identifier:
//      64-bit integer specifying the bus agent that generated the transaction responsible for
//      the Machine Check event.
//                    
//  - Responder Identifier:
//      64-bit integer specifying the bus agent that responded to a transaction responsible for
//      the Machine Check event.
//                    
//  - Precise Instruction Pointer:
//      64-bit integer specifying the virtual address that points to the IA-64 bundle that 
//      contained the instruction responsible for the Machine Check event.
//                    

#define ERROR_PROCESSOR_GUID \
    { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MODINFO_VALID  {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG CheckInfo: 1;             //       0:
        ULONGLONG RequestorIdentifier: 1;   //       1:
        ULONGLONG ResponderIdentifier: 1;   //       2:
        ULONGLONG TargetIdentifier: 1;      //       3:
        ULONGLONG PreciseIP: 1;             //       4:
        ULONGLONG Reserved: 59;             //    5-63:
    };
} ERROR_MODINFO_VALID, *PERROR_MODINFO_VALID;

typedef enum _ERROR_CHECK_IS    {
    isIA64 = 0,
    isIA32 = 1,
} ERROR_CHECK_IS;

typedef enum _ERROR_CACHE_CHECK_OPERATION   {
    CacheUnknownOp = 0,
    CacheLoad  = 1,
    CacheStore = 2,
    CacheInstructionFetch = 3,
    CacheDataPrefetch = 4,
    CacheSnoop = 5,
    CacheCastOut = 6,
    CacheMoveIn = 7,
} ERROR_CACHE_CHECK_OPERATION;

typedef enum _ERROR_CACHE_CHECK_MESI    {
    CacheInvalid = 0,
    CacheHeldShared = 1,
    CacheHeldExclusive = 2,
    CacheModified = 3,
} ERROR_CACHE_CHECK_MESI;

typedef union _ERROR_CACHE_CHECK    {
    ULONGLONG CacheCheck;
    struct
    {
        ULONGLONG Operation:4;             // bits  0- 3: Cache operation
        ULONGLONG Level:2;                 //       4- 5: Cache Level
        ULONGLONG Reserved1:2;             //       6- 7
        ULONGLONG DataLine:1;              //       8   : Failure data part of cache line
        ULONGLONG TagLine:1;               //       9   : Failure tag part of cache line
        ULONGLONG DataCache:1;             //      10   : Failure in data cache
        ULONGLONG InstructionCache:1;      //      11   : Failure in instruction cache
        ULONGLONG MESI:3;                  //      12-14:
        ULONGLONG MESIValid:1;             //      15   : MESI field is valid
        ULONGLONG Way:5;                   //      16-20: Failure in Way of Cache
        ULONGLONG WayIndexValid:1;         //      21   : Way and Index fields valid
        ULONGLONG Reserved2:10;            //      22-31
        ULONGLONG Index:20;                //      32-51: Index of cache line
        ULONGLONG Reserved3:2;             //      52-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

typedef enum _ERROR_TLB_CHECK_OPERATION   {
    TlbUnknownOp = 0,
    TlbAccessWithLoad  = 1,
    TlbAccessWithStore = 2,
    TlbAccessWithInstructionFetch = 3,
    TlbAccessWithDataPrefetch = 4,
    TlbShootDown = 5,
    TlbProbe = 6,
    TlbVhptFill = 7,
} ERROR_TLB_CHECK_OPERATION;

typedef union _ERROR_TLB_CHECK  {
    ULONGLONG TlbCheck;
    struct
    {
        ULONGLONG TRSlot:8;                // bits  0- 7: Slot number of Translation Register
        ULONGLONG TRSlotValid:1;           //       8   : TRSlot field is valid
        ULONGLONG Reserved1:1;             //       9
        ULONGLONG Level:2;                 //      10-11: TLB Level
        ULONGLONG Reserved2:4;             //      12-15
        ULONGLONG DataTransReg:1;          //      16   : Error in data translation register
        ULONGLONG InstructionTransReg:1;   //      17   : Error in instruction translation register
        ULONGLONG DataTransCache:1;        //      18   : Error in data translation cache
        ULONGLONG InstructionTransCache:1; //      19   : Error in instruction translation cache
        ULONGLONG Operation:4;             //      20-23: Operation
        ULONGLONG Reserved3:30;            //      24-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_TLB_CHECK, *PERROR_TLB_CHECK;

typedef enum _ERROR_BUS_CHECK_OPERATION   {
    BusUnknownOp = 0,
    BusPartialRead  = 1,
    BusPartialWrite = 2,
    BusFullLineRead = 3,
    BusFullLineWrite = 4,
    BusWriteBack = 5,
    BusSnoopProbe = 6,
    BusIncomingPtcG = 7,
    BusWriteCoalescing = 8,
} ERROR_BUS_CHECK_OPERATION;

typedef union _ERROR_BUS_CHECK  {
    ULONGLONG BusCheck;
    struct
    {
        ULONGLONG Size:5;                  // bits  0- 4: Transaction size
        ULONGLONG Internal:1;              //       5   : Internal bus error
        ULONGLONG External:1;              //       6   : External bus error
        ULONGLONG CacheTransfer:1;         //       7   : Error occured in Cache to Cache Transfer 
        ULONGLONG Type:8;                  //       8-15: Transaction type
        ULONGLONG Severity:5;              //      16-20: Error severity - platform specific
        ULONGLONG Hierarchy:2;             //      21-22: Level or Bus hierarchy
        ULONGLONG Reserved1:1;             //      23
        ULONGLONG Status:8;                //      24-31: Bus error status - processor bus specific
        ULONGLONG Reserved2:22;            //      32-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

typedef enum _ERROR_REGFILE_CHECK_IDENTIFIER   {
    RegFileUnknownId = 0,
    GeneralRegisterBank1 = 1,
    GeneralRegisterBank0 = 2,
    FloatingPointRegister = 3,
    BranchRegister = 4,
    PredicateRegister = 5,
    ApplicationRegister = 6,
    ControlRegister = 7,
    RegionRegister = 8,
    ProtectionKeyRegister = 9,
    DataBreakPointRegister = 10,
    InstructionBreakPointRegister = 11,
    PerformanceMonitorControlRegister = 12,
    PerformanceMonitorDataRegister = 13,
} ERROR_REGFILE_CHECK_IDENTIFIER;

typedef enum _ERROR_REGFILE_CHECK_OPERATION   {
    RegFileUnknownOp = 0,
    RegFileRead = 1,
    RegFileWrite = 2,
} ERROR_REGFILE_CHECK_OPERATION;

typedef union _ERROR_REGFILE_CHECK  {
    ULONGLONG RegFileCheck;
    struct
    {
        ULONGLONG Identifier:4;            // bits  0- 3: Register file identifier
        ULONGLONG Operation:4;             //       4- 7: Operation that causes the MC event
        ULONGLONG RegisterNumber:7;        //       8-14: Register number responsible for MC event
        ULONGLONG RegisterNumberValid:1;   //      15   : Register number field is valid
        ULONGLONG Reserved1:38;            //      16-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG Reserved2:3;             //      60-62
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_REGFILE_CHECK, *PERROR_REGFILE_CHECK;

typedef enum _ERROR_MS_CHECK_OPERATION   {
    MsUnknownOp = 0,
    MsReadOrLoad = 1,
    MsWriteOrStore = 2,
} ERROR_MS_CHECK_OPERATION;

typedef union _ERROR_MS_CHECK  {
    ULONGLONG MsCheck;
    struct
    {
        ULONGLONG StructureIdentifier:5;   // bits  0- 4: Structure Identifier - impl. specific
        ULONGLONG Level:3;                 //       5- 7: Structure Level where error was generated
        ULONGLONG ArrayId:4;               //       8-11: Identification of the array 
        ULONGLONG Operation:4;             //      12-15: Operation
        ULONGLONG Way:6;                   //      16-21: Way where the error was located
        ULONGLONG WayValid:1;              //      22   : Way field is valid
        ULONGLONG IndexValid:1;            //      23   : Index field is valid
        ULONGLONG Reserved1:8;             //      24-31
        ULONGLONG Index:8;                 //      32-39: Index where the error was located
        ULONGLONG Reserved2:14;            //      40-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_MS_CHECK, *PERROR_MS_CHECK;

typedef union _ERROR_CHECK_INFO   {
    ULONGLONG             CheckInfo;
    ERROR_CACHE_CHECK     CacheCheck;
    ERROR_TLB_CHECK       TlbCheck;
    ERROR_BUS_CHECK       BusCheck;
    ERROR_REGFILE_CHECK   RegFileCheck;
    ERROR_MS_CHECK        MsCheck;
} ERROR_CHECK_INFO, *PERROR_CHECK_INFO;

// SAL Specs July 2000: The size of _ERROR_MODINFO will always be 48 Bytes.

typedef struct _ERROR_MODINFO   {
    ERROR_MODINFO_VALID Valid;
    ERROR_CHECK_INFO    CheckInfo;
    ULONGLONG           RequestorId;
    ULONGLONG           ResponderId;
    ULONGLONG           TargetId;
    ULONGLONG           PreciseIP;
} ERROR_MODINFO, *PERROR_MODINFO;

typedef union _ERROR_PROCESSOR_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorMap: 1;              //       0:
        ULONGLONG StateParameter: 1;        //       1:
        ULONGLONG CRLid: 1;                 //       2:
        ULONGLONG StaticStruct:1;           //       3: Processor Static Info error.
        ULONGLONG CacheCheckNum:4;          //     4-7: Cache errors.
        ULONGLONG TlbCheckNum:4;            //    8-11: Tlb errors.
        ULONGLONG BusCheckNum:4;            //   12-15: Bus errors.
        ULONGLONG RegFileCheckNum:4;        //   16-19: Registers file errors.
        ULONGLONG MsCheckNum:4;             //   20-23: Micro-Architecture errors.
        ULONGLONG CpuIdInfo:1;              //      24: CPUID Info.
        ULONGLONG Reserved:39;              //   25-63: Reserved.
    };
} ERROR_PROCESSOR_VALID, *PERROR_PROCESSOR_VALID;

typedef union _ERROR_PROCESSOR_ERROR_MAP {
    ULONGLONG   ErrorMap;
    struct  {
        ULONGLONG   Cid:4;                 // bits  0- 3: Processor Core Identifier
        ULONGLONG   Tid:4;                 //       4- 7: Logical Thread Identifier
        ULONGLONG   Eic:4;                 //       8-11: Instruction Caches Level Information
        ULONGLONG   Edc:4;                 //      12-15: Data        Caches Level Information
        ULONGLONG   Eit:4;                 //      16-19: Instruction TLB    Level Information
        ULONGLONG   Edt:4;                 //      20-23: Data        TLB    Level Information
        ULONGLONG   Ebh:4;                 //      24-27: Processor   Bus    Level Information
        ULONGLONG   Erf:4;                 //      28-31: Register    File   Level Information
        ULONGLONG   Ems:16;                //      32-47: MicroArchitecture  Level Information
        ULONGLONG   Reserved:16;      
    };
} ERROR_PROCESSOR_ERROR_MAP, *PERROR_PROCESSOR_ERROR_MAP;

typedef ERROR_PROCESSOR_ERROR_MAP    _ERROR_PROCESSOR_LEVEL_INDEX;
typedef _ERROR_PROCESSOR_LEVEL_INDEX ERROR_PROCESSOR_LEVEL_INDEX, *PERROR_PROCESSOR_LEVEL_INDEX;

typedef union _ERROR_PROCESSOR_STATE_PARAMETER {
    ULONGLONG   StateParameter;
    struct {
        ULONGLONG reserved0:2;  //   0-1 : reserved
        ULONGLONG rz:1;         //     2 : Rendez-vous successful
        ULONGLONG ra:1;         //     3 : Rendez-vous attempted
        ULONGLONG me:1;         //     4 : Distinct Multiple errors
        ULONGLONG mn:1;         //     5 : Min-state Save Area registered
        ULONGLONG sy:1;         //     6 : Storage integrity synchronized
        ULONGLONG co:1;         //     7 : Continuable
        ULONGLONG ci:1;         //     8 : Machine Check isolated
        ULONGLONG us:1;         //     9 : Uncontained Storage damage
        ULONGLONG hd:1;         //    10 : Hardware damage
        ULONGLONG tl:1;         //    11 : Trap lost
        ULONGLONG mi:1;         //    12 : More Information
        ULONGLONG pi:1;         //    13 : Precise Instruction pointer
        ULONGLONG pm:1;         //    14 : Precise Min-state Save Area
        ULONGLONG dy:1;         //    15 : Processor Dynamic State valid
        ULONGLONG in:1;         //    16 : INIT interruption
        ULONGLONG rs:1;         //    17 : RSE valid
        ULONGLONG cm:1;         //    18 : Machine Check corrected
        ULONGLONG ex:1;         //    19 : Machine Check expected
        ULONGLONG cr:1;         //    20 : Control Registers valid
        ULONGLONG pc:1;         //    21 : Performance Counters valid
        ULONGLONG dr:1;         //    22 : Debug Registers valid
        ULONGLONG tr:1;         //    23 : Translation Registers valid
        ULONGLONG rr:1;         //    24 : Region Registers valid
        ULONGLONG ar:1;         //    25 : Application Registers valid
        ULONGLONG br:1;         //    26 : Branch Registers valid
        ULONGLONG pr:1;         //    27 : Predicate Registers valid
        ULONGLONG fp:1;         //    28 : Floating-Point Registers valid
        ULONGLONG b1:1;         //    29 : Preserved Bank 1 General Registers valid
        ULONGLONG b0:1;         //    30 : Preserved Bank 0 General Registers valid
        ULONGLONG gr:1;         //    31 : General Registers valid
        ULONGLONG dsize:16;     // 47-32 : Processor Dynamic State size
        ULONGLONG reserved1:11; // 48-58 : reserved
        ULONGLONG cc:1;         //    49 : Cache Check
        ULONGLONG tc:1;         //    60 : TLB   Check
        ULONGLONG bc:1;         //    61 : Bus   Check
        ULONGLONG rc:1;         //    62 : Register File Check
        ULONGLONG uc:1;         //    63 : Micro-Architectural Check
    };
} ERROR_PROCESSOR_STATE_PARAMETER, *PERROR_PROCESSOR_STATE_PARAMETER;
    
typedef union _PROCESSOR_LOCAL_ID  {
    ULONGLONG LocalId;
    struct {
        ULONGLONG reserved:16;  //  0-16 : reserved
        ULONGLONG eid:8;        // 16-23 : Extended Id 
        ULONGLONG id:8;         // 24-31 : Id
        ULONGLONG ignored:32;   // 32-63 : ignored
    };
} PROCESSOR_LOCAL_ID, *PPROCESSOR_LOCAL_ID;

typedef struct _ERROR_PROCESSOR_MS {
    ULONGLONG      MsError   [ /* Valid.MsCheckNum      */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_MS, *PERROR_PROCESSOR_MS;

typedef struct _ERROR_PROCESSOR_CPUID_INFO {   // Must be 48 bytes.
    ULONGLONG CpuId0;
    ULONGLONG CpuId1;
    ULONGLONG CpuId2;
    ULONGLONG CpuId3;
    ULONGLONG CpuId4;
    ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO, *PERROR_PROCESSOR_CPUID_INFO;                                       

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID {
    ULONGLONG     Valid;
    struct {                                // Bits
        // Warning: Match the VALID fields with the _ERROR_PROCESSOR_STATIC_INFO members.
        //          KD extensions use the field names to access the PSI structure.
        ULONGLONG MinState: 1;              //       0: MinState              valid.
        ULONGLONG BR: 1;                    //       1: Branch      Registers valid.
        ULONGLONG CR: 1;                    //       2: Control     Registers valid.
        ULONGLONG AR: 1;                    //       3: Application Registers valid.
        ULONGLONG RR: 1;                    //       4:             Registers valid.
        ULONGLONG FR: 1;                    //       5:             Registers valid.
        ULONGLONG Reserved: 58;             //    6-63: Reserved.
    };
} ERROR_PROCESSOR_STATIC_INFO_VALID, *PERROR_PROCESSOR_STATIC_INFO_VALID;

typedef struct _ERROR_PROCESSOR_STATIC_INFO  {
    ERROR_PROCESSOR_STATIC_INFO_VALID Valid;
    UCHAR      MinState[ /* SAL Specs, July 2000 and Jan 2001 state approximatively: */ 1024];
    ULONGLONG  BR      [ 8 ];
    ULONGLONG  CR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  AR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  RR      [ 8 ];
    ULONGLONG  FR      [ 2 * 128 ];
} ERROR_PROCESSOR_STATIC_INFO, *PERROR_PROCESSOR_STATIC_INFO;

typedef struct _ERROR_PROCESSOR {
    ERROR_SECTION_HEADER              Header;
    ERROR_PROCESSOR_VALID             Valid;
    ERROR_PROCESSOR_ERROR_MAP         ErrorMap;
    ERROR_PROCESSOR_STATE_PARAMETER   StateParameter;
    PROCESSOR_LOCAL_ID                CRLid;
#if 0
// The presence of the following data depends on the valid bits
// from ERROR_PROCESSOR.Valid.
//
    ERROR_MODINFO               CacheErrorInfo   [ /* Valid.CacheCheckNum   */ ]; // 0->15 cache error modinfo structs.
    ERROR_MODINFO               TlbErrorInfo     [ /* Valid.TlbCheckNum     */ ]; // 0->15 tlb   error modinfo structs.
    ERROR_MODINFO               BusErrorInfo     [ /* Valid.BusCheckNum     */ ]; // 0->15 bus   error modinfo structs.
    ERROR_MODINFO               RegFileCheckInfo [ /* Valid.RegFileCheckNum */ ]; // 0->15 registers file errors.
    ERROR_MODINFO               MsCheckInfo      [ /* Valid.MsCheckNum      */ ]; // 0->15 registers file errors.
    ERROR_PROCESSOR_CPUID_INFO  CpuIdInfo;       // field will always be there but could be zero-padded.
    ERROR_PROCESSOR_STATIC_INFO StaticInfo;      // field will always be there but could be zero-padded.
#endif // 0
} ERROR_PROCESSOR, *PERROR_PROCESSOR;

//
// IA64 ERROR PROCESSOR State Parameter - GR18 - definitions.
//

#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT     60
#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK      0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT       61
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK        0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT       62
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK        0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT   63
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK    0x1

////////////////////////////////////////////////////////////////////
//
// IA64 PLATFORM ERRORS Definitions
//
// We tried to respect the order in which these error devices are 
// presented in the SAL specs.

//
// IA64 ERRORS: _ERR_TYPE definitions
//
// Warning 04/01/01: "ERR_TYPE" or "ERROR_TYPE" are already used in the NT namespace.
//

typedef enum _ERR_TYPES    {
// Generic error types:
    ERR_INTERNAL = 1,         // Error detected internal to the component
    ERR_BUS      = 16,        // Error detected in the bus
// Detailed Internal Error Types:
    ERR_MEM      = 4,         // Storage error in memory (DRAM)
    ERR_TLB      = 5,         // Storage error in TLB
    ERR_CACHE    = 6,         // Storage error in cache
    ERR_FUNCTION = 7,         // Error in one or more functional units
    ERR_SELFTEST = 8,         // Component failed self test
    ERR_FLOW     = 9,         // Overflow or Undervalue of internal queue
// Detailed Bus Error Types:
    ERR_MAP      = 17,        // Virtual address not found on IO-TLB or IO-PDIR
    ERR_IMPROPER = 18,        // Improper access error
    ERR_UNIMPL   = 19,        // Access to a memory address which is not mapped to any component
    ERR_LOL      = 20,        // Loss Of Lockstep
    ERR_RESPONSE = 21,        // Response to which there is no associated request
    ERR_PARITY   = 22,        // Bus parity error
    ERR_PROTOCOL = 23,        // Detection of a protocol error
    ERR_ERROR    = 24,        // Detection of PATH_ERROR
    ERR_TIMEOUT  = 25,        // Bus operation time-out
    ERR_POISONED = 26,        // A read was issued to data which has been poisoned
} _ERR_TYPE;

//
// IA64 ERRORS: ERROR_STATUS definitions
//

typedef union _ERROR_STATUS {
    ULONGLONG Status;
    struct  {                 //  Bits:
        ULONGLONG Reserved0:8;  //   7-0: Reserved
        ULONGLONG Type:8;       //  15-8: Error Type - See _ERR_TYPE definitions.
        ULONGLONG Address:1;    //    16: Error was detected on address signals or on address portion of transaction
        ULONGLONG Control:1;    //    17: Error was detected on control signals or in control portion of transaction
        ULONGLONG Data:1;       //    18: Error was detected on data signals or in data portion of transaction
        ULONGLONG Responder:1;  //    19: Error was detected by responder of transaction
        ULONGLONG Requestor:1;  //    20: Error was detected by requestor of transaction
        ULONGLONG FirstError:1; //    21: If multiple errors, this is the first error of the highest severity that occurred
        ULONGLONG Overflow:1;   //    22: Additional errors occurred which were not logged because registers overflow 
        ULONGLONG Reserved1:41; // 63-23: Reserved
    };
} ERROR_STATUS, *PERROR_STATUS;

//
// IA64 ERRORS: Platform OEM_DATA definitions
//

typedef struct _ERROR_OEM_DATA {
    USHORT Length;
#if 0
    UCHAR  Data[/* ERROR_OEM_DATA.Length */];
#endif // 0
} ERROR_OEM_DATA, *PERROR_OEM_DATA;

//
// IA64 ERRORS: Platform BUS_SPECIFIC_DATA definitions
//

typedef union _ERROR_BUS_SPECIFIC_DATA {
    ULONGLONG BusSpecificData;
    struct {                                         // Bits :
        ULONGLONG LockAsserted:1;                    //     0: LOCK# Asserted during request phase
        ULONGLONG DeferLogged:1;                     //     1: Defer phase is logged
        ULONGLONG IOQEmpty:1;                        //     2: IOQ is empty
        ULONGLONG DeferredTransaction:1;             //     3: Component interface deferred transaction
        ULONGLONG RetriedTransaction:1;              //     4: Component interface retried transaction
        ULONGLONG MemoryClaimedTransaction:1;        //     5: memory claimed the transaction
        ULONGLONG IOClaimedTransaction:1;            //     6: IO controller claimed the transaction
        ULONGLONG ResponseParitySignal:1;            //     7: Response parity signal
        ULONGLONG DeferSignal:1;                     //     8: DEFER# signal
        ULONGLONG HitMSignal:1;                      //     9: HITM# signal
        ULONGLONG HitSignal:1;                       //    10: HIT# signal
        ULONGLONG RequestBusFirstCycle:6;            // 16-11: First cycle of request bus
        ULONGLONG RequestBusSecondCycle:6;           // 22-17: Second cycle of request bus
        ULONGLONG AddressParityBusFirstCycle:2;      // 24-23: First cycle of address parity bus
        ULONGLONG AddressParityBusSecondCycle:2;     // 26-25: Second cycle of address parity
        ULONGLONG ResponseBus:3;                     // 29-27: Response bus
        ULONGLONG RequestParitySignalFirstCycle:1;   //    30: First cycle of request parity signal
        ULONGLONG RequestParitySignalSecondCycle:1;  //    31: Second cycle of request parity signal
        ULONGLONG Reserved:32;                       // 63-32: Reserved
    };
} ERROR_BUS_SPECIFIC_DATA, *PERROR_BUS_SPECIFIC_DATA;

//
// IA64 ERRORS: Platform ERROR_MEMORY device definitions
//
// With reference to the ACPI Memory Device.
//

#define ERROR_MEMORY_GUID \
    { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MEMORY_VALID    {
    ULONGLONG     Valid;
    struct {                                 // Bits
        ULONGLONG ErrorStatus:1;             //       0: Error Status valid bit
        ULONGLONG PhysicalAddress:1;         //       1: Physical Address valid bit
        ULONGLONG AddressMask:1;             //       2: Address Mask bit
        ULONGLONG Node:1;                    //       3: Node valid bit
        ULONGLONG Card:1;                    //       4: Card valid bit
        ULONGLONG Module:1;                  //       5: Module valid bit
        ULONGLONG Bank:1;                    //       6: Bank valid bit
        ULONGLONG Device:1;                  //       7: Device valid bit
        ULONGLONG Row:1;                     //       8: Row valid bit
        ULONGLONG Column:1;                  //       9: Column valid bit
        ULONGLONG BitPosition:1;             //      10: Bit Position valid bit
        ULONGLONG RequestorId:1;             //      11: Platform Requestor Id valid bit
        ULONGLONG ResponderId:1;             //      12: Platform Respinder Id valid bit
        ULONGLONG TargetId:1;                //      13: Platform Target    Id valid bit
        ULONGLONG BusSpecificData:1;         //      14: Platform Bus specific data valid bit
        ULONGLONG OemId:1;                   //      15: Platform OEM id   valid bit
        ULONGLONG OemData:1;                 //      16: Platform OEM data valid bit
        ULONGLONG Reserved:47;               //   63-17: Reserved
    };
} ERROR_MEMORY_VALID, *PERROR_MEMORY_VALID;

typedef struct _ERROR_MEMORY    {
    ERROR_SECTION_HEADER  Header;
    ERROR_MEMORY_VALID    Valid;
    ERROR_STATUS          ErrorStatus;         // Memory device error status fields - See ERROR_STATUS defs.
    ULONGLONG             PhysicalAddress;     // Physical Address of the memory error
    ULONGLONG             PhysicalAddressMask; // Valid bits for Physical Address
    USHORT                Node;                // Node identifier in a multi-node system
    USHORT                Card;                // Card   number of the memory error location
    USHORT                Module;              // Module number of the memory error location
    USHORT                Bank;                // Bank   number of the memory error location
    USHORT                Device;              // Device number of the memory error location
    USHORT                Row;                 // Row    number of the memory error location
    USHORT                Column;              // Column number of the memory error location
    USHORT                BitPosition;         // Bit within the word that is in error
    ULONGLONG             RequestorId;         // Hardware address of the device or component initiating transaction
    ULONGLONG             ResponderId;         // Hardware address of the responder to transaction
    ULONGLONG             TargetId;            // Hardware address of intended target of transaction       
    ULONGLONG             BusSpecificData;     // Bus dependent data of the on-board processor. It is a OEM specific field.
    UCHAR                 OemId[16];           // OEM defined identification for memory controller
    ERROR_OEM_DATA        OemData;     // OEM platform specific data. 
} ERROR_MEMORY, *PERROR_MEMORY;

//
// IA64 ERRORS: Platform ERROR_PCI_BUS device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_BUS_GUID \
    { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_BUS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorStatus:1;            //       0: Error Status             valid bit
        ULONGLONG ErrorType:1;              //       1: Error Type               valid bit
        ULONGLONG Id:1;                     //       2: Identifier               valid bit
        ULONGLONG Address:1;                //       3: Address                  valid bit
        ULONGLONG Data:1;                   //       4: Data                     valid bit
        ULONGLONG CmdType:1;                //       5: Command Type             valid bit
        ULONGLONG RequestorId:1;            //       6: Requestor Identifier     valid bit
        ULONGLONG ResponderId:1;            //       7: Responder Identifier     valid bit
        ULONGLONG TargetId:1;               //       8: Target    Identifer      valid bit
        ULONGLONG OemId:1;                  //       9: OEM Identification       valid bit
        ULONGLONG OemData:1;                //      10: OEM Data                 valid bit
        ULONGLONG Reserved:57;              //   11-63: Reserved
    };
} ERROR_PCI_BUS_VALID, *PERROR_PCI_BUS_VALID;

typedef struct _ERROR_PCI_BUS_TYPE {
    UCHAR Type;
    UCHAR Reserved;
} ERROR_PCI_BUS_TYPE, *PERROR_PCI_BUS_TYPE;

#define PciBusUnknownError       ((UCHAR)0)
#define PciBusDataParityError    ((UCHAR)1)
#define PciBusSystemError        ((UCHAR)2)
#define PciBusMasterAbort        ((UCHAR)3)
#define PciBusTimeOut            ((UCHAR)4)
#define PciMasterDataParityError ((UCHAR)5)
#define PciAddressParityError    ((UCHAR)6)
#define PciCommandParityError    ((UCHAR)7)
//      PciOtherErrors           Reserved

typedef struct _ERROR_PCI_BUS_ID    {
    UCHAR BusNumber;         // Bus     Number
    UCHAR SegmentNumber;     // Segment Number
} ERROR_PCI_BUS_ID, *PERROR_PCI_BUS_ID;

typedef struct _ERROR_PCI_BUS    {
    ERROR_SECTION_HEADER  Header;
    ERROR_PCI_BUS_VALID   Valid;
    ERROR_STATUS          ErrorStatus;    // PCI Bus Error Status - See ERROR_STATUS definitions.
    ERROR_PCI_BUS_TYPE    Type;           // PCI Bus Error Type 
    ERROR_PCI_BUS_ID      Id;             // PCI Bus Identifier      
    UCHAR                 Reserved[4];    // Reserved
    ULONGLONG             Address;        // Memory or IO Address on the PCI bus at
                                          // the time of the event
    ULONGLONG             Data;           // Data on the PCI bus at time of the event
    ULONGLONG             CmdType;        // Bus Command or Operation at time of the event
    ULONGLONG             RequestorId;    // Bus Requestor Identifier at time of the event
    ULONGLONG             ResponderId;    // Bus Responder Identifier at time of the event
    ULONGLONG             TargetId;       // Intended Bus Target Identifier at time of the event
    UCHAR                 OemId[16];      // OEM defined identification for pci bus
    ERROR_OEM_DATA        OemData;        // OEM specific data. 
} ERROR_PCI_BUS, *PERROR_PCI_BUS;

//
// IA64 ERRORS: Platform ERROR_PCI_COMPONENT device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_COMPONENT_GUID \
    { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_COMPONENT_VALID   {
    ULONGLONG Valid;
    struct {                                       // Bits:
        ULONGLONG ErrorStatus:1;                   //    0: Error Status valid bit
        ULONGLONG Info:1;                          //    1: Information  valid bit
        ULONGLONG MemoryMappedRegistersPairs:1;    //    2: Number of Memory Mapped Registers Pairs valid bit
        ULONGLONG ProgrammedIORegistersPairs:1;    //    3: Number of Programmed IO Registers Pairs valid bit
        ULONGLONG RegistersDataPairs:1;            //    4: Memory Mapped Registers Pairs valid bit
        ULONGLONG OemData:1;                       //    5: OEM Data valid bit.
        ULONGLONG Reserved:58;                     // 63-6: Reserved
    };
} ERROR_PCI_COMPONENT_VALID, *PERROR_PCI_COMPONENT_VALID;

typedef struct _ERROR_PCI_COMPONENT_INFO {  // Bytes:
   USHORT VendorId;                         //   0-1: Vendor Identifier
   USHORT DeviceId;                         //   2-3: Device Identifier
   UCHAR  ClassCodeInterface;               //     4: Class Code.Interface field
   UCHAR  ClassCodeSubClass;                //     5: Class Code.SubClass  field
   UCHAR  ClassCodeBaseClass;               //     6: Class Code.BaseClass field
   UCHAR  FunctionNumber;                   //     7: Function Number
   UCHAR  DeviceNumber;                     //     8: Device Number
   UCHAR  BusNumber;                        //     9: Bus Number
   UCHAR  SegmentNumber;                    //    10: Segment Number
   UCHAR  Reserved0;    
   ULONG  Reserved1;
} ERROR_PCI_COMPONENT_INFO, *PERROR_PCI_COMPONENT_INFO;

typedef struct _ERROR_PCI_COMPONENT  {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;                 // Component Error Status
     ERROR_PCI_COMPONENT_INFO    Info;                        // Component Information
     ULONG                       MemoryMappedRegistersPairs;  // Number of Memory Mapped Registers Pairs
     ULONG                       ProgrammedIORegistersPairs;  // Number of Programmed IO Registers Pairs
#if 0
     ULONGLONG                   RegistersPairs[/* 2 * (MemoryMappedRegistersPairs + ProgrammedIORegistersPairs) */];
     ERROR_OEM_DATA              OemData;
#endif // 0
 } ERROR_PCI_COMPONENT, *PERROR_PCI_COMPONENT;

//
// IA64 ERRORS: Platform ERROR_SYSTEM_EVENT_LOG device definitions
//
// With reference to the IPMI System Event Log.
//

#define ERROR_SYSTEM_EVENT_LOG_GUID \
    { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SYSTEM_EVENT_LOG_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG RecordId:1;               //       0: Record Identifier     valid bit
        ULONGLONG RecordType:1;             //       1: Record Type           valid bit
        ULONGLONG GeneratorId:1;            //       2: Generator Identifier  valid bit
        ULONGLONG EVMRev:1;                 //       3: Event Format Revision valid bit
        ULONGLONG SensorType:1;             //       4: Sensor Type           valid bit
        ULONGLONG SensorNum:1;              //       5: Sensor Number         valid bit
        ULONGLONG EventDirType:1;           //       6: Event Dir             valid bit
        ULONGLONG EventData1:1;             //       7: Event Data1           valid bit
        ULONGLONG EventData2:1;             //       8: Event Data2           valid bit
        ULONGLONG EventData3:1;             //       9: Event Data3           valid bit
        ULONGLONG Reserved:54;              //   10-63:
    };
} ERROR_SYSTEM_EVENT_LOG_VALID, *PSYSTEM_EVENT_LOG_VALID;

typedef struct _ERROR_SYSTEM_EVENT_LOG    {
    ERROR_SECTION_HEADER         Header;
    ERROR_SYSTEM_EVENT_LOG_VALID Valid;
    USHORT                       RecordId;     // Record Identifier used for SEL record access
    UCHAR                        RecordType;   // Record Type:
                                               //   0x02 - System Event Record
                                               //   0xC0 - 0xDF OEM     time stamped, bytes 8-16 OEM defined
                                               //   0xE0 - 0xFF OEM non-time stamped, bytes 4-16 OEM defined
    ULONG                        TimeStamp;    // Time stamp of the event log
    USHORT                       GeneratorId;  // Software ID if event was generated by software
                                               //   Byte 1:
                                               //       Bit 0   - set to 1 when using system software
                                               //       Bit 7:1 - 7-bit system ID
                                               //   Byte 2:
                                               //       Bit 1:0 - IPMB device LUN if byte 1 holds slave
                                               //                 address, 0x0 otherwise
                                               //       Bit 7:2 - Reserved.
    UCHAR                        EVMRevision;  // Error message format version
    UCHAR                        SensorType;   // Sensor Type code of the sensor that generated event
    UCHAR                        SensorNumber; // Number of the sensor that generated event
    UCHAR                        EventDir;     // Event Dir
                                               //   Bit 7 - 0: asserted, 1: desasserted
                                               // Event Type
                                               //   Bit 6:0 - Event Type code
    UCHAR                        Data1;        // Event data field
    UCHAR                        Data2;        // Event data field
    UCHAR                        Data3;        // Event data field
} ERROR_SYSTEM_EVENT_LOG, *PERROR_SYSTEM_EVENT_LOG;

//
// IA64 ERRORS: Platform ERROR_SMBIOS device definitions
//
// With reference to the SMBIOS Specifications.
//

#define ERROR_SMBIOS_GUID \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SMBIOS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG EventType:1;              //       0: Event Type valid bit
        ULONGLONG Length:1;                 //       1: Length     valid bit
        ULONGLONG TimeStamp:1;              //       2: Time Stamp valid bit
        ULONGLONG OemData:1;                //       3: Data       valid bit
        ULONGLONG Reserved:60;              //    4-63:
    };
} ERROR_SMBIOS_VALID, *PERROR_SMBIOS_VALID;

//
// ERROR_SMBIOS.Type definitions
//

typedef UCHAR ERROR_SMBIOS_EVENT_TYPE, *PERROR_SMBIOS_EVENT_TYPE;
// enum values defined in SMBIOS 2.3 - 3.3.16.6.1

typedef struct _ERROR_SMBIOS    {
    ERROR_SECTION_HEADER     Header;
    ERROR_SMBIOS_VALID       Valid;
    ERROR_SMBIOS_EVENT_TYPE  EventType;   // Event Type
    UCHAR                    Length;      // Length of the error information in bytes
    ERROR_TIMESTAMP          TimeStamp;   // Event Time Stamp
    ERROR_OEM_DATA           OemData;     // Optional data validated by SMBIOS.Valid.Data.
} ERROR_SMBIOS, *PERROR_SMBIOS;

//
// IA64 ERRORS: Platform Specific error device definitions
//

#define ERROR_PLATFORM_SPECIFIC_GUID \
    { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_SPECIFIC_VALID, *PERROR_PLATFORM_SPECIFIC_VALID;

typedef struct _ERROR_PLATFORM_SPECIFIC  {
     ERROR_SECTION_HEADER           Header;
     ERROR_PLATFORM_SPECIFIC_VALID  Valid;
     ERROR_STATUS                   ErrorStatus; // Platform Generic Error Status
     ULONGLONG                      RequestorId; // Bus Requestor ID at the time of the event
     ULONGLONG                      ResponderId; // Bus Responder ID at the time of the event
     ULONGLONG                      TargetId;    // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA        BusSpecificData; // OEM specific Bus dependent data
     UCHAR                          OemId[16];       // OEM specific data for bus identification
     ERROR_OEM_DATA                 OemData;         // OEM specific data 
#if 0
     UCHAR                          OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_SPECIFIC, *PERROR_PLATFORM_SPECIFIC;

//
// IA64 ERRORS: Platform Bus error device definitions
//

#define ERROR_PLATFORM_BUS_GUID \
    { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_BUS_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_BUS_VALID, *PERROR_PLATFORM_BUS_VALID;

typedef struct _ERROR_PLATFORM_BUS {
     ERROR_SECTION_HEADER        Header;
     ERROR_PLATFORM_BUS_VALID    Valid;
     ERROR_STATUS                ErrorStatus;       // Bus Error Status
     ULONGLONG                   RequestorId;       // Bus Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Bus Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_BUS, *PERROR_PLATFORM_BUS;

//
// IA64 ERRORS: Platform Host Controller error device definitions
//

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID \
    { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}
    

typedef union _ERROR_PLATFORM_HOST_CONTROLLER_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_HOST_CONTROLLER_VALID, *PERROR_PLATFORM_HOST_CONTROLLER_VALID;

typedef struct _ERROR_PLATFORM_HOST_CONTROLLER {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;       // Host Controller Error Status
     ULONGLONG                   RequestorId;       // Host controller Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Host controller Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Host controller intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
} ERROR_PLATFORM_HOST_CONTROLLER, *PERROR_PLATFORM_HOST_CONTROLLER;

//
// IA64 ERROR_LOGRECORDS definitions
//
//  MCA_EXCEPTION,
//  CMC_EXCEPTION,
//  CPE_EXCEPTION.
//

// For compatibility with previous versions of the definitions:
typedef ERROR_RECORD_HEADER ERROR_LOGRECORD, *PERROR_LOGRECORD;

typedef ERROR_RECORD_HEADER MCA_EXCEPTION, *PMCA_EXCEPTION;    // Machine Check Abort
typedef ERROR_RECORD_HEADER CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef ERROR_RECORD_HEADER CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#endif // _IA64_

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#endif // _MCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\miglib.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    miglib.h

Abstract:

    Declares the interfaces for miglib.lib, a library of Win9x
    migration functions.

Author:

    Jim Schmidt (jimschm) 08-Feb-1999

Revision History:

    <alias> <date> <comments>

--*/

//
// Constants (needed by outside projects)
//

#ifndef HASHTABLE

#define HASHTABLE   PVOID

#endif

//
// General
//

VOID
InitializeMigLib (
    VOID
    );

VOID
TerminateMigLib (
    VOID
    );

//
// hwcomp.dat interface
//

DWORD
OpenHwCompDatA (
    IN      PCSTR HwCompDatPath
    );

DWORD
LoadHwCompDat (
    IN      DWORD HwCompDatId
    );

DWORD
GetHwCompDatChecksum (
    IN      DWORD HwCompDatId
    );

VOID
DumpHwCompDatA (
    IN      PCSTR HwCompDatPath,
    IN      BOOL IncludeInfName
    );

DWORD
OpenAndLoadHwCompDatA (
    IN      PCSTR HwCompDatPath
    );

DWORD
OpenAndLoadHwCompDatExA (
    IN      PCSTR HwCompDatPath,
    IN      HASHTABLE PnpIdTable,           OPTIONAL
    IN      HASHTABLE UnSupPnpIdTable,      OPTIONAL
    IN      HASHTABLE InfFileTable          OPTIONAL
    );

VOID
SetWorkingTables (
    IN      DWORD HwCompDatId,
    IN      HASHTABLE PnpIdTable,
    IN      HASHTABLE UnSupPnpIdTable,
    IN      HASHTABLE InfFileTable
    );

VOID
TakeHwCompHashTables (
    IN      DWORD HwCompDatId,
    OUT     HASHTABLE *PnpIdTable,
    OUT     HASHTABLE *UnsupportedPnpIdTable,
    OUT     HASHTABLE *InfFileTable
    );

VOID
CloseHwCompDat (
    IN      DWORD HwCompDatId
    );

BOOL
IsPnpIdSupportedByNtA (
    IN      DWORD HwCompDatId,
    IN      PCSTR PnpId
    );

BOOL
IsPnpIdUnsupportedByNtA (
    IN      DWORD HwCompDatId,
    IN      PCSTR PnpId
    );

//
// A & W macros -- note, no W versions here
//

#ifndef UNICODE

#define OpenHwCompDat               OpenHwCompDatA
#define DumpHwCompDat               DumpHwCompDatA
#define OpenAndLoadHwCompDat        OpenAndLoadHwCompDatA
#define OpenAndLoadHwCompDatEx      OpenAndLoadHwCompDatExA
#define IsPnpIdSupportedByNt        IsPnpIdSupportedByNtA
#define IsPnpIdUnsupportedByNt      IsPnpIdUnsupportedByNtA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\hdlsblk.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    hdlsblk.h

Abstract:

    This module contains the public header information (function prototypes,
    data and type declarations) for the Headless Loader Block information.

Author:

    Sean Selitrennikoff (v-seans) Oct, 1999

Revision History:

--*/

#ifndef _HDLSBLK_
#define _HDLSBLK_

//
// Block for passing headless parameters from the loader to the kernel.
//

typedef struct _HEADLESS_LOADER_BLOCK {

    //
    // Where did the COM parameters come from.
    //
    BOOLEAN UsedBiosSettings;

    //
    // COM parameters.
    //
    UCHAR   DataBits;
    UCHAR   StopBits;
    BOOLEAN Parity;
    ULONG   BaudRate;
    ULONG   PortNumber;
    PUCHAR  PortAddress;

    //
    // PCI device settings.
    //
    USHORT  PciDeviceId;
    USHORT  PciVendorId;
    UCHAR   PciBusNumber;
    UCHAR   PciSlotNumber;
    UCHAR   PciFunctionNumber;
    ULONG   PciFlags;

    GUID    SystemGUID;                 // Machine's GUID.

    BOOLEAN IsMMIODevice;               // Is the UART in SYSIO or MMIO space

    //
    UCHAR   TerminalType;               // What kind of terminal do we think
                                        // we're talking to?
                                        // 0 = VT100
                                        // 1 = VT100+
                                        // 2 = VT-UTF8
                                        // 3 = PC ANSI
                                        // 4-255 = reserved

} HEADLESS_LOADER_BLOCK, *PHEADLESS_LOADER_BLOCK;

#endif // _HDLSBLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\kdextsfn.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    kdextsfn.h

Abstract:
    This has definitions for info exported by kdexts.dll.

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 2/14/2001

--*/

#ifndef _KDEXTSFN_H
#define _KDEXTSFN_H

//
// device.c
//
typedef struct _DEBUG_DEVICE_OBJECT_INFO {
    ULONG      SizeOfStruct; // must be == sizeof(DEBUG_DEVICE_OBJECT_INFO)
    ULONG64    DevObjAddress;
    ULONG      ReferenceCount;
    BOOL       QBusy;
    ULONG64    DriverObject;
    ULONG64    CurrentIrp;
    ULONG64    DevExtension;
    ULONG64    DevObjExtension;
} DEBUG_DEVICE_OBJECT_INFO, *PDEBUG_DEVICE_OBJECT_INFO;


// GetDevObjInfo
typedef HRESULT
(WINAPI *PGET_DEVICE_OBJECT_INFO)(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 DeviceObject,
    OUT PDEBUG_DEVICE_OBJECT_INFO pDevObjInfo);


//
// driver.c
//
typedef struct _DEBUG_DRIVER_OBJECT_INFO {
    ULONG     SizeOfStruct; // must be == sizef(DEBUG_DRIVER_OBJECT_INFO)
    ULONG     DriverSize;
    ULONG64   DriverObjAddress;
    ULONG64   DriverStart;
    ULONG64   DriverExtension;
    ULONG64   DeviceObject;
    UNICODE_STRING64 DriverName;
} DEBUG_DRIVER_OBJECT_INFO, *PDEBUG_DRIVER_OBJECT_INFO;

// GetDrvObjInfo
typedef HRESULT
(WINAPI *PGET_DRIVER_OBJECT_INFO)(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 DriverObject,
    OUT PDEBUG_DRIVER_OBJECT_INFO pDrvObjInfo);

//
// irp.c
//
typedef struct _DEBUG_IRP_STACK_INFO {
    UCHAR     Major;
    UCHAR     Minor;
    ULONG64   DeviceObject;
    ULONG64   FileObject;
    ULONG64   CompletionRoutine;
    ULONG64   StackAddress;
} DEBUG_IRP_STACK_INFO, *PDEBUG_IRP_STACK_INFO;

typedef struct _DEBUG_IRP_INFO {
    ULONG     SizeOfStruct;  // Must be == sizeof(DEBUG_IRP_INFO)
    ULONG64   IrpAddress;
    ULONG     StackCount;
    ULONG     CurrentLocation;
    ULONG64   MdlAddress;
    ULONG64   Thread;
    ULONG64   CancelRoutine;
    DEBUG_IRP_STACK_INFO CurrentStack;
} DEBUG_IRP_INFO, *PDEBUG_IRP_INFO;

// GetIrpInfo
typedef HRESULT
(WINAPI * PGET_IRP_INFO)(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 Irp,
    OUT PDEBUG_IRP_INFO IrpInfo
    );



//
// pool.c
//
typedef struct _DEBUG_POOL_DATA {
    ULONG   SizeofStruct;
    ULONG64 PoolBlock;
    ULONG64 Pool;
    ULONG   PreviousSize;
    ULONG   Size;
    ULONG   PoolTag;
    ULONG64 ProcessBilled;
    ULONG   Free:1;
    ULONG   LargePool:1;
    ULONG   SpecialPool:1;
    ULONG   Pageable:1;
    ULONG   Protected:1;
    ULONG   Allocated:1;
    ULONG   Reserved:26;
    ULONG64 Reserved2[4];
    CHAR    PoolTagDescription[64];
} DEBUG_POOL_DATA, *PDEBUG_POOL_DATA;


// GetPoolData
typedef HRESULT
(WINAPI *PGET_POOL_DATA)(
    PDEBUG_CLIENT Client,
    ULONG64 Pool,
    PDEBUG_POOL_DATA PoolData
    );

typedef enum _DEBUG_POOL_REGION {
    DbgPoolRegionUnknown,
    DbgPoolRegionSpecial,
    DbgPoolRegionPaged,
    DbgPoolRegionNonPaged,
    DbgPoolRegionCode,
    DbgPoolRegionNonPagedExpansion,
    DbgPoolRegionMax,
} DEBUG_POOL_REGION;

// GetPoolRegion
typedef HRESULT
(WINAPI  *PGET_POOL_REGION)(
     PDEBUG_CLIENT Client,
     ULONG64 Pool,
     DEBUG_POOL_REGION *PoolRegion
     );

#endif // _KDEXTSFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\nesy.h ===
#ifndef _NESSY_INC
#define _NESSY_INC


#ifdef  __cplusplus
extern "C" {
#endif
    
    // A nesy database consists of an index file named nesy.x and a data file called nesy.bin.
    // The index file is composed of 3 DWORD records that tell the id of the blob, where the
    // blob starts in the nesy.bin file and how large the blob is in bytes. The index file is
    // simply read into memory and searched sequentially for the requested record. Normal
    // blobs in a nesy database begin with id 1000. The numbers below 1000 are reserved for
    // special uses. For application compatibility the blob who's id is 0 is special. This blob
    // is used to store the structure that is read by the loader to hook and executible. The
    // format of Blob0 at a high level is like this:
    //
    // Blob0
    // {
    //    A list of modules (mainly system DLLs) that should be excluded from shimming
    //    A list of shim DLL's that shim API's
    //    for each DLL {
    //        A list of modules or specific calls to exclude from shimming (added to the global list)
    //        A list of modules or specific calls to include for shimming (contrary to the global list)
    //    }
    //    A list of in memory patch modules
    //    A list of exes that have patches
    //    for each exe {
    //        A list of matching files 
    //        An array of patches to apply 
    //        A list of DLLs to apply 
    //        for each DLL {
    //            A list of modules or specific calls to exclude from shimming (added to the DLL list and global list)
    //            A list of modules or specific calls to include for shimming (contrary to the global and/or DLL list)
    //        }
    //    }
    // }
    //
    // This is another way of looking at blob0
    //
    // At a high level Blob0 is structured like this:
    //
    //   [BLOB0]
    //    | |
    //    | [GLOBAL EXCLUDE 1] -> [GLOBAL EXCLUDE 2] -> NULL
    //    |
    //   [SHIM DLL1] -> [SHIM DLL2] -> NULL
    //    | |            |
    //    | |            [same as SHIM DLL 1]
    //    | |
    //    | [INCLUDE 1] -> [INCLUDE 2] -> NULL
    //    |
    //   [PATCH NAME1] -> [PATCH NAME2] -> [PATCH NAME3] -> NULL
    //    |
    //   [EXE 1] -> [EXE 2] -> NULL
    //    | | |        |
    //    | | |        [same as EXE 1]
    //    | | |
    //    | | [DLL REF 1] -> [DLL REF 2] -> NULL
    //    | |   |              |
    //    | |   |              [same as DLL REF 1]
    //    | |   |
    //    | |   [INCLUDE 1] -> [INCLUDE 2] -> NULL
    //    | |
    //    | [ARRAY OF PATCH REFS (blob IDs)]
    //    |
    //   [MATCHING INFO 1] -> [MATCHING INFO 2] -> NULL
    //
    // PEXELIST is an exe name list
    // PMATCHINGINFO is a matching list there is one matching list for an exe
    // PDLLNAMELIST is a shim dll list
    // PPATCHNAMELIST is an in memory patch name list
    
#define NESY_VERSION    11
#define NESY_MAGIC      0x7973656E // 'nesy' (reversed because of little-endian ordering)
    
#define BLOB_APPNAME_CATALOG    0      // Special Blob list of apps that have blobs in the data base
    
#define BLOB_SPECIAL_LOWEST     0      // Special reserved blob id First one
#define BLOB_SPECIAL_LAST       1000   // Special reserved blob id last one
    
    //
    // blobs 1001 and up are for user patches and other binary data.
    //
    
#pragma pack(1)
    
    typedef enum _INCTYPE {
        INCLUDE = 0,
            EXCLUDE
    } INCTYPE;
    
    typedef struct _INDEXRECORD
    {
        DWORD dwID;         // id for this index record.
        DWORD dwDataFileBlobOffset; // offset in data file where the data is stored.
        DWORD dwDataFileBlobLength; // length of the data in the data file.
    } INDEXRECORD, *PINDEXRECORD;
    
    typedef struct _INDEXFILEHEADER
    {
        DWORD   dwVersion;         // version of index file
        DWORD   dwMagic;
        DWORD   dwlastIndexUsed; // next index record
        DWORD   dwTotalRecords;  // total records in index file
        DWORD   dwLastID;        // last id used
    } INDEXFILEHEADER, *PINDEXFILEHEADER;
    
    
    typedef struct _INDEXFILE
    {
        INDEXFILEHEADER hdr;            // index file header
#pragma warning( disable : 4200 )
        INDEXRECORD     indexRecords[]; // one or more index records
#pragma warning( default : 4200 )
    } INDEXFILE, *PINDEXFILE;
    
    // The following definations are for blob 0 which lists the DLL's and Applications and Exes
    // that are hooked and patches by the shim.
    
    // this is a definition for an inclusion list, which is also used for exclusion lists as well
    //
    // NOTE: contains two variable-length strings; the second can be accessed as follows:
    //
    // TCHAR *szLocalAPI = NULL;
    // /* we assume INCLUDELIST *pIncludes;, and that it is valid */
    // 
    // if (pIncludes->dwOffsetToAPI) {
    //     szLocalAPI = (PBYTE)pIncludes + dwOffsetToAPI;
    // }
    //
    
    typedef struct _INCLUDELIST
    {
        DWORD	dwNext;         // offset of next inclusion or 0 if this is the last
        INCTYPE eType;          // whether this is an include or exclude
        DWORD	dwModuleOffset; // the offset within the calling module of the call that should be included/excluded
        DWORD   dwOffsetToAPI;  // offset from struct begin to the string that tells what the API is, or 0 if there is none specified
#pragma warning( disable : 4200 )
        TCHAR   szModule[]; // text description for this patch blob
#pragma warning( default : 4200 )
        // TCHAR szAPI []        // this is to let folks know that there is potentially another string -- see code above
    } INCLUDELIST, *PINCLUDELIST;
    
    
    // The following definations are for blob 0 which lists the DLL's and Applications and Exes
    // that are hooked and patches by the shim.
    
    typedef struct _DLLNAMELIST
    {
        DWORD   dwNext;       // offset of next DLL file in list or 0 if this is the last file in the list.
        DWORD   dwBlobID;     // id of blob image associated with this dll
        
        DWORD           dwIncludeOffset;    // offset of inclusion list 
        PINCLUDELIST    pIncludeList;       // pointer to inclusion list
        
#pragma warning( disable : 4200 )
        TCHAR   szFileName[]; // file name for this blob
#pragma warning( default : 4200 )
        
    } DLLNAMELIST, *PDLLNAMELIST;
    
    PDLLNAMELIST NextDllName(PDLLNAMELIST pCurrent);
    
    // The following definations are for blob 0 which lists the DLL's and Applications and Exes
    // that are hooked and patches by the shim.
    
    typedef struct _PATCHNAMELIST
    {
        DWORD   dwNext;       // offset of next DLL file in list or 0 if this is the last file in the list.
        DWORD   dwBlobID;     // id of blob image associated with this patch
#pragma warning( disable : 4200 )
        TCHAR   szDescription[]; // text description for this patch blob
#pragma warning( default : 4200 )
    } PATCHNAMELIST, *PPATCHNAMELIST;
    
    // The following definations are for blob 0 which lists the DLL's and Applications and Exes
    // that are hooked and patches by the shim.
    
    typedef struct _MATCHINGINFO
    {
        DWORD       dwNext;     // next matching structure in list.
        DWORD       dwSize;     // size of binary image, 0 if size is not to be used as a matching criteria
        DWORD       dwCrc;      // crc of binary image, 0 if crc is not to be used.
        FILETIME    ft;         // date time file was created, 0 if time is not to be used.
#pragma warning( disable : 4200 )
        TCHAR       szFileName[];     // relative path file name of file to match against. This path is
        // relative to the EXE file above this one.
#pragma warning( default : 4200 )
    } MATCHINGINFO, *PMATCHINGINFO;
    
    typedef struct _DLLREFLIST
    {
        DWORD           dwNext;
        DWORD           dwBlobID;
        
        DWORD           dwIncludeOffset;    // offset of inclusion list
        PINCLUDELIST    pIncludeList;       // pointer to inclusion list
    } DLLREFLIST, *PDLLREFLIST;
    
    typedef struct _EXELIST
    {
        DWORD           dwNext;             // next exe in list
        DWORD           dwExeID;            // id unique to this exe
        LARGE_INTEGER   qwFlags;            // the kernel flags
        
        PDWORD          pdwBlobPatchID;     // pointer to blob id array
        DWORD           dwBlobPatchOffset;  // offset of blob array
        DWORD           dwTotalPatchBlobs;  // total hook DLL's for this exe
        
        DWORD           dwMatchInfoOffset;  // offset of match info
        PMATCHINGINFO   pMatchInfo;         // pointer to matching info list
        
        DWORD           dwDllListOffset;    // offset to DLL list for this EXE
        PDLLREFLIST     pDllList;           // pointer to DLL list for this EXE
        
#pragma warning( disable : 4200 )
        TCHAR       szFileName[];     // file name that we are hooking with the shim dlls or patching with a patch.
#pragma warning( default : 4200 )
    } EXELIST, *PEXELIST;
    
    typedef struct _BLOB0
    {
        DWORD           dwVersion;          // version of format
        DWORD           dwMagic;            // more verification of format
        DWORD           dwBlobSize;         // size of blob
        DWORD           dwDllNameOffset;    // offset in bytes where the dll list begins.
        DWORD           dwPatchNameOffset;  // offset in bytes where the patch list begins.
        DWORD           dwExeGroupOffset;   // offset in bytes where the Application group list begins.
        DWORD           dwIncludeOffset;    // offset in bytes where the global include list begins
        PDLLNAMELIST    pDllNameList;       // pointer to shim dll info
        PPATCHNAMELIST  pPatchNameList;     // pointer to patch blob info
        PEXELIST        pExeList;           // pointer to application blob info list
        PINCLUDELIST    pIncludeList;       // pointer to global include list (which generally only has excludes)
    } BLOB0, *PBLOB0;
    
#pragma pack()
    
    // at init time, call InitializeDatabase to init the DBs global variables
    //
    // then before querying any information, call GetBlob0, and pass the returned pointer
    // into any query functions.
    //
    // When done with the DB, call FreeBlob0, followed by RestoreDatabase
    BOOL InitializeDatabase(LPSTR szPath);
    
    PBLOB0 GetBlob0(void);
    
    void FreeBlob0(PBLOB0 pBlob0);
    
    void RestoreDatabase(void);

    
    PEXELIST GetExe(
        PBLOB0 pBlob0,
        LPSTR szModuleName
        );
    
    DWORD GetExeHookDLLCount(
        PBLOB0 pBlob0,
        PEXELIST pExe
        );
    
    DWORD GetExePatchCount(
        PBLOB0 pBlob0,
        PEXELIST pExe
        );
    
    BOOL GetExeFlags(
        PEXELIST pExe,
        LARGE_INTEGER *pqwFlags    // passed back flags
        );
    
    PBYTE GetHookDLLBlob(
        DWORD dwBlobID
        );
    
    PBYTE GetPatchBlob(
        DWORD dwBlobID
        );
    
    //
    // helpful iterators for moving around in Blob0
    //
    PEXELIST NextExe(PEXELIST pCurrent);
    
    PMATCHINGINFO NextMatchInfo(PMATCHINGINFO pCurrent);
    
    PINCLUDELIST NextInclude(PINCLUDELIST pCurrent);
    
    TCHAR *szGetAPIPtr(PINCLUDELIST pInclude); // get the API string out of the structure
    
    PPATCHNAMELIST NextPatchName(PPATCHNAMELIST pCurrent);
    
    PDLLNAMELIST NextDllName(PDLLNAMELIST pCurrent);
    
    PDLLREFLIST NextDllRef(PDLLREFLIST pCurrent);
    
#ifdef  __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\machinep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    machinep.h

Abstract:

    This is the include file that defines detect of machine type.

     This file is only included from following files

     + \machine\*.c
     + \utils\ulib\machine.cxx

     And same definition is in

     + \public\sdk\inc\machine.h
     + \ntos\config\i386.h
     + \ntos\fastfat\fatinit.c
     + \ntos\dd\scsidisk\disk.c

     And this library will be linked with following module.

     + winsrv.dll ( usersrvl.lib )
     + main.cpl
     + display.cpl
     + winfile.exe
     + winlogon.exe
     + msgina.dll

Author:

Revision History:

--*/

#ifndef _MACHINEP_ID_
#define _MACHINEP_ID_

#if defined(_X86_)

//
// Registry Key
//

//
// UNICODE
//

#define REGISTRY_HARDWARE_DESCRIPTION_W \
        L"\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_W      \
        L"Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_W   \
        L"Identifier"

#define FUJITSU_FMR_NAME_W    L"FUJITSU FMR-"
#define NEC_PC98_NAME_W       L"NEC PC-98"

//
// ANSI
//

#define REGISTRY_HARDWARE_DESCRIPTION_A \
        "\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_A      \
        "Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_A   \
        "Identifier"

#define FUJITSU_FMR_NAME_A    "FUJITSU FMR-"
#define NEC_PC98_NAME_A       "NEC PC-98"

//
// Automatic
//

#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_HARDWARE_SYSTEM      \
        TEXT("Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")

//
// These definition are only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

#endif // defined(i386)
#endif // _MACHINE_ID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntddvdm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    ntddvdm.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the NTVDM kernel mode virtual devices.

Author:

    William Hsieh (williamh) 31-May-1996

Revision History:

--*/

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
#define IOCTL_VDM_BASE		FILE_DEVICE_VDM

//
// 32 VDDs. Each VDD has possible 127 private ioctl code
// These values are based on the fact that there are 12 bits reserved
// for function id in each IOCTL code.
//
#define IOCTL_VDM_GROUP_MASK	0xF80
#define IOCTL_VDM_GROUP_SIZE	127

#define IOCTL_VDM_PARALLEL_GROUP    0

#define IOCTL_VDM_PARALLEL_BASE IOCTL_VDM_BASE + IOCTL_VDM_PARALLEL_GROUP * IOCTL_VDM_GROUP_SIZE
#define IOCTL_VDM_PAR_WRITE_DATA_PORT	CTL_CODE(IOCTL_VDM_PARALLEL_BASE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VDM_PAR_WRITE_CONTROL_PORT CTL_CODE(IOCTL_VDM_PARALLEL_BASE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VDM_PAR_READ_STATUS_PORT CTL_CODE(IOCTL_VDM_PARALLEL_BASE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntperf.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntperf.h

Abstract:

    This module contains the performance event logging definitions.

Author:

    Stephen Hsiao (shsiao) 30-March-2000

Revision History:

--*/

#ifndef _NTPERF_
#define _NTPERF_

#include <wmistr.h>
#include <ntwmi.h>

#define PERF_ASSERT(x) ASSERT(x)
#define PERFINFO_ASSERT_PACKET_OVERFLOW(Size) ASSERT ((Size) <= MAXUSHORT)

//
// See ntwmi.w for the definition of Enable flags, hook id's, etc. 
//
#define PERF_MASK_INDEX         (0xe0000000)
#define PERF_MASK_GROUP         (~PERF_MASK_INDEX)

#define PERF_NUM_MASKS       8
typedef ULONG PERFINFO_MASK;

//
// This structure holds a group mask for all the PERF_NUM_MASKS sets
// (see PERF_MASK_INDEX above).
//
// CombinedMasks is the bitwise inclusive OR of all the masks; it is
// used to quickly check if any group is turned on.
//

//
// ISSUE-2000/03/30-shsiao, Remove the CombinedMasks before release.
//
typedef struct _PERFINFO_GROUPMASK {
    ULONG Masks[PERF_NUM_MASKS];
    ULONG CombinedMasks;
} PERFINFO_GROUPMASK, *PPERFINFO_GROUPMASK;

#define PERF_GET_MASK_INDEX(GM) (((GM) & PERF_MASK_INDEX) >> 29)
#define PERF_GET_MASK_GROUP(GM) ((GM) & PERF_MASK_GROUP)

#define PERFINFO_CLEAR_GROUPMASK(pGroupMask) \
    RtlZeroMemory((pGroupMask), sizeof(PERFINFO_GROUPMASK))

#define PERFINFO_OR_GROUP_WITH_GROUPMASK(Group, pGroupMask) \
    (pGroupMask)->Masks[PERF_GET_MASK_INDEX(Group)] |= PERF_GET_MASK_GROUP(Group); \
    (pGroupMask)->CombinedMasks |= PERF_GET_MASK_GROUP(Group);

//
// Determines whether any group is on in a group mask
//
#define PerfIsAnyGroupOnInGroupMask(pGroupMask) \
    ((pGroupMask)->CombinedMasks != 0)

//
// Determines whether a group is on in its set in a group mask
//
#define PerfIsGroupOnInGroupMask(Group,pGroupMask) \
    (((pGroupMask) != NULL) && (((pGroupMask)->Masks[PERF_GET_MASK_INDEX((Group))] & PERF_GET_MASK_GROUP((Group))) != 0))

typedef struct _PERFINFO_HOOK_HANDLE {
    PPERFINFO_TRACE_HEADER PerfTraceHeader;
    PWMI_BUFFER_HEADER WmiBufferHeader;
} PERFINFO_HOOK_HANDLE, *PPERFINFO_HOOK_HANDLE;

#define PERFINFO_HOOK_HANDLE_TO_DATA(_HookHandle, _Type) \
    ((_Type) (&((_HookHandle).PerfTraceHeader)->Data[0]))

#define PERFINFO_APPLY_OFFSET_GIVING_TYPE(_Base, _Offset, _Type) \
     ((_Type) (((PPERF_BYTE) (_Base)) + (_Offset)))

#define PERFINFO_ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

//
// Data structures of events
//
typedef unsigned char PERF_BYTE, *PPERF_BYTE;

#define PERFINFO_THREAD_SWAPABLE      0
#define PERFINFO_THREAD_NONSWAPABLE   1
typedef struct _PERFINFO_THREAD_INFORMATION {
    PVOID StackBase;
    PVOID StackLimit;
    PVOID UserStackBase;
    PVOID UserStackLimit;
    PVOID StartAddr;
    PVOID Win32StartAddr;
    ULONG ProcessId;
    ULONG ThreadId;
    char  WaitMode;
} PERFINFO_THREAD_INFORMATION, *PPERFINFO_THREAD_INFORMATION;

typedef struct _PERFINFO_DRIVER_MAJORFUNCTION {
    ULONG UniqMatchId;
    PVOID RoutineAddr;
    PVOID Irp;
    ULONG MajorFunction;
    ULONG MinorFunction;
    PVOID FileNamePointer;
} PERFINFO_DRIVER_MAJORFUNCTION, *PPERFINFO_DRIVER_MAJORFUNCTION;

typedef struct _PERFINFO_DRIVER_MAJORFUNCTION_RET {
    ULONG UniqMatchId;
    PVOID Irp;
} PERFINFO_DRIVER_MAJORFUNCTION_RET, *PPERFINFO_DRIVER_MAJORFUNCTION_RET;


typedef struct _PERFINFO_DRIVER_COMPLETE_REQUEST {
    //
    // Driver major function routine address for the "current" stack location 
    // on the IRP when it was completed. It is used to identify which driver 
    // was processing the IRP when the IRP got completed.
    //

    PVOID RoutineAddr;

    //
    // Irp field and UniqMatchId is used to match COMPLETE_REQUEST 
    // and COMPLETE_REQUEST_RET logged for an IRP completion.
    //

    PVOID Irp;
    ULONG UniqMatchId;
    
} PERFINFO_DRIVER_COMPLETE_REQUEST, *PPERFINFO_DRIVER_COMPLETE_REQUEST;

typedef struct _PERFINFO_DRIVER_COMPLETE_REQUEST_RET {

    //
    // Irp field and UniqMatchId is used to match COMPLETE_REQUEST 
    // and COMPLETE_REQUEST_RET logged for an IRP completion.
    //

    PVOID Irp;
    ULONG UniqMatchId;
} PERFINFO_DRIVER_COMPLETE_REQUEST_RET, *PPERFINFO_DRIVER_COMPLETE_REQUEST_RET;

//
// This structure is logged when PopSetPowerAction is called to start
// propagating a new power action (e.g. standby/hibernate/shutdown)
//

typedef struct _PERFINFO_SET_POWER_ACTION {

    //
    // This field is used to match SET_POWER_ACTION_RET entry.
    //

    PVOID Trigger;
    
    ULONG PowerAction;
    ULONG LightestState;
} PERFINFO_SET_POWER_ACTION, *PPERFINFO_SET_POWER_ACTION;

//
// This structure is logged when PopSetPowerAction completes.
//

typedef struct _PERFINFO_SET_POWER_ACTION_RET {
    PVOID Trigger;
    NTSTATUS Status;
} PERFINFO_SET_POWER_ACTION_RET, *PPERFINFO_SET_POWER_ACTION_RET;


//
// This structure is logged when PopSetDevicesSystemState is called to 
// propagate a system state to all devices.
//

typedef struct _PERFINFO_SET_DEVICES_STATE {
    ULONG SystemState;
    BOOLEAN Waking;
    BOOLEAN Shutdown;
    UCHAR IrpMinor;
} PERFINFO_SET_DEVICES_STATE, *PPERFINFO_SET_DEVICES_STATE;

//
// This structure is logged when PopSetDevicesSystemState is done.
//

typedef struct _PERFINFO_SET_DEVICES_STATE_RET {
    NTSTATUS Status;
} PERFINFO_SET_DEVICES_STATE_RET, *PPERFINFO_SET_DEVICES_STATE_RET;

//
// This structure is logged when PopNotifyDevice calls into a driver
// to set the power state of a device.
//

typedef struct _PERFINFO_PO_NOTIFY_DEVICE {

    //
    // This field is used to match notification and completion log
    // entries for a device.
    //

    PVOID Irp;

    //
    // Base address of the driver that owns this device.
    //

    PVOID DriverStart;

    //
    // Device node properties.
    //

    UCHAR OrderLevel;

    //
    // Major and minor IRP codes for the request made to the driver.
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    // Type of power irp
    //
    POWER_STATE_TYPE Type;
    POWER_STATE      State;

    //
    // Length of the device name in characters excluding terminating NUL,
    // and the device name itself. Depending on how much fits into our
    // stack buffer, this is the *last* part of the device name.
    //

    ULONG DeviceNameLength;
    WCHAR DeviceName[1];
   
} PERFINFO_PO_NOTIFY_DEVICE, *PPERFINFO_PO_NOTIFY_DEVICE;

//
// This structure is logged when a PopNotifyDevice processing for a
// particular device completes.
//

typedef struct _PERFINFO_PO_NOTIFY_DEVICE_COMPLETE {

    //
    // This field is used to match notification and completion log
    // entries for a device.
    //

    PVOID Irp;

    //
    // Status with which the notify power IRP was completed.
    //

    NTSTATUS Status;

} PERFINFO_PO_NOTIFY_DEVICE_COMPLETE, *PPERFINFO_PO_NOTIFY_DEVICE_COMPLETE;

//
// This structure is logged around every win32 state callout
//
typedef struct _PERFINFO_PO_SESSION_CALLOUT {
    POWER_ACTION SystemAction;
    SYSTEM_POWER_STATE MinSystemState;
    ULONG Flags;
    ULONG PowerStateTask;
} PERFINFO_PO_SESSION_CALLOUT, *PPERFINFO_PO_SESSION_CALLOUT;

typedef struct _PERFINFO_PO_PRESLEEP {
    LARGE_INTEGER PerformanceCounter;
    LARGE_INTEGER PerformanceFrequency;
} PERFINFO_PO_PRESLEEP, *PPERFINFO_PO_PRESLEEP;

typedef struct _PERFINFO_PO_POSTSLEEP {
    LARGE_INTEGER PerformanceCounter;
} PERFINFO_PO_POSTSLEEP, *PPERFINFO_PO_POSTSLEEP;

typedef struct _PERFINFO_BOOT_PHASE_START {
    LONG Phase;
} PERFINFO_BOOT_PHASE_START, *PPERFINFO_BOOT_PHASE_START;

typedef struct _PERFINFO_BOOT_PREFETCH_INFORMATION {
    LONG Action;
    NTSTATUS Status;
    LONG Pages;
} PERFINFO_BOOT_PREFETCH_INFORMATION, *PPERFINFO_BOOT_PREFETCH_INFORMATION;

typedef struct _PERFINFO_PO_SESSION_CALLOUT_RET {
  NTSTATUS Status;
} PERFINFO_PO_SESSION_CALLOUT_RET, *PPERFINFO_PO_SESSION_CALLOUT_RET;

typedef struct _PERFINFO_FILENAME_INFORMATION {
    PVOID HashKeyFileNamePointer;
    WCHAR FileName[1];
} PERFINFO_FILENAME_INFORMATION, *PPERFINFO_FILENAME_INFORMATION;

typedef struct _PERFINFO_SAMPLED_PROFILE_INFORMATION {
    PVOID InstructionPointer;
    ULONG ThreadId;
    ULONG Count;
} PERFINFO_SAMPLED_PROFILE_INFORMATION, *PPERFINFO_SAMPLED_PROFILE_INFORMATION;

#define  PERFINFO_SAMPLED_PROFILE_CACHE_MAX 20
typedef struct _PERFINFO_SAMPLED_PROFILE_CACHE {
    ULONG Entries;
    PERFINFO_SAMPLED_PROFILE_INFORMATION Sample[PERFINFO_SAMPLED_PROFILE_CACHE_MAX];
} PERFINFO_SAMPLED_PROFILE_CACHE, *PPERFINFO_SAMPLED_PROFILE_CACHE;

typedef struct _PERFINFO_DPC_INFORMATION {
    ULONGLONG InitialTime;
    PVOID DpcRoutine;
} PERFINFO_DPC_INFORMATION, *PPERFINFO_DPC_INFORMATION;

typedef struct _PERFINFO_INTERRUPT_INFORMATION {
    ULONGLONG InitialTime;
    PVOID ServiceRoutine;
    ULONG ReturnValue;
} PERFINFO_INTERRUPT_INFORMATION, *PPERFINFO_INTERRUPT_INFORMATION;

typedef struct _PERFINFO_PFN_INFORMATION {
    ULONG_PTR PageFrameIndex;
} PERFINFO_PFN_INFORMATION, *PPERFINFO_PFN_INFORMATION;

typedef struct _PERFINFO_SWAPPROCESS_INFORMATION {
    ULONG_PTR PageDirectoryBase;
    ULONG ProcessId;
} PERFINFO_SWAPPROCESS_INFORMATION, *PPERFINFO_SWAPPROCESS_INFORMATION;

typedef struct _PERFINFO_HARDPAGEFAULT_INFORMATION {
    LARGE_INTEGER ReadOffset;
    LARGE_INTEGER IoTime;
    PVOID VirtualAddress;
    PVOID FileObject;
    ULONG ThreadId;
    ULONG ByteCount;
} PERFINFO_HARDPAGEFAULT_INFORMATION, *PPERFINFO_HARDPAGEFAULT_INFORMATION;

typedef struct _PERFINFO_TRIMPROCESS_INFORMATION {
    ULONG ProcessId;
    ULONG ProcessWorkingSet;
    ULONG ProcessPageFaultCount;
    ULONG ProcessLastPageFaultCount;
    ULONG ActualTrim;
} PERFINFO_TRIMPROCESS_INFORMATION, *PPERFINFO_TRIMPROCESS_INFORMATION;

typedef struct _PERFINFO_WS_INFORMATION {
    ULONG ProcessId;
    ULONG ProcessWorkingSet;
    ULONG ProcessPageFaultCount;
    ULONG ProcessClaim;
    ULONG ProcessEstimatedAvailable;
    ULONG ProcessEstimatedAccessed;
    ULONG ProcessEstimatedShared;
    ULONG ProcessEstimatedModified;
} PERFINFO_WS_INFORMATION, *PPERFINFO_WS_INFORMATION;

//
// Fault based working set actions.
//

#define PERFINFO_WS_ACTION_RESET_COUNTER            1
#define PERFINFO_WS_ACTION_NOTHING                  2
#define PERFINFO_WS_ACTION_INCREMENT_COUNTER        3
#define PERFINFO_WS_ACTION_WILL_TRIM                4
#define PERFINFO_WS_ACTION_FORCE_TRIMMING_PROCESS   5
#define PERFINFO_WS_ACTION_WAIT_FOR_WRITER          6
#define PERFINFO_WS_ACTION_EXAMINED_ALL_PROCESS     7
#define PERFINFO_WS_ACTION_AMPLE_PAGES_EXIST        8
#define PERFINFO_WS_ACTION_END_WALK_ENTRIES         9

//
// Claim based working set actions.
//

#define PERFINFO_WS_ACTION_ADJUST_CLAIM_PARAMETER  10
#define PERFINFO_WS_ACTION_CLAIMBASED_TRIM         11
#define PERFINFO_WS_ACTION_FORCE_TRIMMING_CLAIM    12
#define PERFINFO_WS_ACTION_GOAL_REACHED            13
#define PERFINFO_WS_ACTION_MAX_PASSES              14
#define PERFINFO_WS_ACTION_WAIT_FOR_WRITER_CLAIM   15

//
// New
//

#define PERFINFO_WS_ACTION_CLAIM_STATE             16
#define PERFINFO_WS_ACTION_FAULT_STATE             17
#define PERFINFO_WS_ACTION_CLAIM_WS                18
#define PERFINFO_WS_ACTION_FAULT_WS                19

typedef struct _PERFINFO_WORKINGSETMANAGER_INFORMATION {
    ULONG Action;
    ULONG_PTR Available;
    ULONG_PTR DesiredFreeGoal;
    ULONG PageFaultCount;
    ULONG ZFODFaultCount;
    union {
        struct {
            ULONG_PTR DesiredReductionGoal;
            ULONG LastPageFaultCount;
            ULONG CheckCounter;
        } Fault;
        struct {
            ULONG_PTR TotalClaim;
            ULONG_PTR TotalEstimatedAvailable;
            ULONG AgeEstimationShift;
            ULONG PlentyFreePages;
            BOOLEAN Replacing;
        } Claim;
    };
} PERFINFO_WORKINGSETMANAGER_INFORMATION, *PPERFINFO_WORKINGSETMANAGER_INFORMATION;

#ifdef NTPERF
/*++
    This code uses the BBTBuffer memory reserved at boot time
    (/PERFMEM=xxx) and removed from MM's memory size
    calculations as a memory buffer for trace event logging.
    If this memory is allocated and not in use by another logger
    such as kernel icecap, then both both WMI and PerfInfo
    trace events will be logged to it.

    The buffer is mapped in to both kernel and usermode as writable
    memory (the reasons this is under ifdef and will not be
    shipped in a retail kernel).

    Layout of Perfinfo trace buffer:


PerfBufHdr()           ----->+------------------------------------+
                             | PERFINFO_TRACEBUF_HEADER structure |
PerfBufHdr() +         ----->+------------------------------------+
 sizeof(                     | Header Zone:                       |
  PERFINFO_TRACEBUF_HEADER)  |    Thread Hash                     |
                             |                                    |
                             |                                    |
PerfStartPtr() ==      ----->+------------------------------------+
  PerfBufHdr() +             | Trace events                       |
 PerfBufHeaderZoneSize       |   . Processes created              |
                             |   . Pages faulted                  |
                             |   . Pages removed                  |
                             |   . Sections created               |
                             |   . Drivers loaded                 |
                             |   . etc. etc...                    |
                             |                                    |
PerfMaxPtr()           ----->+------------------------------------+

    Information neccessary to allocate a trace event and post
    process the log is contained in the header.

    Trace events are WMI trace events.

--*/

typedef enum _PERFORMANCE_INFORMATION_CLASS {
    PerformanceMmInfoInformation,
    PerfICReserved1,
    PerformancePerfInfoStart,
    PerformancePerfInfoStop,
    PerfICReserved2,
    PerformanceMmInfoMarkWithFlush,
    PerformanceMmInfoMark,
    PerformanceMmInfoAsyncMark,
    PerfICReserved3,
    PerfICReserved4,
    PerformanceMmInfoFlush,
    PerformanceMmInfoBigFootOn,
    PerformanceMmInfoBigFootOff,
    PerformanceMmInfoDriverRangeSet,
    PerfICReserved5,
    PerfICReserved6,
    PerformanceMmInfoDriverDelaySet,
    PerformanceShutdownDumpInfo,
    PerformanceMmInfoDriverRangeReset,
    PerfICReserved7,
    PerfICReserved8,
    PerformanceBranchTracingBreakpoints
} PERFORMANCE_INFORMATION_CLASS;

//
// Breakpoint info for instruction tracing
//
#define PERFINFO_MAX_BREAKPOINTS 4
typedef struct _PERFINFO_BREAKPOINT_ADDRESS {
  int nAddresses;
  LONG Action[PERFINFO_MAX_BREAKPOINTS];
  PVOID Addresses[PERFINFO_MAX_BREAKPOINTS];
} PERFINFO_BREAKPOINT_ADDRESS, *PPERFINFO_BREAKPOINT_ADDRESS;

//
// Used for the SetSystemInformation interface
//
typedef struct _PERFINFO_PERFORMANCE_INFORMATION {
    PERFORMANCE_INFORMATION_CLASS PerformanceType;
    union {
        struct {
            PERFINFO_GROUPMASK Flags;
        } StartInfo;
        ULONG           BigFootSize;
        ULONG           TracingOn;
        struct {
            BOOLEAN         DumpOnShutDown;
            BOOLEAN         DumpOnHibernate;
        } ShutdownDumpInfo;
        PERFINFO_BREAKPOINT_ADDRESS BreakPointAddress;
    };
} PERFINFO_PERFORMANCE_INFORMATION, *PPERFINFO_PERFORMANCE_INFORMATION;

//
// This allows us to keep our bearings when our time
// is reset or modified in hibernate or standby etc.
//
typedef struct _PERFINFO_RESUME_CLOCK_REFERENCE {
    PERFINFO_TIMESTAMP TickCount;
    LARGE_INTEGER SystemTime;
} PERFINFO_RESUME_CLOCK_REFERENCE, *PPERFINFO_RESUME_CLOCK_REFERENCE;

//
// For private loggers which need per thread info.
//
#define PERFINFO_INVALID_ID -1
typedef struct _PERFINFO_THREAD_HASH_ENTRY {
    //
    // These fields are used by Modbound
    //
    ULONG Start;
    ULONG End;
    ULONG Count;

    // Used internally by the hash table.  Current thread assigned to this
    // node.
    LONG CurThread;

    //
    // These fields are used for Kernel mode stack dump
    //
    ULONG DumpStackRunning;
    PERFINFO_TIMESTAMP  LastContextSwitchTime;

} PERFINFO_THREAD_HASH_ENTRY, *PPERFINFO_THREAD_HASH_ENTRY;

#define PERFINFO_MAX_LOGGER_NAME_LENGTH 80

#define PERFINFO_MAJOR_VERSION              34
#define PERFINFO_MINOR_VERSION              0

//
// What timing format is used in the trace
//
#define FLAG_SYSTEM_TIME   0x00000001
#define FLAG_PERF_COUNTER  0x00000002
#define FLAG_CYCLE_COUNT   0x00000004

#define FLAG_WMI_TRACE     0x80000000

//
// Define event header type
//
#ifdef _WIN64
#define TRACE_HEADER_TYPE_SYSTEM    TRACE_HEADER_TYPE_SYSTEM64
#define TRACE_HEADER_TYPE_PERFINFO  TRACE_HEADER_TYPE_PERFINFO64

#else

#define TRACE_HEADER_TYPE_SYSTEM    TRACE_HEADER_TYPE_SYSTEM32
#define TRACE_HEADER_TYPE_PERFINFO  TRACE_HEADER_TYPE_PERFINFO32
#endif

//
// Add new fields to the header first by replacing reserved, fields
// and then by adding to the end.
//
typedef struct _PERFINFO_TRACEBUF_HEADER {
    ULONG PagesReserved;
    USHORT usMajorVersion;              // Bump if the header or existing hooks have changed.
    USHORT usMinorVersion;              // Bump if hooks are added.

    BOOLEAN fVersionMismatch;           // Set if a logger has a version mismatch
    char szBadVersionComponentName[PERFINFO_MAX_LOGGER_NAME_LENGTH];
    ULONG PerfBufHeaderZoneSize;        // Size of header zone in bytes
    LONGLONG KePerfFrequency;
    union {                             // Pointers for the beginning, current log
        PPERF_BYTE Ptr;                 // log pointer, and end of the buffer.
        UINT_PTR Offset;                // Ptr is used when logging.
    } Start, Current, Max;              // Offset when post processing a binary file.
    ULONGLONG PerfInitTime;             // Time when buffer inited
    ULONG LoggerCounts;
    PPERF_BYTE pCOWHeader;              // Location of currently active COWHeader.
                                        // NULL if no COWHeader is allocated.
    ULONGLONG CalcPerfFrequency;        // Calculated machine frequency
    ULONGLONG BufferBytesLost;          // in bytes
    ULONGLONG PerfGlobalMaskLastSetTime;
    PPERFINFO_THREAD_HASH_ENTRY ThreadHash; 
                                        // Per-thread logging state info
    ULONG Reserved2;
    ULONG ThreadHashOverflow;           // TRUE if thread table filled during
                                        // the trace.
    LARGE_INTEGER PerfInitSystemTime;   // SystemTime when logging was turned on.
    LARGE_INTEGER Reserved11;
    ULONG Reserved3;
    ULONG Reserved4;
    PVOID MmSystemRangeStart;           // System Address Range Starts here
    ULONG Reserved5;
    ULONG TracePid;                     // Indicates that modbound should only log calls
                                        // within one process (default is 0 for all
                                        // processes).
    ULONG Reserved7;
    ULONG Reserved8;                    // byte count of timestamp
    PERFINFO_TIMESTAMP GetStack_CSwitchDelta;
    PERFINFO_TIMESTAMP GetStack_DrvDelayDelta;  
                                        // Used for driver delay hooks.
    PERFINFO_GROUPMASK GlobalGroupMask;
    ULONGLONG EventPerfFrequency;       // Timestamp quantum for events
    struct _PERFINFO_TRACEBUF_HEADER *SelfPointer; 
                                        // Used to rebase the buffer when post processing
    ULONG Reserved9;
    ULONG BufferFlag;
    PERFINFO_TIMESTAMP LogStopTime;     // Set when logging stopped

    //
    // LastClockRef is set to the last clock reference logged by
    // PerfkLogCurrentSystemTimeAndClock. This is so we can adjust the
    // buffer end timestamp (in case the clock was reset during
    // tracing) without heving to go through the whole buffer.
    //
    PERFINFO_RESUME_CLOCK_REFERENCE LastClockRef;
    ULONG TraceBufferSize;
    PWMI_BUFFER_HEADER UserModePerCpuBuffer[MAXIMUM_PROCESSORS];
                                        //Per CPU Buffer for user mode logging
} PERFINFO_TRACEBUF_HEADER, *PPERFINFO_TRACEBUF_HEADER;

typedef struct _PERFINFO_MARK_INFORMATION {
    char Name[1];
} PERFINFO_MARK_INFORMATION, *PPERFINFO_MARK_INFORMATION;

//
// This means 16K is the size of our thread hash table ... currently this
// takes up about 1/2MB.
//
#define PERFINFO_THREAD_HASH_SIZE 0x4000
#define PERFINFO_THREAD_HASH_MASK 0x3FFF
#define PERFINFO_HEADER_ZONE_SIZE \
        ALIGN_TO_POWER2((sizeof(PERFINFO_TRACEBUF_HEADER) + \
                               (PERFINFO_THREAD_HASH_SIZE * sizeof(PERFINFO_THREAD_HASH_ENTRY))), \
                               PAGE_SIZE)


//
// Instruction tracing
//
#define PERFINFO_BRANCH_ESCAPE -128

//
// Structure to hold cached branches.
// We have a Used member because PerkLogBytes pads and aligns
// data.
//
typedef struct _PERFINFO_EXCEPTION_BRANCH_CACHE {
  USHORT Used;
  PERF_BYTE Data[1];
} PERFINFO_EXCEPTION_BRANCH_CACHE, *PPERFINFO_EXCEPTION_BRANCH_CACHE;

#endif // NTPERF

#endif // _NTPERF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\newexe.h ===
/*
 *	SCCSID = @(#)newexe.h	13.4 89/06/26
 *
 *  Title
 *
 *	newexe.h
 *	Pete Stewart
 *	(C) Copyright Microsoft Corp 1984-1998
 *	17 August 1984
 *
 *  Description
 *
 *	Data structure definitions for the DOS 4.0/Windows 2.0
 *	executable file format.
 *
 *  Modification History
 *
 *	84/08/17	Pete Stewart	Initial version
 *	84/10/17	Pete Stewart	Changed some constants to match OMF
 *	84/10/23	Pete Stewart	Updates to match .EXE format revision
 *	84/11/20	Pete Stewart	Substantial .EXE format revision
 *	85/01/09	Pete Stewart	Added constants ENEWEXE and ENEWHDR
 *	85/01/10	Steve Wood	Added resource definitions
 *	85/03/04	Vic Heller	Reconciled Windows and DOS 4.0 versions
 *	85/03/07	Pete Stewart	Added movable entry count
 *	85/04/01	Pete Stewart	Segment alignment field, error bit
 *	85/10/03	Reuben Borman	Removed segment discard priority
 *	85/10/11	Vic Heller	Added PIF header fields
 *	86/03/10	Reuben Borman	Changes for DOS 5.0
 *	86/09/02	Reuben Borman	NSPURE ==> NSSHARED
 *	87/05/04	Reuben Borman	Added ne_cres and NSCONFORM
 *	87/07/08	Reuben Borman	Added NEAPPTYPE definitions
 *	88/03/24	Wieslaw Kalkus	Added 32-bit .EXE format
 *	89/03/23	Wieslaw Kalkus	Added ne_flagsothers for OS/2 1.2
 */

/*INT32*/

    /*_________________________________________________________________*
     |								       |
     |								       |
     |	DOS3 .EXE FILE HEADER DEFINITION			       |
     |								       |
     |_________________________________________________________________|
     *								       */


#define EMAGIC		0x5A4D		/* Old magic number */
#define ENEWEXE		sizeof(struct exe_hdr)
					/* Value of E_LFARLC for new .EXEs */
#define ENEWHDR		0x003C		/* Offset in old hdr. of ptr. to new */
#define ERESWDS		0x0010		/* No. of reserved words (OLD) */
#define ERES1WDS	0x0004		/* No. of reserved words in e_res */
#define ERES2WDS	0x000A		/* No. of reserved words in e_res2 */
#define ECP		0x0004		/* Offset in struct of E_CP */
#define ECBLP		0x0002		/* Offset in struct of E_CBLP */
#define EMINALLOC	0x000A		/* Offset in struct of E_MINALLOC */

struct exe_hdr {			/* DOS 1, 2, 3 .EXE header */
    unsigned short	e_magic;	/* Magic number */
    unsigned short	e_cblp;		/* Bytes on last page of file */
    unsigned short	e_cp;		/* Pages in file */
    unsigned short	e_crlc;		/* Relocations */
    unsigned short	e_cparhdr;	/* Size of header in paragraphs */
    unsigned short	e_minalloc;	/* Minimum extra paragraphs needed */
    unsigned short	e_maxalloc;	/* Maximum extra paragraphs needed */
    unsigned short	e_ss;		/* Initial (relative) SS value */
    unsigned short	e_sp;		/* Initial SP value */
    unsigned short	e_csum;		/* Checksum */
    unsigned short	e_ip;		/* Initial IP value */
    unsigned short	e_cs;		/* Initial (relative) CS value */
    unsigned short	e_lfarlc;	/* File address of relocation table */
    unsigned short	e_ovno;		/* Overlay number */
    unsigned short	e_res[ERES1WDS];/* Reserved words */
    unsigned short	e_oemid;	/* OEM identifier (for e_oeminfo) */
    unsigned short	e_oeminfo;	/* OEM information; e_oemid specific */
    unsigned short	e_res2[ERES2WDS];/* Reserved words */
    long		e_lfanew;	/* File address of new exe header */
  };

/* XLATOFF */
#define E_MAGIC(x)	(x).e_magic
#define E_CBLP(x)	(x).e_cblp
#define E_CP(x)		(x).e_cp
#define E_CRLC(x)	(x).e_crlc
#define E_CPARHDR(x)	(x).e_cparhdr
#define E_MINALLOC(x)	(x).e_minalloc
#define E_MAXALLOC(x)	(x).e_maxalloc
#define E_SS(x)		(x).e_ss
#define E_SP(x)		(x).e_sp
#define E_CSUM(x)	(x).e_csum
#define E_IP(x)		(x).e_ip
#define E_CS(x)		(x).e_cs
#define E_LFARLC(x)	(x).e_lfarlc
#define E_OVNO(x)	(x).e_ovno
#define E_RES(x)	(x).e_res
#define E_OEMID(x)	(x).e_oemid
#define E_OEMINFO(x)	(x).e_oeminfo
#define E_RES2(x)	(x).e_res2
#define E_LFANEW(x)	(x).e_lfanew
/* XLATON */


    /*_________________________________________________________________*
     |								       |
     |								       |
     |	OS/2 & WINDOWS .EXE FILE HEADER DEFINITION - 286 version       |
     |								       |
     |_________________________________________________________________|
     *								       */

#define NEMAGIC		0x454E		/* New magic number */
#define NECRC		8		/* Offset into new header of NE_CRC */

#ifdef	CRUISER

#define NERESBYTES	8		/* Eight bytes reserved (now) */

struct new_exe {			/* New .EXE header */
    unsigned short	ne_magic;	/* Magic number NE_MAGIC */
    unsigned char	ne_ver;		/* Version number */
    unsigned char	ne_rev;		/* Revision number */
    unsigned short	ne_enttab;	/* Offset of Entry Table */
    unsigned short	ne_cbenttab;	/* Number of bytes in Entry Table */
    long		ne_crc;		/* Checksum of whole file */
    unsigned short	ne_flags;	/* Flag word */
    unsigned short	ne_autodata;	/* Automatic data segment number */
    unsigned short	ne_heap;	/* Initial heap allocation */
    unsigned short	ne_stack;	/* Initial stack allocation */
    long		ne_csip;	/* Initial CS:IP setting */
    long		ne_sssp;	/* Initial SS:SP setting */
    unsigned short	ne_cseg;	/* Count of file segments */
    unsigned short	ne_cmod;	/* Entries in Module Reference Table */
    unsigned short	ne_cbnrestab;	/* Size of non-resident name table */
    unsigned short	ne_segtab;	/* Offset of Segment Table */
    unsigned short	ne_rsrctab;	/* Offset of Resource Table */
    unsigned short	ne_restab;	/* Offset of resident name table */
    unsigned short	ne_modtab;	/* Offset of Module Reference Table */
    unsigned short	ne_imptab;	/* Offset of Imported Names Table */
    long		ne_nrestab;	/* Offset of Non-resident Names Table */
    unsigned short	ne_cmovent;	/* Count of movable entries */
    unsigned short	ne_align;	/* Segment alignment shift count */
    unsigned short	ne_cres;	/* Count of resource entries */
    unsigned char	ne_exetyp;	/* Target operating system */
    unsigned char	ne_flagsothers; /* Other .EXE flags */
    char		ne_res[NERESBYTES];
					/* Pad structure to 64 bytes */
  };
#else

#define NERESBYTES	0

struct new_exe {			/* New .EXE header */
    unsigned short int	ne_magic;	/* Magic number NE_MAGIC */
    char		ne_ver;		/* Version number */
    char		ne_rev;		/* Revision number */
    unsigned short int	ne_enttab;	/* Offset of Entry Table */
    unsigned short int	ne_cbenttab;	/* Number of bytes in Entry Table */
    long		ne_crc;		/* Checksum of whole file */
    unsigned short int	ne_flags;	/* Flag word */
    unsigned short int	ne_autodata;	/* Automatic data segment number */
    unsigned short int	ne_heap;	/* Initial heap allocation */
    unsigned short int	ne_stack;	/* Initial stack allocation */
    long		ne_csip;	/* Initial CS:IP setting */
    long		ne_sssp;	/* Initial SS:SP setting */
    unsigned short int	ne_cseg;	/* Count of file segments */
    unsigned short int	ne_cmod;	/* Entries in Module Reference Table */
    unsigned short int	ne_cbnrestab;	/* Size of non-resident name table */
    unsigned short int	ne_segtab;	/* Offset of Segment Table */
    unsigned short int	ne_rsrctab;	/* Offset of Resource Table */
    unsigned short int	ne_restab;	/* Offset of resident name table */
    unsigned short int	ne_modtab;	/* Offset of Module Reference Table */
    unsigned short int	ne_imptab;	/* Offset of Imported Names Table */
    long		ne_nrestab;	/* Offset of Non-resident Names Table */
    unsigned short int	ne_cmovent;	/* Count of movable entries */
    unsigned short int	ne_align;	/* Segment alignment shift count */
    unsigned short int	ne_cres;	/* Count of resource segments */
    unsigned char	ne_exetyp;	/* Target operating system */
    unsigned char	ne_flagsothers; /* Other .EXE flags */
    unsigned short int	ne_pretthunks;	/* offset to return thunks */
    unsigned short int	ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int	ne_swaparea;	/* Minimum code swap area size */
    unsigned short int	ne_expver;	/* Expected Windows version number */
  };
#endif

/* ASM
; Chksum not supported unless ne_psegcsum defined in NEW_EXE structure

ne_psegcsum = word ptr ne_exetyp
ne_onextexe = word ptr ne_crc

; New 3.0 Gang Load area description

ne_gang_start	= ne_pretthunks
ne_gang_length	= ne_psegrefbytes

new_exe1	struc
		dw  ?
ne_usage	dw  ?
		dw  ?
ne_pnextexe	dw  ?
ne_pautodata	dw  ?
ne_pfileinfo	dw  ?
new_exe1	ends
*/

/* XLATOFF */
#define NE_MAGIC(x)	    (x).ne_magic
#define NE_VER(x)	    (x).ne_ver
#define NE_REV(x)	    (x).ne_rev
#define NE_ENTTAB(x)	    (x).ne_enttab
#define NE_CBENTTAB(x)	    (x).ne_cbenttab
#define NE_CRC(x)	    (x).ne_crc
#define NE_FLAGS(x)	    (x).ne_flags
#define NE_AUTODATA(x)	    (x).ne_autodata
#define NE_HEAP(x)	    (x).ne_heap
#define NE_STACK(x)	    (x).ne_stack
#define NE_CSIP(x)	    (x).ne_csip
#define NE_SSSP(x)	    (x).ne_sssp
#define NE_CSEG(x)	    (x).ne_cseg
#define NE_CMOD(x)	    (x).ne_cmod
#define NE_CBNRESTAB(x)	    (x).ne_cbnrestab
#define NE_SEGTAB(x)	    (x).ne_segtab
#define NE_RSRCTAB(x)	    (x).ne_rsrctab
#define NE_RESTAB(x)	    (x).ne_restab
#define NE_MODTAB(x)	    (x).ne_modtab
#define NE_IMPTAB(x)	    (x).ne_imptab
#define NE_NRESTAB(x)	    (x).ne_nrestab
#define NE_CMOVENT(x)	    (x).ne_cmovent
#define NE_ALIGN(x)	    (x).ne_align
#define NE_CRES(x)	    (x).ne_cres
#define NE_RES(x)	    (x).ne_res
#define NE_EXETYP(x)	    (x).ne_exetyp
#define NE_FLAGSOTHERS(x)   (x).ne_flagsothers

#define NE_USAGE(x)	(WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)	(WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)	(WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif
/* XLATON */

/*
 *  Format of NE_FLAGS(x):
 *
 *  p					Not-a-process
 *   x					Unused
 *    e					Errors in image
 *     x				Unused
 *	b				Bound Family/API
 *	 ttt				Application type
 *	    f				Floating-point instructions
 *	     3				386 instructions
 *	      2				286 instructions
 *	       0			8086 instructions
 *		P			Protected mode only
 *		 p			Per-process library initialization
 *		  i			Instance data
 *		   s			Solo data
 */
#define NENOTP		0x8000		/* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define	NEPRIVLIB       0x4000		/* A lib which lives above the line */
#define NEIERR		0x2000		/* Errors in image */
#define NEBOUND		0x0800		/* Bound Family/API */
#define NEAPPTYP	0x0700		/* Application type mask */
#define NENOTWINCOMPAT	0x0100		/* Not compatible with P.M. Windowing */
#define NEWINCOMPAT	0x0200		/* Compatible with P.M. Windowing */
#define NEWINAPI	0x0300		/* Uses P.M. Windowing API */
#define NEFLTP		0x0080		/* Floating-point instructions */
#define NEI386		0x0040		/* 386 instructions */
#define NEI286		0x0020		/* 286 instructions */
#define NEI086		0x0010		/* 8086 instructions */
#define NEPROT		0x0008		/* Runs in protected mode only */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEPPLI		0x0004		/* Per-Process Library Initialization */
#define NEINST		0x0002		/* Instance data */
#define NESOLO		0x0001		/* Solo data */

/*
 * Below are the private bits used by the Windows 2.0 loader.  All are
 * in the file, with the exception of NENONRES and NEWINPROT which are
 * runtime only flags.
 */

#define NEWINPROT	NEIERR
#define NENONRES        NEFLTP        /* Contains non-resident code segments */
#define NEALLOCHIGH     NEI386        /* Private allocs above the line okay */
#define NEEMSSEPINST    NEI286        /* Want each instance in separate */
#define NELIM32         NEI086        /* Uses LIM 3.2 API (Intel Above board) */

/*
 *  Format of NE_FLAGSOTHERS(x):
 *
 *	7 6 5 4 3 2 1 0	 - bit no
 *	| |   |	      |
 *	| |   |	      +---------------- Support for long file names
 *	| |   +------------------------ Reserved for Win16 loader: must be 0
 *      | +---------------------------- Intl versions use this for ml shell
 *      +------------------------------ Some segs of this module get patched
 */

#define NELONGNAMES	0x01
#define NEFORCESTUB	0x02	/* WIN40 - Always run the stub from DOS */
#define	NEINFONT	0x02	/* WIN30 - 2.x app runs in 3.x prot mode */
#define	NEINPROT	0x04	/* WIN30 - 2.x app gets proportional font */
#define	NEGANGLOAD	0x08	/* WIN30 - Contains gangload area */
#define NEASSUMENODEP   0x10	/* Reserved for Win16 loader. Must be 0 in file */
#define NEINTLAPP       0x40	/* WIN31 - intl versions use this. */
#define NEHASPATCH      0x80    /* WIN40 - Some segs of this module get patched */

/*
 *  Target operating systems
 */

#define NE_UNKNOWN	0x0		/* Unknown (any "new-format" OS) */
#define NE_OS2		0x1		/* Microsoft/IBM OS/2 (default)	 */
#define NE_WINDOWS	0x2		/* Microsoft Windows */
#define NE_DOS4		0x3		/* Microsoft MS-DOS 4.x */
#define NE_DEV386	0x4		/* Microsoft Windows 386 */

#ifndef NO_APPLOADER
#define	NEAPPLOADER     0x0800		/* set if app has its own loader */
#endif  /* !NO_APPLOADER */

struct new_seg {			/* New .EXE segment table entry */
    unsigned short	ns_sector;	/* File sector of start of segment */
    unsigned short	ns_cbseg;	/* Number of bytes in file */
    unsigned short	ns_flags;	/* Attribute flags */
    unsigned short	ns_minalloc;	/* Minimum allocation in bytes */
  };

/* ASM
new_seg1	struc
		db	size new_seg dup (?)
ns_handle	dw	?	
new_seg1	ends
*/

/* XLATOFF */
struct new_seg1 {			/* New .EXE segment table entry */
    unsigned short	ns_sector;	/* File sector of start of segment */
    unsigned short	ns_cbseg;	/* Number of bytes in file */
    unsigned short	ns_flags;	/* Attribute flags */
    unsigned short	ns_minalloc;	/* Minimum allocation in bytes */
    unsigned short	ns_handle;	/* Handle of segment */
  };

#define NS_SECTOR(x)	(x).ns_sector
#define NS_CBSEG(x)	(x).ns_cbseg
#define NS_FLAGS(x)	(x).ns_flags
#define NS_MINALLOC(x)	(x).ns_minalloc
/* XLATON */

/*
 *  Format of NS_FLAGS(x)
 *
 *  Flag word has the following format:
 *
 *	15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *	    |  |  |  |	| | | | | | | | | | |
 *	    |  |  |  |	| | | | | | | | +-+-+--- Segment type DATA/CODE
 *	    |  |  |  |	| | | | | | | +--------- Iterated segment
 *	    |  |  |  |	| | | | | | +----------- Movable segment
 *	    |  |  |  |	| | | | | +------------- Segment can be shared
 *	    |  |  |  |	| | | | +--------------- Preload segment
 *	    |  |  |  |	| | | +----------------- Execute/read-only for code/data segment
 *	    |  |  |  |	| | +------------------- Segment has relocations
 *	    |  |  |  |	| +--------------------- Code conforming/Data is expand down
 *	    |  |  |  +--+----------------------- I/O privilege level
 *	    |  |  +----------------------------- Discardable segment
 *	    |  +-------------------------------- 32-bit code segment
 *	    +----------------------------------- Huge segment/GDT allocation requested
 *
 */

#define NSTYPE		0x0007		/* Segment type mask */
#define NSCODE		0x0000		/* Code segment */
#define NSDATA		0x0001		/* Data segment */
#define NSITER		0x0008		/* Iterated segment flag */
#define NSMOVE		0x0010		/* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSSHARED	0x0020		/* Shared segment flag */
#define NSSHARE		0x0020
#define NSPRELOAD	0x0040		/* Preload segment flag */
#define NSEXRD		0x0080		/* Execute-only (code segment) or */
#define NSERONLY	0x0080		/* read-only (data segment) */
#define NSRELOC		0x0100		/* Segment has relocations */
#define NSCONFORM	0x0200		/* Conforming segment */
#define NSEXPDOWN	0x0200		/* Data segment is expand down */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL		0x0C00		/* I/O privilege level (286 DPL bits) */
#define SHIFTDPL	10		/* Left shift count for SEGDPL field */
#define NSDISCARD	0x1000		/* Segment is discardable */
#define NS32BIT		0x2000		/* 32-bit code segment */
#define NSHUGE		0x4000		/* Huge memory segment, length of
					   segment and minimum allocation
					   size are in segment sector units */
#define NSGDT		0x8000		/* GDT allocation requested */

#define	NS286DOS        0xEE06		/* These bits only used by 286DOS */

#define NSALIGN 9			/* Segment data aligned on 512 byte
					   boundaries */

#define	NSALLOCED       0x0002		/* Set if ns_handle points to
					   uninitialized mem */
#define NSLOADED	0x0004		/* ns_sector field contains memory
					   address */
#define	NSUSESDATA      0x0400     	/* Set if an entry point in this
					   segment uses the automatic data
					   segment of a SOLO library */

#define	NSGETHIGH	0x0200
#define	NSINDIRECT	0x2000
#define	NSWINCODE	0x4000		/* flag for code */

#define	NSKCACHED	0x0800		/* cached by kernel */
#define	NSPRIVLIB	NSITER
#define	NSNOTP		0x8000

#ifndef NO_APPLOADER
#define	NSCACHED	0x8000		/* in AppLoader Cache */
#endif /*!NO_APPLOADER */

/* XLATOFF */
struct new_segdata {			/* Segment data */
    union {
	struct {
	    unsigned short	ns_niter;	/* number of iterations */
	    unsigned short	ns_nbytes;	/* number of bytes */
	    char		ns_iterdata;	/* iterated data bytes */
	  } ns_iter;
	struct {
	    char		ns_data;	/* data bytes */
	  } ns_noniter;
      } ns_union;
  };
/* XLATON */

struct new_rlcinfo {			/* Relocation info */
    unsigned short	nr_nreloc;	/* number of relocation items that */
  };					/* follow */

/* XLATOFF */
#pragma pack(1)

struct new_rlc {			/* Relocation item */
    char		nr_stype;	/* Source type */
    char		nr_flags;	/* Flag byte */
    unsigned short	nr_soff;	/* Source offset */
    union {
	struct {
	    char	nr_segno;	/* Target segment number */
	    char	nr_res;		/* Reserved */
	    unsigned short nr_entry;	/* Target Entry Table offset */
	  } 		nr_intref;	/* Internal reference */
	struct {
	    unsigned short nr_mod;	/* Index into Module Reference Table */
	    unsigned short nr_proc;	/* Procedure ordinal or name offset */
	  } 		nr_import;	/* Import */
	struct {
	    unsigned short nr_ostype;	/* OSFIXUP type */
	    unsigned short nr_osres;	/* reserved */
	  }		nr_osfix;	/* Operating system fixup */
      }			nr_union;	/* Union */
  };

#pragma pack()
/* XLATON */

/* ASM
new_rlc         struc
nr_stype        db  ?
nr_flags        db  ?
nr_soff         dw  ?
nr_mod          dw  ?
nr_proc         dw  ?
new_rlc         ends

nr_segno        equ nr_flags+3
nr_entry        equ nr_proc
*/

/* XLATOFF */
#define NR_STYPE(x)	(x).nr_stype
#define NR_FLAGS(x)	(x).nr_flags
#define NR_SOFF(x)	(x).nr_soff
#define NR_SEGNO(x)	(x).nr_union.nr_intref.nr_segno
#define NR_RES(x)	(x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)	(x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)	(x).nr_union.nr_import.nr_mod
#define NR_PROC(x)	(x).nr_union.nr_import.nr_proc
#define NR_OSTYPE(x)	(x).nr_union.nr_osfix.nr_ostype
#define NR_OSRES(x)	(x).nr_union.nr_osfix.nr_osres
/* XLATON */

/*
 *  Format of NR_STYPE(x) and R32_STYPE(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *		 | | | |
 *		 +-+-+-+--- source type
 *
 */

#define NRSTYP		0x0f		/* Source type mask */
#define NRSBYT		0x00		/* lo byte (8-bits)*/
#define NRSBYTE		0x00
#define NRSSEG		0x02		/* 16-bit segment (16-bits) */
#define NRSPTR		0x03		/* 16:16 pointer (32-bits) */
#define NRSOFF		0x05		/* 16-bit offset (16-bits) */
#define NRPTR48		0x06		/* 16:32 pointer (48-bits) */
#define NROFF32		0x07		/* 32-bit offset (32-bits) */
#define NRSOFF32	0x08		/* 32-bit self-relative offset (32-bits) */

/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *		   | | |
 *		   | +-+--- Reference type
 *		   +------- Additive fixup
 */

#define NRADD		0x04		/* Additive fixup */
#define NRRTYP		0x03		/* Reference type mask */
#define NRRINT		0x00		/* Internal reference */
#define NRRORD		0x01		/* Import by ordinal */
#define NRRNAM		0x02		/* Import by name */
#define NRROSF		0x03		/* Operating system fixup */
#define OSFIXUP		NRROSF

/* Resource type or name string */
struct rsrc_string {
    char rs_len;	    /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

/* XLATOFF */
#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string
/* XLATON */

/* Resource type information block */
struct rsrc_typeinfo {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

/* XLATOFF */
#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc
/* XLATON */

/* Resource name information block */
struct rsrc_nameinfo {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are	      */
    unsigned short rn_offset;	/* file offset to resource data */
    unsigned short rn_length;	/* length of resource data */
    unsigned short rn_flags;	/* resource flags */
    unsigned short rn_id;	/* resource name id */
    unsigned short rn_handle;	/* If loaded, then global handle */
    unsigned short rn_usage;	/* Initially zero.  Number of times */
				/* the handle for this resource has */
				/* been given out */
    };

/* XLATOFF */
#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage
/* XLATON */

#define RSORDID	    0x8000	/* if high bit of ID set then integer id */
				/* otherwise ID is offset of string from
				   the beginning of the resource table */

				/* Ideally these are the same as the */
				/* corresponding segment flags */
#define RNMOVE	    0x0010	/* Moveable resource */
#define RNPURE	    0x0020	/* Pure (read-only) resource */
#define RNPRELOAD   0x0040	/* Preloaded resource */
#define RNDISCARD   0x1000	/* Discard priority level for resource */
#define	RNLOADED    0x0004	/* True if handler proc return handle */

#define RNUNUSED    0x0EF8B	/* Unused resource flags */

/* XLATOFF */
/* Resource table */
struct new_rsrc {
    unsigned short rs_align;	/* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align
/* XLATON */

/* ASM
new_rsrc        struc
rs_align        dw ?
new_rsrc        ends

entfixed        struc
entflags        db  ?
entoffset       dw  ?
entfixed        ends

pent		struc
penttype	db  ?
pentflags	db  ?
pentsegno	db  ?
pentoffset	dw  ?
pent		ends

pm_entstruc	struc
pm_entstart	dw	?
pm_entend	dw	?
pm_entnext	dw	?
pm_entstruc	ends

ENT_UNUSED	= 000h
ENT_ABSSEG      = 0FEh
ENT_MOVEABLE    = 0FFh
ENT_PUBLIC      = 001h
ENT_DATA        = 002h
INTOPCODE       = 0CDh

savedCS = 4
savedIP = 2
savedBP = 0
savedDS = -2
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntsetup.h ===
#ifndef     _NTSETUP_H_
#define _NTSETUP_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Module: ntsetup.h
//
//  Author: Dan Elliott
//
//  Abstract:
//      Header file for internal-use declarations used by NT Setup
//
//  Environment:
//      Whistler
//
//  Revision History:
//      000818  dane    Created and added REGSTR_VALUE_OOEMOOBEINPROGRESS.
//
//////////////////////////////////////////////////////////////////////////////

// This value is set in the HKLM\System\Setup key to dword:1 by SysPrep
// utilities to indicate that OOBE will be run on first boot.  If
// services.exe finds this value set to 1, it runs PnP, signals OOBE that PnP
// is complete, then waits for a signal from OOBE before starting other
// services.
//
#define REGSTR_VALUE_OOBEINPROGRESS TEXT("OobeInProgress")
#define REGSTR_VALUE_OEMOOBEINPROGRESS L"OemOobeInProgress"

#endif  //  _NTSETUP_H_

//
///// End of file: ntsetup.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntfsexp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    NtfsExp.h

Abstract:

    This module defines the exports from NtOfs.SYS for use exclusively by
    Transactions and Encryption.

    *********************************
    *No other clients are supported.*
    *********************************

Author:

    Mark Zbikowski  [MarkZ]         7-Dec-1995
    Jeff Havens     [JHavens]
    Brian Andrew    [BrianAn]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:


--*/

#ifndef _NTFS_

//
//  The MFT Segment Reference is an address in the MFT tagged with
//  a circularly reused sequence number set at the time that the MFT
//  Segment Reference was valid.  Note that this format limits the
//  size of the Master File Table to 2**48 segments.  So, for
//  example, with a 1KB segment size the maximum size of the master
//  file would be 2**58 bytes, or 2**28 gigabytes.
//

typedef struct _FILE_REFERENCE {

    //
    //  First a 48 bit segment number.
    //

    ULONG SegmentNumberLowPart;                                    //  offset = 0x000
    USHORT SegmentNumberHighPart;                                  //  offset = 0x004

    //
    //  Now a 16 bit nonzero sequence number.  A value of 0 is
    //  reserved to allow the possibility of a routine accepting
    //  0 as a sign that the sequence number check should be
    //  repressed.
    //

    USHORT SequenceNumber;                                          //  offset = 0x006

} FILE_REFERENCE, *PFILE_REFERENCE;                   //  sizeof = 0x008

#endif

//
//  Big picture view of the interaction between extensions and NtOfs:
//
//      NtOfs exports a number of interfaces that give abstract access to
//      on-disk structures and attempt to hide, as much as possible, the
//      implementation details.
//
//      V/Q/X are implemented as DLL's that link to NtOfs.Sys.  NtOfs can load
//      and function in absence of these DLL's.
//
//      All communication between user-mode code and V/Q/X occurs via the
//      Nt Io API which is routed through NtOfs.  Client code will open either
//      an NtOfs Volume, Directory, or File and will issue NtIo calls to the
//      resultant handle.
//
//      NtOfs will create an IrpContext, decode the file object appropriately,
//      and call out to entry points in V/Q/X that are registered at load-time.
//
//      V/Q/X will perform whatever actions are necessary utilizing NtOfs exports
//      and then return from the original call from NtOfs an NTSTATUS code.  NtOfs
//      will perform the appropriate CompleteIrp calls, posting for STATUS_PENDING,
//      etc.
//
//      No exceptions can be raised across the NtOfs export or NtOfs import
//      interfaces.  All user-buffer access and validation will occur in the
//      code that uses it.  Since user buffers may disappear at any time, any
//      client of these buffers must wrap access to the buffers in an exception
//      clause.
//
//      V/Q/X may perform activities in threads separate from the original
//      requestor.  For these cases, NtOfs will provide a means where calls separate
//      from a user-mode request can be accepted.  Typically, this means "cloning"
//      an IrpContext.
//

//
//  Opaque handle definitions.
//

//
//  ISSUE:  Most NtOfs internal routines rely on having an IrpContext passed in
//  along with FCB and SCB pointers.  Rather than exposing FCB and IrpContext
//  as separate contexts, should we wrap these up into a separate structure and
//  pass it along?
//

typedef struct _FCB *OBJECT_HANDLE;
typedef struct _SCB *ATTRIBUTE_HANDLE;
typedef struct _SCB *INDEX_HANDLE;
typedef struct _READ_CONTEXT *PREAD_CONTEXT;
typedef ULONG SECURITY_ID;
typedef struct _CI_CALL_BACK CI_CALL_BACK, *PCI_CALL_BACK;
typedef struct _VIEW_CALL_BACK VIEW_CALL_BACK, *PVIEW_CALL_BACK;
typedef struct _IRP_CONTEXT *PIRP_CONTEXT;

//
//  Map Handle.  This structure defines a byte range of the file which is mapped
//  or pinned, and stores the Bcb returned from the Cache Manager.
//

typedef struct _MAP_HANDLE {

    //
    //  Range being mapped or pinned
    //

    LONGLONG FileOffset;
    ULONG Length;

    //
    //  Virtual address corresponding to FileOffset
    //

    PVOID Buffer;

    //
    //  Bcb pointer returned from Cache Manager
    //

    PVOID Bcb;

} MAP_HANDLE, *PMAP_HANDLE;

//
//  Quick Index Hint.  This is stream offset information returned by
//  NtOfsFindRecord, and taken as input to NtOfsUpdateRecord, to allow
//  quick updates to index records in the event that they have not
//  moved.  This structure must always have the same size and alignment
//  as QUICK_INDEX in ntfsstru.h.
//

typedef struct _QUICK_INDEX_HINT {
    LONGLONG HintData[3];
} QUICK_INDEX_HINT, *PQUICK_INDEX_HINT;

//
//  Index structures
//

typedef struct {
    ULONG KeyLength;
    PVOID Key;
} INDEX_KEY, *PINDEX_KEY;

typedef struct {
    ULONG DataLength;
    PVOID Data;
} INDEX_DATA, *PINDEX_DATA;

typedef struct {
    INDEX_KEY KeyPart;
    INDEX_DATA DataPart;
} INDEX_ROW, *PINDEX_ROW;

//
//  COLLATION_FUNCTION returns LessThan if Key1 precedes Key2
//                             EqualTo if Key1 is identical to Key2
//                             GreaterThan if Key1 follows Key2
//

typedef FSRTL_COMPARISON_RESULT (*PCOLLATION_FUNCTION) (
            IN PINDEX_KEY Key1,
            IN PINDEX_KEY Key2,
            IN PVOID CollationData
            );

typedef struct _UPCASE_TABLE_AND_KEY {

    //
    //  Pointer to a table of upcased unicode characters indexed by character to
    //  be upcased.
    //

    PWCH UpcaseTable;

    //
    //  Size of UpcaseTable in unicode characters
    //

    ULONG UpcaseTableSize;

    //
    //  Optional addtional pointer.
    //

    INDEX_KEY Key;

} UPCASE_TABLE_AND_KEY, *PUPCASE_TABLE_AND_KEY;

//
//  Wait for new length block used to synchronize a thread with FileSize
//  exceeding the specified Length.
//

typedef struct _WAIT_FOR_NEW_LENGTH {

    //
    //  Link words for multiple waiters on the Scb.
    //

    LIST_ENTRY WaitList;

    //
    //  Set event when FileSize exceeds this length.
    //

    LONGLONG Length;

    //
    //  Event to set when new length achieved.
    //

    KEVENT Event;

    //
    //  Irp to complete when new length achieved. (If Irp present, Event is
    //  ignored.)
    //

    PIRP Irp;

    //
    //  Stream we are waiting on.
    //

    ATTRIBUTE_HANDLE Stream;

    //
    //  Status code for operation that caused the new length to be satisfied.
    //  It may be STATUS_CANCELLED, STATUS_TIMEOUT or STATUS_SUCCESS
    //  or a request specific status.
    //

    NTSTATUS Status;

    //
    //  Flags.
    //

    ULONG Flags;

} WAIT_FOR_NEW_LENGTH, *PWAIT_FOR_NEW_LENGTH;

#define NTFS_WAIT_FLAG_ASYNC                    (0x00000001)

//
//  Standard collation functions for simple indices
//

FSRTL_COMPARISON_RESULT
NtOfsCollateUlong (             //  Both must be single Ulong
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData      //  Don't care, may be NULL
    );

FSRTL_COMPARISON_RESULT
NtOfsCollateUlongs (            //  Lengths do not have to be equal
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData      //  Don't care, may be NULL
    );

FSRTL_COMPARISON_RESULT
NtOfsCollateSid (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData      //  Don't care, may be NULL
    );

FSRTL_COMPARISON_RESULT
NtOfsCollateUnicode (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData      //  PUPCASE_TABLE_AND_KEY (with no key)
    );

//
//  Standard match functions for simple indices
//

NTSTATUS
NtOfsMatchAll (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData      //  Don't care, may be NULL
    );

NTSTATUS
NtOfsMatchUlongExact (
    IN PINDEX_ROW IndexRow,     //  Both must be single Ulong
    IN OUT PVOID MatchData      //  PINDEX_KEY describing Ulong
    );

NTSTATUS
NtOfsMatchUlongsExact (         //  Lengths do not have to be equal
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData      //  PINDEX_KEY describing Ulongs
    );

NTSTATUS
NtOfsMatchUnicodeExpression (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData      //  PUPCASE_TABLE_AND_KEY with Uni expression (must have wildcards)
    );

NTSTATUS
NtOfsMatchUnicodeString (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData      //  PUPCASE_TABLE_AND_KEY with Uni string (no wildcards)
    );

//
//  MATCH_FUNCTION returns
//      STATUS_SUCCESS if the IndexRow matches
//      STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
//          continue
//      STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
//          should terminate
//

typedef NTSTATUS (*PMATCH_FUNCTION) (IN PINDEX_ROW IndexRow, IN OUT PVOID MatchData);

//
//  CREATE_OPTIONS - common flags governing creation/opening of objects
//

typedef enum _CREATE_OPTIONS
{
    CREATE_NEW = 0,
    CREATE_OR_OPEN = 1,
    OPEN_EXISTING = 2
} CREATE_OPTIONS;


//
//  EXCLUSION - Form of exclusion desired when opening an object
//

typedef enum _EXCLUSION
{
    SHARED = 0,
    EXCLUSIVE
} EXCLUSION;



//
//  Additional Dos Attribute indicating Content Index status of an object.
//  If this is set on a document, it suppresses indexing.  It is inherited
//  from a parent directory at create time.  This is stored in the
//  DUPLICATED_INFORMATION structure.
//

#define SUPPRESS_CONTENT_INDEX      (0x20000000)

//
//  Define the size of the index buffer/bucket for view indexes, in bytes.
//

#define NTOFS_VIEW_INDEX_BUFFER_SIZE    (0x1000)

//
//  Exported constants.
//

//
//  NtOfsContentIndexSystemFile is the repository for all CI related data on the
//  disk.

extern FILE_REFERENCE NtOfsContentIndexSystemFile;

#if defined(_NTFSPROC_)

#define NTFSAPI

#else

#define NTFSAPI //DECLSPEC_IMPORT

#endif

////////////////////////////////////////////////////////////////////////////////

//
//  Index API - These encapsulate the NtOfs BTree mechanisms.
//

//
//  NtOfsCreateIndex creates or opens a named index attribute in an object.  The
//  ObjectHandle has been acquired exclusive and the returned handle is not
//  acquired.  The collation data is interpreted only by the CollationFunction.
//
//  IndexHandles retain a "seek" position where enumerations (NtOfsReadRecords)
//  may continue.  This seek position may be updated by the routines as described
//  below.
//
//  If DeleteCollationData is 1, ExFreePool will be called on CollationData, either
//  immediately if the index already exists, or when the index is deleted some time
//  after the final close.  If NtOfsCreateIndex returns an error, then CollationData
//  must be deleted by the caller.  If specified as 0, then ColloationData will not
//  be deleted.
//

NTFSAPI
NTSTATUS
NtOfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG DeleteCollationData,
    IN ULONG CollationRule,
    IN PCOLLATION_FUNCTION CollationFunction,
    IN PVOID CollationData OPTIONAL,
    OUT INDEX_HANDLE *IndexHandle
    );


//
//  NtOfsFindRecord finds a single record in an index stream for read-only access
//  or in preparation for calling NtOfsUpdateRecord.
//

NTFSAPI
NTSTATUS
NtOfsFindRecord (
    IN PIRP_CONTEXT IrpContext,
    IN INDEX_HANDLE IndexHandle,
    IN PINDEX_KEY IndexKey,
    OUT PINDEX_ROW IndexRow,
    OUT PMAP_HANDLE MapHandle,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    );

//
//  NtOfsFindRecord finds a single record in an index stream for read-only access
//  or in preparation for calling NtOfsUpdateRecord.
//

NTFSAPI
NTSTATUS
NtOfsFindLastRecord (
    IN PIRP_CONTEXT IrpContext,
    IN INDEX_HANDLE IndexHandle,
    IN PINDEX_KEY MaxIndexKey,
    OUT PINDEX_ROW IndexRow,
    OUT PMAP_HANDLE MapHandle
    );

//
//  NtOfsAddRecords performs bulk, logged inserts into an index.  The index will
//  be acquired exclusive for this call.  Each record added must have a unique
//  (with regards to the collation function) key.  No maps are currently
//  outstanding on this index.  If SequentialInsertMode is nonzero, this is a hint
//  to the index package to keep all BTree buffers as full as possible, by splitting
//  as close to the end of the buffer as possible.  If specified as zero, random
//  inserts are assumed, and buffers are always split in the middle for better balance.
//
//  This call may update the IndexHandle seek position
//

NTFSAPI
VOID
NtOfsAddRecords (
    IN PIRP_CONTEXT IrpContext,
    IN INDEX_HANDLE IndexHandle,
    IN ULONG Count,
    IN PINDEX_ROW IndexRow,
    IN ULONG SequentialInsertMode
    );

//
//  NtOfsDeleteRecords performs bulk, logged deletion from an index.  The index
//  will be acquired exclusive for this call.  No maps are currently outstanding
//  on this index.
//
//  This call may update the IndexHandle seek position
//

NTFSAPI
VOID
NtOfsDeleteRecords (
    IN PIRP_CONTEXT IrpContext,
    IN INDEX_HANDLE IndexHandle,
    IN ULONG Count,
    IN PINDEX_KEY IndexKey
    );

//
//  NtOfsReadRecords applies a match function to a block of contiguous records in
//  the BTree starting either at a given IndexKey or beginning where it last left
//  off.
//
//  IndexKey is an optional point at which to begin the enumeration.  The
//  seek position of IndexHandle is set to return the next logical record
//  on the next NtOfsReadRecords call.
//
//  NtOfsReadRecords will seek to the appropriate point in the BTree (as defined
//  by the IndexKey or saved position and the CollateFunction) and begin calling
//  MatchFunction for each record.  It continues doing this while MatchFunction
//  returns STATUS_SUCCESS.  If MatchFunction returns STATUS_NO_MORE_MATCHES,
//  NtOfsReadRecords will cache this result and not call MatchFunction again until
//  called with a non-NULL IndexKey.
//
//  NtOfsReadRecords returns the last status code returned by MatchFunction.
//
//  The IndexHandle does not have to be acquired as it is acquired shared for the
//  duration of the call.  NtOfsReadRecords may
//  return with STATUS_SUCCESS without filling the output buffer (say, every 10
//  index pages) to reduce lock contention.
//
//  NtOfsReadRecords will read up to Count rows, comprising up to BufferLength
//  bytes in total and will fill in the Rows[] array for each row returned.
//
//  Note that this call is self-synchronized, such that successive calls to
//  the routine are guaranteed to make progress through the index and to return
//  items in Collation order, in spite of Add and Delete record calls being
//  interspersed with Read records calls.
//

NTFSAPI
NTSTATUS
NtOfsReadRecords (
        IN PIRP_CONTEXT IrpContext,
        IN INDEX_HANDLE IndexHandle,
        IN OUT PREAD_CONTEXT *ReadContext,
        IN OPTIONAL PINDEX_KEY IndexKey,
        IN PMATCH_FUNCTION MatchFunction,
        IN PVOID MatchData,
        IN OUT ULONG *Count,
        OUT PINDEX_ROW Rows,
        IN ULONG BufferLength,
        OUT PVOID Buffer
        );

NTFSAPI
VOID
NtOfsFreeReadContext (
        IN PREAD_CONTEXT ReadContext
        );

//
//  NtOfsUpdateRecord updates a single record in place.  It is guaranteed that the
//  length of the data/key portion of the record does not change.  The index will
//  be acquired exclusive for this call.
//
//  This call may update the IndexHandle seek position
//

NTFSAPI
VOID
NtOfsUpdateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN INDEX_HANDLE IndexHandle,
    IN ULONG Count,
    IN PINDEX_ROW IndexRow,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL,
    IN OUT PMAP_HANDLE MapHandle OPTIONAL
    );

//
//  NtOfsCloseIndex closes an index handle.  The index must not be acquired for this
//  call.  No outstanding maps are allowed.
//

NTFSAPI
VOID
NtOfsCloseIndex (
    IN PIRP_CONTEXT IrpContext,
    IN INDEX_HANDLE IndexHandle
    );

//
//  NtOfsDeleteIndex removes an index attribute from an object.  The object will be
//  acquired exclusive for this call.
//

NTFSAPI
VOID
NtOfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle,
    IN INDEX_HANDLE IndexHandle
    );

////////////////////////////////////////////////////////////////////////////////

//
//  Map API - These encapsulate the NtOfs/Cache manager interactions
//

//
//  NtOfsInitializeMapHandle initializes a map handle so it can be safely
//  released at any time.
//
//  NTFSAPI
//  VOID
//  NtOfsInitializeMapHandle (
//      IN PMAP_HANDLE Map
//      );
//

#define NtOfsInitializeMapHandle( M ) { (M)->Bcb = NULL; }

//
//  NtOfsMapAttribute maps a portion of the specified attribute and returns a pointer
//  to the memory.  The memory mapped may not span a mapping window.  Multiple maps
//  are allowed through different handles in different threads.  The data is not
//  preread nor is the memory pinned.
//


#ifndef _NTFSPROC_
NTFSAPI
VOID
NtOfsMapAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    );

#else
#ifdef MAPCOUNT_DBG
#define NtOfsMapAttribute(I,S,O,L,B,M) (                                             \
    CcMapData((S)->FileObject, (PLARGE_INTEGER)&(O), (L), TRUE, &(M)->Bcb, (B)),     \
    (I)->MapCount++,                                                                 \
    (M)->FileOffset = (O),                                                           \
    (M)->Length = (L),                                                               \
    (M)->Buffer = *(PVOID *)(B)                                                      \
)
#else
#define NtOfsMapAttribute(I,S,O,L,B,M) (                                             \
    CcMapData((S)->FileObject, (PLARGE_INTEGER)&(O), (L), TRUE, &(M)->Bcb, (B)),     \
    (M)->FileOffset = (O),                                                           \
    (M)->Length = (L),                                                               \
    (M)->Buffer = *(PVOID *)(B)                                                      \
)
#endif
#endif

//
//  NtOfsPreparePinWrite maps and pins a portion of the specified attribute and
//  returns a pointer to the memory.  This is equivalent to doing a NtOfsMapAttribute
//  followed by NtOfsPinRead and NtOfsDirty but is more efficient.
//

#ifndef _NTFSPROC_
NTFSAPI
VOID
NtOfsPreparePinWrite (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    );

#else
#ifdef MAPCOUNT_DBG
#define NtOfsPreparePinWrite(I,S,O,L,B,M) {                                                     \
    if (((O) + (L)) > (S)->Header.AllocationSize.QuadPart) {                                    \
        ExRaiseStatus(STATUS_END_OF_FILE);                                                      \
    }                                                                                           \
    CcPreparePinWrite((S)->FileObject, (PLARGE_INTEGER)&(O), (L), FALSE, TRUE, &(M)->Bcb, (B)); \
    (I)->MapCount++;                                                                            \
    (M)->FileOffset = (O);                                                                      \
    (M)->Length = (L);                                                                          \
    (M)->Buffer = (B);                                                                          \
}
#else
#define NtOfsPreparePinWrite(I,S,O,L,B,M) {                                                     \
    if (((O) + (L)) > (S)->Header.AllocationSize.QuadPart) {                                    \
        ExRaiseStatus(STATUS_END_OF_FILE);                                                      \
    }                                                                                           \
    CcPreparePinWrite((S)->FileObject, (PLARGE_INTEGER)&(O), (L), FALSE, TRUE, &(M)->Bcb, (B)); \
    (M)->FileOffset = (O);                                                                      \
    (M)->Length = (L);                                                                          \
    (M)->Buffer = (B);                                                                          \
}
#endif
#endif

//
//  NtOfsPinRead pins a section of a map and read in all pages from the mapped
//  attribute.  Offset and Length must describe a byte range which is equal to
//  or included by the original mapped range.
//

#ifndef _NTFSPROC_
NTFSAPI
VOID
NtOfsPinRead(
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PMAP_HANDLE MapHandle
    );

#else
#ifdef MAPCOUNT_DBG
#define NtOfsPinRead(I,S,O,L,M) {                                                           \
    ASSERT((M)->Bcb != NULL);                                                               \
    ASSERT(((O) >= (M)->FileOffset) && (((O) + (L)) <= ((M)->FileOffset + (M)->Length)));   \
    CcPinMappedData((S)->FileObject, (PLARGE_INTEGER)&(O), (L), TRUE, &(M)->Bcb);           \
    (I)->MapCount++;                                                                        \
    (M)->FileOffset = (O);                                                                  \
    (M)->Length = (L);                                                                      \
}
#else
#define NtOfsPinRead(I,S,O,L,M) {                                                           \
    ASSERT((M)->Bcb != NULL);                                                               \
    ASSERT(((O) >= (M)->FileOffset) && (((O) + (L)) <= ((M)->FileOffset + (M)->Length)));   \
    CcPinMappedData((S)->FileObject, (PLARGE_INTEGER)&(O), (L), TRUE, &(M)->Bcb);           \
    (M)->FileOffset = (O);                                                                  \
    (M)->Length = (L);                                                                      \
}
#endif
#endif

//
//  NtOfsDirty marks a map as being dirty (eligible for lazy writer access) and
//  marks the pages with an optional LSN for coordination with LFS.  This call
//  is invalid unless the map has been pinned.
//

//  NTFSAPI
//  NtOfsDirty (
//      IN PIRP_CONTEXT IrpContext,
//      IN PMAP_HANDLE MapHandle,
//      PLSN Lsn OPTIONAL
//      );

#define NtOfsDirty(I,M,L) {CcSetDirtyPinnedData((M)->Bcb,(L));}

//
//  NtOfsReleaseMap unmaps/unpins a mapped portion of an attribute.
//


#ifndef _NTFSPROC_
NTFSAPI
VOID
NtOfsReleaseMap (
    IN PIRP_CONTEXT IrpContext,
    IN PMAP_HANDLE MapHandle
    );

#else

#ifdef MAPCOUNT_DBG
#define NtOfsReleaseMap(IC,M) {                             \
    if ((M)->Bcb != NULL) {                                 \
        CcUnpinData((M)->Bcb);                              \
        (IC)->MapCount--;                                   \
        (M)->Bcb = NULL;                                    \
    }                                                       \
}
#else
#define NtOfsReleaseMap(IC,M) {                             \
    if ((M)->Bcb != NULL) {                                 \
        CcUnpinData((M)->Bcb);                              \
        (M)->Bcb = NULL;                                    \
    }                                                       \
}
#endif
#endif

//
//  NtOfsPutData writes data into an attribute in a recoverable fashion.  The
//  caller must have opened the attribute with LogNonresidentToo.
//
//  NtOfsPutData will write the data atomically and update the mapped image,
//  subject to the normal lazy commit of the transaction.
//

NTFSAPI
VOID
NtOfsPutData (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Offset,
    IN ULONG Length,
    IN PVOID Data OPTIONAL
    );


////////////////////////////////////////////////////////////////////////////////

//
//  Attribute API - These encapsulate access to attributes on files/directories
//  and summary catalogs
//

//
//  NtOfsCreateAttribute will create or open a data attribute and return a handle
//  that will allow mapping operations.
//
//  For attributes that wish to have logging behavior, LogNonresidentToo must be
//  set to true.  See the discussion on NtOfsPutData (in the mapping section
//  above).
//

NTFSAPI
NTSTATUS
NtOfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG LogNonresidentToo,
    OUT ATTRIBUTE_HANDLE *AttributeHandle
    );

//
//  NtOfsCreateAttributeEx will create or open an attribute and return a handle
//  that will allow mapping operations.  If a standard data attribute is to be
//  used, call NtOfsCreateAttribute instead.  This function is here for callers
//  who need to use a different attribute type code.
//
//  For attributes that wish to have logging behavior, LogNonresidentToo must be
//  set to true.  See the discussion on NtOfsPutData (in the mapping section
//  above).
//

NTFSAPI
NTSTATUS
NtOfsCreateAttributeEx (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle,
    IN UNICODE_STRING Name,
    IN ULONG AttributeTypeCode,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG LogNonresidentToo,
    OUT ATTRIBUTE_HANDLE *AttributeHandle
    );

//
//  Valid AttributeTypeCode values for NtOfsCreateAttributeEx:
//

#define $LOGGED_UTILITY_STREAM           (0x100)


//
//  NtOfsCloseAttribute releases the attribute.  The attribute is not acquired.  No
//  outstanding maps are active.
//

NTFSAPI
VOID
NtOfsCloseAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE AttributeHandle
    );

//
//  NtOfsDeleteAttribute releases all storage associated with the attribute.  The
//  object will be acquired exclusive.  The attribute will be acquired exclusive.
//  No outstanding maps are active.
//

NTFSAPI
VOID
NtOfsDeleteAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle,
    IN ATTRIBUTE_HANDLE AttributeHandle
    );

//
//  NtOfsQueryLength returns the current length of user data within the attribute.
//  The attribute may be mapped.  The attribute may be acquired.
//

NTFSAPI
LONGLONG
NtOfsQueryLength (
    IN ATTRIBUTE_HANDLE AttributeHandle
    );

//
//  NtOfsSetLength sets the current EOF on the given attribute.  The attribute
//  may not be mapped to the view containing Length, or any subsequent view.
//  The attribute will be acquired exclusive.
//

NTFSAPI
VOID
NtOfsSetLength (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Length
    );
//
//  NtOfsWaitForNewLength allows the caller to wait for the specified length to
//  be exceeded, or optionally timeout, if the specified Irp has not been cancelled.
//

NTFSAPI
NTSTATUS
NtOfsWaitForNewLength (
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Length,
    IN ULONG Async,
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//
//  This routine may be called any time FileSize has changed to wake any threads
//  waiting for a particular FileSize change.  Or specify WakeAll to unconditionally
//  wake all waiters.
//

VOID
NtOfsPostNewLength (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN ATTRIBUTE_HANDLE Attribute,
    IN BOOLEAN WakeAll
    );

//
//  NtOfsDecommit releases storage associated with a range of the attribute.  It does
//  not change the EOF marker nor does it change the logical position of data within
//  the attribute.  The range of the attribute being released may be mapped or
//  pinned.
//
//  Reads from decommitted ranges should return zero (although Query will never read
//  from these ranges).
//
//  Writes to decommitted pages should fail or be nooped (although Query will never
//  write to these ranges).
//
//  This call will purge, so none of the views overlapping the specified range may
//  be mapped.
//

NTFSAPI
VOID
NtOfsDecommit (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN LONGLONG Offset,
    IN LONGLONG Length
    );

//
//  NtOfsFlushAttribute flushes all cached data to the disk and returns upon
//  completion.  If the attribute is LogNonresidentToo, then only the log file
//  is flushed.  Optionally, the range may be purged as well.  If the attribute
//  is purged, then there can be no mapped views.
//

NTFSAPI
VOID
NtOfsFlushAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    IN ULONG Purge
    );

//
//  NtOfsQueryAttributeSecurityId returns the security ID for the attribute if
//  present.
//

NTFSAPI
VOID
NtOfsQueryAttributeSecurityId (
    IN PIRP_CONTEXT IrpContext,
    IN ATTRIBUTE_HANDLE Attribute,
    OUT SECURITY_ID *SecurityId
    );

////////////////////////////////////////////////////////////////////////////////

//
//  Concurrency control API
//
//  As a rule, these routines are not required.  All NtOfs routines are
//  self-synchronized as atomic actions, or as parts of a top-level action when
//  called within a top-level action routine.
//
//  ISSUE:  In particular, supporting the exclusive access call is an implementation
//          problem for Ntfs.  Wrapping top-level actions is the best way to preserve
//          exclusive access across calls.
//

VOID
NtOfsAcquireObjectShared (
    HANDLE ObjectHandle
    );

//  VOID
//  NtOfsAcquireObjectExclusive (
//      HANDLE ObjectHandle
//      );

VOID
NtOfsReleaseObject (
    HANDLE ObjectHandle
    );

//  Debugging routines
BOOLEAN
NtOfsIsObjectAcquiredExclusive (
    HANDLE ObjectHandle
    );

BOOLEAN
NtOfsIsObjectAcquiredShared (
    HANDLE ObjectHandle
    );


////////////////////////////////////////////////////////////////////////////////

//
//  File/Directory/Etc API
//

//
//  NtOfsOpenByFileReference opens an object given a file reference.  The file is
//  assumed to exist; this call cannot be used to create a file.  The returned
//  handle is acquired according to the input exclusion.
//

NTFSAPI
NTSTATUS
NtOfsOpenByFileReference (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_REFERENCE FileReference,
    IN EXCLUSION Exclusion,
    OUT OBJECT_HANDLE *ObjectHandle
    );

//
//  NtOfsCreateRelativeObject opens or creates an object relative to a specified
//  parent object.  The parent will be acquired exclusive.  The child is opened
//  acquired according to the input exclusion.
//
//  ISSUE:  When creating an object, is the transaction committed before this
//  call returns?
//

NTFSAPI
NTSTATUS
NtOfsCreateRelativeObject (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ParentObjectHandle,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN EXCLUSION Exclusion,
    OUT OBJECT_HANDLE *ObjectHandle
    );

//
//  NtOfsCloseObject releases the object handle.
//

NTFSAPI
NTSTATUS
NtOfsCloseObject (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle
    );

//
//  NtOfsDeleteObject deletes the object.  No user-mode handle is attached to
//  the object.  No attributes are currently open.  The object is acquired
//  exclusive.
//

NTFSAPI
NTSTATUS
NtOfsDeleteObject (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle
    );

//
//  NtOfsDeleteAllAttributes deletes all attributes of the object.  No attribute
//  is open.  The object is acquired exclusive.
//

NTFSAPI
NTSTATUS
NtOfsDeleteAllAttributes (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle
    );

//
//  NtOfsQueryPathFromRoot returns *A* path from the root to a node.  In the
//  presence of hard links, several paths may exist, however, only one needs
//  to be returned.  Memory for the file name is provided by the caller.
//

NTFSAPI
NTSTATUS
NtOfsQueryPathFromRoot (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_REFERENCE FileReference,
    OUT UNICODE_STRING *PathName
    );

//
//  NtOfsQueryFileName returns the final component in the path name into a
//  caller-supplied buffer.  In the presence of hard links, several names
//  may exist, however, only one needs to be returned.
//

NTFSAPI
NTSTATUS
NtOfsQueryFileName (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_REFERENCE FileReference,
    OUT UNICODE_STRING *FileName
    );

//
//  NtOfsQueryFileReferenceFromName returns the file reference named by the path
//

NTFSAPI
NTSTATUS
NtOfsQueryFileReferenceFromName (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING Name,
    OUT FILE_REFERENCE *FileReference
    );

//
//  This call must be very fast;  it is a very common call made by CI/Query.
//

NTFSAPI
NTSTATUS
NtOfsQueryFileReferenceFromHandle (
    IN OBJECT_HANDLE Object,
    OUT FILE_REFERENCE *FileReference
    );

//
//  NtOfsQueryObjectSecurityId returns the security Id associated with an object.
//  The object is acquired shared or exclusive.  This call must be very fast
//

NTFSAPI
NTSTATUS
NtOfsQueryObjectSecurityId (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ObjectHandle,
    OUT SECURITY_ID *SecurityId
    );


////////////////////////////////////////////////////////////////////////////////

//
//  Scope API
//

//
//  NtOfsIsAncestorOf must quickly tell if one file is an ancestor of the given
//  child.  In the presence of hard links, we may pick a "preferred" path (i.e.
//  we don't have to travel to all ancestors).  This call must be reasonably fast
//  since this is a very frequent call from Query.
//

NTFSAPI
NTSTATUS
NtOfsIsAncestorOf (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_REFERENCE Ancestor,
    IN FILE_REFERENCE Child
    );

//
//  NtOfsGetParentFileReferenceFromHandle is used to retrieve the FileReference
//  of the parent of the named object.  With hard links the "first" parent may
//  be chosen.  This call needs to be reasonably efficient.
//

NTFSAPI
NTSTATUS
NtOfsGetParentFileReferenceFromHandle (
    IN PIRP_CONTEXT IrpContext,
    IN OBJECT_HANDLE ChildObject,
    OUT FILE_REFERENCE *ParentFileReference
    );


////////////////////////////////////////////////////////////////////////////////

//
//  Security API
//
//  NtOfs maintains a "per-IrpContext" cache that speeds up security validation.
//  Clients clear the cache (at the beginning of a query, say) and then do
//  successive probes which may populate the cache.
//

//
//  NtOfsClearSecurityCache clears the cache.
//

NTFSAPI
NTSTATUS
NtOfsClearSecurityCache (
    IN PIRP_CONTEXT IrpContext
    );

//
//  NtOfsIsAccessGranted uses the Se routines to validate access and caches the
//  result for the specified SecurityId and DesiredAccess.  The cache is first
//  probed to see if the access can be granted immediately.  If the SecurityId is
//  not found, the corresponding ACL is retrieved and tested with the supplied
//  access state and DesiredAccess.  The result of this test is cached and
//  returned.
//

NTFSAPI
NTSTATUS
NtOfsIsAccessGranted (
    IN PIRP_CONTEXT IrpContext,
    IN SECURITY_ID SecurityId,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_STATE *SecurityAccessState
    );


////////////////////////////////////////////////////////////////////////////////

//
//  Worker thread stuff.  Worker threads are needed for building new indexes
//


////////////////////////////////////////////////////////////////////////////////

//
//  Miscellaneous information query/set
//

//
//  Content Index may need to mark the volume as dirty to allow garbage collection
//  of orphan objects by CHKDSK.
//

NTFSAPI
NTSTATUS
NtOfsMarkVolumeCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG NewState,
    IN ULONG StateMask,
    OUT ULONG *OldState
    );

//
//  NtOfsQueryVolumeStatistics returns the current capacity and free space on a
//  volume.  Ci uses this for heuristics to decide on when to trigger master merge,
//  when to suppress master merge, etc.
//

NTFSAPI
NTSTATUS
NtOfsQueryVolumeStatistics (
    IN PIRP_CONTEXT IrpContext,
    OUT LONGLONG *TotalClusters,
    OUT LONGLONG *FreeClusters
    );

//
//  Query needs to retain some state in the NtOfs Ccb.
//

NTFSAPI
NTSTATUS
NtOfsQueryHandleState (
    IN PIRP_CONTEXT IrpContext,
    OUT VOID *OldData
    );

NTFSAPI
NTSTATUS
NtOfsSetHandleState (
    IN PIRP_CONTEXT IrpContext,
    IN VOID *Data
    );

//
//  Generic unwrapping routines that get access to SCB/IRPC and FCB/IRPC
//  pairs.
//

NTFSAPI
NTSTATUS
NtOfsQueryAttributeHandle (
    IN PIRP_CONTEXT IrpContext,
    OUT ATTRIBUTE_HANDLE *AttributeHandle
    );

NTFSAPI
NTSTATUS
NtOfsQueryObjectHandle (
    IN PIRP_CONTEXT IrpContext,
    OUT OBJECT_HANDLE *ObjectHandle
    );

//
//  Create a context in which the caller can perform I/O in separate.
//  threads.  This means creating an IRP/IRP_CONTEXT.  Each IrpContext corresponds
//  to one I/O activity at a time.  Multiple IrpContexts may be active in a thread
//  at a single time.
//

NTFSAPI
NTSTATUS
NtOfsCloneIrpContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PIRP_CONTEXT *NewIrpContext
    );

//
//  NtOfsCompleteRequest completes an IrpContext that has been previously cloned.
//  All other FsCtl Irps are completed by Ntfs.
//

NTFSAPI
NTSTATUS
NtOfsCompleteRequest (
    IN PIRP_CONTEXT IrpContext,
    NTSTATUS Status
    );


////////////////////////////////////////////////////////////////////////////////

//
//  Iterators.  While each iterator is created through a separate API, each one
//  must support two operations:
//      Next - this fills a buffer with as many records as possible
//      Close - this releases the iterator.
//

typedef struct _BASE_FILE_SEGMENT_ITERATOR BASE_FILE_SEGMENT_ITERATOR;

typedef struct _USN_ITERATOR USN_ITERATOR;

//
//  The types of iterators are:
//
//      Scope            iterate over a directory (optionally RECURSIVE)
//                       (implemented in Query)
//      View             iterate over the rows in a view with a partial key match
//                       (implemented in View)
//      BaseFileSegment  iterate over all base file record segments
//                       (implemented in NtOfs)
//      SummaryCatalog   iterate over all rows in a summary catalog
//      Usn              iterate over all objects with Usn's in a specific range
//                       (implmented in NtOfs)
//
//  Each iteration is passed a buffer which is filled (as much as possible) with
//  a packed array of:
//      FILE_REFERENCE
//      DUPLICATED_INFORMATION
//      STAT_INFORMATION
//  for each enumerated object.  The output length is the length in bytes that
//  was filled in with the enumeration request.

NTFSAPI
NTSTATUS
NtOfsCreateBaseFileSegmentIterator (
    IN PIRP_CONTEXT IrpContext,
    OUT BASE_FILE_SEGMENT_ITERATOR *Iterator
    );

NTFSAPI
NTSTATUS
NtOfsNextBaseFileSegmentIteration (
    IN PIRP_CONTEXT IrpContext,
    IN BASE_FILE_SEGMENT_ITERATOR *Iterator,
    IN OUT ULONG *BufferLength,
    IN OUT PVOID Buffer
    );

NTFSAPI
NTSTATUS
NtOfsCloseBaseFileSegmentIterator (
    IN PIRP_CONTEXT IrpContext,
    IN BASE_FILE_SEGMENT_ITERATOR *Iterator
    );

NTFSAPI
NTSTATUS
NtOfsCreateUsnIterator (
    IN PIRP_CONTEXT IrpContext,
    IN USN BeginningUsn,
    IN USN EndingUsn,
    OUT USN_ITERATOR *Iterator
    );

NTFSAPI
NTSTATUS
NtOfsNextUsnIteration (
    IN PIRP_CONTEXT IrpContext,
    IN USN_ITERATOR *Iterator,
    IN OUT ULONG *BufferLength,
    IN OUT PVOID Buffer
    );

NTFSAPI
NTSTATUS
NtOfsCloseUsnIterator (
    IN PIRP_CONTEXT IrpContext,
    IN USN_ITERATOR *Iterator
    );


////////////////////////////////////////////////////////////////////////////////

//
//  Infrastructure support.
//
//  V/C/X register callbacks with NtOfs when they are loaded.  Until they are loaded
//  NtOfs will call default routines (that do nothing).
//

typedef enum _NTFS_ADDON_TYPES {
    Encryption = 3
} NTFS_ADDON_TYPES;


////////////////////////////////////////////////////////////////////////////////

//
//  Encryption
//

//
//  Stream Create Status       for FileDirFlag
//

#define STREAM_NEW_OR_EXIST_MASK  0x000f0000
#define FILE_DIR_TYPE_MASK        0x000000ff

#define FILE_NEW                  0x00000001
#define FILE_EXISTING             0x00000002
#define DIRECTORY_NEW             0x00000004
#define DIRECTORY_EXISTING        0x00000008
#define EXISTING_FILE_ENCRYPTED   0x00000010
#define STREAM_NEW                0x00010000
#define STREAM_EXISTING           0x00020000

//
//  Encryption flag         for EncryptionFlag
//

#define STREAM_ENCRYPTED          0x00000001
#define FILE_ENCRYPTED            0x00000002

//
//  Access flags
//
//  NB -- These values are NOT arbitrary.  Notice also that they are not
//        in value order, they are grouped according to their meaning.
//        Their values correspond to FILE_READ_DATA, etc. and
//        TOKEN_HAS_BACKUP_PRIVILEGE, etc.
//

#define READ_DATA_ACCESS          0x01
#define WRITE_DATA_ACCESS         0x02
#define APPEND_DATA_ACCESS        0x04
#define EXECUTE_ACCESS            0x20
#define READ_ATTRIBUTES_ACCESS    0x80
#define WRITE_ATTRIBUTES_ACCESS   0x100

#define BACKUP_ACCESS             0x08
#define RESTORE_ACCESS            0x10
#define TRAVERSE_ACCESS           0x40
#define MANAGE_VOLUME_ACCESS      0x200

//
//  Volume State
//

#define READ_ONLY_VOLUME         0x00000001

typedef NTSTATUS
(*ENCRYPTED_FILE_CREATE) (
    IN OBJECT_HANDLE FileHdl,
    IN OBJECT_HANDLE ParentDir OPTIONAL,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG FileDirFlag,
    IN ULONG VolumeState,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN PVOID FileKeyContext,
    IN OUT PVOID *PKeyContext,
    IN OUT ULONG *ContextLength,
    IN OUT PVOID *PCreateContext,
    IN OUT PBOOLEAN Reserved
    );

typedef NTSTATUS
(*ENCRYPTED_FILE_PRE_CREATE) (
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

typedef NTSTATUS
(*ENCRYPTED_FILE_POST_CREATE) (
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS Status,
    IN OUT PVOID *PCreateContext
    );

typedef NTSTATUS
(*ENCRYPTED_FILE_SYSTEM_CONTROL) (
    IN PVOID PInputBuffer OPTIONAL,
    IN ULONG InputDataLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN OUT ULONG *OutputBufferLength OPTIONAL,
    IN ULONG EncryptionFlag,
    IN ULONG AccessFlag,
    IN ULONG VolumeState,
    IN ULONG FsControlCode,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN ATTRIBUTE_HANDLE Attribute,
    IN OUT PVOID *PContext OPTIONAL,
    IN OUT ULONG *ContextLength OPTIONAL
    );

typedef NTSTATUS
(*ENCRYPTED_FILE_PRE_FILE_SYSTEM_CONTROL) (
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

typedef NTSTATUS
(*ENCRYPTED_FILE_READ)(
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    );

typedef NTSTATUS
(*ENCRYPTED_FILE_WRITE)(
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    );

typedef VOID
(*ENCRYPTED_FILE_CLEANUP)(
    IN OUT PVOID *Context
    );

#define ENCRYPTION_CURRENT_INTERFACE_VERSION 3

#define ENCRYPTION_ALL_STREAMS       0x00000001
#define ENCRYPTION_ALLOW_COMPRESSION 0x00000002

typedef struct _ENCRYPTION_CALL_BACK {
    ULONG InterfaceVersion;
    ULONG ImplementationFlags;
    ENCRYPTED_FILE_CREATE FileCreate;
    ENCRYPTED_FILE_PRE_CREATE PreCreate;
    ENCRYPTED_FILE_POST_CREATE PostCreate;
    ENCRYPTED_FILE_SYSTEM_CONTROL FileSystemControl_1;
    ENCRYPTED_FILE_SYSTEM_CONTROL FileSystemControl_2;
    ENCRYPTED_FILE_PRE_FILE_SYSTEM_CONTROL PreFileSystemControl;
    ENCRYPTED_FILE_READ AfterReadProcess;
    ENCRYPTED_FILE_WRITE BeforeWriteProcess;
    ENCRYPTED_FILE_CLEANUP CleanUp;
} ENCRYPTION_CALL_BACK, *PENCRYPTION_CALL_BACK;

//
//  NtOfsRegisterCallBacks supplies a call table to NtOfs.  Each table has an
//  interface version number.  If the interface version does not exactly match
//  what NtOfs expects, the call will fail.
//

NTFSAPI
NTSTATUS
NtOfsRegisterCallBacks (
    NTFS_ADDON_TYPES NtfsAddonType,
    PVOID CallBackTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\nesyu.h ===
#ifndef NESYU_INC
#define NESYU_INC

#include "nesy.h"

    // This file and the bobbit program are the only documentation on the nesy read only
    // database system.

    //
    // CreateDatabase
    //
    // Creates a new database
    BOOL CreateDatabase(
        LPCTSTR szDatabasePath    // directory where the database is to be created.
    );

    // Returns a buffer with the blob ids listed. The caller is responsible for freeing
    // this buffer when finished with it.

    //
    // List
    //
    // Returns a buffer with the blobs from iBeginID to iEndID listed. The caller is
    // responsible for freeing this buffer when finished with it.

    BOOL List(
        int iLevel,             // Level of information desired, 0 lists the blobs only, 1 lists the contents of the blob as well.
        LPCTSTR szDatabasePath,   // directory path where database is, use ".\\" to specify the current directory.
        int iBeginID,           // Beginning blob id to list, -1 means begin at beginning of the database.
        int iEndID              // ending blob id to list, -1 means no end blob so all are listed.
    );

    //
    // SearchDatabase
    //
    // Returns a buffer with the blob ids listed. The caller is responsible for freeing
    // this buffer when finished with it.

    BOOL SearchDatabase(
        LPCTSTR szSearchString,   // search string to be found in database.
        int iLevel,             // Level of information desired, 0 lists the blobs only, 1 lists the contents of the blob as well.
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );

    //
    // UpdateBlob
    //
    // Updates a specific blob in the database with the specified file.
    // The return value is the blob id if successfull or -1 if an error occurs.

    int UpdateBlob(
        int blobID,             // blob id to add to the database
        LPCTSTR szBlobFile,       // blob file to be added to the database
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );

    //
    // UpdateBlob
    //
    // Updates a specific blob in the database with the blob in memory.
    // The return value is the blob id if successfull or -1 if an error occurs.

    int UpdateBlob(
        int blobID,             // blob id to add to the database
        LPVOID pBlob,           // memory buffer containing blob to be added to the database.
        DWORD dwBlobSize,       // size of blob to be added to the database.
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );

    //
    // WriteBlob
    //
    // Write a specific blob file to the database. Pass in -1 for the blob id to
    // add a new blob to the database. The return value is the blob id
    // if successfull or -1 if an error occurs.
    int WriteBlob(
        int blobID,             // blob id to add to the database
        LPCTSTR szBlobFile,       // blob file to be added to the database
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );

    //
    // WriteBlob
    //
    // Write a specific blob in memory to the database. Pass in -1 for the blob id to
    // add a new blob to the database. The return value is the blob id
    // if successfull or -1 if an error occurs.
    int WriteBlob(
        int blobID,             // blob id to add to the database
        LPVOID pBlob,           // memory buffer containing blob to be added to the database.
        DWORD dwBlobSize,       // size of blob to be added to the database.
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );

    //
    // DeleteBlob
    //
    // delete the specified blob. returns TRUE if successfull or FALSE if not.
    BOOL DeleteBlob(
        int blobID,             // blob id to add to the database
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );


    //
    // AddShimDll
    //
    // Adds a new shim dll to the database's blob 0. This API returns the blob id if successfull or -1 if an
    // error occurs. In the case of an error GetLastError() can be checked to get additional information
    // as to the specific cause of the error.

    int AddShimDll(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the blob is successfully added then this pointer is updated with the new blob0
        DWORD *pdwShimID,       // If successful, passes back the ID of the shim DLL record created
        LPCTSTR szBlobFile,       // Shim DLL to be added to the database
        LPCTSTR szDatabasePath    // directory path where database is, use ".\\" to specify the current directory.
    );

    //
    // AddPatchBlob
    //
    // Adds a new shim dll to the database's blob 0. This API returns the blob id if successfull or -1 if an
    // error occurs. In the case of an error GetLastError() can be checked to get additional information
    // as to the specific cause of the error.

    int AddPatchBlob(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the blob is successfully added then this pointer is updated with the new blob0
        LPCTSTR szBlobFile,     // Patch blob to be added to the database
        LPCTSTR szDescription,  // Description of this patch, this is for information purposes only.
        LPCTSTR szDatabasePath  // directory path where database is, use ".\\" to specify the current directory.
    );
    //
    // AddExe
    //
    // This method adds a new exe to blob 0. Then function returns the unique id of the exe that was added. This id can
    // be used to later identify the exe. In the case of an error this function returns 0. The function GetLastError()
    // can then be checked to determine the cause of the error.

    DWORD AddExe(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the exe is successfully added then this pointer is updated with the new blob0
        PDWORD pdwBlobPatchID,  // array for DWORDs that identify the patch DLL's to be used for this exe
        DWORD dwTotalPatchBlobs,// total patch blobs in previous array.
        PLARGE_INTEGER pqwFlags,// Flags associated with this exe.
        LPCTSTR szFileName      // exe that is to be hooked with the shim DLL's identified by the pdwBlobID parameter.
    );

    //
    // AddGlobalInclude
    //
    // Adds a module to the global include list. This list will largely or completely consist of windows system
    // DLLs that shouldn't be patched, so mostly it will be exclusions. 
    // This list can be overridden by inclusion lists at the DLL or EXE level
    // returns TRUE/FALSE for success.

    BOOL AddGlobalInclude(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the blob is successfully added then this pointer is updated with the new blob0
        INCTYPE eType,          // the type: INCLUDE or EXCLUDE
        LPCTSTR szModule,       // The module to exclude from shimming
        LPCTSTR szAPI,          // the specific API call that should be excluded, or NULL for all APIs
        DWORD dwModuleOffset    // used to specify a specific call instance that should be excluded
    );

    //
    // AddShimDllInclude
    //
    // Adds an include item to the Shim DLL record, which allows a shim dll to shim a DLL which would otherwise
    // be excluded by the global exclusion list. Otherwise much like AddGlobalExclude.
    BOOL AddShimDllInclude(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the blob is successfully added then this pointer is updated with the new blob0
        DWORD dwShimID,         // the ID of the shim record, passed back from AddShimDLL
        INCTYPE eType,          // the type: INCLUDE or EXCLUDE
        LPCTSTR szModule,        // the module to add to the shim list
        LPCTSTR szAPI,           // the specific API to include
        DWORD dwModuleOffset    // used to specify a specific call instance that should be included
    );

    //
    // AddDllRef
    //
    // Adds to an Exe record a reference to a shim DLL that should be loaded when the executable is loaded
    // Inclusions or exclusions of specific modules or calls can be added later by 
    BOOL AddDllRef(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the blob is successfully added then this pointer is updated with the new blob0
        DWORD dwExeID,          // the exe ID, passed back from AddExe
        DWORD *pdwDllRefID,     // passes back the Dll ref ID, used to add include/exclude info later
        DWORD dwBlobID          // the blob ID of the dll that should be added
    );

    //
    // AddDllRefInclude
    //
    // Adds an include item to the DLL ref record, which allows adding a DLL for a specific exe which would otherwise
    // be excluded by the global exclusion list or the Shim DLL exclusion list. Otherwise much like AddGlobalExclude.
    BOOL AddDllRefInclude(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the blob is successfully added then this pointer is updated with the new blob0
        DWORD dwDllRefID,       // the ID of the Dll ref record, passed back from AddDllRef          
        INCTYPE eType,          // the type: INCLUDE or EXCLUDE
        LPCTSTR szModule,        // the module to add to the shim list                              
        LPCTSTR szAPI,           // the specific API to include                                     
        DWORD dwModuleOffset    // used to specify a specific call instance that should be included
    );
    
    //
    // AddMatchingInfo
    //
    // This method adds a new matching file to an exe in blob 0. The exe is identified by the id returned from the AddExe
    // method. This method returns TRUE if the matching info is successfully added or FALSE if an error occurs. In the case
    // of an failure the GetLastError() function can be checked to determine the cause of the error.

    BOOL AddMatchingInfo(
        PBLOB0 *ppBlob0,        // Blob 0 pointer. If the exe is successfully added then this pointer is updated with the new blob0
        DWORD dwExeID,          // Exe id where matching info is to be added. This id is returned from the AddExe function.
        LPCTSTR szFileName,      // relative path file name of the matching file. This path is relative to the exe file
                                // that this matching file is being added to.
        DWORD dwSize = 0,       // Size of the matching file. This parameter can be 0 if size is not to be a criteria.
        DWORD dwCrc = 0,        // Crc of the matching file. This parameter can be 0 if size is not to be a criteria.
        PFILETIME pFt = NULL    // file time of the matching file. This parameter can be 0 if size is not to be a criteria.
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntacpi.h ===
;/*++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
; Module Name:
;
;   ntacpi.h
;
; Abstract:
;
;
;   This module contains definitions specific to the HAL's
;   ACPI function.
;
; Author:
;
;   Jake Oshins (jakeo) Feb. 18, 1997
;
; Revision History:
;
;-

if 0        ; Begin C only code         */

#ifndef _ACPI_H_
#define _ACPI_H_


#define SLEEP_STATE_FLUSH_CACHE         0x1
#define SLEEP_STATE_FIRMWARE_RESTART    0x2
#define SLEEP_STATE_SAVE_MOTHERBOARD    0x4
#define SLEEP_STATE_OFF                 0x8
#define SLEEP_STATE_RESTART_OTHER_PROCESSORS    0x10

typedef struct {
    union {
        struct {
            ULONG       Pm1aVal:4;
            ULONG       Pm1bVal:4;
            ULONG       Flags:24;
        } bits;
        ULONG   AsULONG;
    };
} SLEEP_STATE_CONTEXT, *PSLEEP_STATE_CONTEXT;


//
// ACPI Register definitions
//

#define P_LVL2          4
#define PBLK_THT_EN                     0x10

//
// Register layout of PM1x_EVT register
// Note also defined in acpiregs.h
//

#define PM1_PWRBTN_STS_BIT      8
#define PM1_PWRBTN_STS          (1 << PM1_PWRBTN_STS_BIT)

//
// Register layout of PM1x_CTL
//

#define SCI_EN              1
#define BM_RLD              2
#define CTL_IGNORE          0x200
#define SLP_TYP_SHIFT       10
#define SLP_EN              0x2000

#define CTL_PRESERVE        (SCI_EN + BM_RLD + CTL_IGNORE)

#define PM_TMR_FREQ     3579545



//
// HAL's table
//

typedef enum {
    HalAcpiTimerInit,
    HalAcpiTimerInterrupt,
    HalAcpiMachineStateInit,
    HalAcpiQueryFlags,
    HalPicStateIntact,
    HalRestorePicState,
    HalPciInterfaceReadConfig,
    HalPciInterfaceWriteConfig,
    HalSetVectorState,
    HalGetIOApicVersion,
    HalSetMaxLegacyPciBusNumber,
    HalIsVectorValid,
    HalAcpiMaxFunction
} HAL_DISPATCH_FUNCTION;

typedef
VOID
(*pHalAcpiTimerInit)(
    IN ULONG    TimerPort,
    IN BOOLEAN  TimerValExt
    );

typedef
VOID
(*pHalAcpiTimerInterrupt)(
    VOID
    );

typedef struct {
    ULONG   Count;
    ULONG   Pblk[1];
} PROCESSOR_INIT, *PPROCESSOR_INIT;

#define HAL_C1_SUPPORTED 0x01
#define HAL_C2_SUPPORTED 0x02
#define HAL_C3_SUPPORTED 0x04
#define HAL_S1_SUPPORTED 0x08
#define HAL_S2_SUPPORTED 0x10
#define HAL_S3_SUPPORTED 0x20
#define HAL_S4_SUPPORTED 0x40
#define HAL_S5_SUPPORTED 0x80

typedef struct {
    BOOLEAN     Supported;
    UCHAR       Pm1aVal;
    UCHAR       Pm1bVal;
} HAL_SLEEP_VAL, *PHAL_SLEEP_VAL;

typedef
VOID
(*pHalAcpiMachineStateInit)(
    IN  PPROCESSOR_INIT ProcInit,
    IN  PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG          PicVal
    );

typedef
ULONG
(*pHalAcpiQueryFlags)(
    VOID
    );

typedef
BOOLEAN
(*pHalPicStateIntact)(
    VOID
    );

typedef
VOID
(*pHalRestorePicState)(
    VOID
    );

typedef
ULONG
(*pHalInterfaceReadWriteConfig)(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Flags for interrupt vectors
//

#define VECTOR_MODE         1
#define VECTOR_LEVEL        1
#define VECTOR_EDGE         0
#define VECTOR_POLARITY     2
#define VECTOR_ACTIVE_LOW   2
#define VECTOR_ACTIVE_HIGH  0

//
// Vector Type:
//
// VECTOR_SIGNAL = standard edge-triggered or
//		   level-sensitive interrupt vector
//
// VECTOR_MESSAGE = an MSI (Message Signalled Interrupt) vector
//

#define VECTOR_TYPE         4
#define VECTOR_SIGNAL       0
#define VECTOR_MESSAGE      4

#define IS_LEVEL_TRIGGERED(vectorFlags) \
    (vectorFlags & VECTOR_LEVEL)

#define IS_EDGE_TRIGGERED(vectorFlags) \
    !(vectorFlags & VECTOR_LEVEL)

#define IS_ACTIVE_LOW(vectorFlags) \
    (vectorFlags & VECTOR_ACTIVE_LOW)

#define IS_ACTIVE_HIGH(vectorFlags) \
    !(vectorFlags & VECTOR_ACTIVE_LOW)

typedef
VOID
(*pHalSetVectorState)(
    IN ULONG Vector,
    IN ULONG Flags
    );

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    );

#define HAL_ACPI_PCI_RESOURCES    0x01
#define HAL_ACPI_PRT_SUPPORT      0x02

typedef
ULONG
(*pHalGetIOApicVersion)(
    IN ULONG ApicNo
    );

typedef
VOID
(*pHalSetMaxLegacyPciBusNumber)(
    IN ULONG BusNumber
    );

typedef
BOOLEAN
(*pHalIsVectorValid)(
    IN ULONG Vector
    );

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    );

//
//  typedef struct _PM_DISPATCH_TABLE {
//      ULONG   Signature;
//      ULONG   Version;
//      PVOID   Function[1];
//  } PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;
//

typedef struct {
    ULONG   Signature;
    ULONG   Version;
    pHalAcpiTimerInit               HalpAcpiTimerInit;
    pHalAcpiTimerInterrupt          HalpAcpiTimerInterrupt;
    pHalAcpiMachineStateInit        HalpAcpiMachineStateInit;
    pHalAcpiQueryFlags              HalpAcpiQueryFlags;
    pHalPicStateIntact              HalxPicStateIntact;
    pHalRestorePicState             HalxRestorePicState;
    pHalInterfaceReadWriteConfig    HalpPciInterfaceReadConfig;
    pHalInterfaceReadWriteConfig    HalpPciInterfaceWriteConfig;
    pHalSetVectorState              HalpSetVectorState;
    pHalGetIOApicVersion            HalpGetIOApicVersion;
    pHalSetMaxLegacyPciBusNumber    HalpSetMaxLegacyPciBusNumber;
    pHalIsVectorValid               HalpIsVectorValid;
} HAL_ACPI_DISPATCH_TABLE, *PHAL_ACPI_DISPATCH_TABLE;

#define HAL_ACPI_DISPATCH_SIGNATURE   'HAL '
#define HAL_ACPI_DISPATCH_VERSION     2

#define HalAcpiTimerInit            ((pHalAcpiTimerInit)PmHalDispatchTable->Function[HalAcpiTimerInit])
#define HalAcpiTimerInterrupt       ((pHalAcpiTimerInterrupt)PmHalDispatchTable->Function[HalAcpiTimerInterrupt])
#define HalAcpiMachineStateInit     ((pHalAcpiMachineStateInit)PmHalDispatchTable->Function[HalAcpiMachineStateInit])
#define HalPicStateIntact           ((pHalPicStateIntact)PmHalDispatchTable->Function[HalPicStateIntact])
#define HalRestorePicState          ((pHalRestorePicState)PmHalDispatchTable->Function[HalRestorePicState])
#define HalPciInterfaceReadConfig   ((pHalInterfaceReadWriteConfig)PmHalDispatchTable->Function[HalPciInterfaceReadConfig])
#define HalPciInterfaceWriteConfig  ((pHalInterfaceReadWriteConfig)PmHalDispatchTable->Function[HalPciInterfaceWriteConfig])
#define HalSetVectorState           ((pHalSetVectorState)PmHalDispatchTable->Function[HalSetVectorState])
#define HalGetIOApicVersion         ((pHalGetIOApicVersion)PmHalDispatchTable->Function[HalGetIOApicVersion])
#define HalSetMaxLegacyPciBusNumber ((pHalSetMaxLegacyPciBusNumber)PmHalDispatchTable->Function[HalSetMaxLegacyPciBusNumber])
#define HalIsVectorValid            ((pHalIsVectorValid)PmHalDispatchTable->Function[HalIsVectorValid])

extern PPM_DISPATCH_TABLE PmAcpiDispatchTable;
extern PPM_DISPATCH_TABLE PmHalDispatchTable;

//
// ACPI driver's table
//
typedef enum {
    AcpiEnableDisableGPEvents,
    AcpiInitEnableAcpi,
    AcpiGpeEnableWakeEvents,
    AcpiMaxFunction
} ACPI_DISPATCH_FUNCTION;

typedef
VOID
(*pAcpiEnableDisableGPEvents) (
    IN BOOLEAN Enable
    );

typedef
VOID
(*pAcpiInitEnableAcpi) (
    IN BOOLEAN ReEnable
    );

typedef
VOID
(*pAcpiGpeEnableWakeEvents)(
    VOID
    );

typedef struct {
    ULONG   Signature;
    ULONG   Version;
    pAcpiEnableDisableGPEvents    AcpipEnableDisableGPEvents;
    pAcpiInitEnableAcpi           AcpipInitEnableAcpi;
    pAcpiGpeEnableWakeEvents      AcpipGpeEnableWakeEvents;
} ACPI_HAL_DISPATCH_TABLE, *PACPI_HAL_DISPATCH_TABLE;

#define ACPI_HAL_DISPATCH_SIGNATURE   'ACPI'
#define ACPI_HAL_DISPATCH_VERSION     1

#define AcpiEnableDisableGPEvents       (*(pAcpiEnableDisableGPEvents)PmAcpiDispatchTable->Function[AcpiEnableDisableGPEvents])
#define AcpiInitEnableAcpi              (*(pAcpiInitEnableAcpi)PmAcpiDispatchTable->Function[AcpiInitEnableAcpi])
#define AcpiGpeEnableWakeEvents         (*(pAcpiGpeEnableWakeEvents)PmAcpiDispatchTable->Function[AcpiGpeEnableWakeEvents])

// from detect\i386\acpibios.h
typedef struct {
    PHYSICAL_ADDRESS    Base;
    LARGE_INTEGER       Length;
    ULONGLONG           Type;
} ACPI_E820_ENTRY, *PACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONGLONG           Count;
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE;
 
typedef ACPI_BIOS_MULTI_NODE UNALIGNED *PACPI_BIOS_MULTI_NODE;

typedef enum {
    AcpiAddressRangeMemory = 1,
    AcpiAddressRangeReserved,
    AcpiAddressRangeACPI,
    AcpiAddressRangeNVS,
    AcpiAddressRangeMaximum,
} ACPI_BIOS_E820_TYPE, *PACPI_BIOS_E820_TYPE;


NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    );

#endif //_ACPI_H_

/*
endif
;
;  Begin assembly part of the definitions
;


;
; Register layout of ACPI processor register block
;

P_CNT                   equ     0
P_LVL2                  equ     4
P_LVL3                  equ     5


;
; Register layout of PM1x_EVT register
;

BM_STS              equ       10h
WAK_STS             equ     8000h

;
; Register layout of PM1x_Enable
;

TMR_EN              equ     0001h
GBL_EN              equ     0020h
PWRBTN_EN           equ     0100h
SLPBTN_EN           equ     0200h
RTC_EN              equ     0400h

;
; Register layout of PM1x_CTL
;

SCI_EN              equ     1
BM_RLD              equ     2
CTL_IGNORE          equ     200h
SLP_TYP_SHIFT       equ     10
SLP_EN              equ     2000h

CTL_PRESERVE        equ     (SCI_EN + BM_RLD + CTL_IGNORE)

;
; Register layout of PM2_CNT
;

ARB_DIS             equ     1

;
; ACPI registers, as laid out in HalpFixedAcpiDescTable
;

PM1a_EVT        EQU _HalpFixedAcpiDescTable + 56
PM1b_EVT        EQU _HalpFixedAcpiDescTable + 60
PM1_EVT_LEN     EQU _HalpFixedAcpiDescTable + 88

PM1a_CNT        EQU _HalpFixedAcpiDescTable + 64
PM1b_CNT        EQU _HalpFixedAcpiDescTable + 68

PM2_CNT_BLK     EQU _HalpFixedAcpiDescTable + 72

PM_TMR_BLK      EQU _HalpFixedAcpiDescTable + 76
PM_TMR_FREQ     EQU 3579545

GPE0_BLK        EQU _HalpFixedAcpiDescTable + 80
GPE1_BLK        EQU _HalpFixedAcpiDescTable + 84

GPE0_BLK_LEN    EQU _HalpFixedAcpiDescTable + 92
GPE1_BLK_LEN    EQU _HalpFixedAcpiDescTable + 93

FLUSH_SIZE      EQU _HalpFixedAcpiDescTable + 100
FLUSH_STRIDE    EQU _HalpFixedAcpiDescTable + 102

DUTY_OFFSET     EQU _HalpFixedAcpiDescTable + 104

RTC_DAY_ALRM    EQU _HalpFixedAcpiDescTable + 106
RTC_MON_ALRM    EQU _HalpFixedAcpiDescTable + 107
RTC_CENTURY     EQU _HalpFixedAcpiDescTable + 108
FADT_FLAGS      EQU _HalpFixedAcpiDescTable + 112

;
; FADT flag values
;
WBINVD_SUPPORTED    EQU 1
WBINVD_FLUSH        EQU 2

;
GeneralWakeupEnable EQU 0
RtcWakeupEnable     EQU 1

;
; Constants used in the Context parameter to HaliAcpiSleep
;  (must match C code above)
;
SLEEP_STATE_FLUSH_CACHE         EQU 1
SLEEP_STATE_FIRMWARE_RESTART    EQU 2
SLEEP_STATE_SAVE_MOTHERBOARD    EQU 4
SLEEP_STATE_OFF                 EQU 8
SLEEP_STATE_RESTART_OTHER_PROCESSORS    EQU 10h
CONTEXT_FLAG_SHIFT              EQU 8


;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntosp.h ===
/*++ BUILD Version: 0133    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntosp.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to external projects like Windows and Termsrv

Revision History:

--*/
#ifndef _NTOSP_
#define _NTOSP_

#ifdef _NTDDK_
#error "Can't include ntddk.h and ntosp.h"
#else
#define _NTDDK_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <excpt.h>
#include <ntdef.h>
#include <bugcodes.h>
#include <arc.h>
#include <arccodes.h>
//
// Kernel Mutex Level Numbers (must be globallly assigned within executive)
// The third token in the name is the sub-component name that defines and
// uses the level number.
//

//
// Used by Vdm for protecting io simulation structures
//

#define MUTEX_LEVEL_VDM_IO                  (ULONG)0x00000001

#define MUTEX_LEVEL_EX_PROFILE              (ULONG)0x00000040

//
// The LANMAN Redirector uses the file system major function, but defines
// it's own mutex levels.  We can do this safely because we know that the
// local filesystem will never call the remote filesystem and vice versa.
//

#define MUTEX_LEVEL_RDR_FILESYS_DATABASE    (ULONG)0x10100000
#define MUTEX_LEVEL_RDR_FILESYS_SECURITY    (ULONG)0x10100001

//
// File System levels.
//

#define MUTEX_LEVEL_FILESYSTEM_RAW_VCB      (ULONG)0x11000006

//
// In the NT STREAMS environment, a mutex is used to serialize open, close
// and Scheduler threads executing in a subsystem-parallelized stack.
//

#define MUTEX_LEVEL_STREAMS_SUBSYS          (ULONG)0x11001001

//
// Mutex level used by LDT support on x86
//

#define MUTEX_LEVEL_PS_LDT                  (ULONG)0x1F000000

#ifdef __cplusplus
extern "C" {   // extern "C"
#endif
//
// Define types that are not exported.
//

typedef struct _ACCESS_STATE *PACCESS_STATE;
typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _EJOB *PEJOB;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ERESOURCE *PERESOURCE;
typedef struct _ETHREAD *PETHREAD;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _IRP *PIRP;
typedef struct _KPROCESS *PKPROCESS, *RESTRICTED_POINTER PRKPROCESS;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _KTRAP_FRAME *PKTRAP_FRAME;
typedef struct _LOADER_PARAMETER_BLOCK *PLOADER_PARAMETER_BLOCK;
typedef struct _TRANSLATOR_INTERFACE *PTRANSLATOR_INTERFACE;
typedef struct _HANDLE_TABLE *PHANDLE_TABLE;

//
// Define macros to fix up structure references
//

#define PEProcessToPKProcess(P) ((PKPROCESS)P)

#if defined(_M_AMD64)

PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_AMD64)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)


//
// Define per processor nonpaged lookaside list descriptor structure.
//

struct _NPAGED_LOOKASIDE_LIST;

typedef struct _PP_LOOKASIDE_LIST {
    struct _GENERAL_LOOKASIDE *P;
    struct _GENERAL_LOOKASIDE *L;
} PP_LOOKASIDE_LIST, *PPP_LOOKASIDE_LIST;

//
// Define the number of small pool lists.
//
// N.B. This value is used in pool.h and is used to allocate single entry
//      lookaside lists in the processor block of each processor.

#define POOL_SMALL_LISTS 32

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL


extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

// begin_ntndis
//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

// end_ntndis
//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//
//

typedef struct _KAPC {
    CSHORT Type;
    CSHORT Size;
    ULONG Spare0;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
    CCHAR ApcStateIndex;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is of medium or high importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of high importance, then a DPC interrupt is requested on the
// target processor and the DPC will be processed when the interrupt occurs.
// Otherwise, the DPC execution will be delayed on the target processor until
// the DPC queue depth on the target processor is greater that the maximum
// target depth or the minimum DPC rate on the target processor is less than
// the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed whne the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PULONG_PTR Lock;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;


//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
VOID
(*PKIPI_WORKER)(
    IN PKIPI_CONTEXT PacketContext,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;

#if defined(NT_UP)

#define HOT_STATISTIC(a) a

#else

#define HOT_STATISTIC(a) (KeGetCurrentPrcb()->a)

#endif

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.  In a future compiler this will
// be placed at:
//
//      ULONG Pages[];
//
// Until this declaration is permitted, however, one simply calculates the
// base of the array by adding one to the base MDL pointer:
//
//      Pages = (PULONG) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//


typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000


#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    { if (KeGetCurrentIrql() > APC_LEVEL) { \
          KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
          ASSERT(FALSE); \
       } \
    }
#else
#define PAGED_CODE() NOP_FUNCTION;
#endif

//
// Data structure used to represent client security context for a thread.
// This data structure is used to support impersonation.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_CLIENT_CONTEXT {
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_TOKEN ClientToken;
    BOOLEAN DirectlyAccessClientToken;
    BOOLEAN DirectAccessEffectiveOnly;
    BOOLEAN ServerIsRemote;
    TOKEN_CONTROL ClientTokenControl;
    } SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

//
// where
//
//    SecurityQos - is the security quality of service information in effect
//        for this client.  This information is used when directly accessing
//        the client's token.  In this case, the information here over-rides
//        the information in the client's token.  If a copy of the client's
//        token is requested, it must be generated using this information,
//        not the information in the client's token.  In all cases, this
//        information may not provide greater access than the information
//        in the client's token.  In particular, if the client's token is
//        an impersonation token with an impersonation level of
//        "SecurityDelegation", but the information in this field indicates
//        an impersonation level of "SecurityIdentification", then
//        the server may only get a copy of the token with an Identification
//        level of impersonation.
//
//    ClientToken - If the DirectlyAccessClientToken field is FALSE,
//        then this field contains a pointer to a duplicate of the
//        client's token.  Otherwise, this field points directly to
//        the client's token.
//
//    DirectlyAccessClientToken - This boolean flag indicates whether the
//        token pointed to by ClientToken is a copy of the client's token
//        or is a direct reference to the client's token.  A value of TRUE
//        indicates the client's token is directly accessed, FALSE indicates
//        a copy has been made.
//
//    DirectAccessEffectiveOnly - This boolean flag indicates whether the
//        the disabled portions of the token that is currently directly
//        referenced may be enabled.  This field is only valid if the
//        DirectlyAccessClientToken field is TRUE.  In that case, this
//        value supersedes the EffectiveOnly value in the SecurityQos
//        FOR THE CURRENT TOKEN ONLY!  If the client changes to impersonate
//        another client, this value may change.  This value is always
//        minimized by the EffectiveOnly flag in the SecurityQos field.
//
//    ServerIsRemote - If TRUE indicates that the server of the client's
//        request is remote.  This is used for determining the legitimacy
//        of certain levels of impersonation and to determine how to
//        track context.
//
//    ClientTokenControl - If the ServerIsRemote flag is TRUE, and the
//        tracking mode is DYNAMIC, then this field contains a copy of
//        the TOKEN_SOURCE from the client's token to assist in deciding
//        whether the information at the remote server needs to be
//        updated to match the current state of the client's security
//        context.
//
//
//    NOTE: At some point, we may find it worthwhile to keep an array of
//          elements in this data structure, where each element of the
//          array contains {ClientToken, ClientTokenControl} fields.
//          This would allow efficient handling of the case where a client
//          thread was constantly switching between a couple different
//          contexts - presumably impersonating client's of its own.
//
#if defined(_NTSYSTEM_)

#define NTKERNELAPI

#else

#define NTKERNELAPI DECLSPEC_IMPORT     // wdm ntddk nthal ntndis ntifs

#endif
#define NTHALAPI DECLSPEC_IMPORT            
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#if defined(_WIN64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_HEADER {
    ULONGLONG Alignment;
    ULONGLONG Region;
} SLIST_HEADER;

typedef struct _SLIST_HEADER *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif


//
//  Some simple Rtl routines for IP address <-> string literal conversion
//

struct in_addr;
struct in6_addr;

NTSYSAPI
PSTR
NTAPI
RtlIpv4AddressToStringA (
    IN const struct in_addr *Addr,
    OUT PSTR S
    );

NTSYSAPI
PSTR
NTAPI
RtlIpv6AddressToStringA (
    IN const struct in6_addr *Addr,
    OUT PSTR S
    );

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW (
    IN const struct in_addr *Addr,
    OUT PWSTR S
    );

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW (
    IN const struct in6_addr *Addr,
    OUT PWSTR S
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressA (
    IN PCSTR S,
    IN BOOLEAN Strict,
    OUT PCSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressA (
    IN PCSTR S,
    OUT PCSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW (
    IN PCWSTR S,
    IN BOOLEAN Strict,
    OUT LPCWSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW (
    IN PCWSTR S,
    OUT PCWSTR *Terminator,
    OUT struct in6_addr *Addr
    );

#ifdef UNICODE
#define RtlIpv4AddressToString RtlIpv4AddressToStringW
#define RtlIpv6AddressToString RtlIpv6AddressToStringW
#define RtlIpv4StringToAddress RtlIpv4StringToAddressW
#define RtlIpv6StringToAddress RtlIpv6StringToAddressW
#else
#define RtlIpv4AddressToString RtlIpv4AddressToStringA
#define RtlIpv6AddressToString RtlIpv6AddressToStringA
#define RtlIpv4StringToAddress RtlIpv4StringToAddressA
#define RtlIpv6StringToAddress RtlIpv6StringToAddressA
#endif // UNICODE


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

// end_ntminiport

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data,
    IN ULONG DataLength
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data,
    IN ULONG DataLength // number of words
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data,
    IN ULONG DataLength  // number of dwords
    );


#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level

#if defined(NT_UP)

#define SYNCH_LEVEL DISPATCH_LEVEL  // synchronization level - UP system

#else

#define SYNCH_LEVEL (IPI_LEVEL-1)   // synchronization level - MP system

#endif

#define MODE_MASK    1      

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) { \
    volatile PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    while (TRUE) {                                                          \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        _asm { rep nop }                                                    \
    }                                                                       \
}

// end_wdm

#else


VOID
NTAPI
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

//
// 386 hardware structures
//

//
// A Page Table Entry on an Intel 386/486 has the following definition.
//
// **** NOTE A PRIVATE COPY OF THIS EXISTS IN THE MM\I386 DIRECTORY! ****
// ****  ANY CHANGES NEED TO BE MADE TO BOTH HEADER FILES.           ****
//


typedef struct _HARDWARE_PTE_X86 {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
    ULONG reserved : 1;  // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE_X86, *PHARDWARE_PTE_X86;

typedef struct _HARDWARE_PTE_X86PAE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE_X86PAE, *PHARDWARE_PTE_X86PAE;

//
// Special check to work around mspdb limitation
//
#if defined (_NTSYM_HARDWARE_PTE_SYMBOL_)
#if !defined (_X86PAE_)
typedef struct _HARDWARE_PTE {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
    ULONG reserved : 1;  // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

#else
typedef struct _HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE, *PHARDWARE_PTE;
#endif

#else

#if !defined (_X86PAE_)
typedef HARDWARE_PTE_X86 HARDWARE_PTE;
typedef PHARDWARE_PTE_X86 PHARDWARE_PTE;
#else
typedef HARDWARE_PTE_X86PAE HARDWARE_PTE;
typedef PHARDWARE_PTE_X86PAE PHARDWARE_PTE;
#endif
#endif

//
// GDT Entry
//

typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;

#define TYPE_CODE   0x10  // 11010 = Code, Readable, NOT Conforming, Accessed
#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed
#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04

//
// Entry of Interrupt Descriptor Table (IDTENTRY)
//

typedef struct _KIDTENTRY {
   USHORT Offset;
   USHORT Selector;
   USHORT Access;
   USHORT ExtendedOffset;
} KIDTENTRY;

typedef KIDTENTRY *PKIDTENTRY;


//
// TSS (Task switch segment) NT only uses to control stack switches.
//
//  The only fields we actually care about are Esp0, Ss0, the IoMapBase
//  and the IoAccessMaps themselves.
//
//
//  N.B.    Size of TSS must be <= 0xDFFF
//

//
// The interrupt direction bitmap is used on Pentium to allow
// the processor to emulate V86 mode software interrupts for us.
// There is one for each IOPM.  It is located by subtracting
// 32 from the IOPM base in the Tss.
//
#define INT_DIRECTION_MAP_SIZE   32
typedef UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];

#define IOPM_COUNT      1           // Number of i/o access maps that
                                    // exist (in addition to
                                    // IO_ACCESS_MAP_NONE)

#define IO_ACCESS_MAP_NONE 0

#define IOPM_SIZE           8192    // Size of map callers can set.

#define PIOPM_SIZE          8196    // Size of structure we must allocate
                                    // to hold it.

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

typedef struct _KiIoAccessMap {
    KINT_DIRECTION_MAP DirectionMap;
    UCHAR IoMap[PIOPM_SIZE];
} KIIO_ACCESS_MAP;


typedef struct _KTSS {

    USHORT  Backlink;
    USHORT  Reserved0;

    ULONG   Esp0;
    USHORT  Ss0;
    USHORT  Reserved1;

    ULONG   NotUsed1[4];

    ULONG   CR3;
    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;


    USHORT  Es;
    USHORT  Reserved2;

    USHORT  Cs;
    USHORT  Reserved3;

    USHORT  Ss;
    USHORT  Reserved4;

    USHORT  Ds;
    USHORT  Reserved5;

    USHORT  Fs;
    USHORT  Reserved6;

    USHORT  Gs;
    USHORT  Reserved7;

    USHORT  LDT;
    USHORT  Reserved8;

    USHORT  Flags;

    USHORT  IoMapBase;

    KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];

    //
    // This is the Software interrupt direction bitmap associated with
    // IO_ACCESS_MAP_NONE
    //
    KINT_DIRECTION_MAP IntDirectionMap;
} KTSS, *PKTSS;


#define KiComputeIopmOffset(MapNumber)          \
    (MapNumber == IO_ACCESS_MAP_NONE) ?         \
        (USHORT)(sizeof(KTSS)) :                    \
        (USHORT)(FIELD_OFFSET(KTSS, IoMaps[MapNumber-1].IoMap))

// begin_windbgkd

//
// Special Registers for i386
//

#ifdef _X86_

typedef struct _DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _X86_

// end_windbgkd

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
    USHORT MinorVersion;
    USHORT MajorVersion;

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;

    CCHAR   CpuType;
    CCHAR   CpuID;
    USHORT  CpuStep;

    struct _KPROCESSOR_STATE ProcessorState;

    ULONG   KernelReserved[16];         // For use by the kernel
    ULONG   HalReserved[16];            // For use by Hal

//
// Per processor lock queue entries.
//
// N.B. The following padding is such that the first lock entry falls in the
//      last eight bytes of a cache line. This makes the dispatcher lock and
//      the context swap lock lie in separate cache lines.
//

    UCHAR PrcbPad0[28 + 64];
    KSPIN_LOCK_QUEUE LockQueue[16];
    UCHAR PrcbPad1[8];

// End of the architecturally defined section of the PRCB.

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;


//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    PVOID   KdVersionBlock;

    struct _KIDTENTRY *IDT;
    struct _KGDTENTRY *GDT;
    struct _KTSS      *TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   DebugActive;
    UCHAR   Number;


} KPCR, *PKPCR;


#define EFLAGS_TF             0x00000100L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_USER_SANITIZE  0x003e0dd7L

// end_nthal

//
// Sanitize segCS and eFlags based on a processor mode.
//
// If kernel mode,
//      force CPL == 0
//
// If user mode,
//      force CPL == 3
//

#define SANITIZE_SEG(segCS, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((segCS) & 0xfffc)) : \
        ((0x00000003L) | ((segCS) & 0xffff))))

//
// If kernel mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Interrupt, AlignCheck.
//
// If user mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, AlignCheck.
//      force Interrupts on.
//


#define SANITIZE_FLAGS(eFlags, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((eFlags) & 0x003e0fd7)) : \
        ((((eFlags) & EFLAGS_V86_MASK) && KeI386VdmIoplAllowed) ? \
        (((eFlags) & KeI386EFlagsAndMaskV86) | KeI386EFlagsOrMaskV86) : \
        ((EFLAGS_INTERRUPT_MASK) | ((eFlags) & EFLAGS_USER_SANITIZE)))))

//
// Masks for Dr7 and sanitize macros for various Dr registers.
//

#define DR6_LEGAL   0x0000e00f

#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,
                                // Local enable for Dr0-Dr4,
                                // Le for "perfect" trapping

#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active

#define SANITIZE_DR6(Dr6, mode) ((Dr6 & DR6_LEGAL));

#define SANITIZE_DR7(Dr7, mode) ((Dr7 & DR7_LEGAL));

#define SANITIZE_DRADDR(DrReg, mode) (          \
    (mode) == KernelMode ?                      \
        (DrReg) :                               \
        (((PVOID)DrReg <= MM_HIGHEST_USER_ADDRESS) ?   \
            (DrReg) :                           \
            (0)                                 \
        )                                       \
    )

//
// Define macro to clear reserved bits from MXCSR so that we don't
// GP fault when doing an FRSTOR
//

extern ULONG KiMXCsrMask;

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & KiMXCsrMask)

//
// Nonvolatile context pointers
//
// bryanwi 21 feb 90 - This is bogus.  The 386 doesn't have
//                     enough nonvolatile context to make this
//                     structure worthwhile.  Can't declare a
//                     field to be void, so declare a Junk structure
//                     instead.

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    ULONG   Junk;
} KNONVOLATILE_CONTEXT_POINTERS,  *PKNONVOLATILE_CONTEXT_POINTERS;

// begin_nthal
//
// Trap frame
//
//  NOTE - We deal only with 32bit registers, so the assembler equivalents
//         are always the extended forms.
//
//  NOTE - Unless you want to run like slow molasses everywhere in the
//         the system, this structure must be of DWORD length, DWORD
//         aligned, and its elements must all be DWORD aligned.
//
//  NOTE WELL   -
//
//      The i386 does not build stack frames in a consistent format, the
//      frames vary depending on whether or not a privilege transition
//      was involved.
//
//      In order to make NtContinue work for both user mode and kernel
//      mode callers, we must force a canonical stack.
//
//      If we're called from kernel mode, this structure is 8 bytes longer
//      than the actual frame!
//
//  WARNING:
//
//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)
//

typedef struct _KTRAP_FRAME {


//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    ULONG   PreviousPreviousMode;

    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} KTRAP_FRAME;


typedef KTRAP_FRAME *PKTRAP_FRAME;
typedef KTRAP_FRAME *PKEXCEPTION_FRAME;

#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))
#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))
#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)

//
//  Bits forced to 0 in SegCs if Esp has been edited.
//

#define FRAME_EDITED        0xfff8

// end_nthal

//
// The frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//

typedef struct _KCALLOUT_FRAME {
    ULONG   InStk;          // saved initial stack address
    ULONG   TrFr;           // saved callback trap frame
    ULONG   CbStk;          // saved callback stack address
    ULONG   Edi;            // saved nonvolatile registers
    ULONG   Esi;            //
    ULONG   Ebx;            //
    ULONG   Ebp;            //
    ULONG   Ret;            // saved return address
    ULONG   OutBf;          // address to store output buffer
    ULONG   OutLn;          // address to store output length
} KCALLOUT_FRAME;

typedef KCALLOUT_FRAME *PKCALLOUT_FRAME;


//
//  Switch Frame
//
//  386 doesn't have an "exception frame", and doesn't normally make
//  any use of nonvolatile context register structures.
//
//  However, swapcontext in ctxswap.c and KeInitializeThread in
//  thredini.c need to share common stack structure used at thread
//  startup and switch time.
//
//  This is that structure.
//

typedef struct _KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   Eflags;
    ULONG   RetAddr;
} KSWITCHFRAME, *PKSWITCHFRAME;


//
// Various 387 defines
//

#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present

// begin_ntddk begin_wdm
//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

// end_ntndis end_wdm
//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define the highest user address and user probe address.
//


extern PVOID *MmHighestUserAddress;
extern PVOID *MmSystemRangeStart;
extern ULONG *MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS *MmHighestUserAddress
#define MM_SYSTEM_RANGE_START *MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS *MmUserProbeAddress

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

//
// The lowest address for system space.
//

#if !defined (_X86PAE_)
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
#else
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0C00000
#endif

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_ntddk end_wdm

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define page directory and page base addresses.
//

#define PDE_BASE_X86    0xc0300000
#define PDE_BASE_X86PAE 0xc0600000

#define PTE_TOP_X86     0xC03FFFFF
#define PDE_TOP_X86     0xC0300FFF

#define PTE_TOP_X86PAE  0xC07FFFFF
#define PDE_TOP_X86PAE  0xC0603FFF


#if !defined (_X86PAE_)
#define PDE_BASE PDE_BASE_X86
#define PTE_TOP  PTE_TOP_X86
#define PDE_TOP  PDE_TOP_X86
#else
#define PDE_BASE PDE_BASE_X86PAE
#define PTE_TOP  PTE_TOP_X86PAE
#define PDE_TOP  PDE_TOP_X86PAE
#endif
#define PTE_BASE 0xc0000000

#define KIP0PCRADDRESS              0xffdff000  

#define KI_USER_SHARED_DATA         0xffdf0000
#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

//
// Convert various portable ExInterlock APIs into their architectural
// equivalents.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend,Lock) \
        Exfi386InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend,Lock) \
        Exfi386InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target,Value,Lock) \
        Exfi386InterlockedExchangeUlong(Target,Value)

//  begin_wdm

#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList

//  end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

#if !defined(_WINBASE_) && !defined(NONTOSPINTERLOCK) 
#if !defined(MIDL_PASS) // wdm
#if defined(NO_INTERLOCKED_INTRINSICS) || defined(_CROSS_PLATFORM_)
//  begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

//  end_wdm

#else       // NO_INTERLOCKED_INCREMENTS || _CROSS_PLATFORM_

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)


#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#pragma intrinsic (_InterlockedExchange)
#define InterlockedExchange _InterlockedExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedIncrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedIncrement)
#define InterlockedIncrement _InterlockedIncrement
#else
#define InterlockedIncrement(Addend) (InterlockedExchangeAdd (Addend, 1)+1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedDecrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedDecrement)
#define InterlockedDecrement _InterlockedDecrement
#else
#define InterlockedDecrement(Addend) (InterlockedExchangeAdd (Addend, -1)-1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

#pragma intrinsic (_InterlockedExchangeAdd)
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#else
// begin_wdm
FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    )
{
    __asm {
         mov     eax, Increment
         mov     ecx, Addend
    lock xadd    [ecx], eax
    }
}
// end_wdm
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#pragma intrinsic (_InterlockedCompareExchange)
#define InterlockedCompareExchange (LONG)_InterlockedCompareExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
   lock cmpxchg [ecx], edx
    }
}
#endif

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

#endif      // INTERLOCKED_INTRINSICS || _CROSS_PLATFORM_
// begin_wdm
#endif      // MIDL_PASS
#endif      // __WINBASE__ && !NONTOSPINTERLOCK

typedef struct _PROCESS_IO_PORT_HANDLER_INFORMATION {
    BOOLEAN Install;            // true if handlers to be installed
    ULONG NumEntries;
    ULONG Context;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
} PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;


//
//    Vdm Objects and Io handling structure
//

typedef struct _VDM_IO_HANDLER_FUNCTIONS {
    PDRIVER_IO_PORT_ULONG  UlongIo;
    PDRIVER_IO_PORT_ULONG_STRING UlongStringIo;
    PDRIVER_IO_PORT_USHORT UshortIo[2];
    PDRIVER_IO_PORT_USHORT_STRING UshortStringIo[2];
    PDRIVER_IO_PORT_UCHAR UcharIo[4];
    PDRIVER_IO_PORT_UCHAR_STRING UcharStringIo[4];
} VDM_IO_HANDLER_FUNCTIONS, *PVDM_IO_HANDLER_FUNCTIONS;

typedef struct _VDM_IO_HANDLER {
    struct _VDM_IO_HANDLER *Next;
    ULONG PortNumber;
    VDM_IO_HANDLER_FUNCTIONS IoFunctions[2];
} VDM_IO_HANDLER, *PVDM_IO_HANDLER;



// begin_nthal begin_ntddk begin_wdm


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below

// end_wdm

#if NT_UP
    #define _PCR   ds:[KIP0PCRADDRESS]
#else
    #define _PCR   fs:[0]
#endif


//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE
PKPRCB
NTAPI
KeGetCurrentPrcb (VOID)
{
    __asm {  mov eax, _PCR KPCR.Prcb     }
}

// begin_ntddk begin_wdm

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

NTHALAPI
KIRQL
NTAPI
KeGetCurrentIrql();

// end_wdm
//
// Get the current processor number
//

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
    __asm {  movzx eax, _PCR KPCR.Number  }
}


#pragma warning(default:4035)

// begin_wdm
#endif // !defined(MIDL_PASS) && defined(_M_IX86)


NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

// end_ntddk end_wdm
// begin_nthal

NTKERNELAPI
VOID
NTAPI
KeProfileInterruptWithSource (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );


#endif // defined(_X86_)

#ifdef _X86_
VOID
NTAPI
Ke386SetLdtProcess (
    struct _KPROCESS  *Process,
    PLDT_ENTRY  Ldt,
    ULONG       Limit
    );

VOID
NTAPI
Ke386SetDescriptorProcess (
    struct _KPROCESS  *Process,
    ULONG       Offset,
    LDT_ENTRY   LdtEntry
    );

VOID
NTAPI
Ke386GetGdtEntryThread (
    struct _KTHREAD *Thread,
    ULONG Offset,
    PKGDTENTRY Descriptor
    );

BOOLEAN
NTAPI
Ke386SetIoAccessMap (
    ULONG               MapNumber,
    PKIO_ACCESS_MAP     IoAccessMap
    );

BOOLEAN
NTAPI
Ke386QueryIoAccessMap (
    ULONG              MapNumber,
    PKIO_ACCESS_MAP    IoAccessMap
    );

BOOLEAN
NTAPI
Ke386IoSetAccessProcess (
    struct _KPROCESS    *Process,
    ULONG       MapNumber
    );

VOID
NTAPI
Ke386SetIOPL(
    struct _KPROCESS    *Process
    );

NTSTATUS
NTAPI
Ke386CallBios (
    IN ULONG BiosCommand,
    IN OUT PCONTEXT BiosArguments
    );

VOID
NTAPI
KiEditIopmDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
NTAPI
Ki386GetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    );

ULONG
Ki386DispatchOpcodeV86 (
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
NTAPI
Ke386SetVdmInterruptHandler (
    IN struct _KPROCESS *Process,
    IN ULONG Interrupt,
    IN USHORT Selector,
    IN ULONG  Offset,
    IN BOOLEAN Gate32
    );
#endif //_X86_
#define INIT_SYSTEMROOT_LINKNAME "\\SystemRoot"
#define INIT_SYSTEMROOT_DLLPATH  "\\SystemRoot\\System32"
#define INIT_SYSTEMROOT_BINPATH  "\\SystemRoot\\System32"
extern ULONG NtBuildNumber;

#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

VOID
__inbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__inwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__indwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
__outbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__outwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__outdwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

//
// Interlocked intrinsic functions.
//

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG64
InterlockedAnd64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedOr64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedXor64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONG64
InterlockedIncrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    IN OUT LONG64 volatile *Target,
    IN LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 ExChange,
    IN LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if defined(_AMD64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the AMD64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1

//
// Define constants for bits in CR0.
//

#define CR0_PE 0x00000001               // protection enable
#define CR0_MP 0x00000002               // math present
#define CR0_EM 0x00000004               // emulate math coprocessor
#define CR0_TS 0x00000008               // task switched
#define CR0_ET 0x00000010               // extension type (80387)
#define CR0_NE 0x00000020               // numeric error
#define CR0_WP 0x00010000               // write protect
#define CR0_AM 0x00040000               // alignment mask
#define CR0_NW 0x20000000               // not write-through
#define CR0_CD 0x40000000               // cache disable
#define CR0_PG 0x80000000               // paging

//
// Define functions to read and write CR0.
//

#ifdef __cplusplus
extern "C" {
#endif


#define ReadCR0() __readcr0()

ULONG64
__readcr0 (
    VOID
    );

#define WriteCR0(Data) __writecr0(Data)

VOID
__writecr0 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr0)
#pragma intrinsic(__writecr0)

//
// Define functions to read and write CR3.
//

#define ReadCR3() __readcr3()

ULONG64
__readcr3 (
    VOID
    );

#define WriteCR3(Data) __writecr3(Data)

VOID
__writecr3 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr3)
#pragma intrinsic(__writecr3)

//
// Define constants for bits in CR4.
//

#define CR4_VME 0x00000001              // V86 mode extensions
#define CR4_PVI 0x00000002              // Protected mode virtual interrupts
#define CR4_TSD 0x00000004              // Time stamp disable
#define CR4_DE  0x00000008              // Debugging Extensions
#define CR4_PSE 0x00000010              // Page size extensions
#define CR4_PAE 0x00000020              // Physical address extensions
#define CR4_MCE 0x00000040              // Machine check enable
#define CR4_PGE 0x00000080              // Page global enable
#define CR4_FXSR 0x00000200             // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400         // XMMI used by OS

//
// Define functions to read and write CR4.
//

#define ReadCR4() __readcr4()

ULONG64
__readcr4 (
    VOID
    );

#define WriteCR4(Data) __writecr4(Data)

VOID
__writecr4 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr4)
#pragma intrinsic(__writecr4)

//
// Define functions to read and write CR8.
//
// CR8 is the APIC TPR register.
//

#define ReadCR8() __readcr8()

ULONG64
__readcr8 (
    VOID
    );

#define WriteCR8(Data) __writecr8(Data)

VOID
__writecr8 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr8)
#pragma intrinsic(__writecr8)

#ifdef __cplusplus
}
#endif

//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level

#define CLOCK_LEVEL 13                  // Interval clock level
#define IPI_LEVEL 14                    // Interprocessor interrupt level
#define POWER_LEVEL 14                  // Power failure level
#define PROFILE_LEVEL 15                // timer used for profiling.
#define HIGH_LEVEL 15                   // Highest interrupt level

#if defined(NT_UP)

#define SYNCH_LEVEL DISPATCH_LEVEL      // synchronization level

#else

#define SYNCH_LEVEL (IPI_LEVEL - 1)     // synchronization level

#endif

#define IRQL_VECTOR_OFFSET 2            // offset from IRQL to vector / 16

#define MODE_MASK 1                                                 

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use in/out instructions.)
//

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    volatile UCHAR *Register
    )
{
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    volatile USHORT *Register
    )
{
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    volatile ULONG *Register
    )
{
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    __movsb(Register, Buffer, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    __movsw(Register, Buffer, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    __movsd(Register, Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    PUCHAR Register,
    UCHAR Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    PUSHORT Register,
    USHORT Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    PULONG Register,
    ULONG Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsb(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsw(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsd(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__forceinline
USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__forceinline
ULONG
READ_PORT_ULONG (
    PULONG Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __inbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __inwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __indwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __outbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __outwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __outdwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) \
    *(PULONG64)(CurrentCount) = **((volatile ULONG64 **)(&KeTickCount));

// end_wdm

#else


VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

//
// AMD64 hardware structures
//
// A Page Table Entry on an AMD64 has the following definition.
//

#define _HARDWARE_PTE_WORKING_SET_BITS  11

typedef struct _HARDWARE_PTE {
    ULONG64 Valid : 1;
    ULONG64 Write : 1;                // UP version
    ULONG64 Owner : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 LargePage : 1;
    ULONG64 Global : 1;
    ULONG64 CopyOnWrite : 1;          // software field
    ULONG64 Prototype : 1;            // software field
    ULONG64 reserved0 : 1;            // software field
    ULONG64 PageFrameNumber : 28;
    ULONG64 reserved1 : 24 - (_HARDWARE_PTE_WORKING_SET_BITS+1);
    ULONG64 SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONG64 NoExecute : 1;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG64)(dirbase)) = (((ULONG64)(pfn)) << PAGE_SHIFT)

//
// Define Global Descriptor Table (GDT) entry structure and constants.
//
// Define descriptor type codes.
//

#define TYPE_CODE 0x1A                  // 11010 = code, read only
#define TYPE_DATA 0x12                  // 10010 = data, read and write
#define TYPE_TSS64 0x09                 // 01001 = task state segment

//
// Define descriptor privilege levels for user and system.
//

#define DPL_USER 3
#define DPL_SYSTEM 0

//
// Define limit granularity.
//

#define GRANULARITY_BYTE 0
#define GRANULARITY_PAGE 1

#define SELECTOR_TABLE_INDEX 0x04

typedef union _KGDTENTRY64 {
    struct {
        USHORT  LimitLow;
        USHORT  BaseLow;
        union {
            struct {
                UCHAR   BaseMiddle;
                UCHAR   Flags1;
                UCHAR   Flags2;
                UCHAR   BaseHigh;
            } Bytes;

            struct {
                ULONG   BaseMiddle : 8;
                ULONG   Type : 5;
                ULONG   Dpl : 2;
                ULONG   Present : 1;
                ULONG   LimitHigh : 4;
                ULONG   System : 1;
                ULONG   LongMode : 1;
                ULONG   DefaultBig : 1;
                ULONG   Granularity : 1;
                ULONG   BaseHigh : 8;
            } Bits;
        };

        ULONG BaseUpper;
        ULONG MustBeZero;
    };

    ULONG64 Alignment;
} KGDTENTRY64, *PKGDTENTRY64;

//
// Define Interrupt Descriptor Table (IDT) entry structure and constants.
//

typedef union _KIDTENTRY64 {
   struct {
       USHORT OffsetLow;
       USHORT Selector;
       USHORT IstIndex : 3;
       USHORT Reserved0 : 5;
       USHORT Type : 5;
       USHORT Dpl : 2;
       USHORT Present : 1;
       USHORT OffsetMiddle;
       ULONG OffsetHigh;
       ULONG Reserved1;
   };

   ULONG64 Alignment;
} KIDTENTRY64, *PKIDTENTRY64;

//
// Define two union definitions used for parsing addresses into the
// component fields required by a GDT.
//

typedef union _KGDT_BASE {
    struct {
        USHORT BaseLow;
        UCHAR BaseMiddle;
        UCHAR BaseHigh;
        ULONG BaseUpper;
    };

    ULONG64 Base;
} KGDT_BASE, *PKGDT_BASE;

C_ASSERT(sizeof(KGDT_BASE) == sizeof(ULONG64));


typedef union _KGDT_LIMIT {
    struct {
        USHORT LimitLow;
        USHORT LimitHigh : 4;
        USHORT MustBeZero : 12;
    };

    ULONG Limit;
} KGDT_LIMIT, *PKGDT_LIMIT;

C_ASSERT(sizeof(KGDT_LIMIT) == sizeof(ULONG));

//
// Define Task State Segment (TSS) structure and constants.
//
// Task switches are not supported by the AMD64, but a task state segment
// must be present to define the kernel stack pointer and I/O map base.
//
// N.B. This structure is misaligned as per the AMD64 specification.
//
// N.B. The size of TSS must be <= 0xDFFF.
//

#define IOPM_SIZE 8192

typedef UCHAR KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

#pragma pack(push, 4)
typedef struct _KTSS64 {
    ULONG Reserved0;
    ULONG64 Rsp0;
    ULONG64 Rsp1;
    ULONG64 Rsp2;

    //
    // Element 0 of the Ist is reserved
    //

    ULONG64 Ist[8];
    ULONG64 Reserved1;
    USHORT IoMapBase;
    KIO_ACCESS_MAP IoMap;
    ULONG IoMapEnd;
    ULONG Reserved2;
} KTSS64, *PKTSS64;
#pragma pack(pop)

C_ASSERT((sizeof(KTSS64) % sizeof(PVOID)) == 0);

#define TSS_IST_RESERVED 0
#define TSS_IST_PANIC 1
#define TSS_IST_MCA 2

#define IO_ACCESS_MAP_NONE FALSE

#define KiComputeIopmOffset(Enable)               \
    ((Enable == FALSE) ?                          \
        (USHORT)(sizeof(KTSS64)) : (USHORT)(FIELD_OFFSET(KTSS64, IoMap[0])))

// begin_windbgkd

#if defined(_AMD64_)

//
// Define pseudo descriptor structures for both 64- and 32-bit mode.
//

typedef struct _KDESCRIPTOR {
    USHORT Pad[3];
    USHORT Limit;
    PVOID Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KDESCRIPTOR32 {
    USHORT Pad[3];
    USHORT Limit;
    ULONG Base;
} KDESCRIPTOR32, *PKDESCRIPTOR32;

//
// Define special kernel registers and the initial MXCSR value.
//

typedef struct _KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Define processor state structure.
//

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _AMD64_

// end_windbgkd

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1

#define PRCB_BUILD_DEBUG 0x1
#define PRCB_BUILD_UNIPROCESSOR 0x2

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    USHORT MinorVersion;
    USHORT MajorVersion;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    KAFFINITY SetMember;
    KAFFINITY NotSetMember;
    KPROCESSOR_STATE ProcessorState;
    CCHAR CpuType;
    CCHAR CpuID;
    USHORT CpuStep;
    ULONG KernelReserved[16];
    ULONG HalReserved[16];
    UCHAR PrcbPad0[88 + 112];

//
// End of the architecturally defined section of the PRCB.
//

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;


//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB NtTib;
    struct _KPRCB *CurrentPrcb;
    ULONG64 SavedRcx;
    ULONG64 SavedR11;
    KIRQL Irql;
    UCHAR SecondLevelCacheAssociativity;
    UCHAR Number;
    UCHAR Fill0;
    ULONG Irr;
    ULONG IrrActive;
    ULONG Idr;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG StallScaleFactor;
    union _KIDTENTRY64 *IdtBase;
    union _KGDTENTRY64 *GdtBase;
    struct _KTSS64 *TssBase;


} KPCR, *PKPCR;


//
// Define legacy floating status word bit masks.
//

#define FSW_INVALID_OPERATION 0x1
#define FSW_DENORMAL 0x2
#define FSW_ZERO_DIVIDE 0x4
#define FSW_OVERFLOW 0x8
#define FSW_UNDERFLOW 0x10
#define FSW_PRECISION 0x20
#define FSW_STACK_FAULT 0x40
#define FSW_CONDITION_CODE_0 0x100
#define FSW_CONDITION_CODE_1 0x200
#define FSW_CONDITION_CODE_2 0x400
#define FSW_CONDITION_CODE_3 0x4000

#define FSW_ERROR_MASK (FSW_INVALID_OPERATION | FSW_DENORMAL |              \
                        FSW_ZERO_DIVIDE | FSW_OVERFLOW | FSW_UNDERFLOW |    \
                        FSW_PRECISION | FSW_STACK_FAULT)

//
// Define MxCsr floating control/status word bit masks.
//
// No flush to zero, round to nearest, and all exception masked.
//

#define INITIAL_MXCSR 0x1f80            // initial MXCSR vlaue

#define XSW_INVALID_OPERATION 0x1
#define XSW_DENORMAL 0x2
#define XSW_ZERO_DIVIDE 0x4
#define XSW_OVERFLOW 0x8
#define XSW_UNDERFLOW 0x10
#define XSW_PRECISION 0x20

#define XSW_ERROR_MASK (XSW_INVALID_OPERATION |  XSW_DENORMAL |             \
                        XSW_ZERO_DIVIDE | XSW_OVERFLOW | XSW_UNDERFLOW |    \
                        XSW_PRECISION)

#define XSW_ERROR_SHIFT 7

#define XCW_INVALID_OPERATION 0x80
#define XCW_DENORMAL 0x100
#define XCW_ZERO_DIVIDE 0x200
#define XCW_OVERFLOW 0x400
#define XCW_UNDERFLOW 0x800
#define XCW_PRECISION 0x1000
#define XCW_ROUND_CONTROL 0x6000
#define XCW_FLUSH_ZERO 0x8000

//
// Define EFLAG bit masks and shift offsets.
//

#define EFLAGS_CF_MASK 0x00000001       // carry flag
#define EFLAGS_PF_MASK 0x00000004       // parity flag
#define EFALGS_AF_MASK 0x00000010       // auxiliary carry flag
#define EFLAGS_ZF_MASK 0x00000040       // zero flag
#define EFLAGS_SF_MASK 0x00000080       // sign flag
#define EFLAGS_TF_MASK 0x00000100       // trap flag
#define EFLAGS_IF_MASK 0x00000200       // interrupt flag
#define EFLAGS_DF_MASK 0x00000400       // direction flag
#define EFLAGS_OF_MASK 0x00000800       // overflow flag
#define EFLAGS_IOPL_MASK 0x00003000     // I/O privilege level
#define EFLAGS_NT_MASK 0x00004000       // nested task
#define EFLAGS_RF_MASK 0x00010000       // resume flag
#define EFLAGS_VM_MASK 0x00020000       // virtual 8086 mode
#define EFLAGS_AC_MASK 0x00040000       // alignment check
#define EFLAGS_VIF_MASK 0x00080000      // virtual interrupt flag
#define EFLAGS_VIP_MASK 0x00100000      // virtual interrupt pending
#define EFLAGS_ID_MASK 0x00200000       // identification flag

#define EFLAGS_TF_SHIFT 8               // trap
#define EFLAGS_IF_SHIFT 9               // interrupt enable

// end_nthal

//
// Define sanitize EFLAGS macro.
//
// If kernel mode, then
//      caller can specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Interrupt, Direction, Overflow, Align Check, identification.
//
// If user mode, then
//      caller can specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Align Check, and force Interrupt on.
//

#define EFLAGS_KERNEL_SANITIZE 0x00240fd5L
#define EFLAGS_USER_SANITIZE 0x00040dd5L

#define SANITIZE_EFLAGS(eFlags, mode) (                                      \
    ((mode) == KernelMode ?                                                  \
        ((eFlags) & EFLAGS_KERNEL_SANITIZE) :                                \
        (((eFlags) & EFLAGS_USER_SANITIZE) | EFLAGS_IF_MASK)))

//
// Define sanitize debug register macros.
//
// Define control register settable bits and active mask.
//

#define DR7_LEGAL 0xffff0155
#define DR7_ACTIVE 0x00000055

//
// Define macro to sanitize the debug control register.
//

#define SANITIZE_DR7(Dr7, mode) ((Dr7 & DR7_LEGAL));

//
// Define macro to santitize debug address registers.
//

#define SANITIZE_DRADDR(DrReg, mode)                                         \
    ((mode) == KernelMode ?                                                  \
        (DrReg) :                                                            \
        (((PVOID)(DrReg) <= MM_HIGHEST_USER_ADDRESS) ? (DrReg) : 0))                                 \

//
// Define macro to clear reserved bits from MXCSR.
//

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & 0xffbf)

//
// Define macro to clear reserved bits for legacy FP control word.
//

#define SANITIZE_FCW(_fcw_) ((_fcw_) & 0x1f37)

// begin_nthal
//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//

typedef struct _KEXCEPTION_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Kernel callout initial stack value.
//

    ULONG64 InitialStack;

//
// Saved nonvolatile floating registers.
//

    M128 Xmm6;
    M128 Xmm7;
    M128 Xmm8;
    M128 Xmm9;
    M128 Xmm10;
    M128 Xmm11;
    M128 Xmm12;
    M128 Xmm13;
    M128 Xmm14;
    M128 Xmm15;

//
// Kernel callout frame variables.
//

    ULONG64 TrapFrame;
    ULONG64 CallbackStack;
    ULONG64 OutputBuffer;
    ULONG64 OutputLength;

//
// Saved nonvolatile register - not always saved.
//

    ULONG64 Fill1;
    ULONG64 Rbp;

//
// Saved nonvolatile registers.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

//
// EFLAGS and return address.
//

    ULONG64 Return;
} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

#define KEXCEPTION_FRAME_LENGTH sizeof(KEXCEPTION_FRAME)

C_ASSERT((sizeof(KEXCEPTION_FRAME) & STACK_ROUND) == 0);

#define EXCEPTION_RECORD_LENGTH                                              \
    ((sizeof(EXCEPTION_RECORD) + STACK_ROUND) & ~STACK_ROUND)

//
// Machine Frame
//
// This frame is established by code that trampolines to user mode (e.g. user
// APC, user callback, dispatch user exception, etc.). The purpose of this
// frame is to allow unwinding through these callbacks if an exception occurs.
//
// N.B. This frame is identical to the frame that is pushed for a trap without
//      an error code and is identical to the hardware part of a trap frame.
//

typedef struct _MACHINE_FRAME {
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} MACHINE_FRAME, *PMACHINE_FRAME;

#define MACHINE_FRAME_LENGTH sizeof(MACHINE_FRAME)

C_ASSERT((sizeof(MACHINE_FRAME) & STACK_ROUND) == 8);

//
// Switch Frame
//
// This frame is established by the code that switches context from one
// thread to the next and is used by the thread initialization code to
// construct a stack that will start the execution of a thread in the
// thread start up code.
//

typedef struct _KSWITCH_FRAME {
    ULONG64 Fill0;
    ULONG MxCsr;
    KIRQL ApcBypass;
    BOOLEAN NpxSave;
    UCHAR Fill1[2];
    ULONG64 Rbp;
    ULONG64 Return;
} KSWITCH_FRAME, *PKSWITCH_FRAME;

#define KSWITCH_FRAME_LENGTH sizeof(KSWITCH_FRAME)

C_ASSERT((sizeof(KSWITCH_FRAME) & STACK_ROUND) == 0);

//
// Trap frame
//
// This frame is established when handling a trap. It provides a place to
// save all volatile registers. The nonvolatile registers are saved in an
// exception frame or through the normal C calling conventions for saved
// registers.
//

typedef struct _KTRAP_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Previous processor mode (system services only) and previous IRQL
// (interrupts only).
//

    KPROCESSOR_MODE PreviousMode;
    KIRQL PreviousIrql;
    UCHAR Fill0[2];

//
// Floating point state.
//

    ULONG MxCsr;

//
//  Volatile registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 Spare0;

//
// Volatile floating registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    M128 Xmm0;
    M128 Xmm1;
    M128 Xmm2;
    M128 Xmm3;
    M128 Xmm4;
    M128 Xmm5;

//
//  Debug registers.
//

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

//
//  Segment registers
//

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

//
// Previous trap frame address.
//

    ULONG64 TrapFrame;

//
// Exception record for exceptions.
//

    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD) + 15) & (~15)];

//
// Saved nonvolatile registers RBX, RDI and RSI. These registers are only
// saved in system service trap frames.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

//
// Saved nonvolatile register RBP. This register is used as a frame
// pointer during trap processing and is saved in all trap frames.
//

    ULONG64 Rbp;

//
// Information pushed by hardware.
//
// N.B. The error code is not always pushed by hardware. For those cases
//      where it is not pushed by hardware a dummy error code is allocated
//      on the stack.
//

    ULONG64 ErrorCode;
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} KTRAP_FRAME, *PKTRAP_FRAME;

#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)

C_ASSERT((sizeof(KTRAP_FRAME) & STACK_ROUND) == 0);

//
// IPI, profile, update run time, and update system time interrupt routines.
//

NTKERNELAPI
VOID
KeIpiInterrupt (
    IN PKTRAP_FRAME TrapFrame
    );

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    IN PKTRAP_FRAME TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );

NTKERNELAPI
VOID
KeUpdateRunTime (
    IN PKTRAP_FRAME TrapFrame
    );

NTKERNELAPI
VOID
KeUpdateSystemTime (
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG64 Increment
    );

// end_nthal

//
// The frame saved by the call out to user mode code is defined here to allow
// the kernel debugger to trace the entire kernel stack when user mode callouts
// are active.
//
// N.B. The kernel callout frame is the same as an exception frame.
//

typedef KEXCEPTION_FRAME KCALLOUT_FRAME;
typedef PKEXCEPTION_FRAME PKCALLOUT_FRAME;

typedef struct _UCALLOUT_FRAME {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    MACHINE_FRAME MachineFrame;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;

#define UCALLOUT_FRAME_LENGTH sizeof(UCALLOUT_FRAME)

C_ASSERT((sizeof(UCALLOUT_FRAME) & STACK_ROUND) == 8);

// begin_ntddk begin_wdm
//
// The nonvolatile floating state
//

typedef struct _KFLOATING_SAVE {
    ULONG MxCsr;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// AMD64 Specific portions of mm component.
//
// Define the page size for the AMD64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

// end_ntndis end_wdm

#define PXE_BASE          0xFFFFF6FB7DBED000UI64
#define PXE_SELFMAP       0xFFFFF6FB7DBEDF68UI64
#define PPE_BASE          0xFFFFF6FB7DA00000UI64
#define PDE_BASE          0xFFFFF6FB40000000UI64
#define PTE_BASE          0xFFFFF68000000000UI64

#define PXE_TOP           0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP           0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP           0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP           0xFFFFF6FFFFFFFFFFUI64

#define PDE_KTBASE_AMD64  PPE_BASE

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PTI_MASK_AMD64 (PTE_PER_PAGE - 1)
#define PDI_MASK_AMD64 (PDE_PER_PAGE - 1)
#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

//
// Define the highest user address and user probe address.
//


extern PVOID *MmHighestUserAddress;
extern PVOID *MmSystemRangeStart;
extern ULONG64 *MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS *MmHighestUserAddress
#define MM_SYSTEM_RANGE_START *MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS *MmUserProbeAddress

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFF080000000000

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)


#define KI_USER_SHARED_DATA     0xFFFFF78000000000UI64

#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

//
// Intrinsic functions
//

//  begin_wdm

#if defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

// end_wdm

//
// The following routines are provided for backward compatibility with old
// code. They are no longer the preferred way to accomplish these functions.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#define ExInterlockedDecrementLong(Addend, Lock)                            \
    _ExInterlockedDecrementLong(Addend)

__forceinline
LONG
_ExInterlockedDecrementLong (
    IN OUT PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedDecrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedIncrementLong(Addend, Lock)                            \
    _ExInterlockedIncrementLong(Addend)

__forceinline
LONG
_ExInterlockedIncrementLong (
    IN OUT PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedIncrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedExchangeUlong(Target, Value, Lock)                     \
    _ExInterlockedExchangeUlong(Target, Value)

__forceinline
_ExInterlockedExchangeUlong (
    IN OUT PULONG Target,
    IN ULONG Value
    )

{

    return (ULONG)InterlockedExchange((PLONG)Target, (LONG)Value);
}

// begin_wdm

#endif // defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)


#if !defined(MIDL_PASS) && defined(_M_AMD64)

//
// AMD646 function prototype definitions
//

// end_wdm


//
// Get address of current processor block.
//

__forceinline
PKPRCB
KeGetCurrentPrcb (
    VOID
    )

{

    return (PKPRCB)__readgsqword(FIELD_OFFSET(KPCR, CurrentPrcb));
}

// begin_ntddk

//
// Get the current processor number
//

__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return (ULONG)__readgsbyte(FIELD_OFFSET(KPCR, Number));
}


// begin_wdm

#endif // !defined(MIDL_PASS) && defined(_M_AMD64)


NTKERNELAPI
NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE SaveArea
    );

NTKERNELAPI
NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE SaveArea
    );


#endif // defined(_AMD64_)


#ifdef _AMD64_

VOID
KeSetIoAccessMap (
    PKIO_ACCESS_MAP IoAccessMap
    );

VOID
KeQueryIoAccessMap (
    PKIO_ACCESS_MAP IoAccessMap
    );

VOID
KeSetIoAccessProcess (
    struct _KPROCESS *Process,
    BOOLEAN Enable
    );

VOID
KiEditIopmDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#endif //_AMD64_

//
// Platform specific kernel fucntions to raise and lower IRQL.
//
// These functions are imported for ntddk, ntifs, and wdm. They are
// inlined for nthal, ntosp, and the system.
//

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_WDMDDK_)

// begin_ntddk begin_wdm

#if defined(_AMD64_)

NTKERNELAPI
KIRQL
KeGetCurrentIrql (
    VOID
    );

NTKERNELAPI
VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTKERNELAPI
KIRQL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

// end_wdm

NTKERNELAPI
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );

NTKERNELAPI
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );

// begin_wdm

#endif // defined(_AMD64_)

// end_ntddk end_wdm

#else

// begin_nthal

#if defined(_AMD64_) && !defined(MIDL_PASS)

__forceinline
KIRQL
KeGetCurrentIrql (
    VOID
    )

/*++

Routine Description:

    This function return the current IRQL.

Arguments:

    None.

Return Value:

    The current IRQL is returned as the function value.

--*/

{

    return (KIRQL)ReadCR8();
}

__forceinline
VOID
KeLowerIrql (
   IN KIRQL NewIrql
   )

/*++

Routine Description:

    This function lowers the IRQL to the specified value.

Arguments:

    NewIrql  - Supplies the new IRQL value.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= NewIrql);

    WriteCR8(NewIrql);
    return;
}

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

__forceinline
KIRQL
KfRaiseIrql (
    IN KIRQL NewIrql
    )

/*++

Routine Description:

    This function raises the current IRQL to the specified value and returns
    the previous IRQL.

Arguments:

    NewIrql (cl) - Supplies the new IRQL value.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= NewIrql);

    WriteCR8(NewIrql);
    return OldIrql;
}

__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= DISPATCH_LEVEL);

    WriteCR8(DISPATCH_LEVEL);
    return OldIrql;
}

__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= SYNCH_LEVEL);

    WriteCR8(SYNCH_LEVEL);
    return OldIrql;
}

#endif // defined(_AMD64_) && !defined(MIDL_PASS)

// end_nthal

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_WDMDDK_)


#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 100

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"


#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
void __setReg (int, unsigned __int64);
void __isrlz (void);
void __dsrlz (void);
void __fwb (void);
void __mf (void);
void __mfa (void);
void __synci (void);
__int64 __thash (__int64);
__int64 __ttag (__int64);
void __ptcl (__int64, __int64);
void __ptcg (__int64, __int64);
void __ptcga (__int64, __int64);
void __ptri (__int64, __int64);
void __ptrd (__int64, __int64);
void __invalat (void);
void __break (int);
void __fc (__int64);
void __sum (int);
void __rsm (int);
void _ReleaseSpinLock( unsigned __int64 *);

#ifdef _M_IA64
#pragma intrinsic (__getReg)
#pragma intrinsic (__setReg)
#pragma intrinsic (__isrlz)
#pragma intrinsic (__dsrlz)
#pragma intrinsic (__fwb)
#pragma intrinsic (__mf)
#pragma intrinsic (__mfa)
#pragma intrinsic (__synci)
#pragma intrinsic (__thash)
#pragma intrinsic (__ttag)
#pragma intrinsic (__ptcl)
#pragma intrinsic (__ptcg)
#pragma intrinsic (__ptcga)
#pragma intrinsic (__ptri)
#pragma intrinsic (__ptrd)
#pragma intrinsic (__invalat)
#pragma intrinsic (__break)
#pragma intrinsic (__fc)
#pragma intrinsic (__sum)
#pragma intrinsic (__rsm)
#pragma intrinsic (_ReleaseSpinLock)

#endif // _M_IA64

#ifdef __cplusplus
}
#endif


// end_wdm end_ntndis

//
// Define macro to generate import names.
//

#define IMPORT_NAME(name) __imp_##name

// begin_wdm

//
// Define length of interrupt vector table.
//

#define MAXIMUM_VECTOR 256

// end_wdm


//
// IA64 specific interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for values are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecture specific interfaces.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExIa64InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExIa64InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExIa64InterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExIa64InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

// begin_wdm

//
// IA64 Interrupt Definitions.
//
// Define length of interrupt object dispatch code in longwords.
//

#define DISPATCH_LENGTH 2*2                // Length of dispatch code template in 32-bit words

//
// Begin of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL            0      // Passive release level
#define LOW_LEVEL                0      // Lowest interrupt level
#define APC_LEVEL                1      // APC interrupt level
#define DISPATCH_LEVEL           2      // Dispatcher level
#define CMC_LEVEL                3      // Correctable machine check level
#define DEVICE_LEVEL_BASE        4      // 4 - 11 - Device IRQLs
#define PC_LEVEL                12      // Performance Counter IRQL
#define IPI_LEVEL               14      // IPI IRQL
#define CLOCK_LEVEL             13      // Clock Timer IRQL
#define POWER_LEVEL             15      // Power failure level
#define PROFILE_LEVEL           15      // Profiling level
#define HIGH_LEVEL              15      // Highest interrupt level

#if defined(NT_UP)

#define SYNCH_LEVEL             DISPATCH_LEVEL  // Synchronization level - UP

#else

#define SYNCH_LEVEL             (IPI_LEVEL-1) // Synchronization level - MP

#endif

//
// The current IRQL is maintained in the TPR.mic field. The
// shift count is the number of bits to shift right to extract the
// IRQL from the TPR. See the GET/SET_IRQL macros.
//

#define TPR_MIC        4
#define TPR_IRQL_SHIFT TPR_MIC

// To go from vector number <-> IRQL we just do a shift
#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT

//
// Interrupt Vector Definitions
//

#define APC_VECTOR          APC_LEVEL << VECTOR_IRQL_SHIFT
#define DISPATCH_VECTOR     DISPATCH_LEVEL << VECTOR_IRQL_SHIFT


//
// End of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define profile intervals.
//

#define DEFAULT_PROFILE_COUNT 0x40000000 // ~= 20 seconds @50mhz
#define DEFAULT_PROFILE_INTERVAL (10 * 500) // 500 microseconds
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 40) // 40 microseconds

#if defined(_M_IA64) && !defined(RC_INVOKED)

#define InterlockedAdd _InterlockedAdd
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    LONG volatile *Addend,
    LONG Value
    );

LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_IA64) && !defined(RC_INVOKED)


#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))
#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)

//
// Prototype for get current IRQL. **** TBD (read TPR)
//

NTKERNELAPI
KIRQL
KeGetCurrentIrql();

// end_wdm

//
// Get address of current processor block.
//

#define KeGetCurrentPrcb() PCR->Prcb

//
// Get address of processor control region.
//

#define KeGetPcr() PCR

//
// Get address of current kernel thread object.
//

#if defined(_M_IA64)
#define KeGetCurrentThread() PCR->CurrentThread
#endif

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() PCR->Number

//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() PCR->DcacheFillSize


#define KeSaveFloatingPointState(a)         STATUS_SUCCESS
#define KeRestoreFloatingPointState(a)      STATUS_SUCCESS


//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

// end_wdm

#else


NTKERNELAPI
VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONG   Reserved;
} KFLOATING_SAVE, *PKFLOATING_SAVE;


//
// Processor Control Block (PRCB)
//

#define PRCB_MINOR_VERSION 1
#define PRCB_MAJOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

struct _RESTART_BLOCK;

typedef struct _KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
//

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *RESTRICTED_POINTER NextThread;
    struct _KTHREAD *IdleThread;
    CCHAR Number;
    CCHAR WakeIdle;
    USHORT BuildType;
    KAFFINITY SetMember;
    struct _RESTART_BLOCK *RestartBlock;
    ULONG_PTR PcrPage;
    ULONG Spare0[4];

//
// Processor Idendification Registers.
//

    ULONG     ProcessorModel;
    ULONG     ProcessorRevision;
    ULONG     ProcessorFamily;
    ULONG     ProcessorArchRev;
    ULONGLONG ProcessorSerialNumber;
    ULONGLONG ProcessorFeatureBits;
    UCHAR     ProcessorVendorString[16];

//
// Space reserved for the system.
//

    ULONGLONG SystemReserved[8];

//
// Space reserved for the HAL.
//

    ULONGLONG HalReserved[16];

//
// End of the architecturally defined section of the PRCB.
} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// begin_ntndis

//
// OS_MCA, OS_INIT HandOff State definitions
//
// Note: The following definitions *must* match the definiions of the
//       corresponding SAL Revision Hand-Off structures.
//

typedef struct _SAL_HANDOFF_STATE   {
    ULONGLONG     PalProcEntryPoint;
    ULONGLONG     SalProcEntryPoint;
    ULONGLONG     SalGlobalPointer;
     LONGLONG     RendezVousResult;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     MinStateSavePtr;
} SAL_HANDOFF_STATE, *PSAL_HANDOFF_STATE;

typedef struct _OS_HANDOFF_STATE    {
    ULONGLONG     Result;
    ULONGLONG     SalGlobalPointer;
    ULONGLONG     MinStateSavePtr;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     NewContextFlag;
} OS_HANDOFF_STATE, *POS_HANDOFF_STATE;

//
// per processor OS_MCA and OS_INIT resource structure
//


#define SER_EVENT_STACK_FRAME_ENTRIES    8

typedef struct _SAL_EVENT_RESOURCES {

    SAL_HANDOFF_STATE   SalToOsHandOff;
    OS_HANDOFF_STATE    OsToSalHandOff;
    PVOID               StateDump;
    ULONGLONG           StateDumpPhysical;
    PVOID               BackStore;
    ULONGLONG           BackStoreLimit;
    PVOID               Stack;
    ULONGLONG           StackLimit;
    PULONGLONG          PTOM;
    ULONGLONG           StackFrame[SER_EVENT_STACK_FRAME_ENTRIES];
    PVOID               EventPool;
    ULONG               EventPoolSize;
} SAL_EVENT_RESOURCES, *PSAL_EVENT_RESOURCES;

//
// PAL Mini-save area, used by MCA and INIT
//

typedef struct _PAL_MINI_SAVE_AREA {
    ULONGLONG IntNats;      //  Nat bits for r1-r31
                            //  r1-r31 in bits 1 thru 31.
    ULONGLONG IntGp;        //  r1, volatile
    ULONGLONG IntT0;        //  r2-r3, volatile
    ULONGLONG IntT1;        //
    ULONGLONG IntS0;        //  r4-r7, preserved
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntV0;        //  r8, volatile
    ULONGLONG IntT2;        //  r9-r11, volatile
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;        //  stack pointer (r12), special
    ULONGLONG IntTeb;       //  teb (r13), special
    ULONGLONG IntT5;        //  r14-r31, volatile
    ULONGLONG IntT6;

    ULONGLONG B0R16;        // Bank 0 registers 16-31
    ULONGLONG B0R17;        
    ULONGLONG B0R18;        
    ULONGLONG B0R19;        
    ULONGLONG B0R20;        
    ULONGLONG B0R21;        
    ULONGLONG B0R22;        
    ULONGLONG B0R23;        
    ULONGLONG B0R24;        
    ULONGLONG B0R25;        
    ULONGLONG B0R26;        
    ULONGLONG B0R27;        
    ULONGLONG B0R28;        
    ULONGLONG B0R29;        
    ULONGLONG B0R30;        
    ULONGLONG B0R31;        

    ULONGLONG IntT7;        // Bank 1 registers 16-31
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG Preds;        //  predicates, preserved
    ULONGLONG BrRp;         //  return pointer, b0, preserved
    ULONGLONG RsRSC;        //  RSE configuration, volatile
    ULONGLONG StIIP;        //  Interruption IP
    ULONGLONG StIPSR;       //  Interruption Processor Status
    ULONGLONG StIFS;        //  Interruption Function State
    ULONGLONG XIP;          //  Event IP
    ULONGLONG XPSR;         //  Event Processor Status
    ULONGLONG XFS;          //  Event Function State
    
} PAL_MINI_SAVE_AREA, *PPAL_MINI_SAVE_AREA;

//
// Define Processor Control Region Structure.
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//
    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

//
// First and second level cache parameters.
//

    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;
    ULONG SecondLevelDcacheSize;
    ULONG SecondLevelDcacheFillSize;
    ULONG SecondLevelIcacheSize;
    ULONG SecondLevelIcacheFillSize;

//
// Data cache alignment and fill size used for cache flushing and alignment.
// These fields are set to the larger of the first and second level data
// cache fill sizes.
//

    ULONG DcacheAlignment;
    ULONG DcacheFillSize;

//
// Instruction cache alignment and fill size used for cache flushing and
// alignment. These fields are set to the larger of the first and second
// level data cache fill sizes.
//

    ULONG IcacheAlignment;
    ULONG IcacheFillSize;

//
// Processor identification from PrId register.
//

    ULONG ProcessorId;

//
// Profiling data.
//

    ULONG ProfileInterval;
    ULONG ProfileCount;

//
// Stall execution count and scale factor.
//

    ULONG StallExecutionCount;
    ULONG StallScaleFactor;

    ULONG InterruptionCount;

//
// Space reserved for the system.
//

    ULONGLONG   SystemReserved[6];

//
// Space reserved for the HAL
//

    ULONGLONG   HalReserved[64];

//
// IRQL mapping tables.
//

    UCHAR IrqlMask[64];
    UCHAR IrqlTable[64];

//
// External Interrupt vectors.
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved interrupt vector mask.
//

    ULONG ReservedVectors;

//
// Processor affinity mask.
//

    KAFFINITY SetMember;

//
// Complement of the processor affinity mask.
//

    KAFFINITY NotMember;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
//  Shadow copy of Prcb->CurrentThread for fast access
//

    struct _KTHREAD *CurrentThread;

//
// Processor number.
//

    CCHAR Number;                        // Processor Number
    UCHAR DebugActive;                   // debug register active in user flag
    UCHAR KernelDebugActive;             // debug register active in kernel flag
    UCHAR CurrentIrql;                   // Current IRQL
    union {
        USHORT SoftwareInterruptPending; // Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;          // 0x01 if APC int pending
            UCHAR DispatchInterrupt;     // 0x01 if dispatch int pending
        };
    };

//
// Address of per processor SAPIC EOI Table
//

    PVOID       EOITable;

//
// IA-64 Machine Check Events trackers
//

    UCHAR       InOsMca;
    UCHAR       InOsInit;
    UCHAR       InOsCmc;
    UCHAR       InOsCpe;
    ULONG       InOsULONG_Spare; // Spare ULONG
    PSAL_EVENT_RESOURCES OsMcaResourcePtr;
    PSAL_EVENT_RESOURCES OsInitResourcePtr;

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

// end_nthal end_ntddk

//
// OS Part
//

//
//  Address of the thread who currently owns the high fp register set
//

    struct _KTHREAD *HighFpOwner;

//  Per processor kernel (ntoskrnl.exe) global pointer
    ULONGLONG   KernelGP;
//  Per processor initial kernel stack for current thread
    ULONGLONG   InitialStack;
//  Per processor pointer to kernel BSP
    ULONGLONG   InitialBStore;
//  Per processor kernel stack limit
    ULONGLONG   StackLimit;
//  Per processor kernel backing store limit
    ULONGLONG   BStoreLimit;
//  Per processor panic kernel stack
    ULONGLONG   PanicStack;

//
//  Save area for kernel entry/exit
//
    ULONGLONG   SavedIIM;
    ULONGLONG   SavedIFA;

    ULONGLONG   ForwardProgressBuffer[16];
    PVOID       Pcb;      // holds KPROCESS for MP region synchronization

//
//  Nt page table base addresses
//
    ULONGLONG   PteUbase;
    ULONGLONG   PteKbase;
    ULONGLONG   PteSbase;
    ULONGLONG   PdeUbase;
    ULONGLONG   PdeKbase;
    ULONGLONG   PdeSbase;
    ULONGLONG   PdeUtbase;
    ULONGLONG   PdeKtbase;
    ULONGLONG   PdeStbase;

//
//  The actual resources for the OS_INIT and OS_MCA handlers
//  are placed at the end of the PCR structure so that auto
//  can be used to get to get between the public and private
//  sections of the PCR in the traps and context routines.
//
    SAL_EVENT_RESOURCES OsMcaResource;
    SAL_EVENT_RESOURCES OsInitResource;

// begin_nthal begin_ntddk

} KPCR, *PKPCR;


//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG_PTR MmUserProbeAddress;


#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)((ULONG_PTR)(UADDRESS_BASE+0x00010000))

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(PLabelAddress) \
    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))

#define VRN_MASK   0xE000000000000000UI64    // Virtual Region Number mask

#endif // defined(_IA64_)

//
// Define structure of boot driver list.
//

typedef struct _BOOT_DRIVER_LIST_ENTRY {
    LIST_ENTRY Link;
    UNICODE_STRING FilePath;
    UNICODE_STRING RegistryPath;
    PKLDR_DATA_TABLE_ENTRY LdrEntry;
} BOOT_DRIVER_LIST_ENTRY, *PBOOT_DRIVER_LIST_ENTRY;
#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks
//

#if defined(_X86_)

#define PAUSE_PROCESSOR _asm { rep nop }

#else

#define PAUSE_PROCESSOR

#endif


//
// Define macro to generate an affinity mask.
//

#define AFFINITY_MASK(n) ((ULONG_PTR)1 << (n))


typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
    } KAPC_ENVIRONMENT;

// begin_ntddk begin_wdm begin_nthal begin_ntminiport begin_ntifs begin_ntndis

//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    Spare2,
    Spare3,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

// end_ntddk end_wdm end_nthal

//
// Miscellaneous type definitions
//
// APC state
//

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[MaximumMode];
    struct _KPROCESS *Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;
    BOOLEAN Busy;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

//
// Define the interrupt service function type and the empty struct
// type.
//
typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );
typedef struct _KINTERRUPT *PKINTERRUPT, *RESTRICTED_POINTER PRKINTERRUPT; 
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT, KMUTEX, *PKMUTEX, *RESTRICTED_POINTER PRKMUTEX;

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;
//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;


NTKERNELAPI
VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN KAPC_ENVIRONMENT Environment,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ProcessorMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    );

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    );

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    );

//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

// end_wdm

NTKERNELAPI
VOID
KeSetImportanceDpc (
    IN PRKDPC Dpc,
    IN KDPC_IMPORTANCE Importance
    );

NTKERNELAPI
VOID
KeSetTargetProcessorDpc (
    IN PRKDPC Dpc,
    IN CCHAR Number
    );

// begin_wdm

NTKERNELAPI
VOID
KeFlushQueuedDpcs (
    VOID
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueueIfBusy (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );


NTKERNELAPI
BOOLEAN
KeSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

NTKERNELAPI
KIRQL
KeAcquireInterruptSpinLock (
    IN PKINTERRUPT Interrupt
    );

NTKERNELAPI
VOID
KeReleaseInterruptSpinLock (
    IN PKINTERRUPT Interrupt,
    IN KIRQL OldIrql
    );

//
// Kernel dispatcher object functions
//
// Event Object
//


NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

NTKERNELAPI
VOID
KeClearEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

NTKERNELAPI
LONG
KeReadStateEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );


NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

//
// Mutex object
//

NTKERNELAPI
VOID
KeInitializeMutex (
    IN PRKMUTEX Mutex,
    IN ULONG Level
    );

NTKERNELAPI
LONG
KeReadStateMutex (
    IN PRKMUTEX Mutex
    );

NTKERNELAPI
LONG
KeReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm
//
// Queue Object.
//

NTKERNELAPI
VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    );

NTKERNELAPI
LONG
KeReadStateQueue (
    IN PRKQUEUE Queue
    );

NTKERNELAPI
LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    );

// begin_ntddk begin_wdm
//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

NTKERNELAPI
LONG
KeReadStateSemaphore (
    IN PRKSEMAPHORE Semaphore
    );

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );


NTKERNELAPI
VOID
KeAttachProcess (
    IN PRKPROCESS Process
    );

NTKERNELAPI
VOID
KeDetachProcess (
    VOID
    );


NTKERNELAPI
VOID
KeStackAttachProcess (
    IN PRKPROCESS PROCESS,
    OUT PRKAPC_STATE ApcState
    );

NTKERNELAPI
VOID
KeUnstackDetachProcess (
    IN PRKAPC_STATE ApcState
    );


NTKERNELAPI
BOOLEAN
KeIsAttachedProcess(
    VOID
    );

NTKERNELAPI                                         // ntddk wdm nthal ntifs
NTSTATUS                                            // ntddk wdm nthal ntifs
KeDelayExecutionThread (                            // ntddk wdm nthal ntifs
    IN KPROCESSOR_MODE WaitMode,                    // ntddk wdm nthal ntifs
    IN BOOLEAN Alertable,                           // ntddk wdm nthal ntifs
    IN PLARGE_INTEGER Interval                      // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs

VOID
KeRevertToUserAffinityThread (
    VOID
    );


VOID
KeSetSystemAffinityThread (
    IN KAFFINITY Affinity
    );

NTKERNELAPI
BOOLEAN
KeSetKernelStackSwapEnable (
    IN BOOLEAN Enable
    );

// end_ntifs
NTKERNELAPI                                         // ntddk wdm nthal ntifs
KPRIORITY                                           // ntddk wdm nthal ntifs
KeSetPriorityThread (                               // ntddk wdm nthal ntifs
    IN PKTHREAD Thread,                             // ntddk wdm nthal ntifs
    IN KPRIORITY Priority                           // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs

#if ((defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) ||defined(_NTHAL_)) && !defined(_NTSYSTEM_DRIVER_) || defined(_NTOSP_))

// begin_wdm

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

NTKERNELAPI
BOOLEAN
KeAreApcsDisabled(
    VOID
    );

// end_wdm

#else

//++
//
// VOID
// KeEnterCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegion() KeGetCurrentThread()->KernelApcDisable -= 1

//++
//
// VOID
// KeEnterCriticalRegionThread (
//    PKTHREAD CurrentThread
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's for the current thread only.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    CurrentThread - Current thread thats executing. This must be the
//                    current thread.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegionThread(CurrentThread) { \
    ASSERT (CurrentThread == KeGetCurrentThread ()); \
    (CurrentThread)->KernelApcDisable -= 1;          \
}

//++
//
// VOID
// KeLeaveCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function enables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeLeaveCriticalRegion() KiLeaveCriticalRegion()

//++
//
// VOID
// KeLeaveCriticalRegionThread (
//    PKTHREAD CurrentThread
//    )
//
//
// Routine Description:
//
//    This function enables kernel APC's for the current thread.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    CurrentThread - Current thread thats executing. This must be the
//                    current thread.
//
// Return Value:
//
//    None.
//--

#define KeLeaveCriticalRegionThread(CurrentThread) { \
    ASSERT (CurrentThread == KeGetCurrentThread ()); \
    KiLeaveCriticalRegionThread(CurrentThread);      \
}

#define KeAreApcsDisabled() (KeGetCurrentThread()->KernelApcDisable != 0);

//++
//
// KPROCESSOR_MODE
// KeGetPReviousMode (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function gets the threads previous mode from the trap frame
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    KPROCESSOR_MODE - Previous mode for this thread
//--
#define KeGetPreviousMode()     (KeGetCurrentThread()->PreviousMode)

//++
//
// KPROCESSOR_MODE
// KeGetPReviousModeByThread (
//    PKTHREAD xxCurrentThread
//    )
//
//
// Routine Description:
//
//    This function gets the threads previous mode from the trap frame.
//
//
// Arguments:
//
//    xxCurrentThread - Current thread. This can not be a cross thread reference
//
// Return Value:
//
//    KPROCESSOR_MODE - Previous mode for this thread
//--
#define KeGetPreviousModeByThread(xxCurrentThread) (ASSERT (xxCurrentThread == KeGetCurrentThread ()),\
                                                    (xxCurrentThread)->PreviousMode)


#endif

//  begin_wdm

//
// Timer object
//

NTKERNELAPI
VOID
KeInitializeTimer (
    IN PKTIMER Timer
    );

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

NTKERNELAPI
BOOLEAN
KeReadStateTimer (
    PKTIMER Timer
    );

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );


#define KeWaitForMutexObject KeWaitForSingleObject

NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray OPTIONAL
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


//
// On X86 the following routines are defined in the HAL and imported by
// all other modules.
//

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  __declspec(dllimport)

#else

#define _DECL_HAL_KE_IMPORT

#endif


_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    );

_DECL_HAL_KE_IMPORT
LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    );

//
// spin lock functions
//

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

// end_wdm

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

// begin_wdm

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#else

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

NTKERNELAPI
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );


#if defined(_X86_)

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

// end_wdm

_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToDpcLevel(
    VOID
    );

_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToSynchLevel(
    VOID
    );

// begin_wdm

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

// end_wdm

// begin_wdm

#elif defined(_ALPHA_)

#define KeLowerIrql(a)      __swpirql(a)
#define KeRaiseIrql(a,b)    *(b) = __swpirql(a)

// end_wdm

extern ULONG KiSynchIrql;

#define KfRaiseIrql(a)      __swpirql(a)
#define KeRaiseIrqlToDpcLevel() __swpirql(DISPATCH_LEVEL)
#define KeRaiseIrqlToSynchLevel() __swpirql((UCHAR)KiSynchIrql)

// begin_wdm

#elif defined(_IA64_)

VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

VOID
KeRaiseIrql (
    IN KIRQL NewIrql,
    OUT PKIRQL OldIrql
    );

// end_wdm

KIRQL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );

KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );

// begin_wdm

#elif defined(_AMD64_)

//
// These function are defined in amd64.h for the AMD64 platform.
//

#else

#error "no target architecture"

#endif

//
// Queued spin lock functions for "in stack" lock handles.
//
// The following three functions RAISE and LOWER IRQL when a queued
// in stack spin lock is acquired or released using these routines.
//

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeAcquireInStackQueuedSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );


_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseInStackQueuedSpinLock (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

//
// The following two functions do NOT raise or lower IRQL when a queued
// in stack spin lock is acquired or released using these functions.
//

NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

//
// Miscellaneous kernel functions
//

typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;

typedef
VOID
(*PKBUGCHECK_CALLBACK_ROUTINE) (
    IN PVOID Buffer,
    IN ULONG Length
    );

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

#define KeInitializeCallbackRecord(CallbackRecord) \
    (CallbackRecord)->State = BufferEmpty

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    );

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PUCHAR Component
    );

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
} KBUGCHECK_CALLBACK_REASON;

typedef
VOID
(*PKBUGCHECK_REASON_CALLBACK_ROUTINE) (
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN struct _KBUGCHECK_REASON_CALLBACK_RECORD* Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    );

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    IN PVOID InBuffer;
    IN ULONG InBufferLength;
    IN ULONG MaximumAllowed;
    OUT GUID Guid;
    OUT PVOID OutBuffer;
    OUT ULONG OutBufferLength;
} KBUGCHECK_SECONDARY_DUMP_DATA, *PKBUGCHECK_SECONDARY_DUMP_DATA;

typedef enum _KBUGCHECK_DUMP_IO_TYPE
{
    KbDumpIoInvalid,
    KbDumpIoHeader,
    KbDumpIoBody,
    KbDumpIoSecondaryData,
    KbDumpIoComplete
} KBUGCHECK_DUMP_IO_TYPE;

typedef struct _KBUGCHECK_DUMP_IO {
    IN ULONG64 Offset;
    IN PVOID Buffer;
    IN ULONG BufferLength;
    IN KBUGCHECK_DUMP_IO_TYPE Type;
} KBUGCHECK_DUMP_IO, *PKBUGCHECK_DUMP_IO;

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckReasonCallback (
    IN PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord
    );

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckReasonCallback (
    IN PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PUCHAR Component
    );

// end_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );


NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

#define WIN32K_SERVICE_INDEX 1
#define IIS_SERVICE_INDEX 2
NTKERNELAPI
BOOLEAN
KeAddSystemServiceTable(
    IN PULONG_PTR Base,
    IN PULONG Count OPTIONAL,
    IN ULONG Limit,
    IN PUCHAR Number,
    IN ULONG Index
    );

NTKERNELAPI
BOOLEAN
KeRemoveSystemServiceTable(
    IN ULONG Index
    );

NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

NTKERNELAPI
ULONG
KeQueryTimeIncrement (
    VOID
    );

NTKERNELAPI
ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    );

// end_wdm
NTKERNELAPI
KAFFINITY
KeQueryActiveProcessors (
    VOID
    );


//
// Define the firmware routine types
//

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalPowerDownRoutine,
    HalRestartRoutine,
    HalRebootRoutine,
    HalInteractiveModeRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;
NTKERNELAPI
NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    );
//
// Time update notify routine.
//

typedef
VOID
(FASTCALL *PTIME_UPDATE_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId,
    IN KPROCESSOR_MODE Mode
    );

NTKERNELAPI
VOID
FASTCALL
KeSetTimeUpdateNotifyRoutine(
    IN PTIME_UPDATE_NOTIFY_ROUTINE NotifyRoutine
    );

extern PLOADER_PARAMETER_BLOCK KeLoaderBlock;       
extern NTSYSAPI CCHAR KeNumberProcessors;           

#if defined(_AMD64_) || defined(_ALPHA_) || defined(_IA64_)

extern volatile LARGE_INTEGER KeTickCount;

#else

extern volatile KSYSTEM_TIME KeTickCount;

#endif


typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmNonCachedUnordered,       // IA64
    MmUSWCCached,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;

#define POOL_COLD_ALLOCATION 256     // Note this cannot encode into the header.

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis begin_ntosp

//
// The following two definitions control the raising of exceptions on quota
// and allocation failures.
//

#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16               // ntifs



NTKERNELAPI
PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

//
// _EX_POOL_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPoolPriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//
// SpecialPool can be specified to bound the allocation at a page end (or
// beginning).  This should only be done on systems being debugged as the
// memory cost is expensive.
//
// N.B.  These values are very carefully chosen so that the pool allocation
//       code can quickly crack the priority request.
//

typedef enum _EX_POOL_PRIORITY {
    LowPoolPriority,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41

    } EX_POOL_PRIORITY;

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTagPriority(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif //POOL_TAGGING

NTKERNELAPI
PVOID
ExAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

// end_wdm
#if defined(POOL_TAGGING)
#define ExFreePool(a) ExFreePoolWithTag(a,0)
#endif

//
// If high order bit in Pool tag is set, then must use ExFreePoolWithTag to free
//

#define PROTECTED_POOL 0x80000000

// begin_wdm
NTKERNELAPI
VOID
ExFreePoolWithTag(
    IN PVOID P,
    IN ULONG Tag
    );

// end_ntddk end_wdm end_nthal end_ntifs


#ifndef POOL_TAGGING
#define ExFreePoolWithTag(a,b) ExFreePool(a)
#endif //POOL_TAGGING

NTKERNELAPI                                     // ntifs
SIZE_T                                          // ntifs
ExQueryPoolBlockSize (                          // ntifs
    IN PVOID PoolBlock,                         // ntifs
    OUT PBOOLEAN QuotaCharged                   // ntifs
    );                                          // ntifs
//
// Routines to support fast mutexes.
//

typedef struct _FAST_MUTEX {
    LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Event;
    ULONG OldIrql;
} FAST_MUTEX, *PFAST_MUTEX;

#define ExInitializeFastMutex(_FastMutex)                            \
    (_FastMutex)->Count = 1;                                         \
    (_FastMutex)->Owner = NULL;                                      \
    (_FastMutex)->Contention = 0;                                    \
    KeInitializeEvent(&(_FastMutex)->Event,                          \
                      SynchronizationEvent,                          \
                      FALSE);

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

#if defined(_ALPHA_) || defined(_IA64_) || defined(_AMD64_)

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#elif defined(_X86_)

NTHALAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTHALAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTHALAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#else

#error "Target architecture not defined"

#endif

//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

// end_ntndis

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment,
    IN PKSPIN_LOCK Lock
    );


NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong (
    IN PULONG Addend,
    IN ULONG Increment,
    IN PKSPIN_LOCK Lock
    );


#if defined(_AMD64_) || defined(_AXP64_) || defined(_IA64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#elif defined(_ALPHA_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExpInterlockedCompareExchange64(Destination, Exchange, Comperand)

#else

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExfInterlockedCompareExchange64(Destination, Exchange, Comperand)

#endif

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables AMD64, IA64, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
//

#if !defined(_WINBASE_)

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

{

#ifdef _WIN64

    //
    // Slist headers must be 16 byte aligned.
    //

    if ((ULONG_PTR) SListHead & 0x0f) {

        DbgPrint( "InitializeSListHead unaligned Slist header.  Address = %p, Caller = %p\n", SListHead, _ReturnAddress());
        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    }

#endif

    SListHead->Alignment = 0;

    //
    // For IA-64 we save the region number of the elements of the list in a
    // separate field.  This imposes the requirement that all elements stored
    // in the list are from the same region.

#if defined(_IA64_)

    SListHead->Region = (ULONG_PTR)SListHead & VRN_MASK;

#elif defined(_AMD64_)

    SListHead->Region = 0;

#endif

    return;
}

#endif

#endif // !defined(_WINBASE_)

#define ExInitializeSListHead InitializeSListHead

PSLIST_ENTRY
FirstEntrySList (
    IN const SLIST_HEADER *SListHead
    );

/*++

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#if defined(_WIN64)

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    )

{

    return (USHORT)(SListHead->Alignment & 0xffff);
}

#endif

#else

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

#endif

#if defined(_WIN64)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#if !defined(_WINBASE_)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#else

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

#else

#define ExInterlockedPopEntrySList(ListHead, Lock) \
    InterlockedPopEntrySList(ListHead)

#define ExInterlockedPushEntrySList(ListHead, ListEntry, Lock) \
    InterlockedPushEntrySList(ListHead, ListEntry)

#endif

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#if !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

#define InterlockedFlushSList(Head) \
    ExInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

#endif // defined(_WIN64)


typedef
PVOID
(*PALLOCATE_FUNCTION) (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    IN PVOID Buffer
    );

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _GENERAL_LOOKASIDE {

#else

typedef struct DECLSPEC_CACHEALIGN _GENERAL_LOOKASIDE {

#endif

    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    union {
        ULONG AllocateMisses;
        ULONG AllocateHits;
    };

    ULONG TotalFrees;
    union {
        ULONG FreeMisses;
        ULONG FreeHits;
    };

    POOL_TYPE Type;
    ULONG Tag;
    ULONG Size;
    PALLOCATE_FUNCTION Allocate;
    PFREE_FUNCTION Free;
    LIST_ENTRY ListEntry;
    ULONG LastTotalAllocates;
    union {
        ULONG LastAllocateMisses;
        ULONG LastAllocateHits;
    };

    ULONG Future[2];
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _NPAGED_LOOKASIDE_LIST {

#else

typedef struct DECLSPEC_CACHEALIGN _NPAGED_LOOKASIDE_LIST {

#endif

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;

#endif

} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    );

__inline
PVOID
ExAllocateFromNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);


#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);

#endif

    }
    return;
}

// end_ntndis

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_)  || defined(_NDIS_))

typedef struct _PAGED_LOOKASIDE_LIST {

#else

typedef struct DECLSPEC_CACHEALIGN _PAGED_LOOKASIDE_LIST {

#endif

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    FAST_MUTEX Lock__ObsoleteButDoNotDelete;

#endif

} PAGED_LOOKASIDE_LIST, *PPAGED_LOOKASIDE_LIST;


NTKERNELAPI
VOID
ExInitializePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeletePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PVOID
ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

#else

__inline
PVOID
ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

#endif

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
VOID
ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    );

#else

__inline
VOID
ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);
    }

    return;
}

#endif


NTKERNELAPI
VOID
NTAPI
ProbeForRead(
    IN CONST VOID *Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    );

// Probe function definitions
//
// Probe for read functions.
//
//++
//
// VOID
// ProbeForRead(
//     IN PVOID Address,
//     IN ULONG Length,
//     IN ULONG Alignment
//     )
//
//--

#define ProbeForRead(Address, Length, Alignment)                             \
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||                       \
           ((Alignment) == 4) || ((Alignment) == 8) ||                       \
           ((Alignment) == 16));                                             \
                                                                             \
    if ((Length) != 0) {                                                     \
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {               \
            ExRaiseDatatypeMisalignment();                                   \
                                                                             \
        }                                                                    \
        if ((((ULONG_PTR)(Address) + (Length)) < (ULONG_PTR)(Address)) ||    \
            (((ULONG_PTR)(Address) + (Length)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
            ExRaiseAccessViolation();                                        \
        }                                                                    \
    }

//++
//
// VOID
// ProbeForReadSmallStructure(
//     IN PVOID Address,
//     IN ULONG Length,
//     IN ULONG Alignment
//     )
//
//--

#define ProbeForReadSmallStructure(Address,Size,Alignment) {                 \
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||                       \
           ((Alignment) == 4) || ((Alignment) == 8) ||                       \
           ((Alignment) == 16));                                             \
    if (Size == 0 || Size > 0x10000) {                                       \
        ASSERT (0);                                                          \
        ProbeForRead (Address,Size,Alignment);                               \
    } else {                                                                 \
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {               \
            ExRaiseDatatypeMisalignment();                                   \
        }                                                                    \
        if ((ULONG_PTR)(Address) >= (ULONG_PTR)MM_USER_PROBE_ADDRESS) {      \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;              \
        }                                                                    \
    }                                                                        \
}


//++
//
// BOOLEAN
// ProbeAndReadBoolean(
//     IN PBOOLEAN Address
//     )
//
//--

#define ProbeAndReadBoolean(Address) \
    (((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS) : (*(volatile BOOLEAN *)(Address)))

//++
//
// CHAR
// ProbeAndReadChar(
//     IN PCHAR Address
//     )
//
//--

#define ProbeAndReadChar(Address) \
    (((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CHAR * const)MM_USER_PROBE_ADDRESS) : (*(volatile CHAR *)(Address)))

//++
//
// UCHAR
// ProbeAndReadUchar(
//     IN PUCHAR Address
//     )
//
//--

#define ProbeAndReadUchar(Address) \
    (((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UCHAR * const)MM_USER_PROBE_ADDRESS) : (*(volatile UCHAR *)(Address)))

//++
//
// SHORT
// ProbeAndReadShort(
//     IN PSHORT Address
//     )
//
//--

#define ProbeAndReadShort(Address) \
    (((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SHORT * const)MM_USER_PROBE_ADDRESS) : (*(volatile SHORT *)(Address)))

//++
//
// USHORT
// ProbeAndReadUshort(
//     IN PUSHORT Address
//     )
//
//--

#define ProbeAndReadUshort(Address) \
    (((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile USHORT * const)MM_USER_PROBE_ADDRESS) : (*(volatile USHORT *)(Address)))

//++
//
// HANDLE
// ProbeAndReadHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeAndReadHandle(Address) \
    (((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HANDLE * const)MM_USER_PROBE_ADDRESS) : (*(volatile HANDLE *)(Address)))

//++
//
// PVOID
// ProbeAndReadPointer(
//     IN PVOID *Address
//     )
//
//--

#define ProbeAndReadPointer(Address) \
    (((Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile PVOID * const)MM_USER_PROBE_ADDRESS) : (*(volatile PVOID *)(Address)))

//++
//
// LONG
// ProbeAndReadLong(
//     IN PLONG Address
//     )
//
//--

#define ProbeAndReadLong(Address) \
    (((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LONG * const)MM_USER_PROBE_ADDRESS) : (*(volatile LONG *)(Address)))

//++
//
// ULONG
// ProbeAndReadUlong(
//     IN PULONG Address
//     )
//
//--


#define ProbeAndReadUlong(Address) \
    (((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULONG * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULONG *)(Address)))

//++
//
// ULONG_PTR
// ProbeAndReadUlong_ptr(
//     IN PULONG_PTR Address
//     )
//
//--

#define ProbeAndReadUlong_ptr(Address) \
    (((Address) >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULONG_PTR * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULONG_PTR *)(Address)))

//++
//
// QUAD
// ProbeAndReadQuad(
//     IN PQUAD Address
//     )
//
//--

#define ProbeAndReadQuad(Address) \
    (((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile QUAD * const)MM_USER_PROBE_ADDRESS) : (*(volatile QUAD *)(Address)))

//++
//
// UQUAD
// ProbeAndReadUquad(
//     IN PUQUAD Address
//     )
//
//--

#define ProbeAndReadUquad(Address) \
    (((Address) >= (UQUAD * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UQUAD * const)MM_USER_PROBE_ADDRESS) : (*(volatile UQUAD *)(Address)))

//++
//
// LARGE_INTEGER
// ProbeAndReadLargeInteger(
//     IN PLARGE_INTEGER Source
//     )
//
//--

#define ProbeAndReadLargeInteger(Source)  \
    (((Source) >= (LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) : (*(volatile LARGE_INTEGER *)(Source)))

//++
//
// ULARGE_INTEGER
// ProbeAndReadUlargeInteger(
//     IN PULARGE_INTEGER Source
//     )
//
//--

#define ProbeAndReadUlargeInteger(Source)  \
    (((Source) >= (ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULARGE_INTEGER *)(Source)))

//++
//
// UNICODE_STRING
// ProbeAndReadUnicodeString(
//     IN PUNICODE_STRING Source
//     )
//
//--

#define ProbeAndReadUnicodeString(Source)  \
    (((Source) >= (UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) : (*(volatile UNICODE_STRING *)(Source)))
//++
//
// <STRUCTURE>
// ProbeAndReadStructure(
//     IN P<STRUCTURE> Source
//     <STRUCTURE>
//     )
//
//--

#define ProbeAndReadStructure(Source,STRUCTURE)  \
    (((Source) >= (STRUCTURE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(STRUCTURE * const)MM_USER_PROBE_ADDRESS) : (*(STRUCTURE *)(Source)))

//
// Probe for write functions definitions.
//
//++
//
// VOID
// ProbeForWriteBoolean(
//     IN PBOOLEAN Address
//     )
//
//--

#define ProbeForWriteBoolean(Address) {                                      \
    if ((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {               \
        *(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                        \
                                                                             \
    *(volatile BOOLEAN *)(Address) = *(volatile BOOLEAN *)(Address);         \
}

//++
//
// VOID
// ProbeForWriteChar(
//     IN PCHAR Address
//     )
//
//--

#define ProbeForWriteChar(Address) {                                         \
    if ((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile CHAR * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(volatile CHAR *)(Address) = *(volatile CHAR *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteUchar(
//     IN PUCHAR Address
//     )
//
//--

#define ProbeForWriteUchar(Address) {                                        \
    if ((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile UCHAR *)(Address) = *(volatile UCHAR *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteIoStatus(
//     IN PIO_STATUS_BLOCK Address
//     )
//
//--

#define ProbeForWriteIoStatus(Address) {                                     \
    if ((Address) >= (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS) {       \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile IO_STATUS_BLOCK *)(Address) = *(volatile IO_STATUS_BLOCK *)(Address); \
}

#ifdef  _WIN64
#define ProbeForWriteIoStatusEx(Address, Cookie) {                                          \
    if ((Address) >= (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS) {                      \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                                 \
    }                                                                                       \
    if ((ULONG_PTR)(Cookie) & (ULONG)1) {                                                            \
        *(volatile IO_STATUS_BLOCK32 *)(Address) = *(volatile IO_STATUS_BLOCK32 *)(Address);\
    } else {                                                                                \
        *(volatile IO_STATUS_BLOCK *)(Address) = *(volatile IO_STATUS_BLOCK *)(Address);    \
    }                                                                                       \
}
#else
#define ProbeForWriteIoStatusEx(Address, Cookie)    ProbeForWriteIoStatus(Address)
#endif

//++
//
// VOID
// ProbeForWriteShort(
//     IN PSHORT Address
//     )
//
//--

#define ProbeForWriteShort(Address) {                                        \
    if ((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile SHORT * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile SHORT *)(Address) = *(volatile SHORT *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteUshort(
//     IN PUSHORT Address
//     )
//
//--

#define ProbeForWriteUshort(Address) {                                       \
    if ((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile USHORT * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile USHORT *)(Address) = *(volatile USHORT *)(Address);           \
}

//++
//
// VOID
// ProbeForWriteHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeForWriteHandle(Address) {                                       \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile HANDLE *)(Address) = *(volatile HANDLE *)(Address);           \
}

//++
//
// VOID
// ProbeAndZeroHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeAndZeroHandle(Address) {                                        \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile HANDLE *)(Address) = 0;                                       \
}

//++
//
// VOID
// ProbeForWritePointer(
//     IN PVOID Address
//     )
//
//--

#define ProbeForWritePointer(Address) {                                      \
    if ((PVOID *)(Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) {        \
        *(volatile PVOID * const)MM_USER_PROBE_ADDRESS = NULL;               \
    }                                                                        \
                                                                             \
    *(volatile PVOID *)(Address) = *(volatile PVOID *)(Address);             \
}

//++
//
// VOID
// ProbeAndNullPointer(
//     IN PVOID *Address
//     )
//
//--

#define ProbeAndNullPointer(Address) {                                       \
    if ((PVOID *)(Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) {        \
        *(volatile PVOID * const)MM_USER_PROBE_ADDRESS = NULL;               \
    }                                                                        \
                                                                             \
    *(volatile PVOID *)(Address) = NULL;                                     \
}

//++
//
// VOID
// ProbeForWriteLong(
//     IN PLONG Address
//     )
//
//--

#define ProbeForWriteLong(Address) {                                        \
    if ((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                       \
                                                                            \
    *(volatile LONG *)(Address) = *(volatile LONG *)(Address);              \
}

//++
//
// VOID
// ProbeForWriteUlong(
//     IN PULONG Address
//     )
//
//--

#define ProbeForWriteUlong(Address) {                                        \
    if ((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile ULONG *)(Address) = *(volatile ULONG *)(Address);             \
}
//++
//
// VOID
// ProbeForWriteUlong_ptr(
//     IN PULONG_PTR Address
//     )
//
//--

#define ProbeForWriteUlong_ptr(Address) {                                    \
    if ((Address) >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) {             \
        *(volatile ULONG_PTR * const)MM_USER_PROBE_ADDRESS = 0;              \
    }                                                                        \
                                                                             \
    *(volatile ULONG_PTR *)(Address) = *(volatile ULONG_PTR *)(Address);     \
}

//++
//
// VOID
// ProbeForWriteQuad(
//     IN PQUAD Address
//     )
//
//--

#define ProbeForWriteQuad(Address) {                                         \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(volatile QUAD *)(Address) = *(volatile QUAD *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteUquad(
//     IN PUQUAD Address
//     )
//
//--

#define ProbeForWriteUquad(Address) {                                        \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile UQUAD *)(Address) = *(volatile UQUAD *)(Address);             \
}

//
// Probe and write functions definitions.
//
//++
//
// VOID
// ProbeAndWriteBoolean(
//     IN PBOOLEAN Address,
//     IN BOOLEAN Value
//     )
//
//--

#define ProbeAndWriteBoolean(Address, Value) {                               \
    if ((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {               \
        *(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteChar(
//     IN PCHAR Address,
//     IN CHAR Value
//     )
//
//--

#define ProbeAndWriteChar(Address, Value) {                                  \
    if ((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile CHAR * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUchar(
//     IN PUCHAR Address,
//     IN UCHAR Value
//     )
//
//--

#define ProbeAndWriteUchar(Address, Value) {                                 \
    if ((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteShort(
//     IN PSHORT Address,
//     IN SHORT Value
//     )
//
//--

#define ProbeAndWriteShort(Address, Value) {                                 \
    if ((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile SHORT * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUshort(
//     IN PUSHORT Address,
//     IN USHORT Value
//     )
//
//--

#define ProbeAndWriteUshort(Address, Value) {                                \
    if ((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile USHORT * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteHandle(
//     IN PHANDLE Address,
//     IN HANDLE Value
//     )
//
//--

#define ProbeAndWriteHandle(Address, Value) {                                \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteLong(
//     IN PLONG Address,
//     IN LONG Value
//     )
//
//--

#define ProbeAndWriteLong(Address, Value) {                                  \
    if ((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUlong(
//     IN PULONG Address,
//     IN ULONG Value
//     )
//
//--

#define ProbeAndWriteUlong(Address, Value) {                                 \
    if ((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteQuad(
//     IN PQUAD Address,
//     IN QUAD Value
//     )
//
//--

#define ProbeAndWriteQuad(Address, Value) {                                  \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUquad(
//     IN PUQUAD Address,
//     IN UQUAD Value
//     )
//
//--

#define ProbeAndWriteUquad(Address, Value) {                                 \
    if ((Address) >= (UQUAD * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteSturcture(
//     IN P<STRUCTURE> Address,
//     IN <STRUCTURE> Value,
//     <STRUCTURE>
//     )
//
//--

#define ProbeAndWriteStructure(Address, Value,STRUCTURE) {                   \
    if ((STRUCTURE * const)(Address) >= (STRUCTURE * const)MM_USER_PROBE_ADDRESS) {    \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}


// begin_ntifs begin_ntddk begin_wdm begin_ntosp
//
// Common probe for write functions.
//

NTKERNELAPI
VOID
NTAPI
ProbeForWrite (
    IN PVOID Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    );

//
// Worker Thread
//

typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeWorkItem)    // Use IoAllocateWorkItem
#endif
#define ExInitializeWorkItem(Item, Routine, Context) \
    (Item)->WorkerRoutine = (Routine);               \
    (Item)->Parameter = (Context);                   \
    (Item)->List.Flink = NULL;

DECLSPEC_DEPRECATED_DDK                     // Use IoQueueWorkItem
NTKERNELAPI
VOID
ExQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem,
    IN WORK_QUEUE_TYPE QueueType
    );


NTKERNELAPI
BOOLEAN
ExIsProcessorFeaturePresent(
    ULONG ProcessorFeature
    );

//
// Zone Allocation
//

typedef struct _ZONE_SEGMENT_HEADER {
    SINGLE_LIST_ENTRY SegmentList;
    PVOID Reserved;
} ZONE_SEGMENT_HEADER, *PZONE_SEGMENT_HEADER;

typedef struct _ZONE_HEADER {
    SINGLE_LIST_ENTRY FreeList;
    SINGLE_LIST_ENTRY SegmentList;
    ULONG BlockSize;
    ULONG TotalSegmentSize;
} ZONE_HEADER, *PZONE_HEADER;


DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInitializeZone(
    IN PZONE_HEADER Zone,
    IN ULONG BlockSize,
    IN PVOID InitialSegment,
    IN ULONG InitialSegmentSize
    );

DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize
    );

DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInterlockedExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize,
    IN PKSPIN_LOCK Lock
    );

//++
//
// PVOID
// ExAllocateFromZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--
#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExAllocateFromZone)
#endif
#define ExAllocateFromZone(Zone) \
    (PVOID)((Zone)->FreeList.Next); \
    if ( (Zone)->FreeList.Next ) (Zone)->FreeList.Next = (Zone)->FreeList.Next->Next


//++
//
// PVOID
// ExFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExFreeToZone)
#endif
#define ExFreeToZone(Zone,Block)                                    \
    ( ((PSINGLE_LIST_ENTRY)(Block))->Next = (Zone)->FreeList.Next,  \
      (Zone)->FreeList.Next = ((PSINGLE_LIST_ENTRY)(Block)),        \
      ((PSINGLE_LIST_ENTRY)(Block))->Next                           \
    )

//++
//
// BOOLEAN
// ExIsFullZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine determines if the specified zone is full or not.  A zone
//     is considered full if the free list is empty.
//
// Arguments:
//
//     Zone - Pointer to the zone header to be tested.
//
// Return Value:
//
//     TRUE if the zone is full and FALSE otherwise.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsFullZone)
#endif
#define ExIsFullZone(Zone) \
    ( (Zone)->FreeList.Next == (PSINGLE_LIST_ENTRY)NULL )

//++
//
// PVOID
// ExInterlockedAllocateFromZone(
//     IN PZONE_HEADER Zone,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//     The removal is performed with the specified lock owned for the sequence
//     to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
//     Lock - Pointer to the spin lock which should be obtained before removing
//         the entry from the allocation list.  The lock is released before
//         returning to the caller.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedAllocateFromZone)
#endif
#define ExInterlockedAllocateFromZone(Zone,Lock) \
    (PVOID) ExInterlockedPopEntryList( &(Zone)->FreeList, Lock )

//++
//
// PVOID
// ExInterlockedFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.  The insertion is performed with the lock
//     owned for the sequence to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
//     Lock - Pointer to the spin lock which should be obtained before inserting
//         the entry onto the free list.  The lock is released before returning
//         to the caller.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedFreeToZone)
#endif
#define ExInterlockedFreeToZone(Zone,Block,Lock) \
    ExInterlockedPushEntryList( &(Zone)->FreeList, ((PSINGLE_LIST_ENTRY) (Block)), Lock )


//++
//
// BOOLEAN
// ExIsObjectInFirstZoneSegment(
//     IN PZONE_HEADER Zone,
//     IN PVOID Object
//     )
//
// Routine Description:
//
//     This routine determines if the specified pointer lives in the zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         object may belong.
//
//     Object - Pointer to the object in question.
//
// Return Value:
//
//     TRUE if the Object came from the first segment of zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsObjectInFirstZoneSegment)
#endif
#define ExIsObjectInFirstZoneSegment(Zone,Object) ((BOOLEAN)     \
    (((PUCHAR)(Object) >= (PUCHAR)(Zone)->SegmentList.Next) &&   \
     ((PUCHAR)(Object) < (PUCHAR)(Zone)->SegmentList.Next +      \
                         (Zone)->TotalSegmentSize))              \
)

//
//  Define executive resource data structures.
//

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;
//
//  Values for ERESOURCE.Flag
//

#define ResourceNeverExclusive       0x10
#define ResourceReleaseByOtherThread 0x20
#define ResourceOwnedExclusive       0x80

#define RESOURCE_HASH_TABLE_SIZE 64

typedef struct _RESOURCE_HASH_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID Address;
    ULONG ContentionCount;
    ULONG Number;
} RESOURCE_HASH_ENTRY, *PRESOURCE_HASH_ENTRY;

typedef struct _RESOURCE_PERFORMANCE_DATA {
    ULONG ActiveResourceCount;
    ULONG TotalResourceCount;
    ULONG ExclusiveAcquire;
    ULONG SharedFirstLevel;
    ULONG SharedSecondLevel;
    ULONG StarveFirstLevel;
    ULONG StarveSecondLevel;
    ULONG WaitForExclusive;
    ULONG OwnerTableExpands;
    ULONG MaximumTableExpand;
    LIST_ENTRY HashTable[RESOURCE_HASH_TABLE_SIZE];
} RESOURCE_PERFORMANCE_DATA, *PRESOURCE_PERFORMANCE_DATA;

//
// Define executive resource function prototypes.
//
NTKERNELAPI
NTSTATUS
ExInitializeResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
NTSTATUS
ExReinitializeResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
BOOLEAN
ExAcquireResourceSharedLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireResourceExclusiveLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireSharedStarveExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireSharedWaitForExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    IN PERESOURCE Resource
    );

//
//  VOID
//  ExReleaseResource(
//      IN PERESOURCE Resource
//      );
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExReleaseResource)       // Use ExReleaseResourceLite
#endif
#define ExReleaseResource(R) (ExReleaseResourceLite(R))

NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
VOID
ExReleaseResourceForThreadLite(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD ResourceThreadId
    );

NTKERNELAPI
VOID
ExSetResourceOwnerPointer(
    IN PERESOURCE Resource,
    IN PVOID OwnerPointer
    );

NTKERNELAPI
VOID
ExConvertExclusiveToSharedLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
NTSTATUS
ExDeleteResourceLite (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExGetExclusiveWaiterCount (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExGetSharedWaiterCount (
    IN PERESOURCE Resource
    );

//
//  ERESOURCE_THREAD
//  ExGetCurrentResourceThread(
//      );
//

#define ExGetCurrentResourceThread() ((ULONG_PTR)PsGetCurrentThread())

NTKERNELAPI
BOOLEAN
ExIsResourceAcquiredExclusiveLite (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExIsResourceAcquiredSharedLite (
    IN PERESOURCE Resource
    );

//
// An acquired resource is always owned shared, as shared ownership is a subset
// of exclusive ownership.
//
#define ExIsResourceAcquiredLite ExIsResourceAcquiredSharedLite

// end_wdm
//
//  ntddk.h stole the entrypoints we wanted so fix them up here.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeResource)            // use ExInitializeResourceLite
#pragma deprecated(ExAcquireResourceShared)         // use ExAcquireResourceSharedLite
#pragma deprecated(ExAcquireResourceExclusive)      // use ExAcquireResourceExclusiveLite
#pragma deprecated(ExReleaseResourceForThread)      // use ExReleaseResourceForThreadLite
#pragma deprecated(ExConvertExclusiveToShared)      // use ExConvertExclusiveToSharedLite
#pragma deprecated(ExDeleteResource)                // use ExDeleteResourceLite
#pragma deprecated(ExIsResourceAcquiredExclusive)   // use ExIsResourceAcquiredExclusiveLite
#pragma deprecated(ExIsResourceAcquiredShared)      // use ExIsResourceAcquiredSharedLite
#pragma deprecated(ExIsResourceAcquired)            // use ExIsResourceAcquiredSharedLite
#endif
#define ExInitializeResource ExInitializeResourceLite
#define ExAcquireResourceShared ExAcquireResourceSharedLite
#define ExAcquireResourceExclusive ExAcquireResourceExclusiveLite
#define ExReleaseResourceForThread ExReleaseResourceForThreadLite
#define ExConvertExclusiveToShared ExConvertExclusiveToSharedLite
#define ExDeleteResource ExDeleteResourceLite
#define ExIsResourceAcquiredExclusive ExIsResourceAcquiredExclusiveLite
#define ExIsResourceAcquiredShared ExIsResourceAcquiredSharedLite
#define ExIsResourceAcquired ExIsResourceAcquiredSharedLite


//
// Push lock definitions
//
typedef struct _EX_PUSH_LOCK {

#define EX_PUSH_LOCK_WAITING   0x1
#define EX_PUSH_LOCK_EXCLUSIVE 0x2
#define EX_PUSH_LOCK_SHARE_INC 0x4

    union {
        struct {
            ULONG_PTR Waiting : 1;
            ULONG_PTR Exclusive : 1;
            ULONG_PTR Shared : sizeof (ULONG_PTR) * 8 - 2;
        };
        ULONG_PTR Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;


#if defined (NT_UP)
#define EX_CACHE_LINE_SIZE 16
#define EX_PUSH_LOCK_FANNED_COUNT 1
#else
#define EX_CACHE_LINE_SIZE 128
#define EX_PUSH_LOCK_FANNED_COUNT (PAGE_SIZE/EX_CACHE_LINE_SIZE)
#endif

//
// Define a fan out structure for n push locks each in its own cache line
//
typedef struct _EX_PUSH_LOCK_CACHE_AWARE {
    PEX_PUSH_LOCK Locks[EX_PUSH_LOCK_FANNED_COUNT];
} EX_PUSH_LOCK_CACHE_AWARE, *PEX_PUSH_LOCK_CACHE_AWARE;

//
// Define structure thats a push lock padded to the size of a cache line
//
typedef struct _EX_PUSH_LOCK_CACHE_AWARE_PADDED {
        EX_PUSH_LOCK Lock;
        union {
            UCHAR Pad[EX_CACHE_LINE_SIZE - sizeof (EX_PUSH_LOCK)];
            BOOLEAN Single;
        };
} EX_PUSH_LOCK_CACHE_AWARE_PADDED, *PEX_PUSH_LOCK_CACHE_AWARE_PADDED;


//
// Rundown protection structure
//
typedef struct _EX_RUNDOWN_REF {

#define EX_RUNDOWN_ACTIVE      0x1
#define EX_RUNDOWN_COUNT_SHIFT 0x1
#define EX_RUNDOWN_COUNT_INC   (1<<EX_RUNDOWN_COUNT_SHIFT)
    union {
        ULONG_PTR Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

//
//  The Ex/Ob handle table interface package (in handle.c)
//

//
//  The Ex/Ob handle table package uses a common handle definition.  The actual
//  type definition for a handle is a pvoid and is declared in sdk/inc.  This
//  package uses only the low 32 bits of the pvoid pointer.
//
//  For simplicity we declare a new typedef called an exhandle
//
//  The 2 bits of an EXHANDLE is available to the application and is
//  ignored by the system.  The next 24 bits store the handle table entry
//  index and is used to refer to a particular entry in a handle table.
//
//  Note that this format is immutable because there are outside programs with
//  hardwired code that already assumes the format of a handle.
//

typedef struct _EXHANDLE {

    union {

        struct {

            //
            //  Application available tag bits
            //

            ULONG TagBits : 2;

            //
            //  The handle table entry index
            //

            ULONG Index : 30;

        };

        HANDLE GenericHandleOverlay;

#define HANDLE_VALUE_INC 4 // Amount to increment the Value to get to the next handle

        ULONG_PTR Value;
    };

} EXHANDLE, *PEXHANDLE;
//
// Get previous mode
//

NTKERNELAPI
KPROCESSOR_MODE
ExGetPreviousMode(
    VOID
    );
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );

// end_wdm

NTKERNELAPI
VOID
ExRaiseDatatypeMisalignment (
    VOID
    );

NTKERNELAPI
VOID
ExRaiseAccessViolation (
    VOID
    );

NTKERNELAPI
NTSTATUS
ExRaiseHardError(
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );
int
ExSystemExceptionFilter(
    VOID
    );

NTKERNELAPI
VOID
ExGetCurrentProcessorCpuUsage(
    IN PULONG CpuUsage
    );

NTKERNELAPI
VOID
ExGetCurrentProcessorCounts(
    OUT PULONG IdleCount,
    OUT PULONG KernelAndUser,
    OUT PULONG Index
    );
//
// Set timer resolution.
//

NTKERNELAPI
ULONG
ExSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution
    );

//
// Subtract time zone bias from system time to get local time.
//

NTKERNELAPI
VOID
ExSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

//
// Add time zone bias to local time to get system time.
//

NTKERNELAPI
VOID
ExLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );


//
// Define the type for Callback function.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef VOID (*PCALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


NTKERNELAPI
NTSTATUS
ExCreateCallback (
    OUT PCALLBACK_OBJECT *CallbackObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN Create,
    IN BOOLEAN AllowMultipleCallbacks
    );

NTKERNELAPI
PVOID
ExRegisterCallback (
    IN PCALLBACK_OBJECT CallbackObject,
    IN PCALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackContext
    );

NTKERNELAPI
VOID
ExUnregisterCallback (
    IN PVOID CallbackRegistration
    );

NTKERNELAPI
VOID
ExNotifyCallback (
    IN PVOID CallbackObject,
    IN PVOID Argument1,
    IN PVOID Argument2
    );




typedef
PVOID
(*PKWIN32_GLOBALATOMTABLE_CALLOUT) ( void );

extern PKWIN32_GLOBALATOMTABLE_CALLOUT ExGlobalAtomTableCallout;


//
// UUID Generation
//

typedef GUID UUID;

NTKERNELAPI
NTSTATUS
ExUuidCreate(
    OUT UUID *Uuid
    );


NTKERNELAPI
VOID
FASTCALL
ExfInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

NTKERNELAPI
VOID
FORCEINLINE
FASTCALL
ExInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Initialize rundown protection structure

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    RunRef->Count = 0;
}


//
// Reset a rundown protection block
//
NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

//
// Acquire rundown protection
//
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     );

//
// Release rundown protection
//
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     );

//
// Mark rundown block as rundown having been completed.
//
NTKERNELAPI
VOID
FASTCALL
ExRundownCompleted (
     IN PEX_RUNDOWN_REF RunRef
     );

//
// Wait for all protected acquires to exit
//
NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionRelease (
     IN PEX_RUNDOWN_REF RunRef
     );


//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_NTOSP_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     *KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT *KdDebuggerNotPresent

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT KdDebuggerNotPresent

#endif



//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0


//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs

//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

// end_ntddk end_wdm
//
// Priority increment used when satisfying a wait on an executive mutant
// (NtReleaseMutant)
//

#define MUTANT_INCREMENT                1

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_wdm end_ntndis
//
// Directory control minor function codes
//

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02

//
// File system control minor function codes.  Note that "user request" is
// assumed to be zero by both the I/O system and file systems.  Do not change
// this value.
//

#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04    // To be obsoleted soon
#define IRP_MN_KERNEL_CALL              0x04

//
// Lock control minor function codes
//

#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04

//
// Read and Write minor function codes for file systems supporting Lan Manager
// software.  All of these subfunction codes are invalid if the file has been
// opened with FO_NO_INTERMEDIATE_BUFFERING.  They are also invalid in combi-
// nation with synchronous calls (Irp Flag or file open option).
//
// Note that "normal" is assumed to be zero by both the I/O system and file
// systems.  Do not change this value.
//

#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08

#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

// begin_wdm
//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
// end_wdm
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
// begin_wdm

//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b

// end_ntminiport

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

// end_ntddk end_wdm

#define IO_CHECK_CREATE_PARAMETERS      0x0200
#define IO_ATTACH_DEVICE                0x0400


//
//  This flag is only meaning full to IoCreateFileSpecifyDeviceObjectHint.
//  FileHandles created using IoCreateFileSpecifyDeviceObjectHint with this
//  flag set will bypass ShareAccess checks on this file.
//

#define IO_IGNORE_SHARE_ACCESS_CHECK    0x0800  // Ignores share access checks on opens.

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

//
// Define the interfaces for the dump driver's routines.
//

typedef
BOOLEAN
(*PDUMP_DRIVER_OPEN) (
    IN LARGE_INTEGER PartitionOffset
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE) (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

//
// Actions accepted by DRIVER_WRITE_PENDING
//
#define IO_DUMP_WRITE_FULFILL   0   // fulfill IO request as if DRIVER_WAIT
#define IO_DUMP_WRITE_START     1   // start new IO
#define IO_DUMP_WRITE_RESUME    2   // resume pending IO
#define IO_DUMP_WRITE_FINISH    3   // finish pending IO
#define IO_DUMP_WRITE_INIT      4   // initialize locals

// size of data used by WRITE_PENDING that should be preserved
// between the calls
#define IO_DUMP_WRITE_DATA_PAGES 2
#define IO_DUMP_WRITE_DATA_SIZE (IO_DUMP_WRITE_DATA_PAGES << PAGE_SHIFT)

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE_PENDING) (
    IN LONG Action,
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl,
    IN PVOID LocalData
    );


typedef
VOID
(*PDUMP_DRIVER_FINISH) (
    VOID
    );

struct _ADAPTER_OBJECT;

//
// This is the information passed from the system to the disk dump driver
// during the driver's initialization.
//

typedef struct _DUMP_INITIALIZATION_CONTEXT {
    ULONG Length;
    ULONG Reserved;             // Was MBR Checksum. Should be zero now.
    PVOID MemoryBlock;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PSTALL_ROUTINE StallRoutine;
    PDUMP_DRIVER_OPEN OpenRoutine;
    PDUMP_DRIVER_WRITE WriteRoutine;
    PDUMP_DRIVER_FINISH FinishRoutine;
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID PortConfiguration;
    BOOLEAN CrashDump;
    ULONG MaximumTransferSize;
    ULONG CommonBufferSize;
    PVOID TargetAddress; //Opaque pointer to target address structure
    PDUMP_DRIVER_WRITE_PENDING WritePendingRoutine;
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;
        struct {
            GUID DiskId;
        } Gpt;
    } DiskInfo;
} DUMP_INITIALIZATION_CONTEXT, *PDUMP_INITIALIZATION_CONTEXT;


// begin_ntddk
//
// Define callout routine type for use in IoQueryDeviceDescription().
//

typedef NTSTATUS (*PIO_QUERY_DEVICE_ROUTINE)(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );


// Defines the order of the information in the array of
// PKEY_VALUE_FULL_INFORMATION.
//

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData,
    IoQueryDeviceComponentInformation,
    IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

// begin_wdm begin_ntifs
//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

// end_ntddk end_wdm end_ntifs

//
// Define the named pipe create parameters structure used for internal calls
// to IoCreateFile when a named pipe is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a named pipe.
//

typedef struct _NAMED_PIPE_CREATE_PARAMETERS {
    ULONG NamedPipeType;
    ULONG ReadMode;
    ULONG CompletionMode;
    ULONG MaximumInstances;
    ULONG InboundQuota;
    ULONG OutboundQuota;
    LARGE_INTEGER DefaultTimeout;
    BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCATTER_GATHER_LIST;

//
// Define the I/O version of a DPC routine.
//

typedef
VOID
(*PIO_DPC_ROUTINE) (
    IN PKDPC Dpc,
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID Context
    );

//
// Define driver timer routine type.
//

typedef
VOID
(*PIO_TIMER_ROUTINE) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN PVOID Context
    );

//
// Define driver initialization routine type.
//
typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

// end_wdm
//
// Define driver reinitialization routine type.
//

typedef
VOID
(*PDRIVER_REINITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PVOID Context,
    IN ULONG Count
    );

// begin_wdm begin_ntndis
//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//
typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );
//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );


//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
(*PFAST_IO_CHECK_IF_POSSIBLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O query basic and standard information procedures.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_BASIC_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_STANDARD_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O lock and unlock procedures.
//

typedef
BOOLEAN
(*PFAST_IO_LOCK) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_SINGLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL) (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL_BY_KEY) (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
(*PFAST_IO_DEVICE_CONTROL) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

typedef
VOID
(*PFAST_IO_ACQUIRE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

typedef
VOID
(*PFAST_IO_RELEASE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
(*PFAST_IO_DETACH_DEVICE) (
    IN struct _DEVICE_OBJECT *SourceDevice,
    IN struct _DEVICE_OBJECT *TargetDevice
    );

//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_NETWORK_OPEN_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  Define Mdl-based routines for the server to call
//

typedef
BOOLEAN
(*PFAST_IO_MDL_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_PREPARE_MDL_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT struct _ERESOURCE **ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _ERESOURCE *ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
BOOLEAN
(*PFAST_IO_READ_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_OPEN) (
    IN struct _IRP *Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010


//
// Volume Parameter Block (VPB)
//

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_) || defined(_NTOSP_))

//  begin_wdm
//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

// end_wdm
#else

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; // ntndis

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_ || _NTOSP_)

//  begin_wdm
//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

// end_wdm

typedef struct _CONTROLLER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PVOID ControllerExtension;
    KDEVICE_QUEUE DeviceWaitQueue;

    ULONG Spare1;
    LARGE_INTEGER Spare2;

} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;

// begin_wdm
//
// Define Device Object (DO) flags
//
// end_wdm end_ntddk end_nthal end_ntifs

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000

// begin_wdm begin_ntddk begin_nthal begin_ntifs
//
// Device Object structure definition
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis


struct  _DEVICE_OBJECT_POWER_EXTENSION;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object


} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
// end_wdm
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040

// begin_wdm

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //


} DRIVER_EXTENSION, *PDRIVER_EXTENSION;


typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis



//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_RANDOM_ACCESS                0x00100000
#define FO_FILE_OPEN_CANCELLED          0x00200000
#define FO_VOLUME_OPEN                  0x00400000
#define FO_FILE_OBJECT_HAS_EXTENSION    0x00800000
#define FO_REMOTE_ORIGIN                0x01000000

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    ULONG Waiters;
    ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    PIO_COMPLETION_CONTEXT CompletionContext;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000
#define IRP_RETRY_IO_COMPLETION         0x00004000
#define IRP_CLASS_CACHE_OPERATION       0x00008000

#define IRP_SET_USER_EVENT              IRP_CLOSE_OPERATION

// begin_wdm
//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

#define SL_READ_ACCESS_GRANTED          0x01
#define SL_WRITE_ACCESS_GRANTED         0x04    // Gap for SL_OVERRIDE_VERIFY_VOLUME

//
// Lock
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation,
    SingleBusRelations
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
    ULONG Count;
    PDEVICE_OBJECT Objects[1];  // variable length
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE;

// begin_ntminiport

// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

// end_ntminiport

typedef struct _DEVICE_CAPABILITIES {
    USHORT Size;
    USHORT Version;  // the version documented here is version 1
    ULONG DeviceD1:1;
    ULONG DeviceD2:1;
    ULONG LockSupported:1;
    ULONG EjectSupported:1; // Ejectable in S0
    ULONG Removable:1;
    ULONG DockDevice:1;
    ULONG UniqueID:1;
    ULONG SilentInstall:1;
    ULONG RawDeviceOK:1;
    ULONG SurpriseRemovalOK:1;
    ULONG WakeFromD0:1;
    ULONG WakeFromD1:1;
    ULONG WakeFromD2:1;
    ULONG WakeFromD3:1;
    ULONG HardwareDisabled:1;
    ULONG NonDynamic:1;
    ULONG WarmEjectSupported:1;
    ULONG NoDisplayInUI:1;
    ULONG Reserved:14;

    ULONG Address;
    ULONG UINumber;

    DEVICE_POWER_STATE DeviceState[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    ULONG D1Latency;
    ULONG D2Latency;
    ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _POWER_SEQUENCE {
    ULONG SequenceD1;
    ULONG SequenceD2;
    ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4    // serial number for this device
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

// begin_ntndis

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

// end_ntndis

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            ULONG POINTER_ALIGNMENT EaLength;
        } Create;


        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Write;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            PSTRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
            ULONG POINTER_ALIGNMENT FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT CompletionFilter;
        } NotifyDirectory;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
                HANDLE DeleteHandle;
            };
        } SetFile;


        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
            PVOID Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            PLARGE_INTEGER Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } LockControl;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

// end_wdm
        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG POINTER_ALIGNMENT Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;

// begin_wdm
        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;


        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;

// end_ntifs

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;

// begin_ntifs
        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            ULONG_PTR ProviderId;
            PVOID DataPath;
            ULONG BufferSize;
            PVOID Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// end_wdm

//
// The following structure is used by drivers that are initializing to
// determine the number of devices of a particular type that have already
// been initialized.  It is also used to track whether or not the AtDisk
// address range has already been claimed.  Finally, it is used by the
// NtQuerySystemInformation system service to return device type counts.
//

typedef struct _CONFIGURATION_INFORMATION {

    //
    // This field indicates the total number of disks in the system.  This
    // number should be used by the driver to determine the name of new
    // disks.  This field should be updated by the driver as it finds new
    // disks.
    //

    ULONG DiskCount;                // Count of hard disks thus far
    ULONG FloppyCount;              // Count of floppy disks thus far
    ULONG CdRomCount;               // Count of CD-ROM drives thus far
    ULONG TapeCount;                // Count of tape drives thus far
    ULONG ScsiPortCount;            // Count of SCSI port adapters thus far
    ULONG SerialCount;              // Count of serial devices thus far
    ULONG ParallelCount;            // Count of parallel devices thus far

    //
    // These next two fields indicate ownership of one of the two IO address
    // spaces that are used by WD1003-compatable disk controllers.
    //

    BOOLEAN AtDiskPrimaryAddressClaimed;    // 0x1F0 - 0x1FF
    BOOLEAN AtDiskSecondaryAddressClaimed;  // 0x170 - 0x17F

    //
    // Indicates the structure version, as anything value belong this will have been added.
    // Use the structure size as the version.
    //

    ULONG Version;

    //
    // Indicates the total number of medium changer devices in the system.
    // This field will be updated by the drivers as it determines that
    // new devices have been found and will be supported.
    //

    ULONG MediumChangerCount;

} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;

//
// Public I/O routine definitions
//

NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    );


DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTKERNELAPI
NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoAllocateController(
    IN PCONTROLLER_OBJECT ControllerObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

//  begin_wdm

NTKERNELAPI
NTSTATUS
IoAllocateDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress,
    IN ULONG DriverObjectExtensionSize,
    OUT PVOID *DriverObjectExtension
    );

// begin_ntifs

NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    );

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    );

NTKERNELAPI
PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    );

// end_wdm end_ntifs
//++
//
// VOID
// IoAssignArcName(
//     IN PUNICODE_STRING ArcName,
//     IN PUNICODE_STRING DeviceName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers of bootable media to create a symbolic
//     link between the ARC name of their device and its NT name.  This allows
//     the system to determine which device in the system was actually booted
//     from since the ARC firmware only deals in ARC names, and NT only deals
//     in NT names.
//
// Arguments:
//
//     ArcName - Supplies the Unicode string representing the ARC name.
//
//     DeviceName - Supplies the name to which the ARCname refers.
//
// Return Value:
//
//     None.
//
//--

#define IoAssignArcName( ArcName, DeviceName ) (  \
    IoCreateSymbolicLink( (ArcName), (DeviceName) ) )

DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReprtDetectedDevice
NTKERNELAPI
NTSTATUS
IoAssignResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );


NTKERNELAPI
NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    );

// end_wdm

DECLSPEC_DEPRECATED_DDK                 // Use IoAttachDeviceToDeviceStack
NTKERNELAPI
NTSTATUS
IoAttachDeviceByPointer(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

// begin_wdm

NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

typedef struct _BOOTDISK_INFORMATION {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

//
// This structure should follow the previous structure field for field.
//
typedef struct _BOOTDISK_INFORMATION_EX {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_EX, *PBOOTDISK_INFORMATION_EX;

NTKERNELAPI
NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    );


NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

NTKERNELAPI
BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    );


NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

//
// This value should be returned from completion routines to continue
// completing the IRP upwards. Otherwise, STATUS_MORE_PROCESSING_REQUIRED
// should be returned.
//
#define STATUS_CONTINUE_COMPLETION      STATUS_SUCCESS

//
// Completion routines can also use this enumeration in place of status codes.
//
typedef enum _IO_COMPLETION_ROUTINE_RESULT {

    ContinueCompletion = STATUS_CONTINUE_COMPLETION,
    StopCompletion = STATUS_MORE_PROCESSING_REQUIRED

} IO_COMPLETION_ROUTINE_RESULT, *PIO_COMPLETION_ROUTINE_RESULT;

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

// end_ntifs

NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    );

//  end_wdm

NTKERNELAPI
PCONTROLLER_OBJECT
IoCreateController(
    IN ULONG Size
    );

//  begin_wdm begin_ntifs

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

#define WDM_MAJORVERSION        0x01
#define WDM_MINORVERSION        0x20

NTKERNELAPI
BOOLEAN
IoIsWdmVersionAvailable(
    IN UCHAR MajorVersion,
    IN UCHAR MinorVersion
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    );


NTKERNELAPI
PKEVENT
IoCreateNotificationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

NTKERNELAPI
PKEVENT
IoCreateSynchronizationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

//  end_wdm

//++
//
// VOID
// IoDeassignArcName(
//     IN PUNICODE_STRING ArcName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers to deassign an ARC name that they
//     created to a device.  This is generally only called if the driver is
//     deleting the device object, which means that the driver is probably
//     unloading.
//
// Arguments:
//
//     ArcName - Supplies the ARC name to be removed.
//
// Return Value:
//
//     None.
//
//--

#define IoDeassignArcName( ArcName ) (  \
    IoDeleteSymbolicLink( (ArcName) ) )

// end_ntifs

NTKERNELAPI
VOID
IoDeleteController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

//  begin_wdm begin_ntifs

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    );

// end_ntifs

NTKERNELAPI
VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    );

// end_ntddk end_wdm end_nthal

NTKERNELAPI
VOID
IoEnqueueIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoFreeController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

//  begin_wdm begin_ntifs

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoFreeMdl(
    IN PMDL Mdl
    );


NTKERNELAPI
PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI                                 // ntddk wdm nthal
PDEVICE_OBJECT                              // ntddk wdm nthal
IoGetAttachedDeviceReference(               // ntddk wdm nthal
    IN PDEVICE_OBJECT DeviceObject          // ntddk wdm nthal
    );                                      // ntddk wdm nthal
                                            // ntddk wdm nthal
NTKERNELAPI
PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI                                 // ntddk nthal ntosp
PCONFIGURATION_INFORMATION                  // ntddk nthal ntosp
IoGetConfigurationInformation( VOID );      // ntddk nthal ntosp

// begin_ntddk begin_wdm begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal end_wdm

NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceToVerify(
    IN PETHREAD Thread
    );

//  begin_wdm

NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress
    );

NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );

// begin_nthal

NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,           OPTIONAL // required for PnP drivers
    IN struct _DEVICE_DESCRIPTION *DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

NTKERNELAPI
BOOLEAN
IoForwardIrpSynchronously(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#define IoForwardAndCatchIrp IoForwardIrpSynchronously

//  end_wdm

NTKERNELAPI
PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    );

// end_nthal


// begin_wdm

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

NTKERNELAPI
PVOID
IoGetInitialStack(
    VOID
    );

NTKERNELAPI
VOID
IoGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

//
//  The following function is used to tell the caller how much stack is available
//

FORCEINLINE
ULONG_PTR
IoGetRemainingStackSize (
    VOID
    )
{
    ULONG_PTR Top;
    ULONG_PTR Bottom;

    IoGetStackLimits( &Bottom, &Top );
    return((ULONG_PTR)(&Top) - Bottom );
}

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    );

// end_ntddk end_wdm end_nthal

NTKERNELAPI
ULONG
IoGetRequestorProcessId(
    IN PIRP Irp
    );

NTKERNELAPI
PEPROCESS
IoGetRequestorProcess(
    IN PIRP Irp
    );


//++
//
// VOID
// IoInitializeDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--

#define IoInitializeDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),     \
                     (DeviceObject) ) )

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );


NTKERNELAPI
VOID
IoReuseIrp(
    IN OUT PIRP Irp,
    IN NTSTATUS Iostatus
    );

// end_wdm

NTKERNELAPI
VOID
IoCancelFileOpen(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PFILE_OBJECT    FileObject
    );

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


NTKERNELAPI
PIRP
IoMakeAssociatedIrp(
    IN PIRP Irp,
    IN CCHAR StackSize
    );

//  begin_wdm

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

DECLSPEC_DEPRECATED_DDK                 // Use IoGetDeviceProperty
NTKERNELAPI
NTSTATUS
IoQueryDeviceDescription(
    IN PINTERFACE_TYPE BusType OPTIONAL,
    IN PULONG BusNumber OPTIONAL,
    IN PCONFIGURATION_TYPE ControllerType OPTIONAL,
    IN PULONG ControllerNumber OPTIONAL,
    IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,
    IN PULONG PeripheralNumber OPTIONAL,
    IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoQueueThreadIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoRaiseHardError(
    IN PIRP Irp,
    IN PVPB Vpb OPTIONAL,
    IN PDEVICE_OBJECT RealDeviceObject
    );

NTKERNELAPI
BOOLEAN
IoRaiseInformationalHardError(
    IN NTSTATUS ErrorStatus,
    IN PUNICODE_STRING String OPTIONAL,
    IN PKTHREAD Thread OPTIONAL
    );

NTKERNELAPI
BOOLEAN
IoSetThreadHardErrorMode(
    IN BOOLEAN EnableHardErrors
    );

NTKERNELAPI
VOID
IoRegisterBootDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );


NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoRegisterLastChanceShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

// begin_wdm

NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    );


NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );


DECLSPEC_DEPRECATED_DDK                 // Use IoReportResourceForDetection
NTKERNELAPI
NTSTATUS
IoReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );

//  begin_wdm

//++
//
// VOID
// IoRequestDpc(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIRP Irp,
//     IN PVOID Context
//     )
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--

#define IoRequestDpc( DeviceObject, Irp, Context ) ( \
    KeInsertQueueDpc( &(DeviceObject)->Dpc, (Irp), (Context) ) )

//++
//
// PDRIVER_CANCEL
// IoSetCancelRoutine(
//     IN PIRP Irp,
//     IN PDRIVER_CANCEL CancelRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     Previous value of CancelRoutine field in the IRP.
//
//--

#define IoSetCancelRoutine( Irp, NewCancelRoutine ) (  \
    (PDRIVER_CANCEL) InterlockedExchangePointer( (PVOID *) &(Irp)->CancelRoutine, (PVOID) (NewCancelRoutine) ) )

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION __irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    __irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    __irpSp->CompletionRoutine = (Routine);                                   \
    __irpSp->Context = (CompletionContext);                                   \
    __irpSp->Control = 0;                                                     \
    if ((Success)) { __irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { __irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { __irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

NTSTATUS
IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN InvokeOnSuccess,
    IN BOOLEAN InvokeOnError,
    IN BOOLEAN InvokeOnCancel
    );



NTKERNELAPI
VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntddk end_nthal

NTKERNELAPI
NTSTATUS
IoSetInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN PVOID FileInformation
    );


//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION __irpSp; \
    PIO_STACK_LOCATION __nextIrpSp; \
    __irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    __nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( __nextIrpSp, __irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    __nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) { \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++; }


NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );



typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    LONG        IoCount;
    KEVENT      RemoveEvent;

} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
    LONG        Signature;
    LONG        HighWatermark;
    LONGLONG    MaxLockedTicks;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    LONG        LowMemoryCount;
    ULONG       Reserved1[4];
    PVOID       Reserved2;
    PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

#define IoInitializeRemoveLock(Lock, Tag, Maxmin, HighWater) \
        IoInitializeRemoveLockEx (Lock, Tag, Maxmin, HighWater, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    IN  PIO_REMOVE_LOCK Lock,
    IN  ULONG   AllocateTag, // Used only on checked kernels
    IN  ULONG   MaxLockedMinutes, // Used only on checked kernels
    IN  ULONG   HighWatermark, // Used only on checked kernels
    IN  ULONG   RemlockSize // are we checked or free
    );
//
//  Initialize a remove lock.
//
//  Note: Allocation for remove locks needs to be within the device extension,
//  so that the memory for this structure stays allocated until such time as the
//  device object itself is deallocated.
//

#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx (
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID   Tag, // Optional
    IN PCSTR            File,
    IN ULONG            Line,
    IN ULONG            RemlockSize // are we checked or free
    );

//
// Routine Description:
//
//    This routine is called to acquire the remove lock for a device object.
//    While the lock is held, the caller can assume that no pending pnp REMOVE
//    requests will be completed.
//
//    The lock should be acquired immediately upon entering a dispatch routine.
//    It should also be acquired before creating any new reference to the
//    device object if there's a chance of releasing the reference before the
//    new one is done, in addition to references to the driver code itself,
//    which is removed from memory when the last device object goes.
//
//    Arguments:
//
//    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.
//
//    Tag - Used for tracking lock allocation and release.  The same tag
//          specified when acquiring the lock must be used to release the lock.
//          Tags are only checked in checked versions of the driver.
//
//    File - set to __FILE__ as the location in the code where the lock was taken.
//
//    Line - set to __LINE__.
//
// Return Value:
//
//    Returns whether or not the remove lock was obtained.
//    If successful the caller should continue with work calling
//    IoReleaseRemoveLock when finished.
//
//    If not successful the lock was not obtained.  The caller should abort the
//    work but not call IoReleaseRemoveLock.
//

#define IoReleaseRemoveLock(RemoveLock, Tag) \
        IoReleaseRemoveLockEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag, // Optional
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called to release the remove lock on the device object.  It
//    must be called when finished using a previously locked reference to the
//    device object.  If an Tag was specified when acquiring the lock then the
//    same Tag must be specified when releasing the lock.
//
//    When the lock count reduces to zero, this routine will signal the waiting
//    event to release the waiting thread deleting the device object protected
//    by this lock.
//
// Arguments:
//
//    DeviceObject - the device object to lock
//
//    Tag - The TAG (if any) specified when acquiring the lock.  This is used
//          for lock tracking purposes
//
// Return Value:
//
//    none
//

#define IoReleaseRemoveLockAndWait(RemoveLock, Tag) \
        IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called when the client would like to delete the
//    remove-locked resource.  This routine will block until all the remove
//    locks have released.
//
//    This routine MUST be called after acquiring the lock.
//
// Arguments:
//
//    RemoveLock
//
// Return Value:
//
//    none
//


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );

VOID
IoSetStartIoAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeferredStartIo,
    IN BOOLEAN NonCancelable
    );

// begin_ntifs

NTKERNELAPI
VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    );


NTKERNELAPI
PEPROCESS
IoThreadToProcess(
    IN PETHREAD Thread
    );


NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

//  end_wdm

NTKERNELAPI
VOID
IoUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_nthal

NTKERNELAPI
NTSTATUS
IoVerifyVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    );


NTKERNELAPI                                     // ntddk wdm nthal
VOID                                            // ntddk wdm nthal
IoWriteErrorLogEntry(                           // ntddk wdm nthal
    IN PVOID ElEntry                            // ntddk wdm nthal
    );                                          // ntddk wdm nthal


NTKERNELAPI
NTSTATUS
IoCreateDriver (
    IN PUNICODE_STRING DriverName,   OPTIONAL
    IN PDRIVER_INITIALIZE InitializationFunction
    );

NTKERNELAPI
VOID
IoDeleteDriver (
    IN PDRIVER_OBJECT DriverObject
    );


typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );


NTKERNELAPI
NTSTATUS
IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
);

//
// Action code for IoWMIRegistrationControl api
//

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

//
// Code passed in IRP_MN_REGINFO WMI irp
//

#define WMIREGISTER                 0
#define WMIUPDATE                   1

NTKERNELAPI
NTSTATUS
IoWMIAllocateInstanceIds(
    IN GUID *Guid,
    IN ULONG InstanceCount,
    OUT ULONG *FirstInstanceId
    );

NTKERNELAPI
NTSTATUS
IoWMISuggestInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
    IN BOOLEAN CombineNames,
    OUT PUNICODE_STRING SuggestedInstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIWriteEvent(
    IN PVOID WnodeEventItem
    );

#if defined(_WIN64)
NTKERNELAPI
ULONG IoWMIDeviceObjectToProviderId(
    PDEVICE_OBJECT DeviceObject
    );
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

NTKERNELAPI
NTSTATUS IoWMIOpenBlock(
    IN GUID *DataBlockGuid,
    IN ULONG DesiredAccess,
    OUT PVOID *DataBlockObject
    );


NTKERNELAPI
NTSTATUS IoWMIQueryAllData(
    IN PVOID DataBlockObject,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);


NTKERNELAPI
NTSTATUS
IoWMIQueryAllDataMultiple(
    IN PVOID *DataBlockObjectList,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);


NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);

NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstanceMultiple(
    IN PVOID *DataBlockObjectList,
    IN PUNICODE_STRING InstanceNames,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);

NTKERNELAPI
NTSTATUS
IoWMISetSingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

NTKERNELAPI
NTSTATUS
IoWMISetSingleItem(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

NTKERNELAPI
NTSTATUS
IoWMIExecuteMethod(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN OUT PULONG OutBufferSize,
    IN OUT PUCHAR InOutBuffer
    );



typedef VOID (*WMI_NOTIFICATION_CALLBACK)(
    PVOID Wnode,
    PVOID Context
    );

NTKERNELAPI
NTSTATUS
IoWMISetNotificationCallback(
    IN PVOID Object,
    IN WMI_NOTIFICATION_CALLBACK Callback,
    IN PVOID Context
    );

NTKERNELAPI
NTSTATUS
IoWMIHandleToInstanceName(
    IN PVOID DataBlockObject,
    IN HANDLE FileHandle,
    OUT PUNICODE_STRING InstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIDeviceObjectToInstanceName(
    IN PVOID DataBlockObject,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING InstanceName
    );

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation,
    IN BOOLEAN Quota
    );


#if defined(_WIN64)
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif
NTKERNELAPI
VOID
FASTCALL
IoAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );
DECLSPEC_DEPRECATED_DDK                 // Use IoWritePartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTKERNELAPI
NTSTATUS
IoCreateDisk(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _CREATE_DISK* Disk
    );

NTKERNELAPI
NTSTATUS
IoReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DRIVE_LAYOUT_INFORMATION_EX** DriveLayout
    );

NTKERNELAPI
NTSTATUS
IoWritePartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTKERNELAPI
NTSTATUS
IoSetPartitionInformationEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG PartitionNumber,
    IN struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    );

NTKERNELAPI
NTSTATUS
IoUpdateDiskGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DISK_GEOMETRY_EX* OldDiskGeometry,
    IN struct _DISK_GEOMETRY_EX* NewDiskGeometry
    );

NTKERNELAPI
NTSTATUS
IoVerifyPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FixErrors
    );

typedef struct _DISK_SIGNATURE {
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;

        struct {
            GUID DiskId;
        } Gpt;
    };
} DISK_SIGNATURE, *PDISK_SIGNATURE;

NTKERNELAPI
NTSTATUS
IoReadDiskSignature(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PDISK_SIGNATURE Signature
    );


NTSTATUS
IoVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );
NTSTATUS
IoEnumerateDeviceObjectList(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  *DeviceObjectList,
    IN  ULONG           DeviceObjectListSize,
    OUT PULONG          ActualNumberDeviceObjects
    );

PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IoGetDiskDeviceObject(
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );


NTSTATUS
IoSetSystemPartition(
    PUNICODE_STRING VolumeNameString
    );

// begin_wdm
VOID
IoFreeErrorLogEntry(
    PVOID ElEntry
    );

// Cancel SAFE API set start
//
// The following APIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of APIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue API set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel API code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel API set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//


//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp
    );

typedef VOID
(*PIO_CSQ_REMOVE_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
    );

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
(*PIO_CSQ_PEEK_NEXT_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
    );

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
(*PIO_CSQ_ACQUIRE_LOCK)(
     IN  PIO_CSQ Csq,
     OUT PKIRQL  Irql
     );

typedef VOID
(*PIO_CSQ_RELEASE_LOCK)(
     IN PIO_CSQ Csq,
     IN KIRQL   Irql
     );


//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
(*PIO_CSQ_COMPLETE_CANCELED_IRP)(
    IN  PIO_CSQ    Csq,
    IN  PIRP       Irp
    );

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

//
// Initializes the cancel queue structure.
//

NTSTATUS
IoCsqInitialize(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP               CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );


//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

VOID
IoCsqInsertIrp(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

//
// Returns an IRP if one can be found. NULL otherwise.
//

PIRP
IoCsqRemoveNextIrp(
    IN  PIO_CSQ   Csq,
    IN  PVOID     PeekContext
    );

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

PIRP
IoCsqRemoveIrp(
    IN  PIO_CSQ             Csq,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

// Cancel SAFE API set end


NTSTATUS
IoCreateFileSpecifyDeviceObjectHint(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PVOID DeviceObject
    );

NTSTATUS
IoAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );


NTSTATUS
IoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    );

//
// Define PnP Device Property for IoGetDeviceProperty
//

typedef enum {
    DevicePropertyDeviceDescription,
    DevicePropertyHardwareID,
    DevicePropertyCompatibleIDs,
    DevicePropertyBootConfiguration,
    DevicePropertyBootConfigurationTranslated,
    DevicePropertyClassName,
    DevicePropertyClassGuid,
    DevicePropertyDriverKeyName,
    DevicePropertyManufacturer,
    DevicePropertyFriendlyName,
    DevicePropertyLocationInformation,
    DevicePropertyPhysicalDeviceObjectName,
    DevicePropertyBusTypeGuid,
    DevicePropertyLegacyBusType,
    DevicePropertyBusNumber,
    DevicePropertyEnumeratorName,
    DevicePropertyAddress,
    DevicePropertyUINumber,
    DevicePropertyInstallState,
    DevicePropertyRemovalPolicy
} DEVICE_REGISTRY_PROPERTY;

typedef BOOLEAN (*PTRANSLATE_BUS_ADDRESS)(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef struct _DMA_ADAPTER *(*PGET_DMA_ADAPTER)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

typedef ULONG (*PGET_SET_DEVICE_DATA)(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef enum _DEVICE_INSTALL_STATE {
    InstallStateInstalled,
    InstallStateNeedsReinstall,
    InstallStateFailedInstall,
    InstallStateFinishInstall
} DEVICE_INSTALL_STATE, *PDEVICE_INSTALL_STATE;

//
// Define structure returned in response to IRP_MN_QUERY_BUS_INFORMATION by a
// PDO indicating the type of bus the device exists on.
//

typedef struct _PNP_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} PNP_BUS_INFORMATION, *PPNP_BUS_INFORMATION;

//
// Define structure returned in response to IRP_MN_QUERY_LEGACY_BUS_INFORMATION
// by an FDO indicating the type of bus it is.  This is normally the same bus
// type as the device's children (i.e., as retrieved from the child PDO's via
// IRP_MN_QUERY_BUS_INFORMATION) except for cases like CardBus, which can
// support both 16-bit (PCMCIABus) and 32-bit (PCIBus) cards.
//

typedef struct _LEGACY_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} LEGACY_BUS_INFORMATION, *PLEGACY_BUS_INFORMATION;

//
// Defines for IoGetDeviceProperty(DevicePropertyRemovalPolicy).
//
typedef enum _DEVICE_REMOVAL_POLICY {

    RemovalPolicyExpectNoRemoval = 1,
    RemovalPolicyExpectOrderlyRemoval = 2,
    RemovalPolicyExpectSurpriseRemoval = 3

} DEVICE_REMOVAL_POLICY, *PDEVICE_REMOVAL_POLICY;



typedef struct _BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PTRANSLATE_BUS_ADDRESS TranslateBusAddress;
    PGET_DMA_ADAPTER GetDmaAdapter;
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;

} BUS_INTERFACE_STANDARD, *PBUS_INTERFACE_STANDARD;

//
// The following definitions are used in ACPI QueryInterface
//
typedef BOOLEAN (* PGPE_SERVICE_ROUTINE) (
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_CONNECT_VECTOR) (
                            PDEVICE_OBJECT,
                            ULONG,
                            KINTERRUPT_MODE,
                            BOOLEAN,
                            PGPE_SERVICE_ROUTINE,
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_DISCONNECT_VECTOR) (
                            PVOID);

typedef NTSTATUS (* PGPE_ENABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_DISABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_CLEAR_STATUS) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef VOID (* PDEVICE_NOTIFY_CALLBACK) (
                            PVOID,
                            ULONG);

typedef NTSTATUS (* PREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK,
                            PVOID);

typedef void (* PUNREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK);

typedef struct _ACPI_INTERFACE_STANDARD {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR                     GpeConnectVector;
    PGPE_DISCONNECT_VECTOR                  GpeDisconnectVector;
    PGPE_ENABLE_EVENT                       GpeEnableEvent;
    PGPE_DISABLE_EVENT                      GpeDisableEvent;
    PGPE_CLEAR_STATUS                       GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS      RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS    UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD, *PACPI_INTERFACE_STANDARD;

// end_wdm end_ntddk

typedef enum _ACPI_REG_TYPE {
    PM1a_ENABLE,
    PM1b_ENABLE,
    PM1a_STATUS,
    PM1b_STATUS,
    PM1a_CONTROL,
    PM1b_CONTROL,
    GP_STATUS,
    GP_ENABLE,
    SMI_CMD,
    MaxRegType
} ACPI_REG_TYPE, *PACPI_REG_TYPE;

typedef USHORT (*PREAD_ACPI_REGISTER) (
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register);

typedef VOID (*PWRITE_ACPI_REGISTER) (
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register,
  IN USHORT        Value
  );

typedef struct ACPI_REGS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // READ/WRITE_ACPI_REGISTER functions
    //
    PREAD_ACPI_REGISTER  ReadAcpiRegister;
    PWRITE_ACPI_REGISTER WriteAcpiRegister;

} ACPI_REGS_INTERFACE_STANDARD, *PACPI_REGS_INTERFACE_STANDARD;


typedef NTSTATUS (*PHAL_QUERY_ALLOCATE_PORT_RANGE) (
  IN BOOLEAN IsSparse,
  IN BOOLEAN PrimaryIsMmio,
  IN PVOID VirtBaseAddr OPTIONAL,
  IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
  IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
  OUT PUSHORT NewRangeId
  );

typedef VOID (*PHAL_FREE_PORT_RANGE)(
    IN USHORT RangeId
    );


typedef struct _HAL_PORT_RANGE_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // QueryAllocateRange/FreeRange functions
    //
    PHAL_QUERY_ALLOCATE_PORT_RANGE QueryAllocateRange;
    PHAL_FREE_PORT_RANGE FreeRange;

} HAL_PORT_RANGE_INTERFACE, *PHAL_PORT_RANGE_INTERFACE;


//
// describe the CMOS HAL interface
//

typedef enum _CMOS_DEVICE_TYPE {
    CmosTypeStdPCAT,
    CmosTypeIntelPIIX4,
    CmosTypeDal1501
} CMOS_DEVICE_TYPE;


typedef
ULONG
(*PREAD_ACPI_CMOS) (
    IN CMOS_DEVICE_TYPE     CmosType,
    IN ULONG                SourceAddress,
    IN PUCHAR               DataBuffer,
    IN ULONG                ByteCount
    );

typedef
ULONG
(*PWRITE_ACPI_CMOS) (
    IN CMOS_DEVICE_TYPE     CmosType,
    IN ULONG                SourceAddress,
    IN PUCHAR               DataBuffer,
    IN ULONG                ByteCount
    );

typedef struct _ACPI_CMOS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // READ/WRITE_ACPI_CMOS functions
    //
    PREAD_ACPI_CMOS     ReadCmos;
    PWRITE_ACPI_CMOS    WriteCmos;

} ACPI_CMOS_INTERFACE_STANDARD, *PACPI_CMOS_INTERFACE_STANDARD;

//
// These definitions are used for getting PCI Interrupt Routing interfaces
//

typedef struct {
    PVOID   LinkNode;
    ULONG   StaticVector;
    UCHAR   Flags;
} ROUTING_TOKEN, *PROUTING_TOKEN;

//
// Flag indicating that the device supports
// MSI interrupt routing or that the provided token contains
// MSI routing information
//

#define PCI_MSI_ROUTING         0x1
#define PCI_STATIC_ROUTING      0x2

typedef
NTSTATUS
(*PGET_INTERRUPT_ROUTING)(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken,
    OUT UCHAR           *Flags
    );

typedef
NTSTATUS
(*PSET_INTERRUPT_ROUTING_TOKEN)(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    );

typedef
VOID
(*PUPDATE_INTERRUPT_LINE)(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR LineRegister
    );

typedef struct _INT_ROUTE_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PGET_INTERRUPT_ROUTING GetInterruptRouting;
    PSET_INTERRUPT_ROUTING_TOKEN SetInterruptRoutingToken;
    PUPDATE_INTERRUPT_LINE UpdateInterruptLine;

} INT_ROUTE_INTERFACE_STANDARD, *PINT_ROUTE_INTERFACE_STANDARD;

// Some well-known interface versions supported by the PCI Bus Driver

#define PCI_INT_ROUTE_INTRF_STANDARD_VER 1

NTKERNELAPI
NTSTATUS
IoSynchronousInvalidateDeviceRelations(
    PDEVICE_OBJECT DeviceObject,
    DEVICE_RELATION_TYPE Type
    );

// begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
NTSTATUS
IoReportDetectedDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements OPTIONAL,
    IN BOOLEAN ResourceAssigned,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

// begin_wdm

NTKERNELAPI
VOID
IoInvalidateDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_RELATION_TYPE Type
    );

NTKERNELAPI
VOID
IoRequestDeviceEject(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTKERNELAPI
NTSTATUS
IoGetDeviceProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
    IN ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength
    );

//
// The following definitions are used in IoOpenDeviceRegistryKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

NTKERNELAPI
NTSTATUS
IoOpenDeviceRegistryKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DevInstRegKey
    );

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString,     OPTIONAL
    OUT PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceKey
    );

NTKERNELAPI
NTSTATUS
IoSetDeviceInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable
    );

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN ULONG Flags,
    OUT PWSTR *SymbolicLinkList
    );

#define DEVICE_INTERFACE_INCLUDE_NONACTIVE   0x00000001

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaceAlias(
    IN PUNICODE_STRING SymbolicLinkName,
    IN CONST GUID *AliasInterfaceClassGuid,
    OUT PUNICODE_STRING AliasSymbolicLinkName
    );

//
// Define PnP notification event categories
//

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

//
// Define flags that modify the behavior of IoRegisterPlugPlayNotification
// for the various event categories...
//

#define PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES    0x00000001

typedef
NTSTATUS
(*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
    IN PVOID NotificationStructure,
    IN PVOID Context
);


NTKERNELAPI
NTSTATUS
IoRegisterPlugPlayNotification(
    IN IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    IN ULONG EventCategoryFlags,
    IN PVOID EventCategoryData OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Context,
    OUT PVOID *NotificationEntry
    );

NTKERNELAPI
NTSTATUS
IoUnregisterPlugPlayNotification(
    IN PVOID NotificationEntry
    );

NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChange(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    );

typedef
VOID
(*PDEVICE_CHANGE_COMPLETE_CALLBACK)(
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoInvalidateDeviceState(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#define IoAdjustPagingPathCount(_count_,_paging_) {     \
    if (_paging_) {                                     \
        InterlockedIncrement(_count_);                  \
    } else {                                            \
        InterlockedDecrement(_count_);                  \
    }                                                   \
}

NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChangeAsynchronous(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure,  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    IN PDEVICE_CHANGE_COMPLETE_CALLBACK Callback,       OPTIONAL
    IN PVOID Context    OPTIONAL
    );

NTKERNELAPI
NTSTATUS
IoReportResourceForDetection(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    OUT PBOOLEAN ConflictDetected
    );

typedef enum _RESOURCE_TRANSLATION_DIRECTION { 
    TranslateChildToParent,                    
    TranslateParentToChild                     
} RESOURCE_TRANSLATION_DIRECTION;              

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_HANDLER)(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER)(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

//
// Translator Interface
//

typedef struct _TRANSLATOR_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PTRANSLATE_RESOURCE_HANDLER TranslateResources;
    PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements;
} TRANSLATOR_INTERFACE, *PTRANSLATOR_INTERFACE;


//
// Header structure for all Plug&Play notification events...
//

typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
    USHORT Version; // presently at version 1.
    USHORT Size;    // size (in bytes) of header + event-specific data.
    GUID Event;
    //
    // Event-specific stuff starts here.
    //
} PLUGPLAY_NOTIFICATION_HEADER, *PPLUGPLAY_NOTIFICATION_HEADER;

//
// Notification structure for all EventCategoryHardwareProfileChange events...
//

typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // (No event-specific data)
    //
} HWPROFILE_CHANGE_NOTIFICATION, *PHWPROFILE_CHANGE_NOTIFICATION;


//
// Notification structure for all EventCategoryDeviceInterfaceChange events...
//

typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    GUID InterfaceClassGuid;
    PUNICODE_STRING SymbolicLinkName;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION, *PDEVICE_INTERFACE_CHANGE_NOTIFICATION;


//
// Notification structures for EventCategoryTargetDeviceChange...
//

//
// The following structure is used for TargetDeviceQueryRemove,
// TargetDeviceRemoveCancelled, and TargetDeviceRemoveComplete:
//
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;
} TARGET_DEVICE_REMOVAL_NOTIFICATION, *PTARGET_DEVICE_REMOVAL_NOTIFICATION;

//
// The following structure header is used for all other (i.e., 3rd-party)
// target device change events.  The structure accommodates both a
// variable-length binary data buffer, and a variable-length unicode text
// buffer.  The header must indicate where the text buffer begins, so that
// the data can be delivered in the appropriate format (ANSI or Unicode)
// to user-mode recipients (i.e., that have registered for handle-based
// notification via RegisterDeviceNotification).
//

typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;    // This field must be set to NULL by callers of
                                // IoReportTargetDeviceChange.  Clients that
                                // have registered for target device change
                                // notification on the affected PDO will be
                                // called with this field set to the file object
                                // they specified during registration.
                                //
    LONG NameBufferOffset;      // offset (in bytes) from beginning of
                                // CustomDataBuffer where text begins (-1 if none)
                                //
    UCHAR CustomDataBuffer[1];  // variable-length buffer, containing (optionally)
                                // a binary data at the start of the buffer,
                                // followed by an optional unicode text buffer
                                // (word-aligned).
                                //
} TARGET_DEVICE_CUSTOM_NOTIFICATION, *PTARGET_DEVICE_CUSTOM_NOTIFICATION;

ULONG
IoPnPDeliverServicePowerNotification(
    IN   POWER_ACTION           PowerOperation,
    IN   ULONG                  PowerNotificationCode,
    IN   ULONG                  PowerNotificationData,
    IN   BOOLEAN                Synchronous
    );

//
// Define OEM bitmapped font check values.
//

#define OEM_FONT_VERSION 0x200
#define OEM_FONT_TYPE 0
#define OEM_FONT_ITALIC 0
#define OEM_FONT_UNDERLINE 0
#define OEM_FONT_STRIKEOUT 0
#define OEM_FONT_CHARACTER_SET 255
#define OEM_FONT_FAMILY (3 << 4)

//
// Define OEM bitmapped font file header structure.
//
// N.B. this is a packed structure.
//

#include "pshpack1.h"
typedef struct _OEM_FONT_FILE_HEADER {
    USHORT Version;
    ULONG FileSize;
    UCHAR Copyright[60];
    USHORT Type;
    USHORT Points;
    USHORT VerticleResolution;
    USHORT HorizontalResolution;
    USHORT Ascent;
    USHORT InternalLeading;
    USHORT ExternalLeading;
    UCHAR Italic;
    UCHAR Underline;
    UCHAR StrikeOut;
    USHORT Weight;
    UCHAR CharacterSet;
    USHORT PixelWidth;
    USHORT PixelHeight;
    UCHAR Family;
    USHORT AverageWidth;
    USHORT MaximumWidth;
    UCHAR FirstCharacter;
    UCHAR LastCharacter;
    UCHAR DefaultCharacter;
    UCHAR BreakCharacter;
    USHORT WidthInBytes;
    ULONG Device;
    ULONG Face;
    ULONG BitsPointer;
    ULONG BitsOffset;
    UCHAR Filler;
    struct {
        USHORT Width;
        USHORT Offset;
    } Map[1];
} OEM_FONT_FILE_HEADER, *POEM_FONT_FILE_HEADER;
#include "poppack.h"


//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG BusNumber; // unused for WDM
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1
#define DEVICE_DESCRIPTION_VERSION2 2

// end_ntddk end_wdm

//
// Boot record disk partition table entry structure format.
//

typedef struct _PARTITION_DESCRIPTOR {
    UCHAR ActiveFlag;               // Bootable or not
    UCHAR StartingTrack;            // Not used
    UCHAR StartingCylinderLsb;      // Not used
    UCHAR StartingCylinderMsb;      // Not used
    UCHAR PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    UCHAR EndingTrack;              // Not used
    UCHAR EndingCylinderLsb;        // Not used
    UCHAR EndingCylinderMsb;        // Not used
    UCHAR StartingSectorLsb0;       // Hidden sectors
    UCHAR StartingSectorLsb1;
    UCHAR StartingSectorMsb0;
    UCHAR StartingSectorMsb1;
    UCHAR PartitionLengthLsb0;      // Sectors in this partition
    UCHAR PartitionLengthLsb1;
    UCHAR PartitionLengthMsb0;
    UCHAR PartitionLengthMsb1;
} PARTITION_DESCRIPTOR, *PPARTITION_DESCRIPTOR;

//
// Number of partition table entries
//

#define NUM_PARTITION_TABLE_ENTRIES     4

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

//
// Initial size of the Partition list structure.
//

#define PARTITION_BUFFER_SIZE          2048

//
// Partition active flag - i.e., boot indicator
//

#define PARTITION_ACTIVE_FLAG          0x80

//
// Get and set environment variable values.
//

NTHALAPI
ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    );

NTHALAPI
ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    );

NTHALAPI
NTSTATUS
HalGetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    );

NTSTATUS
HalSetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );

NTSTATUS
HalEnumerateEnvironmentVariablesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

#if defined(_ALPHA_) || defined(_IA64_)         
                                                
NTHALAPI
VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

// begin_ntddk begin_ntifs begin_ntndis
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );

#endif                                          
                                                
#if defined(_M_IX86) || defined(_M_AMD64)       
                                                
#define HalGetDmaAlignmentRequirement() 1L      
#endif                                          

NTHALAPI                                        // ntddk ntifs wdm ntndis
VOID                                            // ntddk ntifs wdm ntndis
KeFlushWriteBuffer (                            // ntddk ntifs wdm ntndis
    VOID                                        // ntddk ntifs wdm ntndis
    );                                          // ntddk ntifs wdm ntndis
                                                // ntddk ntifs wdm ntndis


#if defined(_ALPHA_)

NTHALAPI
PVOID
HalCreateQva(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN PVOID VirtualAddress
    );

NTHALAPI
PVOID
HalDereferenceQva(
    PVOID Qva,
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber
    );

#endif


#if !defined(_X86_)

NTHALAPI
BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    );

#endif
NTHALAPI
BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    );
//
// Firmware interface functions.
//

NTHALAPI
VOID
HalReturnToFirmware (
    IN FIRMWARE_REENTRY Routine
    );

//
// System interrupts functions.
//

NTHALAPI
VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    );

NTHALAPI
BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    );

// begin_ntddk
//
// I/O driver configuration functions.
//
#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif // NO_LEGACY_DRIVERS

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

//
// Values for AddressSpace parameter of HalTranslateBusAddress
//
//      0x0         - Memory space
//      0x1         - Port space
//      0x2 - 0x1F  - Address spaces specific for Alpha
//                      0x2 - UserMode view of memory space
//                      0x3 - UserMode view of port space
//                      0x4 - Dense memory space
//                      0x5 - reserved
//                      0x6 - UserMode view of dense memory space
//                      0x7 - 0x1F - reserved
//

NTHALAPI
PVOID
HalAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN OUT PULONG NumberOfMapRegisters
    );

#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif // NO_LEGACY_DRIVERS

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoGetDmaAdapter
NTHALAPI
PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

//
// System beep functions.
//
#if !defined(NO_LEGACY_DRIVERS)
NTHALAPI
BOOLEAN
HalMakeBeep(
    IN ULONG Frequency
    );
#endif // NO_LEGACY_DRIVERS

//
// The following function prototypes are for HAL routines with a prefix of Io.
//
// DMA adapter object functions.
//

//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

// begin_ntndis
//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );

typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForBus) (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );
typedef
VOID
(FASTCALL *pHalReferenceBusHandler) (
    IN PBUS_HANDLER   BusHandler
    );

//*****************************************************************************
//      HAL Function dispatch
//

typedef enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation,
    HalProfileSourceInformation,
    HalInformationClassUnused1,
    HalPowerInformation,
    HalProcessorSpeedInformation,
    HalCallbackInformation,
    HalMapRegisterInformation,
    HalMcaLogInformation,               // Machine Check Abort Information
    HalFrameBufferCachingInformation,
    HalDisplayBiosInformation,
    HalProcessorFeatureInformation,
    HalNumaTopologyInterface,
    HalErrorInformation,                // General MCA, CMC, CPE Error Information.
    HalCmcLogInformation,               // Processor Corrected Machine Check Information
    HalCpeLogInformation,               // Corrected Platform Error Information
    HalQueryMcaInterface,
    HalQueryAMLIIllegalIOPortAddresses,
    HalQueryMaxHotPlugMemoryAddress,
    HalPartitionIpiInterface,
    HalPlatformInformation
    // information levels >= 0x8000000 reserved for OEM use
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


typedef enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval,
    HalProfileSourceInterruptHandler,
    HalMcaRegisterDriver,              // Registring Machine Check Abort driver
    HalKernelErrorHandler,
    HalCmcRegisterDriver,              // Registring Processor Corrected Machine Check driver
    HalCpeRegisterDriver,              // Registring Corrected Platform  Error driver
    HalMcaLog,
    HalCmcLog,
    HalCpeLog,
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;


typedef
NTSTATUS
(*pHalQuerySystemInformation)(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );

NTSTATUS
HaliQuerySystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );
NTSTATUS
HaliHandlePCIConfigSpaceAccess(
    IN      BOOLEAN Read,
    IN      ULONG   Addr,
    IN      ULONG   Size,
    IN OUT  PULONG  pData
    );

typedef
NTSTATUS
(*pHalSetSystemInformation)(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

NTSTATUS
HaliSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

typedef
VOID
(FASTCALL *pHalExamineMBR)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

typedef
VOID
(FASTCALL *pHalIoAssignDriveLetters)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

typedef
NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

typedef
NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

typedef
NTSTATUS
(*pHalQueryBusSlots)(
    IN PBUS_HANDLER         BusHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

typedef
NTSTATUS
(*pHalInitPnpDriver)(
    VOID
    );

NTSTATUS
HaliInitPnpDriver(
    VOID
    );

typedef struct _PM_DISPATCH_TABLE {
    ULONG   Signature;
    ULONG   Version;
    PVOID   Function[1];
} PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;

typedef
NTSTATUS
(*pHalInitPowerManagement)(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

typedef
struct _DMA_ADAPTER *
(*pHalGetDmaAdapter)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

typedef
NTSTATUS
(*pHalGetInterruptTranslator)(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

NTSTATUS
HaliGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

typedef
BOOLEAN
(*pHalTranslateBusAddress)(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef
NTSTATUS
(*pHalAssignSlotResources) (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

typedef
VOID
(*pHalHaltSystem) (
    VOID
    );

typedef
VOID
(*pHalResetDisplay) (
    VOID
    );

typedef
UCHAR
(*pHalVectorToIDTEntry) (
    ULONG Vector
);

typedef
BOOLEAN
(*pHalFindBusAddressTranslation) (
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

typedef
NTSTATUS
(*pHalStartMirroring)(
    VOID
    );

typedef
NTSTATUS
(*pHalEndMirroring)(
    IN ULONG PassNumber
    );

typedef
NTSTATUS
(*pHalMirrorPhysicalMemory)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

typedef
NTSTATUS
(*pHalMirrorVerify)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

typedef struct {
    UCHAR     Type;  //CmResourceType
    BOOLEAN   Valid;
    UCHAR     Reserved[2];
    PUCHAR    TranslatedAddress;
    ULONG     Length;
} DEBUG_DEVICE_ADDRESS, *PDEBUG_DEVICE_ADDRESS;

typedef struct {
    PHYSICAL_ADDRESS  Start;
    PHYSICAL_ADDRESS  MaxEnd;
    PVOID             VirtualAddress;
    ULONG             Length;
    BOOLEAN           Cached;
    BOOLEAN           Aligned;
} DEBUG_MEMORY_REQUIREMENTS, *PDEBUG_MEMORY_REQUIREMENTS;

typedef struct {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;
    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    BOOLEAN   Initialized;
    DEBUG_DEVICE_ADDRESS BaseAddress[6];
    DEBUG_MEMORY_REQUIREMENTS   Memory;
} DEBUG_DEVICE_DESCRIPTOR, *PDEBUG_DEVICE_DESCRIPTOR;

typedef
NTSTATUS
(*pKdSetupPciDeviceForDebugging)(
    IN     PVOID                     LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
NTSTATUS
(*pKdReleasePciDeviceForDebugging)(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
PVOID
(*pKdGetAcpiTablePhase0)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN ULONG Signature
    );

typedef
VOID
(*pKdCheckPowerButton)(
    VOID
    );

typedef
VOID
(*pHalEndOfBoot)(
    VOID
    );

typedef
PVOID
(*pKdMapPhysicalMemory64)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

typedef
VOID
(*pKdUnmapVirtualAddress)(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );


typedef struct {
    ULONG                           Version;
    pHalQuerySystemInformation      HalQuerySystemInformation;
    pHalSetSystemInformation        HalSetSystemInformation;
    pHalQueryBusSlots               HalQueryBusSlots;
    ULONG                           Spare1;
    pHalExamineMBR                  HalExamineMBR;
    pHalIoAssignDriveLetters        HalIoAssignDriveLetters;
    pHalIoReadPartitionTable        HalIoReadPartitionTable;
    pHalIoSetPartitionInformation   HalIoSetPartitionInformation;
    pHalIoWritePartitionTable       HalIoWritePartitionTable;

    pHalHandlerForBus               HalReferenceHandlerForBus;
    pHalReferenceBusHandler         HalReferenceBusHandler;
    pHalReferenceBusHandler         HalDereferenceBusHandler;

    pHalInitPnpDriver               HalInitPnpDriver;
    pHalInitPowerManagement         HalInitPowerManagement;

    pHalGetDmaAdapter               HalGetDmaAdapter;
    pHalGetInterruptTranslator      HalGetInterruptTranslator;

    pHalStartMirroring              HalStartMirroring;
    pHalEndMirroring                HalEndMirroring;
    pHalMirrorPhysicalMemory        HalMirrorPhysicalMemory;
    pHalEndOfBoot                   HalEndOfBoot;
    pHalMirrorVerify                HalMirrorVerify;

} HAL_DISPATCH, *PHAL_DISPATCH;

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_DISPATCH   HalDispatchTable;
#define HALDISPATCH     HalDispatchTable

#else

extern  HAL_DISPATCH    HalDispatchTable;
#define HALDISPATCH     (&HalDispatchTable)

#endif

#define HAL_DISPATCH_VERSION        3

#define HalDispatchTableVersion         HALDISPATCH->Version
#define HalQuerySystemInformation       HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation         HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots                HALDISPATCH->HalQueryBusSlots

#define HalReferenceHandlerForBus       HALDISPATCH->HalReferenceHandlerForBus
#define HalReferenceBusHandler          HALDISPATCH->HalReferenceBusHandler
#define HalDereferenceBusHandler        HALDISPATCH->HalDereferenceBusHandler

#define HalInitPnpDriver                HALDISPATCH->HalInitPnpDriver
#define HalInitPowerManagement          HALDISPATCH->HalInitPowerManagement

#define HalGetDmaAdapter                HALDISPATCH->HalGetDmaAdapter
#define HalGetInterruptTranslator       HALDISPATCH->HalGetInterruptTranslator

#define HalStartMirroring               HALDISPATCH->HalStartMirroring
#define HalEndMirroring                 HALDISPATCH->HalEndMirroring
#define HalMirrorPhysicalMemory         HALDISPATCH->HalMirrorPhysicalMemory
#define HalEndOfBoot                    HALDISPATCH->HalEndOfBoot
#define HalMirrorVerify                 HALDISPATCH->HalMirrorVerify


//
// HAL System Information Structures.
//

// for the information class "HalInstalledBusInformation"
typedef struct _HAL_BUS_INFORMATION{
    INTERFACE_TYPE  BusType;
    BUS_DATA_TYPE   ConfigurationType;
    ULONG           BusNumber;
    ULONG           Reserved;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
    KPROFILE_SOURCE Source;
    BOOLEAN Supported;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

typedef struct _HAL_PROFILE_SOURCE_INFORMATION_EX {
    KPROFILE_SOURCE Source;
    BOOLEAN         Supported;
    ULONG_PTR       Interval;
    ULONG_PTR       DefInterval;
    ULONG_PTR       MaxInterval;
    ULONG_PTR       MinInterval;
} HAL_PROFILE_SOURCE_INFORMATION_EX, *PHAL_PROFILE_SOURCE_INFORMATION_EX;

// for the information class "HalProfileSourceInterval"
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
    KPROFILE_SOURCE Source;
    ULONG_PTR Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

// for the information class "HalDispayBiosInformation"
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
    HalDisplayInt10Bios,
    HalDisplayEmulatedBios,
    HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION, *PHAL_DISPLAY_BIOS_INFORMATION;

// for the information class "HalPowerInformation"
typedef struct _HAL_POWER_INFORMATION {
    ULONG   TBD;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

// for the information class "HalProcessorSpeedInformation"
typedef struct _HAL_PROCESSOR_SPEED_INFO {
    ULONG   ProcessorSpeed;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

// for the information class "HalCallbackInformation"
typedef struct _HAL_CALLBACKS {
    PCALLBACK_OBJECT  SetSystemInformation;
    PCALLBACK_OBJECT  BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

// for the information class "HalProcessorFeatureInformation"
typedef struct _HAL_PROCESSOR_FEATURE {
    ULONG UsableFeatureBits;
} HAL_PROCESSOR_FEATURE;

// for the information class "HalNumaTopologyInterface"

typedef ULONG HALNUMAPAGETONODE;

typedef
HALNUMAPAGETONODE
(*PHALNUMAPAGETONODE)(
    IN  ULONG_PTR   PhysicalPageNumber
    );

typedef
NTSTATUS
(*PHALNUMAQUERYPROCESSORNODE)(
    IN  ULONG       ProcessorNumber,
    OUT PUSHORT     Identifier,
    OUT PUCHAR      Node
    );

typedef struct _HAL_NUMA_TOPOLOGY_INTERFACE {
    ULONG                               NumberOfNodes;
    PHALNUMAQUERYPROCESSORNODE          QueryProcessorNode;
    PHALNUMAPAGETONODE                  PageToNode;
} HAL_NUMA_TOPOLOGY_INTERFACE;

typedef
NTSTATUS
(*PHALIOREADWRITEHANDLER)(
    IN      BOOLEAN fRead,
    IN      ULONG dwAddr,
    IN      ULONG dwSize,
    IN OUT  PULONG pdwData
    );

// for the information class "HalQueryIllegalIOPortAddresses"
typedef struct _HAL_AMLI_BAD_IO_ADDRESS_LIST
{
    ULONG                   BadAddrBegin;
    ULONG                   BadAddrSize;
    ULONG                   OSVersionTrigger;
    PHALIOREADWRITEHANDLER  IOHandler;
} HAL_AMLI_BAD_IO_ADDRESS_LIST, *PHAL_AMLI_BAD_IO_ADDRESS_LIST;


typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#pragma warning(default:4200)

// end_ntndis

typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

typedef struct _DMA_ADAPTER {
    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID
(*PDRIVER_LIST_CONTROL)(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

typedef NTSTATUS
(*PCALCULATE_SCATTER_GATHER_LIST_SIZE)(
     IN PDMA_ADAPTER DmaAdapter,
     IN OPTIONAL PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     OUT PULONG  ScatterGatherListSize,
     OUT OPTIONAL PULONG pNumberOfMapRegisters
     );

typedef NTSTATUS
(*PBUILD_SCATTER_GATHER_LIST)(
     IN PDMA_ADAPTER DmaAdapter,
     IN PDEVICE_OBJECT DeviceObject,
     IN PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     IN PDRIVER_LIST_CONTROL ExecutionRoutine,
     IN PVOID Context,
     IN BOOLEAN WriteToDevice,
     IN PVOID   ScatterGatherBuffer,
     IN ULONG   ScatterGatherLength
     );

typedef NTSTATUS
(*PBUILD_MDL_FROM_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
    PCALCULATE_SCATTER_GATHER_LIST_SIZE CalculateScatterGatherList;
    PBUILD_SCATTER_GATHER_LIST BuildScatterGatherList;
    PBUILD_MDL_FROM_SCATTER_GATHER_LIST BuildMdlFromScatterGatherList;
} DMA_OPERATIONS;

// end_wdm


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_))

// begin_wdm

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
FORCEINLINE
PVOID
HalAllocateCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
FORCEINLINE
VOID
HalFreeCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
FORCEINLINE
NTSTATUS
IoAllocateAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
FORCEINLINE
BOOLEAN
IoFlushAdapterBuffers(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
FORCEINLINE
VOID
IoFreeAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
FORCEINLINE
VOID
IoFreeMapRegisters(
    IN PDMA_ADAPTER DmaAdapter,
    IN PVOID MapRegisterBase,
    IN ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
FORCEINLINE
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}

DECLSPEC_DEPRECATED_DDK                 // Use GetDmaAlignment
FORCEINLINE
ULONG
HalGetDmaAlignment(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
FORCEINLINE
ULONG
HalReadDmaCounter(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}

// end_wdm

#else

//
// DMA adapter object functions.
//
NTHALAPI
NTSTATUS
HalAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
NTHALAPI
PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
NTHALAPI
VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
NTHALAPI
ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    );

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
NTHALAPI
BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
NTHALAPI
VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
NTHALAPI
VOID
IoFreeMapRegisters(
   IN PADAPTER_OBJECT AdapterObject,
   IN PVOID MapRegisterBase,
   IN ULONG NumberOfMapRegisters
   );

DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
NTHALAPI
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );
#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_)

NTSTATUS
HalGetScatterGatherList (
    IN PADAPTER_OBJECT DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT DmaAdapter
    );


//
// Define maximum disk transfer size to be used by MM and Cache Manager,
// so that packet-oriented disk drivers can optimize their packet allocation
// to this size.
//

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

//++
//
// ULONG_PTR
// ROUND_TO_PAGES (
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(COMPUTE_PAGES_SPANNED)   // Use ADDRESS_AND_SIZE_TO_SPAN_PAGES
#endif

#define COMPUTE_PAGES_SPANNED(Va, Size) ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size)

#define IS_SYSTEM_ADDRESS(VA) ((VA) >= MM_SYSTEM_RANGE_START)

//++
// PPFN_NUMBER
// MmGetMdlPfnArray (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlPfnArray routine returns the virtual address of the
//     first element of the array of physical page numbers associated with
//     the MDL.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the first element of the array of
//     physical page numbers associated with the MDL.
//
//--

#define MmGetMdlPfnArray(Mdl) ((PPFN_NUMBER)(Mdl + 1))

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virtual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)                                     \
    ((PVOID) ((PCHAR) ((Mdl)->StartVa) + (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

//++
//
// PVOID
// MmGetMdlStartVa (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--

#define MmGetMdlBaseVa(Mdl)  ((Mdl)->StartVa)

typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize(
    VOID
    );

//  end_wdm

NTKERNELAPI
BOOLEAN
MmIsThisAnNtAsSystem(
    VOID
    );

//  begin_wdm

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;

NTKERNELAPI
NTSTATUS
MmGrowKernelStack (
    IN PVOID CurrentStack
    );
NTKERNELAPI
NTSTATUS
MmAdjustWorkingSetSize (
    IN SIZE_T WorkingSetMinimum,
    IN SIZE_T WorkingSetMaximum,
    IN ULONG SystemCache,
    IN BOOLEAN IncreaseOkay
    );

NTKERNELAPI
NTSTATUS
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT File OPTIONAL
    );


NTKERNELAPI
NTSTATUS
MmMapViewOfSection(
    IN PVOID SectionToMap,
    IN PEPROCESS Process,
    IN OUT PVOID *CapturedBase,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PSIZE_T CapturedViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection(
    IN PEPROCESS Process,
    IN PVOID BaseAddress
     );


NTSTATUS
MmIsVerifierEnabled (
    OUT PULONG VerifierFlags
    );

NTSTATUS
MmAddVerifierThunks (
    IN PVOID ThunkBuffer,
    IN ULONG ThunkBufferSize
    );


NTKERNELAPI
VOID
MmProbeAndLockProcessPages (
    IN OUT PMDL MemoryDescriptorList,
    IN PEPROCESS Process,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );


// begin_nthal
//
// I/O support routines.
//

NTKERNELAPI
VOID
MmProbeAndLockPages (
    IN OUT PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );


NTKERNELAPI
VOID
MmUnlockPages (
    IN PMDL MemoryDescriptorList
    );


NTKERNELAPI
VOID
MmBuildMdlForNonPagedPool (
    IN OUT PMDL MemoryDescriptorList
    );

NTKERNELAPI
PVOID
MmMapLockedPages (
    IN PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
PVOID
MmGetSystemRoutineAddress (
    IN PUNICODE_STRING SystemRoutineName
    );

NTKERNELAPI
NTSTATUS
MmAdvanceMdl (
    IN PMDL Mdl,
    IN ULONG NumberOfBytes
    );

// end_wdm

NTKERNELAPI
NTSTATUS
MmMapUserAddressesToPage (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN PVOID PageAddress
    );

// begin_wdm
NTKERNELAPI
NTSTATUS
MmProtectMdlSystemAddress (
    IN PMDL MemoryDescriptorList,
    IN ULONG NewProtect
    );

//
// _MM_PAGE_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPagePriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//

// begin_ntndis

typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;

// end_ntndis

//
// Note: This function is not available in WDM 1.0
//
NTKERNELAPI
PVOID
MmMapLockedPagesSpecifyCache (
     IN PMDL MemoryDescriptorList,
     IN KPROCESSOR_MODE AccessMode,
     IN MEMORY_CACHING_TYPE CacheType,
     IN PVOID BaseAddress,
     IN ULONG BugCheckOnFailure,
     IN MM_PAGE_PRIORITY Priority
     );

NTKERNELAPI
VOID
MmUnmapLockedPages (
    IN PVOID BaseAddress,
    IN PMDL MemoryDescriptorList
    );

PVOID
MmAllocateMappingAddress (
     IN SIZE_T NumberOfBytes,
     IN ULONG PoolTag
     );

VOID
MmFreeMappingAddress (
     IN PVOID BaseAddress,
     IN ULONG PoolTag
     );

PVOID
MmMapLockedPagesWithReservedMapping (
    IN PVOID MappingAddress,
    IN ULONG PoolTag,
    IN PMDL MemoryDescriptorList,
    IN MEMORY_CACHING_TYPE CacheType
    );

VOID
MmUnmapReservedMapping (
     IN PVOID BaseAddress,
     IN ULONG PoolTag,
     IN PMDL MemoryDescriptorList
     );

// end_wdm

typedef struct _PHYSICAL_MEMORY_RANGE {
    PHYSICAL_ADDRESS BaseAddress;
    LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

NTKERNELAPI
NTSTATUS
MmAddPhysicalMemory (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

NTKERNELAPI
NTSTATUS
MmAddPhysicalMemoryEx (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes,
    IN ULONG Flags
    );

NTKERNELAPI
NTSTATUS
MmRemovePhysicalMemory (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

NTKERNELAPI
NTSTATUS
MmRemovePhysicalMemoryEx (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes,
    IN ULONG Flags
    );

NTKERNELAPI
PPHYSICAL_MEMORY_RANGE
MmGetPhysicalMemoryRanges (
    VOID
    );

NTSTATUS
MmMarkPhysicalMemoryAsGood (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

NTSTATUS
MmMarkPhysicalMemoryAsBad (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

// begin_wdm

NTKERNELAPI
PMDL
MmAllocatePagesForMdl (
    IN PHYSICAL_ADDRESS LowAddress,
    IN PHYSICAL_ADDRESS HighAddress,
    IN PHYSICAL_ADDRESS SkipBytes,
    IN SIZE_T TotalBytes
    );

NTKERNELAPI
VOID
MmFreePagesFromMdl (
    IN PMDL MemoryDescriptorList
    );

NTKERNELAPI
PVOID
MmMapIoSpace (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );


NTKERNELAPI
PVOID
MmMapVideoDisplay (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
     );

NTKERNELAPI
VOID
MmUnmapVideoDisplay (
     IN PVOID BaseAddress,
     IN SIZE_T NumberOfBytes
     );

NTKERNELAPI
PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmGetVirtualForPhysical (
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory (
    IN SIZE_T NumberOfBytes,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemorySpecifyCache (
    IN SIZE_T NumberOfBytes,
    IN PHYSICAL_ADDRESS LowestAcceptableAddress,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress,
    IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory (
    IN PVOID BaseAddress
    );

NTKERNELAPI
VOID
MmFreeContiguousMemorySpecifyCache (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );


NTKERNELAPI
PVOID
MmAllocateNonCachedMemory (
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
VOID
MmFreeNonCachedMemory (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid (
    IN PVOID VirtualAddress
    );

DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
BOOLEAN
MmIsNonPagedSystemAddressValid (
    IN PVOID VirtualAddress
    );

//  begin_wdm

NTKERNELAPI
SIZE_T
MmSizeOfMdl(
    IN PVOID Base,
    IN SIZE_T Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoCreateMdl
NTKERNELAPI
PMDL
MmCreateMdl(
    IN PMDL MemoryDescriptorList OPTIONAL,
    IN PVOID Base,
    IN SIZE_T Length
    );

NTKERNELAPI
PVOID
MmLockPagableDataSection(
    IN PVOID AddressWithinSection
    );

// end_wdm

NTKERNELAPI
VOID
MmLockPagableSectionByHandle (
    IN PVOID ImageSectionHandle
    );

NTKERNELAPI
VOID
MmResetDriverPaging (
    IN PVOID AddressWithinSection
    );


NTKERNELAPI
PVOID
MmPageEntireDriver (
    IN PVOID AddressWithinSection
    );

NTKERNELAPI
VOID
MmUnlockPagableImageSection(
    IN PVOID ImageSectionHandle
    );

NTKERNELAPI
HANDLE
MmSecureVirtualMemory (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG ProbeMode
    );

NTKERNELAPI
VOID
MmUnsecureVirtualMemory (
    IN HANDLE SecureHandle
    );

NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN OUT PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSessionSpace (
    IN PVOID MappedBase
    );

//++
//
// VOID
// MmInitializeMdl (
//     IN PMDL MemoryDescriptorList,
//     IN PVOID BaseVa,
//     IN SIZE_T Length
//     )
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--

#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
    (MemoryDescriptorList)->Next = (PMDL) NULL; \
    (MemoryDescriptorList)->Size = (CSHORT)(sizeof(MDL) +  \
            (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES((BaseVa), (Length)))); \
    (MemoryDescriptorList)->MdlFlags = 0; \
    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
    (MemoryDescriptorList)->ByteCount = (ULONG)(Length); \
    }

//++
//
// PVOID
// MmGetSystemAddressForMdlSafe (
//     IN PMDL MDL,
//     IN MM_PAGE_PRIORITY PRIORITY
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL. If the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
//     Priority - Supplies an indication as to how important it is that this
//                request succeed under low available PTE conditions.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//     Unlike MmGetSystemAddressForMdl, Safe guarantees that it will always
//     return NULL on failure instead of bugchecking the system.
//
//     This macro is not usable by WDM 1.0 drivers as 1.0 did not include
//     MmMapLockedPagesSpecifyCache.  The solution for WDM 1.0 drivers is to
//     provide synchronization and set/reset the MDL_MAPPING_CAN_FAIL bit.
//
//--

#define MmGetSystemAddressForMdlSafe(MDL, PRIORITY)                    \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPagesSpecifyCache((MDL),      \
                                                           KernelMode, \
                                                           MmCached,   \
                                                           NULL,       \
                                                           FALSE,      \
                                                           (PRIORITY))))

//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(MmGetSystemAddressForMdl)    // Use MmGetSystemAddressForMdlSafe
#endif

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

//++
//
// VOID
// MmPrepareMdlForReuse (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--

#define MmPrepareMdlForReuse(MDL)                                       \
    if (((MDL)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {         \
        ASSERT(((MDL)->MdlFlags & MDL_PARTIAL) != 0);                   \
        MmUnmapLockedPages( (MDL)->MappedSystemVa, (MDL) );             \
    } else if (((MDL)->MdlFlags & MDL_PARTIAL) == 0) {                  \
        ASSERT(((MDL)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);       \
    }

typedef NTSTATUS (*PMM_DLL_INITIALIZE)(
    IN PUNICODE_STRING RegistryPath
    );

typedef NTSTATUS (*PMM_DLL_UNLOAD)(
    VOID
    );



//
// Define an empty typedef for the _DRIVER_OBJECT structure so it may be
// referenced by function types before it is actually defined.
//
struct _DRIVER_OBJECT;

NTKERNELAPI
LOGICAL
MmIsDriverVerifying (
    IN struct _DRIVER_OBJECT *DriverObject
    );

VOID
MmMapMemoryDumpMdl(
    IN OUT PMDL MemoryDumpMdl
    );


// begin_ntminiport

//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );

// end_ntminiport

NTSTATUS
MmSetBankedSection (
    IN HANDLE ProcessHandle,
    IN PVOID VirtualAddress,
    IN ULONG BankLength,
    IN BOOLEAN ReadWriteBank,
    IN PBANKED_SECTION_ROUTINE BankRoutine,
    IN PVOID Context);
//
//  Security operation codes
//

typedef enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor,
    QuerySecurityDescriptor,
    DeleteSecurityDescriptor,
    AssignSecurityDescriptor
    } SECURITY_OPERATION_CODE, *PSECURITY_OPERATION_CODE;

//
//  Data structure used to capture subject security context
//  for access validations and auditing.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
    } SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  ACCESS_STATE and related structures                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  Initial Privilege Set - Room for three privileges, which should
//  be enough for most applications.  This structure exists so that
//  it can be imbedded in an ACCESS_STATE structure.  Use PRIVILEGE_SET
//  for all other references to Privilege sets.
//

#define INITIAL_PRIVILEGE_COUNT         3

typedef struct _INITIAL_PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
    } INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;



//
// Combine the information that describes the state
// of an access-in-progress into a single structure
//


typedef struct _ACCESS_STATE {
   LUID OperationID;
   BOOLEAN SecurityEvaluated;
   BOOLEAN GenerateAudit;
   BOOLEAN GenerateOnClose;
   BOOLEAN PrivilegesAllocated;
   ULONG Flags;
   ACCESS_MASK RemainingDesiredAccess;
   ACCESS_MASK PreviouslyGrantedAccess;
   ACCESS_MASK OriginalDesiredAccess;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
   PSECURITY_DESCRIPTOR SecurityDescriptor;
   PVOID AuxData;
   union {
      INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
      PRIVILEGE_SET PrivilegeSet;
      } Privileges;

   BOOLEAN AuditPrivileges;
   UNICODE_STRING ObjectName;
   UNICODE_STRING ObjectTypeName;

   } ACCESS_STATE, *PACCESS_STATE;

typedef struct _AUX_ACCESS_DATA {
    PPRIVILEGE_SET PrivilegesUsed;
    GENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessesToAudit;
    ACCESS_MASK MaximumAuditMask;
} AUX_ACCESS_DATA, *PAUX_ACCESS_DATA;

typedef struct _SE_EXPORTS {

    //
    // Privilege values
    //

    LUID    SeCreateTokenPrivilege;
    LUID    SeAssignPrimaryTokenPrivilege;
    LUID    SeLockMemoryPrivilege;
    LUID    SeIncreaseQuotaPrivilege;
    LUID    SeUnsolicitedInputPrivilege;
    LUID    SeTcbPrivilege;
    LUID    SeSecurityPrivilege;
    LUID    SeTakeOwnershipPrivilege;
    LUID    SeLoadDriverPrivilege;
    LUID    SeCreatePagefilePrivilege;
    LUID    SeIncreaseBasePriorityPrivilege;
    LUID    SeSystemProfilePrivilege;
    LUID    SeSystemtimePrivilege;
    LUID    SeProfileSingleProcessPrivilege;
    LUID    SeCreatePermanentPrivilege;
    LUID    SeBackupPrivilege;
    LUID    SeRestorePrivilege;
    LUID    SeShutdownPrivilege;
    LUID    SeDebugPrivilege;
    LUID    SeAuditPrivilege;
    LUID    SeSystemEnvironmentPrivilege;
    LUID    SeChangeNotifyPrivilege;
    LUID    SeRemoteShutdownPrivilege;


    //
    // Universally defined Sids
    //


    PSID  SeNullSid;
    PSID  SeWorldSid;
    PSID  SeLocalSid;
    PSID  SeCreatorOwnerSid;
    PSID  SeCreatorGroupSid;


    //
    // Nt defined Sids
    //


    PSID  SeNtAuthoritySid;
    PSID  SeDialupSid;
    PSID  SeNetworkSid;
    PSID  SeBatchSid;
    PSID  SeInteractiveSid;
    PSID  SeLocalSystemSid;
    PSID  SeAliasAdminsSid;
    PSID  SeAliasUsersSid;
    PSID  SeAliasGuestsSid;
    PSID  SeAliasPowerUsersSid;
    PSID  SeAliasAccountOpsSid;
    PSID  SeAliasSystemOpsSid;
    PSID  SeAliasPrintOpsSid;
    PSID  SeAliasBackupOpsSid;

    //
    // New Sids defined for NT5
    //

    PSID  SeAuthenticatedUsersSid;

    PSID  SeRestrictedSid;
    PSID  SeAnonymousLogonSid;

    //
    // New Privileges defined for NT5
    //

    LUID  SeUndockPrivilege;
    LUID  SeSyncAgentPrivilege;
    LUID  SeEnableDelegationPrivilege;

    //
    // New Sids defined for post-Windows 2000

    PSID  SeLocalServiceSid;
    PSID  SeNetworkServiceSid;

    //
    // New Privileges defined for post-Windows 2000
    //

    LUID  SeManageVolumePrivilege;

} SE_EXPORTS, *PSE_EXPORTS;

#define SeDeleteClientSecurity(C)  {                                           \
            if (SeTokenType((C)->ClientToken) == TokenPrimary) {               \
                PsDereferencePrimaryToken( (C)->ClientToken );                 \
            } else {                                                           \
                PsDereferenceImpersonationToken( (C)->ClientToken );           \
            }                                                                  \
        }

// end_ntifs

//++
//VOID
//SeStopImpersonatingClient()
//
///*++
//
//Routine Description:
//
//    This service is used to stop impersonating a client using an
//    impersonation token.  This service must be called in the context
//    of the server thread which wishes to stop impersonating its
//    client.
//
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//--

#define SeStopImpersonatingClient() PsRevertToSelf()

NTKERNELAPI
NTSTATUS
SeCaptureSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    IN KPROCESSOR_MODE RequestorMode,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );

NTKERNELAPI
VOID
SeReleaseSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR CapturedSecurityDescriptor,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN ForceCapture
    );

// begin_ntifs

NTKERNELAPI
VOID
SeCaptureSubjectContext (
    OUT PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTKERNELAPI
VOID
SeLockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTKERNELAPI
VOID
SeUnlockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

NTKERNELAPI
VOID
SeReleaseSubjectContext (
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );


NTKERNELAPI
NTSTATUS
SeAssignSecurity (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ExplicitDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
NTSTATUS
SeAssignSecurityEx (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ExplicitDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
NTSTATUS
SeDeassignSecurity (
    IN OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTKERNELAPI
BOOLEAN
SeAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN BOOLEAN SubjectContextLocked,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN KPROCESSOR_MODE AccessMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


#ifdef SE_NTFS_WORLD_CACHE

VOID
SeGetWorldRights (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK GrantedAccess
    );

#endif


NTKERNELAPI
BOOLEAN
SePrivilegeCheck(
    IN OUT PPRIVILEGE_SET RequiredPrivileges,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
VOID
SeFreePrivileges(
    IN PPRIVILEGE_SET Privileges
    );

NTKERNELAPI
VOID
SePrivilegeObjectAuditAlarm(
    IN HANDLE Handle,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode
    );
NTKERNELAPI                                     // ntifs
TOKEN_TYPE                                      // ntifs
SeTokenType(                                    // ntifs
    IN PACCESS_TOKEN Token                      // ntifs
    );                                          // ntifs

SECURITY_IMPERSONATION_LEVEL
SeTokenImpersonationLevel(
    IN PACCESS_TOKEN Token
    );

NTKERNELAPI                                     // ntifs
BOOLEAN                                         // ntifs
SeTokenIsAdmin(                                 // ntifs
    IN PACCESS_TOKEN Token                      // ntifs
    );                                          // ntifs


NTKERNELAPI                                     // ntifs
BOOLEAN                                         // ntifs
SeTokenIsRestricted(                            // ntifs
    IN PACCESS_TOKEN Token                      // ntifs
    );                                          // ntifs
NTKERNELAPI
NTSTATUS
SeQueryAuthenticationIdToken(
    IN PACCESS_TOKEN Token,
    OUT PLUID AuthenticationId
    );

NTKERNELAPI
NTSTATUS
SeCreateClientSecurity (
    IN PETHREAD ClientThread,
    IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    IN BOOLEAN RemoteSession,
    OUT PSECURITY_CLIENT_CONTEXT ClientContext
    );
NTKERNELAPI
NTSTATUS
SeImpersonateClientEx(
    IN PSECURITY_CLIENT_CONTEXT ClientContext,
    IN PETHREAD ServerThread OPTIONAL
    );
NTKERNELAPI
NTSTATUS
SeCreateAccessState(
   IN PACCESS_STATE AccessState,
   IN PAUX_ACCESS_DATA AuxData,
   IN ACCESS_MASK DesiredAccess,
   IN PGENERIC_MAPPING GenericMapping
   );

NTKERNELAPI
VOID
SeDeleteAccessState(
    IN PACCESS_STATE AccessState
    );

NTKERNELAPI
NTSTATUS
SeQuerySecurityDescriptorInfo (
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );

NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfo (
    IN PVOID Object OPTIONAL,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfoEx (
    IN PVOID Object OPTIONAL,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTKERNELAPI
NTSTATUS
SeAppendPrivileges(
    PACCESS_STATE AccessState,
    PPRIVILEGE_SET Privileges
    );

NTKERNELAPI                                                     
BOOLEAN                                                         
SeSinglePrivilegeCheck(                                         
    LUID PrivilegeValue,                                        
    KPROCESSOR_MODE PreviousMode                                
    );                                                          

NTKERNELAPI
NTSTATUS
SeQueryInformationToken (
    IN PACCESS_TOKEN Token,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID *TokenInformation
    );

//
//  Grants access to SeExports structure
//

extern NTKERNELAPI PSE_EXPORTS SeExports;


NTKERNELAPI
VOID
PoSetSystemState (
    IN EXECUTION_STATE Flags
    );

// begin_ntifs

NTKERNELAPI
PVOID
PoRegisterSystemState (
    IN PVOID StateHandle,
    IN EXECUTION_STATE Flags
    );

// end_ntifs

typedef
VOID
(*PREQUEST_POWER_COMPLETE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTKERNELAPI
NTSTATUS
PoRequestPowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PREQUEST_POWER_COMPLETE CompletionFunction,
    IN PVOID Context,
    OUT PIRP *Irp OPTIONAL
    );

NTKERNELAPI
NTSTATUS
PoRequestShutdownEvent (
    OUT PVOID *Event
    );

NTKERNELAPI
NTSTATUS
PoRequestShutdownWait (
    IN PETHREAD Thread
    );

// begin_ntifs

NTKERNELAPI
VOID
PoUnregisterSystemState (
    IN PVOID StateHandle
    );

// begin_nthal

NTKERNELAPI
POWER_STATE
PoSetPowerState (
    IN PDEVICE_OBJECT   DeviceObject,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State
    );

NTKERNELAPI
NTSTATUS
PoCallDriver (
    IN PDEVICE_OBJECT   DeviceObject,
    IN OUT PIRP         Irp
    );

NTKERNELAPI
VOID
PoStartNextPowerIrp(
    IN PIRP    Irp
    );


NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    IN PDEVICE_OBJECT     DeviceObject,
    IN ULONG              ConservationIdleTime,
    IN ULONG              PerformanceIdleTime,
    IN DEVICE_POWER_STATE State
    );

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0

//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5

// end_ntddk end_wdm end_nthal

// Used for queuing work items to be performed at shutdown time.  Same
// rules apply as per Ex work queues.
NTKERNELAPI
NTSTATUS
PoQueueShutdownWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    );


PKTHREAD
FORCEINLINE
PsGetKernelThread(
    IN PETHREAD ThreadObject
    )
{
    return (PKTHREAD)ThreadObject;
}

PKPROCESS
FORCEINLINE
PsGetKernelProcess(
    IN PEPROCESS ProcessObject
    )
{
    return (PKPROCESS)ProcessObject;
}

NTSTATUS
PsGetContextThread(
    IN PETHREAD Thread,
    IN OUT PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    );

NTSTATUS
PsSetContextThread(
    IN PETHREAD Thread,
    IN PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    );

NTKERNELAPI
PEPROCESS
PsGetCurrentProcess(
    VOID
    );

NTKERNELAPI
PETHREAD
PsGetCurrentThread(
    VOID
    );
//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

NTKERNELAPI
NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );


NTKERNELAPI
PACCESS_TOKEN
PsReferencePrimaryToken(
    IN PEPROCESS Process
    );

VOID
PsDereferencePrimaryToken(
    IN PACCESS_TOKEN PrimaryToken
    );

VOID
PsDereferenceImpersonationToken(
    IN PACCESS_TOKEN ImpersonationToken
    );

// end_ntifs
// begin_ntifs

NTKERNELAPI
PACCESS_TOKEN
PsReferenceImpersonationToken(
    IN PETHREAD Thread,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

// end_ntifs

PACCESS_TOKEN
PsReferenceEffectiveToken(
    IN PETHREAD Thread,
    OUT PTOKEN_TYPE TokenType,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );

// begin_ntifs



LARGE_INTEGER
PsGetProcessExitTime(
    VOID
    );

// end_ntifs
BOOLEAN
PsIsThreadTerminating(
    IN PETHREAD Thread
    );


NTSTATUS
PsImpersonateClient(
    IN PETHREAD Thread,
    IN PACCESS_TOKEN Token,
    IN BOOLEAN CopyOnOpen,
    IN BOOLEAN EffectiveOnly,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


NTKERNELAPI
VOID
PsRevertToSelf(
    VOID
    );

NTKERNELAPI
VOID
PsRevertThreadToSelf(
    PETHREAD Thread
    );

NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
    IN HANDLE ProcessId,
    OUT PEPROCESS *Process
    );

NTKERNELAPI
NTSTATUS
PsLookupThreadByThreadId(
    IN HANDLE ThreadId,
    OUT PETHREAD *Thread
    );

// begin_ntifs
//
// Quota Operations
//

VOID
PsChargePoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR Amount
    );

NTSTATUS
PsChargeProcessPoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR Amount
    );

VOID
PsReturnPoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR Amount
    );

// end_ntifs

typedef
NTSTATUS
(*PKWIN32_PROCESS_CALLOUT) (
    IN PEPROCESS Process,
    IN BOOLEAN Initialize
    );


typedef enum _PSW32JOBCALLOUTTYPE {
    PsW32JobCalloutSetInformation,
    PsW32JobCalloutAddProcess,
    PsW32JobCalloutTerminate
} PSW32JOBCALLOUTTYPE;

typedef struct _WIN32_JOBCALLOUT_PARAMETERS {
    PVOID Job;
    PSW32JOBCALLOUTTYPE CalloutType;
    IN PVOID Data;
} WIN32_JOBCALLOUT_PARAMETERS, *PKWIN32_JOBCALLOUT_PARAMETERS;


typedef
NTSTATUS
(*PKWIN32_JOB_CALLOUT) (
    IN PKWIN32_JOBCALLOUT_PARAMETERS Parm
     );


typedef enum _PSW32THREADCALLOUTTYPE {
    PsW32ThreadCalloutInitialize,
    PsW32ThreadCalloutExit
} PSW32THREADCALLOUTTYPE;

typedef
NTSTATUS
(*PKWIN32_THREAD_CALLOUT) (
    IN PETHREAD Thread,
    IN PSW32THREADCALLOUTTYPE CalloutType
    );

typedef enum _PSPOWEREVENTTYPE {
    PsW32FullWake,
    PsW32EventCode,
    PsW32PowerPolicyChanged,
    PsW32SystemPowerState,
    PsW32SystemTime,
    PsW32DisplayState,
    PsW32CapabilitiesChanged,
    PsW32SetStateFailed,
    PsW32GdiOff,
    PsW32GdiOn
} PSPOWEREVENTTYPE;

typedef struct _WIN32_POWEREVENT_PARAMETERS {
    PSPOWEREVENTTYPE EventNumber;
    ULONG_PTR Code;
} WIN32_POWEREVENT_PARAMETERS, *PKWIN32_POWEREVENT_PARAMETERS;



typedef enum _POWERSTATETASK {
    PowerState_BlockSessionSwitch,
    PowerState_Init,
    PowerState_QueryApps,
    PowerState_QueryFailed,
    PowerState_SuspendApps,
    PowerState_ShowUI,
    PowerState_NotifyWL,
    PowerState_ResumeApps,
    PowerState_UnBlockSessionSwitch

} POWERSTATETASK;

typedef struct _WIN32_POWERSTATE_PARAMETERS {
    BOOLEAN Promotion;
    POWER_ACTION SystemAction;
    SYSTEM_POWER_STATE MinSystemState;
    ULONG Flags;
    BOOLEAN fQueryDenied;
    POWERSTATETASK PowerStateTask;
} WIN32_POWERSTATE_PARAMETERS, *PKWIN32_POWERSTATE_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_POWEREVENT_CALLOUT) (
    IN PKWIN32_POWEREVENT_PARAMETERS Parm
    );

typedef
NTSTATUS
(*PKWIN32_POWERSTATE_CALLOUT) (
    IN PKWIN32_POWERSTATE_PARAMETERS Parm
    );

typedef
NTSTATUS
(*PKWIN32_OBJECT_CALLOUT) (
    IN PVOID Parm
    );



typedef struct _WIN32_CALLOUTS_FPNS {
    PKWIN32_PROCESS_CALLOUT ProcessCallout;
    PKWIN32_THREAD_CALLOUT ThreadCallout;
    PKWIN32_GLOBALATOMTABLE_CALLOUT GlobalAtomTableCallout;
    PKWIN32_POWEREVENT_CALLOUT PowerEventCallout;
    PKWIN32_POWERSTATE_CALLOUT PowerStateCallout;
    PKWIN32_JOB_CALLOUT JobCallout;
    PVOID BatchFlushRoutine;
    PKWIN32_OBJECT_CALLOUT DesktopOpenProcedure;
    PKWIN32_OBJECT_CALLOUT DesktopOkToCloseProcedure;
    PKWIN32_OBJECT_CALLOUT DesktopCloseProcedure;
    PKWIN32_OBJECT_CALLOUT DesktopDeleteProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationOkToCloseProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationCloseProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationDeleteProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationParseProcedure;
    PKWIN32_OBJECT_CALLOUT WindowStationOpenProcedure;
} WIN32_CALLOUTS_FPNS, *PKWIN32_CALLOUTS_FPNS;

NTKERNELAPI
VOID
PsEstablishWin32Callouts(
    IN PKWIN32_CALLOUTS_FPNS pWin32Callouts
    );

typedef enum _PSPROCESSPRIORITYMODE {
    PsProcessPriorityBackground,
    PsProcessPriorityForeground,
    PsProcessPrioritySpinning
} PSPROCESSPRIORITYMODE;

NTKERNELAPI
VOID
PsSetProcessPriorityByClass(
    IN PEPROCESS Process,
    IN PSPROCESSPRIORITYMODE PriorityMode
    );



HANDLE
PsGetCurrentProcessId( VOID );

HANDLE
PsGetCurrentThreadId( VOID );


NTKERNELAPI
ULONG
PsGetCurrentProcessSessionId(
    VOID
    );

NTKERNELAPI
PVOID
PsGetCurrentThreadStackLimit(
    VOID
    );

NTKERNELAPI
PVOID
PsGetCurrentThreadStackBase(
    VOID
    );

NTKERNELAPI
CCHAR
PsGetCurrentThreadPreviousMode(
    VOID
    );

NTKERNELAPI
PERESOURCE
PsGetJobLock(
    PEJOB Job
    );

NTKERNELAPI
ULONG
PsGetJobSessionId(
    PEJOB Job
    );

NTKERNELAPI
ULONG
PsGetJobUIRestrictionsClass(
    PEJOB Job
    );

NTKERNELAPI
LONGLONG
PsGetProcessCreateTimeQuadPart(
    PEPROCESS Process
    );

NTKERNELAPI
PVOID
PsGetProcessDebugPort(
    PEPROCESS Process
    );

BOOLEAN
PsIsProcessBeingDebugged(
    PEPROCESS Process
    );

NTKERNELAPI
BOOLEAN
PsGetProcessExitProcessCalled(
    PEPROCESS Process
    );

NTKERNELAPI
NTSTATUS
PsGetProcessExitStatus(
    PEPROCESS Process
    );

NTKERNELAPI
HANDLE
PsGetProcessId(
    PEPROCESS Process
    );

NTKERNELAPI
UCHAR *
PsGetProcessImageFileName(
    PEPROCESS Process
    );

#define PsGetCurrentProcessImageFileName() PsGetProcessImageFileName(PsGetCurrentProcess())

NTKERNELAPI
HANDLE
PsGetProcessInheritedFromUniqueProcessId(
    PEPROCESS Process
    );

NTKERNELAPI
PEJOB
PsGetProcessJob(
    PEPROCESS Process
    );

NTKERNELAPI
ULONG
PsGetProcessSessionId(
    PEPROCESS Process
    );

NTKERNELAPI
PVOID
PsGetProcessSectionBaseAddress(
    PEPROCESS Process
    );


#define PsGetProcessPcb(Process) ((PKPROCESS)(Process))

NTKERNELAPI
PPEB
PsGetProcessPeb(
    PEPROCESS Process
    );

NTKERNELAPI
UCHAR
PsGetProcessPriorityClass(
    PEPROCESS Process
    );

NTKERNELAPI
HANDLE
PsGetProcessWin32WindowStation(
    PEPROCESS Process
    );

#define PsGetCurrentProcessWin32WindowStation() PsGetProcessWin32WindowStation(PsGetCurrentProcess())

NTKERNELAPI
PVOID
PsGetProcessWin32Process(
    PEPROCESS Process
    );

#define PsGetCurrentProcessWin32Process() PsGetProcessWin32Process(PsGetCurrentProcess())

#if defined(_WIN64)
NTKERNELAPI
PVOID
PsGetProcessWow64Process(
    PEPROCESS Process
    );
#endif

NTKERNELAPI
HANDLE
PsGetThreadId(
    PETHREAD Thread
     );

NTKERNELAPI
CCHAR
PsGetThreadFreezeCount(
    PETHREAD Thread
    );

NTKERNELAPI
BOOLEAN
PsGetThreadHardErrorsAreDisabled(
    PETHREAD Thread);

NTKERNELAPI
PEPROCESS
PsGetThreadProcess(
    PETHREAD Thread
     );

#define PsGetCurrentThreadProcess() PsGetThreadProcess(PsGetCurrentThread())

NTKERNELAPI
HANDLE
PsGetThreadProcessId(
    PETHREAD Thread
     );
#define PsGetCurrentThreadProcessId() PsGetThreadProcessId(PsGetCurrentThread())

NTKERNELAPI
ULONG
PsGetThreadSessionId(
    PETHREAD Thread
     );

#define  PsGetThreadTcb(Thread) ((PKTHREAD)(Thread))

NTKERNELAPI
PVOID
PsGetThreadTeb(
    PETHREAD Thread
     );

#define PsGetCurrentThreadTeb() PsGetThreadTeb(PsGetCurrentThread())

NTKERNELAPI
PVOID
PsGetThreadWin32Thread(
    PETHREAD Thread
     );

#define PsGetCurrentThreadWin32Thread() PsGetThreadWin32Thread(PsGetCurrentThread())


NTKERNELAPI                         //ntifs
BOOLEAN                             //ntifs
PsIsSystemThread(                   //ntifs
    PETHREAD Thread                 //ntifs
     );                             //ntifs

NTKERNELAPI
BOOLEAN
PsIsThreadImpersonating (
    IN PETHREAD Thread
    );

NTSTATUS
PsReferenceProcessFilePointer (
    IN PEPROCESS Process,
    OUT PVOID *pFilePointer
    );

NTKERNELAPI
VOID
PsSetJobUIRestrictionsClass(
    PEJOB Job,
    ULONG UIRestrictionsClass
    );

NTKERNELAPI
VOID
PsSetProcessPriorityClass(
    PEPROCESS Process,
    UCHAR PriorityClass
    );

NTKERNELAPI
NTSTATUS
PsSetProcessWin32Process(
    PEPROCESS Process,
    PVOID Win32Process,
    PVOID PrevWin32Proces
    );

NTKERNELAPI
VOID
PsSetProcessWindowStation(
    PEPROCESS Process,
    HANDLE Win32WindowStation
    );


NTKERNELAPI
VOID
PsSetThreadHardErrorsAreDisabled(
    PETHREAD Thread,
    BOOLEAN HardErrorsAreDisabled
    );

NTKERNELAPI
VOID
PsSetThreadWin32Thread(
    PETHREAD Thread,
    PVOID Win32Thread,
    PVOID PrevWin32Thread
    );

NTKERNELAPI
PVOID
PsGetProcessSecurityPort(
    PEPROCESS Process
    );

NTKERNELAPI
NTSTATUS
PsSetProcessSecurityPort(
    PEPROCESS Process,
    PVOID Port
    );

typedef
NTSTATUS
(*PROCESS_ENUM_ROUTINE)(
    IN PEPROCESS Process,
    IN PVOID Context
    );

typedef
NTSTATUS
(*THREAD_ENUM_ROUTINE)(
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PVOID Context
    );

NTSTATUS
PsEnumProcesses (
    IN PROCESS_ENUM_ROUTINE CallBack,
    IN PVOID Context
    );


NTSTATUS
PsEnumProcessThreads (
    IN PEPROCESS Process,
    IN THREAD_ENUM_ROUTINE CallBack,
    IN PVOID Context
    );

PEPROCESS
PsGetNextProcess (
    IN PEPROCESS Process
    );

PETHREAD
PsGetNextProcessThread (
    IN PEPROCESS Process,
    IN PETHREAD Thread
    );

VOID
PsQuitNextProcess (
    IN PEPROCESS Process
    );

VOID
PsQuitNextProcessThread (
    IN PETHREAD Thread
    );

PEJOB
PsGetNextJob (
    IN PEJOB Job
    );

PEPROCESS
PsGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    );

VOID
PsQuitNextJob (
    IN PEJOB Job
    );

VOID
PsQuitNextJobProcess (
    IN PEPROCESS Process
    );

NTSTATUS
PsSuspendProcess (
    IN PEPROCESS Process
    );

NTSTATUS
PsResumeProcess (
    IN PEPROCESS Process
    );

NTSTATUS
PsTerminateProcess(
    IN PEPROCESS Process,
    IN NTSTATUS Status
    );

NTSTATUS
PsSuspendThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );

NTSTATUS
PsResumeThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );

//
// Object Manager types
//

typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

// end_ntddk end_wdm end_nthal end_ntifs

typedef struct _OBJECT_DUMP_CONTROL {
    PVOID Stream;
    ULONG Detail;
} OB_DUMP_CONTROL, *POB_DUMP_CONTROL;

typedef VOID (*OB_DUMP_METHOD)(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

typedef enum _OB_OPEN_REASON {
    ObCreateHandle,
    ObOpenHandle,
    ObDuplicateHandle,
    ObInheritHandle,
    ObMaxOpenReason
} OB_OPEN_REASON;


typedef NTSTATUS (*OB_OPEN_METHOD)(
    IN OB_OPEN_REASON OpenReason,
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG HandleCount
    );

typedef BOOLEAN (*OB_OKAYTOCLOSE_METHOD)(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

typedef VOID (*OB_CLOSE_METHOD)(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    );

typedef VOID (*OB_DELETE_METHOD)(
    IN  PVOID   Object
    );

typedef NTSTATUS (*OB_PARSE_METHOD)(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

typedef NTSTATUS (*OB_SECURITY_METHOD)(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

typedef NTSTATUS (*OB_QUERYNAME_METHOD)(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

/*

    A security method and its caller must obey the following w.r.t.
    capturing and probing parameters:

    For a query operation, the caller must pass a kernel space address for
    CapturedLength.  The caller should be able to assume that it points to
    valid data that will not change.  In addition, the SecurityDescriptor
    parameter (which will receive the result of the query operation) must
    be probed for write up to the length given in CapturedLength.  The
    security method itself must always write to the SecurityDescriptor
    buffer in a try clause in case the caller de-allocates it.

    For a set operation, the SecurityDescriptor parameter must have
    been captured via SeCaptureSecurityDescriptor.  This parameter is
    not optional, and therefore may not be NULL.

*/



//
// Prototypes for Win32 WindowStation and Desktop object callout routines
//
typedef struct _WIN32_OPENMETHOD_PARAMETERS {
   OB_OPEN_REASON OpenReason;
   PEPROCESS Process;
   PVOID Object;
   ACCESS_MASK GrantedAccess;
   ULONG HandleCount;
} WIN32_OPENMETHOD_PARAMETERS, *PKWIN32_OPENMETHOD_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_OPENMETHOD_CALLOUT) ( PKWIN32_OPENMETHOD_PARAMETERS );
extern PKWIN32_OPENMETHOD_CALLOUT ExDesktopOpenProcedureCallout;
extern PKWIN32_OPENMETHOD_CALLOUT ExWindowStationOpenProcedureCallout;



typedef struct _WIN32_OKAYTOCLOSEMETHOD_PARAMETERS {
   PEPROCESS Process;
   PVOID Object;
   HANDLE Handle;
   KPROCESSOR_MODE PreviousMode;
} WIN32_OKAYTOCLOSEMETHOD_PARAMETERS, *PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_OKTOCLOSEMETHOD_CALLOUT) ( PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS );
extern PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExDesktopOkToCloseProcedureCallout;
extern PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExWindowStationOkToCloseProcedureCallout;



typedef struct _WIN32_CLOSEMETHOD_PARAMETERS {
   PEPROCESS Process;
   PVOID Object;
   ACCESS_MASK GrantedAccess;
   ULONG ProcessHandleCount;
   ULONG SystemHandleCount;
} WIN32_CLOSEMETHOD_PARAMETERS, *PKWIN32_CLOSEMETHOD_PARAMETERS;
typedef
NTSTATUS
(*PKWIN32_CLOSEMETHOD_CALLOUT) ( PKWIN32_CLOSEMETHOD_PARAMETERS );
extern PKWIN32_CLOSEMETHOD_CALLOUT ExDesktopCloseProcedureCallout;
extern PKWIN32_CLOSEMETHOD_CALLOUT ExWindowStationCloseProcedureCallout;



typedef struct _WIN32_DELETEMETHOD_PARAMETERS {
   PVOID Object;
} WIN32_DELETEMETHOD_PARAMETERS, *PKWIN32_DELETEMETHOD_PARAMETERS;
typedef
NTSTATUS
(*PKWIN32_DELETEMETHOD_CALLOUT) ( PKWIN32_DELETEMETHOD_PARAMETERS );
extern PKWIN32_DELETEMETHOD_CALLOUT ExDesktopDeleteProcedureCallout;
extern PKWIN32_DELETEMETHOD_CALLOUT ExWindowStationDeleteProcedureCallout;


typedef struct _WIN32_PARSEMETHOD_PARAMETERS {
   PVOID ParseObject;
   PVOID ObjectType;
   PACCESS_STATE AccessState;
   KPROCESSOR_MODE AccessMode;
   ULONG Attributes;
   PUNICODE_STRING CompleteName;
   PUNICODE_STRING RemainingName;
   PVOID Context OPTIONAL;
   PSECURITY_QUALITY_OF_SERVICE SecurityQos;
   PVOID *Object;
} WIN32_PARSEMETHOD_PARAMETERS, *PKWIN32_PARSEMETHOD_PARAMETERS;
typedef
NTSTATUS
(*PKWIN32_PARSEMETHOD_CALLOUT) ( PKWIN32_PARSEMETHOD_PARAMETERS );
extern PKWIN32_PARSEMETHOD_CALLOUT ExWindowStationParseProcedureCallout;


//
// Object Type Structure
//

typedef struct _OBJECT_TYPE_INITIALIZER {
    USHORT Length;
    BOOLEAN UseDefaultObject;
    BOOLEAN CaseInsensitive;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    BOOLEAN MaintainTypeList;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    OB_DUMP_METHOD DumpProcedure;
    OB_OPEN_METHOD OpenProcedure;
    OB_CLOSE_METHOD CloseProcedure;
    OB_DELETE_METHOD DeleteProcedure;
    OB_PARSE_METHOD ParseProcedure;
    OB_SECURITY_METHOD SecurityProcedure;
    OB_QUERYNAME_METHOD QueryNameProcedure;
    OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;

#define OBJECT_LOCK_COUNT 4

typedef struct _OBJECT_TYPE {
    ERESOURCE Mutex;
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;            // Copy from object header for convenience
    PVOID DefaultObject;
    ULONG Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER TypeInfo;
#ifdef POOL_TAGGING
    ULONG Key;
#endif //POOL_TAGGING
    ERESOURCE ObjectLocks[ OBJECT_LOCK_COUNT ];
} OBJECT_TYPE, *POBJECT_TYPE;

//
// Object Directory Structure
//

#define NUMBER_HASH_BUCKETS 37

typedef struct _OBJECT_DIRECTORY {
    struct _OBJECT_DIRECTORY_ENTRY *HashBuckets[ NUMBER_HASH_BUCKETS ];
    EX_PUSH_LOCK Lock;
    struct _DEVICE_MAP *DeviceMap;
    USHORT Reserved;
    USHORT SymbolicLinkUsageCount;
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;
typedef struct _OBJECT_CREATE_INFORMATION *POBJECT_CREATE_INFORMATION;;

typedef struct _OBJECT_HEADER {
    LONG PointerCount;
    union {
        LONG HandleCount;
        PVOID NextToFree;
    };
    POBJECT_TYPE Type;
    UCHAR NameInfoOffset;
    UCHAR HandleInfoOffset;
    UCHAR QuotaInfoOffset;
    UCHAR Flags;
    union {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PSECURITY_DESCRIPTOR SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;
typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
#if DBG
    ULONG Reserved2;
    LONG DbgDereferenceCount;
#ifdef _WIN64
    ULONG64  Reserved3;   // Win64 requires these structures to be 16 byte aligned.
#endif
#endif
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;
#define OBJECT_TO_OBJECT_HEADER( o ) \
    CONTAINING_RECORD( (o), OBJECT_HEADER, Body )
#define OBJECT_HEADER_TO_NAME_INFO( oh ) ((POBJECT_HEADER_NAME_INFO) \
    ((oh)->NameInfoOffset == 0 ? NULL : ((PCHAR)(oh) - (oh)->NameInfoOffset)))

#define OBJECT_HEADER_TO_CREATOR_INFO( oh ) ((POBJECT_HEADER_CREATOR_INFO) \
    (((oh)->Flags & OB_FLAG_CREATOR_INFO) == 0 ? NULL : ((PCHAR)(oh) - sizeof(OBJECT_HEADER_CREATOR_INFO))))

NTKERNELAPI
NTSTATUS
ObCreateObjectType(
    IN PUNICODE_STRING TypeName,
    IN POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    OUT POBJECT_TYPE *ObjectType
    );


NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN KPROCESSOR_MODE ProbeMode,
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE OwnershipMode,
    IN OUT PVOID ParseContext OPTIONAL,
    IN ULONG ObjectBodySize,
    IN ULONG PagedPoolCharge,
    IN ULONG NonPagedPoolCharge,
    OUT PVOID *Object
    );

//
// These inlines correct an issue where the compiler refetches
// the output object over and over again because it thinks its
// a possible alias for other stores.
//
FORCEINLINE
NTSTATUS
_ObCreateObject(
    IN KPROCESSOR_MODE ProbeMode,
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN KPROCESSOR_MODE OwnershipMode,
    IN OUT PVOID ParseContext OPTIONAL,
    IN ULONG ObjectBodySize,
    IN ULONG PagedPoolCharge,
    IN ULONG NonPagedPoolCharge,
    OUT PVOID *pObject
    )
{
    PVOID Object;
    NTSTATUS Status;

    Status = ObCreateObject (ProbeMode,
                             ObjectType,
                             ObjectAttributes,
                             OwnershipMode,
                             ParseContext,
                             ObjectBodySize,
                             PagedPoolCharge,
                             NonPagedPoolCharge,
                             &Object);
    *pObject = Object;
    return Status;
}

#define ObCreateObject _ObCreateObject


NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PVOID *NewObject OPTIONAL,
    OUT PHANDLE Handle OPTIONAL
    );

// end_nthal

NTKERNELAPI                                                     // ntddk wdm nthal ntifs
NTSTATUS                                                        // ntddk wdm nthal ntifs
ObReferenceObjectByHandle(                                      // ntddk wdm nthal ntifs
    IN HANDLE Handle,                                           // ntddk wdm nthal ntifs
    IN ACCESS_MASK DesiredAccess,                               // ntddk wdm nthal ntifs
    IN POBJECT_TYPE ObjectType OPTIONAL,                        // ntddk wdm nthal ntifs
    IN KPROCESSOR_MODE AccessMode,                              // ntddk wdm nthal ntifs
    OUT PVOID *Object,                                          // ntddk wdm nthal ntifs
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   // ntddk wdm nthal ntifs
    );                                                          // ntddk wdm nthal ntifs

FORCEINLINE
NTSTATUS
_ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *pObject,
    OUT POBJECT_HANDLE_INFORMATION pHandleInformation OPTIONAL
    )
{
    PVOID Object;
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle (Handle,
                                        DesiredAccess,
                                        ObjectType,
                                        AccessMode,
                                        &Object,
                                        pHandleInformation);
    *pObject = Object;
    return Status;
}

#define ObReferenceObjectByHandle _ObReferenceObjectByHandle

NTKERNELAPI
NTSTATUS
ObReferenceFileObjectForWrite(
    IN HANDLE Handle,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *FileObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE Handle
    );


NTKERNELAPI                                                     // ntifs
NTSTATUS                                                        // ntifs
ObOpenObjectByPointer(                                          // ntifs
    IN PVOID Object,                                            // ntifs
    IN ULONG HandleAttributes,                                  // ntifs
    IN PACCESS_STATE PassedAccessState OPTIONAL,                // ntifs
    IN ACCESS_MASK DesiredAccess OPTIONAL,                      // ntifs
    IN POBJECT_TYPE ObjectType OPTIONAL,                        // ntifs
    IN KPROCESSOR_MODE AccessMode,                              // ntifs
    OUT PHANDLE Handle                                          // ntifs
    );                                                          // ntifs

NTSTATUS
ObReferenceObjectByName(
    IN PUNICODE_STRING ObjectName,
    IN ULONG Attributes,
    IN PACCESS_STATE PassedAccessState OPTIONAL,
    IN ACCESS_MASK DesiredAccess OPTIONAL,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *Object
    );


NTKERNELAPI
BOOLEAN
ObFindHandleForObject(
    IN PEPROCESS Process,
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN POBJECT_HANDLE_INFORMATION MatchCriteria OPTIONAL,
    OUT PHANDLE Handle
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

#define ObDereferenceObject(a)                                     \
        ObfDereferenceObject(a)

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
LONG
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
LONG
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );

NTKERNELAPI
NTSTATUS
ObQueryNameString(
    IN PVOID Object,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

NTSTATUS
ObGetObjectSecurity(
    IN PVOID Object,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PBOOLEAN MemoryAllocated
    );

VOID
ObReleaseObjectSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN MemoryAllocated
    );

NTKERNELAPI
BOOLEAN
ObCheckCreateObjectAccess(
    IN PVOID DirectoryObject,
    IN ACCESS_MASK CreateAccess,
    IN PACCESS_STATE AccessState OPTIONAL,
    IN PUNICODE_STRING ComponentName,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PNTSTATUS AccessStatus
   );

NTKERNELAPI
BOOLEAN
ObCheckObjectAccess(
    IN PVOID Object,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN TypeMutexLocked,
    IN KPROCESSOR_MODE AccessMode,
    OUT PNTSTATUS AccessStatus
    );


NTKERNELAPI
NTSTATUS
ObAssignSecurity(
    IN PACCESS_STATE AccessState,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    );
NTSTATUS
ObSetSecurityObjectByPointer (
    IN PVOID Object,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
ObSetHandleAttributes (
    IN HANDLE Handle,
    IN POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
ObCloseHandle (
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );


NTKERNELAPI
NTSTATUS
ObSetSecurityDescriptorInfo(
    IN PVOID Object,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80



// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_wdm end_ntminiport


//
// Portable portion of HAL & HAL bus extender definitions for BUSHANDLER
// BusData for installed PCI buses.
//

typedef VOID
(*PciPin2Line) (
    IN struct _BUS_HANDLER  *BusHandler,
    IN struct _BUS_HANDLER  *RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

typedef VOID
(*PciLine2Pin) (
    IN struct _BUS_HANDLER  *BusHandler,
    IN struct _BUS_HANDLER  *RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

typedef VOID
(*PciReadWriteConfig) (
    IN struct _BUS_HANDLER *BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#define PCI_DATA_TAG            ' ICP'
#define PCI_DATA_VERSION        1

typedef struct _PCIBUSDATA {
    ULONG                   Tag;
    ULONG                   Version;
    PciReadWriteConfig      ReadConfig;
    PciReadWriteConfig      WriteConfig;
    PciPin2Line             Pin2Line;
    PciLine2Pin             Line2Pin;
    PCI_SLOT_NUMBER         ParentSlot;
    PVOID                   Reserved[4];
} PCIBUSDATA, *PPCIBUSDATA;

typedef ULONG (*PCI_READ_WRITE_CONFIG)(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef VOID (*PCI_PIN_TO_LINE)(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciData
    );

typedef VOID (*PCI_LINE_TO_PIN)(
    IN PVOID Context,
    IN PPCI_COMMON_CONFIG PciNewData,
    IN PPCI_COMMON_CONFIG PciOldData
    );

typedef struct _PCI_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard PCI bus interfaces
    //
    PCI_READ_WRITE_CONFIG ReadConfig;
    PCI_READ_WRITE_CONFIG WriteConfig;
    PCI_PIN_TO_LINE PinToLine;
    PCI_LINE_TO_PIN LineToPin;
} PCI_BUS_INTERFACE_STANDARD, *PPCI_BUS_INTERFACE_STANDARD;

#define PCI_BUS_INTERFACE_STANDARD_VERSION 1

// begin_wdm

#define PCI_DEVICE_PRESENT_INTERFACE_VERSION 1

//
// Flags for PCI_DEVICE_PRESENCE_PARAMETERS
//
#define PCI_USE_SUBSYSTEM_IDS   0x00000001
#define PCI_USE_REVISION        0x00000002
// The following flags are only valid for IsDevicePresentEx
#define PCI_USE_VENDEV_IDS      0x00000004
#define PCI_USE_CLASS_SUBCLASS  0x00000008
#define PCI_USE_PROGIF          0x00000010
#define PCI_USE_LOCAL_BUS       0x00000020
#define PCI_USE_LOCAL_DEVICE    0x00000040

//
// Search parameters structure for IsDevicePresentEx
//
typedef struct _PCI_DEVICE_PRESENCE_PARAMETERS {
    
    ULONG Size;
    ULONG Flags;

    USHORT VendorID;
    USHORT DeviceID;
    UCHAR RevisionID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    UCHAR BaseClass;
    UCHAR SubClass;
    UCHAR ProgIf;

} PCI_DEVICE_PRESENCE_PARAMETERS, *PPCI_DEVICE_PRESENCE_PARAMETERS;

typedef
BOOLEAN
(*PPCI_IS_DEVICE_PRESENT) (
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN UCHAR RevisionID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN ULONG Flags
);

typedef
BOOLEAN
(*PPCI_IS_DEVICE_PRESENT_EX) (
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // pci device info
    //
    PPCI_IS_DEVICE_PRESENT IsDevicePresent;
    
    PPCI_IS_DEVICE_PRESENT_EX IsDevicePresentEx;

} PCI_DEVICE_PRESENT_INTERFACE, *PPCI_DEVICE_PRESENT_INTERFACE;


//
//  Normal uncompressed Copy and Mdl Apis
//

NTKERNELAPI
BOOLEAN
FsRtlCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
BOOLEAN
FsRtlCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntifs

NTKERNELAPI
BOOLEAN
FsRtlMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    );

BOOLEAN
FsRtlMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    );

#define LEGAL_ANSI_CHARACTER_ARRAY        (*FsRtlLegalAnsiCharacterArray) 
#define NLS_OEM_LEAD_BYTE_INFO            (*NlsOemLeadByteInfo) 

extern UCHAR const* const LEGAL_ANSI_CHARACTER_ARRAY;
extern PUSHORT NLS_OEM_LEAD_BYTE_INFO;  // Lead byte info. for ACP

//
//  These following bit values are set in the FsRtlLegalDbcsCharacterArray
//

#define FSRTL_FAT_LEGAL         0x01
#define FSRTL_HPFS_LEGAL        0x02
#define FSRTL_NTFS_LEGAL        0x04
#define FSRTL_WILD_CHARACTER    0x08
#define FSRTL_OLE_LEGAL         0x10
#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)

//
//  The following macro is used to determine if an Ansi character is wild.
//

#define FsRtlIsAnsiCharacterWild(C) (                               \
    FsRtlTestAnsiCharacter((C), FALSE, FALSE, FSRTL_WILD_CHARACTER) \
)

//
//  The following macro is used to determine if an Ansi character is Fat legal.
//

#define FsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_FAT_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Hpfs legal.
//

#define FsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_HPFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Ntfs legal.
//

#define FsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is
//  legal in an Ntfs stream name
//

#define FsRtlIsAnsiCharacterLegalNtfsStream(C,WILD_OK) (                    \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_STREAM_LEGAL)   \
)

//
//  The following macro is used to determine if an Ansi character is legal,
//  according to the caller's specification.
//

#define FsRtlIsAnsiCharacterLegal(C,FLAGS) (          \
    FsRtlTestAnsiCharacter((C), TRUE, FALSE, (FLAGS)) \
)

//
//  The following macro is used to test attributes of an Ansi character,
//  according to the caller's specified flags.
//

#define FsRtlTestAnsiCharacter(C, DEFAULT_RET, WILD_OK, FLAGS) (            \
        ((SCHAR)(C) < 0) ? DEFAULT_RET :                                    \
                           FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)],         \
                                   (FLAGS) |                                \
                                   ((WILD_OK) ? FSRTL_WILD_CHARACTER : 0) ) \
)


//
//  The following two macros use global data defined in ntos\rtl\nlsdata.c
//
//  BOOLEAN
//  FsRtlIsLeadDbcsCharacter (
//      IN UCHAR DbcsCharacter
//      );
//
//  /*++
//
//  Routine Description:
//
//      This routine takes the first bytes of a Dbcs character and
//      returns whether it is a lead byte in the system code page.
//
//  Arguments:
//
//      DbcsCharacter - Supplies the input character being examined
//
//  Return Value:
//
//      BOOLEAN - TRUE if the input character is a dbcs lead and
//              FALSE otherwise
//
//  --*/
//
//

#define FsRtlIsLeadDbcsCharacter(DBCS_CHAR) (                      \
    (BOOLEAN)((UCHAR)(DBCS_CHAR) < 0x80 ? FALSE :                  \
              (NLS_MB_CODE_PAGE_TAG &&                             \
               (NLS_OEM_LEAD_BYTE_INFO[(UCHAR)(DBCS_CHAR)] != 0))) \
)

NTKERNELAPI
VOID
FsRtlDissectDbcs (
    IN ANSI_STRING InputName,
    OUT PANSI_STRING FirstPart,
    OUT PANSI_STRING RemainingPart
    );

NTKERNELAPI
BOOLEAN
FsRtlDoesDbcsContainWildCards (
    IN PANSI_STRING Name
    );

NTKERNELAPI
BOOLEAN
FsRtlIsDbcsInExpression (
    IN PANSI_STRING Expression,
    IN PANSI_STRING Name
    );

NTKERNELAPI
BOOLEAN
FsRtlIsFatDbcsLegal (
    IN ANSI_STRING DbcsName,
    IN BOOLEAN WildCardsPermissible,
    IN BOOLEAN PathNamePermissible,
    IN BOOLEAN LeadingBackslashPermissible
    );

NTKERNELAPI
NTSTATUS
LpcRequestPort(
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage
    );

NTSTATUS
LpcRequestWaitReplyPort(
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );

NTSTATUS
LpcRequestWaitReplyPortEx (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );

NTSTATUS
LpcDisconnectPort (
    IN PVOID Port
    );


extern POBJECT_TYPE *ExEventPairObjectType;
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *IoDriverObjectType;
extern POBJECT_TYPE *PsProcessType;
extern POBJECT_TYPE *PsThreadType;
extern POBJECT_TYPE *PsJobType;
extern POBJECT_TYPE *LpcPortObjectType;
extern POBJECT_TYPE *LpcWaitablePortObjectType;
extern POBJECT_TYPE MmSectionObjectType;

#ifdef __cplusplus
}    // extern "C"
#endif

#endif // _NTOSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\pchrexec.h ===
#ifndef PCHREXEC_H
#define PCHREXEC_H

#define ERRORREP_HANG_PIPENAME  L"\\\\.\\pipe\\PCHHangRepExecPipe"
#define ERRORREP_FAULT_PIPENAME L"\\\\.\\pipe\\PCHFaultRepExecPipe"
#define ERRORREP_PIPE_BUF_SIZE  8192 

/*
 * Data structure passed for a remote exec request
 *
 * NOTE: pointers are self relative
 *
 */

typedef enum tagEExecServStatus
{
    essErr = 0,
    essOk,
    essOkQueued,
} EExecServStatus;


// *** Note: the size of these structures must be divisible by sizeof(WCHAR)
//           or we'll get an alignment fault on ia64 (and other alignment 
//           sensitive processors)


typedef struct tagSPCHExecServGenericReply
{
    DWORD               cb;

    EExecServStatus     ess;
    DWORD               dwErr;

} SPCHExecServGenericReply;

typedef struct tagSPCHExecServHangRequest
{
    DWORD       cbTotal;
    DWORD       cbESR;
    DWORD       pidReqProcess;

    BOOL        fIs64bit;
    ULONG       ulSessionId;

    UINT64      wszEventName;
    DWORD       dwpidHung;
    DWORD       dwtidHung;
} SPCHExecServHangRequest;


// this structure MUST have the same initial 3 elements as SPCHExecServGenericReply
typedef struct tagSPCHExecServHangReply
{
    DWORD               cb;

    EExecServStatus     ess;
    DWORD               dwErr;

    // NOTE: The handle for hProcess is converted from the remove exec
    //       server into the requestors process using the pidReqProcess
    //       in the request.
    HANDLE              hProcess;
} SPCHExecServHangReply;

typedef struct tagSPCHExecServFaultRequest
{
    DWORD       cbTotal;
    DWORD       cbESR;
    DWORD       pidReqProcess;
    
    BOOL        fIs64bit;

    DWORD       thidFault;
    UINT64      pvFaultAddr;
    UINT64      wszExe;
    UINT64      pEP;
} SPCHExecServFaultRequest;

// this structure MUST have the same initial 3 elements as SPCHExecServGenericReply
typedef struct tagSPCHExecServFaultReply
{
    DWORD               cb;

    EExecServStatus     ess;
    DWORD               dwErr;

    // NOTE: The handle for hProcess is converted from the remove exec
    //       server into the requestors process using the pidReqProcess
    //       in the request.
    HANDLE              hProcess;

    // these point into data immediately following the struct
    UINT64              wszDir;
    UINT64              wszDumpName;
} SPCHExecServFaultReply;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\pencrypt.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pencrypt.c

Abstract:

    Helper functions to work with PID encryption in Setup

Author:

    Peter Wassmann (peterw) 12-Dec-2001

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#pragma once

HRESULT PrepareEncryptedPIDA(LPSTR szPID, UINT uiDays, LPSTR *szOut);
HRESULT PrepareEncryptedPIDW(LPWSTR szPID, UINT uiDays, LPWSTR *szOutData);
HRESULT ValidateEncryptedPIDW(LPWSTR szPID, LPWSTR *szOutData);
HRESULT ValidateEncryptedPIDA(LPSTR PID, LPSTR *szOutData);

//
// Function name macros
//

#ifdef UNICODE
#define PrepareEncryptedPID         PrepareEncryptedPIDW
#define ValidateEncryptedPID        ValidateEncryptedPIDW
#else
#define PrepareEncryptedPID         PrepareEncryptedPIDA
#define ValidateEncryptedPID        ValidateEncryptedPIDA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ocmgrlib.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ocmgrlib.h

Abstract:

    Header file for Optional Component Manager common library.

Author:

    Ted Miller (tedm) 13-Sep-1996

Revision History:

--*/


//
// debugging text output flag.  this can go away once we figure out a way to log information 
// when called from sysocmgr other than popping up UI in the user's face
//
#define OcErrTrace		0x20000000


//
// Default icon index, in case we couldn't find the specified one or
// a component's INF doesn't specify one. It's a little diamond in
// a generic gray.
//
#define DEFAULT_ICON_INDEX  11

//
// Maximum string lengths.
//
#define MAXOCDESC           150
#define MAXOCTIP            200
#define MAXOCIFLAG          512

//
// Maximum number of needs (subcomps that are needed by a subcomp).
//
//#define MAX_NEEDS           10

//
// Indices for selection states.
//
#define SELSTATE_NO         0
#define SELSTATE_PARTIAL    1
#define SELSTATE_YES        2
#define SELSTATE_INIT       666

//
// Structure used with OcCreateOcPage
//
typedef struct _OC_PAGE_CONTROLS {
    //
    // Dialog template info.
    //
    HMODULE TemplateModule;
    LPCTSTR TemplateResource;

    //
    // Ids for various controls.
    //
    UINT ListBox;
    UINT DetailsButton;
    UINT TipText;
    UINT ResetButton;
    UINT InstalledCountText;
    UINT SpaceNeededText;
    UINT SpaceAvailableText;
    UINT InstructionsText;
    UINT HeaderText;
    UINT SubheaderText;
    UINT ComponentHeaderText;

} OC_PAGE_CONTROLS, *POC_PAGE_CONTROLS;

//
// Structure used with OcCreateSetupPage
//
typedef struct _SETUP_PAGE_CONTROLS {
    //
    // Dialog template info.
    //
    HMODULE TemplateModule;
    LPCTSTR TemplateResource;

    //
    // Progress bar and progress text.
    //
    UINT ProgressBar;
    UINT ProgressLabel;
    UINT ProgressText;

    //
    // Animation for external install program
    //
    UINT AnimationControl;
    UINT AnimationResource;
    BOOL ForceExternalProgressIndicator;

    BOOL AllowCancel;

    // title and description

    UINT HeaderText;
    UINT SubheaderText;

} SETUP_PAGE_CONTROLS, *PSETUP_PAGE_CONTROLS;

//
// Flags for OcInitialize
//
#define OCINIT_FORCENEWINF      0x00000001
#define OCINIT_KILLSUBCOMPS     0x00000002
#define OCINIT_RUNQUIET         0x00000004
#define OCINIT_LANGUAGEAWARE    0x00000008

// for calling pOcQueryOrSetNewInf and OcComponentState

typedef enum {
    infQuery = 0,
    infSet,
    infReset
};

//
// Routines that must be provided by whoever links to
// the OC Manager common library. These are the routines that 'cement'
// the OC Manager into a particular environment.
//
typedef
VOID
(WINAPI *POC_FILL_IN_SETUP_DATA_PROC_A)(
    OUT PSETUP_DATAA SetupData
    );

typedef
VOID
(WINAPI *POC_FILL_IN_SETUP_DATA_PROC_W)(
    OUT PSETUP_DATAW SetupData
    );

typedef
INT
(WINAPIV *POC_LOG_ERROR)(
    IN OcErrorLevel Level,
    IN LPCTSTR      FormatString,
    ...
    );

typedef
VOID
(WINAPI *POC_SET_REBOOT_PROC)(
    VOID
    );

typedef
HWND 
(WINAPI *POC_SHOWHIDEWIZARDPAGE)(
    IN BOOL bShow
    );

typedef
LRESULT
(WINAPI *POC_BILLBOARD_PROGRESS_CALLBACK)(
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    );

typedef 
VOID
(WINAPI *POC_BILLBOARD_SET_PROGRESS_TEXT_W)(
    IN PWSTR Text
    );

typedef 
VOID
(WINAPI *POC_BILLBOARD_SET_PROGRESS_TEXT_A)(
    IN PSTR Text
    );

typedef 
VOID
(WINAPI *POC_SETUP_PERF_DATA)(
    IN PWSTR FileName,
    IN ULONG LineNumber,
    IN PWSTR TagStr,
    IN PWSTR FormatStr,
    ...
    );

typedef struct _OCM_CLIENT_CALLBACKSA {
    //
    // Routine to fill in the setup data structure that provides info
    // about the environment in which the OC Manager is running.
    //
    POC_FILL_IN_SETUP_DATA_PROC_A FillInSetupDataA;

    //
    // Routine to log an error.
    //
    POC_LOG_ERROR LogError;

    //
    // Routine to indicate need to reboot
    //
    POC_SET_REBOOT_PROC SetReboot;

    //
    // Routine to tell the wizard to show or hide
    // Only has effect if the billboard is shown
    //
    POC_SHOWHIDEWIZARDPAGE ShowHideWizardPage;

    //
    // Routine to call into to the the progress feedback
    // to the billboard.
    //
    POC_BILLBOARD_PROGRESS_CALLBACK BillboardProgressCallback;

    // 
    // Routine which tells setup what string to display for the progress bar.
    //
    POC_BILLBOARD_SET_PROGRESS_TEXT_A BillBoardSetProgressText;

    POC_SETUP_PERF_DATA SetupPerfData;
} OCM_CLIENT_CALLBACKSA, *POCM_CLIENT_CALLBACKSA;

typedef struct _OCM_CLIENT_CALLBACKSW {
    //
    // Routine to fill in the setup data structure that provides info
    // about the environment in which the OC Manager is running.
    //
    POC_FILL_IN_SETUP_DATA_PROC_A FillInSetupDataA;

    //
    // Routine to log an error.
    //
    POC_LOG_ERROR LogError;

    //
    // Routine to indicate need to reboot
    //
    POC_SET_REBOOT_PROC SetReboot;

    POC_FILL_IN_SETUP_DATA_PROC_W FillInSetupDataW;

    //
    // Routine to tell the wizard to show or hide
    // Only has effect if the billboard is shown
    //
    POC_SHOWHIDEWIZARDPAGE ShowHideWizardPage;

    //
    // Routine to call into to the the progress feedback
    // to the billboard.
    //
    POC_BILLBOARD_PROGRESS_CALLBACK BillboardProgressCallback;

    // 
    // Routine which tells setup what string to display for the progress bar.
    //
    POC_BILLBOARD_SET_PROGRESS_TEXT_W BillBoardSetProgressText;

    POC_SETUP_PERF_DATA SetupPerfData;


} OCM_CLIENT_CALLBACKSW, *POCM_CLIENT_CALLBACKSW;

#ifndef UNICODE // ansi
    typedef OCM_CLIENT_CALLBACKSA  OCM_CLIENT_CALLBACKS;
    typedef POCM_CLIENT_CALLBACKSA POCM_CLIENT_CALLBACKS;
#else // unicode
    typedef OCM_CLIENT_CALLBACKSW  OCM_CLIENT_CALLBACKS;
    typedef POCM_CLIENT_CALLBACKSW POCM_CLIENT_CALLBACKS;
#endif    

//
// Routines that are provided by the OC Manager common library.
//
PVOID
OcInitialize(
    IN  POCM_CLIENT_CALLBACKS Callbacks,
    IN  LPCTSTR               MasterOcInfName,
    IN  UINT                  Flags,
    OUT PBOOL                 ShowError,
    IN  PVOID                 Log
    );

VOID
OcTerminate(
    IN OUT PVOID *OcManagerContext
    );

UINT
OcGetWizardPages(
    IN  PVOID                OcManagerContext,
    OUT PSETUP_REQUEST_PAGES Pages[WizPagesTypeMax]
    );

HPROPSHEETPAGE
OcCreateOcPage(
    IN PVOID             OcManagerContext,
    IN POC_PAGE_CONTROLS WizardPageControlsInfo,
    IN POC_PAGE_CONTROLS DetailsPageControlsInfo
    );

HPROPSHEETPAGE
OcCreateSetupPage(
    IN PVOID                OcManagerContext,
    IN PSETUP_PAGE_CONTROLS ControlsInfo
    );

VOID
OcRememberWizardDialogHandle(
    IN PVOID OcManagerContext,
    IN HWND  DialogHandle
    );

BOOL
OcSubComponentsPresent(
    IN PVOID OcManagerContext
   );

UINT
OcComponentState(
    LPCTSTR component,
    UINT    operation,
    DWORD  *val
    );

#define OcSetComponentState(a,b) OcComponentState(a,infSet,b)
#define OcGetComponentState(a,b) OcComponentState(a,infQuery,b)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\pciintrf.h ===
/*++

Module Name:

    pciintrf.h

Abstract:

    Contains interface GUIDs and structures for non-wdm modules that
    interface directly with the PCI driver via the PNP QUERY_INTERFACE
    mechanism.

Author:

    Peter Johnston (peterj) November 1997

Revision History:

--*/


DEFINE_GUID(GUID_PCI_CARDBUS_INTERFACE_PRIVATE, 0xcca82f31, 0x54d6, 0x11d1, 0x82, 0x24, 0x00, 0xa0, 0xc9, 0x32, 0x43, 0x85);
DEFINE_GUID(GUID_PCI_PME_INTERFACE, 0xaac7e6ac, 0xbb0b, 0x11d2, 0xb4, 0x84, 0x00, 0xc0, 0x4f, 0x72, 0xde, 0x8b);
DEFINE_GUID(GUID_PCI_NATIVE_IDE_INTERFACE, 0x98f37d63, 0x42ae, 0x4ad9, 0x8c, 0x36, 0x93, 0x2d, 0x28, 0x38, 0x3d, 0xf8);

#ifndef _PCIINTRF_
#define _PCIINTRF_

//
// CardBus
//

#define PCI_CB_INTRF_VERSION    1

typedef
NTSTATUS
(*PCARDBUSADD)(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID * DeviceContext
    );

typedef
NTSTATUS
(*PCARDBUSDELETE)(
    IN PVOID DeviceContext
    );

typedef
NTSTATUS
(*PCARDBUSPCIDISPATCH)(
    IN PVOID DeviceContext,
    IN PIRP  Irp
    );

typedef
NTSTATUS
(*PCARDBUSGETLOCATION)(
    IN PDEVICE_OBJECT DeviceObject,
    OUT UCHAR *Bus,
    OUT UCHAR *DeviceNumber,
    OUT UCHAR *FunctionNumber,
    OUT BOOLEAN *OnDebugPath
    );


typedef struct _PCI_CARDBUS_INTERFACE_PRIVATE {

    //
    // generic interface header
    //

    USHORT Size;
    USHORT Version;
    PVOID Context;                      // not actually used in this interface
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Pci data.
    //

    PDRIVER_OBJECT DriverObject;        // returned ptr to PCI driver

    //
    // Pci-Cardbus private interfaces
    //

    PCARDBUSADD AddCardBus;
    PCARDBUSDELETE DeleteCardBus;
    PCARDBUSPCIDISPATCH DispatchPnp;
    PCARDBUSGETLOCATION GetLocation;


} PCI_CARDBUS_INTERFACE_PRIVATE, *PPCI_CARDBUS_INTERFACE_PRIVATE;

typedef
VOID
(*PPME_GET_INFORMATION) (
    IN  PDEVICE_OBJECT  Pdo,
    OUT PBOOLEAN        PmeCapable,
    OUT PBOOLEAN        PmeStatus,
    OUT PBOOLEAN        PmeEnable
    );

typedef
VOID
(*PPME_CLEAR_PME_STATUS) (
    IN  PDEVICE_OBJECT  Pdo
    );

typedef
VOID
(*PPME_SET_PME_ENABLE) (
    IN  PDEVICE_OBJECT  Pdo,
    IN  BOOLEAN         PmeEnable
    );

typedef struct _PCI_PME_INTERFACE {

    //
    // generic interface header
    //
    USHORT              Size;
    USHORT          Version;
    PVOID           Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;

    //
    // PME Signal interfaces
    //
    PPME_GET_INFORMATION    GetPmeInformation;
    PPME_CLEAR_PME_STATUS   ClearPmeStatus;
    PPME_SET_PME_ENABLE     UpdateEnable;

} PCI_PME_INTERFACE, *PPCI_PME_INTERFACE;

// Some well-known interface versions supported by the PCI Bus Driver

#define PCI_PME_INTRF_STANDARD_VER 1

//
// 
//

typedef
VOID
(*PPCI_IDE_IOSPACE_INTERRUPT_CONTROL)(
    IN PVOID Context,
    IN BOOLEAN Enable
    );

/*++


Routine Description:

    Controls the enabling and disabling of native mode PCI IDE controllers
    IoSpaceEnable bits which on some controllers (currently Intel ICH3)
    will mask off interrupt generation and this prevent the system from 
    crashing...
    
    This should be called during AddDevice and the calling it modifies 
    PCIs behaviour to not enable IO space during START_DEVICE for the device.
    This function the allows the requester to enable IO space when appropriate.
   
    
Arguments:

    Context - Context from the PCI_NATIVE_IDE_INTERFACE
    
    Enable - If TRUE then set the IoSpaceEnable bit in the command register,
             otherwise disable it.


Return Value:

    None - if this operation fails we have aleady bugchecked in the PCI driver

--*/

typedef struct _PCI_NATIVE_IDE_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Native IDE methods
    //
    PPCI_IDE_IOSPACE_INTERRUPT_CONTROL InterruptControl;

} PCI_NATIVE_IDE_INTERFACE, *PPCI_NATIVE_IDE_INTERFACE;

#define PCI_NATIVE_IDE_INTERFACE_VERSION    1

#endif // _PCIINTRF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\oscpkt.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    oscpkt.h

Abstract:

    This file describes OSchooser packets.

Author:

    Adam Barr (adamba) 25-July-1997

Revision History:

--*/

#ifndef _OSCPKT_
#define _OSCPKT_

//
// Defines NTLMSSP_MESSAGE_SIGNATURE_SIZE
//

#include <ntlmsp.h>

//
// The 4 byte signatures for our packets. They all start with hex 81
// (for messages to the server) or hex 82 (for messages from the server).
//

static const PCHAR NegotiateSignature = "\x81" "NEG";
static const PCHAR ChallengeSignature = "\x82" "CHL";
static const PCHAR AuthenticateSignature = "\x81" "AUT";
static const PCHAR AuthenticateFlippedSignature = "\x81" "AU2";
static const PCHAR ResultSignature = "\x82" "RES";
static const PCHAR RequestUnsignedSignature = "\x81" "RQU";
static const PCHAR ResponseUnsignedSignature = "\x82" "RSU";
static const PCHAR RequestSignedSignature = "\x81" "REQ";
static const PCHAR ResponseSignedSignature = "\x82" "RSP";
static const PCHAR ErrorSignedSignature = "\x82" "ERR";
static const PCHAR UnrecognizedClientSignature = "\x82" "UNR";
static const PCHAR LogoffSignature = "\x81" "OFF";
static const PCHAR NegativeAckSignature = "\x82" "NAK";
static const PCHAR NetcardRequestSignature = "\x81" "NCQ";
static const PCHAR NetcardResponseSignature = "\x82" "NCR";
static const PCHAR NetcardErrorSignature = "\x82" "NCE";
static const PCHAR HalRequestSignature = "\x81" "HLQ";
static const PCHAR HalResponseSignature = "\x82" "HLR";
static const PCHAR SetupRequestSignature = "\x81" "SPQ";
static const PCHAR SetupResponseSignature = "\x82" "SPS";


//
// Format for packets we exchange during login.
//

typedef struct _LOGIN_PACKET {
    UCHAR Signature[4];   // "AUT", "CHL", etc.
    ULONG Length;         // of the rest of the packet.
    union {
        UCHAR Data[1];    // the NTLMSSP buffer.
        ULONG Status;     // status for result packets.
    };
} LOGIN_PACKET, *PLOGIN_PACKET;

#define LOGIN_PACKET_DATA_OFFSET  FIELD_OFFSET(LOGIN_PACKET, Data[0])

//
// Format for signed packets.
//

typedef struct _SIGNED_PACKET {
    UCHAR Signature[4];   // "REQ", "RSP".
    ULONG Length;         // of the rest of the packet (starting after this field).
    ULONG SequenceNumber;
    USHORT FragmentNumber; // which fragment in a message this is
    USHORT FragmentTotal; // total number of fragments in this message
    ULONG SignLength;
    UCHAR Sign[NTLMSSP_MESSAGE_SIGNATURE_SIZE];
    UCHAR Data[1];        // the data.
} SIGNED_PACKET, *PSIGNED_PACKET;

#define SIGNED_PACKET_DATA_OFFSET  FIELD_OFFSET(SIGNED_PACKET, Data[0])
#define SIGNED_PACKET_EMPTY_LENGTH  (FIELD_OFFSET(SIGNED_PACKET, Data[0]) - FIELD_OFFSET(SIGNED_PACKET, Length) - sizeof(ULONG))
#define SIGNED_PACKET_ERROR_LENGTH  (FIELD_OFFSET(SIGNED_PACKET, SequenceNumber) + sizeof(ULONG))

//
// Format for subsequent fragments of signed packets -- same as SIGNED_PACKET
// except without the sign.
//

typedef struct _FRAGMENT_PACKET {
    UCHAR Signature[4];   // "RSP".
    ULONG Length;         // of the rest of the packet (starting after this field).
    ULONG SequenceNumber;
    USHORT FragmentNumber; // which fragment in a message this is
    USHORT FragmentTotal; // total number of fragments in this message
    UCHAR Data[1];        // the data.
} FRAGMENT_PACKET, *PFRAGMENT_PACKET;

#define FRAGMENT_PACKET_DATA_OFFSET  FIELD_OFFSET(FRAGMENT_PACKET, Data[0])
#define FRAGMENT_PACKET_EMPTY_LENGTH  (FIELD_OFFSET(FRAGMENT_PACKET, Data[0]) - FIELD_OFFSET(FRAGMENT_PACKET, Length) - sizeof(ULONG))


//
// These are definitions for RebootParameter inside the CREATE_DATA structure.  They are used
// to pass specific instructions and/or options for the next reboot.
//
#define OSC_REBOOT_COMMAND_CONSOLE_ONLY                       0x1  // This means that the CREATE_DATA is a launch of a command console.
#define OSC_REBOOT_ASR                                        0x2  // This means that the CREATE_DATA is a launch of ASR.

//
// Structure that goes in the Data section of a signed packet for
// a create account response.
//
#define OSC_CREATE_DATA_VERSION 1

typedef struct _CREATE_DATA {
    UCHAR Id[4];      // Contains "ACCT", where a normal screen has "NAME"
    ULONG VersionNumber;
    ULONG RebootParameter;
    UCHAR Sid[28];
    UCHAR Domain[32];
    UCHAR Name[32];
    UCHAR Password[32];
    ULONG UnicodePasswordLength;  // in bytes
    WCHAR UnicodePassword[32];
    UCHAR Padding[24];
    UCHAR MachineType[6];  // 'i386\0' or 'Alpha\0'
    UCHAR NextBootfile[128];
    UCHAR SifFile[128];
} CREATE_DATA, *PCREATE_DATA;

//
// The maximum length of a screen name
//

#define MAX_SCREEN_NAME_LENGTH  32

//
// The maximum number of flip servers we handle
//

#define MAX_FLIP_SERVER_COUNT   8


//
// This is the structure that is sent to the server to get information
// about a card. It roughly corresponds to the PXENV_UNDI_GET_NIC_TYPE
// structure, but is redefined here to make sure that it won't change.
//

typedef struct _NET_CARD_INFO {
    ULONG NicType;  // 2=PCI, 3=PnP
    union{
        struct{
            USHORT Vendor_ID;
            USHORT Dev_ID;
            UCHAR Base_Class;
            UCHAR Sub_Class;
            UCHAR Prog_Intf;
            UCHAR Rev;
            USHORT BusDevFunc;
            USHORT Pad1;
            ULONG Subsys_ID;
        }pci;
        struct{
            ULONG EISA_Dev_ID;
            UCHAR Base_Class;
            UCHAR Sub_Class;
            UCHAR Prog_Intf;
            UCHAR Pad2;
            USHORT CardSelNum;
            USHORT Pad3;
        }pnp;
    };

} NET_CARD_INFO, * PNET_CARD_INFO;

//
// Packets we exchange with the server.
//

#define OSCPKT_NETCARD_REQUEST_VERSION 2

typedef struct _NETCARD_REQUEST_PACKET {
    UCHAR Signature[4];   // "NCQ".
    ULONG Length;         // of the rest of the packet (starting after this field).
    ULONG Version;        // set to OSCPKT_NETCARD_REQUEST_VERSION
    ULONG Architecture;   // See NetPc spec for definitions for x86, Alpha, etc.
    UCHAR Guid[16];       // Guid of the NetPc
    NET_CARD_INFO CardInfo;
    USHORT SetupDirectoryLength;
#if defined(REMOTE_BOOT)
    ULONG FileCheckAndCopy;// Should BINL check for this netcard and copy if necessary
    USHORT DriverDirectoryLength;
    UCHAR  DriverDirectoryPath[ 1 ];  // only sent if FileCheckAndCopy is TRUE
#endif

    // if REMOTE_BOOT is defined, the SetupDirectoryPath simply follows
    // DriverDirectoryPath

    UCHAR  SetupDirectoryPath[ 1 ];
} NETCARD_REQUEST_PACKET, * PNETCARD_REQUEST_PACKET;

typedef struct _NETCARD_RESPONSE_PACKET {
    UCHAR Signature[4];   // "NCR" or "NCE"
    ULONG Length;         // of the rest of the packet (starting after this field).
    ULONG Status;         // if not SUCCESS, the packet ends here.
    ULONG Version;        // currently 1

    //
    //  these are offsets within the packet where the associated string starts
    //  if the length is zero, the value is not present.
    //

    ULONG HardwareIdOffset;     // string is in unicode, null terminated
    ULONG DriverNameOffset;     // string is in unicode, null terminated
    ULONG ServiceNameOffset;    // string is in unicode, null terminated
    ULONG RegistryLength;
    ULONG RegistryOffset;       // string is in ansi, length of RegistryLength

} NETCARD_RESPONSE_PACKET, * PNETCARD_RESPONSE_PACKET;

#define NETCARD_RESPONSE_NO_REGISTRY_LENGTH  (FIELD_OFFSET(NETCARD_RESPONSE_PACKET, Registry[0]) - FIELD_OFFSET(NETCARD_RESPONSE_PACKET, Length) - sizeof(ULONG))

#define MAX_HAL_NAME_LENGTH 30 // Keep in sync with definition in setupblk.h

typedef struct _HAL_REQUEST_PACKET {
    UCHAR Signature[4];   // "HLQ".
    ULONG Length;         // of the rest of the packet (starting after this field).
    UCHAR Guid[16];       // Ugly, but defn of Guid will not change anytime soon...
    ULONG GuidLength;     // number of bytes in Guid that are valid.
    CHAR HalName[MAX_HAL_NAME_LENGTH + 1];
} HAL_REQUEST_PACKET, * PHAL_REQUEST_PACKET;

typedef struct _HAL_RESPONSE_PACKET {
    UCHAR Signature[4];   // "NCR" or "NCE"
    ULONG Length;         // of the rest of the packet (starting after this field).
    NTSTATUS Status;      // if not SUCCESS, the packet ends here.
} HAL_RESPONSE_PACKET, * PHAL_RESPONSE_PACKET;


#define OSC_ADMIN_PASSWORD_LEN     64
#define TFTP_RESTART_BLOCK_VERSION 2

typedef struct _TFTP_RESTART_BLOCK_V1 {
    CHAR User[64];
    CHAR Domain[64];
    CHAR Password[64];
    CHAR SifFile[128];
    CHAR RebootFile[128];
    ULONGLONG RebootParameter;
    ULONG Checksum;
    ULONG Tag;
} TFTP_RESTART_BLOCK_V1, *PTFTP_RESTART_BLOCK_V1;


//
// N.B.  The TFTP_RESTART_BLOCK_V1 structure members must be properly aligned
// working backwards.  So make sure there isn't any problem packing the 
// structure.
//
// The structure itself will be placed in memory such that the TFTP_RESTART_BLOCK_V1 will
// be on a mod-8 boundary.  This structure is used by win2k clients.
//
// All offsets from AdministratorPassword on down MUST stay in order and in alignment
// to allow WinXP Beta2 loaders to work.  If you add any items, make sure you place
// them at the top and add/use Filler fields to keep alignment correct.
//
typedef struct _TFTP_RESTART_BLOCK {
    ULONG Filler1;                                      // mod-8
    ULONG HeadlessTerminalType;                         // mod-4
    CHAR  AdministratorPassword[OSC_ADMIN_PASSWORD_LEN];// mod-8  Don't change the alignment from here down! 
    ULONG HeadlessPortNumber;                           // mod-8
    ULONG HeadlessParity;                               // mod-4
    ULONG HeadlessBaudRate;                             // mod-8
    ULONG HeadlessStopBits;                             // mod-4
    ULONG HeadlessUsedBiosSettings;                     // mod-8
    ULONG HeadlessPciDeviceId;                          // mod-4
    ULONG HeadlessPciVendorId;                          // mod-8
    ULONG HeadlessPciBusNumber;                         // mod-4
    ULONG HeadlessPciSlotNumber;                        // mod-8
    ULONG HeadlessPciFunctionNumber;                    // mod-4
    ULONG HeadlessPciFlags;                             // mod-8
    PUCHAR HeadlessPortAddress;                         // mod-4
    ULONG TftpRestartBlockVersion;                      // mod-8
    ULONG NewCheckSumLength;                            // mod-4
    ULONG NewCheckSum;                                  // mod-8 address.
    TFTP_RESTART_BLOCK_V1 RestartBlockV1;               // this will start on a mod-8 address.
} TFTP_RESTART_BLOCK, *PTFTP_RESTART_BLOCK;





//
// Packet used by textmode setup for requests and responses
//
typedef struct _SPUDP_PACKET {
    UCHAR Signature[4];   // "SPQ", "SPS".
    ULONG Length;         // of the rest of the packet (starting after this field).
    ULONG RequestType;    // Specific request needed.
    NTSTATUS Status;      // Status of the operation (used in response packets)
    ULONG SequenceNumber;
    USHORT FragmentNumber; // which fragment in a message this is
    USHORT FragmentTotal; // total number of fragments in this message
    UCHAR Data[1];        // the data.
} SPUDP_PACKET, *PSPUDP_PACKET;

#define SPUDP_PACKET_DATA_OFFSET  FIELD_OFFSET(SPUDP_PACKET, Data[0])
#define SPUDP_PACKET_EMPTY_LENGTH  (FIELD_OFFSET(SPUDP_PACKET, Data[0]) - FIELD_OFFSET(SPUDP_PACKET, Length) - sizeof(ULONG))

typedef struct _SP_NETCARD_INFO_REQ {
    ULONG Version;        // currently 0
    ULONG Architecture;   // See NetPc spec for definitions for x86, Alpha, etc.
    NET_CARD_INFO CardInfo;
    WCHAR SetupPath[1];
} SP_NETCARD_INFO_REQ, *PSP_NETCARD_INFO_REQ;

typedef struct _SP_NETCARD_INFO_RSP {
    ULONG cFiles;           // Count of the number of source/destination pairs below.
    WCHAR MultiSzFiles[1];
} SP_NETCARD_INFO_RSP, *PSP_NETCARD_INFO_RSP;

#endif // _OSCPKT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntwmi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntwmi.h

Abstract:

    definitions for WMI Flags and Event Id's

Author:

    Stephen Hsiao

Environment:

    Kernel and User modes

Revision History:


--*/

#ifndef _NTWMI_
#define _NTWMI_

#ifndef ETW_WOW6432

#include <evntrace.h>

// Alignment macros
#define DEFAULT_TRACE_ALIGNMENT 8              // 8 byte alignment
#define ALIGN_TO_POWER2( x, n ) (((ULONG)(x) + ((n)-1)) & ~((ULONG)(n)-1))

//
// The predefined event groups or families for NT subsystems
//

#define EVENT_TRACE_GROUP_HEADER               0x0000
#define EVENT_TRACE_GROUP_IO                   0x0100
#define EVENT_TRACE_GROUP_MEMORY               0x0200
#define EVENT_TRACE_GROUP_PROCESS              0x0300
#define EVENT_TRACE_GROUP_FILE                 0x0400
#define EVENT_TRACE_GROUP_THREAD               0x0500
#define EVENT_TRACE_GROUP_TCPIP                0x0600
#define EVENT_TRACE_GROUP_IPXSPX               0x0700
#define EVENT_TRACE_GROUP_UDPIP                0x0800
#define EVENT_TRACE_GROUP_REGISTRY             0x0900
#define EVENT_TRACE_GROUP_DBGPRINT             0x0A00
#define EVENT_TRACE_GROUP_CONFIG               0x0B00

#define EVENT_TRACE_GROUP_POOL                 0x0E00
#define EVENT_TRACE_GROUP_PERFINFO             0x0F00
#define EVENT_TRACE_GROUP_HEAP                 0x1000
#define EVENT_TRACE_GROUP_OBJECT               0x1100
#define EVENT_TRACE_GROUP_POWER                0x1200
#define EVENT_TRACE_GROUP_MODBOUND             0x1300
#define EVENT_TRACE_GROUP_TBD                  0x1400
#define EVENT_TRACE_GROUP_DPC                  0x1500
#define EVENT_TRACE_GROUP_GDI                  0x1600
#define EVENT_TRACE_GROUP_CRITSEC              0x1700

//
// The highest order bit of a data block is set if trace, WNODE otherwise
//
#define TRACE_HEADER_FLAG                   0x80000000

// Header type for tracing messages
// | Marker(8) | Reserved(8)  | Size(16) | MessageNumber(16) | Flags(16)
#define TRACE_MESSAGE                       0x10000000

// | MARKER(16) | SIZE (16)   | ULONG32        |
#define TRACE_HEADER_ULONG32                0xA0000000

// | MARKER(16) | SIZE (16)   | ULONG 32       | TIME_STAMP ...
#define TRACE_HEADER_ULONG32_TIME           0xB0000000

//
// The second bit is set if the trace is used by PM & CP (fixed headers)
// If not, the data block is used by for finer data for performance analysis
//
#define TRACE_HEADER_EVENT_TRACE            0x40000000
//
// If set, the data block is SYSTEM_TRACE_HEADER
//
#define TRACE_HEADER_ENUM_MASK              0x00FF0000

//
// The following are various header type
//
#define TRACE_HEADER_TYPE_SYSTEM32          1
#define TRACE_HEADER_TYPE_SYSTEM64          2
#define TRACE_HEADER_TYPE_FULL_HEADER       10
#define TRACE_HEADER_TYPE_INSTANCE          11
#define TRACE_HEADER_TYPE_TIMED             12
#define TRACE_HEADER_TYPE_ULONG32           13
#define TRACE_HEADER_TYPE_WNODE_HEADER      14
#define TRACE_HEADER_TYPE_MESSAGE           15
#define TRACE_HEADER_TYPE_PERFINFO32        16
#define TRACE_HEADER_TYPE_PERFINFO64        17

#define SYSTEM_TRACE_VERSION                 1

#ifdef _WIN64
#define PERFINFO_TRACE_MARKER     TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                    | (TRACE_HEADER_TYPE_PERFINFO64 << 16) | SYSTEM_TRACE_VERSION

#define SYSTEM_TRACE_MARKER     TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                    | (TRACE_HEADER_TYPE_SYSTEM64 << 16) | SYSTEM_TRACE_VERSION
#else
#define PERFINFO_TRACE_MARKER     TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                    | (TRACE_HEADER_TYPE_PERFINFO32 << 16) | SYSTEM_TRACE_VERSION

#define SYSTEM_TRACE_MARKER     TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                    | (TRACE_HEADER_TYPE_SYSTEM32 << 16) | SYSTEM_TRACE_VERSION
#endif

//
// Support a maximum of 64 logger instances. One is reserved for the kernel.
#define MAXLOGGERS                            64

//
// Set of Internal Flags passed to the Logger via ClientContext during StartTrace
//

#define EVENT_TRACE_CLOCK_RAW           0x00000000  // Use Raw timestamp
#define EVENT_TRACE_CLOCK_PERFCOUNTER   0x00000001  // Use HighPerfClock (Default)
#define EVENT_TRACE_CLOCK_SYSTEMTIME    0x00000002  // Use SystemTime
#define EVENT_TRACE_CLOCK_CPUCYCLE      0x00000003  // Use CPU cycle counter

// begin_wmikm
//
// Public routines to break down the Loggerhandle
//
#define KERNEL_LOGGER_ID                      0xFFFF    // USHORT only

typedef struct _TRACE_ENABLE_CONTEXT {
    USHORT  LoggerId;           // Actual Id of the logger
    UCHAR   Level;              // Enable level passed by control caller
    UCHAR   InternalFlag;       // Reserved
    ULONG   EnableFlags;        // Enable flags passed by control caller
} TRACE_ENABLE_CONTEXT, *PTRACE_ENABLE_CONTEXT;


#define WmiGetLoggerId(LoggerContext) \
    (((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->LoggerId == \
        (USHORT)KERNEL_LOGGER_ID) ? \
        KERNEL_LOGGER_ID : \
        ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->LoggerId

#define WmiGetLoggerEnableFlags(LoggerContext) \
   ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->EnableFlags
#define WmiGetLoggerEnableLevel(LoggerContext) \
    ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->Level

#define WmiSetLoggerId(Id, Context) \
     (((PTRACE_ENABLE_CONTEXT)Context)->LoggerId = (Id  ? \
                           (USHORT)Id: (USHORT)KERNEL_LOGGER_ID));

// end_wmikm

//
// NOTE: The following should not overlap with other bits in the LogFileMode
// or LoggerMode defined in evntrace.h. Placed here since it is for internal
// use only.
//

#define EVENT_TRACE_KD_FILTER_MODE          0x00080000  // KD_FILTER

//
// see evntrace.h for pre-defined generic event types (0-10)
//

typedef struct _WMI_TRACE_PACKET {   // must be ULONG!!
    USHORT  Size;
    union{
        USHORT  HookId;
        struct {
            UCHAR   Type;
            UCHAR   Group;
        };
    };
} WMI_TRACE_PACKET, *PWMI_TRACE_PACKET;

typedef struct _WMI_CLIENT_CONTEXT {
    UCHAR                   ProcessorNumber;
    UCHAR                   Alignment;
    USHORT                  LoggerId;
} WMI_CLIENT_CONTEXT, *PWMI_CLIENT_CONTEXT;

typedef ULONGLONG  PERFINFO_TIMESTAMP;
typedef struct _PERFINFO_TRACE_HEADER PERFINFO_TRACE_ENTRY, *PPERFINFO_TRACE_ENTRY;

//
// 64-bit Trace header for NTPERF events
//
// Note.  The field "Version" will temporary be used to log CPU Id when log to PerfMem.
// This will be removed after we change the buffer management to be the same as WMI.
// i.e., Each CPU will allocate a block of memory for logging and CPU id is in the header
// of each block.
//
typedef struct _PERFINFO_TRACE_HEADER {
    union {
        ULONG       Marker;
        struct {
            USHORT  Version;
            UCHAR   HeaderType;
            UCHAR   Flags;  //WMI uses this flag to identify event types
        };
    };
    union {
        ULONG            Header;    // both sizes must be the same!
        WMI_TRACE_PACKET Packet;
    };
    union {
        PERFINFO_TIMESTAMP TS;
        LARGE_INTEGER      SystemTime;
    };
    UCHAR Data[1];
} PERFINFO_TRACE_HEADER, *PPERFINFO_TRACE_HEADER;

//
// 64-bit Trace header for kernel events
//
typedef struct _SYSTEM_TRACE_HEADER {
    union {
        ULONG       Marker;
        struct {
            USHORT  Version;
            UCHAR   HeaderType;
            UCHAR   Flags;
        };
    };
    union {
        ULONG            Header;    // both sizes must be the same!
        WMI_TRACE_PACKET Packet;
    };
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   SystemTime;
    ULONG           KernelTime;
    ULONG           UserTime;
} SYSTEM_TRACE_HEADER, *PSYSTEM_TRACE_HEADER;

//
// 64-bit Trace Header for Tracing Messages
//

typedef struct _WMI_TRACE_MESSAGE_PACKET {  // must be ULONG!!
    USHORT  MessageNumber;                  // The message Number, index of messages by GUID
                                            // Or ComponentID
    USHORT  OptionFlags ;                   // Flags associated with the message
} WMI_TRACE_MESSAGE_PACKET, *PWMI_TRACE_MESSAGE_PACKET;

typedef struct _MESSAGE_TRACE_HEADER {
    union {
        ULONG       Marker;
        struct {
            USHORT  Size;                           // Total Size of the message including header
            UCHAR   Reserved;               // Unused and reserved
            UCHAR   Version;                // The message structure type (TRACE_MESSAGE_FLAG)
        };
    };
    union {
        ULONG            Header;            // both sizes must be the same!
        WMI_TRACE_MESSAGE_PACKET Packet;
    };
} MESSAGE_TRACE_HEADER, *PMESSAGE_TRACE_HEADER;

typedef struct _MESSAGE_TRACE {
    MESSAGE_TRACE_HEADER    MessageHeader ;
    UCHAR                   Data ;
} MESSAGE_TRACE, *PMESSAGE_TRACE ;

//
// Structure used to pass user log messages to the kernel
//
typedef struct _MESSAGE_TRACE_USER {
    MESSAGE_TRACE_HEADER    MessageHeader ;
    ULONG                   MessageFlags  ;
    ULONG64                 LoggerHandle ;
    GUID                    MessageGuid ;
    ULONG                   DataSize ;
    UCHAR                   Data ;
} MESSAGE_TRACE_USER, *PMESSAGE_TRACE_USER ;


#ifndef MEMPHIS

//
// Logger configuration and running statistics. This structure is used
// by WMI.DLL to convert to UNICODE_STRING
//
// begin_wmikm
typedef struct _WMI_LOGGER_INFORMATION {
    WNODE_HEADER Wnode;       // Had to do this since wmium.h comes later
//
// data provider by caller
    ULONG BufferSize;                   // buffer size for logging (in kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // aging decay time, in minutes
    union {
        HANDLE  LogFileHandle;          // handle to logfile
        ULONG64 LogFileHandle64;
    };

// data returned to caller
// end_wmikm
    union {
// begin_wmikm
        ULONG NumberOfBuffers;          // no of buffers in use
// end_wmikm
        ULONG InstanceCount;            // Number of Provider Instances
    };
    union {
// begin_wmikm
        ULONG FreeBuffers;              // no of buffers free
// end_wmikm
        ULONG InstanceId;               // Current Provider's Id for UmLogger
    };
    union {
// begin_wmikm
        ULONG EventsLost;               // event records lost
// end_wmikm
        ULONG NumberOfProcessors;       // Passed on to UmLogger
    };
// begin_wmikm
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    union {
        HANDLE  LoggerThreadId;         // thread id of Logger
        ULONG64 LoggerThreadId64;       // thread is of Logger
    };
    union {
        UNICODE_STRING LogFileName;     // used only in WIN64
        UNICODE_STRING64 LogFileName64; // Logfile name: only in WIN32
    };

// mandatory data provided by caller
    union {
        UNICODE_STRING LoggerName;      // Logger instance name in WIN64
        UNICODE_STRING64 LoggerName64;  // Logger Instance name in WIN32
    };

// private
    union {
        PVOID   Checksum;
        ULONG64 Checksum64;
    };
    union {
        PVOID   LoggerExtension;
        ULONG64 LoggerExtension64;
    };
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;

//
// structure for NTDLL tracing
//

typedef struct
{
        BOOLEAN IsGet;
        PWMI_LOGGER_INFORMATION LoggerInfo;
} WMINTDLLLOGGERINFO, *PWMINTDLLLOGGERINFO;

typedef struct _TIMED_TRACE_HEADER {
    USHORT          Size;
    USHORT          Marker;
    ULONG32         EventId;
    union {
        LARGE_INTEGER   TimeStamp;
        ULONG64         LoggerId;
    };
} TIMED_TRACE_HEADER, *PTIMED_TRACE_HEADER;

// end_wmikm
// the circular buffer pool, using forward linked list

#endif //!MEMPHIS

#define WMI_NON_BLOCKING

#ifdef WMI_NON_BLOCKING
typedef struct _WMI_BUFFER_STATE {
   ULONG               Free:1;
   ULONG               InUse:1;
   ULONG               Flush:1;
   ULONG               Unused:29;
} WMI_BUFFER_STATE, *PWMI_BUFFER_STATE;
#endif //WMI_NON_BLOCKING

#define WNODE_FLAG_THREAD_BUFFER        0x00800000

typedef struct _WMI_BUFFER_HEADER {
    union {
            WNODE_HEADER        Wnode;
        struct {
            ULONG64         Reserved1;
            ULONG64         Reserved2;
            LARGE_INTEGER   Reserved3;
#ifdef WMI_NON_BLOCKING
            union{
                struct {
                    PVOID Alignment;          
                    SINGLE_LIST_ENTRY SlistEntry;
                };
                LIST_ENTRY      Entry;
            };
#else
            LIST_ENTRY      Entry;
#endif //WMI_NON_BLOCKING
        };
        struct {
            LONG            ReferenceCount;     // Buffer reference count
            ULONG           SavedOffset;        // Temp saved offset
            ULONG           CurrentOffset;      // Current offset
            ULONG           UsePerfClock;       // UsePerfClock flag
            LARGE_INTEGER   TimeStamp;
            GUID            Guid;
            WMI_CLIENT_CONTEXT ClientContext;
#ifdef WMI_NON_BLOCKING
            union {
                WMI_BUFFER_STATE State;
                ULONG Flags;
            };
#else
            ULONG           Flags;
#endif //WMI_NON_BLOCKING
        };
    };
    ULONG                   Offset;
    ULONG                   EventsLost;
    union {
        GUID                InstanceGuid;
        struct {
            PVOID               LoggerContext;
#ifdef WMI_NON_BLOCKING
            SINGLE_LIST_ENTRY GlobalEntry;
#endif //WMI_NON_BLOCKING
        };
    };
} WMI_BUFFER_HEADER, *PWMI_BUFFER_HEADER;

typedef struct _TRACE_ENABLE_FLAG_EXTENSION {
    USHORT      Offset;     // Offset to the flag array in structure
    UCHAR       Length;     // Length of flag array in ULONGs
    UCHAR       Flag;       // Must be set to EVENT_TRACE_FLAG_EXTENSION
} TRACE_ENABLE_FLAG_EXTENSION, *PTRACE_ENABLE_FLAG_EXTENSION;

typedef struct _WMI_SET_MARK_INFORMATION {
    ULONG Flag;
    WCHAR Mark[1];
} WMI_SET_MARK_INFORMATION, *PWMI_SET_MARK_INFORMATION;

#define WMI_SET_MARK_WITH_FLUSH 0x00000001

#ifdef NTPERF
typedef struct _WMI_SWITCH_PERFMEM_BUFFER_INFORMATION {
    PWMI_BUFFER_HEADER Buffer;
    ULONG ProcessorId;
} WMI_SWITCH_PERFMEM_BUFFER_INFORMATION, *PWMI_SWITCH_PERFMEM_BUFFER_INFORMATION;
#endif //NTPERF

// Public Enable flags are defined in envtrace.h.
//
// This section contains extended enable flags whcih are private.
//
// Each PerfMacros Hook Contains a GlobalMask and a Hook Id.
//     The Global Mask is Used For Grouping Hooks by logical type
//                - I/O related Hooks are Grouped together under
//                  PERF_FILE_IO or PERF_DISK_IO
//                - Loader related Hooks are grouped together
//                  under PERF_LOADER,
//                - etc
// The data for a particular hook will only be logged
// if the Global Mask of the particular Hook is set.
//
// WHEN YOU ADD NEW GROUPS, UPDATE THE NAME TABLE in perfgroups.c:
// PerfGroupNames Note: If you modify numeric value of a group, update
// PerfKnownFlags table
//
// we have a set of 8 global masks available. the highest 3 bits in
// PERF_MASK_INDEX region determine to which set a particular
// global group belongs. if PERF_MASK_INDEX is 0xe0000000
// all of the following can be unique groups that can be
// turned on or of individually and used when logging data:
//
// #define PERF_GROUP1 0x00400000 in the 0th set
// #define PERF_GROUP2 0x20400000 in the 1st set
// #define PERF_GROUP3 0x40400000 in the 2nd set
// ...
// #define PERF_GROUP2 0xe0400000 in the 7th set
//
// See ntperf.h for the manupulation of flags
//
//
// Currently, no GlobalMask change is supported.
//
// Merging logging with WMI, we will use the first global mask for flags used
// by both PERF and WMI
//
// GlobalMask 0: ALL masks used in WMI defined in evntrace.h.
// These PERF_xxx are going away after we merge with WMI completely.
//

#define PERF_REGISTRY        EVENT_TRACE_FLAG_REGISTRY
#define PERF_FILE_IO         EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS
#define PERF_PROC_THREAD     EVENT_TRACE_FLAG_PROCESS | EVENT_TRACE_FLAG_THREAD
#define PERF_DISK_IO         EVENT_TRACE_FLAG_DISK_FILE_IO | EVENT_TRACE_FLAG_DISK_IO
#define PERF_LOADER          EVENT_TRACE_FLAG_IMAGE_LOAD
#define PERF_ALL_FAULTS      EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS
#define PERF_FILENAME        EVENT_TRACE_FLAG_DISK_FILE_IO
#define PERF_NETWORK         EVENT_TRACE_FLAG_NETWORK_TCPIP

//
// GlobalMask 1: The candidates to be checked into retails
//
#define PERF_MEMORY          0x20000001   // High level WS manager activities, PFN changes
#define PERF_PROFILE         0x20000002   // Sysprof
#define PERF_CONTEXT_SWITCH  0x20000004   // Context Switch
#define PERF_FOOTPRINT       0x20000008   // Flush WS on every mark_with_flush
#define PERF_DRIVERS         0x20000010
#define PERF_ADDTOWS         0x20000020
#define PERF_VERSION         0x20000040
#define PERF_DPC             0x20000080
#define PERF_SHUTDOWN        0x20000100
#define PERF_HIBER           0x20000200
#define PERF_RESUME          0x20000400
#define PERF_EXCEPTION       0x20000800
#define PERF_FILENAME_ALL    0x20001000
#define PERF_INTERRUPT       0x20004000

//
// GlobalMask 2: The candidate to remain in NTPERF
//

#define PERF_UNDEFINED       0x40000001
#define PERF_POOL            0x40000002
#define PERF_FOOTPRINT_PROC  0x40000004   // Get details WS count or pfn
#define PERF_WS_DETAIL       0x40000008   //
#define PERF_WS_ENTRY        0x40000010   //
#define PERF_HEAP            0x40000020
#define PERF_SYSCALL         0x40000040
#define PERF_WMI_TRACE       0x40000080   // Indicate to log all WMI events
#define PERF_BACKTRACE       0x40000100
#define PERF_VULCAN          0x40000200
#define PERF_OBJECTS         0x40000400
#define PERF_EVENTS          0x40000800
#define PERF_FULLTRACE       0x40001000
#define PERF_FAILED_STKDUMP  0x40002000
#define PERF_PREFETCH        0x40004000
#define PERF_FONTS           0x40008000

//
// GlobalMask 3: The candidate to be removed soon 
//
#define PERF_SERVICES                   0x80000002
#define PERF_MASK_CHANGE                0x80000004
#define PERF_DLL_INFO                   0x80000008
#define PERF_DLL_FLUSH_WS               0x80000010
#define PERF_CLEARWS                    0x80000020
#define PERF_MEMORY_SNAPSHOT            0x80000040
#define PERF_NO_MASK_CHANGE             0x80000080
#define PERF_DATA_ACCESS                0x80000100
#define PERF_MISC                       0x80000200
#define PERF_READYQUEUE                 0x80000400
#define PERF_MULTIMEDIA                 0x80000800
#define PERF_PROC_ATTACH                0x80001000
#define PERF_DSHOW_DETAILED             0x80002000
#define PERF_DSHOW_SAMPLES              0x80004000
#define PERF_POWER                      0x80008000
#define PERF_SOFT_TRIM                  0x80010000
#define PERF_DLL_THREAD_ATTACH_FLUSH_WS 0x80020000
#define PERF_DLL_THREAD_DETACH_FLUSH_WS 0x80040000

//
// GlobalMask 7: The mark is a control mask.  All flags that changes system
// behaviors go here.
//
#define PERF_CLUSTER_OFF     0xe0000001
#define PERF_BIGFOOT         0xe0000002

//
// Converting old PERF hooks into WMI format.  More clean up to be done.
//
// WHEN YOU ADD NEW TYPES UPDATE THE NAME TABLE in perfgroups.c:
// PerfLogTypeNames ALSO UPDATE VERIFICATION TABLE IN PERFPOSTTBLS.C
//

//
// Event for header
//
#define WMI_LOG_TYPE_HEADER                         (EVENT_TRACE_GROUP_HEADER | EVENT_TRACE_TYPE_INFO)

//
// Event for hardware config
//
#define WMI_LOG_TYPE_CONFIG_CPU                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_CPU)
#define WMI_LOG_TYPE_CONFIG_PHYSICALDISK          (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK)
#define WMI_LOG_TYPE_CONFIG_LOGICALDISK           (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_LOGICALDISK)
#define WMI_LOG_TYPE_CONFIG_NIC                   (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_NIC)
#define WMI_LOG_TYPE_CONFIG_VIDEO                 (EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_VIDEO)
//
//Event for Image and File Name
//
#define PERFINFO_LOG_TYPE_FILENAME                  (EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_INFO)
#define PERFINFO_LOG_TYPE_FILENAME_CREATE           (EVENT_TRACE_GROUP_FILE | 0x20)
#define PERFINFO_LOG_TYPE_FILENAME_SECTION1         (EVENT_TRACE_GROUP_FILE | 0x21)


//
//Event types for Process
//
#define WMI_LOG_TYPE_PROCESS_CREATE                 (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_START)
#define WMI_LOG_TYPE_PROCESS_DELETE                 (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_END)
#define WMI_LOG_TYPE_PROCESS_DC_START               (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_DC_START)
#define WMI_LOG_TYPE_PROCESS_DC_END                 (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_DC_END)
#define WMI_LOG_TYPE_PROCESS_LOAD_IMAGE             (EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_LOAD)

#define PERFINFO_LOG_TYPE_PROCESSNAME               (EVENT_TRACE_GROUP_PROCESS | 0x20)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_DIEDPROCESS               (EVENT_TRACE_GROUP_PROCESS | 0x21)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_OUTSWAPPROCESS            (EVENT_TRACE_GROUP_PROCESS | 0x22)  // going away
#define PERFINFO_LOG_TYPE_INSWAPPROCESS             (EVENT_TRACE_GROUP_PROCESS | 0x23)
#define PERFINFO_LOG_TYPE_IMAGELOAD                 (EVENT_TRACE_GROUP_PROCESS | 0x24)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_IMAGEUNLOAD               (EVENT_TRACE_GROUP_PROCESS | 0x25)
#define PERFINFO_LOG_TYPE_BOOT_PHASE_START          (EVENT_TRACE_GROUP_PROCESS | 0x26)

//
//Event types for Thread
//
#define WMI_LOG_TYPE_THREAD_CREATE                  (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_START)
#define WMI_LOG_TYPE_THREAD_DELETE                  (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_END)
#define WMI_LOG_TYPE_THREAD_DC_START                (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_DC_START)
#define WMI_LOG_TYPE_THREAD_DC_END                  (EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_DC_END)

#define PERFINFO_LOG_TYPE_CREATETHREAD              (EVENT_TRACE_GROUP_THREAD | 0x20) // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_TERMINATETHREAD           (EVENT_TRACE_GROUP_THREAD | 0x21) // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_GROWKERNELSTACK           (EVENT_TRACE_GROUP_THREAD | 0x22)
#define PERFINFO_LOG_TYPE_CONVERTTOGUITHREAD        (EVENT_TRACE_GROUP_THREAD | 0x23)
#define PERFINFO_LOG_TYPE_CONTEXTSWAP               (EVENT_TRACE_GROUP_THREAD | 0x24) // new context swap struct
#define PERFINFO_LOG_TYPE_THREAD_RESERVED1          (EVENT_TRACE_GROUP_THREAD | 0x25)
#define PERFINFO_LOG_TYPE_THREAD_RESERVED2          (EVENT_TRACE_GROUP_THREAD | 0x26)
#define PERFINFO_LOG_TYPE_OUTSWAPSTACK              (EVENT_TRACE_GROUP_THREAD | 0x27) // going away
#define PERFINFO_LOG_TYPE_INSWAPSTACK               (EVENT_TRACE_GROUP_THREAD | 0x28) // going away

//
// Event types for IO subsystem
//
#define WMI_LOG_TYPE_TCPIP_SEND                     (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_SEND)
#define WMI_LOG_TYPE_TCPIP_RECEIVE                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RECEIVE)
#define WMI_LOG_TYPE_TCPIP_CONNECT                  (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_CONNECT)
#define WMI_LOG_TYPE_TCPIP_DISCONNECT               (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_DISCONNECT)
#define WMI_LOG_TYPE_TCPIP_RETRANSMIT               (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RETRANSMIT)
#define WMI_LOG_TYPE_TCPIP_ACCEPT                   (EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACCEPT)

#define WMI_LOG_TYPE_UDP_SEND                       (EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_SEND)
#define WMI_LOG_TYPE_UDP_RECEIVE                    (EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_RECEIVE)

#define WMI_LOG_TYPE_IO_READ                        (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_READ)
#define WMI_LOG_TYPE_IO_WRITE                       (EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_WRITE)

#define PERFINFO_LOG_TYPE_DRIVER_INIT                       (EVENT_TRACE_GROUP_IO | 0x20)
#define PERFINFO_LOG_TYPE_DRIVER_INIT_COMPLETE              (EVENT_TRACE_GROUP_IO | 0x21)
#define PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_CALL         (EVENT_TRACE_GROUP_IO | 0x22)
#define PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_RETURN       (EVENT_TRACE_GROUP_IO | 0x23)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_CALL     (EVENT_TRACE_GROUP_IO | 0x24)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_RETURN   (EVENT_TRACE_GROUP_IO | 0x25)
#define PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_CALL            (EVENT_TRACE_GROUP_IO | 0x26)
#define PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_RETURN          (EVENT_TRACE_GROUP_IO | 0x27)
#define PERFINFO_LOG_TYPE_DRIVER_STARTIO_CALL               (EVENT_TRACE_GROUP_IO | 0x28)
#define PERFINFO_LOG_TYPE_DRIVER_STARTIO_RETURN             (EVENT_TRACE_GROUP_IO | 0x29)
#define PERFINFO_LOG_TYPE_WMI_DISKPERF_READ                 (EVENT_TRACE_GROUP_IO | 0x2a)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_WMI_DISKPERF_WRITE                (EVENT_TRACE_GROUP_IO | 0x2b)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_WMI_DISKPERF_READ_COMPLETE        (EVENT_TRACE_GROUP_IO | 0x2c)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_WMI_DISKPERF_WRITE_COMPLETE       (EVENT_TRACE_GROUP_IO | 0x2d)  // To be replaced with WMI hooks
#define PERFINFO_LOG_TYPE_WMI_DISKPERF_CACHED_READ_COMPLETE (EVENT_TRACE_GROUP_IO | 0x2e)
#define PERFINFO_LOG_TYPE_WMI_DISKPERF_CACHE_WARM_COMPLETE  (EVENT_TRACE_GROUP_IO | 0x2f)
#define PERFINFO_LOG_TYPE_PREFETCH_ACTION                   (EVENT_TRACE_GROUP_IO | 0x30)
#define PERFINFO_LOG_TYPE_PREFETCH_REQUEST                  (EVENT_TRACE_GROUP_IO | 0x31)
#define PERFINFO_LOG_TYPE_PREFETCH_READLIST                 (EVENT_TRACE_GROUP_IO | 0x32)
#define PERFINFO_LOG_TYPE_PREFETCH_READ                     (EVENT_TRACE_GROUP_IO | 0x33)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST           (EVENT_TRACE_GROUP_IO | 0x34)
#define PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST_RETURN    (EVENT_TRACE_GROUP_IO | 0x35)
#define PERFINFO_LOG_TYPE_BOOT_PREFETCH_INFORMATION         (EVENT_TRACE_GROUP_IO | 0x36)

//
// Event types for Memory subsystem
//
#define WMI_LOG_TYPE_PAGE_FAULT_TRANSITION         (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_TF)
#define WMI_LOG_TYPE_PAGE_FAULT_DEMAND_ZERO        (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_DZF)
#define WMI_LOG_TYPE_PAGE_FAULT_COPY_ON_WRITE      (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_COW)
#define WMI_LOG_TYPE_PAGE_FAULT_GUARD_PAGE         (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_GPF)
#define WMI_LOG_TYPE_PAGE_FAULT_HARD_PAGE_FAULT    (EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_HPF)

#define PERFINFO_LOG_TYPE_HARDFAULT                (EVENT_TRACE_GROUP_MEMORY | 0x20)
#define PERFINFO_LOG_TYPE_REMOVEPAGEBYCOLOR        (EVENT_TRACE_GROUP_MEMORY | 0x21)
#define PERFINFO_LOG_TYPE_REMOVEPAGEFROMLIST       (EVENT_TRACE_GROUP_MEMORY | 0x22)
#define PERFINFO_LOG_TYPE_PAGEINMEMORY             (EVENT_TRACE_GROUP_MEMORY | 0x23)
#define PERFINFO_LOG_TYPE_INSERTINFREELIST         (EVENT_TRACE_GROUP_MEMORY | 0x24)
#define PERFINFO_LOG_TYPE_SECTIONREMOVED           (EVENT_TRACE_GROUP_MEMORY | 0x25)
#define PERFINFO_LOG_TYPE_INSERTINLIST             (EVENT_TRACE_GROUP_MEMORY | 0x26)
#define PERFINFO_LOG_TYPE_INSERTATFRONT            (EVENT_TRACE_GROUP_MEMORY | 0x28)
#define PERFINFO_LOG_TYPE_UNLINKFROMSTANDBY        (EVENT_TRACE_GROUP_MEMORY | 0x29)
#define PERFINFO_LOG_TYPE_UNLINKFFREEORZERO        (EVENT_TRACE_GROUP_MEMORY | 0x2a)
#define PERFINFO_LOG_TYPE_WORKINGSETMANAGER        (EVENT_TRACE_GROUP_MEMORY | 0x2b)
#define PERFINFO_LOG_TYPE_TRIMPROCESS              (EVENT_TRACE_GROUP_MEMORY | 0x2c)
#define PERFINFO_LOG_TYPE_MEMORYSNAP               (EVENT_TRACE_GROUP_MEMORY | 0x2d)
#define PERFINFO_LOG_TYPE_ZEROSHARECOUNT           (EVENT_TRACE_GROUP_MEMORY | 0x2e)
#define PERFINFO_LOG_TYPE_TRANSITIONFAULT          (EVENT_TRACE_GROUP_MEMORY | 0x2f)
#define PERFINFO_LOG_TYPE_DEMANDZEROFAULT          (EVENT_TRACE_GROUP_MEMORY | 0x30)
#define PERFINFO_LOG_TYPE_ADDVALIDPAGETOWS         (EVENT_TRACE_GROUP_MEMORY | 0x31)
#define PERFINFO_LOG_TYPE_OUTWS_REPLACEUSED        (EVENT_TRACE_GROUP_MEMORY | 0x32)
#define PERFINFO_LOG_TYPE_OUTWS_REPLACEUNUSED      (EVENT_TRACE_GROUP_MEMORY | 0x33)
#define PERFINFO_LOG_TYPE_OUTWS_VOLUNTRIM          (EVENT_TRACE_GROUP_MEMORY | 0x34)
#define PERFINFO_LOG_TYPE_OUTWS_FORCETRIM          (EVENT_TRACE_GROUP_MEMORY | 0x35)
#define PERFINFO_LOG_TYPE_OUTWS_ADJUSTWS           (EVENT_TRACE_GROUP_MEMORY | 0x36)
#define PERFINFO_LOG_TYPE_OUTWS_EMPTYQ             (EVENT_TRACE_GROUP_MEMORY | 0x37)
#define PERFINFO_LOG_TYPE_WORKINGSETSNAP           (EVENT_TRACE_GROUP_MEMORY | 0x38)
#define PERFINFO_LOG_TYPE_DECREFCNT                (EVENT_TRACE_GROUP_MEMORY | 0x39)
#define PERFINFO_LOG_TYPE_DECSHARCNT               (EVENT_TRACE_GROUP_MEMORY | 0x3a)
#define PERFINFO_LOG_TYPE_ZEROREFCOUNT             (EVENT_TRACE_GROUP_MEMORY | 0x3b)
#define PERFINFO_LOG_TYPE_WSINFOPROCESS            (EVENT_TRACE_GROUP_MEMORY | 0x3c)
#define PERFINFO_LOG_TYPE_ADDTOWORKINGSET          (EVENT_TRACE_GROUP_MEMORY | 0x3d)
#define PERFINFO_LOG_TYPE_DELETEKERNELSTACK        (EVENT_TRACE_GROUP_MEMORY | 0x3e)
#define PERFINFO_LOG_TYPE_PROTOPTEFAULT            (EVENT_TRACE_GROUP_MEMORY | 0x3f)
#define PERFINFO_LOG_TYPE_ADDTOWS                  (EVENT_TRACE_GROUP_MEMORY | 0x40)
#define PERFINFO_LOG_TYPE_OUTWS_HASHFULL           (EVENT_TRACE_GROUP_MEMORY | 0x41)
#define PERFINFO_LOG_TYPE_MOD_PAGE_WRITER1         (EVENT_TRACE_GROUP_MEMORY | 0x42)
#define PERFINFO_LOG_TYPE_MOD_PAGE_WRITER2         (EVENT_TRACE_GROUP_MEMORY | 0x43)
#define PERFINFO_LOG_TYPE_MOD_PAGE_WRITER3         (EVENT_TRACE_GROUP_MEMORY | 0x44)
#define PERFINFO_LOG_TYPE_FAULTADDR_WITH_IP        (EVENT_TRACE_GROUP_MEMORY | 0x45)
#define PERFINFO_LOG_TYPE_TRIMSESSION              (EVENT_TRACE_GROUP_MEMORY | 0x46)
#define PERFINFO_LOG_TYPE_MEMORYSNAPLITE           (EVENT_TRACE_GROUP_MEMORY | 0x47)
#define PERFINFO_LOG_TYPE_WS_SESSION               (EVENT_TRACE_GROUP_MEMORY | 0x48)

// (EVENT_TRACE_GROUP_POOL
// 
//
// Event types for Registry subsystem
//
#define WMI_LOG_TYPE_REG_CREATE            (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGCREATE)
#define WMI_LOG_TYPE_REG_OPEN              (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGOPEN)
#define WMI_LOG_TYPE_REG_DELETE            (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGDELETE)
#define WMI_LOG_TYPE_REG_QUERY             (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGQUERY)
#define WMI_LOG_TYPE_REG_SET_VALUE         (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGSETVALUE)
#define WMI_LOG_TYPE_REG_DELETE_VALUE      (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGDELETEVALUE)
#define WMI_LOG_TYPE_REG_QUERY_VALUE       (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGQUERYVALUE)
#define WMI_LOG_TYPE_REG_ENUM_KEY          (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGENUMERATEKEY)
#define WMI_LOG_TYPE_REG_ENUM_VALUE        (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY)
#define WMI_LOG_TYPE_REG_QUERY_MULTIVALUE  (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE)
#define WMI_LOG_TYPE_REG_SET_INFO          (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGSETINFORMATION)
#define WMI_LOG_TYPE_REG_FLUSH             (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGFLUSH)
#define WMI_LOG_TYPE_REG_RUNDOWN           (EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGKCBDMP)

#define PERFINFO_LOG_TYPE_CMCELLREFERRED            (EVENT_TRACE_GROUP_REGISTRY | 0x20)
#define PERFINFO_LOG_TYPE_REG_KCB_KEYNAME           (EVENT_TRACE_GROUP_REGISTRY | 0x21)
#define PERFINFO_LOG_TYPE_REG_KCB_CREATE            (EVENT_TRACE_GROUP_REGISTRY | 0x22)
#define PERFINFO_LOG_TYPE_REG_PARSEKEY_START        (EVENT_TRACE_GROUP_REGISTRY | 0x23)
#define PERFINFO_LOG_TYPE_REG_PARSEKEY_END          (EVENT_TRACE_GROUP_REGISTRY | 0x24)
#define PERFINFO_LOG_TYPE_REG_DELETE_KEY            (EVENT_TRACE_GROUP_REGISTRY | 0x25)
#define PERFINFO_LOG_TYPE_REG_DELETE_VALUE          (EVENT_TRACE_GROUP_REGISTRY | 0x26)
#define PERFINFO_LOG_TYPE_REG_ENUM_KEY              (EVENT_TRACE_GROUP_REGISTRY | 0x27)
#define PERFINFO_LOG_TYPE_REG_ENUM_VALUE            (EVENT_TRACE_GROUP_REGISTRY | 0x28)
#define PERFINFO_LOG_TYPE_REG_QUERY_KEY             (EVENT_TRACE_GROUP_REGISTRY | 0x29)
#define PERFINFO_LOG_TYPE_REG_QUERY_VALUE           (EVENT_TRACE_GROUP_REGISTRY | 0x2a)
#define PERFINFO_LOG_TYPE_REG_QUERY_MULTIVALUE      (EVENT_TRACE_GROUP_REGISTRY | 0x2b)
#define PERFINFO_LOG_TYPE_REG_SET_VALUE             (EVENT_TRACE_GROUP_REGISTRY | 0x2c)
#define PERFINFO_LOG_TYPE_REG_NOTIFY_POST           (EVENT_TRACE_GROUP_REGISTRY | 0x2d)
#define PERFINFO_LOG_TYPE_REG_NOTIFY_KCB            (EVENT_TRACE_GROUP_REGISTRY | 0x2e)

//
// Event types for PERF tracing specific subsystem
//
#define PERFINFO_LOG_TYPE_PERFFREQUENCY                (EVENT_TRACE_GROUP_PERFINFO | 0x20)
#define PERFINFO_LOG_TYPE_PERFCOUNTERSTART             (EVENT_TRACE_GROUP_PERFINFO | 0x21)
#define PERFINFO_LOG_TYPE_MARK                         (EVENT_TRACE_GROUP_PERFINFO | 0x22)
#define PERFINFO_LOG_TYPE_VERSION                      (EVENT_TRACE_GROUP_PERFINFO | 0x23)
#define PERFINFO_LOG_TYPE_ASYNCMARK                    (EVENT_TRACE_GROUP_PERFINFO | 0x24)
#define PERFINFO_LOG_TYPE_FILENAMEBUFFER               (EVENT_TRACE_GROUP_PERFINFO | 0x25)  // to be cleaned up
#define PERFINFO_LOG_TYPE_IMAGENAME                    (EVENT_TRACE_GROUP_PERFINFO | 0x26)
#define PERFINFO_LOG_TYPE_RESERVED1                    (EVENT_TRACE_GROUP_PERFINFO | 0x27)
#define PERFINFO_LOG_TYPE_RESERVED2                    (EVENT_TRACE_GROUP_PERFINFO | 0x28)
#define PERFINFO_LOG_TYPE_RESERVED3                    (EVENT_TRACE_GROUP_PERFINFO | 0x29)
#define PERFINFO_LOG_TYPE_WMI_TRACE_IO                 (EVENT_TRACE_GROUP_PERFINFO | 0x2a)
#define PERFINFO_LOG_TYPE_WMI_TRACE_FILENAME_EVENT     (EVENT_TRACE_GROUP_PERFINFO | 0x2b)
#define PERFINFO_LOG_TYPE_GLOBAL_MASK_CHANGE           (EVENT_TRACE_GROUP_PERFINFO | 0x2c)
#define PERFINFO_LOG_TYPE_TRACEINFO                    (EVENT_TRACE_GROUP_PERFINFO | 0x2d) // go away
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE              (EVENT_TRACE_GROUP_PERFINFO | 0x2e)
#define PERFINFO_LOG_TYPE_TIMERDPC_ENTER               (EVENT_TRACE_GROUP_PERFINFO | 0x2f)
#define PERFINFO_LOG_TYPE_TIMERDPC_EXIT                (EVENT_TRACE_GROUP_PERFINFO | 0x30)
#define PERFINFO_LOG_TYPE_DPC_ENTER                    (EVENT_TRACE_GROUP_PERFINFO | 0x31)
#define PERFINFO_LOG_TYPE_DPC_EXIT                     (EVENT_TRACE_GROUP_PERFINFO | 0x32)
#define PERFINFO_LOG_TYPE_SYSCALL_ENTER                (EVENT_TRACE_GROUP_PERFINFO | 0x33)
#define PERFINFO_LOG_TYPE_SYSCALL_EXIT                 (EVENT_TRACE_GROUP_PERFINFO | 0x34)
#define PERFINFO_LOG_TYPE_BACKTRACE                    (EVENT_TRACE_GROUP_PERFINFO | 0x35)
#define PERFINFO_LOG_TYPE_BACKTRACE_USERSTACK          (EVENT_TRACE_GROUP_PERFINFO | 0x36)
#define PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE        (EVENT_TRACE_GROUP_PERFINFO | 0x37)
#define PERFINFO_LOG_TYPE_EXCEPTION_STACK              (EVENT_TRACE_GROUP_PERFINFO | 0x38)
#define PERFINFO_LOG_TYPE_BRANCH_TRACE                 (EVENT_TRACE_GROUP_PERFINFO | 0x39)
#define PERFINFO_LOG_TYPE_BRANCH_TRACE_DEBUG           (EVENT_TRACE_GROUP_PERFINFO | 0x40)
#define PERFINFO_LOG_TYPE_BRANCH_ADDRESS_DEBUG         (EVENT_TRACE_GROUP_PERFINFO | 0x41)
#define PERFINFO_LOG_TYPE_INTERRUPT                    (EVENT_TRACE_GROUP_PERFINFO | 0x43)
#define PERFINFO_LOG_TYPE_DPC                          (EVENT_TRACE_GROUP_PERFINFO | 0x44)
#define PERFINFO_LOG_TYPE_TIMERDPC                     (EVENT_TRACE_GROUP_PERFINFO | 0x45)

//
// Event types for Pool subsystem
//

#define PERFINFO_LOG_TYPE_ALLOCATEPOOL                 (EVENT_TRACE_GROUP_POOL | 0x20)
#define PERFINFO_LOG_TYPE_FREEPOOL                     (EVENT_TRACE_GROUP_POOL | 0x21)
#define PERFINFO_LOG_TYPE_POOLSTAT                     (EVENT_TRACE_GROUP_POOL | 0x22)
#define PERFINFO_LOG_TYPE_ADDPOOLPAGE                  (EVENT_TRACE_GROUP_POOL | 0x23)
#define PERFINFO_LOG_TYPE_FREEPOOLPAGE                 (EVENT_TRACE_GROUP_POOL | 0x24)
#define PERFINFO_LOG_TYPE_BIGPOOLPAGE                  (EVENT_TRACE_GROUP_POOL | 0x25)
#define PERFINFO_LOG_TYPE_POOLSNAP                     (EVENT_TRACE_GROUP_POOL | 0x26)

//
// Event types for Heap subsystem
//
#define PERFINFO_LOG_TYPE_HEAP_CREATE                  (EVENT_TRACE_GROUP_HEAP | 0x20)
#define PERFINFO_LOG_TYPE_HEAP_ALLOC                   (EVENT_TRACE_GROUP_HEAP | 0x21)
#define PERFINFO_LOG_TYPE_HEAP_REALLOC                 (EVENT_TRACE_GROUP_HEAP | 0x22)
#define PERFINFO_LOG_TYPE_HEAP_DESTROY                 (EVENT_TRACE_GROUP_HEAP | 0x23)
#define PERFINFO_LOG_TYPE_HEAP_FREE                    (EVENT_TRACE_GROUP_HEAP | 0x24)
#define PERFINFO_LOG_TYPE_HEAP_EXTEND                  (EVENT_TRACE_GROUP_HEAP | 0x25)
#define PERFINFO_LOG_TYPE_HEAP_SNAPSHOT                (EVENT_TRACE_GROUP_HEAP | 0x26)
#define PERFINFO_LOG_TYPE_HEAP_CREATE_SNAPSHOT         (EVENT_TRACE_GROUP_HEAP | 0x27)
#define PERFINFO_LOG_TYPE_HEAP_DESTROY_SNAPSHOT        (EVENT_TRACE_GROUP_HEAP | 0x28)
#define PERFINFO_LOG_TYPE_HEAP_EXTEND_SNAPSHOT         (EVENT_TRACE_GROUP_HEAP | 0x29)
#define PERFINFO_LOG_TYPE_HEAP_CONTRACT                            (EVENT_TRACE_GROUP_HEAP | 0x2a)
#define PERFINFO_LOG_TYPE_HEAP_LOCK                                        (EVENT_TRACE_GROUP_HEAP | 0x2b)
#define PERFINFO_LOG_TYPE_HEAP_UNLOCK                              (EVENT_TRACE_GROUP_HEAP | 0x2c)
#define PERFINFO_LOG_TYPE_HEAP_VALIDATE                            (EVENT_TRACE_GROUP_HEAP | 0x2d)
#define PERFINFO_LOG_TYPE_HEAP_WALK                                (EVENT_TRACE_GROUP_HEAP | 0x2e)

//
// Event Types for Critical Section Subsystem
//

#define PERFINFO_LOG_TYPE_CRITSEC_ENTER                            (EVENT_TRACE_GROUP_CRITSEC | 0x20)
#define PERFINFO_LOG_TYPE_CRITSEC_LEAVE                            (EVENT_TRACE_GROUP_CRITSEC | 0x21)
#define PERFINFO_LOG_TYPE_CRITSEC_COLLISION                        (EVENT_TRACE_GROUP_CRITSEC | 0x22)

//
// Event types for Object subsystem
//
#define PERFINFO_LOG_TYPE_DECLARE_OBJECT               (EVENT_TRACE_GROUP_OBJECT | 0x20)
#define PERFINFO_LOG_TYPE_WAIT_OBJECT                  (EVENT_TRACE_GROUP_OBJECT | 0x21)
#define PERFINFO_LOG_TYPE_UNWAIT_OBJECT                (EVENT_TRACE_GROUP_OBJECT | 0x22)
#define PERFINFO_LOG_TYPE_SIGNAL_OBJECT                (EVENT_TRACE_GROUP_OBJECT | 0x23)
#define PERFINFO_LOG_TYPE_CLEAR_OBJECT                 (EVENT_TRACE_GROUP_OBJECT | 0x24)
#define PERFINFO_LOG_TYPE_UNWAIT_SIGNALED_OBJECT       (EVENT_TRACE_GROUP_OBJECT | 0x25)

//
// Event types for Power subsystem
//
#define PERFINFO_LOG_TYPE_BATTERY_LIFE_INFO            (EVENT_TRACE_GROUP_POWER | 0x20)
#define PERFINFO_LOG_TYPE_IDLE_STATE_CHANGE            (EVENT_TRACE_GROUP_POWER | 0x21)
#define PERFINFO_LOG_TYPE_SET_POWER_ACTION             (EVENT_TRACE_GROUP_POWER | 0x22)
#define PERFINFO_LOG_TYPE_SET_POWER_ACTION_RET         (EVENT_TRACE_GROUP_POWER | 0x23)
#define PERFINFO_LOG_TYPE_SET_DEVICES_STATE            (EVENT_TRACE_GROUP_POWER | 0x24)
#define PERFINFO_LOG_TYPE_SET_DEVICES_STATE_RET        (EVENT_TRACE_GROUP_POWER | 0x25)
#define PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE             (EVENT_TRACE_GROUP_POWER | 0x26)
#define PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE    (EVENT_TRACE_GROUP_POWER | 0x27)
#define PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT           (EVENT_TRACE_GROUP_POWER | 0x28)
#define PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT_RET       (EVENT_TRACE_GROUP_POWER | 0x29)
#define PERFINFO_LOG_TYPE_PO_PRESLEEP                  (EVENT_TRACE_GROUP_POWER | 0x30)
#define PERFINFO_LOG_TYPE_PO_POSTSLEEP                 (EVENT_TRACE_GROUP_POWER | 0x31)

//
// Event types for MODBound subsystem
//
#define PERFINFO_LOG_TYPE_MODULEBOUND_ENT              (EVENT_TRACE_GROUP_MODBOUND | 0x20)
#define PERFINFO_LOG_TYPE_MODULEBOUND_JUMP             (EVENT_TRACE_GROUP_MODBOUND | 0x21)
#define PERFINFO_LOG_TYPE_MODULEBOUND_RET              (EVENT_TRACE_GROUP_MODBOUND | 0x22)
#define PERFINFO_LOG_TYPE_MODULEBOUND_CALL             (EVENT_TRACE_GROUP_MODBOUND | 0x23)
#define PERFINFO_LOG_TYPE_MODULEBOUND_CALLRET          (EVENT_TRACE_GROUP_MODBOUND | 0x24)
#define PERFINFO_LOG_TYPE_MODULEBOUND_INT2E            (EVENT_TRACE_GROUP_MODBOUND | 0x25)
#define PERFINFO_LOG_TYPE_MODULEBOUND_INT2B            (EVENT_TRACE_GROUP_MODBOUND | 0x26)
#define PERFINFO_LOG_TYPE_MODULEBOUND_FULLTRACE        (EVENT_TRACE_GROUP_MODBOUND | 0x27)

//
// Event types for gdi subsystem
#define PERFINFO_LOG_TYPE_FONT_REALIZE                 (EVENT_TRACE_GROUP_GDI | 0x20)
#define PERFINFO_LOG_TYPE_FONT_DELETE                  (EVENT_TRACE_GROUP_GDI | 0x21)
#define PERFINFO_LOG_TYPE_FONT_ACTIVATE                (EVENT_TRACE_GROUP_GDI | 0x22)
#define PERFINFO_LOG_TYPE_FONT_FLUSH                   (EVENT_TRACE_GROUP_GDI | 0x23)

//
// Event types To be Decided if they are still needed?
//

#define PERFINFO_LOG_TYPE_DISPATCHMSG                       (EVENT_TRACE_GROUP_TBD | 0x00)
#define PERFINFO_LOG_TYPE_GLYPHCACHE                        (EVENT_TRACE_GROUP_TBD | 0x01)
#define PERFINFO_LOG_TYPE_GLYPHS                            (EVENT_TRACE_GROUP_TBD | 0x02)
#define PERFINFO_LOG_TYPE_READWRITE                         (EVENT_TRACE_GROUP_TBD | 0x03)
#define PERFINFO_LOG_TYPE_EXPLICIT_LOAD                     (EVENT_TRACE_GROUP_TBD | 0x04)
#define PERFINFO_LOG_TYPE_IMPLICIT_LOAD                     (EVENT_TRACE_GROUP_TBD | 0x05)
#define PERFINFO_LOG_TYPE_CHECKSUM                          (EVENT_TRACE_GROUP_TBD | 0x06)
#define PERFINFO_LOG_TYPE_DLL_INIT                          (EVENT_TRACE_GROUP_TBD | 0x07)
#define PERFINFO_LOG_TYPE_SERVICE_DD_START_INIT             (EVENT_TRACE_GROUP_TBD | 0x08)
#define PERFINFO_LOG_TYPE_SERVICE_DD_DONE_INIT              (EVENT_TRACE_GROUP_TBD | 0x09)
#define PERFINFO_LOG_TYPE_SERVICE_START_INIT                (EVENT_TRACE_GROUP_TBD | 0x0a)
#define PERFINFO_LOG_TYPE_SERVICE_DONE_INIT                 (EVENT_TRACE_GROUP_TBD | 0x0b)
#define PERFINFO_LOG_TYPE_SERVICE_NAME                      (EVENT_TRACE_GROUP_TBD | 0x0c)
#define PERFINFO_LOG_TYPE_WSINFOSESSION                     (EVENT_TRACE_GROUP_TBD | 0x0d)
#define PERFINFO_LOG_TIMED_ENTER_ROUTINE                    (EVENT_TRACE_GROUP_TBD | 0x0e)
#define PERFINFO_LOG_TIMED_EXIT_ROUTINE                     (EVENT_TRACE_GROUP_TBD | 0x0f)
#define PERFINFO_LOG_TYPE_CTIME_STATS                       (EVENT_TRACE_GROUP_TBD | 0x10)
#define PERFINFO_LOG_TYPE_MARKED_DIRTY                      (EVENT_TRACE_GROUP_TBD | 0x11)
#define PERFINFO_LOG_TYPE_MARKED_CELL_DIRTY                 (EVENT_TRACE_GROUP_TBD | 0x12)
#define PERFINFO_LOG_TYPE_HIVE_WRITE_DIRTY                  (EVENT_TRACE_GROUP_TBD | 0x13)
#define PERFINFO_LOG_TYPE_DUMP_HIVECELL                     (EVENT_TRACE_GROUP_TBD | 0x14)
#define PERFINFO_LOG_TYPE_HIVE_STAT                         (EVENT_TRACE_GROUP_TBD | 0x16)
#define PERFINFO_LOG_TYPE_CLOCKREF                          (EVENT_TRACE_GROUP_TBD | 0x17)
#define PERFINFO_LOG_TYPE_COWHEADER                         (EVENT_TRACE_GROUP_TBD | 0x18)
#define PERFINFO_LOG_TYPE_COWBLOB                           (EVENT_TRACE_GROUP_TBD | 0x19)
#define PERFINFO_LOG_TYPE_COWBLOB_CLOSED                    (EVENT_TRACE_GROUP_TBD | 0x1a)
#define PERFINFO_LOG_TYPE_WMIPERFFREQUENCY                  (EVENT_TRACE_GROUP_TBD | 0x1d)
#define PERFINFO_LOG_TYPE_CDROM_READ                        (EVENT_TRACE_GROUP_TBD | 0x1e)
#define PERFINFO_LOG_TYPE_CDROM_READ_COMPLETE               (EVENT_TRACE_GROUP_TBD | 0x1f)
#define PERFINFO_LOG_TYPE_KE_SET_EVENT                      (EVENT_TRACE_GROUP_TBD | 0x20)
#define PERFINFO_LOG_TYPE_REG_PARSEKEY                      (EVENT_TRACE_GROUP_TBD | 0x21)
#define PERFINFO_LOG_TYPE_REG_PARSEKEYEND                   (EVENT_TRACE_GROUP_TBD | 0x22)
#define PERFINFO_LOG_TYPE_ATTACH_PROCESS                    (EVENT_TRACE_GROUP_TBD | 0x24)
#define PERFINFO_LOG_TYPE_DETACH_PROCESS                    (EVENT_TRACE_GROUP_TBD | 0x25)
#define PERFINFO_LOG_TYPE_DATA_ACCESS                       (EVENT_TRACE_GROUP_TBD | 0x26)
#define PERFINFO_LOG_TYPE_KDHELP                            (EVENT_TRACE_GROUP_TBD | 0x27)
#define PERFINFO_LOG_TYPE_BOOT_OPTIONS                      (EVENT_TRACE_GROUP_TBD | 0x28)
#define PERFINFO_LOG_TYPE_FAILED_STKDUMP                    (EVENT_TRACE_GROUP_TBD | 0x2c)
#define PERFINFO_LOG_TYPE_SYSTEM_TIME                       (EVENT_TRACE_GROUP_TBD | 0x2f)
#define PERFINFO_LOG_TYPE_READYQUEUE                        (EVENT_TRACE_GROUP_TBD | 0x30)

//
// KMIXER hooks are in audio\filters\kmixer\pins.c
//
#define PERFINFO_LOG_TYPE_KMIXER_DRIVER_ENTRY               (EVENT_TRACE_GROUP_TBD | 0x31)
#define PERFINFO_LOG_TYPE_KMIXER_DSOUND_STARVATION          (EVENT_TRACE_GROUP_TBD | 0x32)
#define PERFINFO_LOG_TYPE_KMIXER_DPC_STARVATION             (EVENT_TRACE_GROUP_TBD | 0x33)
#define PERFINFO_LOG_TYPE_KMIXER_WAVE_TOP_STARVATION        (EVENT_TRACE_GROUP_TBD | 0x34)

#define PERFINFO_LOG_TYPE_OVERLAY_QUALITY                   (EVENT_TRACE_GROUP_TBD | 0x35)
                                                            // in amovie\filters\mixer\ovmixer\ominpin.cpp
#define PERFINFO_LOG_TYPE_DVD_RENDER_SAMPLE                 (EVENT_TRACE_GROUP_TBD | 0x36)
#define PERFINFO_LOG_TYPE_CDVD_SET_DISCONTINUITY            (EVENT_TRACE_GROUP_TBD | 0x37)
                                                            // in amovie\filters\dvdnav\dvdnav\dvd.cpp
#define PERFINFO_LOG_TYPE_CSPLITTER_SET_DISCONTINUITY       (EVENT_TRACE_GROUP_TBD | 0x38)
                                                            // in amovie\filters\dvdnav\base\splitter.cpp

// following hooks are in amovie\sdk\classes\base
#define PERFINFO_LOG_TYPE_DSHOW_CTOR                                   (EVENT_TRACE_GROUP_TBD | 0x39)
#define PERFINFO_LOG_TYPE_DSHOW_DTOR                                   (EVENT_TRACE_GROUP_TBD | 0x3a)
#define PERFINFO_LOG_TYPE_DSHOW_DELIVER                                (EVENT_TRACE_GROUP_TBD | 0x3b)
#define PERFINFO_LOG_TYPE_DSHOW_RECEIVE                                (EVENT_TRACE_GROUP_TBD | 0x3c)
#define PERFINFO_LOG_TYPE_DSHOW_RUN                                    (EVENT_TRACE_GROUP_TBD | 0x3d)
#define PERFINFO_LOG_TYPE_DSHOW_PAUSE                                  (EVENT_TRACE_GROUP_TBD | 0x3e)
#define PERFINFO_LOG_TYPE_DSHOW_STOP                                   (EVENT_TRACE_GROUP_TBD | 0x3f)
#define PERFINFO_LOG_TYPE_DSHOW_JOINGRAPH                              (EVENT_TRACE_GROUP_TBD | 0x40)
#define PERFINFO_LOG_TYPE_DSHOW_GETBUFFER                              (EVENT_TRACE_GROUP_TBD | 0x41)
#define PERFINFO_LOG_TYPE_DSHOW_RELBUFFER                              (EVENT_TRACE_GROUP_TBD | 0x42)
#define PERFINFO_LOG_TYPE_DSHOW_CONNECT                                (EVENT_TRACE_GROUP_TBD | 0x43)
#define PERFINFO_LOG_TYPE_DSHOW_RXCONNECT                              (EVENT_TRACE_GROUP_TBD | 0x44)
#define PERFINFO_LOG_TYPE_DSHOW_DISCONNECT                             (EVENT_TRACE_GROUP_TBD | 0x45)
#define PERFINFO_LOG_TYPE_DSHOW_GETTIME                                (EVENT_TRACE_GROUP_TBD | 0x46)
#define PERFINFO_LOG_TYPE_DSHOW_AUDIOREND                              (EVENT_TRACE_GROUP_TBD | 0x47)
#define PERFINFO_LOG_TYPE_DSHOW_VIDEOREND                              (EVENT_TRACE_GROUP_TBD | 0x48)
#define PERFINFO_LOG_TYPE_DSHOW_FRAMEDROP                              (EVENT_TRACE_GROUP_TBD | 0x49)
#define PERFINFO_LOG_TYPE_DSHOW_AUDIOBREAK                             (EVENT_TRACE_GROUP_TBD | 0x4a)
#define PERFINFO_LOG_TYPE_DSHOW_SAMPLE_DATADISCONTINUITY               (EVENT_TRACE_GROUP_TBD | 0x4b)
#define PERFINFO_LOG_TYPE_DSHOW_MEDIASAMPLE_SET_DISCONTINUITY          (EVENT_TRACE_GROUP_TBD | 0x4c)
#define PERFINFO_LOG_TYPE_DSHOW_TRANSFORM_INITSAMPLE_SET_DISCONTINUITY (EVENT_TRACE_GROUP_TBD | 0x4d)
#define PERFINFO_LOG_TYPE_DSHOW_TRANSFORM_COPY_SET_DISCONTINUITY       (EVENT_TRACE_GROUP_TBD | 0x4e)
#define PERFINFO_LOG_TYPE_DSHOW_SYNCOBJ_ADVICE_FRAME_SKIP              (EVENT_TRACE_GROUP_TBD | 0x4f)
#define PERFINFO_LOG_TYPE_WMI_REFLECT_DISK_IO_READ                     (EVENT_TRACE_GROUP_TBD | 0x50)
#define PERFINFO_LOG_TYPE_WMI_REFLECT_DISK_IO_WRITE                    (EVENT_TRACE_GROUP_TBD | 0x51)

#if 0
//
// 2000-2199 reserved for SQL Server
//

#define PERFINFO_LOG_TYPE_SQLSERVER_FIRST               (2000)
#define PERFINFO_LOG_TYPE_SQLSERVER_LAST                (PERFINFO_LOG_TYPE_SQLSERVER_FIRST + 199)

//
//  2200-2299 reserved for reflection of WMI events
//

#define PERFINFO_LOG_TYPE_WMI_REFLECT_FIRST             (2200)
#define PERFINFO_LOG_TYPE_WMI_REFLECT_LAST              (PERFINFO_LOG_TYPE_WMI_REFLECT_FIRST + 199)
#endif //0

//
// Data structure used for WMI Kernel Events
//
// **NB** the hardware events are described in software traceing, if they
//        change in layout please update sdktools\trace\tracefmt\default.tmf


#define MAX_DEVICE_ID_LENGTH 256
#define CONFIG_MAX_DOMAIN_NAME_LEN  132


typedef struct _CPU_CONFIG_RECORD {
    ULONG ProcessorSpeed;
    ULONG NumberOfProcessors;
    ULONG MemorySize;               // in MBytes
    ULONG PageSize;                 // in Bytes
    ULONG AllocationGranularity;    // in Bytes
    WCHAR ComputerName[MAX_DEVICE_ID_LENGTH];
    WCHAR DomainName[CONFIG_MAX_DOMAIN_NAME_LEN];
} CPU_CONFIG_RECORD, *PCPU_CONFIG_RECORD;

#define CONFIG_WRITE_CACHE_ENABLED     0x00000001
#define CONFIG_FS_NAME_LEN             16
#define CONFIG_BOOT_DRIVE_LEN          3
typedef struct _PHYSICAL_DISK_RECORD {
    ULONG DiskNumber;
    ULONG BytesPerSector;
    ULONG SectorsPerTrack;
    ULONG TracksPerCylinder;
    ULONGLONG Cylinders;
    ULONG SCSIPortNumber;
    ULONG SCSIPathId;
    ULONG SCSITargetId;
    ULONG SCSILun;
    WCHAR Manufacturer[MAX_DEVICE_ID_LENGTH];

    ULONG PartitionCount;
    BOOLEAN WriteCacheEnabled;
    WCHAR BootDriveLetter[CONFIG_BOOT_DRIVE_LEN];
} PHYSICAL_DISK_RECORD, *PPHYSICAL_DISK_RECORD;

//
// Types of logical drive
//
#define CONFIG_DRIVE_PARTITION  0x00000001
#define CONFIG_DRIVE_VOLUME     0x00000002
#define CONFIG_DRIVE_EXTENT     0x00000004
#define CONFIG_DRIVE_LETTER_LEN 4

typedef struct _LOGICAL_DISK_EXTENTS {
    ULONGLONG StartingOffset;
    ULONGLONG PartitionSize;
    ULONG DiskNumber;           // The physical disk number where the logical drive resides
    
    ULONG Size;                 // The size in bytes of the structure.
    ULONG DriveType;            // Logical drive type partition/volume/extend-partition
    WCHAR DriveLetterString[CONFIG_DRIVE_LETTER_LEN];
    ULONG Pad;
    ULONG PartitionNumber;      // The partition number where the logical drive resides
    ULONG SectorsPerCluster;
    ULONG BytesPerSector;
    LONGLONG NumberOfFreeClusters;
    LONGLONG TotalNumberOfClusters;
    WCHAR FileSystemType[CONFIG_FS_NAME_LEN];
    ULONG VolumeExt;            // Offset to VOLUME_DISK_EXTENTS structure
} LOGICAL_DISK_EXTENTS, *PLOGICAL_DISK_EXTENTS;

#define CONFIG_MAX_DNS_SERVER  4
#define CONFIG_MAX_ADAPTER_ADDRESS_LENGTH 8

//
// Note: Data is an array of structures of type IP_ADDRESS_STRING defined in iptypes.h
//
typedef struct _NIC_RECORD {
    WCHAR NICName[MAX_DEVICE_ID_LENGTH];
    ULONG Index; 
    ULONG PhysicalAddrLen;
    WCHAR PhysicalAddr[CONFIG_MAX_ADAPTER_ADDRESS_LENGTH];
        
    ULONG Size;         // Size of the Data
    LONG IpAddress;     // IP Address offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    LONG SubnetMask;    // subnet mask offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    LONG DhcpServer;    // dhcp server offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    LONG Gateway;       // gateway offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    LONG PrimaryWinsServer; //  primary wins server offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    LONG SecondaryWinsServer;// secondary wins server offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    LONG DnsServer[CONFIG_MAX_DNS_SERVER]; // dns server offset. Copy bytes = sizeof(IP_ADDRESS_STRING)
    ULONG Data;                            // Offset to an array of IP_ADDRESS_STRING
} NIC_RECORD, *PNIC_RECORD;

typedef struct _VIDEO_RECORD {
    ULONG  MemorySize;
    ULONG  XResolution;
    ULONG  YResolution;
    ULONG  BitsPerPixel;
    ULONG  VRefresh;
    WCHAR  ChipType[MAX_DEVICE_ID_LENGTH];
    WCHAR  DACType[MAX_DEVICE_ID_LENGTH];
    WCHAR  AdapterString[MAX_DEVICE_ID_LENGTH];
    WCHAR  BiosString[MAX_DEVICE_ID_LENGTH];
    WCHAR  DeviceId[MAX_DEVICE_ID_LENGTH];
    ULONG  StateFlags;
} VIDEO_RECORD, *PVIDEO_RECORD;

#define CONFIG_MAX_NAME_LENGTH 34
#define CONFIG_MAX_DISPLAY_NAME 256

typedef struct _WMI_SERVICE_INFO {
    WCHAR  ServiceName[CONFIG_MAX_NAME_LENGTH];
    WCHAR  DisplayName[CONFIG_MAX_DISPLAY_NAME];
    WCHAR  ProcessName[CONFIG_MAX_NAME_LENGTH];
    ULONG ProcessId;
} WMI_SERVICE_INFO, *PWMI_SERVICE_INFO;

//
// Stores the ACPI Power Information
//
typedef struct _WMI_POWER_RECORD {
    BOOLEAN  SystemS1;
    BOOLEAN  SystemS2;
    BOOLEAN  SystemS3;
    BOOLEAN  SystemS4;           // hibernate
    BOOLEAN  SystemS5;           // off
    CHAR     Pad1;
    CHAR     Pad2;
    CHAR     Pad3;
} WMI_POWER_RECORD, *PWMI_POWER_RECORD;

typedef struct _WMI_PROCESS_INFORMATION {
    ULONG_PTR PageDirectoryBase;
    ULONG ProcessId;
    ULONG ParentId;
    ULONG SessionId;
    NTSTATUS ExitStatus;
    ULONG Sid;
    // Filename is added at the ned of the structure.
    // Since Sid is variable length field, 
    // FileName is not defined in the structure. 
} WMI_PROCESS_INFORMATION, *PWMI_PROCESS_INFORMATION;

typedef struct _WMI_THREAD_INFORMATION {
    ULONG ProcessId;
    ULONG ThreadId;
} WMI_THREAD_INFORMATION, *PWMI_THREAD_INFORMATION;

typedef struct _WMI_EXTENDED_THREAD_INFORMATION {
    ULONG ProcessId;
    ULONG ThreadId;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID UserStackBase;
    PVOID UserStackLimit;
    PVOID StartAddr;
    PVOID Win32StartAddr;
    CHAR  WaitMode;
} WMI_EXTENDED_THREAD_INFORMATION, *PWMI_EXTENDED_THREAD_INFORMATION;

typedef struct _WMI_IMAGELOAD_INFORMATION {
    PVOID ImageBase;
    SIZE_T ImageSize;
    ULONG ProcessId;
    WCHAR FileName[1];
} WMI_IMAGELOAD_INFORMATION, *PWMI_IMAGELOAD_INFORMATION;

typedef struct _WMI_DISKIO_READWRITE {
    ULONG DiskNumber;
    ULONG IrpFlags;
    ULONG Size;
    ULONG ResponseTime;
    ULONGLONG ByteOffset;
    PVOID FileObject;
    ULONGLONG HighResResponseTime;
} WMI_DISKIO_READWRITE, *PWMI_DISKIO_READWRITE;


typedef struct _WMI_REGISTRY {
    ULONG_PTR Status;
    PVOID Kcb;
    LONGLONG ElapsedTime;
    union{
        ULONG Index;
        ULONG InfoClass;
    };
    WCHAR Name[1]; 
} WMI_REGISTRY, *PWMI_REGISTRY;

typedef struct _WMI_FILE_IO {
    PVOID FileObject;
    WCHAR FileName[1];
} WMI_FILE_IO, *PWMI_FILE_IO;

typedef struct _WMI_TCPIP {

    ULONG Context;
    ULONG  Size;
    ULONG DestAddr;
    ULONG SrcAddr;
    USHORT DestPort;
    USHORT SrcPort;
        
} WMI_TCPIP, *PWMI_TCPIP;

typedef struct _WMI_UDP {

    ULONG PID;
    USHORT Size;
    ULONG DestAddr;
    ULONG SrcAddr;
    USHORT DestPort;
    USHORT SrcPort;

}WMI_UDP, *PWMI_UDP;

typedef struct _WMI_PAGE_FAULT {
    PVOID VirtualAddress;
    PVOID ProgramCounter;
} WMI_PAGE_FAULT, *PWMI_PAGE_FAULT;

typedef struct _WMI_CONTEXTSWAP {

    ULONG   NewThreadId;
    ULONG   OldThreadId;

    CHAR    NewThreadPriority;
    CHAR    OldThreadPriority;
    CHAR    NewThreadQuantum;
    CHAR        OldThreadQuantum;

    UCHAR   OldThreadWaitReason;
    CHAR    OldThreadWaitMode;
    UCHAR   OldThreadState;
    UCHAR   OldThreadIdealProcessor;

} WMI_CONTEXTSWAP, *PWMI_CONTEXTSWAP;

typedef struct _HEAP_EVENT_ALLOC {

        PVOID HeapHandle;               //Handle of Heap
        SIZE_T Size;                    //Size of allocation in bytes
        PVOID Address;                  //Address of Allocation
        ULONG Source;                   //Type ie Lookaside, Lowfrag or main path

}HEAP_EVENT_ALLOC, *PHEAP_EVENT_ALLOC;

typedef struct _HEAP_EVENT_FREE {

        PVOID HeapHandle;               //Handle of Heap
        PVOID Address;                  //Address to free
        ULONG Source;                   //Type ie Lookaside, Lowfrag or main path

}HEAP_EVENT_FREE, *PHEAP_EVENT_FREE;

typedef struct _HEAP_EVENT_REALLOC {

        PVOID HeapHandle;       //Handle of Heap
        PVOID NewAddress;       //New Address returned to user
        PVOID OldAddress;       //Old Address got from user
        SIZE_T NewSize;         //New Size in bytes
        SIZE_T OldSize;         //Old Size in bytes
        ULONG Source;           //Type ie Lookaside, Lowfrag or main path

}HEAP_EVENT_REALLOC, *PHEAP_EVENT_REALLOC;

typedef struct _HEAP_EVENT_EXPANSION {

        PVOID HeapHandle;                               //Handle of Heap
        SIZE_T CommittedSize;                   //Memory Size in bytes actually committed
        PVOID Address;                                  //Address of free block or segment
        SIZE_T FreeSpace;                               //Total free Space in Heap
        SIZE_T CommittedSpace;                  //Memory Committed
        SIZE_T ReservedSpace;                   //Memory reserved
        ULONG NoOfUCRs;                                 //Number of UnCommitted Ranges

}HEAP_EVENT_EXPANSION, *PHEAP_EVENT_EXPANSION;

typedef struct _HEAP_EVENT_CONTRACTION {

        PVOID HeapHandle;                       //Handle of Heap
        SIZE_T DeCommitSize;            //The size of DeCommitted Block
        PVOID DeCommitAddress;          //Address of the Decommitted block
        SIZE_T FreeSpace;                       //Total free Space in Heap in bytes
        SIZE_T CommittedSpace;          //Memory Committed in bytes
        SIZE_T ReservedSpace;           //Memory reserved in bytes
        ULONG NoOfUCRs;                         //Number of UnCommitted Ranges


}HEAP_EVENT_CONTRACTION, *PHEAP_EVENT_CONTRACTION;

typedef struct _HEAP_EVENT_CREATE {

        PVOID HeapHandle;               //Handle of Heap
        ULONG Flags;                    //Flags passed while creating heap.

}HEAP_EVENT_CREATE, *PHEAP_EVENT_CREATE;

typedef struct _CRIT_SEC_COLLISION_EVENT_DATA {

        ULONG           LockCount;              //Lock Count
        PVOID           SpinCount;              //Spin Count
        PVOID           OwningThread;   //Thread having Lock
        PVOID       Address;            //Adress of Critical Section

}CRIT_SEC_COLLISION_EVENT_DATA, *PCRIT_SEC_COLLISION_EVENT_DATA;

//
// Additional Guid used for NTPERF
//

DEFINE_GUID( /* 0268a8b6-74fd-4302-9dd0-6e8f1795c0cf */
    PoolGuid,
    0x0268a8b6,
    0x74fd,
    0x4302,
    0x9d, 0xd0, 0x6e, 0x8f, 0x17, 0x95, 0xc0, 0xcf
    );

DEFINE_GUID( /* ce1dbfb4-137e-4da6-87b0-3f59aa102cbc */
    PerfinfoGuid,
    0xce1dbfb4,
    0x137e,
    0x4da6,
    0x87, 0xb0, 0x3f, 0x59, 0xaa, 0x10, 0x2c, 0xbc
    );

DEFINE_GUID( /* 222962ab-6180-4b88-a825-346b75f2a24a */
        HeapGuid,
        0x222962ab,
        0x6180,
        0x4b88,
        0xa8, 0x25, 0x34, 0x6b, 0x75, 0xf2, 0xa2, 0x4a
        );

DEFINE_GUID  ( /* 3AC66736-CC59-4cff-8115-8DF50E39816B */
        CritSecGuid,
        0x3ac66736,
        0xcc59, 
        0x4cff,
        0x81, 0x15, 0x8d, 0xf5, 0xe, 0x39, 0x81, 0x6b 
        );

DEFINE_GUID  ( /* E21D2142-DF90-4d93-BBD9-30E63D5A4AD6 */
        NtdllTraceGuid,
        0xe21d2142,
        0xdf90,
        0x4d93,
        0xbb, 0xd9, 0x30, 0xe6, 0x3d, 0x5a, 0x4a, 0xd6
        );

DEFINE_GUID( /* 89497f50-effe-4440-8cf2-ce6b1cdcaca7 */
    ObjectGuid,
    0x89497f50,
    0xeffe,
    0x4440,
    0x8c, 0xf2, 0xce, 0x6b, 0x1c, 0xdc, 0xac, 0xa7
    );

DEFINE_GUID( /* a9152f00-3f58-4bee-92a1-70c7d079d5dd */
    ModBoundGuid,
    0xa9152f00,
    0x3f58,
    0x4bee,
    0x92, 0xa1, 0x70, 0xc7, 0xd0, 0x79, 0xd5, 0xdd
    );

DEFINE_GUID ( /* E43445E0-0903-48c3-B878-FF0FCCEBDD04 */
    PowerGuid,
    0xe43445e0,
    0x903,
    0x48c3,
    0xb8, 0x78, 0xff, 0xf, 0xcc, 0xeb, 0xdd, 0x4
   );

DEFINE_GUID ( /* b2d14872-7c5b-463d-8419-ee9bf7d23e04 */
    DpcGuid,
    0xb2d14872,
    0x7c5b,
    0x463d,
    0x84, 0x19, 0xee, 0x9b, 0xf7, 0xd2, 0x3e, 0x04
   );

#endif // ifndef ETW_WOW6432

//
// The following flags denotes what Fields actually contains
//

#define ETW_NT_FLAGS_TRACE_HEADER           0X00000001      // Contiguous Event Trace Header
#define ETW_NT_FLAGS_TRACE_MESSAGE          0X00000002      // Trace Message

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceEvent(
    IN HANDLE TraceHandle,
    IN ULONG  Flags,
    IN ULONG  FieldSize,
    IN PVOID  Fields
    );

#endif // _NTWMI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\profiles.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    profiles.h

Abstract:

    This header file defines the Global definitions and interfaces for
    communicating the profile information between the loader, ntdetect and
    the kernel.

Author:

    Kenneth D. Ray (kenray) Dec 1997


Revision History:

--*/

#ifndef _PROFILES_H_
#define _PROFILES_H_

//
// Profile information stored in the registry, read from cmboot, and presented
// to the loader.
//


#define HW_PROFILE_STATUS_SUCCESS           0x0000
#define HW_PROFILE_STATUS_ALIAS_MATCH       0x0001
#define HW_PROFILE_STATUS_TRUE_MATCH        0x0002
#define HW_PROFILE_STATUS_PRISTINE_MATCH    0x0003
#define HW_PROFILE_STATUS_FAILURE           0xC001

//
// Docking States for the given profile
//
#define HW_PROFILE_DOCKSTATE_UNSUPPORTED       (0x0)
#define HW_PROFILE_DOCKSTATE_UNDOCKED          (0x1)
#define HW_PROFILE_DOCKSTATE_DOCKED            (0x2)
#define HW_PROFILE_DOCKSTATE_UNKNOWN           (0x3)
#define HW_PROFILE_DOCKSTATE_USER_SUPPLIED     (0x4)
#define HW_PROFILE_DOCKSTATE_USER_UNDOCKED     \
            (HW_PROFILE_DOCKSTATE_USER_SUPPLIED | HW_PROFILE_DOCKSTATE_UNDOCKED)
#define HW_PROFILE_DOCKSTATE_USER_DOCKED       \
            (HW_PROFILE_DOCKSTATE_USER_SUPPLIED | HW_PROFILE_DOCKSTATE_DOCKED)

//
// Capabilites of the given profile
//
#define HW_PROFILE_CAPS_VCR               0x0001 // As apposed to Surprize
#define HW_PROFILE_CAPS_DOCKING_WARM      0x0002
#define HW_PROFILE_CAPS_DOCKING_HOT       0x0004
#define HW_PROFILE_CAPS_RESERVED          0xFFF8

//
// Extension structure to the LOADER_PARAMETER_BLOCK in arc.h
//
typedef struct _PROFILE_PARAMETER_BLOCK {

    USHORT  Status;
    USHORT  Reserved;
    USHORT  DockingState;
    USHORT  Capabilities;
    ULONG   DockID;
    ULONG   SerialNumber;

} PROFILE_PARAMETER_BLOCK;

//
// Block to communcation the current ACPI docking state
//
typedef struct _PROFILE_ACPI_DOCKING_STATE {
    USHORT DockingState;
    USHORT SerialLength;
    WCHAR  SerialNumber[1];
} PROFILE_ACPI_DOCKING_STATE, *PPROFILE_ACPI_DOCKING_STATE;

//
// Desire verbose reporting/tracing of docking station related processing of
// hardware profiles in loader? This must be set to FALSE when compiling kernel
// to eliminate "unresolved external" errors from linker
//
// #define DOCKINFO_VERBOSE TRUE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\ntslist.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntslist.h

Abstract:

    This file exposes the internal s-list functionality for projects that need
    to run on down-level platforms.

Revision History:

--*/

#ifndef _NTSLIST_
#define _NTSLIST_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(NTSLIST_ASSERT)
#define NTSLIST_ASSERT(x) ASSERT(x)
#endif // !defined(NTSLIST_ASSERT)

#ifdef _NTSLIST_DIRECT_
#define INLINE_SLIST __inline
#define RtlInitializeSListHead       _RtlInitializeSListHead
#define _RtlFirstEntrySList          FirstEntrySList

PSINGLE_LIST_ENTRY
FirstEntrySList (
    const SLIST_HEADER *ListHead
    );

#define RtlInterlockedPopEntrySList  _RtlInterlockedPopEntrySList
#define RtlInterlockedPushEntrySList _RtlInterlockedPushEntrySList
#define RtlInterlockedFlushSList     _RtlInterlockedFlushSList
#define _RtlQueryDepthSList          RtlpQueryDepthSList
#else
#define INLINE_SLIST
#endif // _NTSLIST_DIRECT_


//
// Define forward referenced function prototypes.
//

VOID
RtlpInitializeSListHead (
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

WORD  
RtlpQueryDepthSList (
    IN PSLIST_HEADER SListHead
    );


INLINE_SLIST
VOID
RtlInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

{

    RtlpInitializeSListHead(SListHead);
    return;
}

INLINE_SLIST
PSINGLE_LIST_ENTRY
RtlInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    )

/*++

Routine Description:

    This function removes an entry from the front of a sequenced singly
    linked list so that access to the list is synchronized in a MP system.
    If there are no entries in the list, then a value of NULL is returned.
    Otherwise, the address of the entry that is removed is returned as the
    function value.

Arguments:

    ListHead - Supplies a pointer to the sequenced listhead from which
        an entry is to be removed.

Return Value:

   The address of the entry removed from the list, or NULL if the list is
   empty.

--*/

{

    DWORD Count;

    //
    // It is posible during the pop of the sequenced list that an access
    // violation can occur if a stale pointer is dereferenced. This is an
    // acceptable result and the operation can be retried.
    //
    // N.B. The count is used to distinguish the case where the list head
    //      itself causes the access violation and therefore no progress
    //      can be made by repeating the operation.
    //

    Count = 0;
    do {
        __try {
            return RtlpInterlockedPopEntrySList(ListHead);

        } __except (Count++ < 20 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            continue;
        }

    } while (TRUE);
}

INLINE_SLIST
PSINGLE_LIST_ENTRY
RtlInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This function inserts an entry at the head of a sequenced singly linked
    list so that access to the list is synchronized in an MP system.

Arguments:

    ListHead - Supplies a pointer to the sequenced listhead into which
        an entry is to be inserted.

    ListEntry - Supplies a pointer to the entry to be inserted at the
        head of the list.

Return Value:

    The address of the previous firt entry in the list. NULL implies list
    went from empty to not empty.

--*/

{
    NTSLIST_ASSERT(((ULONG_PTR)ListEntry & 0x7) == 0);

    return RtlpInterlockedPushEntrySList(ListHead, ListEntry);
}

INLINE_SLIST
PSINGLE_LIST_ENTRY
RtlInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    )

/*++

Routine Description:

    This function flushes the entire list of entries on a sequenced singly
    linked list so that access to the list is synchronized in a MP system.
    If there are no entries in the list, then a value of NULL is returned.
    Otherwise, the address of the firt entry on the list is returned as the
    function value.

Arguments:

    ListHead - Supplies a pointer to the sequenced listhead from which
        an entry is to be removed.

Return Value:

    The address of the entry removed from the list, or NULL if the list is
    empty.

--*/

{

    return RtlpInterlockedFlushSList(ListHead);
}


#ifdef __cplusplus
}
#endif

#endif /* _NTSLIST_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\plugin.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    plugin.h

Abstract:

    This file declares the migration DLL interface as needed
    by the code that implements the interface.  The structures
    and routines are for internal use by setup only.

Author:

    Mike Condra (mikeco) 14-Dec-1997

Revision History:

    jimschm 13-Jan-1998     Revised slightly for new implementation

--*/

#pragma once

//
// private
//

// ANSI!
#define PLUGIN_MIGRATE_DLL              "migrate.dll"
#define PLUGIN_QUERY_VERSION            "QueryVersion"
#define PLUGIN_INITIALIZE_9X            "Initialize9x"
#define PLUGIN_MIGRATE_USER_9X          "MigrateUser9x"
#define PLUGIN_MIGRATE_SYSTEM_9X        "MigrateSystem9x"
#define PLUGIN_INITIALIZE_NT            "InitializeNT"
#define PLUGIN_MIGRATE_USER_NT          "MigrateUserNT"
#define PLUGIN_MIGRATE_SYSTEM_NT        "MigrateSystemNT"

// TCHAR
#define PLUGIN_TEMP_DIR TEXT("setup\\win95upg")

//
// Vendor info struct
//

typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

typedef struct {
    WCHAR   CompanyName[256];
    WCHAR   SupportNumber[256];
    WCHAR   SupportUrl[256];
    WCHAR   InstructionsToUser[1024];
} VENDORINFOW, *PVENDORINFOW;

//
// public
//

// UNICODE!
typedef LONG (CALLBACK *P_INITIALIZE_NT)(
                          IN    LPCWSTR WorkingDirectory,
                          IN    LPCWSTR SourceDirectories,
                                LPVOID Reserved
                          );

typedef LONG (CALLBACK *P_MIGRATE_USER_NT)(
                          IN    HINF hUnattendInf,
                          IN    HKEY hkUser,
                          IN    LPCWSTR szUserName,
                                LPVOID Reserved
                          );

typedef LONG (CALLBACK *P_MIGRATE_SYSTEM_NT)(
                          IN    HINF hUnattendInf,
                                LPVOID Reserved
                          );


// ANSI!
typedef LONG (CALLBACK *P_QUERY_VERSION)(
                          OUT   LPCSTR *szProductID,
                          OUT   LPUINT plDllVersion,
                          OUT   LPINT  *pCodePageArray    OPTIONAL,
                          OUT   LPCSTR *ExeNamesBuf       OPTIONAL,
                          OUT   PVENDORINFO *VendorInfo
                          );

typedef LONG (CALLBACK *P_INITIALIZE_9X)(
                          IN    LPSTR  szWorkingDirectory OPTIONAL,
                          IN    LPSTR  SourcesDirectories,
                                LPVOID Reserved
                          );

typedef LONG (CALLBACK *P_MIGRATE_USER_9X)(
                          IN    HWND hwndParent         OPTIONAL,
                          IN    LPCSTR szUnattendFile,
                          IN    HKEY hkUser,
                          IN    LPCSTR szUserName       OPTIONAL,
                                LPVOID Reserved
                          );

typedef LONG (CALLBACK *P_MIGRATE_SYSTEM_9X)(
                          IN    HWND hwndParent         OPTIONAL,
                          IN    LPCSTR szUnattendFile,
                                LPVOID Reserved
                          );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\pmvdm.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    pmvdm.h

Abstract:

    This include file defines the interface between ProgMan and ntVDM

Author:

Revision History:

--*/




#ifndef _PMVDM_H_
#define _PMVDM_H_

// the progman has a special string passed down in lpReserved parameter to
// the CreateProcess API. The string has a format like:
//  "dde.%d,hotkey.%d,ntvdm.%d,"
// the last substring(ntvdm.%d,)is for progman to inform ntvdm what properties
// the program(the process being created) has.

// the program has Working(Current) Directory property.
#define PROPERTY_HAS_CURDIR		    0x01

// the program has Hotkey(Shortcut Key) property.
#define PROPERTY_HAS_HOTKEY                 0x02

// the program has  Description(Title) property
#define PROPERTY_HAS_TITLE		    0x04

#endif	    // ifndef _PMVDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\protocol.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    protocol.h

Abstract:

    This file defines the protocol specific constants for NT Lanman


Author:

    Larry Osterman (larryo) 5-Apr-1991

Revision History:

    5-Apr-1991  LarryO

        Created from LANMAN 1.2 protocol header.

--*/


#ifndef _PROTOCOL_
#define _PROCOTOL_

//
//
//      Define protocol names
//
//


//
//      PCNET1 is the original SMB protocol (CORE).
//

#define PCNET1          "PC NETWORK PROGRAM 1.0"

//
//      Some versions of the original MSNET defined this as an alternate
//      to the core protocol name
//

#define PCLAN1          "PCLAN1.0"

//
//      This is used for the MS-NET 1.03 product.  It defines Lock&Read,
//      Write&Unlock, and a special version of raw read and raw write.
//
#define MSNET103        "MICROSOFT NETWORKS 1.03"

//
//      This is the  DOS Lanman 1.0 specific protocol.  It is equivilant
//      to the LANMAN 1.0 protocol, except the server is required to
//      map errors from the OS/2 error to an appropriate DOS error.
//
#define MSNET30         "MICROSOFT NETWORKS 3.0"

//
//      This is the first version of the full LANMAN 1.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 2.0 document.
//

#define LANMAN10        "LANMAN1.0"

//
//      This is the first version of the full LANMAN 2.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 3.0 document.  Note
//      that the name is an interim protocol definition.  This is for
//      interoperability with IBM LAN SERVER 1.2
//

#define LANMAN12        "LM1.2X002"

//
//      This is the dos equivilant of the LANMAN12 protocol.  It is identical
//      to the LANMAN12 protocol, but the server will perform error mapping
//      to appropriate DOS errors.
//
#define DOSLANMAN12     "DOS LM1.2X002" /* DOS equivalant of above.  Final
                                         * string will be "DOS LANMAN2.0" */

//
//      Strings for LANMAN 2.1.
//
#define LANMAN21 "LANMAN2.1"
#define DOSLANMAN21 "DOS LANMAN2.1"

//
//       !!! Do not set to final protcol string until the spec
//           is cast in stone.
//
//       The SMB protocol designed for NT.  This has special SMBs
//       which duplicate the NT semantics.
//
#define NTLANMAN "NT LM 0.12"

#ifdef INCLUDE_SMB_IFMODIFIED
//
//       The SMB protocol designed for NT for SMBs post Win2000.
//
#define NTLANMAN2 "NT LM 0.13"
#endif

//
// The Cairo dialect
//
//
#define CAIROX   "Cairo 0.xa"


//
//      The XENIXCORE dialect is a bit special.  It is identical to core,
//      except user passwords are not to be uppercased before being shipped
//      to the server
//
#define XENIXCORE       "XENIX CORE"


//
//      Windows for Workgroups V1.0
//
#define WFW10           "Windows for Workgroups 3.1a"


#define PCNET1_SZ       22
#define PCLAN1_SZ        8

#define MSNET103_SZ     23
#define MSNET30_SZ      22

#define LANMAN10_SZ      9
#define LANMAN12_SZ      9

#define DOSLANMAN12_SZ  13



/*
 * Defines and data for Negotiate Protocol
 */
#define PC1             0
#define PC2             1
#define LM1             2
#define MS30            3
#define MS103           4
#define LM12            5
#define DOSLM12         6


/*  Protocol indexes definition.  */
#define PCLAN           1               /* PC Lan 1.0 & MS Lan 1.03 */
#define MSNT30          2               /* MS Net 3.0 redirector    */
#define DOSLM20         3               /* Dos LAN Manager 2.0      */
#define LANMAN          4               /* Lanman redirector        */
#define LANMAN20        5               /* Lan Manager 2.0          */

//
//  Protocol specific path constraints.
//

#define MAXIMUM_PATHLEN_LANMAN12        260
#define MAXIMUM_PATHLEN_CORE            128

#define MAXIMUM_COMPONENT_LANMAN12      254
#define MAXIMUM_COMPONENT_CORE          8+1+3 // 8.3 filenames.


/*NOINC*/
/*  CLTYPE_BASE should specify the name the first string in the file
    apperr2.h.  NUM_CLTYPES should be equal to the index of the last
    protocol just as is the case with the above definitions.  Also,
    this part should be ifdef'd so that only the files that also include
    the apperr2.h header will have it defined.  */

#ifdef APE2_CLIENT_DOWNLEVEL

#define CLTYPE_BASE     APE2_CLIENT_DOWNLEVEL
#define NUM_CLTYPES     LANMAN20

#endif

#endif  // _PROTOCOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\prefetch.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    prefetch.h

Abstract:

    This module contains the prefetcher definitions that are shared
    between the kernel mode component and the user mode service.

Author:

    Stuart Sechrest (stuartse)
    Cenk Ergan (cenke)
    Chuck Leinzmeier (chuckl)

Revision History:

*/

#ifndef _PREFETCH_H
#define _PREFETCH_H

//
// Prefetcher version. Be sure to update this after making any changes
// to any defines or structures in this file. When in doubt, update
// the version.
//

#define PF_CURRENT_VERSION       17

//
// Magic numbers to identify scenario dump files.
//

#define PF_SCENARIO_MAGIC_NUMBER               0x41434353  
#define PF_TRACE_MAGIC_NUMBER                  0x43435341  
#define PF_SYSINFO_MAGIC_NUMBER                0x6B756843  

//
// Define various limits used in sanity checking a prefetch scenario.
// Do not use these limits except for sanity checking. Most of these are
// very large values that are overkills.
//

#define PF_MAXIMUM_PAGES                       (128*1024)
#define PF_MAXIMUM_LOG_ENTRIES                 PF_MAXIMUM_PAGES
#define PF_MAXIMUM_SECTION_PAGES               8192
#define PF_MAXIMUM_SECTION_FILE_NAME_LENGTH    1024
#define PF_MAXIMUM_FILE_NAME_DATA_SIZE         (4*1024*1024)
#define PF_MAXIMUM_TIMER_PERIOD                (-1i64 * 10 * 60 * 1000 * 1000 * 10)
#define PF_MAXIMUM_ACTIVE_TRACES               4096
#define PF_MAXIMUM_SAVED_TRACES                4096

//
// This is the maximum size a scenario can grow to.
//

#define PF_MAXIMUM_SCENARIO_SIZE               (16*1024*1024)

//
// This is the maximum size a trace file can grow to. It is a function
// of the limits above.
//

#define PF_MAXIMUM_TRACE_SIZE                  PF_MAXIMUM_SCENARIO_SIZE

//
// Maximum allowed sections in a scenario should fit into a USHORT,
// sizeof the SectionId field in log entries.
//

#define PF_MAXIMUM_SECTIONS                    16384

//
// Maximum number of unique directories the files for a scenario can
// be in. This is a sanity check constant.
//

#define PF_MAXIMUM_DIRECTORIES                 (PF_MAXIMUM_SECTIONS * 32)

//
// Minimum size in pages for new scenarios. Smaller traces will be discarded.
//

#define PF_MIN_SCENARIO_PAGES                  32 

//
// Define various types of prefetch scenarios (starting from 0).
//

typedef enum _PF_SCENARIO_TYPE {
    PfApplicationLaunchScenarioType,
    PfSystemBootScenarioType,
    PfMaxScenarioType,
} PF_SCENARIO_TYPE;

//
// Define structure used to identify traces and prefetch instructions
// for a scenario. For application launch scenarios, it consists of
// the first characters in the executable image's name (NUL
// terminated) and a hash of its full path including the image
// name. Both path and image name are uppercased. On a file system
// with case sensitive names executables at the same path with the
// same name except for case will get the same id.
//

#define PF_SCEN_ID_MAX_CHARS                   29

typedef struct _PF_SCENARIO_ID {
    WCHAR ScenName[PF_SCEN_ID_MAX_CHARS + 1];
    ULONG HashId;
} PF_SCENARIO_ID, *PPF_SCENARIO_ID;

//
// This is the scenario name and hash code value for the boot scenario.
//

#define PF_BOOT_SCENARIO_NAME                  L"NTOSBOOT"
#define PF_BOOT_SCENARIO_HASHID                0xB00DFAAD

//
// Extension for the prefetch files.
//

#define PF_PREFETCH_FILE_EXTENSION             L"pf"

//
// A scenario id can be converted to a file name using the following
// sprintf format, using ScenName, HashId and prefetch file extension.
//

#define PF_SCEN_FILE_NAME_FORMAT               L"%ws-%08X.%ws"

//
// This is the maximum number of characters in a scenario file name
// (not path) given the format and definitions above with some head
// room.
//

#define PF_MAX_SCENARIO_FILE_NAME              50

//
// Define the number of periods over which we track page faults for a
// scenario. The duration of the periods depend on the scenario type.
//

#define PF_MAX_NUM_TRACE_PERIODS               10

//
// Define maximum number of characters for the relative path from
// system root to where prefetch files can be found.
//

#define PF_MAX_PREFETCH_ROOT_PATH              32 

//
// Define maximum number of characters for the list of known hosting
// applications.
//

#define PF_HOSTING_APP_LIST_MAX_CHARS          128

//
// Define invalid page index used to terminate a section's page record
// lists in scenarios.
//

#define PF_INVALID_PAGE_IDX                    (-1)

//
// Define the number of launches of the scenario we keep track of for
// usage history of pages. In every page record there is a bit field
// of this size. Do not grow this over 32, size of (ULONG).
//

#define PF_PAGE_HISTORY_SIZE                   8

//
// Define the maximum and minimum scenario sensitivity. A page has to be 
// used in this many of the launches in the history for it to be prefetch.
//

#define PF_MAX_SENSITIVITY                     PF_PAGE_HISTORY_SIZE
#define PF_MIN_SENSITIVITY                     1

//
// Define structure for kernel trace dumps. The dump is all in a
// single contiguous buffer at the top of which is the trace header
// structure.  The trace header contains offsets to an array of log
// entries in the buffer and to a list of section info
// structures. Section info structures come one after the other
// containing file names. There is a log entry for every page
// fault. Every log entry has a SectionId that is the number of the
// section info structure that contains the name of the file the fault
// was to. These are followed by variable sized volumeinfo entries
// that describe the volumes on which the sections in the trace are
// located.
//

//
// NOTE: Do not forget about alignment issues on 64 bit platforms as
// you modify these structures or add new ones.
//

//
// One of these is logged for every page fault.
//

typedef struct _PF_LOG_ENTRY {

    //
    // File offset of the page that was faulted.
    //
    
    ULONG FileOffset;

    //
    // Index into the section info table in the trace header that helps 
    // us identify the file.
    //

    USHORT SectionId;

    //
    // Whether this page was faulted as an image page or data page.
    //

    BOOLEAN IsImage;

    //
    // Whether this is a fault that happened in the process in which
    // the scenario is active. We may log faults in special system
    // process as a part of this scenario.
    //

    BOOLEAN InProcess;

} PF_LOG_ENTRY, *PPF_LOG_ENTRY;

//
// This structure associates a page fault with a file name.
// Note that because we lay these structures right after each other in 
// the trace buffer, if you add a new field which has an alignment  
// greater than 2 bytes, we'll hit alignment problems.
//

typedef struct _PF_SECTION_INFO {

    //
    // Number of characters in the file name, excluding terminating NUL.
    //

    USHORT FileNameLength;

    //
    // Whether this section is for filesystem metafile (e.g. directory.)
    //

    USHORT Metafile:1;
    USHORT Unused:15;

    //
    // Variable length file name buffer including terminating NUL.
    //

    WCHAR FileName[1];

} PF_SECTION_INFO, *PPF_SECTION_INFO;

//
// This structure describes a volume on which the sections in the
// trace are on.
//

typedef struct _PF_VOLUME_INFO {

    //
    // Volume creation time and serial number used to identify the
    // volume in case its NT/device path e.g. \Device\HarddiskVolume1
    // changes.
    //

    LARGE_INTEGER CreationTime;
    ULONG SerialNumber;

    //
    // Current NT/device path for the volume and its length in
    // characters excluding terminating NUL.
    //

    ULONG VolumePathLength;
    WCHAR VolumePath[1];

} PF_VOLUME_INFO, *PPF_VOLUME_INFO;

//
// This is the trace header.
//

typedef struct _PF_TRACE_HEADER {

    //
    // Prefetcher version.
    //

    ULONG Version;

    //
    // Magic number identifying this as a trace.
    //

    ULONG MagicNumber;

    //
    // Total size of the trace buffer in bytes.
    //

    ULONG Size;

    //
    // Scenario id for which this trace was acquired.
    //

    PF_SCENARIO_ID ScenarioId;

    //
    // Type of this scenario.
    //

    PF_SCENARIO_TYPE ScenarioType;

    //
    // Offset from the start of the trace buffer where logged 
    // entries can be found and the number of them.
    //
    
    ULONG TraceBufferOffset;
    ULONG NumEntries;

    //
    // Offset from the start of the trace buffer where the section and
    // file name information is located.
    //
    
    ULONG SectionInfoOffset;
    ULONG NumSections;

    //
    // Offset from the start of the trace buffer where the volume
    // information is located, the number of volumes and the total
    // size of the volume information block.
    //
    
    ULONG VolumeInfoOffset;
    ULONG NumVolumes;
    ULONG VolumeInfoSize;

    //
    // Distribution of the pagefaults over the duration of the trace. 
    // PeriodLength is in 100ns.
    //

    LONGLONG PeriodLength;
    ULONG FaultsPerPeriod[PF_MAX_NUM_TRACE_PERIODS];

    //
    // System time when we started tracing this scenario as
    // returned by KeQuerySystemTime.
    //

    LARGE_INTEGER LaunchTime;

} PF_TRACE_HEADER, *PPF_TRACE_HEADER;

//
// Define structure for prefetch scenario instructions. The
// instructions are all in a single contiguous buffer at the top of
// which is the scenario header structure. The header contains offsets
// to arrays of section and page records as well as a file name data
// buffer. Every section contains an offset into the file name data
// buffer where the file name for that section is located. It also has
// an index into the page record table where the first page for that
// section is located. Subsequent pages of the section are linked
// through indices embedded in the page records. 
//
// This data is followed by the file system metadata prefetch
// instructions so opening the files will not be as expensive. These
// instructions consist of metadata records that describe the metadata
// that needs to be prefetched on the volumes containing the files to
// be prefetched.
//

//
// NOTE: Do not forget about alignment issues on 64 bit platforms as
// you modify these structures or add new ones.
//

//
// Define structure used for describing pages to be prefetched.
//

typedef struct _PF_PAGE_RECORD {
    
    //
    // Index of the next page for this section in the page record
    // table or PF_INVALID_PAGE_IDX to terminate the list.
    //

    LONG NextPageIdx;

    //
    // File offset of the page that was faulted.
    //

    ULONG FileOffset;

    //
    // Whether we should just ignore this page record.
    //

    ULONG IsIgnore:1;

    //
    // Whether this page was faulted as an image page.
    //

    ULONG IsImage:1;

    //
    // Whether this page was faulted as a data page.
    //

    ULONG IsData:1;

    //
    // The following fields are only used by the service:
    //

    //
    // Whether this page was used in the last PF_PAGE_HISTORY_SIZE
    // launches of the scenario. The least significant bit stands for
    // the most recent launch. If a bit is on, it means the page was
    // used in that launch.
    //

    ULONG UsageHistory:PF_PAGE_HISTORY_SIZE;

    //
    // Whether this page was prefetched in the last PF_PAGE_HISTORY_SIZE
    // launches of the scenario. The least significant bit stands for
    // the most recent launch. If a bit is on, it means the page was
    // prefetched in that launch.
    //

    ULONG PrefetchHistory:PF_PAGE_HISTORY_SIZE;

} PF_PAGE_RECORD, *PPF_PAGE_RECORD;

//
// Define structure used for describing sections to prefetch from.
//

typedef struct _PF_SECTION_RECORD {
    
    //
    // Index of the first page for this section in the page record
    // table or PF_INVALID_PAGE_IDX to terminate the list. That page
    // will contain the index for the next page etc.
    //
    
    LONG FirstPageIdx;

    //
    // Total number of page records for this section.
    //

    ULONG NumPages;

    //
    // Byte offset relative to the beginning of the file name data
    // block where the file path for this section can be found, and
    // the number of characters in the file path excluding NUL.
    //

    ULONG FileNameOffset;  
    ULONG FileNameLength;

    //
    // Do we just ignore this section record.
    //

    ULONG IsIgnore:1;

    //
    // Was this section accessed through an image mapping.
    //

    ULONG IsImage:1;

    //
    // Was this section accessed through a data mapping.
    //
    
    ULONG IsData:1;

} PF_SECTION_RECORD, *PPF_SECTION_RECORD;

//
// Define a counted string structure. It can be used to put paths one
// after the other in the scenario/trace file. Its count coming before
// the string would help us verify that the strings are terminated and
// within bounds. The string is still NUL terminated.
//

typedef struct _PF_COUNTED_STRING {
    
    //
    // Number of characters excluding the terminating NUL. Making this
    // a USHORT helps alignment when stacking counted strings one
    // after the other.
    //

    USHORT Length;
    
    //
    // The NUL terminated string. 
    //
    
    WCHAR String[1];

} PF_COUNTED_STRING, *PPF_COUNTED_STRING;

//
// Define structure used for describing the filesystem metadata that
// should be prefetched before prefetching the scenario.
//

typedef struct _PF_METADATA_RECORD {

    //
    // Byte offset relative to the beginning of metadata prefetch info
    // for the NUL terminated volume name on which the metadata to
    // prefetch resides. VolumeNameLength is in characters excluding
    // the terminating NUL.
    //
    
    ULONG VolumeNameOffset;
    ULONG VolumeNameLength;

    //
    // In case volume's NT/device path changes, these magics are used
    // to identify the volume.
    //
    
    LARGE_INTEGER CreationTime;
    ULONG SerialNumber;
    
    //
    // Byte offset relative to the beginning of metadata prefetch info
    // for the input buffer to FSCTL to prefetch the metadata and its size.
    //

    ULONG FilePrefetchInfoOffset;
    ULONG FilePrefetchInfoSize;

    //
    // Byte offset relative to the beginning of metadata prefetch info
    // for the full paths of directories (PF_COUNTED_STRING's) that
    // need to be prefetched on this volume. The paths come one after
    // the other in the buffer.
    //

    ULONG DirectoryPathsOffset;
    ULONG NumDirectories;

} PF_METADATA_RECORD, *PPF_METADATA_RECORD;

//
// This is the scenario header.
//

typedef struct _PF_SCENARIO_HEADER {
    
    //
    // Prefetcher version.
    //

    ULONG Version;      

    //
    // Magic number identifying this as a scenario.
    //

    ULONG MagicNumber;

    //
    // This is the version of the prefetcher maintenance service that
    // generated this file.
    //

    ULONG ServiceVersion;

    //
    // Total size of the scenario.
    //

    ULONG Size;

    //
    // Scenario id identifying the scenario.
    //

    PF_SCENARIO_ID ScenarioId;

    //
    // Type of this scenario.
    //

    PF_SCENARIO_TYPE ScenarioType;

    //
    // Offset from the start of the scenario buffer where the section
    // info table is located. 
    //
    
    ULONG SectionInfoOffset;
    ULONG NumSections;

    //
    // Offset from the start of the scenario buffer where the page
    // records are located.
    //

    ULONG PageInfoOffset;
    ULONG NumPages;

    //
    // Offset from the start of the scenario buffer where file names
    // are located.
    //

    ULONG FileNameInfoOffset;
    ULONG FileNameInfoSize;

    //
    // Offset from the start of the scenario buffer where file system
    // metadata prefetch record table is located, number of these
    // structures and the size of the whole metadata prefetch
    // information.
    //

    ULONG MetadataInfoOffset;
    ULONG NumMetadataRecords;
    ULONG MetadataInfoSize;

    //
    // The following three fields are used to determine if a scenario
    // is getting launched too frequently (e.g. multiple times a
    // second/minute) for prefetching to be useful.
    //

    //
    // This is the KeQuerySystemTime time of the last launch of this
    // scenario for which these scenario instructions were updated.
    //

    LARGE_INTEGER LastLaunchTime;

    //
    // If this much time (in 100ns) has not passed since last launch
    // time, we should not prefetch this scenario.
    //

    LARGE_INTEGER MinRePrefetchTime;

    //
    // If this much time (in 100ns) has not passed since last launch
    // time, we should not trace this scenario.
    //

    LARGE_INTEGER MinReTraceTime;

    //
    // The following fields are used only by the service:
    //

    //
    // Number of times this scenario has been launched.
    //

    ULONG NumLaunches;

    //
    // A page should be used at least this many times in the last
    // PF_PAGE_HISTORY_SIZE launches to be prefetched. Otherwise the
    // ignore bit on the page is set. The kernel does not have look at
    // this variable. The sensitivity is adjusted dynamically by the
    // service according to the hit rate of the prefetched pages.
    //

    ULONG Sensitivity;

} PF_SCENARIO_HEADER, *PPF_SCENARIO_HEADER;

//
// Definitions for the interface between the kernel and the service.
//

//
// This is the name of the event that will be signaled by the kernel
// when there are new scenario traces for the service.
//

#define PF_COMPLETED_TRACES_EVENT_NAME         L"\\BaseNamedObjects\\PrefetchTracesReady"
#define PF_COMPLETED_TRACES_EVENT_WIN32_NAME   L"PrefetchTracesReady"

//
// This is the name of the event that gets signaled by the kernel when
// parameters have changed.
//

#define PF_PARAMETERS_CHANGED_EVENT_NAME         L"\\BaseNamedObjects\\PrefetchParametersChanged"
#define PF_PARAMETERS_CHANGED_EVENT_WIN32_NAME   L"PrefetchParametersChanged"

//
// Define sub information classes for SystemPrefetcherInformation.
//

typedef enum _PREFETCHER_INFORMATION_CLASS {
    PrefetcherRetrieveTrace = 1,
    PrefetcherSystemParameters,
    PrefetcherBootPhase,
} PREFETCHER_INFORMATION_CLASS;

//
// This is the input structure to NtQuerySystemInformation /
// NtSetSystemInformation for the SystemPrefetcherInformation
// information class.
//

typedef struct _PREFETCHER_INFORMATION {
    
    //
    // These two fields help make sure caller does not make bogus
    // requests and keep track of version for this kernel interface.
    //

    ULONG Version;
    ULONG Magic;

    //
    // Sub information class.
    //

    PREFETCHER_INFORMATION_CLASS PrefetcherInformationClass;

    //
    // Input / Output buffer and its length.
    //

    PVOID PrefetcherInformation;
    ULONG PrefetcherInformationLength;

} PREFETCHER_INFORMATION, *PPREFETCHER_INFORMATION;

//
// Define boot phase id's for use with PrefetcherBootPhase information
// subclass.
//

typedef enum _PF_BOOT_PHASE_ID {
    PfKernelInitPhase                            =   0,
    PfBootDriverInitPhase                        =  90,
    PfSystemDriverInitPhase                      = 120,
    PfSessionManagerInitPhase                    = 150,
    PfSMRegistryInitPhase                        = 180,
    PfVideoInitPhase                             = 210,
    PfPostVideoInitPhase                         = 240,
    PfBootAcceptedRegistryInitPhase              = 270,
    PfUserShellReadyPhase                        = 300,
    PfMaxBootPhaseId                             = 900,
} PF_BOOT_PHASE_ID, *PPF_BOOT_PHASE_ID;

//
// Define system wide prefetch parameters structure.
//

//
// Whether a particular type of prefetching is enabled, disabled or
// just not specified.
//

typedef enum _PF_ENABLE_STATUS {
    PfSvNotSpecified,
    PfSvEnabled,
    PfSvDisabled,
    PfSvMaxEnableStatus
} PF_ENABLE_STATUS, *PPF_ENABLE_STATUS;

//
// Define limits structure for different prefetch types.
//

typedef struct _PF_TRACE_LIMITS {
    
    //
    // Maximum number of pages that can be logged.
    //

    ULONG MaxNumPages;
    
    //
    // Maximum number of sections that can be logged.
    //

    ULONG MaxNumSections;

    //
    // Period for the trace timer. The trace times out after
    // PF_MAX_NUM_TRACE_PERIODS. This is in 100ns. It should be
    // negative denoting to the system that periods are relative.
    //
    
    LONGLONG TimerPeriod;

} PF_TRACE_LIMITS, *PPF_TRACE_LIMITS;

//
// System wide prefetch parameters structure.
//

typedef struct _PF_SYSTEM_PREFETCH_PARAMETERS {

    //
    // Whether different types of prefetching are enabled or not.
    //    
    
    PF_ENABLE_STATUS EnableStatus[PfMaxScenarioType];

    //
    // Limits for different prefetch types.
    //

    PF_TRACE_LIMITS TraceLimits[PfMaxScenarioType];

    //
    // Maximum number of active prefetch traces.
    //

    ULONG MaxNumActiveTraces;

    //
    // Maximum number of saved completed prefetch traces. 
    // Note that this should be greater than the number of boot phases,
    // since the service won't be started until later in boot.
    //

    ULONG MaxNumSavedTraces;

    //
    // Path to directory relative to system root where prefetch
    // instructions can be found.
    //

    WCHAR RootDirPath[PF_MAX_PREFETCH_ROOT_PATH];

    //
    // Comma seperated list of hosting applications (e.g. dllhost.exe, mmc.exe,
    // rundll32.exe ...) for which we create scenario ID's based on command line 
    // as well.
    //

    WCHAR HostingApplicationList[PF_HOSTING_APP_LIST_MAX_CHARS];

} PF_SYSTEM_PREFETCH_PARAMETERS, *PPF_SYSTEM_PREFETCH_PARAMETERS;

//
// Useful macros.
//

//
// Macros for alignment. Assumptions are that alignments are a power
// of 2 and allocators (malloc, heap, pool etc) allocate chunks with
// bigger alignment than what you need. You should verify these by
// using asserts and the "power of two" macro below. 
//

//
// Determines whether the value is a power of two. Zero is not a power
// of 2. The value should be of an unsigned type that supports bit
// operations, e.g. not a pointer.
//

#define PF_IS_POWER_OF_TWO(Value)           \
  ((Value) && !((Value) & (Value - 1)))

//
// Return value is the Pointer increased to be aligned with
// Alignment. Alignment must be a power of 2.
//

#define PF_ALIGN_UP(Pointer, Alignment)     \
  ((PVOID)(((ULONG_PTR)(Pointer) + (Alignment) - 1) & (~((ULONG_PTR)(Alignment) - 1))))

//
// Verification code shared with the kernel mode component. This code
// has to be kept in sync copy & paste.
//

BOOLEAN
PfWithinBounds(
    PVOID Pointer,
    PVOID Base,
    ULONG Length
    );

BOOLEAN
PfVerifyScenarioId (
    PPF_SCENARIO_ID ScenarioId
    );

BOOLEAN
PfVerifyScenarioBuffer(
    PPF_SCENARIO_HEADER Scenario,
    ULONG BufferSize,
    PULONG FailedCheck
    );

BOOLEAN
PfVerifyTraceBuffer(
    PPF_TRACE_HEADER Trace,
    ULONG BufferSize,
    PULONG FailedCheck
    );

#endif // _PREFETCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\remboot.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    remboot.h

Abstract:

    This file contains definitions related to remote install.

Author:

    Adam Barr (adamba) 30-Dec-1997

Revision History:

--*/

#ifndef _REMBOOT_H_
#define _REMBOOT_H_

#if defined(REMOTE_BOOT)
//
// Location of CSC and RBR directories.
//

#define REMOTE_BOOT_IMIRROR_PATH_W L"\\IntelliMirror Cache"
#define REMOTE_BOOT_IMIRROR_PATH_A  "\\IntelliMirror Cache"

#define REMOTE_BOOT_CSC_SUBDIR_W   L"\\CSC"                 // relative to IMIRROR_PATH
#define REMOTE_BOOT_CSC_SUBDIR_A    "\\CSC"                 // relative to IMIRROR_PATH

#define REMOTE_BOOT_RBR_SUBDIR_W   L"\\RBR"                 // relative to IMIRROR_PATH
#define REMOTE_BOOT_RBR_SUBDIR_A    "\\RBR"                 // relative to IMIRROR_PATH
#endif // defined(REMOTE_BOOT)

//
// Directory under \RemoteInstall\Setup\<language> where we put
// installation images.
//
#define REMOTE_INSTALL_SHARE_NAME_W L"REMINST"
#define REMOTE_INSTALL_SHARE_NAME_A  "REMINST"

#define REMOTE_INSTALL_SETUP_DIR_W  L"Setup"
#define REMOTE_INSTALL_SETUP_DIR_A   "Setup"

#define REMOTE_INSTALL_IMAGE_DIR_W  L"Images"
#define REMOTE_INSTALL_IMAGE_DIR_A   "Images"

#define REMOTE_INSTALL_TOOLS_DIR_W  L"Tools"
#define REMOTE_INSTALL_TOOLS_DIR_A   "Tools"

#define REMOTE_INSTALL_TEMPLATES_DIR_W  L"Templates"
#define REMOTE_INSTALL_TEMPLATES_DIR_A   "Templates"

//
// Size of the various components in a secret.
//

#define LM_OWF_PASSWORD_SIZE  16
#define NT_OWF_PASSWORD_SIZE  16
#define RI_SECRET_DOMAIN_SIZE  32
#define RI_SECRET_USER_SIZE 32
#define RI_SECRET_SID_SIZE 28
#if defined(REMOTE_BOOT)
#define RI_SECRET_RESERVED_SIZE (64 + sizeof(ULONG))
#endif // defined(REMOTE_BOOT)

//
// The string that is stored in the signature.
//

#define RI_SECRET_SIGNATURE  "NTRI"

//
// Structure that holds a secret.
//

typedef struct _RI_SECRET {
    UCHAR Signature[4];
    ULONG Version;
    UCHAR Domain[RI_SECRET_DOMAIN_SIZE];
    UCHAR User[RI_SECRET_USER_SIZE];
    UCHAR LmEncryptedPassword1[LM_OWF_PASSWORD_SIZE];
    UCHAR NtEncryptedPassword1[NT_OWF_PASSWORD_SIZE];
#if defined(REMOTE_BOOT)
    UCHAR LmEncryptedPassword2[LM_OWF_PASSWORD_SIZE];
    UCHAR NtEncryptedPassword2[NT_OWF_PASSWORD_SIZE];
#endif // defined(REMOTE_BOOT)
    UCHAR Sid[RI_SECRET_SID_SIZE];
#if defined(REMOTE_BOOT)
    UCHAR Reserved[RI_SECRET_RESERVED_SIZE];
#endif // defined(REMOTE_BOOT)
} RI_SECRET, *PRI_SECRET;


//
// FSCTLs the redir supports for accessing the secret.
//

#define IOCTL_RDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _RDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_RDR_BASE, request, method, access)

#define FSCTL_LMMR_RI_INITIALIZE_SECRET        _RDR_CONTROL_CODE(250, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if defined(REMOTE_BOOT)
#define FSCTL_LMMR_RI_CHECK_FOR_NEW_PASSWORD   _RDR_CONTROL_CODE(251, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMMR_RI_IS_PASSWORD_SETTABLE     _RDR_CONTROL_CODE(252, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LMMR_RI_SET_NEW_PASSWORD         _RDR_CONTROL_CODE(253, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif // defined(REMOTE_BOOT)

//used in the remoteboot command console case
#define IOCTL_LMMR_USEKERNELSEC                _RDR_CONTROL_CODE(254, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// Structure used by these IOCTLs.
//

typedef struct _LMMR_RI_INITIALIZE_SECRET {
    RI_SECRET Secret;
#if defined(REMOTE_BOOT)
    BOOLEAN UsePassword2;
#endif // defined(REMOTE_BOOT)
} LMMR_RI_INITIALIZE_SECRET, *PLMMR_RI_INITIALIZE_SECRET;

#if defined(REMOTE_BOOT)
typedef struct _LMMR_RI_CHECK_FOR_NEW_PASSWORD {
    ULONG Length;   // in bytes
    UCHAR Data[1];
} LMMR_RI_CHECK_FOR_NEW_PASSWORD, *PLMMR_RI_CHECK_FOR_NEW_PASSWORD;

typedef struct _LMMR_RI_SET_NEW_PASSWORD {
    ULONG Length1;  // in bytes
    ULONG Length2;  // in bytes -- 0 if no second password is provided
    UCHAR Data[1];  // if present, second password starts Length1 bytes in
} LMMR_RI_SET_NEW_PASSWORD, *PLMMR_RI_SET_NEW_PASSWORD;
#endif // defined(REMOTE_BOOT)

//
//  The format of the IMirror.dat file that we write out
//

#define IMIRROR_DAT_FILE_NAME L"IMirror.dat"

typedef struct _MIRROR_VOLUME_INFO_FILE {
    ULONG   MirrorTableIndex;
    WCHAR   DriveLetter;
    UCHAR   PartitionType;
    BOOLEAN PartitionActive;
    BOOLEAN IsBootDisk;
    BOOLEAN CompressedVolume;
    ULONG   MirrorUncLength;
    ULONG   MirrorUncPathOffset;
    ULONG   DiskNumber;
    ULONG   PartitionNumber;
    ULONG   DiskSignature;
    ULONG   BlockSize;
    ULONG   LastUSNMirrored;
    ULONG   FileSystemFlags;
    WCHAR   FileSystemName[16];
    ULONG   VolumeLabelLength;
    ULONG   VolumeLabelOffset;
    ULONG   NtNameLength;
    ULONG   NtNameOffset;
    ULONG   ArcNameLength;
    ULONG   ArcNameOffset;
    LARGE_INTEGER DiskSpaceUsed;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionSize;
} MIRROR_VOLUME_INFO_FILE, *PMIRROR_VOLUME_INFO_FILE;

#define IMIRROR_CURRENT_VERSION 2

typedef struct _MIRROR_CFG_INFO_FILE {
    ULONG   MirrorVersion;
    ULONG   FileLength;
    ULONG   NumberVolumes;
    ULONG   SystemPathLength;
    ULONG   SystemPathOffset;
    BOOLEAN SysPrepImage;   // if FALSE, means it's a mirror
    BOOLEAN Debug;
    ULONG   MajorVersion;
    ULONG   MinorVersion;
    ULONG   BuildNumber;
    ULONG   KernelFileVersionMS;
    ULONG   KernelFileVersionLS;
    ULONG   KernelFileFlags;
    ULONG   CSDVersionLength;
    ULONG   CSDVersionOffset;
    ULONG   ProcessorArchitectureLength;
    ULONG   ProcessorArchitectureOffset;
    ULONG   CurrentTypeLength;
    ULONG   CurrentTypeOffset;
    ULONG   HalNameLength;
    ULONG   HalNameOffset;
    MIRROR_VOLUME_INFO_FILE Volumes[1];
} MIRROR_CFG_INFO_FILE, *PMIRROR_CFG_INFO_FILE;

//
//  The format of the alternate data stream on sysprep files containing
//  additional client disk info.
//

#define IMIRROR_ACL_STREAM_NAME L":$SYSPREP"
#define IMIRROR_ACL_STREAM_VERSION 2


typedef struct _MIRROR_ACL_STREAM {
    ULONG   StreamVersion;
    ULONG   StreamLength;
    LARGE_INTEGER ChangeTime;
    ULONG   ExtendedAttributes;
    ULONG   SecurityDescriptorLength;
    //      SecurityDescriptor of SecurityDescriptorLength
} MIRROR_ACL_STREAM, *PMIRROR_ACL_STREAM;


#define IMIRROR_SFN_STREAM_NAME L":$SYSPREPSFN"
#define IMIRROR_SFN_STREAM_VERSION 1

typedef struct _MIRROR_SFN_STREAM {
    ULONG   StreamVersion;
    ULONG   StreamLength;
    // short file name of stream length;    
} MIRROR_SFN_STREAM, *PMIRROR_SFN_STREAM;


//
// Service Control Messages to BINLSVC
//
#define BINL_SERVICE_REREAD_SETTINGS 128

//
// UI constants
//
// MAX_DIRECTORY_CHAR_COUNT theoretical limit is 68 for TFTP, but we keep
// it lower here because certain buffers in the kernel, setupdd, etc.,
// are statically allocated too small. Rather than try to fix all these
// buffers now, we are making the enforced limit lower. (40 should still
// be plenty big!) After W2K, we can look at fixing the bad code.
//
#define REMOTE_INSTALL_MAX_DIRECTORY_CHAR_COUNT     40
#define REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT   66
#define REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT      261


//
//  RISETUP has to call into BINLSVC to have it return the list of
//  files required by all the net card INFs in a given directory.  Here's
//  the necessary stuff for this functionality.
//
//  If you specify a non-zero value, we bail.
//

typedef ULONG (*PNETINF_CALLBACK)( PVOID Context, PWCHAR InfName, PWCHAR FileName );

typedef ULONG (*PNETINFENUMFILES)(
    PWCHAR FlatDirectory,           // all the way to "i386"
    ULONG Architecture,             // PROCESSOR_ARCHITECTURE_XXXXX
    PVOID Context,
    PNETINF_CALLBACK CallBack );

#define NETINFENUMFILESENTRYPOINT "NetInfEnumFiles"

ULONG
NetInfEnumFiles (
    PWCHAR FlatDirectory,           // all the way to "i386"
    ULONG Architecture,             // PROCESSOR_ARCHITECTURE_XXXXX
    PVOID Context,
    PNETINF_CALLBACK CallBack
    );

#endif // _REMBOOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\pnpmgr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpmgr.h

Abstract:

    Internal definitions used by kernel-mode and user-mode pnp managers.

Author:

    Paula Tomlinson (paulat) 06-Feb-1997

Revision History:

--*/


#ifndef _PNPMGR_
#define _PNPMGR_

//
// Make sure that stardand defines (everything but guids, basically), don't
// get included twice.
//

//
// This controls how long we wait (in milliseconds) for an app
// to respond to a query type device change message.
//

#define PNP_NOTIFY_TIMEOUT         30000        // 30 seconds

//
// The following are Windows NT specific registry keys that both the
// user-mode pnp manager and kernel-mode pnp manager need to access.
//

#define REGSTR_KEY_DELETEDDEVICE        TEXT("Deleted Device IDs")
#define REGSTR_KEY_LOGCONF              TEXT("LogConf")
#define REGSTR_KEY_DEVICECONTROL        TEXT("Control")
#define REGSTR_KEY_CURRENT_DOCK_INFO    TEXT("CurrentDockInfo")
#define REGSTR_VAL_Count                TEXT("Count")        // add REGSTR_VALUE_COUNT;
#define REGSTR_VAL_MOVEDTO              TEXT("MovedTo")      // add REGSTR_VAL_MOVEDTO;
#define REGSTR_VAL_PNPSERVICETYPE       TEXT("PlugPlayServiceType")
#define REGSTR_VAL_BOOTCONFIG           TEXT("BootConfig")
#define REGSTR_VAL_ALLOCCONFIG          TEXT("AllocConfig")
#define REGSTR_VAL_FORCEDCONFIG         TEXT("ForcedConfig")
#define REGSTR_VAL_OVERRIDECONFIGVECTOR TEXT("OverrideConfigVector")
#define REGSTR_VAL_BASICCONFIGVECTOR    TEXT("BasicConfigVector")
#define REGSTR_VAL_FILTEREDCONFIGVECTOR TEXT("FilteredConfigVector")
#define REGSTR_VAL_ACTIVESERVICE        TEXT("ActiveService")
#define REGSTR_VAL_PHANTOM              TEXT("Phantom")
#define REGSTR_VAL_FIRMWAREIDENTIFIED   TEXT("FirmwareIdentified")
#define REGSTR_VAL_FIRMWAREMEMBER       TEXT("FirmwareMember")
#define REGSTR_VAL_EJECTABLE_DOCKS      TEXT("EjectableDocks")
#define REGSTR_VALUE_UNIQUE_PARENT_ID   TEXT("UniqueParentID")
#define REGSTR_VALUE_PARENT_ID_PREFIX   TEXT("ParentIdPrefix")


//
// Device description to be displayed by newdev during server-side device
// installation (this value entry is located in the device's hardware key).
//
#define REGSTR_VAL_NEW_DEVICE_DESC       TEXT("NewDeviceDesc")

//
// Maximum length for the name of a component that has vetoed a pnp
// notification event.
//
#define MAX_VETO_NAME_LENGTH    512

#endif // _PNPMGR_



#ifndef FAR
#define FAR
#endif

//
// Private device events
//
DEFINE_GUID( GUID_DEVICE_ARRIVAL,                   0xcb3a4009L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATED,                0xcb3a400AL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATE_REQUEST,         0xcb3a400BL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_START_REQUEST,             0xcb3a400CL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_REMOVE_PENDING,            0xcb3a400DL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_QUERY_AND_REMOVE,          0xcb3a400EL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_EJECT,                     0xcb3a400FL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_NOOP,                      0xcb3a4010L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_SURPRISE_REMOVAL,          0xce5af000L, 0x80dd, 0x11d2, 0xa8, 0x8d, 0x00, 0xa0, 0xc9, 0x69, 0x6b, 0x4b);
DEFINE_GUID( GUID_DEVICE_SAFE_REMOVAL,              0x8fbef967L, 0xd6c5, 0x11d2, 0x97, 0xb5, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);
DEFINE_GUID( GUID_DEVICE_EJECT_VETOED,              0xcf7b71e8L, 0xd8fd, 0x11d2, 0x97, 0xb5, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);
DEFINE_GUID( GUID_DEVICE_REMOVAL_VETOED,            0x60dbd5faL, 0xddd2, 0x11d2, 0x97, 0xb8, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);
DEFINE_GUID( GUID_DEVICE_WARM_EJECT_VETOED,         0xcbf4c1f9L, 0x18d5, 0x11d3, 0x97, 0xdb, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);
DEFINE_GUID( GUID_DEVICE_STANDBY_VETOED,            0x03b21c13L, 0x18d6, 0x11d3, 0x97, 0xdb, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);
DEFINE_GUID( GUID_DEVICE_HIBERNATE_VETOED,          0x61173ad9L, 0x194f, 0x11d3, 0x97, 0xdc, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);
DEFINE_GUID( GUID_DEVICE_KERNEL_INITIATED_EJECT,    0x14689b54L, 0x0703, 0x11d3, 0x97, 0xd2, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e);

//
// Private driver events
//
DEFINE_GUID( GUID_DRIVER_BLOCKED,                   0x1bc87a21L, 0xa3ff, 0x47a6, 0x96, 0xaa, 0x6d, 0x01, 0x09, 0x06, 0x80, 0x5a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\pnpsetup.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsetup.h

Abstract:

    This file contains the private data, interfaces and definitions
    associated with the integration of text mode setup and plug & play.

Author:

    Andrew Thornton (andrewth) 01/14/97


Revision History:


--*/

#ifndef FAR
#define FAR
#endif

//
// Private Notification for setupdd.sys during setup
// This should NOT be propagated into any public headers
//

#ifndef _SETUP_DEVICE_ARRIVAL_NOTIFICATION_DEFINED_
#define _SETUP_DEVICE_ARRIVAL_NOTIFICATION_DEFINED_

typedef struct _SETUP_DEVICE_ARRIVAL_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PDEVICE_OBJECT PhysicalDeviceObject;
    HANDLE EnumEntryKey;
    PUNICODE_STRING EnumPath;
    BOOLEAN InstallDriver;
} SETUP_DEVICE_ARRIVAL_NOTIFICATION, *PSETUP_DEVICE_ARRIVAL_NOTIFICATION;

#endif


//
// Device arrival GUID
//
DEFINE_GUID( GUID_SETUP_DEVICE_ARRIVAL, 0xcb3a4000L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x5, 0x3f);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sdistructs.h ===
// Storage Device Image Format
//


#ifndef __SDI_H__
#define __SDI_H__

#if defined(_MSC_VER) && (_MSC_VER >= 1000)
#pragma pack (push, sdi_include, 1)
#endif

#include "basetyps.h"

#ifdef  _NTDDDISK_H_
#define _SDIDDKINCED_
#endif
#ifdef _WINIOCTL_
#define _SDIDDKINCED_
#endif

#ifndef _SDIDDKINCED_
// These are from ntdddisk.h & also defined in winioctl.h
typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia,             // Fixed hard disk media
    F3_120M_512,            // 3.5", 120M Floppy
    F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    F8_256_128,             // 8",     256KB,  128 bytes/sector
    F3_200Mb_512            // 3.5",   200M Floppy (HiFD)
} MEDIA_TYPE, *PMEDIA_TYPE;

typedef struct _DISK_GEOMETRY {
  LARGE_INTEGER  Cylinders;
  MEDIA_TYPE  MediaType;
  ULONG  TracksPerCylinder;
  ULONG  SectorsPerTrack;
  ULONG  BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;

#endif

#define SDIUINT8	UCHAR
#define SDIUINT16	USHORT
#define SDIUINT32	ULONG
#define SDIUINT64	LARGE_INTEGER

#define SDI_BLOCK_SIZE				 4096	// This is fixed.
#define SDI_UNDEFINED				 0
#define SDI_UNUSED					 0
#define SDI_RESERVED				 0
#define SDI_NOBOOTCODE				 0
#define SDI_READYFORDISCARD			 0

#define SDI_INVALIDVENDORID			-1
#define SDI_CHECKSUMSTARTOFFSET		 0
#define SDI_CHECKSUMENDOFFSET		 0x01FF
#define SDI_DEFAULTPAGEALIGNMENT	 1
#define SDI_SIZEOF_SIGNATURE		 8
#define SDI_SIGNATURE				 "$SDI0001"
#define SDI_MDBTYPE_VOLATILE		 1
#define SDI_MDBTYPE_NONVOLATILE		 2
#define SDI_SIZEOF_DEVICEMODEL		 16
#define SDI_SIZEOF_RUNTIMEGUID		 16
#define SDI_SIZEOF_PARAMETERLIST	 2048
// TOC Entry Definitions
#define SDI_TOCMAXENTRIES			 8
// Type
#define SDI_BLOBTYPE_BOOT					0x544F4F42
#define SDI_BLOBTYPE_LOAD					0x44414F4C
#define SDI_BLOBTYPE_PART					0x54524150
#define SDI_BLOBTYPE_DISK					0x4B534944
#define SDI_BLOBTYPE_READYTOBEDISCARDED		(SDI_UNUSED | SDI_READYFORDISCARD)

// Attribute Masks
#define SDI_BLOBATTRIBUTE_TYPE_DEPENDENT_BITMASK	0xFFFF0000
#define SDI_BLOBATTRIBUTE_TYPE_INDEPENDENT_BITMASK	0x0000FFFF
// Attribute Bit Definitions
#define SDI_DISKBLOBATTRIBUTE_ACTIVEDISK_BIT		0x00020000
#define SDI_DISKBLOBATTRIBUTE_MOUNTABLE_BIT			0x00010000


typedef struct _SDI_TOC_ENTRY {
	SDIUINT32		dwType;									// Blob Type 'BOOT', 'LOAD', 'PART', 'DISK'
	SDIUINT8		Reserved_1[4];							// Reserved. MBZ
	SDIUINT32		dwAttribute;							// Attribute (custom field | SDI_UNUSED)
	SDIUINT8		Reserved_2[4];							// Reserved. MBZ
	SDIUINT64		llOffset;								// Offset in Bytes
	SDIUINT64		llSize;									// Size in Bytes
	union _ste_u {
		struct _ste_typeSpecific {
			SDIUINT64		liTypeData;						// Type specific data
			SDIUINT8		Reserved_5[24];			    	// Reserved. MBZ
		} typeSpecific;
		struct _ste_PartBlob {
			SDIUINT8		byType;							// Partition Type
		} PartBlob;
		struct _ste_BinaryBlob {
			SDIUINT64		liBaseAddress;					// Base Address / Sector size etc type specific data
			SDIUINT8		Reserved_5[24];			    	// Reserved. MBZ
		} BinaryBlob;
	} u;
} SDITOC_ENTRY, *PSDITOC_ENTRY;


// #if !defined(__MKTYPLIB__) && !defined(__midl)

typedef struct _SDI_HEADER {
	SDIUINT8		Signature[SDI_SIZEOF_SIGNATURE];		// $SDI0001
	SDIUINT32		dwMDBType;								// Type of Memory this SDI is supposed to boot from
	SDIUINT8		Reserved_1[4];							// Reserved. MBZ
	SDIUINT64		liBootCodeOffset;						// Offset to boot code from beginning of the SDI
	SDIUINT64		liBootCodeSize;							// Size of the boot code
	SDIUINT16		wVendorID;								// Vendor Id
	SDIUINT8		Reserved_2[6];							// Reserved. MBZ
	SDIUINT16		wDeviceID;								// Device Id
	SDIUINT8		Reserved_3[6];							// Reserved. MBZ
	SDIUINT8		DeviceModel[SDI_SIZEOF_DEVICEMODEL];	// Device Model
	SDIUINT32		dwDeviceRole;							// Device Role
	SDIUINT8		Reserved_4[12];							// Reserved. MBZ
	SDIUINT8		RuntimeGUID[SDI_SIZEOF_RUNTIMEGUID];	// Runtime GUID
	SDIUINT32		dwRuntimeOEMRev;						// Runtime OEM Revision Number
	SDIUINT8		Reserved_4_1[12];						// Reserved. MBZ
	SDIUINT32		dwPageAlignmentFactor;					// Page Alignment Factor
	SDIUINT8		Reserved_5[388];						// Reserved. MBZ
	SDIUINT8		ucCheckSum;								// CheckSum
	SDIUINT8		Reserved_6[7];							// Reserved. MBZ
	SDIUINT8		Reserved_7[512];						// Reserved. MBZ
	SDITOC_ENTRY	ToC[SDI_TOCMAXENTRIES];					// Table of Contents
	SDIUINT8		Reserved_8[512];						// Reserved. MBZ
	SDIUINT8		ParameterList[SDI_SIZEOF_PARAMETERLIST];// Parameter List
} SDI_HEADER, *PSDI_HEADER;


typedef struct _SDI_BLOBDEFINITION {
	SDIUINT32		dwType;									// Blob Type 'BOOT', 'LOAD', 'PART', 'DISK'
	SDIUINT32		dwAttribute;							// Attribute (custom field | SDI_UNUSED)
	SDIUINT64		llSize;									// Size in Bytes
	union _sbd_u {
		struct _sbd_typeSpecific {
			SDIUINT64		liTypeData;						// Type specific data
			SDIUINT8		Reserved_5[24];			    	// Reserved. MBZ
		} typeSpecific;
		struct _sbd_PartBlob {
			SDIUINT8		byType;							// Partition Type
		} PartBlob;
		struct _sbd_BinaryBlob {
			SDIUINT64		liBaseAddress;					// Base Address / Sector size etc type specific data
			SDIUINT8		Reserved_5[24];			    	// Reserved. MBZ
		} BinaryBlob;
	} u;
} SDI_BLOBDEFINITION, *PSDI_BLOBDEFINITION;

// #endif

#if defined(_MSC_VER) && (_MSC_VER >= 1000)
#pragma pack (pop, sdi_include)
#endif

#endif //__SDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sertlp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sertlp.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems, but which are private interfaces.

    The routines in this file should not be used outside of the security
    related rtl files.

Author:

    Robert P. Reichel (robertre)    6-12-91

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _SERTLP_
#define _SERTLP_

#include "nt.h"
#include "zwapi.h"
#include "ntrtl.h"



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Local Macros                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef LongAlign
#define LongAlign LongAlignPtr
#endif

#define LongAlignPtr(Ptr) ((PVOID)(((ULONG_PTR)(Ptr) + 3) & -4))
#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
// Macros for calculating the address of the components of a security
// descriptor.  This will calculate the address of the field regardless
// of whether the security descriptor is absolute or self-relative form.
// A null value indicates the specified field is not present in the
// security descriptor.
//

//
//  NOTE: Similar copies of these macros appear in sep.h.
//  Be sure to propagate bug fixes and changes.
//

#define RtlpOwnerAddrSecurityDescriptor( SD )                                  \
           (  ((SD)->Control & SE_SELF_RELATIVE) ?                             \
               (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Owner == 0) ? ((PSID) NULL) :               \
                       (PSID)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Owner)    \
               ) :                                                             \
               (PSID)((SD)->Owner)                                             \
           )

#define RtlpGroupAddrSecurityDescriptor( SD )                                  \
           (  ((SD)->Control & SE_SELF_RELATIVE) ?                             \
               (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Group == 0) ? ((PSID) NULL) :               \
                       (PSID)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Group)    \
               ) :                                                             \
               (PSID)((SD)->Group)                                             \
           )

#define RtlpSaclAddrSecurityDescriptor( SD )                                   \
           ( (!((SD)->Control & SE_SACL_PRESENT) ) ?                           \
             (PACL)NULL :                                                      \
               (  ((SD)->Control & SE_SELF_RELATIVE) ?                         \
                   (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Sacl == 0) ? ((PACL) NULL) :            \
                           (PACL)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Sacl) \
                   ) :                                                         \
                   (PACL)((SD)->Sacl)                                          \
               )                                                               \
           )

#define RtlpDaclAddrSecurityDescriptor( SD )                                   \
           ( (!((SD)->Control & SE_DACL_PRESENT) ) ?                           \
             (PACL)NULL :                                                      \
               (  ((SD)->Control & SE_SELF_RELATIVE) ?                         \
                   (   (((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Dacl == 0) ? ((PACL) NULL) :            \
                           (PACL)RtlOffsetToPointer((SD), ((SECURITY_DESCRIPTOR_RELATIVE *) (SD))->Dacl) \
                   ) :                                                         \
                   (PACL)((SD)->Dacl)                                          \
               )                                                               \
           )




//
//  Macro to determine if the given ID has the owner attribute set,
//  which means that it may be assignable as an owner
//  The GroupSid should not be marked for UseForDenyOnly.
//

#define RtlpIdAssignableAsOwner( G )                                               \
            ( (((G).Attributes & SE_GROUP_OWNER) != 0)  &&                         \
              (((G).Attributes & SE_GROUP_USE_FOR_DENY_ONLY) == 0) )

//
//  Macro to copy the state of the passed bits from the old security
//  descriptor (OldSD) into the Control field of the new one (NewSD)
//

#define RtlpPropagateControlBits( NewSD, OldSD, Bits )                             \
            ( NewSD )->Control |=                     \
            (                                                                  \
            ( OldSD )->Control & ( Bits )             \
            )


//
//  Macro to query whether or not the passed set of bits are ALL on
//  or not (ie, returns FALSE if some are on and not others)
//

#define RtlpAreControlBitsSet( SD, Bits )                                          \
            (BOOLEAN)                                                          \
            (                                                                  \
            (( SD )->Control & ( Bits )) == ( Bits )  \
            )

//
//  Macro to set the passed control bits in the given Security Descriptor
//

#define RtlpSetControlBits( SD, Bits )                                             \
            (                                                                  \
            ( SD )->Control |= ( Bits )                                        \
            )

//
//  Macro to clear the passed control bits in the given Security Descriptor
//

#define RtlpClearControlBits( SD, Bits )                                           \
            (                                                                  \
            ( SD )->Control &= ~( Bits )                                       \
            )




////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                      Prototypes for local procedures                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


BOOLEAN
RtlpContainsCreatorOwnerSid(
    PKNOWN_ACE Ace
    );

BOOLEAN
RtlpContainsCreatorGroupSid(
    PKNOWN_ACE Ace
    );


VOID
RtlpApplyAclToObject (
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
RtlpInheritAcl (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PACL *NewAcl,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    );



NTSTATUS
RtlpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    );

NTSTATUS
RtlpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    );

NTSTATUS
RtlpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    );

BOOLEAN
RtlpValidOwnerSubjectContext(
    IN HANDLE Token,
    IN PSID Owner,
    IN BOOLEAN ServerObject,
    OUT PNTSTATUS ReturnStatus
    );

VOID
RtlpQuerySecurityDescriptor(
    IN PISECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PULONG OwnerSize,
    OUT PSID *PrimaryGroup,
    OUT PULONG PrimaryGroupSize,
    OUT PACL *Dacl,
    OUT PULONG DaclSize,
    OUT PACL *Sacl,
    OUT PULONG SaclSize
    );



NTSTATUS
RtlpFreeVM(
    IN PVOID *Base
    );
NTSTATUS
RtlpConvertToAutoInheritSecurityObject(
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
RtlpNewSecurityObject (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCOunt,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
RtlpSetSecurityObject (
    IN PVOID Object OPTIONAL,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN ULONG PoolType,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    );

FORCEINLINE 
PULONG
RtlpSubAuthoritySid(
    IN PSID Sid,
    IN ULONG SubAuthority
    )
/*++

Routine Description:

    This function returns the address of a sub-authority array element of
    an SID.

Arguments:

    Sid - Pointer to the SID data structure.

    SubAuthority - An index indicating which sub-authority is being specified.
        This value is not compared against the number of sub-authorities in the
        SID for validity.

Return Value:


--*/
{
    PISID ISid;

    //
    //  Typecast to the opaque SID
    //

    ISid = (PISID)Sid;

    return &(ISid->SubAuthority[SubAuthority]);

}

#endif  // _SERTLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\riname.c ===
static PWSTR cszFirst = L"First";
static PWSTR cszLast  = L"Last";
static PWSTR cszUserName = L"Username";
static PWSTR cszMAC   = L"MAC";

static const int iFirst = (sizeof(L"First") / sizeof(WCHAR)) - 1;
static const int iLast  = (sizeof(L"Last" ) / sizeof(WCHAR)) - 1;
static const int iUserName = (sizeof(L"Username") / sizeof(WCHAR)) - 1;
static const int iMAC   = (sizeof(L"MAC"  ) / sizeof(WCHAR)) - 1;

#define STRING_MISSING(_x) (((_x) == NULL) || (*(_x) == 0))

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    )
{
    DWORD error;
    DWORD maxLength;
    DWORD fieldLength;
    WCHAR localString[10];
    WCHAR localFormat[10];
    BOOL padding;
    PWSTR pTemplate;
    PWSTR pOutput;
    PWSTR pOutputEnd;
    PWSTR stringToAdd;
    PWSTR pString;
    BOOL usedUserName;

    pTemplate = Template;
    pOutput = Name;
    pOutputEnd = pOutput + NameLength - 1;

    error = GENNAME_NO_ERROR;
    maxLength = 0;
    usedUserName = FALSE;
    if ( UsedCounter != NULL ) {
        *UsedCounter = FALSE;
    }

    while ( *pTemplate != 0 ) {

        if ( *pTemplate == L'%' ) {

            pTemplate++;
            fieldLength = 0;
            padding = FALSE;
            if ( *pTemplate >= L'0' && *pTemplate <= L'9' ) {
                if (*pTemplate == L'0') {
                    padding = TRUE;
                    //
                    // see if this request to do padding is from the "sample"
                    // entrypoint.  If we're doing padding, we want to make
                    // the sample output show that we will actually do some
                    // padding, so we make our counter small enough to show
                    // the padding.
                    //
                    if (Variables->Counter == 123456789 && 
                        Variables->AllowCounterTruncation &&
                        (0 == wcscmp(Variables->UserName, L"JOHNSMI")) &&
                        (0 == wcscmp(Variables->MacAddress, L"123456789012"))) {
                        Variables->Counter = 1;
                    }
                }
                do {
                    fieldLength = (fieldLength * 10) + (*pTemplate - L'0');
                    pTemplate++;
                } while ( *pTemplate >= L'0' && *pTemplate <= L'9' );
            }

            if ( *pTemplate == L'#' ) {

                DWORD maxCounter;
                DWORD counter;
                DWORD i;

                if (fieldLength > 9) {
                    fieldLength = 9;
                }
                if (fieldLength == 0) {
                    fieldLength = 2;
                }
                if(padding){
                    wsprintf(localFormat,L"%s%d%s", L"%0",fieldLength,L"d");
                } else {
                    wcscpy(localFormat,L"%d");
                }
                
                maxCounter = 10;
                for ( i = 1; i < fieldLength; i++ ) {
                    maxCounter *= 10;
                }

                counter = Variables->Counter;
                if ( counter >= maxCounter ) {
                    if ( !Variables->AllowCounterTruncation ) {
                        return GENNAME_COUNTER_TOO_HIGH;
                    }

                    //
                    // Truncate the counter on the right.
                    //

                    while ( counter > maxCounter ) {
                        counter /= 10;
                    }
                }

                if ( UsedCounter != NULL ) {
                    *UsedCounter = TRUE;
                }

                wsprintf( localString, localFormat, counter );
                stringToAdd = localString;

                pTemplate++;

            } else if ( StrCmpNI( pTemplate, cszFirst, iFirst ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->FirstName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_FIRSTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iFirst;
                
            } else if ( StrCmpNI( pTemplate, cszLast, iLast ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->LastName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_LASTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iLast;

            } else if ( StrCmpNI( pTemplate, cszUserName, iUserName ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                if ( !usedUserName ) {
                    stringToAdd = Variables->UserName;
                    if ( STRING_MISSING(stringToAdd) ) {
                        if ( MissingVariable != NULL ) {
                            *MissingVariable = GENNAME_VARIABLE_USERNAME;
                        }
                        return GENNAME_VARIABLE_MISSING;
                    }
                    usedUserName = TRUE;
                }

                pTemplate += iUserName;

            } else if ( StrCmpNI( pTemplate, cszMAC, iMAC ) == 0 ) {

                if (fieldLength > 12) {
                    fieldLength = 12;
                }
                if (fieldLength == 0) {
                    fieldLength = 12;
                }

                stringToAdd = Variables->MacAddress;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( MissingVariable != NULL ) {
                        *MissingVariable = GENNAME_VARIABLE_MAC;
                    }
                    return GENNAME_VARIABLE_MISSING;
                }

                pTemplate += iMAC;
                
            } else {

                return GENNAME_TEMPLATE_INVALID;
            }

        } else {

            fieldLength = 1;

            localString[0] = *pTemplate;
            localString[1] = 0;
            stringToAdd = localString;

            pTemplate++;
        }

        maxLength += fieldLength;

        pString = stringToAdd;
        for ( pString = stringToAdd;
              (fieldLength > 0) && (*pString != 0);
              fieldLength--, pString++ ) {
            if ( pOutput < pOutputEnd ) {
                *pOutput++ = *pString;
            } else {
                error = GENNAME_NAME_TOO_LONG;
                break;
            }
        }
    }

    if ( MaximumGeneratedNameLength != NULL ) {
        *MaximumGeneratedNameLength = maxLength;
    }

    *pOutput++ = 0;
    
    return error;

} // GenerateNameFromTemplate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\seopaque.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    seopaque.h

Abstract:

    This module contains definitions of opaque Security data structures.

    These structures are available to user and kernel security routines
    only.

    This file is not included by including "ntos.h".

Author:

    Jim Kelly (Jimk) 23-Mar-1990

Revision History:

--*/

#ifndef _SEOPAQUE_
#define _SEOPAQUE_

///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Private Structures                                                   //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
// Generic ACE structures, to be used for casting ACE's of known types
//

typedef struct _KNOWN_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} KNOWN_ACE, *PKNOWN_ACE;

typedef struct _KNOWN_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG Flags;
    // GUID ObjectType;             // Optionally present
    // GUID InheritedObjectType;    // Optionally present
    ULONG SidStart;
} KNOWN_OBJECT_ACE, *PKNOWN_OBJECT_ACE;

typedef struct _KNOWN_COMPOUND_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    USHORT CompoundAceType;
    USHORT Reserved;
    ULONG SidStart;
} KNOWN_COMPOUND_ACE, *PKNOWN_COMPOUND_ACE;

//typedef struct _KNOWN_IMPERSONATION_ACE {
//    ACE_HEADER Header;
//    ACCESS_MASK Mask;
//    USHORT DataType;
//    USHORT Argument;
//    ULONG Operands;
//} KNOWN_IMPERSONATION_ACE, *PKNOWN_IMPERSONATION_ACE;



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Miscellaneous support macros                                         //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
//  Given a pointer return its word aligned equivalent value
//

#define WordAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 1) & -2)     \
    )

//
//  Given a pointer return its longword aligned equivalent value
//

#define LongAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 3) & -4)     \
    )

//
//  Given a size return its longword aligned equivalent value
//

#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
//  Given a size return its sizeof(PVOID) aligned equivalent value
//

#define PtrAlignSize(Size)  \
    (((ULONG)(Size) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1))

//
//  Given a pointer return its quadword aligned equivalent value
//

#define QuadAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 7) & -8)     \
    )

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag) (               \
    ((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE \
    )

//
//  This macro clears a single flag in a set of flags
//

#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
    }

//
//  Get a pointer to the first ace in an acl
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Get a pointer to the following ace
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// A "known" ACE is one of the types that existed before the introduction of
// compound ACEs.  While the name is no longer as accurate as it used to be,
// it's convenient.
//

#define IsKnownAceType(Ace) (                                     \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 3 ACE.
//

#define IsV3AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 4 ACE.
//

#define IsV4AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid ACE.
//

#define IsMSAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_ACE_TYPE)           \
    )

//
//  Determine if an ace is a standard ace
//

#define IsCompoundAceType(Ace) (                                           \
    (((PACE_HEADER)(Ace))->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE))

//
// Test if the ACE is an object ACE.
//

#define IsObjectAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
    )

//
// Update this macro as new ACL revisions are defined.
//

#define ValidAclRevision(Acl) ((Acl)->AclRevision >= MIN_ACL_REVISION && \
                               (Acl)->AclRevision <= MAX_ACL_REVISION )

//
//  Macro to determine if an ace is to be inherited by a subdirectory
//

#define ContainerInherit(Ace) (                      \
    FlagOn((Ace)->AceFlags, CONTAINER_INHERIT_ACE) \
    )

//
//  Macro to determine if an ace is to be proprogate to a subdirectory.
//  It will if it is inheritable by either a container or non-container
//  and is not explicitly marked for no-propagation.
//

#define Propagate(Ace) (                                              \
    !FlagOn((Ace)->AceFlags, NO_PROPAGATE_INHERIT_ACE)  &&            \
    (FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) ||                 \
     FlagOn(( Ace )->AceFlags, CONTAINER_INHERIT_ACE) )               \
    )

//
//  Macro to determine if an ACE is to be inherited by a sub-object
//

#define ObjectInherit(Ace) (                      \
    FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) \
    )

//
// Macro to determine if an ACE was inherited.
//

#define AceInherited(Ace) (                      \
    FlagOn(( Ace )->AceFlags, INHERITED_ACE) \
    )

//
// Extract the SID from a object ACE
//
#define RtlObjectAceObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_OBJECT_TYPE_PRESENT) != 0 )
#define RtlObjectAceInheritedObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) != 0 )

#define RtlObjectAceSid( Ace ) \
    ((PSID)(((PUCHAR)&(((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (RtlObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (RtlObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define RtlObjectAceObjectType( Ace ) \
     ((GUID *)(RtlObjectAceObjectTypePresent(Ace) ? \
        &((PKNOWN_OBJECT_ACE)(Ace))->SidStart : \
        NULL ))

#define RtlObjectAceInheritedObjectType( Ace ) \
     ((GUID *)(RtlObjectAceInheritedObjectTypePresent(Ace) ? \
        ( RtlObjectAceObjectTypePresent(Ace) ? \
            (PULONG)(((PUCHAR)(&((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + sizeof(GUID)) : \
            &((PKNOWN_OBJECT_ACE)(Ace))->SidStart ) : \
        NULL ))

//
// Comparison routine for two GUIDs.
//
#define RtlpIsEqualGuid(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

//
// Macros for mapping DACL/SACL specific security descriptor control bits
//  to generic control bits.
//
// This mapping allows common routines to manipulate control bits generically
//  and have the appropriate bits set in the security descriptor based
//  on whether to ACL is a DACL or a SACL.
//

#define SEP_ACL_PRESENT             SE_DACL_PRESENT
#define SEP_ACL_DEFAULTED           SE_DACL_DEFAULTED
#define SEP_ACL_AUTO_INHERITED      SE_DACL_AUTO_INHERITED
#define SEP_ACL_PROTECTED           SE_DACL_PROTECTED

#define SEP_ACL_ALL ( \
        SEP_ACL_PRESENT | \
        SEP_ACL_DEFAULTED | \
        SEP_ACL_AUTO_INHERITED | \
        SEP_ACL_PROTECTED )

#define SeControlDaclToGeneric( _Dacl ) \
    ((_Dacl) & SEP_ACL_ALL )

#define SeControlGenericToDacl( _Generic ) \
    ((_Generic) & SEP_ACL_ALL )

#define SeControlSaclToGeneric( _Sacl ) ( \
            (((_Sacl) & SE_SACL_PRESENT) ? SEP_ACL_PRESENT : 0 ) | \
            (((_Sacl) & SE_SACL_DEFAULTED) ? SEP_ACL_DEFAULTED : 0 ) | \
            (((_Sacl) & SE_SACL_AUTO_INHERITED) ? SEP_ACL_AUTO_INHERITED : 0 ) | \
            (((_Sacl) & SE_SACL_PROTECTED) ? SEP_ACL_PROTECTED : 0 ) )

#define SeControlGenericToSacl( _Generic ) ( \
            (((_Generic) & SEP_ACL_PRESENT) ? SE_SACL_PRESENT : 0 ) | \
            (((_Generic) & SEP_ACL_DEFAULTED) ? SE_SACL_DEFAULTED : 0 ) | \
            (((_Generic) & SEP_ACL_AUTO_INHERITED) ? SE_SACL_AUTO_INHERITED : 0 ) | \
            (((_Generic) & SEP_ACL_PROTECTED) ? SE_SACL_PROTECTED : 0 ) )




#endif // _SEOPAQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\riname.h ===
#define GENNAME_NO_ERROR            0
#define GENNAME_TEMPLATE_INVALID    1
#define GENNAME_COUNTER_TOO_HIGH    2
#define GENNAME_VARIABLE_MISSING    3
#define GENNAME_NAME_TOO_LONG       4

#define GENNAME_VARIABLE_USERNAME   L"USERNAME"
#define GENNAME_VARIABLE_FIRSTNAME  L"USERFIRSTNAME"
#define GENNAME_VARIABLE_LASTNAME   L"USERLASTNAME"
#define GENNAME_VARIABLE_MAC        L"MAC"

typedef struct _GENNAME_VARIABLES {
    PWSTR UserName;
    PWSTR FirstName;
    PWSTR LastName;
    PWSTR MacAddress;
    DWORD Counter;
    BOOL AllowCounterTruncation;
} GENNAME_VARIABLES, *PGENNAME_VARIABLES;

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\setupdd.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    setupdd.h

Abstract:

    Public header file for setup device driver.

Author:

    Ted Miller (tedm) 11-August-1993

Revision History:

--*/


#ifndef _SETUPDD_
#define _SETUPDD_


#define DD_SETUP_DEVICE_NAME_U  L"\\Device\\Setup"


#define IOCTL_SETUP_START           CTL_CODE(FILE_DEVICE_UNKNOWN,0,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SETUP_FMIFS_MESSAGE   CTL_CODE(FILE_DEVICE_UNKNOWN,1,METHOD_BUFFERED,FILE_ANY_ACCESS)


typedef struct _SETUP_COMMUNICATION {

    union {
        ULONG     RequestNumber;
        NTSTATUS  Status;
        DWORD_PTR UnusedAlign64;
    } u;

    UCHAR Buffer[2048];

} SETUP_COMMUNICATION, *PSETUP_COMMUNICATION;


//
// Input structure for IOCTL_SETUP_START.
//

typedef struct _SETUP_START_INFO {

    //
    // Handles of events used for communication between
    // device driver and user-mode parts of text setup.
    //
    HANDLE RequestReadyEvent;
    HANDLE RequestServicedEvent;

    //
    // Base address of the user-mode process.
    // This is used by the device driver to load massages
    // from the user-mode process' resource tables.
    //
    PVOID UserModeImageBase;

    //
    // System information structure.
    //
    SYSTEM_BASIC_INFORMATION SystemBasicInfo;

    //
    // Address of a buffer in the user process' address space,
    // to be used for same communication.
    //
    PSETUP_COMMUNICATION Communication;

} SETUP_START_INFO, *PSETUP_START_INFO;


//
// Input structure for IOCTL_SETUP_FMIFS_MESSAGE
//

typedef struct _SETUP_DISPLAY_INFO {

    FMIFS_PACKET_TYPE   FmifsPacketType;
    PVOID               FmifsPacket;

} SETUP_FMIFS_MESSAGE, *PSETUP_FMIFS_MESSAGE;




typedef enum {
    SetupServiceDone,
    SetupServiceExecute,
    SetupServiceQueryDirectoryObject,
    SetupServiceFlushVirtualMemory,
    SetupServiceShutdownSystem,
    SetupServiceDeleteKey,
    SetupServiceLoadKbdLayoutDll,
    SetupServiceLockVolume,
    SetupServiceUnlockVolume,
    SetupServiceDismountVolume,
    SetupServiceSetDefaultFileSecurity,
    SetupServiceVerifyFileAccess,
    SetupServiceCreatePageFile,
    SetupServiceGetFullPathName,
    SetupServiceMax
};


typedef struct _SERVICE_EXECUTE {

    PWSTR FullImagePath;
    PWSTR CommandLine;
    ULONG ReturnStatus;

    //
    // The two nul-terminated strings follow in the buffer.
    //
    WCHAR Buffer[1];

} SERVICE_EXECUTE, *PSERVICE_EXECUTE;

typedef struct _SERVICE_DELETE_KEY {

    HANDLE KeyRootDirectory;
    PWSTR  Key;

    //
    // The nul-terminated string follows in the buffer.
    //
    WCHAR Buffer[1];

} SERVICE_DELETE_KEY, *PSERVICE_DELETE_KEY;

typedef struct _SERVICE_QUERY_DIRECTORY_OBJECT {

    HANDLE  DirectoryHandle;
    ULONG   Context;
    BOOLEAN RestartScan;

    //
    // Make sure this fits within the Buffer field of SETUP_COMMUNICATION.
    // It's an arroy of ULONGs to force alignment.
    //
    ULONG  Buffer[256];

} SERVICE_QUERY_DIRECTORY_OBJECT, *PSERVICE_QUERY_DIRECTORY_OBJECT;


typedef struct _SERVICE_FLUSH_VIRTUAL_MEMORY {

    IN PVOID BaseAddress;
    IN SIZE_T RangeLength;

} SERVICE_FLUSH_VIRTUAL_MEMORY, *PSERVICE_FLUSH_VIRTUAL_MEMORY;


typedef struct _SERVICE_LOAD_KBD_LAYOUT_DLL {

    PVOID TableAddress;
    WCHAR DllName[1];

} SERVICE_LOAD_KBD_LAYOUT_DLL, *PSERVICE_LOAD_KBD_LAYOUT_DLL;

typedef struct _SERVICE_LOCK_UNLOCK_VOLUME {

    HANDLE Handle;

} SERVICE_LOCK_UNLOCK_VOLUME, *PSERVICE_LOCK_UNLOCK_VOLUME;

typedef struct _SERVICE_DISMOUNT_VOLUME {

    HANDLE Handle;

} SERVICE_LOCK_DISMOUNT_VOLUME, *PSERVICE_DISMOUNT_VOLUME;

typedef struct _SERVICE_VERIFY_FILE_ACESS {

    ACCESS_MASK DesiredAccess;
    WCHAR       FileName[1];

} SERVICE_VERIFY_FILE_ACCESS, *PSERVICE_VERIFY_FILE_ACCESS;

typedef struct _SERVICE_DEFAULT_FILE_SECURITY {

    WCHAR FileName[1];

} SERVICE_DEFAULT_FILE_SECURITY, *PSERVICE_DEFAULT_FILE_SECURITY;

typedef struct _SERVICE_CREATE_PAGEFILE {

    LARGE_INTEGER MinSize;
    LARGE_INTEGER MaxSize;
    WCHAR FileName[1];

} SERVICE_CREATE_PAGEFILE, *PSERVICE_CREATE_PAGEFILE;

typedef struct _SERVICE_GETFULLPATHNAME {
    WCHAR *NameOut;
    WCHAR FileName[1];
} SERVICE_GETFULLPATHNAME, *PSERVICE_GETFULLPATHNAME;

#endif // ndef _SETUPDD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\seposix.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    seposix.h

Abstract:

    This file contains security related definitions that are private to
    subsystems, such as Posix Id to Sid mappings

Author:

    Scott Birrell (ScottBi) April 13, 1993

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SEPOSIX_
#define _SEPOSIX_

//
// Posix Id definitions
//
// IMPORTANT NOTE:
//
// The Posix Id's for well known Sids and accounts in the local machine's
// BUILTIN in and Accounts have values not exceeding 0x3ffff.  This is
// to allow storage of these Posix Ids in cpio archive file format.
// This format restricts the size of the values to fit within 6 octal
// digits, making 0x3ffff the highest possible value supportable.
//

//
// Posix Id's for universal well known Sids
//

#define SE_NULL_POSIX_ID                         ((ULONG) 0x00010000)
#define SE_WORLD_POSIX_ID                        ((ULONG) 0x00010100)
#define SE_LOCAL_POSIX_ID                        ((ULONG) 0x00010200)
#define SE_CREATOR_OWNER_POSIX_ID                ((ULONG) 0x00010300)
#define SE_CREATOR_GROUP_POSIX_ID                ((ULONG) 0x00010301)
#define SE_NON_UNIQUE_POSIX_ID                   ((ULONG) 0x00010400)

//
// Posix Id's for Nt well known Sids
//

#define SE_AUTHORITY_POSIX_ID                    ((ULONG) 0x00010500)
#define SE_DIALUP_POSIX_ID                       ((ULONG) 0x00010501)
#define SE_NETWORK_POSIX_ID                      ((ULONG) 0x00010502)
#define SE_BATCH_POSIX_ID                        ((ULONG) 0x00010503)
#define SE_INTERACTIVE_POSIX_ID                  ((ULONG) 0x00010504)
#define SE_DEFAULT_LOGON_POSIX_ID                ((ULONG) 0x00010505)
#define SE_SERVICE_POSIX_ID                      ((ULONG) 0x00010506)

//
// Posix Offsets for Built In Domain, Account Domain and Primary Domain
//
// NOTE:  The Posix Id of an account in one of these domains is given
//        by the formula:
//
//        Posix Id = Domain Posix Offset + Relative Id
//
//        where 'Relative Id' is the lowest sub authority in the account's
//        Sid
//

#define SE_NULL_POSIX_OFFSET                     ((ULONG) 0x00000000)
#define SE_BUILT_IN_DOMAIN_POSIX_OFFSET          ((ULONG) 0x00020000)
#define SE_ACCOUNT_DOMAIN_POSIX_OFFSET           ((ULONG) 0x00030000)

//
// NOTE:  The following is valid for workstations that have joined a
// domain only.
//

#define SE_PRIMARY_DOMAIN_POSIX_OFFSET           ((ULONG) 0x00100000)

//
// Seed and increment for Trusted Domain Posix Offsets
//

#define SE_INITIAL_TRUSTED_DOMAIN_POSIX_OFFSET   ((ULONG) 0x00200000)
#define SE_TRUSTED_DOMAIN_POSIX_OFFSET_INCR      ((ULONG) 0x00100000)
#define SE_MAX_TRUSTED_DOMAIN_POSIX_OFFSET       ((ULONG) 0xfff00000)

#endif // _SEPOSIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\setupblk.h ===
#ifndef _SETUPBLK_
#define _SETUPBLK_

//
// Filetypes for files in txtsetup.oem.
//

typedef enum {
    HwFileDriver,
    HwFilePort,
    HwFileClass,
    HwFileInf,
    HwFileDll,
    HwFileDetect,
    HwFileHal,
    HwFileCatalog,
    HwFileMax,
    HwFileDynUpdt = 31
} HwFileType;

#define FILETYPE(FileType)                      (1 << (FileType))
#define SET_FILETYPE_PRESENT(BitArray,FileType) ((BitArray) |= FILETYPE(FileType))
#define IS_FILETYPE_PRESENT(BitArray,FileType)  ((BitArray) & FILETYPE(FileType))

//
// Registry data types for registry data in txtsetup.oem.
//
typedef enum {
    HwRegistryDword,
    HwRegistryBinary,
    HwRegistrySz,
    HwRegistryExpandSz,
    HwRegistryMultiSz,
    HwRegistryMax
} HwRegistryType;

//
// Component types.
//

typedef enum {
    HwComponentComputer,
    HwComponentDisplay,
    HwComponentKeyboard,
    HwComponentLayout,
    HwComponentMouse,
    HwComponentMax
} HwComponentType;


typedef struct _PNP_HARDWARE_ID {

    struct _PNP_HARDWARE_ID *Next;

    //
    // String that represents the hardware id of a PNP device.
    //

    PCHAR Id;

    //
    // Driver for the device
    //

    PCHAR DriverName;

    //
    // GUID for this device, if any
    //
    PCHAR ClassGuid;


} PNP_HARDWARE_ID, *PPNP_HARDWARE_ID;


typedef struct _DETECTED_DEVICE_REGISTRY {

    struct _DETECTED_DEVICE_REGISTRY *Next;

    //
    // The name of the key.  The empty string means the key in the
    // services key itself.
    //

    PCHAR KeyName;

    //
    // The name of the value within the registry key
    //

    PCHAR ValueName;

    //
    // The data type for the value (ie, REG_DWORD, etc)
    //

    ULONG ValueType;

    //
    // The buffer containing the data to be placed into the value.
    // If the ValueType is REG_SZ, then Buffer should point to
    // a nul-terminated ASCII string (ie, not unicode), and BufferSize
    // should be the length in bytes of that string (plus 1 for the nul).
    //

    PVOID Buffer;

    //
    // The size of the buffer in bytes
    //

    ULONG BufferSize;


} DETECTED_DEVICE_REGISTRY, *PDETECTED_DEVICE_REGISTRY;


//
// One of these will be created for each file to be copied for a
// third party device.
//
typedef struct _DETECTED_DEVICE_FILE {

    struct _DETECTED_DEVICE_FILE *Next;

    //
    // Filename of the file.
    //

    PCHAR Filename;

    //
    // type of the file (hal, port, class, etc).
    //

    HwFileType FileType;

    //
    // Part of name of the section in txtsetup.oem [Config.<ConfigName>]
    // that contains registry options.  If this is NULL, then no registry
    // information is associated with this file.
    //
    PCHAR ConfigName;

    //
    // Registry values for the node in the services list in the registry.
    //

    PDETECTED_DEVICE_REGISTRY RegistryValueList;

    //
    // These two fields are used when prompting for the diskette
    // containing the third-party-supplied driver's files.
    //

    PTCHAR DiskDescription;
    PCHAR DiskTagfile;

    //
    // Directory where files are to be found on the disk.
    //

    PCHAR Directory;

    //
    // Arc device name from which this file was loaded
    //
    PCHAR   ArcDeviceName;
    
} DETECTED_DEVICE_FILE, *PDETECTED_DEVICE_FILE;


//
// structure for storing information about a driver we have located and
// will install.
//

typedef struct _DETECTED_DEVICE {

    struct _DETECTED_DEVICE *Next;

    //
    // String used as a key into the relevent section (like [Display],
    // [Mouse], etc).
    //

    PCHAR IdString;

    //
    // 0-based order that this driver is listed in txtsetup.sif.
    // (ULONG)-1 for unsupported (ie, third party) scsi devices.
    //
    ULONG Ordinal;

    //
    // String that describes the hardware.
    //

    PTCHAR Description;

    //
    // If this is TRUE, then there is an OEM option selected for this
    // hardware.
    //

    BOOLEAN ThirdPartyOptionSelected;

    //
    // Bits to be set if a third party option is selected, indicating
    // which type of files are specified in the oem inf file.
    //

    ULONG FileTypeBits;

    //
    // Files for a third party option.
    //

    PDETECTED_DEVICE_FILE Files;

    //
    // For first party files loaded by the boot loader,
    // this value will be the "BaseDllName" -- ie, the filename
    // part only of the file from which the driver was loaded.
    //
    // This field is only filled in in certain cases, so be careful
    // when using it.  See ntos\boot\setup\setup.c. (Always filled in
    // for SCSI devices.)
    //
    PCHAR BaseDllName;

    //
    // If this is TRUE, then there is a migrated driver for this
    // hardware.
    //
    BOOLEAN MigratedDriver;

    //
    // Device's PNP hardware IDs (if any)
    //
    PPNP_HARDWARE_ID    HardwareIds;

} DETECTED_DEVICE, *PDETECTED_DEVICE;

//
// Virtual OEM source devices (containing F6 drivers)
//
typedef struct _DETECTED_OEM_SOURCE_DEVICE  *PDETECTED_OEM_SOURCE_DEVICE;

typedef struct _DETECTED_OEM_SOURCE_DEVICE {
    PDETECTED_OEM_SOURCE_DEVICE Next;
    PSTR                        ArcDeviceName;
    PVOID                       ImageBase;
    ULONGLONG                   ImageSize;
} DETECTED_OEM_SOURCE_DEVICE;

//
// Name of txtsetup.oem
//
#define TXTSETUP_OEM_FILENAME    "txtsetup.oem"
#define TXTSETUP_OEM_FILENAME_U L"txtsetup.oem"

//
// Name of sections in txtsetup.oem.  These are not localized.
//
#define TXTSETUP_OEM_DISKS       "Disks"
#define TXTSETUP_OEM_DISKS_U    L"Disks"
#define TXTSETUP_OEM_DEFAULTS    "Defaults"
#define TXTSETUP_OEM_DEFAULTS_U L"Defaults"

//
// Available names of components in the defaults sections
//
#define TXTSETUP_OEM_DEFAULTS_COMPUTER      "computer"
#define TXTSETUP_OEM_DEFAULTS_COMPUTER_U   L"computer"
#define TXTSETUP_OEM_DEFAULTS_SCSI          "scsi"
#define TXTSETUP_OEM_DEFAULTS_SCSI_U       L"scsi"


//
// Field offsets in txtsetup.oem
//

// in [Disks] section
#define OINDEX_DISKDESCR        0
#define OINDEX_TAGFILE          1
#define OINDEX_DIRECTORY        2

// in [Defaults] section
#define OINDEX_DEFAULT          0

// in [<component_name>] section (ie, [keyboard])
#define OINDEX_DESCRIPTION      0

// in [Files.<compoment_name>.<id>] section (ie, [Files.Keyboard.Oem1])
#define OINDEX_DISKSPEC         0
#define OINDEX_FILENAME         1
#define OINDEX_CONFIGNAME       2

// in [Config.<compoment_name>.<id>] section (ie, [Config.Keyboard.Oem1])
#define OINDEX_KEYNAME          0
#define OINDEX_VALUENAME        1
#define OINDEX_VALUETYPE        2
#define OINDEX_FIRSTVALUE       3

// in [HardwareIds.<compoment_name>.<id>] section (ie, [HardwareIds.Keyboard.Oem1])
#define OINDEX_HW_ID         0
#define OINDEX_DRIVER_NAME   1
#define OINDEX_CLASS_GUID    2


typedef enum {
    SetupOperationSetup,
    SetupOperationUpgrade,
    SetupOperationRepair
} SetupOperation;


typedef struct _SETUP_LOADER_BLOCK_SCALARS {

    //
    // This value indicates the operation we are performing
    // as chosen by the user or discovered by setupldr.
    //
    unsigned    SetupOperation;

    //
    // In some cases we will ask the user whether he wants
    // a CD-ROM or floppy-based installation.  This flag
    // indicates whether he chose a CD-ROM setup.
    //
    unsigned    SetupFromCdRom      : 1;

    //
    // If this flag is set, then setupldr loaded scsi miniport drivers
    // and the scsi class drivers we may need (scsidisk, scsicdrm, scsiflop).
    //
    unsigned    LoadedScsi          : 1;

    //
    // If this flag is set, then setupldr loaded non-scsi floppy class drivers
    // (ie, floppy.sys) and fastfat.sys.
    //
    unsigned    LoadedFloppyDrivers : 1;

    //
    // If this flag is set, then setupldr loaded non-scsi disk class drivers
    // (ie, atdisk, abiosdsk, delldsa, cpqarray) and filesystems (fat, hpfs, ntfs).
    //
    unsigned    LoadedDiskDrivers   : 1;

    //
    // If this flag is set, then setupldr loaded non-scsi cdrom class drivers
    // (currently there are none) and cdfs.
    //
    unsigned    LoadedCdRomDrivers  : 1;

    //
    // If this flag is set, then setupldr loaded all filesystems listed
    // in [FileSystems], on txtsetup.sif.
    //
    unsigned    LoadedFileSystems  : 1;

} SETUP_LOADER_BLOCK_SCALARS, *PSETUP_LOADER_BLOCK_SCALARS;

//
// Purely arbitrary, but all net boot components enforce this.  The only
// problem is if a detected Hal name is greater than this, things get ugly if
// the first MAX_HAL_NAME_LENGTH characters are identical for two different hals.
// NOTE: If you change this, change the definition in private\sm\server\smsrvp.h
// NOTE: If you change this, change the definition in private\inc\oscpkt.h
//
#define MAX_HAL_NAME_LENGTH 30

//
// This definition must match the OSC_ADMIN_PASSWORD_LEN definition in oscpkt.h
// We just define it here to avoid having to drag in oscpkt.h in every location
// that uses setupblk.h
//
#define NETBOOT_ADMIN_PASSWORD_LEN 64


typedef struct _SETUP_LOADER_BLOCK {

    //
    // ARC path to the Setup source media.
    // The Setup boot media path is given by the
    // ArcBootDeviceName field in the loader block itself.
    //
    PCHAR              ArcSetupDeviceName;

    //
    // Detected/loaded video device.
    //
    DETECTED_DEVICE    VideoDevice;

    //
    // Detected/loaded keyboard device.
    //
    PDETECTED_DEVICE    KeyboardDevices;

    //
    // Detected computer type.
    //
    DETECTED_DEVICE    ComputerDevice;

    //
    // Detected/loaded scsi adapters.  This is a linked list
    // because there could be multiple adapters.
    //
    PDETECTED_DEVICE    ScsiDevices;

    //
    // Detected virtual OEM source devices
    //
    PDETECTED_OEM_SOURCE_DEVICE OemSourceDevices;

    //
    // Non-pointer values.
    //
    SETUP_LOADER_BLOCK_SCALARS ScalarValues;

    //
    // Pointer to the txtsetup.sif file loaded by setupldr
    //
    PCHAR IniFile;
    ULONG IniFileLength;

    //
    // Pointer to the winnt.sif file loaded by setupldr
    //
    PCHAR WinntSifFile;
    ULONG WinntSifFileLength;

    //
    // Pointer to the migrate.inf file loaded by setupldr
    //
    PCHAR MigrateInfFile;
    ULONG MigrateInfFileLength;

    //
    // Pointer to the unsupdrv.inf file loaded by setupldr
    //
    PCHAR UnsupDriversInfFile;
    ULONG UnsupDriversInfFileLength;

    //
    // Bootfont.bin file image loaded by setupldr
    //
    PVOID   BootFontFile;
    ULONG   BootFontFileLength;

    // On non-vga displays, setupldr looks in the firmware config tree
    // for the monitor peripheral that should be a child of the
    // display controller for the display being used during installation.
    // It copies its monitor configuration data to allow setup to
    // set the mode properly later.
    //
    PMONITOR_CONFIGURATION_DATA Monitor;
    PCHAR MonitorId;

#ifdef _ALPHA_
    //
    // if alpha, then we need to know if the user supplied an OEM PAL disk
    //
    PDETECTED_DEVICE    OemPal;
#endif

    //
    // Loaded boot bus extenders
    //
    PDETECTED_DEVICE    BootBusExtenders;

    //
    // Loaded bus extenders
    //
    PDETECTED_DEVICE    BusExtenders;

    //
    // Loaded support drivers for input devices
    //
    PDETECTED_DEVICE    InputDevicesSupport;

    //
    //  This is a linked list that the contains the hardware id database,
    //  that will be used during the initialization phase of textmode
    //  setup (setupdd.sys)
    //
    PPNP_HARDWARE_ID HardwareIdDatabase;

    //
    // Remote boot information.
    //

    WCHAR ComputerName[64];
    ULONG IpAddress;
    ULONG SubnetMask;
    ULONG ServerIpAddress;
    ULONG DefaultRouter;
    ULONG DnsNameServer;

    //
    // The PCI hardware ID we got from the ROM of the netboot card
    // ("PCI\VEN_xxx...").
    //

    WCHAR NetbootCardHardwareId[64];

    //
    // The name of the netboot card driver ("abc.sys").
    //

    WCHAR NetbootCardDriverName[24];

    //
    // The name of the netboot card service key in the registry.
    //

    WCHAR NetbootCardServiceName[24];

#if defined(REMOTE_BOOT)
    //
    // The inbound SPI, outbound SPI, and session key for the
    // IPSEC conversation with the server.
    //

    ULONG IpsecInboundSpi;
    ULONG IpsecOutboundSpi;
    ULONG IpsecSessionKey;
#endif // defined(REMOTE_BOOT)

    //
    // If non-NULL this points to a string containing registry values to
    // be added for the netboot card. The string consists of a series of
    // name\0type\0value\0, with a final \0 at the end.
    //

    PCHAR NetbootCardRegistry;
    ULONG NetbootCardRegistryLength;

    //
    // If non-NULL this points to the PCI or ISAPNP information about
    // the netboot card.
    //

    PCHAR NetbootCardInfo;
    ULONG NetbootCardInfoLength;

    //
    // Various flags.
    //

    ULONG Flags;

#define SETUPBLK_FLAGS_IS_REMOTE_BOOT   0x00000001
#define SETUPBLK_FLAGS_IS_TEXTMODE      0x00000002
#if defined(REMOTE_BOOT)
#define SETUPBLK_FLAGS_REPIN            0x00000004
#define SETUPBLK_FLAGS_DISABLE_CSC      0x00000008
#define SETUPBLK_FLAGS_DISCONNECTED     0x00000010
#define SETUPBLK_FLAGS_FORMAT_NEEDED    0x00000020
#define SETUPBLK_FLAGS_IPSEC_ENABLED    0x00000040
#endif // defined(REMOTE_BOOT)
#define SETUPBLK_FLAGS_CONSOLE          0x00000080
#if defined(REMOTE_BOOT)
#define SETUPBLK_FLAGS_PIN_NET_DRIVER   0x00000100
#endif // defined(REMOTE_BOOT)
#define SETUPBLK_FLAGS_REMOTE_INSTALL   0x00000200
#define SETUPBLK_FLAGS_SYSPREP_INSTALL  0x00000400
#define SETUPBLK_XINT13_SUPPORT         0x00000800
#define SETUPBLK_FLAGS_ROLLBACK         0x00001000

#if defined(REMOTE_BOOT)
    //
    // HAL file name.
    //

    CHAR NetBootHalName[MAX_HAL_NAME_LENGTH + 1];
#endif // defined(REMOTE_BOOT)

    //
    // During remote boot textmode setup, NtBootPath in the loader block points
    // to the setup source location. We also need to pass in the path to the
    // machine directory. This will be in the format \server\share\path.
    //
    PCHAR MachineDirectoryPath;

    //
    // Holds the name of the .sif file used by a remote boot machine
    // during textmode setup -- this is a temp file that needs to be
    // deleted. This will be in the format \server\share\path.
    //
    PCHAR NetBootSifPath;

    //
    // On a remote boot, this is information from the secret used
    // when the redirector logs on.
    //

    PVOID NetBootSecret;

#if defined(REMOTE_BOOT)
    //
    // This indicates whether TFTP needed to use the second password in
    // the secret to log on (as a hint to the redirector).
    //

    BOOLEAN NetBootUsePassword2;
#endif // defined(REMOTE_BOOT)

    //
    // This is the UNC path that a SysPrep installation or a machine replacement
    // senario is supposed to connect to find IMirror.dat
    //
    UCHAR NetBootIMirrorFilePath[260];

    //
    // Pointer to the asrpnp.sif file loaded by setupldr
    //
    PCHAR ASRPnPSifFile;
    ULONG ASRPnPSifFileLength;

    //
    // This is the administrator password supplied by the user during a
    // remote install
    UCHAR NetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN];


} SETUP_LOADER_BLOCK, *PSETUP_LOADER_BLOCK;

#endif // _SETUPBLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sfcfiles.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sfcfiles.h

Abstract:

    Implementation of protected DLLs.

Author:

    Wesley Witt (wesw) 18-Dec-1998

Revision History:
    Andrew Ritz (andrewr) 2-Jul-1999 : added comments

--*/

#pragma once

//
// structures
//
typedef struct _PROTECT_FILE_ENTRY {
    PWSTR SourceFileName; // will be NULL if file is not renamed on installation
    PWSTR FileName;       // destination filename plus full path to file
    PWSTR InfName;        // inf file which provides layout information
                          // may be NULL if we use the default layout file
} PROTECT_FILE_ENTRY, *PPROTECT_FILE_ENTRY;


#ifdef __cplusplus
extern "C" {
#endif

//
// prototypes
//
NTSTATUS
SfcGetFiles(
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    );


NTSTATUS
pSfcGetFilesList(
    IN  ULONG Mask,
    OUT PPROTECT_FILE_ENTRY *Files,
    OUT PULONG FileCount
    );

#ifdef __cplusplus
}
#endif



//
// define valid mask bits for pSfcGetFilesList Mask parameter
//
#define SFCFILESMASK_PROFESSIONAL       0x00000000
#define SFCFILESMASK_PERSONAL           0x00000001
#define SFCFILESMASK_TABLET             0x00000002
#define SFCFILESMASK_MEDIACTR           0x00000004
#define SFCFILESMASK_SERVER             0x00000100
#define SFCFILESMASK_ADVSERVER          0x00010000
#define SFCFILESMASK_DTCSERVER          0x01000000


typedef NTSTATUS (*PSFCGETFILES)(PPROTECT_FILE_ENTRY*,PULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\setuplog.h ===
#ifndef _SETUPLOG_
#define _SETUPLOG_

#include <windows.h>
#include <setupapi.h>

//
// File names for the 2 log files.
//
#define SETUPLOG_ACTION_FILENAME    TEXT("setupact.log")
#define SETUPLOG_ERROR_FILENAME     TEXT("setuperr.log")

//
// String used to separate items in the log.
//
#define SETUPLOG_ITEM_TERMINATOR    TEXT("\r\n***\r\n\r\n")

//
// Value to be used as a MessageString to indicate that the MessageId should
// be used instead.
//
#define SETUPLOG_USE_MESSAGEID  (PTSTR)(1)

//
// The LogSeverity type and its associated values are defined in setupapi.h.
// The high order word of the LogSeverity is reserved for the following flags.
//

#define SETUPLOG_SINGLE_MESSAGE     0x00010000

typedef PVOID (*PSPLOG_OPENFILE_ROUTINE) (
    IN  LPCTSTR Filename,
    IN  BOOL    WipeLogFile
    );

typedef UINT (*PSPLOG_CLOSEFILE_ROUTINE) (
    IN  PVOID   LogFile
    );

typedef PVOID (*PSPLOG_ALLOC_ROUTINE) (
    IN  DWORD   Size
    );

typedef VOID (*PSPLOG_FREE_ROUTINE) (
    IN  CONST VOID  *p
    );

typedef PTSTR (*PSPLOG_FORMAT_ROUTINE) (
    IN  LPCTSTR MessageString,
    IN  UINT    MessageId,
    IN  va_list *ArgumentList
    );

typedef BOOL (*PSPLOG_WRITE_ROUTINE) (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    );

typedef BOOL (*PSPLOG_ACQUIRELOCK_ROUTINE) (
    IN  PVOID   Mutex
    );

typedef BOOL (*PSPLOG_RELEASELOCK_ROUTINE) (
    IN  PVOID   Mutex
    );

typedef struct _SETUPLOG_CONTEXT {
    PSPLOG_OPENFILE_ROUTINE     OpenFile;
    PSPLOG_CLOSEFILE_ROUTINE    CloseFile;
    PSPLOG_ALLOC_ROUTINE        AllocMem;
    PSPLOG_FREE_ROUTINE         FreeMem;
    PSPLOG_FORMAT_ROUTINE       Format;
    PSPLOG_WRITE_ROUTINE        Write;
    PSPLOG_ACQUIRELOCK_ROUTINE  Lock;
    PSPLOG_RELEASELOCK_ROUTINE  Unlock;
    PVOID                       hActionLog;
    PVOID                       hErrorLog;
    PVOID                       Mutex;
    LogSeverity                 WorstError;
    LPCTSTR                     SeverityDescriptions[LogSevMaximum];
} SETUPLOG_CONTEXT, *PSETUPLOG_CONTEXT;


//
// API's for setuplog.lib
//
BOOL
SetuplogInitializeEx(
    IN  PSETUPLOG_CONTEXT   SetuplogContext,
    IN  BOOL                WipeLogFile,
    IN  LPCTSTR             ActionFilename,
    IN  LPCTSTR             ErrorFilename,
    IN  PVOID               Reserved1,
    IN  DWORD               Reserved2
    );

BOOL
SetuplogInitialize(
    IN  PSETUPLOG_CONTEXT   SetuplogContext,
    IN  BOOL                WipeLogFile
    );

PTSTR
SetuplogFormatMessageWithContextV(
    IN  PSETUPLOG_CONTEXT   MyContext,
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    IN  va_list             *ArgumentList
    );

PTSTR
SetuplogFormatMessageV(
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    IN  va_list             *ArgumentList
    );

PTSTR
SetuplogFormatMessage(
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    ...
    );

BOOL
SetuplogErrorV(
    IN  LogSeverity         Severity,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,      OPTIONAL
    IN  va_list             *ArgumentList
    );

BOOL
SetuplogError(
    IN  LogSeverity         Severity,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,      OPTIONAL
    ...
    );

BOOL
SetuplogTerminate(
    VOID
    );

#endif // _SETUPLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbipx.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    smb.h

Abstract:

    This file contains request and response structure definitions
    for the specific parameters of each SMB command, as well as codes
    for SMB commands and errors.

Author:

    Chuck Lenzmeier (chuckl) 10-Dec-1993

Revision History:

--*/

#ifndef _SMBIPX_
#define _SMBIPX_

#define SMB_IPX_SERVER_SOCKET    0x5005    // 0x0550 in high-low format
#define SMB_IPX_NAME_SOCKET      0x5105    // 0x0551 in high-low format
#define SMB_IPX_REDIR_SOCKET     0x5205    // 0x0552 in high-low format
#define SMB_IPX_MAILSLOT_SOCKET  0x5305    // 0x0553 in high-low format
#define SMB_IPX_MESSENGER_SOCKET 0x5405    // 0x0554 in high-low format

#define SMB_ERR_BAD_SID 0x10
#define SMB_ERR_WORKING 0x11
#define SMB_ERR_NOT_ME  0x12

#define SMB_IPX_NAME_LENGTH 16

typedef struct _SMB_IPX_NAME_PACKET {
    UCHAR Route[32];
    UCHAR Operation;
    UCHAR NameType;
    USHORT MessageId;
    UCHAR Name[SMB_IPX_NAME_LENGTH];
    UCHAR SourceName[SMB_IPX_NAME_LENGTH];
} SMB_IPX_NAME_PACKET;
typedef SMB_IPX_NAME_PACKET SMB_UNALIGNED *PSMB_IPX_NAME_PACKET;

#define SMB_IPX_NAME_CLAIM          0xf1
#define SMB_IPX_NAME_DELETE         0xf2
#define SMB_IPX_NAME_QUERY          0xf3
#define SMB_IPX_NAME_FOUND          0xf4

#define SMB_IPX_MESSENGER_HANGUP    0xf5

#define SMB_IPX_MAILSLOT_SEND       0xfc
#define SMB_IPX_MAILSLOT_FIND       0xfd
#define SMB_IPX_MAILSLOT_FOUND      0xfe

#define SMB_IPX_NAME_TYPE_MACHINE       0x01
#define SMB_IPX_NAME_TYPE_WORKKGROUP    0x02
#define SMB_IPX_NAME_TYPE_BROWSER       0x03

#endif // _SMBIPX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\shdcom.h ===
#ifndef __SHDCOM_H__
#define __SHDCOM_H__

/* Common definitions, needed by Ring0 and Ring3 code */

#define CSC_DATABASE_VERSION    0x00010005  // major # in higher WORD, minor # in lower word

#define MIN_SPARSEFILL_PRI   1
#define MAX_SERVER_SHARE_NAME_FOR_CSC   64


#ifndef  WM_USER
#define  WM_USER                 0x400
#endif

#define  WM_FILE_OPENS           (WM_USER+1)
#define  WM_SHADOW_ADDED         (WM_USER+2)
#define  WM_SHADOW_DELETED       (WM_USER+3)
#define  WM_SHARE_DISCONNECTED  (WM_USER+4)


#define  WM_DIRTY    WM_USER+100
#define  WM_STALE    WM_USER+101
#define  WM_SPARSE   WM_USER+102

#ifndef IOCTL_RDR_BASE
#define IOCTL_RDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM
#endif //ifndef IOCTL_RDR_BASE

#define SHADOW_IOCTL_ENUM_BASE 1000
#define _SHADOW_IOCTL_CODE(__enum) \
                CTL_CODE(IOCTL_RDR_BASE,SHADOW_IOCTL_ENUM_BASE+__enum, METHOD_NEITHER, FILE_ANY_ACCESS)

#define  IOCTL_SHADOW_GETVERSION                (_SHADOW_IOCTL_CODE(0))

#define  IOCTL_SHADOW_REGISTER_AGENT            (_SHADOW_IOCTL_CODE(1))
#define  IOCTL_SHADOW_UNREGISTER_AGENT          (_SHADOW_IOCTL_CODE(2))
#define  IOCTL_SHADOW_GET_UNC_PATH              (_SHADOW_IOCTL_CODE(3))
#define  IOCTL_SHADOW_BEGIN_PQ_ENUM             (_SHADOW_IOCTL_CODE(4))
#define  IOCTL_SHADOW_END_PQ_ENUM               (_SHADOW_IOCTL_CODE(5))
#define  IOCTL_SHADOW_NEXT_PRI_SHADOW           (_SHADOW_IOCTL_CODE(6))
#define  IOCTL_SHADOW_PREV_PRI_SHADOW           (_SHADOW_IOCTL_CODE(7))
#define  IOCTL_SHADOW_GET_SHADOW_INFO           (_SHADOW_IOCTL_CODE(8))
#define  IOCTL_SHADOW_SET_SHADOW_INFO           (_SHADOW_IOCTL_CODE(9))
#define  IOCTL_SHADOW_CHK_UPDT_STATUS           (_SHADOW_IOCTL_CODE(10))
#define  IOCTL_DO_SHADOW_MAINTENANCE            (_SHADOW_IOCTL_CODE(11))
#define  IOCTL_SHADOW_COPYCHUNK                 (_SHADOW_IOCTL_CODE(12))
#define  IOCTL_SHADOW_BEGIN_REINT               (_SHADOW_IOCTL_CODE(13))
#define  IOCTL_SHADOW_END_REINT                 (_SHADOW_IOCTL_CODE(14))
#define  IOCTL_SHADOW_CREATE                    (_SHADOW_IOCTL_CODE(15))
#define  IOCTL_SHADOW_DELETE                    (_SHADOW_IOCTL_CODE(16))
#define  IOCTL_GET_SHARE_STATUS                 (_SHADOW_IOCTL_CODE(17))
#define  IOCTL_SET_SHARE_STATUS                 (_SHADOW_IOCTL_CODE(18))
#define  IOCTL_ADDUSE                           (_SHADOW_IOCTL_CODE(19))
#define  IOCTL_DELUSE                           (_SHADOW_IOCTL_CODE(20))
#define  IOCTL_GETUSE                           (_SHADOW_IOCTL_CODE(21))
#define  IOCTL_SWITCHES                         (_SHADOW_IOCTL_CODE(22))
#define  IOCTL_GETSHADOW                        (_SHADOW_IOCTL_CODE(23))
#define  IOCTL_GETGLOBALSTATUS                  (_SHADOW_IOCTL_CODE(24))
#define  IOCTL_FINDOPEN_SHADOW                  (_SHADOW_IOCTL_CODE(25))
#define  IOCTL_FINDNEXT_SHADOW                  (_SHADOW_IOCTL_CODE(26))
#define  IOCTL_FINDCLOSE_SHADOW                 (_SHADOW_IOCTL_CODE(27))
#define  IOCTL_GETPRIORITY_SHADOW               (_SHADOW_IOCTL_CODE(28))
#define  IOCTL_SETPRIORITY_SHADOW               (_SHADOW_IOCTL_CODE(29))
#define  IOCTL_ADD_HINT                         (_SHADOW_IOCTL_CODE(30))
#define  IOCTL_DELETE_HINT                      (_SHADOW_IOCTL_CODE(31))
#define  IOCTL_FINDOPEN_HINT                    (_SHADOW_IOCTL_CODE(32))
#define  IOCTL_FINDNEXT_HINT                    (_SHADOW_IOCTL_CODE(33))
#define  IOCTL_FINDCLOSE_HINT                   (_SHADOW_IOCTL_CODE(34))
#define  IOCTL_GET_IH_PRIORITY                  (_SHADOW_IOCTL_CODE(35))
#define  IOCTL_GETALIAS_HSHADOW                 (_SHADOW_IOCTL_CODE(36))
#define  IOCTL_GET_DEBUG_INFO                   (_SHADOW_IOCTL_CODE(37))

// the following are only used on NT but there's no harm in defining them for win9x as well
#define  IOCTL_OPENFORCOPYCHUNK                 (_SHADOW_IOCTL_CODE(40))
#define  IOCTL_CLOSEFORCOPYCHUNK                (_SHADOW_IOCTL_CODE(41))

#define IOCTL_IS_SERVER_OFFLINE                 (_SHADOW_IOCTL_CODE(42))
#define IOCTL_TRANSITION_SERVER_TO_ONLINE       (_SHADOW_IOCTL_CODE(43))
#define IOCTL_TRANSITION_SERVER_TO_OFFLINE      (_SHADOW_IOCTL_CODE(44))
#define IOCTL_NAME_OF_SERVER_GOING_OFFLINE      (_SHADOW_IOCTL_CODE(45))
#define IOCTL_TAKE_SERVER_OFFLINE               (_SHADOW_IOCTL_CODE(46))
#define IOCTL_SHAREID_TO_SHARENAME              (_SHADOW_IOCTL_CODE(47))

#define  CSC_IOCTL_MIN      IOCTL_SHADOW_GETVERSION
#define  CSC_IOCTL_MAX_W9X  IOCTL_GETALIAS_HSHADOW
#define  CSC_IOCTL_MAX_NT   IOCTL_SHAREID_TO_SHARENAME


// Sub operations for IOCTL_DO_SHADOW_MAINTENATCE

#define SHADOW_MAKE_SPACE               1
#define SHADOW_REDUCE_REFPRI            2
#define SHADOW_ADD_SPACE                3
#define SHADOW_FREE_SPACE               4
#define SHADOW_GET_SPACE_STATS          5
#define SHADOW_SET_MAX_SPACE            6
#define SHADOW_PER_THREAD_DISABLE       7
#define SHADOW_PER_THREAD_ENABLE        8
#define SHADOW_REINIT_DATABASE          9
#define SHADOW_ADDHINT_FROM_INODE       10
#define SHADOW_DELETEHINT_FROM_INODE    11
#define SHADOW_COPY_INODE_FILE          12
#define SHADOW_BEGIN_INODE_TRANSACTION  13
#define SHADOW_END_INODE_TRANSACTION    14
#define SHADOW_FIND_CREATE_PRINCIPAL_ID 15
#define SHADOW_GET_SECURITY_INFO        16
#define SHADOW_SET_EXCLUSION_LIST       17
#define SHADOW_SET_BW_CONSERVE_LIST     18
#define SHADOW_TRANSITION_SERVER_TO_OFFLINE 19
#define SHADOW_CHANGE_HANDLE_CACHING_STATE  20
#define SHADOW_RECREATE                     21
#define SHADOW_RENAME                       22
#define SHADOW_SPARSE_STALE_DETECTION_COUNTER   23
#define SHADOW_ENABLE_CSC_FOR_USER              24
#define SHADOW_DISABLE_CSC_FOR_USER             25
#define SHADOW_SET_DATABASE_STATUS              26
#define SHADOW_PURGE_UNPINNED_FILES             27
#define SHADOW_MANUAL_FILE_DETECTION_COUNTER    28

// persistent status flags on files/directories in the CSC database

#define  SHADOW_DIRTY               0x0001   // Contents of file/dir modified while offline

#define  SHADOW_ATTRIB_CHANGE       0x0002  // attributes have been changed offline

#define  SHADOW_TIME_CHANGE         0x0004  // lastmodtime changed offline

#define  SHADOW_STALE               0x0008  // file/dir replic is not in sync with server copy

#define  SHADOW_DELETED             0x0010  // file/dir was deleted in an offline operation

#define  SHADOW_SPARSE              0x0020  // file/dir is not completely filled up

#define  SHADOW_BUSY                0x0040  //

#define  SHADOW_REUSED              0x0080  // A replica name has been reused during an offline
                                            // operation of delete follwed by a create

#define  SHADOW_ORPHAN              0x0100  // used to be a replica but the original has vanished
                                            // from the server

#define  SHADOW_SUSPECT             0x0200  // writes failed on this shadow


#define  SHADOW_LOCALLY_CREATED     0x0400  // File/directory created offline


#define  SHADOW_LOCAL_INODE         0x4000  // This has meaning only for an inode,
                                            // it means that the inode was created while offline

#define  SHADOW_NOT_FSOBJ           0x8000  // This is only a hint


//not used...incorrect #define  mShadowIsFsObj(uStatus)    (((uStatus) & SHADOW_FILESYSTEM_OBJECT)==0)
#define  mShadowHintType(uStatus)   ((uStatus) & SHADOW_HINT_MASK)
#define  mSetHintType(uStatus, type)         ((uStatus) = ((uStatus) & ~SHADOW_HINT_MASK) | ((type) & SHADOW_HINT_MASK))

#define  SHADOW_IS_FILE             0x80000000   // flag ored at runtime for PQ enumeration
#define  SHADOW_FILE_IS_OPEN        0x40000000   // flag ored at runtime for dir enumeration


#define  SHADOW_MODFLAGS         (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_LOCALLY_CREATED|SHADOW_DELETED|SHADOW_REUSED)



// Flags defined for a share entry in the CSC database

#define SHARE_REINT                0x0001  // Needs reintegration (persistent)
#define SHARE_CONFLICTS            0x0002  // Conflicts while merging (Persistent)
#define SHARE_ERRORS               0x0004  // Database errors (Persistent)
//                                  0x0008  // free
#define SHARE_PRESERVES_CASE       0x0010  // (Persistent) may be expendable
#define SHARE_SUPPORTS_LFN         0x0020  // (Persistent) may be expendable

// share caching types (derived from the SMB spec).
// These are set by the admin on the server side.

#define SHARE_MANUAL_REINT          0x0000  // No automatic file by file reint  (Persistent)
#define SHARE_AUTO_REINT            0x0040  // File by file reint is OK         (Persistent)
#define SHARE_VDO                   0x0080  // no need to flow opens            (Persistent)
#define SHARE_NO_CACHING            0x00c0  // client should not cache this share (Persistent)

#define SHARE_CACHING_MASK         0x00c0  // type of caching


// in memory flags
#define  SHARE_FINDS_IN_PROGRESS   0x0200  // has finds in progress
#define  SHARE_FILES_OPEN          0x0400  // has files open
#define  SHARE_CONNECTED           0x0800  // Share is connected right now
#define  SHARE_SHADOWNP            0x1000  // A shadow connection
#define  SHARE_PINNED_OFFLINE      0x2000  // Don't auto-reconnect
#define  SHARE_MERGING             0x4000  // free
#define  SHARE_DISCONNECTED_OP     0x8000  // Disconnected operation in progress




// NB these are identical to
#define  mShadowLocallyCreated(uFlags) ((uFlags) & SHADOW_LOCALLY_CREATED)
#define  mShadowStale(uFlags)          ((uFlags) & SHADOW_STALE)
#define  mShadowDirty(uFlags)          ((uFlags) & SHADOW_DIRTY)
#define  mShadowTimeChange(uFlags)     ((uFlags) & SHADOW_TIME_CHANGE)
#define  mShadowAttribChange(uFlags)   ((uFlags) & SHADOW_ATTRIB_CHANGE)
#define  mShadowSparse(uFlags)         ((uFlags) & SHADOW_SPARSE)
#define  mShadowBusy(uFlags)           ((uFlags) & SHADOW_BUSY)
#define  mShadowSuspect(uFlags)        ((uFlags) & SHADOW_SUSPECT)
#define  mShadowDeleted(uFlags)        ((uFlags) & SHADOW_DELETED)
#define  mShadowReused(uFlags)         ((uFlags) & SHADOW_REUSED)
#define  mShadowOrphan(uFlags)         ((uFlags) & SHADOW_ORPHAN)

#define  mShadowNeedReint(uFlags)      ((uFlags) & (SHADOW_MODFLAGS))
#define  mShadowConflict(uFlags)       (((uFlags) & SHADOW_STALE) && ((uFlags) & SHADOW_MODFLAGS))
#define  mShadowUsable(uFlags)         (!((uFlags) & (SHADOW_STALE|SHADOW_SUSPECT)))

#define  mShadowIsFile(uFlags)         ((uFlags) & SHADOW_IS_FILE)

#define  SHADOW_FLAGS_BITOP_MASK    0xf
#define  SHADOW_FLAGS_ASSIGN        0
#define  SHADOW_FLAGS_AND           1
#define  SHADOW_FLAGS_OR            2

#define  SHADOW_OBJECT_FINDFIRST    3
#define  SHADOW_OBJECT_FINDNEXT     4
#define  SHADOW_OBJECT_FINDCLOSE    5

#define  SHADOW_HINT_FINDFIRST      6
#define  SHADOW_HINT_FINDNEXT       7
#define  SHADOW_HINT_FINDCLOSE      8

#define  SHADOW_HINT_ADD            9
#define  SHADOW_DELETE_HINT         10

#define SHADOW_FLAGS_COMMAND_MASK        0xff00
#define SHADOW_FLAGS_DONT_UPDATE_ORGTIME 0x1000
#define SHADOW_FLAGS_TRUNCATE_DATA       0x2000
#define SHADOW_FLAGS_FORCE_RELINK        0x4000 // forces the entry at the top of PQ even if
                                                // it's current priority is MAX_PRI and all
                                                // it's predecessors are MAX_PRI
#define SHADOW_FLAGS_CHANGE_83NAME       0x8000 // applicable to setshadowinfo
#define SHADOW_FLAGS_SET_REFRESH_TIME    0x0100 // setshadowinfo will update lastrefreshed time

#define  mBitOpShadowFlags(uOp)  ((uOp) & SHADOW_FLAGS_BITOP_MASK)
#define  mOrShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_OR)
#define  mAndShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_AND)
#define  mAssignShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_ASSIGN)

#define  mSetShadowFlagsOp(uVar, uOp)  (((uVar) &= ~SHADOW_FLAGS_BITOP_MASK), (uVar) |= (uOp))
#define  mSetSetShadowCommand(uVar, uCommand)   (((uVar) &= ~SHADOW_FLAGS_COMMAND_MASK), (uVar) |= uCommand)

#define  mDontUpdateOrgTime(uOp)    ((uOp) & SHADOW_FLAGS_DONT_UPDATE_ORGTIME)
#define  mTruncateDataCommand(uOp)  ((uOp) & SHADOW_FLAGS_TRUNCATE_DATA)
#define  mForceRelink(uOp)          ((uOp) & SHADOW_FLAGS_FORCE_RELINK)
#define  mChange83Name(uOp)         ((uOp) & SHADOW_FLAGS_CHANGE_83NAME)
#define  mSetLastRefreshTime(uOp)   ((uOp) & SHADOW_FLAGS_SET_REFRESH_TIME)

#define  SHADOW_SWITCH_SHADOWING        0x0001
#define  SHADOW_SWITCH_LOGGING          0x0002
#define  SHADOW_SWITCH_SHADOWFIND       0x0004
#define  SHADOW_SWITCH_SPEAD_OPTIMIZE   0x0008
#define  SHADOW_SWITCH_REMOTE_BOOT      0x0010

#define  SHADOW_SWITCH_OFF             1
#define  SHADOW_SWITCH_ON              2
#define  SHADOW_SWITCH_GET_STATE       3

#define  mSetBits(uFlags, uBits)    ((uFlags) |= (uBits))
#define  mClearBits(uFlags, uBits)  ((uFlags) &= ~(uBits))
#define  mQueryBits(uFlags, uBits)      ((uFlags) & (uBits))

#ifndef CSC_ON_NT
#define FlagOn(uFlags, uBit)    (mQueryBits(uFlags, uBit) != 0)
#endif

#define RETAIN_VALUE                0xffffffff

// pin flags
// NTRAID#455275-shishirp-1/31/2000, we ended up replicating these in cscapi.h

#define FLAG_CSC_HINT_PIN_USER                  0x01
#define FLAG_CSC_HINT_PIN_INHERIT_USER          0x02
#define FLAG_CSC_HINT_PIN_INHERIT_SYSTEM        0x04
#define FLAG_CSC_HINT_CONSERVE_BANDWIDTH        0x08
#define FLAG_CSC_HINT_PIN_SYSTEM                0x10

#define FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT   0x80000000
#define FLAG_CSC_HINT_COMMAND_MASK              0xf0000000
#define FLAG_CSC_HINT_INHERIT_MASK               (FLAG_CSC_HINT_PIN_INHERIT_USER|FLAG_CSC_HINT_PIN_INHERIT_SYSTEM)

#define mPinFlags(ulHintFlags)          ((ulHintFlags) & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))
#define mPinInheritFlags(ulHintFlags)   ((ulHintFlags) & (FLAG_CSC_HINT_PIN_INHERIT_USER|FLAG_CSC_HINT_PIN_INHERIT_SYSTEM))
#define mPinCommand(ulHintFlags)        ((ulHintFlags) & FLAG_CSC_HINT_COMMAND_MASK)
#define mPinAlterCount(ulHintFlags)     ((ulHintFlags) & FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT)

// These defines are here for historical reasons, they are not used anymore
// Hint, Hint
#define  HINT_FLAG_TYPE_MASK        0x03
#define  HINT_EXCLUSION             0x04
#define  HINT_WILDCARD              0x08

#define  HINT_TYPE_FILE             1
#define  HINT_TYPE_FOLDER           2
#define  HINT_TYPE_SUBTREE          3
//
#define  mNotFsobj(uStatus)         ((uStatus) & SHADOW_NOT_FSOBJ)
#define  mIsHint(uHF)               ((uHF) & HINT_FLAG_TYPE_MASK)
#define  mHintSubtree(uHF)          (((uHF) & HINT_FLAG_TYPE_MASK)==HINT_TYPE_SUBTREE)
#define  mHintExclude(uHF)          ((uHF) & HINT_EXCLUSION)
#define  mHintWildcard(uHF)         ((uHF) & HINT_WILDCARD)



#ifdef  VxD
typedef _WIN32_FIND_DATA   WIN32_FIND_DATA, *PFIND32, far *LPFIND32;
typedef _FILETIME   FILETIME;
#else
typedef LPWIN32_FIND_DATAW   LPFIND32;
#endif

#ifdef CSC_RECORDMANAGER_WINNT
typedef _FILETIME   FILETIME;
#endif

typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;

typedef  ULONG  *PHSHARE;
typedef  ULONG  *PHSERVER;
typedef  ULONG  *PHSHADOW;

#ifdef  VxD
typedef USHORT  wchar_t;
#endif
typedef wchar_t *PWCHAR;
typedef wchar_t *LPWCH, *PWCH;
typedef CONST wchar_t *LPCWCH, *PCWCH;
typedef wchar_t *NWPSTR;
typedef wchar_t *LPWSTR, *PWSTR;

typedef CONST wchar_t *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;
typedef VOID    *CSC_ENUMCOOKIE;

typedef struct tagSTOREDATA
{
    ULONG   ulSize;           // Max shadow data size
    ULONG   ucntDirs;         // Current count of dirs
    ULONG   ucntFiles;        // Current count of files
}
STOREDATA;


#ifndef __COPYCHUNKCONTEXT__
#define __COPYCHUNKCONTEXT__
typedef struct tagCOPYCHUNKCONTEXT
{
    DWORD   dwFlags;
    ULONG   LastAmountRead;
    ULONG   TotalSizeBeforeThisRead;
    HANDLE  handle;
    ULONG   ChunkSize;
    ULONG   Context[1];
}
COPYCHUNKCONTEXT;
#endif

#define COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN 0x00000001

typedef struct tagSHADOWSTORE
{
    ULONG       uFlags;
    STOREDATA   sMax;
    STOREDATA   sCur;
}
SHADOWSTORE;


typedef struct tagCOPYPARAMSA
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG    uOp;
            HSHARE   hShare;
            HSHADOW  hDir;
            HSHADOW  hShadow;
            LPSTR    lpLocalPath;
            LPSTR    lpRemotePath;
            LPSTR    lpSharePath;
        };
    };
}
COPYPARAMSA;

typedef struct tagCOPYPARAMSW
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG       uOp;
            HSHARE      hShare;
            HSHADOW     hDir;
            HSHADOW     hShadow;
            LPWSTR      lpLocalPath;
            LPWSTR      lpRemotePath;
            LPWSTR      lpSharePath;
        };
    };
}
COPYPARAMSW;

typedef struct tagPQPARAMS
{
    union
    {
        DWORD   dwError;
        struct
        {
            HSHARE      hShare;
            HSHADOW     hDir;
            HSHADOW     hShadow;
            ULONG       ulStatus;
            ULONG       ulRefPri;
            ULONG       ulIHPri;
            ULONG       ulHintFlags;
            ULONG       ulHintPri;
            CSC_ENUMCOOKIE       uEnumCookie;
            ULONG       uPos;
            DWORD       dwPQVersion;
        };
    };
}
PQPARAMS;

typedef struct tagSHADOWINFO
{
    union
    {
        DWORD   dwError;
        struct
        {
            HSHARE     hShare;            // share ID
            HSHADOW     hDir;               // directory inode
            HSHADOW     hShadow;            // inode for the item
            union
            {
                HSHADOW     hShadowOrg;         // original inode, applies only to a replica
                HSHADOW     hDirTo;             // input for renaming hShadowFrom into hDirTo
            };
            FILETIME    ftOrgTime;          // the timestamp of a replica as obtained
            FILETIME    ftLastRefreshTime;  // last time a replica was refreshed
            union
            {
                LPFIND32    lpFind32;
                LPVOID      lpBuffer;
            };

            ULONG       uStatus;            // status of the item in the database

            ULONG       ulRefPri;

            union
            {
                ULONG       ulPrincipalID;
                ULONG       ulIHPri;
                ULONG       uRootStatus;
            };

            ULONG       ulHintFlags;

            ULONG       ulHintPri;

            union
            {
                ULONG       uOp;
                ULONG       uSubOperation;
            };

            CSC_ENUMCOOKIE  uEnumCookie;
            ULONG       cbBufferSize;
            DWORD       dwNameSpaceVersion;
        };

    };
}
SHADOWINFO;

#define  FINDOPEN_SHADOWINFO_NORMAL   0x1
#define  FINDOPEN_SHADOWINFO_SPARSE   0x2
#define  FINDOPEN_SHADOWINFO_DELETED  0x4
#define  FINDOPEN_SHADOWINFO_ALL      0x7

typedef struct tagSHAREINFOW
{
    union
    {
        DWORD   dwError;

        struct
        {
            HSHARE  hShare;
            USHORT usCaps;        // Type of resource
            USHORT usState;       // State of the resource (connected/paused etc.)
            unsigned    short rgSharePath[MAX_SERVER_SHARE_NAME_FOR_CSC];    // name of the path
            unsigned    short rgFileSystem[16];    // name of the file system
        };
    };
}
SHAREINFOW;

typedef struct tagSHAREINFOA
{
    union
    {
        DWORD   dwError;

        struct
        {
            HSHARE  hShare;
            USHORT usCaps;        // Type of resource
            USHORT usState;       // State of the resource (connected/paused etc.)
            char rgSharePath[MAX_SERVER_SHARE_NAME_FOR_CSC];    // name of the path
            char rgFileSystem[16];    // name of the file system
        };
    };
}
SHAREINFOA;


typedef struct tagGLOBALSTATUS
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG       uFlagsEvents;     // Reports the latest events noted
            ULONG       uDatabaseErrorFlags;
            SHADOWSTORE sST;
            HSHADOW     hShadowAdded;
            HSHADOW     hDirAdded;
            HSHADOW     hShadowDeleted;
            HSHADOW     hDirDeleted;
            int         cntFileOpen;   // Count of file opens
            HSHARE     hShareDisconnected;
        };
    };
}
GLOBALSTATUS, *LPGLOBALSTATUS;

typedef struct  tagSECURITYINFO
{
    ULONG   ulPrincipalID;      // identifier of the principal
    ULONG   ulPermissions;      // permissions mask
}
SECURITYINFO, *LPSECURITYINFO;

// achtung, these should match with those in the cscsec.h

#define CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS (0x4)
#define CSC_GUEST_PRINCIPAL_ID           (0xfffe)
#define CSC_INVALID_PRINCIPAL_ID         (0x0)


#define FLAG_GLOBALSTATUS_SHADOW_ADDED          0x0001
#define FLAG_GLOBALSTATUS_SHADOW_DELETED        0x0002
#define FLAG_GLOBALSTATUS_FILE_OPENS            0x0004
#define FLAG_GLOBALSTATUS_SHADOW_SPACE          0x0008
#define FLAG_GLOBALSTATUS_SHARE_DISCONNECTED    0x0010
#define FLAG_GLOBALSTATUS_STOP                  0x0020
#define FLAG_GLOBALSTATUS_START                 0x0040
#define FLAG_GLOBALSTATUS_NO_NET                0x0080
#define FLAG_GLOBALSTATUS_GOT_NET               0x0100
#define FLAG_GLOBALSTATUS_INVOKE_AUTODIAL       0x0200
#define FLAG_GLOBALSTATUS_INVOKE_FREESPACE      0x0400

#define FLAG_DATABASESTATUS_DIRTY                   0x00000001
#define FLAG_DATABASESTATUS_ENCRYPTION_MASK         0x00000006
#define FLAG_DATABASESTATUS_UNENCRYPTED             0x00000000 // new inodes will NOT be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED   0x00000004
#define FLAG_DATABASESTATUS_ENCRYPTED               0x00000002 // new fileinodes will be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED     0x00000006

#define mDatabaseEncryptionEnabled(ulGlobalStatus)  ((ulGlobalStatus) & 0x00000002)

#define mDatabasePartiallyEncrypted(ulGlobalStatus) (((ulGlobalStatus) & FLAG_DATABASESTATUS_ENCRYPTION_MASK)==FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED)
#define mDatabasePartiallyUnencrypted(ulGlobalStatus) (((ulGlobalStatus) & FLAG_DATABASESTATUS_ENCRYPTION_MASK)==FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED)

//
// Neutral ANSI/UNICODE types and macros
//
#ifndef _TCHAR_DEFINED

#ifdef  UNICODE                     // r_winnt

typedef wchar_t TCHAR, *PTCHAR;
typedef wchar_t TBYTE , *PTBYTE ;

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR LPCTSTR;
typedef LPWSTR LP;
#define _TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define _TEXT(quote) quote      // r_winnt

#endif /* UNICODE */                // r_winnt

#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

#ifdef VXD

#define UNICODE

#endif

#ifdef  UNICODE

#define COPYPARAMS      COPYPARAMSW
#define SHAREINFO      SHAREINFOW
#define LPCOPYPARAMS    LPCOPYPARAMSW
#define LPSHAREINFO    LPSHAREINFOW
#else

#define COPYPARAMS  COPYPARAMSA
#define SHAREINFO  SHAREINFOA
#define LPCOPYPARAMS    LPCOPYPARAMSA
#define LPSHAREINFO    LPSHAREINFOA
#endif

#ifdef   VxD
typedef HSHARE       *LPHSHARE;
typedef HSHADOW      *LPHSHADOW;
typedef SHADOWSTORE  *LPSHADOWSTORE;
typedef SHADOWINFO   *LPSHADOWINFO;
typedef STOREDATA    *LPSTOREDATA;
typedef PQPARAMS     *LPPQPARAMS;
typedef COPYPARAMSA  *LPCOPYPARAMSA;
typedef SHAREINFOA  *LPSHAREINFOA;
typedef COPYPARAMSW  *LPCOPYPARAMSW;
typedef SHAREINFOW  *LPSHAREINFOW;
#else
typedef HSHARE       FAR *LPHSHARE;
typedef HSHADOW      FAR *LPHSHADOW;
typedef SHADOWSTORE  FAR *LPSHADOWSTORE;
typedef SHADOWINFO   FAR *LPSHADOWINFO;
typedef STOREDATA    FAR *LPSTOREDATA;
typedef PQPARAMS     FAR *LPPQPARAMS;
typedef COPYPARAMS   FAR *LPCOPYPARAMS;
typedef COPYPARAMSA  FAR *LPCOPYPARAMSA;
typedef SHAREINFOA  FAR *LPSHAREINFOA;
typedef COPYPARAMSW  FAR *LPCOPYPARAMSW;
typedef SHAREINFOW  FAR *LPSHAREINFOW;
#endif



// UNICODE versions of registry key/value names

// kept for hist(y)rical reasons
#define REG_KEY_IEXPLORER                       _TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REG_KEY_SHADOW                          _TEXT("System\\CurrentControlSet\\Services\\VxD\\Shadow")

// settings exclusively used by cscdll.dll

#define REG_KEY_CSC_SETTINGS                    _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\CSCSettings")
#define REG_STRING_DATABASE_LOCATION            _TEXT("DatabaseLocation")
#define REG_VALUE_DATABASE_SIZE                 _TEXT("DatabaseSizePercent")
#define REG_VALUE_ENABLED                       _TEXT("Enabled")


// settings defined by UI and policy

#define REG_STRING_POLICY_NETCACHE_KEY          _TEXT("Software\\Policies\\Microsoft\\Windows\\NetCache")
#define REG_STRING_NETCACHE_KEY                 _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache")
#define REG_STRING_EXCLUSION_LIST               _TEXT("ExcludeExtensions")
#define REG_STRING_BANDWIDTH_CONSERVATION_LIST  _TEXT("BandwidthConservationList")
#define REG_VALUE_FORMAT_DATABASE               _TEXT("FormatDatabase")

// ANSI versions of registry key/value names

// kept for hist(y)rical reasons
#define REG_KEY_IEXPLORER_A                     "Software\\Microsoft\\Internet Explorer\\Main"
#define REG_KEY_SHADOW_A                        "System\\CurrentControlSet\\Services\\VxD\\Shadow"

// settings exclusively used by cscdll.dll

#define REG_KEY_CSC_SETTINGS_A                  "Software\\Microsoft\\Windows\\CurrentVersion\\CSCSettings"
#define REG_STRING_DATABASE_LOCATION_A          "DatabaseLocation"
#define REG_VALUE_DATABASE_SIZE_A               "DatabaseSizePercent"
#define REG_VALUE_ENABLED_A                     "Enabled"

// settings defined by UI and policy

#define REG_STRING_POLICY_NETCACHE_KEY_A        "Software\\Policies\\Microsoft\\Windows\\NetCache"
#define REG_STRING_NETCACHE_KEY_A               "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache"
#define REG_STRING_EXCLUSION_LIST_A             "ExcludeExtensions"
#define REG_STRING_BANDWIDTH_CONSERVATION_LIST_A "BandwidthConservationList"
#define REG_STRING_ENCRYPTED_A                  "Encrypted"
#define REG_STRING_ENCRYPT_DECRYPT_A            "EcDc"

#define REG_VALUE_FORMAT_DATABASE_A             "FormatDatabase"

#define SESSION_EVENT_NAME_NT L"\\BaseNamedObjects\\jjCSCSessEvent_UM_KM"
#define SHARED_FILL_EVENT_NAME_NT L"\\BaseNamedObjects\\jjCSCSharedFillEvent_UM_KM"
#define IFNOT_CSC_RECORDMANAGER_WINNT if(FALSE)
#define IF_CSC_RECORDMANAGER_WINNT if(TRUE)
#define WINNT_DOIT(x__) x__

int ShadowLog(
    LPSTR lpFmt,
    ...
    );

#define DoCSCLog(__x)   ShadowLog __x

extern DWORD    dwDebugLogVector;

#define DEBUG_LOG(__bits, __x) {\
    if (((DEBUG_LOG_BIT_##__bits)==0) || FlagOn(dwDebugLogVector,(DEBUG_LOG_BIT_##__bits))){\
            DoCSCLog(__x); \
        }\
    }

#define DEBUG_LOG_BIT_RECORD    0x00000001
#define DEBUG_LOG_BIT_CSHADOW   0x00000002

#endif //#ifndef __SHDCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    smb.h

Abstract:

    This file contains request and response structure definitions
    for the specific parameters of each SMB command, as well as codes
    for SMB commands and errors.

Author:

    David R. Treadwell (davidtr) 27-Sept-1989 (from LanMan 1.2 code)

Revision History:

--*/

#ifndef _SMB_
#define _SMB_

//#include <nt.h>

//#include <smbtypes.h>


/*

Inclusion of SMB request/response structures in this file is
conditionalized in the following way:

    If INCLUDE_SMB_ALL is defined, all of the structures are defined.

    Otherwise, the following names, if defined, cause inclusion of the
    corresponding SMB categories:

        INCLUDE_SMB_ADMIN           Administrative requests:
                                        PROCESS_EXIT
                                        NEGOTIATE
                                        SESSION_SETUP_ANDX
                                        LOGOFF_ANDX

        INCLUDE_SMB_TREE            Tree connect requests:
                                        TREE_CONNECT
                                        TREE_DISCONNECT
                                        TREE_CONNECT_ANDX

        INCLUDE_SMB_DIRECTORY       Directory-related requests:
                                        CREATE_DIRECTORY
                                        DELETE_DIRECTORY
                                        CHECK_DIRECTORY

        INCLUDE_SMB_OPEN_CLOSE      File open and close requests:
                                        OPEN
                                        CREATE
                                        CLOSE
                                        CREATE_TEMPORARY
                                        CREATE_NEW
                                        OPEN_ANDX
                                        CLOSE_AND_TREE_DISC

        INCLUDE_SMB_READ_WRITE      Read and write requests:
                                        READ
                                        WRITE
                                        SEEK
                                        LOCK_AND_READ
                                        WRITE_AND_UNLOCK
                                        WRITE_AND_CLOSE
                                        READ_ANDX
                                        WRITE_ANDX


        INCLUDE_SMB_FILE_CONTROL    File control requests:
                                        FLUSH
                                        DELETE
                                        RENAME
                                        COPY
                                        MOVE

        INCLUDE_SMB_QUERY_SET       File query/set requests:
                                        QUERY_INFORMATION
                                        SET_INFORMATION
                                        QUERY_INFORMATION2
                                        SET_INFORMATION2
                                        QUERY_PATH_INFORMATION
                                        SET_PATH_INFORMATION
                                        QUERY_FILE_INFORMATION
                                        SET_FILE_INFORMATION

        INCLUDE_SMB_LOCK            Lock requests (not LOCK_AND_READ)
                                        LOCK_BYTE_RANGE
                                        UNLOCK_BYTE_RANGE
                                        LOCKING_ANDX

        INCLUDE_SMB_RAW             Raw read/write requests:
                                        READ_RAW
                                        WRITE_RAW

        INCLUDE_SMB_MPX             Multiplexed requests:
                                        READ_MPX
                                        WRITE_MPX

        INCLUDE_SMB_SEARCH          Search requests:
                                        FIND_CLOSE2
                                        FIND_NOTIFY_CLOSE
                                        SEARCH
                                        FIND
                                        FIND_UNIQUE
                                        FIND_CLOSE

        INCLUDE_SMB_TRANSACTION     Transaction and IOCTL requests:
                                        TRANSACTION
                                        IOCTL
                                        TRANSACTION2
                                        NTTRANSACTION

        INCLUDE_SMB_PRINT           Printer requests:
                                        OPEN_PRINT_FILE
                                        WRITE_PRINT_FILE
                                        CLOSE_PRINT_FILE
                                        GET_PRINT_QUEUE

        INCLUDE_SMB_MESSAGE         Message requests:
                                        SEND_MESSAGE
                                        SEND_BROADCAST_MESSAGE
                                        FORWARD_USER_NAME
                                        CANCEL_FORWARD
                                        GET_MACHINE_NAME
                                        SEND_START_MB_MESSAGE
                                        SEND_END_MB_MESSAGE
                                        SEND_TEXT_MB_MESSAGE

        INCLUDE_SMB_MISC            Miscellaneous requests:
                                        QUERY_INFORMATION_SRV
                                        ECHO
                                        QUERY_INFORMATION_DISK
*/

#ifdef INCLUDE_SMB_ALL

#define INCLUDE_SMB_ADMIN
#define INCLUDE_SMB_TREE
#define INCLUDE_SMB_DIRECTORY
#define INCLUDE_SMB_OPEN_CLOSE
#define INCLUDE_SMB_FILE_CONTROL
#define INCLUDE_SMB_READ_WRITE
#define INCLUDE_SMB_LOCK
#define INCLUDE_SMB_RAW
#define INCLUDE_SMB_MPX
#define INCLUDE_SMB_QUERY_SET
#define INCLUDE_SMB_SEARCH
#define INCLUDE_SMB_TRANSACTION
#define INCLUDE_SMB_PRINT
#define INCLUDE_SMB_MESSAGE
#define INCLUDE_SMB_MISC

#endif // def INCLUDE_SMB_ALL


//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING

//
// SMB servers listen on two NETBIOS addresses to facilitate connections. The
// first one is a name formulated from the computer name by padding it with
// a number of blanks ( upto NETBIOS_NAME_LEN ). This name is registered and
// resolved using the NETBIOS name registration/resolution mechanism. They also
// register under a second name *SMBSERVER which is not a valuid netbios name
// but provides a name which can be used in NETBT session setup. This eliminates
// the need for querying the remote adapter status to obtain the name.
//

#define SMBSERVER_LOCAL_ENDPOINT_NAME "*SMBSERVER      "
#define SMBSERVER_LOCAL_ENDPOINT_NAME_UNICODE L"*SMBSERVER      "

//
// SMB Command code definitions:
//

// *** Start of SMB commands
#define SMB_COM_CREATE_DIRECTORY         (UCHAR)0x00
#define SMB_COM_DELETE_DIRECTORY         (UCHAR)0x01
#define SMB_COM_OPEN                     (UCHAR)0x02
#define SMB_COM_CREATE                   (UCHAR)0x03
#define SMB_COM_CLOSE                    (UCHAR)0x04
#define SMB_COM_FLUSH                    (UCHAR)0x05
#define SMB_COM_DELETE                   (UCHAR)0x06
#define SMB_COM_RENAME                   (UCHAR)0x07
#define SMB_COM_QUERY_INFORMATION        (UCHAR)0x08
#define SMB_COM_SET_INFORMATION          (UCHAR)0x09
#define SMB_COM_READ                     (UCHAR)0x0A
#define SMB_COM_WRITE                    (UCHAR)0x0B
#define SMB_COM_LOCK_BYTE_RANGE          (UCHAR)0x0C
#define SMB_COM_UNLOCK_BYTE_RANGE        (UCHAR)0x0D
#define SMB_COM_CREATE_TEMPORARY         (UCHAR)0x0E
#define SMB_COM_CREATE_NEW               (UCHAR)0x0F
#define SMB_COM_CHECK_DIRECTORY          (UCHAR)0x10
#define SMB_COM_PROCESS_EXIT             (UCHAR)0x11
#define SMB_COM_SEEK                     (UCHAR)0x12
#define SMB_COM_LOCK_AND_READ            (UCHAR)0x13
#define SMB_COM_WRITE_AND_UNLOCK         (UCHAR)0x14
#define SMB_COM_READ_RAW                 (UCHAR)0x1A
#define SMB_COM_READ_MPX                 (UCHAR)0x1B
#define SMB_COM_READ_MPX_SECONDARY       (UCHAR)0x1C    // server to redir only
#define SMB_COM_WRITE_RAW                (UCHAR)0x1D
#define SMB_COM_WRITE_MPX                (UCHAR)0x1E
#define SMB_COM_WRITE_MPX_SECONDARY      (UCHAR)0x1F
#define SMB_COM_WRITE_COMPLETE           (UCHAR)0x20    // server to redir only
#define SMB_COM_QUERY_INFORMATION_SRV    (UCHAR)0x21
#define SMB_COM_SET_INFORMATION2         (UCHAR)0x22
#define SMB_COM_QUERY_INFORMATION2       (UCHAR)0x23
#define SMB_COM_LOCKING_ANDX             (UCHAR)0x24
#define SMB_COM_TRANSACTION              (UCHAR)0x25
#define SMB_COM_TRANSACTION_SECONDARY    (UCHAR)0x26
#define SMB_COM_IOCTL                    (UCHAR)0x27
#define SMB_COM_IOCTL_SECONDARY          (UCHAR)0x28
#define SMB_COM_COPY                     (UCHAR)0x29
#define SMB_COM_MOVE                     (UCHAR)0x2A
#define SMB_COM_ECHO                     (UCHAR)0x2B
#define SMB_COM_WRITE_AND_CLOSE          (UCHAR)0x2C
#define SMB_COM_OPEN_ANDX                (UCHAR)0x2D
#define SMB_COM_READ_ANDX                (UCHAR)0x2E
#define SMB_COM_WRITE_ANDX               (UCHAR)0x2F
#define SMB_COM_CLOSE_AND_TREE_DISC      (UCHAR)0x31
#define SMB_COM_TRANSACTION2             (UCHAR)0x32
#define SMB_COM_TRANSACTION2_SECONDARY   (UCHAR)0x33
#define SMB_COM_FIND_CLOSE2              (UCHAR)0x34
#define SMB_COM_FIND_NOTIFY_CLOSE        (UCHAR)0x35
#define SMB_COM_TREE_CONNECT             (UCHAR)0x70
#define SMB_COM_TREE_DISCONNECT          (UCHAR)0x71
#define SMB_COM_NEGOTIATE                (UCHAR)0x72
#define SMB_COM_SESSION_SETUP_ANDX       (UCHAR)0x73
#define SMB_COM_LOGOFF_ANDX              (UCHAR)0x74
#define SMB_COM_TREE_CONNECT_ANDX        (UCHAR)0x75
#define SMB_COM_QUERY_INFORMATION_DISK   (UCHAR)0x80
#define SMB_COM_SEARCH                   (UCHAR)0x81
#define SMB_COM_FIND                     (UCHAR)0x82
#define SMB_COM_FIND_UNIQUE              (UCHAR)0x83
#define SMB_COM_FIND_CLOSE               (UCHAR)0x84
#define SMB_COM_NT_TRANSACT              (UCHAR)0xA0
#define SMB_COM_NT_TRANSACT_SECONDARY    (UCHAR)0xA1
#define SMB_COM_NT_CREATE_ANDX           (UCHAR)0xA2
#define SMB_COM_NT_CANCEL                (UCHAR)0xA4
#define SMB_COM_NT_RENAME                (UCHAR)0xA5
#define SMB_COM_OPEN_PRINT_FILE          (UCHAR)0xC0
#define SMB_COM_WRITE_PRINT_FILE         (UCHAR)0xC1
#define SMB_COM_CLOSE_PRINT_FILE         (UCHAR)0xC2
#define SMB_COM_GET_PRINT_QUEUE          (UCHAR)0xC3
#define SMB_COM_SEND_MESSAGE             (UCHAR)0xD0
#define SMB_COM_SEND_BROADCAST_MESSAGE   (UCHAR)0xD1
#define SMB_COM_FORWARD_USER_NAME        (UCHAR)0xD2
#define SMB_COM_CANCEL_FORWARD           (UCHAR)0xD3
#define SMB_COM_GET_MACHINE_NAME         (UCHAR)0xD4
#define SMB_COM_SEND_START_MB_MESSAGE    (UCHAR)0xD5
#define SMB_COM_SEND_END_MB_MESSAGE      (UCHAR)0xD6
#define SMB_COM_SEND_TEXT_MB_MESSAGE     (UCHAR)0xD7
// *** End of SMB commands

#define SMB_COM_NO_ANDX_COMMAND          (UCHAR)0xFF


//
// Header for SMBs, see #4 page 10
//
// *** Note that we do NOT define PSMB_HEADER as SMB_UNALIGNED!  This is
//     done on the assumption that the SMB header, at least, will always
//     be properly aligned.  If you need to access an unaligned header,
//     declare the pointer as SMB_UNALIGNED *SMB_HEADER.
//

#define SMB_SECURITY_SIGNATURE_LENGTH  8

typedef struct _SMB_HEADER {
    UCHAR Protocol[4];                  // Contains 0xFF,'SMB'
    UCHAR Command;                      // Command code
    UCHAR ErrorClass;                   // Error class
    UCHAR Reserved;                     // Reserved for future use
    _USHORT( Error );                   // Error code
    UCHAR Flags;                        // Flags
    _USHORT( Flags2 );                  // More flags
    union {
        _USHORT( Reserved2 )[6];        // Reserved for future use
        struct {
            _USHORT( PidHigh );         // High part of PID (NT Create And X)
            union {
                struct {
                    _ULONG( Key );              // Encryption key (IPX)
                    _USHORT( Sid );             // Session ID (IPX)
                    _USHORT( SequenceNumber );  // Sequence number (IPX)
                    _USHORT( Gid );             // Group ID (unused?)
                };
                UCHAR SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH];
                                         // Client must send the correct Signature
                                         // for this SMB to be accepted.
            };
        };
    };
    _USHORT( Tid );                     // Authenticated user/group
    _USHORT( Pid );                     // Caller's process id
    _USHORT( Uid );                     // Unauthenticated user id
    _USHORT( Mid );                     // multiplex id
#ifdef NO_PACKING                       // ***
    _USHORT( Kludge );                  // *** make sure parameter structs
#endif                                  // *** are longword aligned
} SMB_HEADER;
typedef SMB_HEADER *PSMB_HEADER;

typedef struct _NT_SMB_HEADER {
    UCHAR Protocol[4];                  // Contains 0xFF,'SMB'
    UCHAR Command;                      // Command code
    union {
        struct {
            UCHAR ErrorClass;           // Error class
            UCHAR Reserved;             // Reserved for future use
            _USHORT( Error );           // Error code
        } DosError;
        ULONG NtStatus;                 // NT-style 32-bit error code
    } Status;
    UCHAR Flags;                        // Flags
    _USHORT( Flags2 );                  // More flags
    union {
        _USHORT( Reserved2 )[6];        // Reserved for future use
        struct {
            _USHORT( PidHigh );         // High part of PID (NT Create And X)
            union {
                struct {
                    _ULONG( Key );              // Encryption key (IPX)
                    _USHORT( Sid );             // Session ID (IPX)
                    _USHORT( SequenceNumber );  // Sequence number (IPX)
                    _USHORT( Gid );             // Group ID (unused?)
                };
                UCHAR SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH];
                                         // Client must send the correct Signature
                                         // for this SMB to be accepted.
            };
        };
    };
    _USHORT( Tid );                     // Authenticated user/group
    _USHORT( Pid );                     // Caller's process id
    _USHORT( Uid );                     // Unauthenticated user id
    _USHORT( Mid );                     // multiplex id
#ifdef NO_PACKING                       // ***
    _USHORT( Kludge );                  // *** make sure parameter structs
#endif                                  // *** are longword aligned
} NT_SMB_HEADER;
typedef NT_SMB_HEADER *PNT_SMB_HEADER;

//
// The SMB header, protocol field, as a long.
//

#define SMB_HEADER_PROTOCOL   (0xFF + ('S' << 8) + ('M' << 16) + ('B' << 24))

//
// Minimum parameter structure that can be returned.  Used in returning
// error SMBs.
//
// *** Note that this structure does NOT have a Buffer field!
//

typedef struct _SMB_PARAMS {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of bytes that follow; min = 0
} SMB_PARAMS;
typedef SMB_PARAMS SMB_UNALIGNED *PSMB_PARAMS;

//
// Generic header for AndX commands.
//

typedef struct _GENERIC_ANDX {
    UCHAR WordCount;                    // Count of parameter words
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved
    _USHORT( AndXOffset );              // Offset (from SMB header start)
} GENERIC_ANDX;
typedef GENERIC_ANDX SMB_UNALIGNED *PGENERIC_ANDX;


#ifdef INCLUDE_SMB_MESSAGE

//
// Cancel Forward SMB, see #1 page 35
// Function is SrvSmbCancelForward()
// SMB_COM_CANCEL_FORWARD 0xD3
//

typedef struct _REQ_CANCEL_FORWARD {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR ForwardedName[];            //  Forwarded name
} REQ_CANCEL_FORWARD;
typedef REQ_CANCEL_FORWARD SMB_UNALIGNED *PREQ_CANCEL_FORWARD;

typedef struct _RESP_CANCEL_FORWARD {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CANCEL_FORWARD;
typedef RESP_CANCEL_FORWARD SMB_UNALIGNED *PRESP_CANCEL_FORWARD;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_DIRECTORY

//
// Check Directory SMB, see #1 page 23
// Function is SrvSmbCheckDirectory()
// SMB_COM_CHECK_DIRECTORY 0x10
//

typedef struct _REQ_CHECK_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryPath[];            //  Directory path
} REQ_CHECK_DIRECTORY;
typedef REQ_CHECK_DIRECTORY SMB_UNALIGNED *PREQ_CHECK_DIRECTORY;

typedef struct _RESP_CHECK_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CHECK_DIRECTORY;
typedef RESP_CHECK_DIRECTORY SMB_UNALIGNED *PRESP_CHECK_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Close SMB, see #1 page 10
// Function is SrvSmbClose()
// SMB_COM_CLOSE 0x04
//

typedef struct _REQ_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE;
typedef REQ_CLOSE SMB_UNALIGNED *PREQ_CLOSE;

typedef struct _RESP_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE;
typedef RESP_CLOSE SMB_UNALIGNED *PRESP_CLOSE;

#ifdef INCLUDE_SMB_IFMODIFIED

typedef struct _REQ_EXTENDED_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
    _ULONG( Flags );                    // NT_CREATE_xxx
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_EXTENDED_CLOSE;
typedef REQ_EXTENDED_CLOSE SMB_UNALIGNED *PREQ_EXTENDED_CLOSE;

#define SMB_RESP_EXTENDED_CLOSE_WORK_COUNT 32

typedef struct _RESP_EXTENDED_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 32
    _ULONG( FileAttributes );           // File attributes for creation
    _ULONG( Flags );                    // NT_CREATE_xxx
    TIME CreationTime;                  // The time the file was created
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    LARGE_INTEGER AllocationSize;       // Initial allocation size
    LARGE_INTEGER EndOfFile;            // The end of file offset

    LARGE_INTEGER UsnValue;             // The file's USN # in NTFS
    LARGE_INTEGER FileReferenceNumber;  //

    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_EXTENDED_CLOSE;
typedef RESP_EXTENDED_CLOSE SMB_UNALIGNED *PRESP_EXTENDED_CLOSE;

#endif // def INCLUDE_SMB_IFMODIFIED

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Close and Tree Disconnect SMB, see #? page ??
// Function is SrvSmbCloseAndTreeDisc
// SMB_COM_CLOSE_AND_TREE_DISC 0x31
//

typedef struct _REQ_CLOSE_AND_TREE_DISC {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE_AND_TREE_DISC;
typedef REQ_CLOSE_AND_TREE_DISC SMB_UNALIGNED *PREQ_CLOSE_AND_TREE_DISC;

typedef struct _RESP_CLOSE_AND_TREE_DISC {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE_AND_TREE_DISC;
typedef RESP_CLOSE_AND_TREE_DISC SMB_UNALIGNED *PRESP_CLOSE_AND_TREE_DISC;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_PRINT

//
// Close Print Spool File SMB, see #1 page 29
// Function is SrvSmbClosePrintSpoolFile()
// SMB_COM_CLOSE_PRINT_FILE 0xC2
//

typedef struct _REQ_CLOSE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE_PRINT_FILE;
typedef REQ_CLOSE_PRINT_FILE SMB_UNALIGNED *PREQ_CLOSE_PRINT_FILE;

typedef struct _RESP_CLOSE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE_PRINT_FILE;
typedef RESP_CLOSE_PRINT_FILE SMB_UNALIGNED *PRESP_CLOSE_PRINT_FILE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Copy SMB, see #2 page 23
// Function is SrvSmbCopy()
// SMB_COM_COPY 0x29
//

typedef struct _REQ_COPY {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Tid2 );                    // Second (target) path TID
    _USHORT( OpenFunction );            // What to do if target file exists
    _USHORT( Flags );                   // Flags to control copy operation:
                                        //  bit 0 - target must be a file
                                        //  bit 1 - target must ba a dir.
                                        //  bit 2 - copy target mode:
                                        //          0 = binary, 1 = ASCII
                                        //  bit 3 - copy source mode:
                                        //          0 = binary, 1 = ASCII
                                        //  bit 4 - verify all writes
                                        //  bit 5 - tree copy
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR SourceFileName[];           //  pathname of source file
    //UCHAR TargetFileName[];           //  pathname of target file
} REQ_COPY;
typedef REQ_COPY SMB_UNALIGNED *PREQ_COPY;

typedef struct _RESP_COPY {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of files copied
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // ASCIIZ pathname of file with error
} RESP_COPY;
typedef RESP_COPY SMB_UNALIGNED *PRESP_COPY;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Create SMB, see #1 page 9
// Create New SMB, see #1 page 23
// Function is SrvSmbCreate()
// SMB_COM_CREATE 0x03
// SMB_COM_CREATE_NEW 0x0F
//

typedef struct _REQ_CREATE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( FileAttributes );          // New file attributes
    _ULONG( CreationTimeInSeconds );        // Creation time
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_CREATE;
typedef REQ_CREATE SMB_UNALIGNED *PREQ_CREATE;

typedef struct _RESP_CREATE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CREATE;
typedef RESP_CREATE SMB_UNALIGNED *PRESP_CREATE;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_DIRECTORY

//
// Create Directory SMB, see #1 page 14
// Function is SrvSmbCreateDirectory
// SMB_COM_CREATE_DIRECTORY 0x00
//

typedef struct _REQ_CREATE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_CREATE_DIRECTORY;
typedef REQ_CREATE_DIRECTORY SMB_UNALIGNED *PREQ_CREATE_DIRECTORY;

typedef struct _RESP_CREATE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CREATE_DIRECTORY;
typedef RESP_CREATE_DIRECTORY SMB_UNALIGNED *PRESP_CREATE_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Create Temporary SMB, see #1 page 21
// Function is SrvSmbCreateTemporary()
// SMB_COM_CREATE_TEMPORARY 0x0E
//

typedef struct _REQ_CREATE_TEMPORARY {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_CREATE_TEMPORARY;
typedef REQ_CREATE_TEMPORARY SMB_UNALIGNED *PREQ_CREATE_TEMPORARY;

typedef struct _RESP_CREATE_TEMPORARY {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} RESP_CREATE_TEMPORARY;
typedef RESP_CREATE_TEMPORARY SMB_UNALIGNED *PRESP_CREATE_TEMPORARY;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Delete SMB, see #1 page 16
// Function is SrvSmbDelete()
// SMB_COM_DELETE 0x06
//

typedef struct _REQ_DELETE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_DELETE;
typedef REQ_DELETE SMB_UNALIGNED *PREQ_DELETE;

typedef struct _RESP_DELETE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_DELETE;
typedef RESP_DELETE SMB_UNALIGNED *PRESP_DELETE;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_DIRECTORY

//
// Delete Directory SMB, see #1 page 15
// Function is SrvSmbDeleteDirectory()
// SMB_COM_DELETE_DIRECTORY 0x01
//

typedef struct _REQ_DELETE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_DELETE_DIRECTORY;
typedef REQ_DELETE_DIRECTORY SMB_UNALIGNED *PREQ_DELETE_DIRECTORY;

typedef struct _RESP_DELETE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_DELETE_DIRECTORY;
typedef RESP_DELETE_DIRECTORY SMB_UNALIGNED *PRESP_DELETE_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_MISC

//
// Echo SMB, see #2 page 25
// Function is SrvSmbEcho()
// SMB_COM_ECHO 0x2B
//

typedef struct _REQ_ECHO {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( EchoCount );               // Number of times to echo data back
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Data to echo
} REQ_ECHO;
typedef REQ_ECHO SMB_UNALIGNED *PREQ_ECHO;

typedef struct _RESP_ECHO {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SequenceNumber );          // Sequence number of this echo
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Echoed data
} RESP_ECHO;
typedef RESP_ECHO SMB_UNALIGNED *PRESP_ECHO;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_SEARCH

//
// Find Close2 SMB, see #3 page 54
// Function is SrvFindClose2()
// SMB_COM_FIND_CLOSE2 0x34
//

typedef struct _REQ_FIND_CLOSE2 {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Sid );                     // Find handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FIND_CLOSE2;
typedef REQ_FIND_CLOSE2 SMB_UNALIGNED *PREQ_FIND_CLOSE2;

typedef struct _RESP_FIND_CLOSE2 {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FIND_CLOSE2;
typedef RESP_FIND_CLOSE2 SMB_UNALIGNED *PRESP_FIND_CLOSE2;

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_SEARCH

//
// Find Notify Close SMB, see #3 page 53
// Function is SrvSmbFindNotifyClose()
// SMB_COM_FIND_NOTIFY_CLOSE 0x35
//

typedef struct _REQ_FIND_NOTIFY_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Handle );                  // Find notify handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FIND_NOTIFY_CLOSE;
typedef REQ_FIND_NOTIFY_CLOSE SMB_UNALIGNED *PREQ_FIND_NOTIFY_CLOSE;

typedef struct _RESP_FIND_NOTIFY_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FIND_NOTIFY_CLOSE;
typedef RESP_FIND_NOTIFY_CLOSE SMB_UNALIGNED *PRESP_FIND_NOTIFY_CLOSE;

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Flush SMB, see #1 page 11
// Function is SrvSmbFlush()
// SMB_COM_FLUSH 0x05
//

typedef struct _REQ_FLUSH {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FLUSH;
typedef REQ_FLUSH SMB_UNALIGNED *PREQ_FLUSH;

typedef struct _RESP_FLUSH {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FLUSH;
typedef RESP_FLUSH SMB_UNALIGNED *PRESP_FLUSH;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_MESSAGE

//
// Forward User Name SMB, see #1 page 34
// Function is SrvSmbForwardUserName()
// SMB_COM_FORWARD_USER_NAME 0xD2
//

typedef struct _REQ_FORWARD_USER_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR ForwardedName[];            //  Forwarded name
} REQ_FORWARD_USER_NAME;
typedef REQ_FORWARD_USER_NAME SMB_UNALIGNED *PREQ_FORWARD_USER_NAME;

typedef struct _RESP_FORWARD_USER_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FORWARD_USER_NAME;
typedef RESP_FORWARD_USER_NAME SMB_UNALIGNED *PRESP_FORWARD_USER_NAME;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Get Machine Name SMB, see #1 page 35
// Function is SrvSmbGetMachineName()
// SMB_COM_GET_MACHINE_NAME 0xD4
//

typedef struct _REQ_GET_MACHINE_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_GET_MACHINE_NAME;
typedef REQ_GET_MACHINE_NAME SMB_UNALIGNED *PREQ_GET_MACHINE_NAME;

typedef struct _RESP_GET_MACHINE_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR MachineName[];              //  Machine name
} RESP_GET_MACHINE_NAME;
typedef RESP_GET_MACHINE_NAME SMB_UNALIGNED *PRESP_GET_MACHINE_NAME;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_PRINT

//
// Get Print Queue SMB, see #1 page 29
// Function is SrvSmbGetPrintQueue()
// SMB_COM_GET_PRINT_QUEUE 0xC3
//

typedef struct _REQ_GET_PRINT_QUEUE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxCount );                // Max number of entries to return
    _USHORT( StartIndex );              // First queue entry to return
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_GET_PRINT_QUEUE;
typedef REQ_GET_PRINT_QUEUE SMB_UNALIGNED *PREQ_GET_PRINT_QUEUE;

typedef struct _RESP_GET_PRINT_QUEUE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( Count );                   // Number of entries returned
    _USHORT( RestartIndex );            // Index of entry after last returned
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Queue elements
} RESP_GET_PRINT_QUEUE;
typedef RESP_GET_PRINT_QUEUE SMB_UNALIGNED *PRESP_GET_PRINT_QUEUE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_TRANSACTION

//
// Ioctl SMB, see #2 page 39
// Function is SrvSmbIoctl()
// SMB_COM_IOCTL 0x27
// SMB_COM_IOCTL_SECONDARY 0x28
//

typedef struct _REQ_IOCTL {
    UCHAR WordCount;                    // Count of parameter words = 14
    _USHORT( Fid );                     // File handle
    _USHORT( Category );                // Device category
    _USHORT( Function );                // Device function
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_IOCTL;
typedef REQ_IOCTL SMB_UNALIGNED *PREQ_IOCTL;

typedef struct _RESP_IOCTL_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_IOCTL_INTERIM;
typedef RESP_IOCTL_INTERIM SMB_UNALIGNED *PRESP_IOCTL_INTERIM;

typedef struct _REQ_IOCTL_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_IOCTL_SECONDARY;
typedef REQ_IOCTL_SECONDARY SMB_UNALIGNED *PREQ_IOCTL_SECONDARY;

typedef struct _RESP_IOCTL {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} RESP_IOCTL;
typedef RESP_IOCTL SMB_UNALIGNED *PRESP_IOCTL;

#endif // def INCLUDE_SMB_TRANSACTION

#ifdef INCLUDE_SMB_LOCK

//
// Lock Byte Range SMB, see #1 page 20
// Function is SrvSmbLockByteRange()
// SMB_COM_LOCK_BYTE_RANGE 0x0C
//

typedef struct _REQ_LOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( Count );                    // Count of bytes to lock
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_LOCK_BYTE_RANGE;
typedef REQ_LOCK_BYTE_RANGE SMB_UNALIGNED *PREQ_LOCK_BYTE_RANGE;

typedef struct _RESP_LOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOCK_BYTE_RANGE;
typedef RESP_LOCK_BYTE_RANGE SMB_UNALIGNED *PRESP_LOCK_BYTE_RANGE;

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_LOCK

//
// Locking and X SMB, see #2 page 46
// Function is SrvLockingAndX()
// SMB_COM_LOCKING_ANDX 0x24
//

typedef struct _REQ_LOCKING_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 8
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle

    //
    // When NT protocol is not negotiated the OplockLevel field is
    // omitted, and LockType field is a full word.  Since the upper
    // bits of LockType are never used, this definition works for
    // all protocols.
    //

    UCHAR( LockType );                  // Locking mode:
                                        //  bit 0: 0 = lock out all access
                                        //         1 = read OK while locked
                                        //  bit 1: 1 = 1 user total file unlock
    UCHAR( OplockLevel );               // The new oplock level
    _ULONG( Timeout );
    _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
    _USHORT( NumberOfLocks );           // Num. lock range structs following
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
    //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
} REQ_LOCKING_ANDX;
typedef REQ_LOCKING_ANDX SMB_UNALIGNED *PREQ_LOCKING_ANDX;

#define LOCKING_ANDX_SHARED_LOCK     0x01
#define LOCKING_ANDX_OPLOCK_RELEASE  0x02
#define LOCKING_ANDX_CHANGE_LOCKTYPE 0x04
#define LOCKING_ANDX_CANCEL_LOCK     0x08
#define LOCKING_ANDX_LARGE_FILES     0x10

#define OPLOCK_BROKEN_TO_NONE        0
#define OPLOCK_BROKEN_TO_II          1

typedef struct _LOCKING_ANDX_RANGE {
    _USHORT( Pid );                     // PID of process "owning" lock
    _ULONG( Offset );                   // Ofset to bytes to [un]lock
    _ULONG( Length );                   // Number of bytes to [un]lock
} LOCKING_ANDX_RANGE;
typedef LOCKING_ANDX_RANGE SMB_UNALIGNED *PLOCKING_ANDX_RANGE;

typedef struct _NT_LOCKING_ANDX_RANGE {
    _USHORT( Pid );                     // PID of process "owning" lock
    _USHORT( Pad );                     // Pad to DWORD align (mbz)
    _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
    _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
    _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
    _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
} NTLOCKING_ANDX_RANGE;
typedef NTLOCKING_ANDX_RANGE SMB_UNALIGNED *PNTLOCKING_ANDX_RANGE;
                                        //
typedef struct _RESP_LOCKING_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOCKING_ANDX;
typedef RESP_LOCKING_ANDX SMB_UNALIGNED *PRESP_LOCKING_ANDX;

#define LOCK_BROKEN_SIZE 51             // # of bytes in lock broken notify

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_ADMIN

//
// Logoff and X SMB, see #3, page 55
// SMB_COM_LOGOFF_ANDX 0x74
//

typedef struct _REQ_LOGOFF_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_LOGOFF_ANDX;
typedef REQ_LOGOFF_ANDX SMB_UNALIGNED *PREQ_LOGOFF_ANDX;

typedef struct _RESP_LOGOFF_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOGOFF_ANDX;
typedef RESP_LOGOFF_ANDX SMB_UNALIGNED *PRESP_LOGOFF_ANDX;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Move SMB, see #2 page 49
// Funcion is SrvSmbMove()
// SMB_COM_MOVE 0x2A
//

typedef struct _REQ_MOVE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Tid2 );                    // Second (target) file id
    _USHORT( OpenFunction );            // what to do if target file exists
    _USHORT( Flags );                   // Flags to control move operations:
                                        //  0 - target must be a file
                                        //  1 - target must be a directory
                                        //  2 - reserved (must be 0)
                                        //  3 - reserved (must be 0)
                                        //  4 - verify all writes
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR NewFileName[];              //  New file name
} REQ_MOVE;
typedef REQ_MOVE SMB_UNALIGNED *PREQ_MOVE;

typedef struct _RESP_MOVE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of files moved
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Pathname of file where error occurred
} RESP_MOVE;
typedef RESP_MOVE SMB_UNALIGNED *PRESP_MOVE;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_ADMIN

//
// Negotiate SMB's for Net 1 and Net 3, see #1 page 25 and #2 page 20
// Function is SrvSmbNegotiate()
// SMB_COM_NEGOTIATE 0x72
//

typedef struct _REQ_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //struct {
    //  UCHAR BufferFormat;             //  0x02 -- Dialect
    //  UCHAR DialectName[];            //  ASCIIZ
    //} Dialects[];
} REQ_NEGOTIATE;
typedef REQ_NEGOTIATE *PREQ_NEGOTIATE;  // *** NOT SMB_UNALIGNED!

typedef struct _RESP_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 13
    _USHORT( DialectIndex );            // Index of selected dialect
    _USHORT( SecurityMode );            // Security mode:
                                        //  bit 0: 0 = share, 1 = user
                                        //  bit 1: 1 = encrypt passwords
                                        //  bit 2: 1 = SMB security signatures enabled
                                        //  bit 3: 1 = SMB security signatures required
    _USHORT( MaxBufferSize );           // Max transmit buffer size
    _USHORT( MaxMpxCount );             // Max pending multiplexed requests
    _USHORT( MaxNumberVcs );            // Max VCs between client and server
    _USHORT( RawMode );                 // Raw modes supported:
                                        //  bit 0: 1 = Read Raw supported
                                        //  bit 1: 1 = Write Raw supported
    _ULONG( SessionKey );
    SMB_TIME ServerTime;                // Current time at server
    SMB_DATE ServerDate;                // Current date at server
    _USHORT( ServerTimeZone );          // Current time zone at server
    _USHORT( EncryptionKeyLength );     // MBZ if this is not LM2.1
    _USHORT( Reserved );                // MBZ
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Password encryption key
    //UCHAR EncryptionKey[];            // The challenge encryption key
    //UCHAR PrimaryDomain[];            // The server's primary domain (2.1 only)
} RESP_NEGOTIATE;
typedef RESP_NEGOTIATE *PRESP_NEGOTIATE;    // *** NOT SMB_UNALIGNED!

// Macros for SecurityMode field, above
#define NEGOTIATE_USER_SECURITY                     0x01
#define NEGOTIATE_ENCRYPT_PASSWORDS                 0x02
#define NEGOTIATE_SECURITY_SIGNATURES_ENABLED       0x04
#define NEGOTIATE_SECURITY_SIGNATURES_REQUIRED      0x08

// Macros for RawMode field, above
#define NEGOTIATE_READ_RAW_SUPPORTED    1
#define NEGOTIATE_WRITE_RAW_SUPPORTED   2

typedef struct _RESP_OLD_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( DialectIndex );            // Index of selected dialect
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OLD_NEGOTIATE;
typedef RESP_OLD_NEGOTIATE *PRESP_OLD_NEGOTIATE;    // *** NOT SMB_UNALIGNED!

typedef struct _RESP_NT_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 17
    _USHORT( DialectIndex );            // Index of selected dialect
    UCHAR( SecurityMode );              // Security mode:
                                        //  bit 0: 0 = share, 1 = user
                                        //  bit 1: 1 = encrypt passwords
                                        //  bit 2: 1 = SMB sequence numbers enabled
                                        //  bit 3: 1 = SMB sequence numbers required
    _USHORT( MaxMpxCount );             // Max pending multiplexed requests
    _USHORT( MaxNumberVcs );            // Max VCs between client and server
    _ULONG( MaxBufferSize );            // Max transmit buffer size
    _ULONG( MaxRawSize );               // Maximum raw buffer size
    _ULONG( SessionKey );
    _ULONG( Capabilities );             // Server capabilities
    _ULONG( SystemTimeLow );            // System (UTC) time of the server (low).
    _ULONG( SystemTimeHigh );           // System (UTC) time of the server (high).
    _USHORT( ServerTimeZone );          // Time zone of server (min from UTC)
    UCHAR( EncryptionKeyLength );       // Length of encryption key.
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Password encryption key
    //for nonExtendedSecurity...
    //UCHAR EncryptionKey[];            // The challenge encryption key
    //UCHAR OemDomainName[];            // The name of the domain (in OEM chars)
    //for ExtendedSecurity...
    //UCHAR GUID[16];                   // The server's GUID
    //UCHAR SecurityBlob[];             // The blob
} RESP_NT_NEGOTIATE;
typedef RESP_NT_NEGOTIATE *PRESP_NT_NEGOTIATE;  // *** NOT SMB_UNALIGNED!

#endif // def INCLUDE_SMB_ADMIN

//
// Server / workstation capabilities
// N.B. Most messages use a ULONG for this, so there are many more
// bits available.
//

#define CAP_RAW_MODE            0x0001
#define CAP_MPX_MODE            0x0002
#define CAP_UNICODE             0x0004
#define CAP_LARGE_FILES         0x0008
#define CAP_NT_SMBS             0x0010
#define CAP_RPC_REMOTE_APIS     0x0020
#define CAP_NT_STATUS           0x0040
#define CAP_LEVEL_II_OPLOCKS    0x0080
#define CAP_LOCK_AND_READ       0x0100
#define CAP_NT_FIND             0x0200
#define CAP_DFS                 0x1000       // This server is DFS aware
#define CAP_INFOLEVEL_PASSTHRU  0x2000       // NT information level requests can pass through
#define CAP_LARGE_READX         0x4000       // Server supports oversized READ&X on files
#define CAP_LARGE_WRITEX        0x8000

#define CAP_RESERVED1           0x00100000   // Reserved for third party SMB server
#define CAP_RESERVED2           0x00200000   // Reserved for third party SMB server
#define CAP_RESERVED3           0x00400000   // Reserved for third party SMB server
#define CAP_UNIX                0x00800000   // This is a Unix SMB server

#define CAP_COMPRESSED_DATA     0x02000000

#define CAP_DYNAMIC_REAUTH      0x20000000

#ifdef INCLUDE_SMB_PERSISTENT
#define CAP_PERSISTENT_HANDLES  0x40000000   // Server supports persistent handles
#endif

#define CAP_EXTENDED_SECURITY   0x80000000   // Server supports extended
                                             // validation.

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open SMB, see #1, page 7
// Function is SrvSmbOpen()
// SMB_COM_OPEN 0x02
//

typedef struct _REQ_OPEN {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( DesiredAccess );           // Mode - read/write/share
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_OPEN;
typedef REQ_OPEN SMB_UNALIGNED *PREQ_OPEN;

typedef struct _RESP_OPEN {
    UCHAR WordCount;                    // Count of parameter words = 7
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // File size
    _USHORT( GrantedAccess );           // Access allowed
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN;
typedef RESP_OPEN SMB_UNALIGNED *PRESP_OPEN;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open and X SMB, see #2 page 51
// Function is SrvOpenAndX()
// SMB_COM_OPEN_ANDX 0x2D
//

typedef struct _REQ_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - return additional info
                                        //  1 - set single user total file lock
                                        //  2 - server notifies consumer of
                                        //      actions which may change file
                                        //  4 - return extended response
    _USHORT( DesiredAccess );           // File open mode
    _USHORT( SearchAttributes );
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( OpenFunction );
    _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
    _ULONG( Timeout );                  // Max milliseconds to wait for resource
    _ULONG( Reserved );                 // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes; min = 1
    UCHAR Buffer[1];                    // File name
} REQ_OPEN_ANDX;
typedef REQ_OPEN_ANDX SMB_UNALIGNED *PREQ_OPEN_ANDX;

typedef struct _RESP_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( Reserved );                // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN_ANDX;
typedef RESP_OPEN_ANDX SMB_UNALIGNED *PRESP_OPEN_ANDX;

typedef struct _RESP_EXTENDED_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( Reserved );                // Reserved (must be 0)
    _ULONG( MaximalAccessRights );      // maximal access rights for user
    _ULONG( GuestMaximalAccessRights ); // maximal access rights for guest
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_EXTENDED_OPEN_ANDX;
typedef RESP_EXTENDED_OPEN_ANDX SMB_UNALIGNED *PRESP_EXTENDED_OPEN_ANDX;

typedef struct _REQ_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 24
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR Reserved;                     // MBZ
    _USHORT( NameLength );              // Length of Name[] in bytes
    _ULONG( Flags );                    // Create flags  NT_CREATE_xxx
    _ULONG( RootDirectoryFid );         // If non-zero, open is relative to this directory
    ACCESS_MASK DesiredAccess;          // NT access desired
    LARGE_INTEGER AllocationSize;       // Initial allocation size
    _ULONG( FileAttributes );           // File attributes for creation
    _ULONG( ShareAccess );              // Type of share access
    _ULONG( CreateDisposition );        // Action to take if file exists or not
    _ULONG( CreateOptions );            // Options to use if creating a file
    _ULONG( ImpersonationLevel );       // Security QOS information
    UCHAR SecurityFlags;                // Security QOS information
    _USHORT( ByteCount );               // Length of byte parameters
    UCHAR Buffer[1];
    //UCHAR Name[];                       // File to open or create
} REQ_NT_CREATE_ANDX;
typedef REQ_NT_CREATE_ANDX SMB_UNALIGNED *PREQ_NT_CREATE_ANDX;

// Flag bit for Security flags

#define SMB_SECURITY_DYNAMIC_TRACKING   0x01
#define SMB_SECURITY_EFFECTIVE_ONLY     0x02

typedef struct _RESP_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 26
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR OplockLevel;                  // The oplock level granted
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    union {
        _USHORT( DeviceState );         // state of IPC device (e.g. pipe)
        _USHORT( FileStatusFlags );     // if a file or directory.  See below.
    };
    BOOLEAN Directory;                  // TRUE if this is a directory
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_NT_CREATE_ANDX;
typedef RESP_NT_CREATE_ANDX SMB_UNALIGNED *PRESP_NT_CREATE_ANDX;

typedef struct _RESP_EXTENDED_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 42
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR OplockLevel;                  // The oplock level granted
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    union {
        _USHORT( DeviceState );         // state of the pipe
        _USHORT( FileStatusFlags );     // if a file or directory.  See below.
    };
    BOOLEAN Directory;                  // TRUE if this is a directory
    UCHAR   VolumeGuid[16];             // the volume GUID
    UCHAR   FileId[8];                  // the file id
    _ULONG ( MaximalAccessRights );        // the access rights for the session owner
    _ULONG ( GuestMaximalAccessRights );   // the maximal access rights for guest
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_EXTENDED_NT_CREATE_ANDX;
typedef RESP_EXTENDED_NT_CREATE_ANDX SMB_UNALIGNED *PRESP_EXTENDED_NT_CREATE_ANDX;

//
//  This request is identical to REQ_NT_CREATE_ANDX up to CreationTime.
//  The SMB command code is the same, Flags has NT_CREATE_IFMODIFIED_REQUEST
//  ORed in.
//

#ifdef INCLUDE_SMB_IFMODIFIED

#define SMB_REQ_EXTENDED_NT_CREATE_ANDX2_WORK_COUNT 48

typedef struct _REQ_NT_CREATE_IF_MODIFIED_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 48
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR Reserved;                     // MBZ
    _USHORT( NameLength );              // Length of Name[] in bytes
    _ULONG( Flags );                    // Create flags  NT_CREATE_xxx
    _ULONG( RootDirectoryFid );         // If non-zero, open is relative to this directory
    ACCESS_MASK DesiredAccess;          // NT access desired
    LARGE_INTEGER AllocationSize;       // Initial allocation size
    _ULONG( FileAttributes );           // File attributes for creation
    _ULONG( ShareAccess );              // Type of share access
    _ULONG( CreateDisposition );        // Action to take if file exists or not
    _ULONG( CreateOptions );            // Options to use if creating a file
    _ULONG( ImpersonationLevel );       // Security QOS information
    UCHAR SecurityFlags;                // Security QOS information

    // the following fields are filled in by the client, if they all match the
    // current file (and attributes also matches), the file is closed
    // automatically and returns with status code of STATUS_FILE_CLOSED.

    TIME CreationTime;                  // The time the file was created
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    LARGE_INTEGER EndOfFile;            // The end of file offset

    LARGE_INTEGER UsnValue;             // The file's USN # in NTFS
    LARGE_INTEGER FileReferenceNumber;  //

    _USHORT( ByteCount );               // Length of byte parameters
    UCHAR Buffer[1];
    //UCHAR Name[];                       // File to open or create
} REQ_NT_CREATE_IF_MODIFIED_ANDX;
typedef REQ_NT_CREATE_IF_MODIFIED_ANDX SMB_UNALIGNED *PREQ_NT_CREATE_IF_MODIFIED_ANDX;

#define SMB_SHORT_NAME_LENGTH 13
#define SMB_RESP_EXTENDED_NT_CREATE_ANDX2_WORK_COUNT 71

typedef struct _RESP_EXTENDED_NT_CREATE_ANDX2 {
    UCHAR WordCount;                    // Count of parameter words = 71
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR OplockLevel;                  // The oplock level granted
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    union {
        _USHORT( DeviceState );         // state of the pipe
        _USHORT( FileStatusFlags );     // if a file or directory.  See below.
    };
    BOOLEAN Directory;                  // TRUE if this is a directory
    UCHAR   VolumeGuid[16];             // the volume GUID
    UCHAR   FileId[8];                  // the file id
    _ULONG ( MaximalAccessRights );        // the access rights for the session owner
    _ULONG ( GuestMaximalAccessRights );   // the maximal access rights for guest

    // below here is where it differs from RESP_EXTENDED_NT_CREATE_ANDX

    LARGE_INTEGER UsnValue;             // The file's USN # in NTFS
    LARGE_INTEGER FileReferenceNumber;  //
    WCHAR ShortName[SMB_SHORT_NAME_LENGTH];  // null terminated. if not present, empty string.

    _USHORT( ByteCount );               // length of long name
    WCHAR Buffer[1];                    // long name goes here in unicode
} RESP_EXTENDED_NT_CREATE_ANDX2;
typedef RESP_EXTENDED_NT_CREATE_ANDX2 SMB_UNALIGNED *PRESP_EXTENDED_NT_CREATE_ANDX2;

#endif  // def INCLUDE_SMB_IFMODIFIED

//
// Values for FileStatusFlags, if the opened resource is a file or directory
//
#define SMB_FSF_NO_EAS          0x0001   // file/dir has no extended attributes
#define SMB_FSF_NO_SUBSTREAMS   0x0002   // file/dir has no substreams
#define SMB_FSF_NO_REPARSETAG   0x0004   // file/dir is not a reparse point


#define SMB_OPLOCK_LEVEL_NONE       0
#define SMB_OPLOCK_LEVEL_EXCLUSIVE  1
#define SMB_OPLOCK_LEVEL_BATCH      2
#define SMB_OPLOCK_LEVEL_II         3

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_PRINT

//
// Open Print File SMB, see #1 page 27
// Function is SrvSmbOpenPrintFile()
// SMB_COM_OPEN_PRINT_FILE 0xC0
//

typedef struct _REQ_OPEN_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( SetupLength );             // Length of printer setup data
    _USHORT( Mode );                    // 0 = Text mode (DOS expands TABs)
                                        // 1 = Graphics mode
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR IdentifierString[];         //  Identifier string
} REQ_OPEN_PRINT_FILE;
typedef REQ_OPEN_PRINT_FILE SMB_UNALIGNED *PREQ_OPEN_PRINT_FILE;

typedef struct _RESP_OPEN_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN_PRINT_FILE;
typedef RESP_OPEN_PRINT_FILE SMB_UNALIGNED *PRESP_OPEN_PRINT_FILE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_ADMIN

//
// Process Exit SMB, see #1 page 22
// Function is SrvSmbProcessExit()
// SMB_COM_PROCESS_EXIT 0x11
//

typedef struct _REQ_PROCESS_EXIT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_PROCESS_EXIT;
typedef REQ_PROCESS_EXIT SMB_UNALIGNED *PREQ_PROCESS_EXIT;

typedef struct _RESP_PROCESS_EXIT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_PROCESS_EXIT;
typedef RESP_PROCESS_EXIT SMB_UNALIGNED *PRESP_PROCESS_EXIT;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_QUERY_SET

//
// Query Information SMB, see #1 page 18
// Function is SrvSmbQueryInformation()
// SMB_COM_QUERY_INFORMATION 0x08
//

typedef struct _REQ_QUERY_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_QUERY_INFORMATION;
typedef REQ_QUERY_INFORMATION SMB_UNALIGNED *PREQ_QUERY_INFORMATION;

typedef struct _RESP_QUERY_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 10
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( FileSize );                 // File size
    _USHORT( Reserved )[5];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_QUERY_INFORMATION;
typedef RESP_QUERY_INFORMATION SMB_UNALIGNED *PRESP_QUERY_INFORMATION;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_QUERY_SET

//
// Query Information2 SMB, see #2 page 37
// Function is SrvSmbQueryInformation2()
// SMB_COM_QUERY_INFORMATION2 0x23
//

typedef struct _REQ_QUERY_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_QUERY_INFORMATION2;
typedef REQ_QUERY_INFORMATION2 SMB_UNALIGNED *PREQ_QUERY_INFORMATION2;

typedef struct _RESP_QUERY_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 11
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( FileDataSize );             // File end of data
    _ULONG( FileAllocationSize );       // File allocation size
    _USHORT( FileAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Reserved buffer
} RESP_QUERY_INFORMATION2;
typedef RESP_QUERY_INFORMATION2 SMB_UNALIGNED *PRESP_QUERY_INFORMATION2;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_MISC

//
// Query Information Disk SMB, see #1 page 24
// Function is SrvSmbQueryInformationDisk()
// SMB_COM_QUERY_INFORMATION_DISK 0x80
//

typedef struct _REQ_QUERY_INFORMATION_DISK {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_QUERY_INFORMATION_DISK;
typedef REQ_QUERY_INFORMATION_DISK SMB_UNALIGNED *PREQ_QUERY_INFORMATION_DISK;

typedef struct _RESP_QUERY_INFORMATION_DISK {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( TotalUnits );              // Total allocation units per server
    _USHORT( BlocksPerUnit );           // Blocks per allocation unit
    _USHORT( BlockSize );               // Block size (in bytes)
    _USHORT( FreeUnits );               // Number of free units
    _USHORT( Reserved );                // Reserved (media identification code)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_QUERY_INFORMATION_DISK;
typedef RESP_QUERY_INFORMATION_DISK SMB_UNALIGNED *PRESP_QUERY_INFORMATION_DISK;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_MISC

//
// Query Server Information SMB, see #? page ??
// Function is SrvSmbQueryInformationServer
// SMB_COM_QUERY_INFORMATION_SRV 0x21
//

typedef struct _REQ_QUERY_INFORMATION_SRV {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Mode );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} REQ_QUERY_INFORMATION_SRV;
typedef REQ_QUERY_INFORMATION_SRV SMB_UNALIGNED *PREQ_QUERY_INFORMATION_SRV;

typedef struct _RESP_QUERY_INFORMATION_SRV {
    UCHAR WordCount;                    // Count of parameter words = 20
    _ULONG( smb_fsid );
    _ULONG( BlocksPerUnit );
    _ULONG( smb_aunits );
    _ULONG( smb_fau );
    _USHORT( BlockSize );
    SMB_DATE smb_vldate;
    SMB_TIME smb_vltime;
    UCHAR smb_vllen;
    UCHAR Reserved;                     // Reserved (must be 0)
    _USHORT( SecurityMode );
    _USHORT( BlockMode );
    _ULONG( Services );
    _USHORT( MaxTransmitSize );
    _USHORT( MaxMpxCount );
    _USHORT( MaxNumberVcs );
    SMB_TIME ServerTime;
    SMB_DATE ServerDate;
    _USHORT( ServerTimeZone );
    _ULONG( Reserved2 );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} RESP_QUERY_INFORMATION_SRV;
typedef RESP_QUERY_INFORMATION_SRV SMB_UNALIGNED *PRESP_QUERY_INFORMATION_SRV;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_READ_WRITE

//
// Read SMB, see #1 page 12
// Lock and Read SMB, see #2 page 44
// SMB_COM_READ 0x0A, Function is SrvSmbRead
// SMB_COM_LOCK_AND_READ 0x13, Function is SrvSmbLockAndRead
//

typedef struct _REQ_READ {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Count of bytes being requested
    _ULONG( Offset );                   // Offset in file of first byte to read
    _USHORT( Remaining );               // Estimate of bytes to read if nonzero
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ;
typedef REQ_READ SMB_UNALIGNED *PREQ_READ;

//
// *** Warning: the following structure is defined the way it is to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _RESP_READ {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Count );                   // Count of bytes actually returned
    _USHORT( Reserved )[4];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes
    //UCHAR Buffer[1];                  // Buffer containing:
      UCHAR BufferFormat;               //  0x01 -- Data block
      _USHORT( DataLength );            //  Length of data
      ULONG Buffer[1];                  //  Data
} RESP_READ;
typedef RESP_READ SMB_UNALIGNED *PRESP_READ;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Read and X SMB, see #2 page 56
// Function is SrvSmbReadAndX()
// SMB_COM_READ_ANDX 0x2E
//

typedef struct _REQ_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 10
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max number of bytes to return
    _USHORT( MinCount );                // Min number of bytes to return
    _ULONG( Timeout );
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_ANDX;
typedef REQ_READ_ANDX SMB_UNALIGNED *PREQ_READ_ANDX;

typedef struct _REQ_NT_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max number of bytes to return
    _USHORT( MinCount );                // Min number of bytes to return
    union {
        _ULONG( Timeout );
        _USHORT( MaxCountHigh );        // upper 16 bits of MaxCount if NT request
    };
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_NT_READ_ANDX;
typedef REQ_NT_READ_ANDX SMB_UNALIGNED *PREQ_NT_READ_ANDX;

typedef struct _RESP_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Remaining );               // Bytes remaining to be read
    _USHORT( DataCompactionMode );
    union {
        _USHORT(CdiLength);             // COMPRESSED_DATA_INFO length
        _USHORT( Reserved );            // Reserved (must be 0)
    };
    _USHORT( DataLength );              // Number of data bytes (min = 0)
    _USHORT( DataOffset );              // Offset (from header start) to data
    union {
        _USHORT( Reserved2 );           // Reserved (must be 0)
        _USHORT( DataLengthHigh );      // upper 16 bits of DataLength if NT request
    };
    _ULONG( Reserved3 )[2];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes.  Inaccurate if we
                                        //   are doing large Read&X's!
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (size = DataLength)
} RESP_READ_ANDX;
typedef RESP_READ_ANDX SMB_UNALIGNED *PRESP_READ_ANDX;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MPX

//
// Read Block Multiplexed SMB, see #2 page 58
// Function is SrvSmbReadMpx()
// SMB_COM_READ_MPX 0x1B
// SMB_COM_READ_MPX_SECONDARY 0x1C
//

typedef struct _REQ_READ_MPX {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_MPX;
typedef REQ_READ_MPX SMB_UNALIGNED *PREQ_READ_MPX;

typedef struct _RESP_READ_MPX {
    UCHAR WordCount;                    // Count of parameter words = 8
    _ULONG( Offset );                   // Offset in file where data read
    _USHORT( Count );                   // Total bytes being returned
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    _USHORT( DataCompactionMode );
    _USHORT( Reserved );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (size = DataLength)
} RESP_READ_MPX;
typedef RESP_READ_MPX SMB_UNALIGNED *PRESP_READ_MPX;

#endif // def INCLUDE_SMB_MPX

#ifdef INCLUDE_SMB_RAW

//
// Read Block Raw SMB, see #2 page 61
// Function is SrvSmbReadRaw()
// SMB_COM_READ_RAW 0x1A
//

typedef struct _REQ_READ_RAW {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_RAW;
typedef REQ_READ_RAW SMB_UNALIGNED *PREQ_READ_RAW;

typedef struct _REQ_NT_READ_RAW {
    UCHAR WordCount;                    // Count of parameter words = 10
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_NT_READ_RAW;
typedef REQ_NT_READ_RAW SMB_UNALIGNED *PREQ_NT_READ_RAW;

// No response params for raw read--the response is the raw data.

#endif // def INCLUDE_SMB_RAW

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Rename SMB, see #1 page 17
// Function is SrvSmbRename()
// SMB_COM_RENAME 0x07
//

typedef struct _REQ_RENAME {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR NewFileName[];              //  New file name
} REQ_RENAME;
typedef REQ_RENAME SMB_UNALIGNED *PREQ_RENAME;


//
// Extended NT rename SMB
// Function is SrvSmbRename()
// SMB_COM_NT_RENAME 0xA5
//

typedef struct _REQ_NTRENAME {
    UCHAR WordCount;                    // Count of parameter words = 4
    _USHORT( SearchAttributes );
    _USHORT( InformationLevel );
    _ULONG( ClusterCount );
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR NewFileName[];              //  New file name
} REQ_NTRENAME;
typedef REQ_NTRENAME SMB_UNALIGNED *PREQ_NTRENAME;

typedef struct _RESP_RENAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_RENAME;
typedef RESP_RENAME SMB_UNALIGNED *PRESP_RENAME;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_SEARCH

//
// Search SMBs.  One structure is common for both the core Search and the
// LAN Manager 1.0 Find First/Next/Close.
//
// Function is SrvSmbSearch()
//
// Search, see #1 page 26
//      SMB_COM_SEARCH 0x81
// FindFirst and FindNext, see #2 page 27
//      SMB_COM_FIND 0x82
// FindUnique, see #2 page 33
//      SMB_COM_FIND_UNIQUE 0x83
// FindClose, see #2 page 31
//      SMB_COM_FIND_CLOSE 0x84
//

typedef struct _REQ_SEARCH {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxCount );                // Number of dir. entries to return
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 5
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name, may be null
    //UCHAR BufferFormat2;              //  0x05 -- Variable block
    //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
    //UCHAR SearchStatus[];             //  Resume key
} REQ_SEARCH;
typedef REQ_SEARCH SMB_UNALIGNED *PREQ_SEARCH;

typedef struct _RESP_SEARCH {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of entries returned
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x05 -- Variable block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Data
} RESP_SEARCH;
typedef RESP_SEARCH SMB_UNALIGNED *PRESP_SEARCH;

//
// These two structures are use to return information in the Search SMBs.
// SMB_DIRECTORY_INFORMATION is used to return information about a file
// that was found.  In addition to the usual information about the file,
// each of these structures contains an SMB_RESUME_KEY, which is used to
// continue or rewind a search.
//
// These structures must be packed, so turn on packing if it isn't
// already on.
//

#ifdef NO_PACKING
#include <packon.h>
#endif // def NO_PACKING

typedef struct _SMB_RESUME_KEY {
    UCHAR Reserved;                     // bit 7 - comsumer use
                                        // bits 5,6 - system use (must preserve)
                                        // bits 0-4 - server use (must preserve)
    UCHAR FileName[11];
    UCHAR Sid;                          // Uniquely identifies Find through Close
    _ULONG( FileIndex );                // Reserved for server use
    UCHAR Consumer[4];                  // Reserved for comsumer use
} SMB_RESUME_KEY;
typedef SMB_RESUME_KEY SMB_UNALIGNED *PSMB_RESUME_KEY;

typedef struct _SMB_DIRECTORY_INFORMATION {
    SMB_RESUME_KEY ResumeKey;
    UCHAR FileAttributes;
    SMB_TIME LastWriteTime;
    SMB_DATE LastWriteDate;
    _ULONG( FileSize );
    UCHAR FileName[13];                 // ASCII, space-filled null terminated
} SMB_DIRECTORY_INFORMATION;
typedef SMB_DIRECTORY_INFORMATION SMB_UNALIGNED *PSMB_DIRECTORY_INFORMATION;

#ifdef NO_PACKING
#include <packoff.h>
#endif // def NO_PACKING

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_READ_WRITE

//
// Seek SMB, see #1 page 14
// Function is SrvSmbSeek
// SMB_COM_SEEK 0x12
//

typedef struct _REQ_SEEK {
    UCHAR WordCount;                    // Count of parameter words = 4
    _USHORT( Fid );                     // File handle
    _USHORT( Mode );                    // Seek mode:
                                        //  0 = from start of file
                                        //  1 = from current position
                                        //  2 = from end of file
    _ULONG( Offset );                   // Relative offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_SEEK;
typedef REQ_SEEK SMB_UNALIGNED *PREQ_SEEK;

typedef struct _RESP_SEEK {
    UCHAR WordCount;                    // Count of parameter words = 2
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEEK;
typedef RESP_SEEK SMB_UNALIGNED *PRESP_SEEK;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Broadcast Message SMB, see #1 page 32
// Function is SrvSmbSendBroadcastMessage()
// SMB_COM_SEND_BROADCAST_MESSAGE 0xD1
//

typedef struct _REQ_SEND_BROADCAST_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 8
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  "*"
    //UCHAR BufferFormat3;              //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_BROADCAST_MESSAGE;
typedef REQ_SEND_BROADCAST_MESSAGE SMB_UNALIGNED *PREQ_SEND_BROADCAST_MESSAGE;

// No response for Send Broadcast Message

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send End of Multi-block Message SMB, see #1 page 33
// Function is SrvSmbSendEndMbMessage()
// SMB_COM_SEND_END_MB_MESSAGE 0xD6
//

typedef struct _REQ_SEND_END_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_SEND_END_MB_MESSAGE;
typedef REQ_SEND_END_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_END_MB_MESSAGE;

typedef struct _RESP_SEND_END_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_END_MB_MESSAGE;
typedef RESP_SEND_END_MB_MESSAGE SMB_UNALIGNED *PRESP_SEND_END_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Single Block Message SMB, see #1 page 31
// Function is SrvSmbSendMessage()
// SMB_COM_SEND_MESSAGE 0xD0
//

typedef struct _REQ_SEND_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 7
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  Destination name (max = 15)
    //UCHAR BufferFormat3;              //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_MESSAGE;
typedef REQ_SEND_MESSAGE SMB_UNALIGNED *PREQ_SEND_MESSAGE;

typedef struct _RESP_SEND_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_MESSAGE;
typedef RESP_SEND_MESSAGE SMB_UNALIGNED *PRESP_SEND_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Start of Multi-block Message SMB, see #1 page 32
// Function is SrvSmbSendStartMbMessage()
// SMB_COM_SEND_START_MB_MESSAGE 0xD5
//

typedef struct _REQ_SEND_START_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  Destination name (max = 15)
} REQ_SEND_START_MB_MESSAGE;
typedef REQ_SEND_START_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_START_MB_MESSAGE;

typedef struct _RESP_SEND_START_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_START_MB_MESSAGE;
typedef RESP_SEND_START_MB_MESSAGE SMB_UNALIGNED *PSEND_START_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Text of Multi-block Message SMB, see #1 page 33
// Function is SrvSmbSendTextMbMessage()
// SMB_COM_SEND_TEXT_MB_MESSAGE 0xD7
//

typedef struct _REQ_SEND_TEXT_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_TEXT_MB_MESSAGE;
typedef REQ_SEND_TEXT_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_TEXT_MB_MESSAGE;

typedef struct _RESP_SEND_TEXT_MB_MESSAGE {
    UCHAR WordCount;                    // Count of aprameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_TEXT_MB_MESSAGE;
typedef RESP_SEND_TEXT_MB_MESSAGE SMB_UNALIGNED *PRESP_SEND_TEXT_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_ADMIN

//
// Session Setup and X SMB, see #2 page 63 and #3 page 10
// Function is SrvSmbSessionSetupAndX()
// SMB_COM_SESSION_SETUP_ANDX 0x73
//

typedef struct _REQ_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 10
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( PasswordLength );          // Account password size
    _ULONG( Reserved );
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR AccountPassword[];          //  Account Password
    //UCHAR AccountName[];              //  Account Name
    //UCHAR PrimaryDomain[];            //  Client's primary domain
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_SESSION_SETUP_ANDX;
typedef REQ_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_SESSION_SETUP_ANDX;

typedef struct _REQ_NT_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 13
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( CaseInsensitivePasswordLength );      // Account password size, ANSI
    _USHORT( CaseSensitivePasswordLength );        // Account password size, Unicode
    _ULONG( Reserved);
    _ULONG( Capabilities );             // Client capabilities
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR CaseInsensitivePassword[];  //  Account Password, ANSI
    //UCHAR CaseSensitivePassword[];    //  Account Password, Unicode
    //UCHAR AccountName[];              //  Account Name
    //UCHAR PrimaryDomain[];            //  Client's primary domain
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_NT_SESSION_SETUP_ANDX;
typedef REQ_NT_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_NT_SESSION_SETUP_ANDX;

//
// Action flags in the response
//
#define SMB_SETUP_GUEST          0x0001          // Session setup as a guest
#define SMB_SETUP_USE_LANMAN_KEY 0x0002          // Use the Lan Manager setup key.

typedef struct _REQ_NT_EXTENDED_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( SecurityBlobLength );        // Account password size, Unicode
    _ULONG( Reserved);
    _ULONG( Capabilities );             // Client capabilities
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR SecurityBlob[];             // opaque security byte array.
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_NT_EXTENDED_SESSION_SETUP_ANDX;
typedef REQ_NT_EXTENDED_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_NT_EXTENDED_SESSION_SETUP_ANDX;

typedef struct _RESP_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 3
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Action );                  // Request mode:
                                        //    bit0 = logged in as GUEST
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR NativeOS[];                 //  Server's native operating system
    //UCHAR NativeLanMan[];             //  Server's native LAN Manager type
    //UCHAR PrimaryDomain[];            //  Server's primary domain
} RESP_SESSION_SETUP_ANDX;
typedef RESP_SESSION_SETUP_ANDX SMB_UNALIGNED *PRESP_SESSION_SETUP_ANDX;

typedef struct _RESP_NT_EXTENDED_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 4
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Action );                  // Request mode:
                                        //    bit0 = logged in as GUEST
    _USHORT( SecurityBlobLength );      // Length of opaque security blob.
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR SecurityBlob[];             // SecurityBlob length message
    //UCHAR NativeOS[];                 //  Server's native operating system
    //UCHAR NativeLanMan[];             //  Server's native LAN Manager type
    //UCHAR PrimaryDomain[];            //  Server's primary domain
} RESP_NT_EXTENDED_SESSION_SETUP_ANDX;
typedef RESP_NT_EXTENDED_SESSION_SETUP_ANDX SMB_UNALIGNED *PRESP_NT_EXTENDED_SESSION_SETUP_ANDX;
#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_QUERY_SET

//
// Set Information SMB, see #1 page 19
// Function is SrvSmbSetInformation()
// SMB_COM_SET_INFORMATION 0x09
//

typedef struct _REQ_SET_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _USHORT( Reserved )[5];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_SET_INFORMATION;
typedef REQ_SET_INFORMATION SMB_UNALIGNED *PREQ_SET_INFORMATION;

typedef struct _RESP_SET_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SET_INFORMATION;
typedef RESP_SET_INFORMATION SMB_UNALIGNED *PRESP_SET_INFORMATION;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_QUERY_SET

//
// Set Information2 SMB, see #2 page 66
// Function is SrvSmbSetInformation2
// SMB_COM_SET_INFORMATION2 0x22
//

typedef struct _REQ_SET_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 7
    _USHORT( Fid );                     // File handle
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Reserved buffer
} REQ_SET_INFORMATION2;
typedef REQ_SET_INFORMATION2 SMB_UNALIGNED *PREQ_SET_INFORMATION2;

typedef struct _RESP_SET_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SET_INFORMATION2;
typedef RESP_SET_INFORMATION2 SMB_UNALIGNED *PRESP_SET_INFORMATION2;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_TRANSACTION

//
// Transaction and Transaction2 SMBs, see #2 page 68 and #3 page 13
// Function is SrvSmbTransaction()
// SMB_COM_TRANSACTION 0x25
// SMB_COM_TRANSACTION_SECONDARY 0x26
// SMB_COM_TRANSACTION2 0x32
// SMB_COM_TRANSACTION2_SECONDARY 0x33
//
// Structures for specific transaction types are defined in smbtrans.h.
//
// *** The Transaction2 secondary request format includes a USHORT Fid
//     field that we ignore.  We can do this because the Fid field
//     occurs at the end of the word parameters part of the request, and
//     because the rest of the request (parameter and data bytes) is
//     pointed by offset fields occurring prior to the Fid field.  (The
//     Fid field was added to speed up dispatching in the OS/2 server,
//     in which different worker processes handle each Fid.  The NT
//     server has only one process.)
//

typedef struct _REQ_TRANSACTION {
    UCHAR WordCount;                    // Count of parameter words; value = (14 + SetupCount)
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - also disconnect TID in Tid
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved2 );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    UCHAR SetupCount;                   // Count of setup words
    UCHAR Reserved3;                    // Reserved (pad above to word)
    UCHAR Buffer[1];                    // Buffer containing:
    //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 //  Count of data bytes
    //UCHAR Name[];                     //  Name of transaction (NULL if Transact2)
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_TRANSACTION;
typedef REQ_TRANSACTION SMB_UNALIGNED *PREQ_TRANSACTION;

#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2
#define SMB_TRANSACTION_RECONNECTING 4
#define SMB_TRANSACTION_DFSFILE 8

typedef struct _RESP_TRANSACTION_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TRANSACTION_INTERIM;
typedef RESP_TRANSACTION_INTERIM SMB_UNALIGNED *PRESP_TRANSACTION_INTERIM;

typedef struct _REQ_TRANSACTION_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_TRANSACTION_SECONDARY;
typedef REQ_TRANSACTION_SECONDARY SMB_UNALIGNED *PREQ_TRANSACTION_SECONDARY;

typedef struct _RESP_TRANSACTION {
    UCHAR WordCount;                    // Count of data bytes; value = 10 + SetupCount
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( Reserved );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    UCHAR SetupCount;                   // Count of setup words
    UCHAR Reserved2;                    // Reserved (pad above to word)
    UCHAR Buffer[1];                    // Buffer containing:
    //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 //  Count of data bytes
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} RESP_TRANSACTION;
typedef RESP_TRANSACTION SMB_UNALIGNED *PRESP_TRANSACTION;

typedef struct _REQ_NT_TRANSACTION {
    UCHAR WordCount;                    // Count of parameter words; value = (19 + SetupCount)
    UCHAR MaxSetupCount;                // Max setup words to return
    _USHORT( Flags );                   // Currently unused
    _ULONG( TotalParameterCount );      // Total parameter bytes being sent
    _ULONG( TotalDataCount );           // Total data bytes being sent
    _ULONG( MaxParameterCount );        // Max parameter bytes to return
    _ULONG( MaxDataCount );             // Max data bytes to return
    _ULONG( ParameterCount );           // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );          // Offset (from header start) to params
    _ULONG( DataCount );                // Data bytes sent this buffer
    _ULONG( DataOffset );               // Offset (from header start) to data
    UCHAR SetupCount;                   // Count of setup words
    _USHORT( Function );                            // The transaction function code
    UCHAR Buffer[1];
    //USHORT Setup[];                   // Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 // Count of data bytes
    //UCHAR Pad1[];                     // Pad to LONG
    //UCHAR Parameters[];               // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                     // Pad to LONG
    //UCHAR Data[];                     // Data bytes (# = DataCount)
} REQ_NT_TRANSACTION;
typedef REQ_NT_TRANSACTION SMB_UNALIGNED *PREQ_NT_TRANSACTION;

#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2

typedef struct _RESP_NT_TRANSACTION_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];
} RESP_NT_TRANSACTION_INTERIM;
typedef RESP_NT_TRANSACTION_INTERIM SMB_UNALIGNED *PRESP_NT_TRANSACTION_INTERIM;

typedef struct _REQ_NT_TRANSACTION_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 18
    UCHAR Reserved1;                    // MBZ
    _USHORT( Reserved2 );               // MBZ
    _ULONG( TotalParameterCount );      // Total parameter bytes being sent
    _ULONG( TotalDataCount );           // Total data bytes being sent
    _ULONG( ParameterCount );           // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );          // Offset (from header start) to params
    _ULONG( ParameterDisplacement );    // Displacement of these param bytes
    _ULONG( DataCount );                // Data bytes sent this buffer
    _ULONG( DataOffset );               // Offset (from header start) to data
    _ULONG( DataDisplacement );         // Displacement of these data bytes
    UCHAR Reserved3;
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];
    //UCHAR Pad1[];                     // Pad to LONG
    //UCHAR Parameters[];               // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                     // Pad to LONG
    //UCHAR Data[];                     // Data bytes (# = DataCount)
} REQ_NT_TRANSACTION_SECONDARY;
typedef REQ_NT_TRANSACTION_SECONDARY SMB_UNALIGNED *PREQ_NT_TRANSACTION_SECONDARY;

typedef struct _RESP_NT_TRANSACTION {
    UCHAR WordCount;                    // Count of data bytes; value = 18 + SetupCount
    UCHAR Reserved1;
    _USHORT( Reserved2 );
    _ULONG( TotalParameterCount );     // Total parameter bytes being sent
    _ULONG( TotalDataCount );          // Total data bytes being sent
    _ULONG( ParameterCount );          // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );         // Offset (from header start) to params
    _ULONG( ParameterDisplacement );   // Displacement of these param bytes
    _ULONG( DataCount );               // Data bytes sent this buffer
    _ULONG( DataOffset );              // Offset (from header start) to data
    _ULONG( DataDisplacement );        // Displacement of these data bytes
    UCHAR SetupCount;                  // Count of setup words
    UCHAR Buffer[1];
    //USHORT Setup[];                  // Setup words (# = SetupWordCount)
    //USHORT ByteCount;                // Count of data bytes
    //UCHAR Pad1[];                    // Pad to LONG
    //UCHAR Parameters[];              // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                    // Pad to SHORT or LONG
    //UCHAR Data[];                    // Data bytes (# = DataCount)
} RESP_NT_TRANSACTION;
typedef RESP_NT_TRANSACTION SMB_UNALIGNED *PRESP_NT_TRANSACTION;

#endif // def INCLUDE_SMB_TRANSACTION

#ifdef INCLUDE_SMB_TREE

//
// Tree Connect SMB, see #1, page 6
// Function is SrvSmbTreeConnect()
// SMB_COM_TREE_CONNECT 0x70
//

typedef struct _REQ_TREE_CONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR Path[];                     //  Server name and share name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR Password[];                 //  Password
    //UCHAR BufferFormat3;              //  0x04 -- ASCII
    //UCHAR Service[];                  //  Service name
} REQ_TREE_CONNECT;
typedef REQ_TREE_CONNECT SMB_UNALIGNED *PREQ_TREE_CONNECT;

typedef struct _RESP_TREE_CONNECT {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxBufferSize );           // Max size message the server handles
    _USHORT( Tid );                     // Tree ID
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TREE_CONNECT;
typedef RESP_TREE_CONNECT SMB_UNALIGNED *PRESP_TREE_CONNECT;

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_TREE

//
// Tree Connect and X SMB, see #2, page 88
// Function is SrvSmbTreeConnectAndX()
// SMB_COM_TREE_CONNECT_ANDX 0x75
//
// TREE_CONNECT_ANDX flags

#define TREE_CONNECT_ANDX_DISCONNECT_TID    (0x1)
// #define TREE_CONNECT_ANDX_W95            (0x2)  -- W95 sets this flag.  Don't know why.
#define TREE_CONNECT_ANDX_EXTENDED_RESPONSE (0x8)

typedef struct _REQ_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 4
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Flags );                   // Additional information
                                        //  bit 0 set = disconnect Tid
                                        //  bit 7 set = extended response
    _USHORT( PasswordLength );          // Length of Password[]
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Password[];                 //  Password
    //UCHAR Path[];                     //  Server name and share name
    //UCHAR Service[];                  //  Service name
} REQ_TREE_CONNECT_ANDX;
typedef REQ_TREE_CONNECT_ANDX SMB_UNALIGNED *PREQ_TREE_CONNECT_ANDX;

typedef struct _RESP_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Service type connected to
} RESP_TREE_CONNECT_ANDX;
typedef RESP_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_TREE_CONNECT_ANDX;

//
// The response for clients that are LAN Manager 2.1 or better.
//

typedef struct _RESP_21_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 3
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( OptionalSupport );         // Optional support bits
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Service[];                  //   Service type connected to
    //UCHAR NativeFileSystem[];         //   Native file system for this tree
} RESP_21_TREE_CONNECT_ANDX;
typedef RESP_21_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_21_TREE_CONNECT_ANDX;

typedef struct _RESP_EXTENDED_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 7
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( OptionalSupport);          // optional support bits
    _ULONG( MaximalShareAccessRights ); // maximal share access rights
    _ULONG( GuestMaximalShareAccessRights); // maximal guest access rights
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Service type connected to
} RESP_EXTENDED_TREE_CONNECT_ANDX;
typedef RESP_EXTENDED_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_EXTENDED_TREE_CONNECT_ANDX;

//
// Optional Support bit definitions
//
#define SMB_SUPPORT_SEARCH_BITS         0x0001
#define SMB_SHARE_IS_IN_DFS             0x0002
#define SMB_UNIQUE_FILE_NAME            0x0010
#define SMB_CSC_MASK                    0x000C      // see below

//
// Bits under SMB_CSC_MASK decode like this:
//
#define SMB_CSC_CACHE_MANUAL_REINT          0x0000      // No automatic file by file reint
#define SMB_CSC_CACHE_AUTO_REINT            0x0004      // File by file reint is OK
#define SMB_CSC_CACHE_VDO                   0x0008      // no need to flow opens
#define SMB_CSC_NO_CACHING                  0x000C      // client should not cache this share

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_TREE

//
// Tree Disconnect SMB, see #1 page 7
// Function is SrvSmbTreeDisconnect()
// SMB_COM_TREE_DISCONNECT 0x71
//

typedef struct _REQ_TREE_DISCONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_TREE_DISCONNECT;
typedef REQ_TREE_DISCONNECT SMB_UNALIGNED *PREQ_TREE_DISCONNECT;

typedef struct _RESP_TREE_DISCONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TREE_DISCONNECT;
typedef RESP_TREE_DISCONNECT SMB_UNALIGNED *PRESP_TREE_DISCONNECT;

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_LOCK

//
// Unlock Byte Range SMB, see #1 page 20
// Function is SrvSmbUnlockByteRange()
// SMB_COM_UNLOCK_BYTE_RANGE 0x0D
//

typedef struct _REQ_UNLOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( Count );                    // Count of bytes to unlock
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_UNLOCK_BYTE_RANGE;
typedef REQ_UNLOCK_BYTE_RANGE SMB_UNALIGNED *PREQ_UNLOCK_BYTE_RANGE;

typedef struct _RESP_UNLOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_UNLOCK_BYTE_RANGE;
typedef RESP_UNLOCK_BYTE_RANGE SMB_UNALIGNED *PRESP_UNLOCK_BYTE_RANGE;

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write SMB, see #1 page 12
// Write and Unlock SMB, see #2 page 92
// Function is SrvSmbWrite()
// SMB_COM_WRITE 0x0B
// SMB_COM_WRITE_AND_UNLOCK 0x14
//

//
// *** Warning: the following structure is defined the way it is to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _REQ_WRITE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to be written
    _ULONG( Offset );                   // Offset in file to begin write
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( ByteCount );               // Count of data bytes
    //UCHAR Buffer[1];                  // Buffer containing:
      UCHAR BufferFormat;               //  0x01 -- Data block
      _USHORT( DataLength );            //  Length of data
      ULONG Buffer[1];                  //  Data
} REQ_WRITE;
typedef REQ_WRITE SMB_UNALIGNED *PREQ_WRITE;

typedef struct _RESP_WRITE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Count of bytes actually written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE;
typedef RESP_WRITE SMB_UNALIGNED *PRESP_WRITE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write and Close SMB, see #2 page 90
// Function is SrvSmbWriteAndClose()
// SMB_COM_WRITE_AND_CLOSE 0x2C
//

//
// The Write and Close parameters can be 6 words long or 12 words long,
// depending on whether it's supposed to look like a Write SMB or a
// Write and X SMB.  So we define two different structures here.
//
// *** Warning: the following structures are defined the way they are to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _REQ_WRITE_AND_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 6
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to write
    _ULONG( Offset );                   // Offset in file of first byte to write
    _ULONG( LastWriteTimeInSeconds );   // Time of last write
    _USHORT( ByteCount );               // 1 (for pad) + value of Count
    UCHAR Pad;                          // To force to doubleword boundary
    ULONG Buffer[1];                    // Data
} REQ_WRITE_AND_CLOSE;
typedef REQ_WRITE_AND_CLOSE SMB_UNALIGNED *PREQ_WRITE_AND_CLOSE;

typedef struct _REQ_WRITE_AND_CLOSE_LONG {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to write
    _ULONG( Offset );                   // Offset in file of first byte to write
    _ULONG( LastWriteTimeInSeconds );   // Time of last write
    _ULONG( Reserved )[3];              // Reserved, must be 0
    _USHORT( ByteCount );               // 1 (for pad) + value of Count
    UCHAR Pad;                          // To force to doubleword boundary
    ULONG Buffer[1];                    // Data
} REQ_WRITE_AND_CLOSE_LONG;
typedef REQ_WRITE_AND_CLOSE_LONG SMB_UNALIGNED *PREQ_WRITE_AND_CLOSE_LONG;

typedef struct _RESP_WRITE_AND_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Count of bytes actually written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_AND_CLOSE;
typedef RESP_WRITE_AND_CLOSE SMB_UNALIGNED *PRESP_WRITE_AND_CLOSE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write and X SMB, see #2 page 94
// Function is SrvSmbWriteAndX()
// SMB_COM_WRITE_ANDX 0x2F
//

typedef struct _REQ_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  0 - write through
                                        //  1 - return Remaining
                                        //  2 - use WriteRawNamedPipe (n. pipes)
                                        //  3 - "this is the start of the msg"
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( Reserved );
    _USHORT( DataLength );              // Number of data bytes in buffer (>=0)
    _USHORT( DataOffset );              // Offset to data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_ANDX;
typedef REQ_WRITE_ANDX SMB_UNALIGNED *PREQ_WRITE_ANDX;

typedef struct _REQ_NT_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 14
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  0 - write through
                                        //  1 - return Remaining
                                        //  2 - use WriteRawNamedPipe (n. pipes)
                                        //  3 - "this is the start of the msg"
    union {
        _USHORT( Remaining );           // Bytes remaining to satisfy request
        _USHORT( CdiLength );           // if SMB_FLAGS2_COMPRESSED
    };
    _USHORT( DataLengthHigh );
    _USHORT( DataLength );              // Number of data bytes in buffer (>=0)
    _USHORT( DataOffset );              // Offset to data bytes
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_NT_WRITE_ANDX;
typedef REQ_NT_WRITE_ANDX SMB_UNALIGNED *PREQ_NT_WRITE_ANDX;

typedef struct _RESP_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 6
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Count );                   // Number of bytes written
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    union {
        _ULONG( Reserved );
        _USHORT( CountHigh );           // if large write&x
    };
    _USHORT( ByteCount );               // Count of data bytes. Inaccurate if
                                        //    large writes
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_ANDX;
typedef RESP_WRITE_ANDX SMB_UNALIGNED *PRESP_WRITE_ANDX;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MPX

//
// Write Block Multiplexed SMB, see #2 page 97
// Function is SrvSmbWriteMpx()
// SMB_COM_WRITE_MPX 0x1E
// SMB_COM_WRITE_MPX_SECONDARY 0x1F
// SMB_COM_WRITE_MPX_COMPLETE 0x20
//

typedef struct _REQ_WRITE_MPX {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  bit 7 - IPX datagram mode
    union {
        struct {
            _USHORT( DataCompactionMode );
            _USHORT( Reserved2 );
        } ;
        _ULONG( Mask );                 // IPX datagram mode mask
    } ;
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_MPX;
typedef REQ_WRITE_MPX SMB_UNALIGNED *PREQ_WRITE_MPX;

typedef struct _RESP_WRITE_MPX_INTERIM {    // First response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Remaining );               // Bytes ramaining to be read (pipe/dev)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_MPX_INTERIM;
typedef RESP_WRITE_MPX_INTERIM SMB_UNALIGNED *PRESP_WRITE_MPX_INTERIM;

typedef struct _RESP_WRITE_MPX_DATAGRAM {    // Response to sequenced request
    UCHAR WordCount;                    // Count of parameter words = 2
    _ULONG( Mask );                     // OR of all masks received
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_MPX_DATAGRAM;
typedef RESP_WRITE_MPX_DATAGRAM SMB_UNALIGNED *PRESP_WRITE_MPX_DATAGRAM;

// Secondary request format, 0 to N of these.

typedef struct _REQ_WRITE_MPX_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words  = 8
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes to be sent
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Reserved );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_MPX_SECONDARY;
typedef REQ_WRITE_MPX_SECONDARY SMB_UNALIGNED *PREQ_WRITE_MPX_SECONDARY;

#endif // def INCLUDE_SMB_MPX

#ifndef INCLUDE_SMB_WRITE_COMPLETE
#ifdef INCLUDE_SMB_MPX
#define INCLUDE_SMB_WRITE_COMPLETE
#else
#ifdef INCLUDE_SMB_RAW
#define INCLUDE_SMB_WRITE_COMPLETE
#endif
#endif
#endif

#ifdef INCLUDE_SMB_WRITE_COMPLETE

//
// The following structure is used as the final response to both Write
// Block Multiplexed and Write Block Raw.
//

typedef struct _RESP_WRITE_COMPLETE {   // Final response; command is
                                        //  SMB_COM_WRITE_COMPLETE
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Total number of bytes written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_COMPLETE;
typedef RESP_WRITE_COMPLETE SMB_UNALIGNED *PRESP_WRITE_COMPLETE;

#endif // def INCLUDE_SMB_WRITE_COMPLETE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write Print File SMB, see #1 page 29
// Function is SrvSmbWritePrintFile()
// SMB_COM_WRITE_PRINT_FILE 0xC1
//

typedef struct _REQ_WRITE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Data
} REQ_WRITE_PRINT_FILE;
typedef REQ_WRITE_PRINT_FILE SMB_UNALIGNED *PREQ_WRITE_PRINT_FILE;

typedef struct _RESP_WRITE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_PRINT_FILE;
typedef RESP_WRITE_PRINT_FILE SMB_UNALIGNED *PRESP_WRITE_PRINT_FILE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_RAW

//
// Write Block Raw SMB, see #2 page 100
// Function is SrvSmbWriteRaw()
// SMB_COM_WRITE_RAW 0x1D
//

typedef struct _REQ_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  (see WriteAndX for #defines)
    _ULONG( Reserved2 );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_RAW;
typedef REQ_WRITE_RAW SMB_UNALIGNED *PREQ_WRITE_RAW;

typedef struct _REQ_NT_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words = 14
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  (see WriteAndX for #defines)
    _ULONG( Reserved2 );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_NT_WRITE_RAW;
typedef REQ_NT_WRITE_RAW SMB_UNALIGNED *PREQ_NT_WRITE_RAW;

typedef struct _RESP_WRITE_RAW_INTERIM {    // First response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_RAW_INTERIM;
typedef RESP_WRITE_RAW_INTERIM SMB_UNALIGNED *PRESP_WRITE_RAW_INTERIM;

typedef struct _RESP_WRITE_RAW_SECONDARY {  // Second (final) response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Total number of bytes written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_RAW_SECONDARY;
typedef RESP_WRITE_RAW_SECONDARY SMB_UNALIGNED *PRESP_WRITE_RAW_SECONDARY;

typedef struct _REQ_103_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( Fid );                     // File handle
    _USHORT( Count );
    _USHORT( Reserved );
    _ULONG( Offset );
    _ULONG( Timeout );
    _USHORT( WriteMode );
    _ULONG( Reserved2 );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} REQ_103_WRITE_RAW;
typedef REQ_103_WRITE_RAW SMB_UNALIGNED *PREQ_103_WRITE_RAW;

typedef struct _RESP_103_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} RESP_103_WRITE_RAW;
typedef RESP_103_WRITE_RAW SMB_UNALIGNED *PRESP_103_WRITE_RAW;

#endif // def INCLUDE_SMB_RAW

typedef struct _REQ_NT_CANCEL {
    UCHAR WordCount;                    // = 0
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} REQ_NT_CANCEL;
typedef REQ_NT_CANCEL SMB_UNALIGNED *PREQ_NT_CANCEL;

typedef struct _RESP_NT_CANCEL {
    UCHAR WordCount;                    // = 0
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_NT_CANCEL;
typedef RESP_NT_CANCEL SMB_UNALIGNED *PRESP_NT_CANCEL;

//
// File open modes
//

#define SMB_ACCESS_READ_ONLY 0
#define SMB_ACCESS_WRITE_ONLY 1
#define SMB_ACCESS_READ_WRITE 2
#define SMB_ACCESS_EXECUTE 3

//
// Open flags
//

#define SMB_OPEN_QUERY_INFORMATION  0x01
#define SMB_OPEN_OPLOCK             0x02
#define SMB_OPEN_OPBATCH            0x04
#define SMB_OPEN_QUERY_EA_LENGTH    0x08
#define SMB_OPEN_EXTENDED_RESPONSE  0x10

//
// NT open manifests
//

#define NT_CREATE_REQUEST_OPLOCK    0x02
#define NT_CREATE_REQUEST_OPBATCH   0x04
#define NT_CREATE_OPEN_TARGET_DIR   0x08
#define NT_CREATE_REQUEST_EXTENDED_RESPONSE 0x10

// these options are post NT 5

#ifdef INCLUDE_SMB_IFMODIFIED
#define NT_CREATE_IFMODIFIED_REQUEST 0x20
#define NT_CREATE_REQUEST_EXTENDED_RESPONSE2 0x80
#endif

#ifdef INCLUDE_SMB_PERSISTENT
#define NT_CREATE_PERSISTANT_HANDLE  0x100
#endif

#define Added              0
#define Removed            1
#define Modified           2
#define RenamedOldName     3
#define RenamedNewName     4

//
// Lockrange for use with OS/2 DosFileLocks call
//

// *** Where is this used?

//typedef struct lockrange {
//    ULONG offset;
//    ULONG range;
//    };

//#define LOCK 0x1
//#define UNLOCK 0x2

//
// Data buffer format codes, from the core protocol.
//

#define SMB_FORMAT_DATA         1
#define SMB_FORMAT_DIALECT      2
#define SMB_FORMAT_PATHNAME     3
#define SMB_FORMAT_ASCII        4
#define SMB_FORMAT_VARIABLE     5

//
// WriteMode flags
//

#define SMB_WMODE_WRITE_THROUGH        0x0001   // complete write before responding
#define SMB_WMODE_SET_REMAINING        0x0002   // returning amt remaining in pipe
#define SMB_WMODE_WRITE_RAW_NAMED_PIPE 0x0004   // write named pipe in raw mode
#define SMB_WMODE_START_OF_MESSAGE     0x0008   // start of pipe message
#define SMB_WMODE_DATAGRAM             0x0080   // start of pipe message

//
// Various SMB flags:
//

//
// If the server supports LockAndRead and WriteAndUnlock, it sets this
// bit the Negotiate response.
//

#define SMB_FLAGS_LOCK_AND_READ_OK 0x01

//
// When on, the consumer guarantees that there is a receive buffer posted
// such that a "Send.No.Ack" can be used by the server to respond to
// the consumer's request.
//

#define SMB_FLAGS_SEND_NO_ACK 0x2

//
// This is part of the Flags field of every SMB header.  If this bit
// is set, then all pathnames in the SMB should be treated as case-
// insensitive.
//

#define SMB_FLAGS_CASE_INSENSITIVE 0x8

//
// When on in session setup, this bit indicates that all paths sent to
// the server are already in OS/2 canonicalized format.
//

#define SMB_FLAGS_CANONICALIZED_PATHS 0x10

//
// When on in a open file request SMBs (open, create, openX, etc.) this
// bit indicates a request for an oplock on the file.  When on in the
// response, this bit indicates that the oplock was granted.
//

#define SMB_FLAGS_OPLOCK 0x20

//
// When on, this bit indicates that the server should notify the client
// on any request that could cause the file to be changed.  If not set,
// the server only notifies the client on other open requests on the
// file.
//

#define SMB_FLAGS_OPLOCK_NOTIFY_ANY 0x40

//
// This bit indicates that the SMB is being sent from server to redir.
//

#define SMB_FLAGS_SERVER_TO_REDIR 0x80

//
// Valid bits for Flags on an incoming SMB
//

#define INCOMING_SMB_FLAGS      \
            (SMB_FLAGS_LOCK_AND_READ_OK    | \
             SMB_FLAGS_SEND_NO_ACK         | \
             SMB_FLAGS_CASE_INSENSITIVE    | \
             SMB_FLAGS_CANONICALIZED_PATHS | \
             SMB_FLAGS_OPLOCK_NOTIFY_ANY   | \
             SMB_FLAGS_OPLOCK)

//
// Names for bits in Flags2 field of SMB header that indicate what the
// client app is aware of.
//

#define SMB_FLAGS2_KNOWS_LONG_NAMES       0x0001
#define SMB_FLAGS2_KNOWS_EAS              0x0002
#define SMB_FLAGS2_SMB_SECURITY_SIGNATURE 0x0004
#define SMB_FLAGS2_COMPRESSED             0x0008
// Unused                                 0x0010
// Unused                                 0x0020
#define SMB_FLAGS2_IS_LONG_NAME           0x0040
// Unused                                 0x0080
// Unused                                 0x0100
// Unused                                 0x0200
#define SMB_FLAGS2_REPARSE_PATH           0x0400
#define SMB_FLAGS2_EXTENDED_SECURITY      0x0800
#define SMB_FLAGS2_DFS                    0x1000
#define SMB_FLAGS2_PAGING_IO              0x2000
#define SMB_FLAGS2_NT_STATUS              0x4000
#define SMB_FLAGS2_UNICODE                0x8000

//
// Valid bits for Flags2 on an incoming SMB
//

#define INCOMING_SMB_FLAGS2     \
            (SMB_FLAGS2_KNOWS_LONG_NAMES | \
             SMB_FLAGS2_KNOWS_EAS        | \
             SMB_FLAGS2_SMB_SECURITY_SIGNATURE     | \
             SMB_FLAGS2_EXTENDED_SECURITY| \
             SMB_FLAGS2_DFS              | \
             SMB_FLAGS2_PAGING_IO        | \
             SMB_FLAGS2_IS_LONG_NAME     | \
             SMB_FLAGS2_NT_STATUS        | \
             SMB_FLAGS2_COMPRESSED       | \
             SMB_FLAGS2_UNICODE          | \
             SMB_FLAGS2_REPARSE_PATH)

//
// The SMB open function determines what action should be taken depending
// on the existence or lack thereof of files used in the operation.  It
// has the following mapping:
//
//    1111 1
//    5432 1098 7654 3210
//    rrrr rrrr rrrC rrOO
//
// where:
//
//    O - Open (action to be taken if the target file exists)
//        0 - Fail
//        1 - Open or Append file
//        2 - Truncate file
//
//    C - Create (action to be taken if the target file does not exist)
//        0 - Fail
//        1 - Create file
//

#define SMB_OFUN_OPEN_MASK 0x3
#define SMB_OFUN_CREATE_MASK 0x10

#define SMB_OFUN_OPEN_FAIL 0
#define SMB_OFUN_OPEN_APPEND 1
#define SMB_OFUN_OPEN_OPEN 1
#define SMB_OFUN_OPEN_TRUNCATE 2

#define SMB_OFUN_CREATE_FAIL 0x00
#define SMB_OFUN_CREATE_CREATE 0x10

//++
//
// BOOLEAN
// SmbOfunCreate(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunCreate(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_CREATE_MASK) == SMB_OFUN_CREATE_CREATE)

//++
//
// BOOLEAN
// SmbOfunAppend(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunAppend(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_APPEND)

//++
//
// BOOLEAN
// SmbOfunTruncate(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunTruncate(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_TRUNCATE)

//
// The desired access mode passed in Open and Open and X has the following
// mapping:
//
//    1111 11
//    5432 1098 7654 3210
//    rWrC rLLL rSSS rAAA
//
// where:
//
//    W - Write through mode.  No read ahead or write behind allowed on
//        this file or device.  When protocol is returned, data is expected
//        to be on the disk or device.
//
//    S - Sharing mode:
//        0 - Compatibility mode (as in core open)
//        1 - Deny read/write/execute (exclusive)
//        2 - Deny write
//        3 - Deny read/execute
//        4 - Deny none
//
//    A - Access mode
//        0 - Open for reading
//        1 - Open for writing
//        2 - Open for reading and writing
//        3 - Open for execute
//
//    rSSSrAAA = 11111111 (hex FF) indicates FCB open (as in core protocol)
//
//    C - Cache mode
//        0 - Normal file
//        1 - Do not cache this file
//
//    L - Locality of reference
//        0 - Locality of reference is unknown
//        1 - Mainly sequential access
//        2 - Mainly random access
//        3 - Random access with some locality
//        4 to 7 - Currently undefined
//


#define SMB_DA_SHARE_MASK           0x70
#define SMB_DA_ACCESS_MASK          0x07
#define SMB_DA_FCB_MASK             (UCHAR)0xFF

#define SMB_DA_ACCESS_READ          0x00
#define SMB_DA_ACCESS_WRITE         0x01
#define SMB_DA_ACCESS_READ_WRITE    0x02
#define SMB_DA_ACCESS_EXECUTE       0x03

#define SMB_DA_SHARE_COMPATIBILITY  0x00
#define SMB_DA_SHARE_EXCLUSIVE      0x10
#define SMB_DA_SHARE_DENY_WRITE     0x20
#define SMB_DA_SHARE_DENY_READ      0x30
#define SMB_DA_SHARE_DENY_NONE      0x40

#define SMB_DA_FCB                  (UCHAR)0xFF

#define SMB_CACHE_NORMAL            0x0000
#define SMB_DO_NOT_CACHE            0x1000

#define SMB_LR_UNKNOWN              0x0000
#define SMB_LR_SEQUENTIAL           0x0100
#define SMB_LR_RANDOM               0x0200
#define SMB_LR_RANDOM_WITH_LOCALITY 0x0300
#define SMB_LR_MASK                 0x0F00

#define SMB_DA_WRITE_THROUGH        0x4000

//
// The Action field of OpenAndX has the following format:
//
//    1111 11
//    5432 1098 7654 3210
//    Lrrr rrrr rrrr rrOO
//
// where:
//
//    L - Opportunistic lock.  1 if lock granted, else 0.
//
//    O - Open action:
//        1 - The file existed and was opened
//        2 - The file did not exist but was created
//        3 - The file existed and was truncated
//

#define SMB_OACT_OPENED     0x01
#define SMB_OACT_CREATED    0x02
#define SMB_OACT_TRUNCATED  0x03

#define SMB_OACT_OPLOCK     0x8000

//
// These flags are passed in the Flags field of the copy and extended rename
// SMBs.
//

//
// If set, the target must be a file or directory.
//

#define SMB_TARGET_IS_FILE         0x1
#define SMB_TARGET_IS_DIRECTORY    0x2

//
// The copy mode--if set, ASCII copying should be done, otherwise binary.
//

#define SMB_COPY_TARGET_ASCII       0x4
#define SMB_COPY_SOURCE_ASCII       0x8

#define SMB_COPY_TREE               0x20

//
// If set, verify all writes.
//

#define SMB_VERIFY_WRITES

//
// Define file attribute bits as used in the SMB protocol.  The specific
// bit positions are, for the most part, identical to those used in NT.
// However, NT does not define Volume and Directory bits.  It also has
// an explicit Normal bit; this bit is implied in SMB attributes by
// Hidden, System, and Directory being off.
//

#define SMB_FILE_ATTRIBUTE_READONLY     0x01
#define SMB_FILE_ATTRIBUTE_HIDDEN       0x02
#define SMB_FILE_ATTRIBUTE_SYSTEM       0x04
#define SMB_FILE_ATTRIBUTE_VOLUME       0x08
#define SMB_FILE_ATTRIBUTE_DIRECTORY    0x10
#define SMB_FILE_ATTRIBUTE_ARCHIVE      0x20

//
// Share type strings are passed in SMBs to indicate what type of shared
// resource is being or has been connected to.
//

#define SHARE_TYPE_NAME_DISK "A:"
#define SHARE_TYPE_NAME_PIPE "IPC"
#define SHARE_TYPE_NAME_COMM "COMM"
#define SHARE_TYPE_NAME_PRINT "LPT1:"
#define SHARE_TYPE_NAME_WILD "?????"

//
// SMB Error codes:
//

//
// Success Class:
//

#define SMB_ERR_SUCCESS (UCHAR)0x00

//
// DOS Error Class:
//

#define SMB_ERR_CLASS_DOS (UCHAR)0x01

#define SMB_ERR_BAD_FUNCTION        1   // Invalid function
#define SMB_ERR_BAD_FILE            2   // File not found
#define SMB_ERR_BAD_PATH            3   // Invalid directory
#define SMB_ERR_NO_FIDS             4   // Too many open files
#define SMB_ERR_ACCESS_DENIED       5   // Access not allowed for req. func.
#define SMB_ERR_BAD_FID             6   // Invalid file handle
#define SMB_ERR_BAD_MCB             7   // Memory control blocks destroyed
#define SMB_ERR_INSUFFICIENT_MEMORY 8   // For the desired function
#define SMB_ERR_BAD_MEMORY          9   // Invalid memory block address
#define SMB_ERR_BAD_ENVIRONMENT     10  // Invalid environment
#define SMB_ERR_BAD_FORMAT          11  // Invalid format
#define SMB_ERR_BAD_ACCESS          12  // Invalid open mode
#define SMB_ERR_BAD_DATA            13  // Invalid data (only from IOCTL)
#define SMB_ERR_RESERVED            14
#define SMB_ERR_BAD_DRIVE           15  // Invalid drive specified
#define SMB_ERR_CURRENT_DIRECTORY   16  // Attempted to remove currect directory
#define SMB_ERR_DIFFERENT_DEVICE    17  // Not the same device
#define SMB_ERR_NO_FILES            18  // File search can't find more files
#define SMB_ERR_BAD_SHARE           32  // An open conflicts with FIDs on file
#define SMB_ERR_LOCK                33  // Conflict with existing lock
#define SMB_ERR_FILE_EXISTS         80  // Tried to overwrite existing file
#define SMB_ERR_BAD_PIPE            230 // Invalie pipe
#define SMB_ERR_PIPE_BUSY           231 // All instances of the pipe are busy
#define SMB_ERR_PIPE_CLOSING        232 // Pipe close in progress
#define SMB_ERR_PIPE_NOT_CONNECTED  233 // No process on other end of pipe
#define SMB_ERR_MORE_DATA           234 // There is more data to return

//
// SERVER Error Class:
//

#define SMB_ERR_CLASS_SERVER (UCHAR)0x02

#define SMB_ERR_ERROR               1   // Non-specific error code
#define SMB_ERR_BAD_PASSWORD        2   // Bad name/password pair
#define SMB_ERR_BAD_TYPE            3   // Reserved
#define SMB_ERR_ACCESS              4   // Requester lacks necessary access
#define SMB_ERR_BAD_TID             5   // Invalid TID
#define SMB_ERR_BAD_NET_NAME        6   // Invalid network name in tree connect
#define SMB_ERR_BAD_DEVICE          7   // Invalid device request
#define SMB_ERR_QUEUE_FULL          49  // Print queue full--returned print file
#define SMB_ERR_QUEUE_TOO_BIG       50  // Print queue full--no space
#define SMB_ERR_QUEUE_EOF           51  // EOF on print queue dump
#define SMB_ERR_BAD_PRINT_FID       52  // Invalid print file FID
#define SMB_ERR_BAD_SMB_COMMAND     64  // SMB command not recognized
#define SMB_ERR_SERVER_ERROR        65  // Internal server error
#define SMB_ERR_FILE_SPECS          67  // FID and pathname were incompatible
#define SMB_ERR_RESERVED2           68
#define SMB_ERR_BAD_PERMITS         69  // Access permissions invalid
#define SMB_ERR_RESERVED3           70
#define SMB_ERR_BAD_ATTRIBUTE_MODE  71  // Invalid attribute mode specified
#define SMB_ERR_SERVER_PAUSED       81  // Server is paused
#define SMB_ERR_MESSAGE_OFF         82  // Server not receiving messages
#define SMB_ERR_NO_ROOM             83  // No room for buffer message
#define SMB_ERR_TOO_MANY_NAMES      87  // Too many remote user names
#define SMB_ERR_TIMEOUT             88  // Operation was timed out
#define SMB_ERR_NO_RESOURCE         89  // No resources available for request
#define SMB_ERR_TOO_MANY_UIDS       90  // Too many UIDs active in session
#define SMB_ERR_BAD_UID             91  // UID not known as a valid UID
#define SMB_ERR_INVALID_NAME        123 // Invalid name returned from FAT.
#define SMB_ERR_INVALID_NAME_RANGE  206 // Non 8.3 name passed to FAT (or non 255 name to HPFS)
#define SMB_ERR_USE_MPX             250 // Can't support Raw; use MPX
#define SMB_ERR_USE_STANDARD        251 // Can't support Raw, use standard r/w
#define SMB_ERR_CONTINUE_MPX        252 // Reserved
#define SMB_ERR_RESERVED4           253
#define SMB_ERR_RESERVED5           254
#define SMB_ERR_NO_SUPPORT_INTERNAL 255 // Internal code for NO_SUPPORT--
                                        // allows codes to be stored in a byte
#define SMB_ERR_NO_SUPPORT          (USHORT)0xFFFF  // Function not supported

//
// HARDWARE Error Class:
//

#define SMB_ERR_CLASS_HARDWARE (UCHAR)0x03

#define SMB_ERR_NO_WRITE            19  // Write attempted to write-prot. disk
#define SMB_ERR_BAD_UNIT            20  // Unknown unit
#define SMB_ERR_DRIVE_NOT_READY     21  // Disk drive not ready
#define SMB_ERR_BAD_COMMAND         22  // Unknown command
#define SMB_ERR_DATA                23  // Data error (CRC)
#define SMB_ERR_BAD_REQUEST         24  // Bad request structure length
#define SMB_ERR_SEEK                25  // Seek error
#define SMB_ERR_BAD_MEDIA           26  // Unknown media type
#define SMB_ERR_BAD_SECTOR          27  // Sector not found
#define SMB_ERR_NO_PAPER            28  // Printer out of paper
#define SMB_ERR_WRITE_FAULT         29  // Write fault
#define SMB_ERR_READ_FAULT          30  // Read fault
#define SMB_ERR_GENERAL             31  // General failure
#define SMB_ERR_LOCK_CONFLICT       33  // Lock conflicts with existing lock
#define SMB_ERR_WRONG_DISK          34  // Wrong disk was found in a drive
#define SMB_ERR_FCB_UNAVAILABLE     35  // No FCBs available to process request
#define SMB_ERR_SHARE_BUFFER_EXCEEDED 36
#define SMB_ERR_DISK_FULL           39  // !!! Undocumented, but in LM2.0

//
// Other Error Classes:
//

#define SMB_ERR_CLASS_XOS        (UCHAR)0x04    // Reserved for XENIX
#define SMB_ERR_CLASS_RMX1       (UCHAR)0xE1    // Reserved for iRMX
#define SMB_ERR_CLASS_RMX2       (UCHAR)0xE2    // Reserved for iRMX
#define SMB_ERR_CLASS_RMX3       (UCHAR)0xE3    // Reserved for iRMX
#define SMB_ERR_CLASS_COMMAND    (UCHAR)0xFF    // Command was not in the SMB format


//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING


#endif // _SMB_

//   Old (LanMan 1.2) and new (NT) field names:
//   (Undocumented fields have corresponding structure in parenthesis)
// smb_access            Access
// smb_action            Action
// smb_adate             AccessDate
// smb_allocsize         AllocationSize
// smb_aname             AccountName
// smb_apasslen          PasswordSize
// smb_apasswd           AccountPassword
// smb_atime             AccessTime
// smb_attr              Attribute
// smb_attribute         Attribute
// smb_aunits            (RESP_QUERY_INFORMATION_SERVER)
// smb_bcc               BufferSize
// smb_blkmode           BlockMode
// smb_blksize           BlockSize
// smb_blksperunit       BlocksPerUnit
// smb_bpu               BlocksPerUnit
// smb_bs                BlockSize
// smb_bufsize           MaxBufferSize
// smb_buf[1]            Buffer[1]
// smb_bytes[*]          Bytes[*]
// smb_cat               Category
// smb_cct               FilesCopied
// smb_cdate             CreateDate
// smb_cert              CertificateOffset
// smb_com               Command
// smb_com2              AndXCommand
// smb_count             Count
// smb_count_left        Remaining
// smb_cryptkey[*]       CryptKey
// smb_ctime             CreateTime
// smb_datablock         DataBlock
// smb_datalen           DataSize
// smb_datasize          DataSize
// smb_data[*]           Data[*]
// smb_dcmode            DataCompactMode
// smb_dev               DeviceName
// smb_doff              DataOffset
// smb_drcnt             DataCount
// smb_drdisp            DataDisplacement
// smb_droff             DataOffset
// smb_dscnt             DataCount
// smb_dsdisp            DataDisplacement
// smb_dsize             DataSize
// smb_dsoff             DataOffset
// smb_encrypt           EncryptKey
// smb_encryptlen        EncryptKeySize
// smb_encryptoff        EncryptKeyOffset
// smb_eos               EndOfSearch
// smb_err               Error
// smb_errmsg[1]         ErrorMessage[1]
// smb_fau               (RESP_QUERY_INFORMATION_SERVER)
// smb_fid               Fid
// smb_fileid            ServerFid
// smb_flag              Flag
// smb_flag2             Flag2
// smb_flags             Flag
// smb_flg               Flag
// smb_freeunits         FreeUnits
// smb_fsid              (RESP_QUERY_INFORMATION_SERVER)
// smb_fsize             FileSize
// smb_fun               Function
// smb_gid               Gid
// smb_handle            Handle
// smb_ident1            Identifier
// smb_idf[4]            Protocol[4]
// smb_index             Index
// smb_info              Info
// smb_left              Remaining
// smb_len               SetupLength
// smb_locknum           NumberOfLocks
// smb_lockrng[*]        LockRange
// smb_locktype          LockType
// smb_lpid              OwnerPid
// smb_maxbytes          MaxBytes
// smb_maxcnt            MaxCount
// smb_maxcount          MaxCount
// smb_maxmux            (RESP_NEGOTIATE)
// smb_maxvcs            MaxNumberVcs
// smb_maxxmitsz         MaxTransmitSize
// smb_maxxmt            MaxTransmitSize
// smb_mdate             ModificationDate
// smb_mdrcnt            MaxDataCount
// smb_mid               Mid
// smb_mincnt            MinCount
// smb_mode              Mode
// smb_mprcnt            MaxParameterCount
// smb_mpxmax            MaxMpxCount
// smb_msrcnt            MaxSetupCount
// smb_mtime             ModificationTime
// smb_name[*]           Name[*]
// smb_off2              AndXOffset
// smb_offset            Offset
// smb_ofun              OpenFunction
// smb_pad               Pad
// smb_pad1[]            Pad1
// smb_pad[]             Pad[]
// smb_param[*]          Parameter[*]
// smb_path              ServerName
// smb_pathname          PathName
// smb_pid               Pid
// smb_prcnt             ParameterCount
// smb_prdisp            ParameterDisplacement
// smb_proff             ParameterCount
// smb_pscnt             ParameterCount
// smb_psdisp            ParameterDisplacement
// smb_psoff             ParameterOffset
// smb_range             LockLength or UnlockLength
// smb_rcls              ErrorClass
// smb_reh               ReservedH
// smb_reh2              ReservedH2
// smb_remaining         Remaining
// smb_remcnt            Remaining
// smb_res1              Reserved
// smb_res2              Reserved2
// smb_res3              Reserved3
// smb_res4              Reserved4
// smb_res5              Reserved5
// smb_reserved          Reserved
// smb_restart           Restart
// smb_resumekey         ResumeKey
// smb_res[5]            Reserved[]
// smb_reverb            ReverbCount
// smb_rsvd              Reserved
// smb_rsvd1             Reserved
// smb_rsvd2             Reserved2
// smb_rsvd3             Reserved3
// smb_rsvd4             Reserved4
// smb_sattr             SearchAttribute
// smb_secmode           SecurityMode
// smb_seq               SequenceNumber
// smb_services          Services
// smb_sesskey           SessionKey
// smb_setup[*]          Setup[*]
// smb_size              Size
// smb_spasslen          ServerPasswordSize
// smb_spasswd           ServerPassword
// smb_srv_date          ServerDate
// smb_srv_time          ServerTime
// smb_srv_tzone         ServerTimeZone
// smb_start             StartIndex
// smb_state             DeviceState
// smb_suwcnt            SetupWordCount
// smb_su_class          SetupClass
// smb_su_com            SetupCommand
// smb_su_handle         SetupFid
// smb_su_opcode         SetupOpcode
// smb_su_priority       SetupPriority
// smb_tcount            Count
// smb_tdis              TreeDisconnect
// smb_tdrcnt            TotalDataCount
// smb_tdscnt            TotalDataCount
// smb_tid               Tid
// smb_tid2              Tid2
// smb_time              Time
// smb_timeout           Timeout
// smb_totalunits        TotalUnits
// smb_tprcnt            TotalParameterCount
// smb_tpscnt            TotalParameterCount
// smb_type              FileType
// smb_uid               Uid
// smb_unlkrng[*]        UnlockRange
// smb_unlocknum         NumberOfUnlocks
// smb_vblen             DataLength
// smb_vcnum             VcNumber
// smb_vldate            (RESP_QUERY_INFORMATION_SERVER)
// smb_vllen             (RESP_QUERY_INFORMATION_SERVER)
// smb_vltime            (RESP_QUERY_INFORMATION_SERVER)
// smb_vwv[1]            Param
// smb_wct               WordCount
// smb_wmode             WriteMode
// smb_xchain            EncryptChainOffset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sfcapip.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sfc.h

Abstract:

    Header file for public SFC interfaces.

Author:

    Wesley Witt (wesw) 2-Feb-1999

Revision History:

--*/


#ifndef _SFC_
#define _SFC_

#ifdef __cplusplus
extern "C" {

#endif
#define SFC_DISABLE_NORMAL          0
#define SFC_DISABLE_ASK             1
#define SFC_DISABLE_ONCE            2
#define SFC_DISABLE_SETUP           3
#define SFC_DISABLE_NOPOPUPS        4

#define SFC_SCAN_NORMAL             0
#define SFC_SCAN_ALWAYS             1
#define SFC_SCAN_ONCE               2
#define SFC_SCAN_IMMEDIATE          3

#define SFC_QUOTA_DEFAULT           50
#define SFC_QUOTA_ALL_FILES         ((ULONG)-1)

#define SFC_IDLE_TRIGGER       L"WFP_IDLE_TRIGGER"

typedef struct _PROTECTED_FILE_DATA {
    WCHAR   FileName[MAX_PATH];
    DWORD   FileNumber;
} PROTECTED_FILE_DATA, *PPROTECTED_FILE_DATA;


BOOL
WINAPI
SfcGetNextProtectedFile(
    IN HANDLE RpcHandle, // must be NULL
    IN PPROTECTED_FILE_DATA ProtFileData
    );

BOOL
WINAPI
SfcIsFileProtected(
    IN HANDLE RpcHandle, // must be NULL
    IN LPCWSTR ProtFileName
    );

//
// new APIs which are not currently supported, but are stubbed out
//
BOOL
WINAPI
SfpVerifyFile(
    IN LPCTSTR pszFileName,
    IN LPTSTR  pszError,
    IN DWORD   dwErrSize
    );    

#define SFC_REGISTRY_DEFAULT        0
#define SFC_REGISTRY_OVERRIDE       1

HANDLE
WINAPI
SfcConnectToServer(
    IN LPCWSTR ServerName
    );

VOID
SfcClose(
    IN HANDLE RpcHandle
    );


#define SFC_ACTION_ADDED                   0x00000001
#define SFC_ACTION_REMOVED                 0x00000002
#define SFC_ACTION_MODIFIED                0x00000004
#define SFC_ACTION_RENAMED_OLD_NAME        0x00000008
#define SFC_ACTION_RENAMED_NEW_NAME        0x00000010


DWORD
WINAPI
SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    );

DWORD
WINAPI
SfcInitiateScan(
    IN HANDLE RpcHandle,
    IN DWORD ScanWhen
    );

ULONG
SfcInitProt(
    IN ULONG OverrideRegistry,
    IN ULONG ReqDisable,
    IN ULONG ReqScan,
    IN ULONG ReqQuota,
    IN HWND ProgressWindow, OPTIONAL
    IN PCWSTR SourcePath,   OPTIONAL
    IN PCWSTR IgnoreFiles   OPTIONAL
    );

VOID
SfcTerminateWatcherThread(
    VOID
    );

#define WM_SFC_NOTIFY (WM_USER+601)

typedef struct _FILEINSTALL_STATUS {
    PCWSTR              FileName;
    DWORDLONG           Version;
    ULONG               Win32Error;
} FILEINSTALL_STATUS, *PFILEINSTALL_STATUS;

typedef BOOL
(CALLBACK *PSFCNOTIFICATIONCALLBACK) (
    IN PFILEINSTALL_STATUS FileInstallStatus,
    IN DWORD_PTR Context
    );

BOOL
WINAPI
SfcInstallProtectedFiles(
    IN HANDLE RpcHandle,
    IN PCWSTR FileNames,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName,
    IN PSFCNOTIFICATIONCALLBACK SfcNotificationCallback,
    IN DWORD_PTR Context
    );
    
//
// new APIs which are not currently supported, but are stubbed out
//

DWORD
WINAPI
SfpInstallCatalog(
    IN LPCTSTR pszCatName, 
    IN LPCTSTR pszCatDependency,
    IN PVOID Reserved
    );


DWORD
WINAPI
SfpDeleteCatalog(
    IN LPCTSTR pszCatName,
    IN PVOID Reserved
    );


#ifdef __cplusplus
}
#endif

#endif // _SFC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbgtpt.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbgtpt.h

Abstract:

    This module defines macros for retrieving and storing SMB data.
    The macros account for the misaligned nature of the SMB protocol.
    They also translate from the little-endian SMB format into
    big-endian format, when necessary.

Author:

    Chuck Lenzmeier (chuckl) 2-Mar-90
    David Treadwell (davditr)

Revision History:

    15-Apr-1991 JohnRo
        Include <smbtypes.h>, to define SMBDBG etc.
--*/

#ifndef _SMBGTPT_
#define _SMBGTPT_

#include <smbtypes.h>
//#include <smb.h>

//
// The following macros store and retrieve USHORTS and ULONGS from
// potentially unaligned addresses, avoiding alignment faults.  They
// would best be written as inline assembly code.
//
// The macros are designed to be used for accessing SMB fields.  Such
// fields are always stored in little-endian byte order, so these macros
// do byte swapping when compiled for a big-endian machine.
//
// !!! Not yet.
//

#if !SMBDBG

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

#endif

//++
//
// USHORT
// SmbGetUshort (
//     IN PSMB_USHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a USHORT value from the possibly misaligned
//     source address, avoiding alignment faults.
//
// Arguments:
//
//     SrcAddress - where to retrieve USHORT value from
//
// Return Value:
//
//     USHORT - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbGetUshort(SrcAddress) *(PSMB_USHORT)(SrcAddress)
#else
#define SmbGetUshort(SrcAddress) (USHORT)(          \
            ( ( (PUCHAR)(SrcAddress) )[0]       ) | \
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 )   \
            )
#endif
#else
#define SmbGetUshort(SrcAddress) (USHORT)(                  \
            ( ( (PUCHAR)(SrcAddress ## S) )[0]       ) |    \
            ( ( (PUCHAR)(SrcAddress ## S) )[1] <<  8 )      \
            )
#endif

#else

USHORT
SmbGetUshort (
    IN PSMB_USHORT SrcAddress
    );

#endif

//++
//
// USHORT
// SmbGetAlignedUshort (
//     IN PUSHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a USHORT value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     SrcAddress - where to retrieve USHORT value from; must be aligned.
//
// Return Value:
//
//     USHORT - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbGetAlignedUshort(SrcAddress) *(SrcAddress)
#else
#define SmbGetAlignedUshort(SrcAddress) *(SrcAddress ## S)
#endif

#else

USHORT
SmbGetAlignedUshort (
    IN PUSHORT SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutUshort (
//     OUT PSMB_USHORT DestAddress,
//     IN USHORT Value
//     )
//
// Routine Description:
//
//     This macro stores a USHORT value at the possibly misaligned
//     destination address, avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store USHORT value.  Address may be
//         misaligned.
//
//     Value - USHORT to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbPutUshort(SrcAddress, Value) \
                            *(PSMB_USHORT)(SrcAddress) = (Value)
#else
#define SmbPutUshort(DestAddress,Value) {                   \
            ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);   \
            ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);   \
        }
#endif
#else
#define SmbPutUshort(DestAddress,Value) {                       \
            ( (PUCHAR)(DestAddress ## S) )[0] = BYTE_0(Value);  \
            ( (PUCHAR)(DestAddress ## S) )[1] = BYTE_1(Value);  \
        }
#endif

#else

VOID
SmbPutUshort (
    OUT PSMB_USHORT DestAddress,
    IN USHORT Value
    );

#endif

//++
//
// VOID
// SmbPutAlignedUshort (
//     OUT PUSHORT DestAddres,
//     IN USHORT Value
//     )
//
// Routine Description:
//
//     This macro stores a USHORT value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     DestAddress - where to store USHORT value.  Address may not be
//         misaligned.
//
//     Value - USHORT to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbPutAlignedUshort(DestAddress,Value) *(DestAddress) = (Value)
#else
#define SmbPutAlignedUshort(DestAddress,Value) *(DestAddress ## S) = (Value)
#endif

#else

VOID
SmbPutAlignedUshort (
    OUT PUSHORT DestAddress,
    IN USHORT Value
    );

#endif

//++
//
// VOID
// SmbMoveUshort (
//     OUT PSMB_USHORT DestAddress
//     IN PSMB_USHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro moves a USHORT value from the possibly misaligned
//     source address to the possibly misaligned destination address,
//     avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store USHORT value
//
//     SrcAddress - where to retrieve USHORT value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbMoveUshort(DestAddress, SrcAddress) \
        *(PSMB_USHORT)(DestAddress) = *(PSMB_USHORT)(SrcAddress)
#else
#define SmbMoveUshort(DestAddress,SrcAddress) {                         \
            ( (PUCHAR)(DestAddress) )[0] = ( (PUCHAR)(SrcAddress) )[0]; \
            ( (PUCHAR)(DestAddress) )[1] = ( (PUCHAR)(SrcAddress) )[1]; \
        }
#endif
#else
#define SmbMoveUshort(DestAddress,SrcAddress) {                                     \
            ( (PUCHAR)(DestAddress ## S) )[0] = ( (PUCHAR)(SrcAddress ## S) )[0];   \
            ( (PUCHAR)(DestAddress ## S) )[1] = ( (PUCHAR)(SrcAddress ## S) )[1];   \
        }
#endif

#else

VOID
SmbMoveUshort (
    OUT PSMB_USHORT DestAddress,
    IN PSMB_USHORT SrcAddress
    );

#endif

//++
//
// ULONG
// SmbGetUlong (
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the possibly misaligned
//     source address, avoiding alignment faults.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbGetUlong(SrcAddress) *(PSMB_ULONG)(SrcAddress)
#else
#define SmbGetUlong(SrcAddress) (ULONG)(                \
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |     \
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 ) |     \
            ( ( (PUCHAR)(SrcAddress) )[2] << 16 ) |     \
            ( ( (PUCHAR)(SrcAddress) )[3] << 24 )       \
            )
#endif
#else
#define SmbGetUlong(SrcAddress) (ULONG)(                    \
            ( ( (PUCHAR)(SrcAddress ## L) )[0]       ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[1] <<  8 ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[2] << 16 ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[3] << 24 )      \
            )
#endif

#else

ULONG
SmbGetUlong (
    IN PSMB_ULONG SrcAddress
    );

#endif

//++
//
// USHORT
// SmbGetAlignedUlong (
//     IN PULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from; must be aligned.
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbGetAlignedUlong(SrcAddress) *(SrcAddress)
#else
#define SmbGetAlignedUlong(SrcAddress) *(SrcAddress ## L)
#endif

#else

ULONG
SmbGetAlignedUlong (
    IN PULONG SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutUlong (
//     OUT PSMB_ULONG DestAddress,
//     IN ULONG Value
//     )
//
// Routine Description:
//
//     This macro stores a ULONG value at the possibly misaligned
//     destination address, avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbPutUlong(SrcAddress, Value) *(PSMB_ULONG)(SrcAddress) = Value
#else
#define SmbPutUlong(DestAddress,Value) {                    \
            ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);   \
            ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);   \
            ( (PUCHAR)(DestAddress) )[2] = BYTE_2(Value);   \
            ( (PUCHAR)(DestAddress) )[3] = BYTE_3(Value);   \
        }
#endif
#else
#define SmbPutUlong(DestAddress,Value) {                        \
            ( (PUCHAR)(DestAddress ## L) )[0] = BYTE_0(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[1] = BYTE_1(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[2] = BYTE_2(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[3] = BYTE_3(Value);  \
        }
#endif

#else

VOID
SmbPutUlong (
    OUT PSMB_ULONG DestAddress,
    IN ULONG Value
    );

#endif

//++
//
// VOID
// SmbPutAlignedUlong (
//     OUT PULONG DestAddres,
//     IN ULONG Value
//     )
//
// Routine Description:
//
//     This macro stores a ULONG value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     DestAddress - where to store ULONG value.  Address may not be
//         misaligned.
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbPutAlignedUlong(DestAddress,Value) *(DestAddress) = (Value)
#else
#define SmbPutAlignedUlong(DestAddress,Value) *(DestAddress ## L) = (Value)
#endif

#else

VOID
SmbPutAlignedUlong (
    OUT PULONG DestAddress,
    IN ULONG Value
    );

#endif

//++
//
// VOID
// SmbMoveUlong (
//     OUT PSMB_ULONG DestAddress,
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro moves a ULONG value from the possibly misaligned
//     source address to the possible misaligned destination address,
//     avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbMoveUlong(DestAddress,SrcAddress) \
        *(PSMB_ULONG)(DestAddress) = *(PSMB_ULONG)(SrcAddress)
#else
#define SmbMoveUlong(DestAddress,SrcAddress) {                          \
            ( (PUCHAR)(DestAddress) )[0] = ( (PUCHAR)(SrcAddress) )[0]; \
            ( (PUCHAR)(DestAddress) )[1] = ( (PUCHAR)(SrcAddress) )[1]; \
            ( (PUCHAR)(DestAddress) )[2] = ( (PUCHAR)(SrcAddress) )[2]; \
            ( (PUCHAR)(DestAddress) )[3] = ( (PUCHAR)(SrcAddress) )[3]; \
        }
#endif
#else
#define SmbMoveUlong(DestAddress,SrcAddress) {                                      \
            ( (PUCHAR)(DestAddress ## L) )[0] = ( (PUCHAR)(SrcAddress ## L) )[0];   \
            ( (PUCHAR)(DestAddress ## L) )[1] = ( (PUCHAR)(SrcAddress ## L) )[1];   \
            ( (PUCHAR)(DestAddress ## L) )[2] = ( (PUCHAR)(SrcAddress ## L) )[2];   \
            ( (PUCHAR)(DestAddress ## L) )[3] = ( (PUCHAR)(SrcAddress ## L) )[3];   \
        }
#endif

#else

VOID
SmbMoveUlong (
    OUT PSMB_ULONG DestAddress,
    IN PSMB_ULONG SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutDate (
//     OUT PSMB_DATE DestAddress,
//     IN SMB_DATE Value
//     )
//
// Routine Description:
//
//     This macro stores an SMB_DATE value at the possibly misaligned
//     destination address, avoiding alignment faults.  This macro
//     is different from SmbPutUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
// Arguments:
//
//     DestAddress - where to store SMB_DATE value
//
//     Value - SMB_DATE to store.  Value must be a constant or an
//         aligned field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbPutDate(DestAddress,Value) (DestAddress)->Ushort = (Value).Ushort
#else
#define SmbPutDate(DestAddress,Value) {                                     \
            ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0((Value).Ushort); \
            ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1((Value).Ushort); \
        }
#endif

#else

VOID
SmbPutDate (
    OUT PSMB_DATE DestAddress,
    IN SMB_DATE Value
    );

#endif

//++
//
// VOID
// SmbMoveDate (
//     OUT PSMB_DATE DestAddress,
//     IN PSMB_DATE SrcAddress
//     )
//
// Routine Description:
//
//     This macro copies an SMB_DATE value from the possibly misaligned
//     source address, avoiding alignment faults.  This macro is
//     different from SmbGetUshort in order to be able to handle funny
//     bitfield / big-endian interactions.
//
//     Note that there is no SmbGetDate because of the way SMB_DATE is
//     defined.  It is a union containing a USHORT and a bitfield
//     struct.  The caller of an SmbGetDate macro would have to
//     explicitly use one part of the union.
//
// Arguments:
//
//     DestAddress - where to store SMB_DATE value.  MUST BE ALIGNED!
//
//     SrcAddress - where to retrieve SMB_DATE value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbMoveDate(DestAddress,SrcAddress)     \
            (DestAddress)->Ushort = (SrcAddress)->Ushort
#else
#define SmbMoveDate(DestAddress,SrcAddress)                         \
            (DestAddress)->Ushort =                                 \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |    \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 )
#endif

#else

VOID
SmbMoveDate (
    OUT PSMB_DATE DestAddress,
    IN PSMB_DATE SrcAddress
    );

#endif

//++
//
// VOID
// SmbZeroDate (
//     IN PSMB_DATE Date
//     )
//
// Routine Description:
//
//     This macro zeroes a possibly misaligned SMB_DATE field.
//
// Arguments:
//
//     Date - Pointer to SMB_DATE field to zero.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbZeroDate(Date) (Date)->Ushort = 0
#else
#define SmbZeroDate(Date) {                     \
            ( (PUCHAR)&(Date)->Ushort )[0] = 0; \
            ( (PUCHAR)&(Date)->Ushort )[1] = 0; \
        }
#endif

#else

VOID
SmbZeroDate (
    IN PSMB_DATE Date
    );

#endif

//++
//
// BOOLEAN
// SmbIsDateZero (
//     IN PSMB_DATE Date
//     )
//
// Routine Description:
//
//     This macro returns TRUE if the supplied SMB_DATE value is zero.
//
// Arguments:
//
//     Date - Pointer to SMB_DATE value to check.  MUST BE ALIGNED!
//
// Return Value:
//
//     BOOLEAN - TRUE if Date is zero, else FALSE.
//
//--

#if !SMBDBG

#define SmbIsDateZero(Date) ( (Date)->Ushort == 0 )

#else

BOOLEAN
SmbIsDateZero (
    IN PSMB_DATE Date
    );

#endif

//++
//
// VOID
// SmbPutTime (
//     OUT PSMB_TIME DestAddress,
//     IN SMB_TIME Value
//     )
//
// Routine Description:
//
//     This macro stores an SMB_TIME value at the possibly misaligned
//     destination address, avoiding alignment faults.  This macro
//     is different from SmbPutUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
// Arguments:
//
//     DestAddress - where to store SMB_TIME value
//
//     Value - SMB_TIME to store.  Value must be a constant or an
//         aligned field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbPutTime(DestAddress,Value) (DestAddress)->Ushort = (Value).Ushort
#else
#define SmbPutTime(DestAddress,Value) {                                     \
            ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0((Value).Ushort); \
            ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1((Value).Ushort); \
        }
#endif

#else

VOID
SmbPutTime (
    OUT PSMB_TIME DestAddress,
    IN SMB_TIME Value
    );

#endif

//++
//
// VOID
// SmbMoveTime (
//     OUT PSMB_TIME DestAddress,
//     IN PSMB_TIME SrcAddress
//     )
//
// Routine Description:
//
//     This macro copies an SMB_TIME value from the possibly
//     misaligned source address, avoiding alignment faults.  This macro
//     is different from SmbGetUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
//     Note that there is no SmbGetTime because of the way SMB_TIME is
//     defined.  It is a union containing a USHORT and a bitfield
//     struct.  The caller of an SmbGetTime macro would have to
//     explicitly use one part of the union.
//
// Arguments:
//
//     DestAddress - where to store SMB_TIME value.  MUST BE ALIGNED!
//
//     SrcAddress - where to retrieve SMB_TIME value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbMoveTime(DestAddress,SrcAddress) \
                (DestAddress)->Ushort = (SrcAddress)->Ushort
#else
#define SmbMoveTime(DestAddress,SrcAddress)                         \
            (DestAddress)->Ushort =                                 \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |    \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 )
#endif

#else

VOID
SmbMoveTime (
    OUT PSMB_TIME DestAddress,
    IN PSMB_TIME SrcAddress
    );

#endif

//++
//
// VOID
// SmbZeroTime (
//     IN PSMB_TIME Time
//     )
//
// Routine Description:
//
//     This macro zeroes a possibly misaligned SMB_TIME field.
//
// Arguments:
//
//     Time - Pointer to SMB_TIME field to zero.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbZeroTime(Time) (Time)->Ushort = 0
#else
#define SmbZeroTime(Time) {                     \
            ( (PUCHAR)&(Time)->Ushort )[0] = 0; \
            ( (PUCHAR)&(Time)->Ushort )[1] = 0; \
        }
#endif

#else

VOID
SmbZeroTime (
    IN PSMB_TIME Time
    );

#endif

//++
//
// BOOLEAN
// SmbIsTimeZero (
//     IN PSMB_TIME Time
//     )
//
// Routine Description:
//
//     This macro returns TRUE if the supplied SMB_TIME value is zero.
//
// Arguments:
//
//     Time - Pointer to SMB_TIME value to check.  Must be aligned and
//         in native format!
//
// Return Value:
//
//     BOOLEAN - TRUE if Time is zero, else FALSE.
//
//--

#if !SMBDBG

#define SmbIsTimeZero(Time) ( (Time)->Ushort == 0 )

#else

BOOLEAN
SmbIsTimeZero (
    IN PSMB_TIME Time
    );

#endif

#endif // def _SMBGTPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbmacro.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbmacro.h

Abstract:

    This module defines macros related to SMB processing.

Author:

    Chuck Lenzmeier (chuckl)   1-Dec-1989
    David Treadwell (davidtr)

Revision History:

--*/

#ifndef _SMBMACRO_
#define _SMBMACRO_

//#include <nt.h>


//
// PVOID
// ALIGN_SMB_WSTR(
//     IN PVOID Pointer
//     )
//
// Routine description:
//
//     This macro aligns the input pointer to the next 2-byte boundary.
//     Used to align Unicode strings in SMBs.
//
// Arguments:
//
//     Pointer - A pointer
//
// Return Value:
//
//     PVOID - Pointer aligned to next 2-byte boundary.
//

#define ALIGN_SMB_WSTR( Pointer ) \
        (PVOID)( ((ULONG_PTR)Pointer + 1) & ~1 )

//
// Macro to find the size of an SMB parameter block.  This macro takes
// as input the type of a parameter block and a byte count.  It finds
// the offset of the Buffer field, which appears at the end of all
// parameter blocks, and adds the byte count to find the total size.
// The type of the returned offset is USHORT.
//
// Note that this macro does NOT pad to a word or longword boundary.
//

#define SIZEOF_SMB_PARAMS(type,byteCount)   \
            (USHORT)( (ULONG_PTR)&((type *)0)->Buffer[0] + (byteCount) )

//
// Macro to find the next location after an SMB parameter block.  This
// macro takes as input the address of the current parameter block, its
// type, and a byte count.  It finds the address of the Buffer field,
// which appears at the end of all parameter blocks, and adds the byte
// count to find the next available location.  The type of the returned
// pointer is PVOID.
//
// The byte count is passed in even though it is available through
// base->ByteCount.  The reason for this is that this number will be a
// compile-time constant in most cases, so the resulting code will be
// simpler and faster.
//
// !!! This macro does not round to a longword boundary when packing
//     is turned off.  Pre-LM 2.0 DOS redirectors cannot handle having
//     too much data sent to them; the exact amount must be sent.
//     We may want to make this macro such that the first location
//     AFTER the returned value (WordCount field of the SMB) is aligned,
//     since most of the fields are misaligned USHORTs.  This would
//     result in a minor performance win on the 386 and other CISC
//     machines.
//

#ifndef NO_PACKING

#define NEXT_LOCATION(base,type,byteCount)  \
        (PVOID)( (ULONG_PTR)( (PUCHAR)( &((type *)(base))->Buffer[0] ) ) + \
        (byteCount) )

#else

#define NEXT_LOCATION(base,type,byteCount)  \
        (PVOID)(( (ULONG_PTR)( (PUCHAR)( &((type *)(base))->Buffer[0] ) ) + \
        (byteCount) + 3) & ~3)

#endif

//
// Macro to find the offset of a followon command to an and X command.
// This offset is the number of bytes from the start of the SMB header
// to where the followon command's parameters should start.
//

#define GET_ANDX_OFFSET(header,params,type,byteCount) \
        (USHORT)( (PCHAR)(params) - (PCHAR)(header) + \
          SIZEOF_SMB_PARAMS( type,(byteCount) ) )

//
// The following are macros to assist in converting OS/2 1.2 EAs to
// NT style and vice-versa.
//

//++
//
// ULONG
// SmbGetNtSizeOfFea (
//     IN PFEA Fea
//     )
//
// Routine Description:
//
//     This macro gets the size that would be required to hold the FEA
//     in NT format.  The length is padded to account for the fact that
//     each FILE_FULL_EA_INFORMATION structure must start on a
//     longword boundary.
//
// Arguments:
//
//     Fea - a pointer to the OS/2 1.2 FEA structure to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes the FEA would require in NT format.
//
//--

//
// The +1 is for the zero terminator on the name, the +3 is for padding.
//

#define SmbGetNtSizeOfFea( Fea )                                            \
            (ULONG)(( FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +   \
                      (Fea)->cbName + 1 + SmbGetUshort( &(Fea)->cbValue ) + \
                      3 ) & ~3 )

//++
//
// ULONG
// SmbGetNtSizeOfGea (
//     IN PFEA Gea
//     )
//
// Routine Description:
//
//     This macro gets the size that would be required to hold the GEA
//     in NT format.  The length is padded to account for the fact that
//     each FILE_FULL_EA_INFORMATION structure must start on a
//     longword boundary.
//
// Arguments:
//
//     Gea - a pointer to the OS/2 1.2 GEA structure to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes the GEA would require in NT format.
//
//--

//
// The +1 is for the zero terminator on the name, the +3 is for padding.
//

#define SmbGetNtSizeOfGea( Gea )                                            \
            (ULONG)(( FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +   \
                      (Gea)->cbName + 1 + 3 ) & ~3 )

//++
//
// ULONG
// SmbGetOs2SizeOfNtFullEa (
//     IN PFILE_FULL_EA_INFORMATION NtFullEa;
//     )
//
// Routine Description:
//
//     This macro gets the size a FILE_FULL_EA_INFORMATION structure would
//     require to be represented in a OS/2 1.2 style FEA.
//
// Arguments:
//
//     NtFullEa - a pointer to the NT FILE_FULL_EA_INFORMATION structure
//         to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes requires for the FEA.
//
//--

#define SmbGetOs2SizeOfNtFullEa( NtFullEa )                                        \
            (ULONG)( sizeof(FEA) + (NtFullEa)->EaNameLength + 1 +               \
                     (NtFullEa)->EaValueLength )

//++
//
// ULONG
// SmbGetOs2SizeOfNtGetEa (
//     IN PFILE_GET_EA_INFORMATION NtGetEa;
//     )
//
// Routine Description:
//
//     This macro gets the size a FILE_GET_EA_INFORMATION structure would
//     require to be represented in a OS/2 1.2 style GEA.
//
// Arguments:
//
//     NtGetEa - a pointer to the NT FILE_GET_EA_INFORMATION structure
//         to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes requires for the GEA.
//
//--

//
// The zero terminator on the name is accounted for by the szName[0]
// field in the GEA definition.
//

#define SmbGetOs2SizeOfNtGetEa( NtGetEa )                                        \
            (ULONG)( sizeof(GEA) + (NtGetEa)->EaNameLength )

#endif // def _SMBMACRO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbtrsup.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    smbtrsup.h

Abstract:

    This module provides the interface to the kernel mode SmbTrace
    component within the LanMan server and redirector.
    The interface providing user-level access to SmbTrace is found in
    nt\private\inc\smbtrace.h

Author:

    Stephan Mueller (t-stephm) 20-July-1992

Revision History:

    20-July-1992 t-stephm

        Created

--*/

#ifndef _SMBTRSUP_
#define _SMBTRSUP_

//
// Selection of components in which SmbTrace will run.
// Pass the appropriate value to SmbTraceStart and SmbTraceStop,
// and test the appropriate element of SmbTraceActive and
// SmbTraceTransitioning.  The actual tracing calls do not require
// a Component parameter as it is implied by the routine being called.
//

typedef enum _SMBTRACE_COMPONENT {
    SMBTRACE_SERVER,
    SMBTRACE_REDIRECTOR
} SMBTRACE_COMPONENT;


extern BOOLEAN SmbTraceActive[];

//
// SmbTrace support exported routines
//


//
// Initialize the SMB tracing package
//
NTSTATUS
SmbTraceInitialize (
    IN SMBTRACE_COMPONENT Component
    );

//
// Terminate the SMB tracing package
//
VOID
SmbTraceTerminate (
    IN SMBTRACE_COMPONENT Component
    );

//
// Start tracing
//
NTSTATUS
SmbTraceStart(
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN OUT PVOID ConfigInOut,
    IN PFILE_OBJECT FileObject,
    IN SMBTRACE_COMPONENT Component
    );

//
// Stop tracing
//
NTSTATUS
SmbTraceStop(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN SMBTRACE_COMPONENT Component
    );


//
// VOID
// SMBTRACE_SRV(
//     IN PMDL SmbMdl,
//     )
//
// Routine description:
//
//     If SmbTrace is turned on, this macro calls SmbTraceCompleteSrv
//     to send the SMB to the smbtrace program in user mode.  This routine
//     is specific to the LanMan server.  Use it for tracing an SMB
//     contained in an Mdl.
//
// Arguments:
//
//     SmbMdl - a pointer to the Mdl containing the SMB that is about
//              to be sent.
//
// Return Value:
//
//     None
//

#define SMBTRACE_SRV(smbmdl)                                        \
            if ( SmbTraceActive[SMBTRACE_SERVER] ) {                \
                SmbTraceCompleteSrv( (smbmdl), NULL, 0 );           \
            }

//
// VOID
// SMBTRACE_SRV2(
//     IN PVOID Smb,
//     IN ULONG SmbLength
//     )
//
// Routine description:
//
//     If SmbTrace is turned on, this macro calls SmbTraceCompleteSrv
//     to send the SMB to the smbtrace program in user mode.  This routine
//     is specific to the LanMan server.  Use it for tracing an SMB
//     found in contiguous memory.
//
// Arguments:
//
//     Smb - a pointer to the SMB that is about to be sent.
//
//     SmbLength - the length of the SMB.
//
// Return Value:
//
//     None
//

#define SMBTRACE_SRV2(smb,smblength)                                \
            if ( SmbTraceActive[SMBTRACE_SERVER] ) {                \
                SmbTraceCompleteSrv( NULL, (smb), (smblength) );    \
            }

//
// Identify a packet for tracing in the server.
// Do not call this routine directly, always use the SMBTRACE_SRV macro
//
VOID
SmbTraceCompleteSrv (
    IN PMDL SmbMdl,
    IN PVOID Smb,
    IN CLONG SmbLength
    );

//
// VOID
// SMBTRACE_RDR(
//     IN PMDL SmbMdl
//     )
//
// Routine description:
//
//     If SmbTrace is turned on, this macro calls SmbTraceCompleteRdr
//     to send the SMB to the smbtrace program in user mode.  This routine
//     is specific to the LanMan redirector.  Use it for tracing an SMB
//     contained in an Mdl.
//
// Arguments:
//
//     SmbMdl - a pointer to the Mdl containing the SMB that is about
//              to be sent.
//
// Return Value:
//
//     None
//

#define SMBTRACE_RDR(smbmdl)                                        \
            if ( SmbTraceActive[SMBTRACE_REDIRECTOR] ) {            \
                SmbTraceCompleteRdr( (smbmdl), NULL, 0 );           \
            }

//
// VOID
// SMBTRACE_RDR2(
//     IN PVOID Smb,
//     IN ULONG SmbLength
//     )
//
// Routine description:
//
//     If SmbTrace is turned on, this macro calls SmbTraceCompleteRdr
//     to send the SMB to the smbtrace program in user mode.  This routine
//     is specific to the LanMan redirector.  Use it for tracing an SMB
//     found in contiguous memory.
//
// Arguments:
//
//     Smb - a pointer to the SMB that is about to be sent.
//
//     SmbLength - the length of the SMB.
//
// Return Value:
//
//     None
//

#define SMBTRACE_RDR2(smb,smblength)                                \
            if ( SmbTraceActive[SMBTRACE_REDIRECTOR] ) {            \
                SmbTraceCompleteRdr( NULL, (smb), (smblength) );    \
            }

//
// Identify a packet for tracing in the redirector.
// Do not call this routine directly, always use one of the SMBTRACE_RDR
// macros.
//
VOID
SmbTraceCompleteRdr (
    IN PMDL SmbMdl,
    IN PVOID Smb,
    IN CLONG SmbLength
    );

#endif  // _SMBTRSUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\spsyslib.h ===
/*
File Description:

    This file contains all the functions shared by riprep, factory, and sysprep.
    User of these functions must link to sysprep.lib.

    We will eventually move sysprep_c.w in here.

*/
#ifndef _SYSLIB_H
#define _SYSLIB_H

#include <cfgmgr32.h>
#include <setupapi.h>

// ============================================================================
// Global Constants
// ============================================================================
#define INIBUF_SIZE 4096
#define INIBUF_GROW 4096

// ============================================================================
// DEVIDS.H
// ============================================================================
#define DEVID_ARRAY_SIZE   100
#define DEVID_ARRAY_GROW   50

typedef struct DEVIDLIST_TAG
{
    TCHAR    szHardwareID[MAX_DEVICE_ID_LEN];
    TCHAR    szCompatibleID[MAX_DEVICE_ID_LEN];
    TCHAR    szINFFileName[MAX_PATH];
} DEVIDLIST, *LPDEVIDLIST;


// Functions
BOOL BuildDeviceIDList
(
    LPTSTR      lpszSectionName,
    LPTSTR      lpszIniFileName,
    LPGUID      lpDeviceClassGUID,
    LPDEVIDLIST *lplpDeviceIDList,
    LPDWORD     lpdwNumDeviceIDs,
    BOOL        bForceIDScan,
    BOOL        bForceAlwaysSecExist
);

#endif // _SYSLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbtypes.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    smbtypes.h

Abstract:

    This module defines types related to SMB processing.

Author:

    Chuck Lenzmeier (chuckl)   1-Dec-1989
    David Treadwell (davidtr)
Revision History:

--*/

#ifndef _SMBTYPES_
#define _SMBTYPES_

//#include <nt.h>

//
// SMBDBG determines whether the get/put macros (in smbgtpt.h) are
// instead defined as function calls.  (This is used to more reliably
// find char/short/long mismatches.
//

#ifndef SMBDBG
#define SMBDBG 0
#endif

//
// SMBDBG1 determines whether the names of short and long fields in SMB
// structures have an extra character appended.  This is used to ensure
// that these fields are only accessed via the get/put macros.  SMBDBG1
// must be disabled when SMBDBG is enabled.
//

#ifndef SMBDBG1
#define SMBDBG1 0
#endif

#if SMBDBG && SMBDBG1
#undef SMBDBG1
#define SMBDBG1 0
#endif

//
// If __unaligned support is available, or if we're compiling for a
// machine that handles unaligned accesses in hardware, then define
// SMB_USE_UNALIGNED as 1 (TRUE).  Otherwise, define it as 0 (FALSE).
// If SMB_USE_UNALIGNED is FALSE, then the macros below use byte
// accesses to build up word and longword accesses to unaligned fields.
//
// Currently, the machines we build for all have SMB_USE_UNALIGNED as
// TRUE.  x86 supports unaligned accesses in hardware, while the MIPS
// compiler supports the __unaligned keyword.
//
// Note that if SMB_USE_UNALIGNED is predefined, we use that definition.
// Also, if SMB_NO_UNALIGNED is defined as TRUE, it forces
// SMB_USE_ALIGNED off.  This allows us to force, for testing purposes,
// use of byte accesses in the macros.
//

#ifndef SMB_NO_UNALIGNED
#define SMB_NO_UNALIGNED 0
#endif

#ifndef SMB_USE_UNALIGNED
#if SMB_NO_UNALIGNED
#define SMB_USE_UNALIGNED 0
#else
#define SMB_USE_UNALIGNED 1
#endif
#endif

//
// ntdef.h defines UNALIGNED as "__unaligned" or "", depending on
// whether we're building for MIPS or x86, respectively.  Because we
// want to be able to disable use of __unaligned, we define
// SMB_UNALIGNED as "UNALIGNED" or "", depending on whether
// SMB_USE_UNALIGNED is TRUE or FALSE, respectively.
//

#if SMB_USE_UNALIGNED
#define SMB_UNALIGNED UNALIGNED
#else
#define SMB_UNALIGNED
#endif

//
// For ease of use, we define types for unaligned pointers to shorts
// and longs in SMBs.  Note that "PUSHORT UNALIGNED" doesn't work.
//

typedef unsigned short SMB_UNALIGNED *PSMB_USHORT;
typedef unsigned long SMB_UNALIGNED *PSMB_ULONG;

//
// Macros for renaming short and long SMB fields.
//

#if SMBDBG1

#define _USHORT( field ) USHORT field ## S
#define _ULONG( field ) ULONG field ## L

#else

#define _USHORT( field ) USHORT field
#define _ULONG( field ) ULONG field

#endif

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING


//
// The SMB_DIALECT type corresponds to the different SMB dialects
// that the server can speak.  Associated with it is the DialectStrings[]
// array that holds information about the ASCIIZ strings that are passed
// in the Negotiate SMB.s
//
// These are listed in order from highest preference to lowest preference.
// The assigned numbers correspond to the array SrvClientTypes[] in the
// server module srvdata.c.
//

typedef enum _SMB_DIALECT {


    SmbDialectCairo,                // Cairo
#ifdef INCLUDE_SMB_IFMODIFIED
    SmbDialectNtLanMan2,            // NT LAN Man for beyond Win2000
#endif
    SmbDialectNtLanMan,             // NT LAN Man
    SmbDialectLanMan21,             // OS/2 Lanman 2.1
    SmbDialectDosLanMan21,          // DOS Lanman 2.1
    SmbDialectLanMan20,             // OS/2 1.2 LanMan 2.0
    SmbDialectDosLanMan20,          // DOS LanMan 2.0
    SmbDialectLanMan10,             // 1st version of full LanMan extensions
    SmbDialectMsNet30,              // Larger subset of LanMan extensions
    SmbDialectMsNet103,             // Limited subset of LanMan extensions
    SmbDialectPcLan10,              // Alternate original protocol
    SmbDialectPcNet10,              // Original protocol
    SmbDialectIllegal,

} SMB_DIALECT, *PSMB_DIALECT;

#define FIRST_DIALECT SmbDialectCairo

#ifdef INCLUDE_SMB_IFMODIFIED
#define FIRST_DIALECT_EMULATED  SmbDialectNtLanMan2
#else
#define FIRST_DIALECT_EMULATED  SmbDialectNtLanMan
#endif

#define LAST_DIALECT SmbDialectIllegal
#define IS_DOS_DIALECT(dialect)                                        \
    ( (BOOLEAN)( (dialect) == SmbDialectDosLanMan21 ||                 \
                 (dialect) == SmbDialectDosLanMan20 ||                 \
                 (dialect) > SmbDialectLanMan10 ) )
#define IS_OS2_DIALECT(dialect) ( (BOOLEAN)!IS_DOS_DIALECT(dialect) )

#ifdef INCLUDE_SMB_IFMODIFIED

#define IS_NT_DIALECT(dialect)  ( (dialect) == SmbDialectNtLanMan ||   \
                                  (dialect) == SmbDialectNtLanMan2 ||  \
                                  (dialect) == SmbDialectCairo )
#define IS_POSTNT5_DIALECT(dialect)  ( (dialect) == SmbDialectNtLanMan2 )

#else

#define IS_NT_DIALECT(dialect)  ( (dialect) == SmbDialectNtLanMan ||   \
                                  (dialect) == SmbDialectCairo )
#endif


#define DIALECT_HONORS_UID(dialect)     \
    ( (BOOLEAN)(dialect <= SmbDialectDosLanMan20 ) )


//
// Date and time structures that conform to MS-DOS standard used in
// some SMBs.
//
// !!! These structures are not portable--they depend on a little-endian
//     machine (TwoSeconds in lowest bits, etc.)
//

typedef union _SMB_DATE {
    USHORT Ushort;
    struct {
        USHORT Day : 5;
        USHORT Month : 4;
        USHORT Year : 7;
    } Struct;
} SMB_DATE;
typedef SMB_DATE SMB_UNALIGNED *PSMB_DATE;

typedef union _SMB_TIME {
    USHORT Ushort;
    struct {
        USHORT TwoSeconds : 5;
        USHORT Minutes : 6;
        USHORT Hours : 5;
    } Struct;
} SMB_TIME;
typedef SMB_TIME SMB_UNALIGNED *PSMB_TIME;


//
// The SMB_FIND_BUFFER and SMB_FIND_BUFFER2 structures are used in the
// Transaction2 Find protocols to return files matching the requested
// specifications.  They are identical except for the EaSize field
// in SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    UCHAR FileNameLength;
    CHAR FileName[1];
} SMB_FIND_BUFFER;
typedef SMB_FIND_BUFFER SMB_UNALIGNED *PSMB_FIND_BUFFER;

typedef struct _SMB_FIND_BUFFER2 {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    _ULONG( EaSize );               // this field intentionally misaligned!
    UCHAR FileNameLength;
    CHAR FileName[1];
} SMB_FIND_BUFFER2;
typedef SMB_FIND_BUFFER2 SMB_UNALIGNED *PSMB_FIND_BUFFER2;


//
// The following structures are used in OS/2 1.2 for extended attributes
// (EAs).  OS/2 2.0 uses the same structures as NT.  See the OS/2
// Programmer's Reference, Volume 4, Chapter 4 for more information.
//
// The FEA structure holds a single EA's name and value and is the
// equivalent ofthe NT structure FILE_FULL_EA_INFORMATION.
//

typedef struct _FEA {
    UCHAR fEA;
    UCHAR cbName;
    _USHORT( cbValue );
} FEA;
typedef FEA SMB_UNALIGNED *PFEA;

//
// The only legal bit in fEA is FEA_NEEDEA.
//

#define FEA_NEEDEA 0x80

//
// The FEALIST structure holds the names and values of multiple EAs
// NT has no direct equivalent but rather strings together
// FILE_FULL_EA_INFORMATION structures.
//

typedef struct _FEALIST {
    _ULONG( cbList );
    FEA list[1];
} FEALIST;
typedef FEALIST SMB_UNALIGNED *PFEALIST;

//
// The GEA structure holds the name of a single EA.  It is used to
// request the value of that EA in OS/2 API functions.  The NT
// equivalent is FILE_GET_EA_INFORMATION.
//

typedef struct _GEA {
    UCHAR cbName;
    CHAR szName[1];
} GEA;
typedef GEA SMB_UNALIGNED *PGEA;

//
// The GEALIST structure holds the names of multiple EAs.  NT has no
// direct equivalent but rather strings together FILE_GET_EA_INFORMATION
// structures.
//

typedef struct _GEALIST {
    _ULONG( cbList );
    GEA list[1];
} GEALIST;
typedef GEALIST SMB_UNALIGNED *PGEALIST;

//
// The EAOP structure holds EA information needed by API calls.  It has
// no NT equivalent.
//

typedef struct _EAOP {
    PGEALIST fpGEAList;
    PFEALIST fpFEAList;
    ULONG oError;
} EAOP;
typedef EAOP SMB_UNALIGNED *PEAOP;

//
// FSALLOCATE contains information about a disk returned by
// SrvSmbQueryFsInfo.
//

typedef struct _FSALLOCATE {
    _ULONG( idFileSystem );
    _ULONG( cSectorUnit );
    _ULONG( cUnit );
    _ULONG( cUnitAvail );
    _USHORT( cbSector );
} FSALLOCATE, *PFSALLOCATE;     // *** NOT SMB_UNALIGNED!

//
// VOLUMELABEL contains information about a volume label returned by
// SrvSmbQueryFsInformation.
//

typedef struct _VOLUMELABEL {
    UCHAR cch;
    CHAR szVolLabel[12];
} VOLUMELABEL, *PVOLUMELABEL;   // *** NOT SMB_UNALIGNED!

//
// FSINFO holds information about a volume returned by
// SrvSmbQueryFsInformation.
//

typedef struct _FSINFO {
    _ULONG( ulVsn );
    VOLUMELABEL vol;
} FSINFO, *PFSINFO;             // *** NOT SMB_UNALIGNED!

//
// File types (returned by OpenAndX and Transact2_Open)
// FileTypeIPC is a private definition for the NT redirector and
// is not in the smb protocol.
//

typedef enum _FILE_TYPE {
    FileTypeDisk = 0,
    FileTypeByteModePipe = 1,
    FileTypeMessageModePipe = 2,
    FileTypePrinter = 3,
    FileTypeCommDevice = 4,
    FileTypeIPC = 0xFFFE,
    FileTypeUnknown = 0xFFFF
} FILE_TYPE;

//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING

#endif // def _SMBTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\spapip.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    spapip.h

Abstract:

    Header file for routines exported from setupapi.dll that are NOT
    part of the setup API, and are thus intended for private/internal use.

Author:

    Ted Miller (tedm) Mar-31-1995

Revision History:

    Jamie Hunter (jamiehun) May-25-2000
            General cleanup. All private exported SetupAPI functions now begin pSetup...

--*/

//
// these are also exported in setupapi.dll
//
#include <sputils.h>

VOID
pSetupOutOfMemory(
    IN HWND Owner OPTIONAL
    );

//
// Global flags / overrides
//
VOID
pSetupSetGlobalFlags(
    IN DWORD Value
    );

DWORD
pSetupGetGlobalFlags(
    VOID
    );

VOID pSetupModifyGlobalFlags(
    IN DWORD Flags,
    IN DWORD Value
    );

#define PSPGF_NO_RUNONCE          0x00000001 // set to inhibit runonce calls
#define PSPGF_NO_BACKUP           0x00000002 // set to inhibit automatic backup
#define PSPGF_NONINTERACTIVE      0x00000004 // set to inhibit all UI
#define PSPGF_SERVER_SIDE_RUNONCE 0x00000008 // batch RunOnce entries for server-side processing
#define PSPGF_NO_VERIFY_INF       0x00000010 // set to inhibit verification (digital signature) of INFs
#define PSPGF_UNATTENDED_SETUP    0x00000020 // set during full unattended setup
#define PSPGF_MINIMAL_EMBEDDED    0x00000040 // minimize footprint for embedded scenarios
#define PSPGF_NO_SCE_EMBEDDED     0x00000080 // don't call SCE for embedded scenarios
#define PSPGF_AUTOFAIL_VERIFIES   0x00000100 // fail all file verification attempts (w/o calling crypto)

//
// to allow syssetup.dll to signal all setupapi.dll's that we require headless mode
// returns TRUE on success. Only works during syssetup
//
BOOL
pSetupSetNoDriverPrompts(
    BOOL Flag
    );


//
// Server-side (non-interactive mode) RunOnce processing support
//
typedef struct _PSP_RUNONCE_NODE {

    struct _PSP_RUNONCE_NODE *Next;

    PCWSTR DllFullPath;
    PCSTR  DllEntryPointName;
    PCWSTR DllParams;

} PSP_RUNONCE_NODE, *PPSP_RUNONCE_NODE;

PPSP_RUNONCE_NODE
pSetupAccessRunOnceNodeList(
    VOID
    );

VOID
pSetupDestroyRunOnceNodeList(
    VOID
    );

//
// per queue overrides
//
BOOL
pSetupSetQueueFlags(
    IN HSPFILEQ QueueHandle,
    IN DWORD flags
    );

DWORD
pSetupGetQueueFlags(
    IN HSPFILEQ QueueHandle
    );

//
// Queue flags.
//
#define FQF_TRY_SIS_COPY                    0x00000001  // try SIS copy first
#define FQF_BACKUP_AWARE                    0x00010000  // allow callbacks
#define FQF_DID_CATALOGS_OK                 0x00020000  // catalog/inf verification has run
#define FQF_DID_CATALOGS_FAILED             0x00040000  // catalog/inf verification has run
#define FQF_DIGSIG_ERRORS_NOUI              0x00080000  // prompt user on failed signature
                                                        // verification
#define FQF_DEVICE_INSTALL                  0x00100000  // file queue is for device install
#define FQF_USE_ALT_PLATFORM                0x00200000  // use AltPlatformInfo for digital
                                                        // signature verification
#define FQF_QUEUE_ALREADY_COMMITTED         0x00400000  // file queue has already been committed
#define FQF_DEVICE_BACKUP                   0x00800000  // device backup
#define FQF_QUEUE_FORCE_BLOCK_POLICY        0x01000000  // force policy to block so we never
                                                        // install unsigned files
#define FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES 0x02000000  // install INF/CAT from 3rd-party location
                                                        // using original names (for exception INFs)
#define FQF_BACKUP_INCOMPLETE               0x04000000  // set if we were not successful backing up
                                                        // all intended files
#define FQF_ABORT_IF_UNSIGNED               0x08000000  // set if we're supposed to bail
                                                        // out of unsigned queue committals
                                                        // so that the caller can set a system
                                                        // restore point.
#define FQF_FILES_MODIFIED                  0x10000000  // set if any files are overwritten.

//
// File functions in fileutil.c
//
BOOL
pSetupGetVersionInfoFromImage(
    IN  PCTSTR          FileName,
    OUT PULARGE_INTEGER Version,
    OUT LANGID         *Language
    );
//
// Private INF routines
//
PCTSTR
pSetupGetField(
    IN PINFCONTEXT Context,
    IN DWORD       FieldIndex
    );


//
// Registry interface routines
//

DWORD
pSetupQueryMultiSzValueToArray(
    IN  HKEY     Root,
    IN  PCTSTR   Subkey,
    IN  PCTSTR   ValueName,
    OUT PTSTR  **Array,
    OUT PUINT    StringCount,
    IN  BOOL     FailIfDoesntExist
    );

DWORD
pSetupSetArrayToMultiSzValue(
    IN HKEY     Root,
    IN PCTSTR   Subkey,
    IN PCTSTR   ValueName,
    IN PTSTR   *Array,
    IN UINT     StringCount
    );

VOID
pSetupFreeStringArray(
    IN PTSTR *Array,
    IN UINT   StringCount
    );

DWORD
pSetupAppendStringToMultiSz(
    IN HKEY   Key,
    IN PCTSTR SubKeyName,       OPTIONAL
    IN DWORD  DevInst,          OPTIONAL
    IN PCTSTR ValueName,        OPTIONAL
    IN PCTSTR String,
    IN BOOL   AllowDuplicates
    );

//
// Service controller helper functions
//
DWORD
pSetupRetrieveServiceConfig(
    IN  SC_HANDLE               ServiceHandle,
    OUT LPQUERY_SERVICE_CONFIG *ServiceConfig
    );

DWORD
pSetupAddTagToGroupOrderListEntry(
    IN PCTSTR LoadOrderGroup,
    IN DWORD  TagId,
    IN BOOL   MoveToFront
    );

DWORD
pSetupAcquireSCMLock(
    IN  SC_HANDLE  SCMHandle,
    OUT SC_LOCK   *pSCMLock
    );


//
// Miscellaneous utility functions
//

BOOL
pSetupInfIsFromOemLocation(
    IN PCTSTR InfFileName,
    IN BOOL   InfDirectoryOnly
    );

DWORD
pSetupGetOsLoaderDriveAndPath(
    IN  BOOL   RootOnly,
    OUT PTSTR  CallerBuffer,
    IN  DWORD  CallerBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

BOOL
pSetupSetSystemSourcePath(
    IN PCTSTR NewSourcePath,
    IN PCTSTR NewSvcPackSourcePath
    );

BOOL
pSetupShouldDeviceBeExcluded(
    IN  PCTSTR DeviceId,
    IN  HINF   hInf,
    OUT PBOOL  ArchitectureSpecificExclude OPTIONAL
    );

BOOL
pSetupDiSetDeviceInfoContext(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Context
    );

BOOL
pSetupDiGetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PDWORD           Context
    );

#define SETUP_HAS_OPEN_DIALOG_EVENT     TEXT("MS_SETUPAPI_DIALOG")
#define SETUP_NODRIVERPROMPTS_MODE      TEXT("MS_SETUPAPI_NODRIVERPROMPTS")

INT
pSetupAddMiniIconToList(
    IN HBITMAP hbmImage,
    IN HBITMAP hbmMask
    );

PCTSTR
pSetupDirectoryIdToPath(
    IN     PCTSTR  DirectoryId,    OPTIONAL
    IN OUT PUINT   DirectoryIdInt, OPTIONAL
    IN     PCTSTR  SubDirectory,   OPTIONAL
    IN     PCTSTR  InfSourcePath,  OPTIONAL
    IN OUT PCTSTR *OsLoaderPath    OPTIONAL
    );

//
// Routine used by optional components code in syssetup to setup runonce/grpconv.
//
DWORD
pSetupInstallStopEx(
    IN BOOL DoRunOnce,
    IN DWORD Flags,
    IN PVOID Reserved
    );

#define INSTALLSTOP_NO_UI        0x00000001     // InstallStop should do no UI
#define INSTALLSTOP_NO_GRPCONV   0x00000002     // Don't do GrpConv

//
// Section access for INF file
//

BOOL
pSetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    );


//
// GUID handling routines
// these may be eventually removed
//
DWORD
pSetupGuidFromString(
   IN  PCTSTR GuidString,
   OUT LPGUID Guid
   );

DWORD
pSetupStringFromGuid(
   IN  CONST GUID *Guid,
   OUT PTSTR       GuidString,
   IN  DWORD       GuidStringSize
   );

BOOL
pSetupIsGuidNull(
    IN CONST GUID *Guid
    );

//
// pSetupInfCacheBuild function
// called to rebuild the cache(s)
//
BOOL
WINAPI
pSetupInfCacheBuild(
    IN DWORD Action
    );

//
// action (more may be added)
//
#define INFCACHEBUILD_UPDATE  0x00000000      // update caches
#define INFCACHEBUILD_REBUILD 0x00000001      // delete and update caches

//
// Digital signature verification routines
//

typedef enum {
    SetupapiVerifyNoProblem,
    SetupapiVerifyCatalogProblem,        // catalog file couldn't be verified
    SetupapiVerifyInfProblem,            // inf file couldn't be installed/verified
    SetupapiVerifyFileNotSigned,         // file is not signed, no verification attempted
    SetupapiVerifyFileProblem,           // file may be signed, but couldn't be verified
    SetupapiVerifyClassInstProblem,      // class installer is unsigned
    SetupapiVerifyCoInstProblem,         // co-installer is unsigned
    SetupapiVerifyCatalogInstallProblem, // catalog install failed (not due to verification failure)
    SetupapiVerifyRegSvrFileProblem,     // file to be registered/unregistered is unsigned
    SetupapiVerifyIncorrectlyCopiedInf,  // invalid attempt to directly copy INF into %windir%\Inf
    SetupapiVerifyAutoFailProblem ,      // PSPGF_AUTOFAIL_VERIFIES flag is set
    SetupapiVerifyDriverBlocked          // driver is in the bad driver database.
} SetupapiVerifyProblem;


DWORD
pSetupVerifyQueuedCatalogs(
    IN HSPFILEQ FileQueue
    );

DWORD
pSetupVerifyCatalogFile(
    IN LPCTSTR CatalogFullPath
    );

DWORD
pSetupVerifyFile(
    IN  LPVOID                  LogContext,
    IN  LPCTSTR                 Catalog,                OPTIONAL
    IN  PVOID                   CatalogBaseAddress,     OPTIONAL
    IN  DWORD                   CatalogImageSize,
    IN  LPCTSTR                 Key,
    IN  LPCTSTR                 FileFullPath,
    OUT SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT LPTSTR                  ProblemFile,            OPTIONAL
    IN  BOOL                    CatalogAlreadyVerified,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT PDWORD                  NumCatalogsConsidered   OPTIONAL
    );

DWORD
pSetupInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath
    );

BOOL
pSetupHandleFailedVerification(
    IN HWND                  Owner,
    IN SetupapiVerifyProblem Problem,
    IN LPCTSTR               ProblemFile,
    IN LPCTSTR               DeviceDesc,          OPTIONAL
    IN DWORD                 DriverSigningPolicy,
    IN BOOL                  NoUI,
    IN DWORD                 Error,
    IN PVOID                 LogContext,          OPTIONAL
    OUT PDWORD               Flags,               OPTIONAL
    IN LPCTSTR               TargetName           OPTIONAL
    );

DWORD
pSetupGetCurrentDriverSigningPolicy(
    IN BOOL IsDeviceInstallation
    );

//
// private SetupDiCallClassInstaller defines/structures
//

//
// DI_FUNCTION codes
//

#define DIF_INTERFACE_TO_DEVICE             0x00000030 // aka DIF_RESERVED2

//
// Structure corresponding to the DIF_INTERFACE_TO_DEVICE install function
// note that this is always Unicode
// always use SetupDiSetClassInstallParamsW
//
typedef struct _SP_INTERFACE_TO_DEVICE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    PCWSTR                 Interface;           // IN (must remain valid)
    WCHAR                  DeviceId[200];       // OUT MAX_DEVICE_ID_LEN
} SP_INTERFACE_TO_DEVICE_PARAMS_W, *PSP_INTERFACE_TO_DEVICE_PARAMS_W;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbtrace.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smbtrace.h

Abstract:

    This module provides the interface between the SmbTrace program and
    the kernel mode SmbTrace component.
    The interface between the kernel mode component and the
    server/redirector is found in nt\private\inc\smbtrsup.h

Author:

    Peter Gray (w-peterg)  16-Mar-92

Revision History:

    Stephan Mueller (t-stephm)  08-July-92

        Extensions to support smbtrace in the redirector as well as the
        server.

--*/

#ifndef _SMBTRACE_
#define _SMBTRACE_

//
// The shared memory has this structure in it, used to manage the
// table and other data shared by the kernel mode component and
// the appliction. It is passed back to the client after creation by the 
// server during a FSCTL_???_START_SMBTRACE via an offset (pointer).
//
typedef struct _SMBTRACE_TABLE_HEADER {
    ULONG    HighestConsumed; // last table entry processed by app (queue head)
    ULONG    NextFree;        // next free entry in table (queue tail)
    BOOLEAN  ApplicationStop; // when set, the application should halt
} SMBTRACE_TABLE_HEADER, *PSMBTRACE_TABLE_HEADER;


//
// The following stucture is one entry in the shared table of
// offsets to the received SMBs. The offsets are relative to the
// start of the shared memory section.
//
typedef struct _SMBTRACE_TABLE_ENTRY {
    ULONG    BufferOffset;    // location of SMB from start of shared memory
    ULONG    SmbLength;       // the length of the SMB
    ULONG    NumberMissed;    // number of preceding SMBs that were missed
    PVOID    SmbAddress;      // real address of original SMB, if available
} SMBTRACE_TABLE_ENTRY, *PSMBTRACE_TABLE_ENTRY;


//
// The following stucture is passed to the server when doing the
// FSCtl "FSCTL_???_START_SMBTRACE". It contains configuration
// information that will affect the way the NT server and Smbtrace
// will interact.
//
typedef struct _SMBTRACE_CONFIG_PACKET_REQ {
    BOOLEAN  SingleSmbMode;  // T to block on DoneEvent, F for faster.
    CLONG    Verbosity;      // how much data the app intends to decode
                             // indicates how much needs to be saved
    ULONG    BufferSize;     // size of shared memory used to store SMBs
    ULONG    TableSize;      // number of entries in the table
} SMBTRACE_CONFIG_PACKET_REQ, *PSMBTRACE_CONFIG_PACKET_REQ;


//
// Here is the response to that FSCTL.
//
typedef struct _SMBTRACE_CONFIG_PACKET_RESP {
    ULONG    HeaderOffset;   // location of header from start of shared memory 
    ULONG    TableOffset;    // location of table from start of shared memory
} SMBTRACE_CONFIG_PACKET_RESP, *PSMBTRACE_CONFIG_PACKET_RESP;


//
// Well-known names for objects accessible to both the server/redirector
// and the Smbtrace application.
//
#define SMBTRACE_SRV_SHARED_MEMORY_NAME   TEXT( "\\SmbTraceSrvMemory" )
#define SMBTRACE_SRV_NEW_SMB_EVENT_NAME   TEXT( "\\SmbTraceSrvNewSmbEvent" )
#define SMBTRACE_SRV_DONE_SMB_EVENT_NAME  TEXT( "\\SmbTraceSrvDoneSmbEvent" )

#define SMBTRACE_LMR_SHARED_MEMORY_NAME   TEXT( "\\SmbTraceRdrMemory" )
#define SMBTRACE_LMR_NEW_SMB_EVENT_NAME   TEXT( "\\SmbTraceRdrNewSmbEvent" )
#define SMBTRACE_LMR_DONE_SMB_EVENT_NAME  TEXT( "\\SmbTraceRdrDoneSmbEvent" )

//
// Verbosity levels indicating how much data the SmbTrace application
// intends to decode, and consequently, how much data the server/redirector
// must preserve for it.
//
#define SMBTRACE_VERBOSITY_OFF            0
#define SMBTRACE_VERBOSITY_SINGLE_LINE    1
#define SMBTRACE_VERBOSITY_ERROR          2
#define SMBTRACE_VERBOSITY_HEADER         3
#define SMBTRACE_VERBOSITY_PARAMS         4
#define SMBTRACE_VERBOSITY_NONESSENTIAL   5

#endif // _SMBTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sputils.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sputils.w (generates sputils.h)

Abstract:

    Header file for utility routines used primarily by setupapi that's also
    used by other components for convinience.
    Link to either sputils.lib (static version) or spapip.lib (dll version)

    For internal use only.

Author:

    Jamie Hunter (jamiehun) Jun-26-2000

Revision History:

--*/

#if defined(SPUTILSW) && defined(UNICODE)
//
// SPUTILSW.LIB is cut down version of SPUTILSU.LIB
// with renamed API's
// thus SPUTILSW.LIB can be used with SPUTILSA.LIB
//
#define pSetupDebugPrintEx pSetupDebugPrintExW
#define pSetupStringTableInitialize pSetupStringTableInitializeW
#define pSetupStringTableInitializeEx pSetupStringTableInitializeExW
#define pSetupStringTableDestroy pSetupStringTableDestroyW
#define pSetupStringTableAddString pSetupStringTableAddStringW
#define pSetupStringTableAddStringEx pSetupStringTableAddStringExW
#define pSetupStringTableLookUpString pSetupStringTableLookUpStringW
#define pSetupStringTableLookUpStringEx pSetupStringTableLookUpStringExW
#define pSetupStringTableGetExtraData pSetupStringTableGetExtraDataW
#define pSetupStringTableSetExtraData pSetupStringTableSetExtraDataW
#define PSTRTAB_ENUM_ROUTINE PSTRTAB_ENUM_ROUTINE_W
#define pSetupStringTableEnum pSetupStringTableEnumW
#define pSetupStringTableStringFromId pSetupStringTableStringFromIdW
#define pSetupStringTableStringFromIdEx pSetupStringTableStringFromIdExW
#define pSetupStringTableDuplicate pSetupStringTableDuplicateW
//
// fileutil.c
//
#define pSetupOpenAndMapFileForRead pSetupOpenAndMapFileForReadW
#define pSetupFileExists pSetupFileExistsW
#define pSetupMakeSurePathExists pSetupMakeSurePathExistsW

#define pSetupDoesUserHavePrivilege pSetupDoesUserHavePrivilegeW
#define pSetupEnablePrivilege pSetupEnablePrivilegeW
#define pSetupRegistryDelnode pSetupRegistryDelnodeW
#define pSetupRegistryDelnodeEx pSetupRegistryDelnodeExW
//
// miscutil.c
//
#define pSetupDuplicateString pSetupDuplicateStringW
#define pSetupCaptureAndConvertAnsiArg pSetupCaptureAndConvertAnsiArgW
#define pSetupConcatenatePaths pSetupConcatenatePathsW
#define pSetupGetFileTitle pSetupGetFileTitleW

#endif // SPUTILSW && UNICODE

//
//
//
// Initialization - must be called to use the tools (static version only)
//
BOOL
pSetupInitializeUtils(
    VOID
    );

BOOL
pSetupUninitializeUtils(
    VOID
    );

//
// Memory allocation functions (also used by other functions below)
//
PVOID
pSetupMalloc(
    IN DWORD Size
    );

PVOID
pSetupDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line
    );

PVOID
pSetupDebugMallocWithTag(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    );

PVOID
pSetupRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    );

PVOID
pSetupReallocWithTag(
    IN PVOID Block,
    IN DWORD NewSize,
    IN DWORD Tag
    );

VOID
pSetupFree(
    IN CONST VOID *Block
    );

VOID
pSetupFreeWithTag(
    IN CONST VOID *Block,
    IN DWORD Tag
    );

VOID
pSetupDebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    );

HANDLE
pSetupGetHeap(
    VOID
    );

#if DBG
#define pSetupCheckedMalloc(Size)    pSetupDebugMalloc(Size,__FILE__,__LINE__)
#define pSetupMallocWithTag(Size,Tag) pSetupDebugMallocWithTag(Size,__FILE__,__LINE__,Tag)
#else
#define pSetupCheckedMalloc(Size) pSetupMalloc(Size)
#define pSetupMallocWithTag(Size,Tag) pSetupMalloc(Size)
#endif

#if DBG
#define pSetupCheckInternalHeap() pSetupHeapCheck()
#else
#define pSetupCheckInternalHeap()
#endif

//
// String table functions
//
PVOID
pSetupStringTableInitialize(
    VOID
    );

PVOID
pSetupStringTableInitializeEx(
    IN UINT ExtraDataSize,  OPTIONAL
    IN UINT Reserved
    );

VOID
pSetupStringTableDestroy(
    IN PVOID StringTable
    );

//
// Flags to be used by pSetupStringTableAddString and pSetupStringTableLookUpString
//
#define STRTAB_CASE_INSENSITIVE 0x00000000
#define STRTAB_CASE_SENSITIVE   0x00000001
#define STRTAB_BUFFER_WRITEABLE 0x00000002
#define STRTAB_NEW_EXTRADATA    0x00000004

LONG
pSetupStringTableAddString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags
    );

LONG
pSetupStringTableAddStringEx(
    IN PVOID StringTable,
    IN PTSTR String,
    IN DWORD Flags,
    IN PVOID ExtraData,     OPTIONAL
    IN UINT  ExtraDataSize  OPTIONAL
    );

LONG
pSetupStringTableLookUpString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags
    );

LONG
pSetupStringTableLookUpStringEx(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
       OUT PVOID ExtraData,             OPTIONAL
    IN     UINT  ExtraDataBufferSize    OPTIONAL
    );

BOOL
pSetupStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    );

BOOL
pSetupStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    );

//
// Type for pSetupStringTableEnum
//
typedef
BOOL
(*PSTRTAB_ENUM_ROUTINE)(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pSetupStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    );

PTSTR
pSetupStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    );

BOOL
pSetupStringTableStringFromIdEx(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN OUT PTSTR pBuffer,
    IN OUT PULONG pBufSize
    );

PVOID
pSetupStringTableDuplicate(
    IN PVOID StringTable
    );

//
// File functions in fileutil.c
//
DWORD
pSetupOpenAndMapFileForRead(
    IN  PCTSTR   FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

DWORD
pSetupMapFileForRead(
    IN  HANDLE   FileHandle,
    OUT PDWORD   FileSize,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

BOOL
pSetupUnmapAndCloseFile(
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

DWORD
pSetupMakeSurePathExists(
    IN PCTSTR FullFilespec
    );

BOOL
pSetupFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );
//
// Non-file-related security routines in security.c.
//
BOOL
pSetupIsUserAdmin(
    VOID
    );

BOOL
pSetupDoesUserHavePrivilege(
    PCTSTR PrivilegeName
    );

BOOL
pSetupEnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    );

//
// Registry utility functions
//

DWORD
pSetupRegistryDelnode(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName
    );

DWORD
pSetupRegistryDelnodeEx(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName,
    IN  DWORD  ExtraFlags
    );

//
// Miscellaneous utility functions
//

DWORD
pSetupCaptureAndConvertAnsiArg(
    IN  PCSTR   AnsiString,
    OUT PCWSTR *UnicodeString
    );

PTSTR
pSetupDuplicateString(
    IN PCTSTR String
    );

PSTR
pSetupUnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    );

PWSTR
pSetupMultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    );

VOID
pSetupCenterWindowRelativeToParent(
    HWND hwnd
    );

#define pSetupUnicodeToAnsi(UnicodeString)    pSetupUnicodeToMultiByte((UnicodeString),CP_ACP)
#define pSetupUnicodeToOem(UnicodeString)     pSetupUnicodeToMultiByte((UnicodeString),CP_OEMCP)
#define pSetupAnsiToUnicode(AnsiString)       pSetupMultiByteToUnicode((AnsiString),CP_ACP)
#define pSetupOemToUnicode(OemString)         pSetupMultiByteToUnicode((OemString),CP_OEMCP)

BOOL
pSetupConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize
    );

PCTSTR
pSetupGetFileTitle(
    IN PCTSTR FilePath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\smbtrans.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    smbtrans.h

Abstract:

    This file contains request and response structure definitions for
    the specific parameters of Transaction and Transaction2 SMBs.

Author:

    Chuck Lenzmeier (chuckl)  23-Feb-1990
    David Treadwell (davidtr)

Revision History:

--*/

#ifndef _SMBTRANS_
#define _SMBTRANS_

//#include <nt.h>

//#include <smbtypes.h>
//#include <smb.h>

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING



//
// Named pipe function codes
//

#define TRANS_SET_NMPIPE_STATE      0x01
#define TRANS_RAW_READ_NMPIPE       0x11
#define TRANS_QUERY_NMPIPE_STATE    0x21
#define TRANS_QUERY_NMPIPE_INFO     0x22
#define TRANS_PEEK_NMPIPE           0x23
#define TRANS_TRANSACT_NMPIPE       0x26
#define TRANS_RAW_WRITE_NMPIPE      0x31
#define TRANS_READ_NMPIPE           0x36
#define TRANS_WRITE_NMPIPE          0x37
#define TRANS_WAIT_NMPIPE           0x53
#define TRANS_CALL_NMPIPE           0x54

//
// Mailslot function code
//

#define TRANS_MAILSLOT_WRITE        0x01

//
// Transaction2 function codes
//

#define TRANS2_OPEN2                    0x00
#define TRANS2_FIND_FIRST2              0x01
#define TRANS2_FIND_NEXT2               0x02
#define TRANS2_QUERY_FS_INFORMATION     0x03
#define TRANS2_SET_FS_INFORMATION       0x04
#define TRANS2_QUERY_PATH_INFORMATION   0x05
#define TRANS2_SET_PATH_INFORMATION     0x06
#define TRANS2_QUERY_FILE_INFORMATION   0x07
#define TRANS2_SET_FILE_INFORMATION     0x08
#define TRANS2_FSCTL                    0x09
#define TRANS2_IOCTL2                   0x0A
#define TRANS2_FIND_NOTIFY_FIRST        0x0B
#define TRANS2_FIND_NOTIFY_NEXT         0x0C
#define TRANS2_CREATE_DIRECTORY         0x0D
#define TRANS2_SESSION_SETUP            0x0E
#define TRANS2_QUERY_FS_INFORMATION_FID 0x0F
#define TRANS2_GET_DFS_REFERRAL         0x10
#define TRANS2_REPORT_DFS_INCONSISTENCY 0x11

#define TRANS2_MAX_FUNCTION             0x11

//
// Nt Transaction function codes
//

#define NT_TRANSACT_MIN_FUNCTION        1

#define NT_TRANSACT_CREATE              1
#define NT_TRANSACT_IOCTL               2
#define NT_TRANSACT_SET_SECURITY_DESC   3
#define NT_TRANSACT_NOTIFY_CHANGE       4
#define NT_TRANSACT_RENAME              5
#define NT_TRANSACT_QUERY_SECURITY_DESC 6
#define NT_TRANSACT_QUERY_QUOTA         7
#define NT_TRANSACT_SET_QUOTA           8

#define NT_TRANSACT_MAX_FUNCTION        8

//
// File information levels
//

#define SMB_INFO_STANDARD               1
#define SMB_INFO_QUERY_EA_SIZE          2
#define SMB_INFO_SET_EAS                2
#define SMB_INFO_QUERY_EAS_FROM_LIST    3
#define SMB_INFO_QUERY_ALL_EAS          4       // undocumented but supported
#define SMB_INFO_QUERY_FULL_NAME        5       // never sent by redir
#define SMB_INFO_IS_NAME_VALID          6
#define SMB_INFO_PASSTHROUGH            1000    // any info above here is a simple pass-through

//
// NT extension to file info levels
//

#define SMB_QUERY_FILE_BASIC_INFO          0x101
#define SMB_QUERY_FILE_STANDARD_INFO       0x102
#define SMB_QUERY_FILE_EA_INFO             0x103
#define SMB_QUERY_FILE_NAME_INFO           0x104
#define SMB_QUERY_FILE_ALLOCATION_INFO     0x105
#define SMB_QUERY_FILE_END_OF_FILEINFO     0x106
#define SMB_QUERY_FILE_ALL_INFO            0x107
#define SMB_QUERY_FILE_ALT_NAME_INFO       0x108
#define SMB_QUERY_FILE_STREAM_INFO         0x109
#define SMB_QUERY_FILE_COMPRESSION_INFO    0x10B

#define SMB_SET_FILE_BASIC_INFO                 0x101
#define SMB_SET_FILE_DISPOSITION_INFO           0x102
#define SMB_SET_FILE_ALLOCATION_INFO            0x103
#define SMB_SET_FILE_END_OF_FILE_INFO           0x104

#define SMB_QUERY_FS_LABEL_INFO            0x101
#define SMB_QUERY_FS_VOLUME_INFO           0x102
#define SMB_QUERY_FS_SIZE_INFO             0x103
#define SMB_QUERY_FS_DEVICE_INFO           0x104
#define SMB_QUERY_FS_ATTRIBUTE_INFO        0x105
#define SMB_QUERY_FS_QUOTA_INFO            0x106        // unused?
#define SMB_QUERY_FS_CONTROL_INFO          0x107

//
// Volume information levels.
//

#define SMB_INFO_ALLOCATION             1
#define SMB_INFO_VOLUME                 2

//
// Rename2 information levels.
//

#define SMB_NT_RENAME_MOVE_CLUSTER_INFO   0x102
#define SMB_NT_RENAME_SET_LINK_INFO       0x103
#define SMB_NT_RENAME_RENAME_FILE         0x104 // Server internal
#define SMB_NT_RENAME_MOVE_FILE           0x105 // Server internal

//
// Protocol for NtQueryQuotaInformationFile
//
typedef struct {
    _USHORT( Fid );                 // FID of target
    UCHAR ReturnSingleEntry;        // Indicates that only a single entry should be returned
                                    //   rather than filling the buffer with as
                                    //   many entries as possible.
    UCHAR RestartScan;              // Indicates whether the scan of the quota information
                                    //   is to be restarted from the beginning.
    _ULONG ( SidListLength );       // Supplies the length of the SID list if present
    _ULONG ( StartSidLength );      // Supplies an optional SID that indicates that the returned
                                    //   information is to start with an entry other
                                    //   than the first.  This parameter is ignored if a
                                    //   SidList is given
    _ULONG( StartSidOffset);        // Supplies the offset of Start Sid in the buffer
} REQ_NT_QUERY_FS_QUOTA_INFO, *PREQ_NT_QUERY_FS_QUOTA_INFO;
//
// Desciptor response
//
// Data Bytes:  The Quota Information
//
typedef struct {
    _ULONG ( Length );
} RESP_NT_QUERY_FS_QUOTA_INFO, *PRESP_NT_QUERY_FS_QUOTA_INFO;

//
// Protocol for NtSetQuotaInformationFile
//
typedef struct {
    _USHORT( Fid );                 // FID of target
} REQ_NT_SET_FS_QUOTA_INFO, *PREQ_NT_SET_FS_QUOTA_INFO;
//
// Response:
//
// Setup words:  None.
// Parameter Bytes:  None.
// Data Bytes:  None.
//

#ifdef INCLUDE_SMB_CAIRO

//
// protocol for sessionsetup as trans2
// function is srvsmbsessionsetup (int srv\smbtrans.c)
// #define TRANS2_SESSION_SETUP 0x0E
//

typedef struct _REQ_CAIRO_TRANS2_SESSION_SETUP {
    UCHAR WordCount;                    // Count of parameter words = 6
    UCHAR Pad;                          // So things are aligned
    _USHORT ( MaxBufferSize );          // Max transmit buffer size
    _USHORT ( MaxMpxCount );            // Max pending multiplexed requests
    _USHORT ( VcNumber );               // 0 = first (only), nonzero=additional VC number
    _ULONG  ( SessionKey );             // Session key (valid iff VcNumber != 0)
    _ULONG  ( Capabilities );           // Server capabilities
    _ULONG  ( BufferLength );
    UCHAR Buffer[1];
    //UCHAR KerberosTicket[];           // The KerberosTicket
} REQ_CAIRO_TRANS2_SESSION_SETUP;
typedef REQ_CAIRO_TRANS2_SESSION_SETUP *PREQ_CAIRO_TRANS2_SESSION_SETUP;  // *** NOT SMB_UNALIGNED!

typedef struct _RESP_CAIRO_TRANS2_SESSION_SETUP {
    UCHAR WordCount;                    // Count of parameter words = 0
    UCHAR Pad;                          // So things are aligned
    _USHORT( Uid );                     // Unauthenticated user id
    _ULONG ( BufferLength );
    UCHAR Buffer[1];
    //UCHAR KerberosTicket[];           // The KerberosTicket
} RESP_CAIRO_TRANS2_SESSION_SETUP;
typedef RESP_CAIRO_TRANS2_SESSION_SETUP *PRESP_CAIRO_TRANS2_SESSION_SETUP;  // *** NOT SMB_UNALIGNED!

typedef struct _REQ_QUERY_FS_INFORMATION_FID {
    _USHORT( InformationLevel );
    _USHORT( Fid );
} REQ_QUERY_FS_INFORMATION_FID;
typedef REQ_QUERY_FS_INFORMATION_FID SMB_UNALIGNED *PREQ_QUERY_FS_INFORMATION_FID;

//
// Setup words for NT I/O control request
//

struct _TempSetup {
    _ULONG( FunctionCode );
    _USHORT( Fid );
    BOOLEAN IsFsctl;
    UCHAR IsFlags;
};

typedef struct _REQ_CAIRO_IO_CONTROL {
    _USHORT( Trans2Function );   // used for Trans2, but not NT transact
    _ULONG( FunctionCode );
    _USHORT( Fid );
    BOOLEAN IsFsctl;
    UCHAR IsFlags;
} REQ_CAIRO_IO_CONTROL;
typedef REQ_CAIRO_IO_CONTROL SMB_UNALIGNED *PREQ_CAIRO_IO_CONTROL;

//
// For Cairo remoting general FSCTLS
//

#define IsTID 1


#endif // INCLUDE_SMB_CAIRO

//
// Dfs Transactions
//

//
// Request for Referral.
//
typedef struct {
    USHORT MaxReferralLevel;            // Latest version of referral understood
    UCHAR RequestFileName[1];           // Dfs name for which referral is sought
} REQ_GET_DFS_REFERRAL;
typedef REQ_GET_DFS_REFERRAL SMB_UNALIGNED *PREQ_GET_DFS_REFERRAL;

//
// The format of an individual referral contains version and length information
//  allowing the client to skip referrals it does not understand.
//
// !! All referral elements must have VersionNumber and Size as the first 2 elements !!
//

typedef struct {
    USHORT  VersionNumber;              // == 1
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
    };
    WCHAR   ShareName[1];               // The server+share name go right here.  NULL terminated.
} DFS_REFERRAL_V1;
typedef DFS_REFERRAL_V1 SMB_UNALIGNED *PDFS_REFERRAL_V1;

typedef struct {
    USHORT  VersionNumber;              // == 2
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
    };
    ULONG   Proximity;                  // Hint of transport cost
    ULONG   TimeToLive;                 // In number of seconds
    USHORT  DfsPathOffset;              // Offset from beginning of this element to Path to access
    USHORT  DfsAlternatePathOffset;     // Offset from beginning of this element to 8.3 path
    USHORT  NetworkAddressOffset;       // Offset from beginning of this element to Network path
} DFS_REFERRAL_V2;
typedef DFS_REFERRAL_V2 SMB_UNALIGNED *PDFS_REFERRAL_V2;

typedef struct {
    USHORT  VersionNumber;              // == 3
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
        USHORT NameListReferral : 1;    // This referral contains an expanded name list
    };
    ULONG   TimeToLive;                 // In number of seconds
    union {
      struct {
        USHORT DfsPathOffset;           // Offset from beginning of this element to Path to access
        USHORT DfsAlternatePathOffset;  // Offset from beginning of this element to 8.3 path
        USHORT NetworkAddressOffset;    // Offset from beginning of this element to Network path
        GUID   ServiceSiteGuid;         // The guid for the site
      };
      struct {
        USHORT SpecialNameOffset;       // Offset from this element to the special name string
        USHORT NumberOfExpandedNames;   // Number of expanded names
        USHORT ExpandedNameOffset;      // Offset from this element to the expanded name list
      };
    };
} DFS_REFERRAL_V3;
typedef DFS_REFERRAL_V3 SMB_UNALIGNED *PDFS_REFERRAL_V3;

typedef struct {
    USHORT  PathConsumed;               // Number of WCHARs consumed in DfsPathName
    USHORT  NumberOfReferrals;          // Number of referrals contained here
    struct {
            ULONG ReferralServers : 1;  // Elements in Referrals[] are referral servers
            ULONG StorageServers : 1;   // Elements in Referrals[] are storage servers
    };
    union {                             // The vector of referrals
        DFS_REFERRAL_V1 v1;
        DFS_REFERRAL_V2 v2;
        DFS_REFERRAL_V3 v3;
    } Referrals[1];                     // [ NumberOfReferrals ]

    //
    // WCHAR StringBuffer[];            // Used by DFS_REFERRAL_V2
    //

} RESP_GET_DFS_REFERRAL;
typedef RESP_GET_DFS_REFERRAL SMB_UNALIGNED *PRESP_GET_DFS_REFERRAL;

//
// During Dfs operations, a client may discover a knowledge inconsistency in the Dfs.
// The parameter portion of the TRANS2_REPORT_DFS_INCONSISTENCY SMB is
// encoded in this way
//

typedef struct {
    UCHAR RequestFileName[1];           // Dfs name for which inconsistency is being reported
    union {
        DFS_REFERRAL_V1 v1;             // The single referral thought to be in error
    } Referral;
} REQ_REPORT_DFS_INCONSISTENCY;
typedef REQ_REPORT_DFS_INCONSISTENCY SMB_UNALIGNED *PREQ_REPORT_DFS_INCONSISTENCY;

//
// The client also needs to send to this server the referral which it believes to be
//  in error.  The data part of this transaction contains the errant referral(s), encoded
//  as above in the DFS_REFERRAL_* structures.
//

//
// Find First, information levels
//

#define SMB_FIND_FILE_DIRECTORY_INFO         0x101
#define SMB_FIND_FILE_FULL_DIRECTORY_INFO    0x102
#define SMB_FIND_FILE_NAMES_INFO             0x103
#define SMB_FIND_FILE_BOTH_DIRECTORY_INFO    0x104
#define SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO 0x105
#define SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO 0x106

#ifdef INCLUDE_SMB_DIRECTORY

//
// CreateDirectory2 function code os Transaction2 SMB, see #3 page 51
// Function is SrvSmbCreateDirectory2()
// TRANS2_CREATE_DIRECTORY 0x0D
//

typedef struct _REQ_CREATE_DIRECTORY2 {
    _ULONG( Reserved );                 // Reserved--must be zero
    UCHAR Buffer[1];                    // Directory name to create
} REQ_CREATE_DIRECTORY2;
typedef REQ_CREATE_DIRECTORY2 SMB_UNALIGNED *PREQ_CREATE_DIRECTORY2;

// Data bytes for CreateDirectory2 request are the extended attributes for the
// created file.

typedef struct _RESP_CREATE_DIRECTORY2 {
    _USHORT( EaErrorOffset );           // Offset into FEAList of first error
                                        // which occurred while setting EAs
} RESP_CREATE_DIRECTORY2;
typedef RESP_CREATE_DIRECTORY2 SMB_UNALIGNED *PRESP_CREATE_DIRECTORY2;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_SEARCH

//
// FindFirst2 function code of Transaction2 SMB, see #3 page 22
// Function is SrvSmbFindFirst2()
// TRANS2_FIND_FIRST2 0x01
//

typedef struct _REQ_FIND_FIRST2 {
    _USHORT( SearchAttributes );
    _USHORT( SearchCount );             // Maximum number of entries to return
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - close search after this request
                                        //  1 - close search if end reached
                                        //  2 - return resume keys
    _USHORT( InformationLevel );
    _ULONG(SearchStorageType);
    UCHAR Buffer[1];                    // File name
} REQ_FIND_FIRST2;
typedef REQ_FIND_FIRST2 SMB_UNALIGNED *PREQ_FIND_FIRST2;

// Data bytes for Find First2 request are a list of extended attributes
// to retrieve (a GEAList), if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_FIND_FIRST2 {
    _USHORT( Sid );                     // Search handle
    _USHORT( SearchCount );             // Number of entries returned
    _USHORT( EndOfSearch );             // Was last entry returned?
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _USHORT( LastNameOffset );          // Offset into data to file name of
                                        //  last entry, if server needs it
                                        //  to resume search; else 0
} RESP_FIND_FIRST2;
typedef RESP_FIND_FIRST2 SMB_UNALIGNED *PRESP_FIND_FIRST2;

// Data bytes for Find First2 response are level-dependent information
// about the matching files.  If bit 2 in the request parameters was
// set, each entry is preceded by a four-byte resume key.

//
// FindNext2 function code of Transaction2 SMB, see #3 page 26
// Function is SrvSmbFindNext2()
// TRANS2_FIND_NEXT2 0x02
//

typedef struct _REQ_FIND_NEXT2 {
    _USHORT( Sid );                     // Search handle
    _USHORT( SearchCount );             // Maximum number of entries to return
    _USHORT( InformationLevel );
    _ULONG( ResumeKey );                // Value returned by previous find
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - close search after this request
                                        //  1 - close search if end reached
                                        //  2 - return resume keys
                                        //  3 - resume/continue, NOT rewind
    UCHAR Buffer[1];                    // Resume file name
} REQ_FIND_NEXT2;
typedef REQ_FIND_NEXT2 SMB_UNALIGNED *PREQ_FIND_NEXT2;

// Data bytes for Find Next2 request are a list of extended attributes
// to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_FIND_NEXT2 {
    _USHORT( SearchCount );             // Number of entries returned
    _USHORT( EndOfSearch );             // Was last entry returned?
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _USHORT( LastNameOffset );          // Offset into data to file name of
                                        //  last entry, if server needs it
                                        //  to resume search; else 0
} RESP_FIND_NEXT2;
typedef RESP_FIND_NEXT2 SMB_UNALIGNED *PRESP_FIND_NEXT2;

// Data bytes for Find Next2 response are level-dependent information
// about the matching files.  If bit 2 in the request parameters was
// set, each entry is preceded by a four-byte resume key.

//
// Flags for REQ_FIND_FIRST2.Flags
//

#define SMB_FIND_CLOSE_AFTER_REQUEST    0x01
#define SMB_FIND_CLOSE_AT_EOS           0x02
#define SMB_FIND_RETURN_RESUME_KEYS     0x04
#define SMB_FIND_CONTINUE_FROM_LAST     0x08
#define SMB_FIND_WITH_BACKUP_INTENT     0x10

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open2 function code of Transaction2 SMB, see #3 page 19
// Function is SrvSmbOpen2()
// TRANS2_OPEN2 0x00
//
// *** Note that the REQ_OPEN2 and RESP_OPEN2 structures closely
//     resemble the REQ_OPEN_ANDX and RESP_OPEN_ANDX structures.
//

typedef struct _REQ_OPEN2 {
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - return additional info
                                        //  1 - set single user total file lock
                                        //  2 - server notifies consumer of
                                        //      actions which may change file
                                        //  3 - return total length of EAs
    _USHORT( DesiredAccess );           // File open mode
    _USHORT( SearchAttributes );        // *** ignored
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( OpenFunction );
    _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
    _USHORT( Reserved )[5];             // Pad through OpenAndX's Timeout,
                                        //  Reserved, and ByteCount
    UCHAR Buffer[1];                    // File name
} REQ_OPEN2;
typedef REQ_OPEN2 SMB_UNALIGNED *PREQ_OPEN2;

// Data bytes for Open2 request are the extended attributes for the
// created file.

typedef struct _RESP_OPEN2 {
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _ULONG( EaLength );                 // Total EA length for opened file
} RESP_OPEN2;
typedef RESP_OPEN2 SMB_UNALIGNED *PRESP_OPEN2;

// The Open2 response has no data bytes.


#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_MISC

//
// QueryFsInformation function code of Transaction2 SMB, see #3 page 30
// Function is SrvSmbQueryFsInformation()
// TRANS2_QUERY_FS_INFORMATION 0x03
//

typedef struct _REQ_QUERY_FS_INFORMATION {
    _USHORT( InformationLevel );
} REQ_QUERY_FS_INFORMATION;
typedef REQ_QUERY_FS_INFORMATION SMB_UNALIGNED *PREQ_QUERY_FS_INFORMATION;

// No data bytes for Query FS Information request.

//typedef struct _RESP_QUERY_FS_INFORMATION {
//} RESP_QUERY_FS_INFORMATION;
//typedef RESP_QUERY_FS_INFORMATION SMB_UNALIGNED *PRESP_QUERY_FS_INFORMATION;

// Data bytes for Query FS Information response are level-dependent
// information about the specified volume.

//
// SetFSInformation function code of Transaction2 SMB, see #3 page 31
// Function is SrvSmbSetFSInformation()
// TRANS2_SET_PATH_INFORMATION 0x04
//

typedef struct _REQ_SET_FS_INFORMATION {
    _USHORT( Fid );
    _USHORT( InformationLevel );
} REQ_SET_FS_INFORMATION;
typedef REQ_SET_FS_INFORMATION SMB_UNALIGNED *PREQ_SET_FS_INFORMATION;

// Data bytes for Set FS Information request are level-dependant
// information about the specified volume.

//typedef struct _RESP_SET_FS_INFORMATION {
//} RESP_SET_FS_INFORMATION;
//typedef RESP_SET_FS_INFORMATION SMB_UNALIGNED *PRESP_SET_FS_INFORMATION;

// The Set FS Information response has no data bytes.

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_QUERY_SET

//
// QueryPathInformation function code of Transaction2 SMB, see #3 page 33
// Function is SrvSmbQueryPathInformation()
// TRANS2_QUERY_PATH_INFORMATION 0x05
//

typedef struct _REQ_QUERY_PATH_INFORMATION {
    _USHORT( InformationLevel );
    _ULONG( Reserved );                 // Must be zero
    UCHAR Buffer[1];                    // File name
} REQ_QUERY_PATH_INFORMATION;
typedef REQ_QUERY_PATH_INFORMATION SMB_UNALIGNED *PREQ_QUERY_PATH_INFORMATION;

// Data bytes for Query Path Information request are a list of extended
// attributes to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_QUERY_PATH_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_QUERY_PATH_INFORMATION;
typedef RESP_QUERY_PATH_INFORMATION SMB_UNALIGNED *PRESP_QUERY_PATH_INFORMATION;

// Data bytes for Query Path Information response are level-dependent
// information about the specified path/file.

//
// SetPathInformation function code of Transaction2 SMB, see #3 page 35
// Function is SrvSmbSetPathInformation()
// TRANS2_SET_PATH_INFORMATION 0x06
//

typedef struct _REQ_SET_PATH_INFORMATION {
    _USHORT( InformationLevel );
    _ULONG( Reserved );                 // Must be zero
    UCHAR Buffer[1];                    // File name
} REQ_SET_PATH_INFORMATION;
typedef REQ_SET_PATH_INFORMATION SMB_UNALIGNED *PREQ_SET_PATH_INFORMATION;

// Data bytes for Set Path Information request are either file information
// and attributes or a list of extended attributes for the file.

typedef struct _RESP_SET_PATH_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_SET_PATH_INFORMATION;
typedef RESP_SET_PATH_INFORMATION SMB_UNALIGNED *PRESP_SET_PATH_INFORMATION;

// The Set Path Information response has no data bytes.

//
// QueryFileInformation function code of Transaction2 SMB, see #3 page 37
// Function is SrvSmbQueryFileInformation()
// TRANS2_QUERY_FILE_INFORMATION 0x07
//

typedef struct _REQ_QUERY_FILE_INFORMATION {
    _USHORT( Fid );                     // File handle
    _USHORT( InformationLevel );
} REQ_QUERY_FILE_INFORMATION;
typedef REQ_QUERY_FILE_INFORMATION SMB_UNALIGNED *PREQ_QUERY_FILE_INFORMATION;

// Data bytes for Query File Information request are a list of extended
// attributes to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_QUERY_FILE_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_QUERY_FILE_INFORMATION;
typedef RESP_QUERY_FILE_INFORMATION SMB_UNALIGNED *PRESP_QUERY_FILE_INFORMATION;

// Data bytes for Query File Information response are level-dependent
// information about the specified path/file.

//
// SetFileInformation function code of Transaction2 SMB, see #3 page 39
// Function is SrvSmbSetFileInformation()
// TRANS2_SET_FILE_INFORMATION 0x08
//

typedef struct _REQ_SET_FILE_INFORMATION {
    _USHORT( Fid );                     // File handle
    _USHORT( InformationLevel );
    _USHORT( Flags );                   // File I/O control flags: bit set-
                                        //  4 - write through
                                        //  5 - no cache
} REQ_SET_FILE_INFORMATION;
typedef REQ_SET_FILE_INFORMATION SMB_UNALIGNED *PREQ_SET_FILE_INFORMATION;

// Data bytes for Set File Information request are either file information
// and attributes or a list of extended attributes for the file.

typedef struct _RESP_SET_FILE_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_SET_FILE_INFORMATION;
typedef RESP_SET_FILE_INFORMATION SMB_UNALIGNED *PRESP_SET_FILE_INFORMATION;

// The Set File Information response has no data bytes.

#endif // def INCLUDE_SMB_QUERY_SET

//
//  Opcodes for Mailslot transactions.  Not all filled in at present.
//    WARNING ... the info here on mailslots (opcode and smb struct)
//                is duplicated in net/h/mslotsmb.h
//

#define MS_WRITE_OPCODE 1

typedef struct _SMB_TRANSACT_MAILSLOT {
    UCHAR WordCount;                    // Count of data bytes; value = 17
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - unused
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved1 );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    UCHAR SetupWordCount;               // = 3
    UCHAR Reserved2;                    // Reserved (pad above to word)
    _USHORT( Opcode );                  // 1 -- Write Mailslot
    _USHORT( Priority );                // Priority of transaction
    _USHORT( Class );                   // Class: 1 = reliable, 2 = unreliable
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR MailslotName[];             //  "\MAILSLOT\<name>0"
    //UCHAR Pad[]                       //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data to write to mailslot
} SMB_TRANSACT_MAILSLOT;
typedef SMB_TRANSACT_MAILSLOT SMB_UNALIGNED *PSMB_TRANSACT_MAILSLOT;

typedef struct _SMB_TRANSACT_NAMED_PIPE {
    UCHAR WordCount;                    // Count of data bytes; value = 16
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - also disconnect TID in Tid
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved1 );
    _USHORT( ParameterCount );
                                        // Buffer containing:
    //UCHAR PipeName[];                 //  "\PIPE\<name>0"
    //UCHAR Pad[]                       //  Pad to SHORT or LONG
    //UCHAR Param[];                    //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[]                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} SMB_TRANSACT_NAMED_PIPE;
typedef SMB_TRANSACT_NAMED_PIPE SMB_UNALIGNED *PSMB_TRANSACT_NAMED_PIPE;


//
// Transaction - QueryInformationNamedPipe, Level 1, output data format
//

typedef struct _NAMED_PIPE_INFORMATION_1 {
    _USHORT( OutputBufferSize );
    _USHORT( InputBufferSize );
    UCHAR MaximumInstances;
    UCHAR CurrentInstances;
    UCHAR PipeNameLength;
    UCHAR PipeName[1];
} NAMED_PIPE_INFORMATION_1;
typedef NAMED_PIPE_INFORMATION_1 SMB_UNALIGNED *PNAMED_PIPE_INFORMATION_1;

//
// Transaction - PeekNamedPipe, output format
//

typedef struct _RESP_PEEK_NMPIPE {
    _USHORT( ReadDataAvailable );
    _USHORT( MessageLength );
    _USHORT( NamedPipeState );
    //UCHAR Pad[];
    //UCHAR Data[];
} RESP_PEEK_NMPIPE;
typedef RESP_PEEK_NMPIPE SMB_UNALIGNED *PRESP_PEEK_NMPIPE;

//
// Define SMB pipe handle state bits used by Query/SetNamedPipeHandleState
//
// These number are the bit location of the fields in the handle state.
//

#define PIPE_COMPLETION_MODE_BITS   15
#define PIPE_PIPE_END_BITS          14
#define PIPE_PIPE_TYPE_BITS         10
#define PIPE_READ_MODE_BITS          8
#define PIPE_MAXIMUM_INSTANCES_BITS  0

/* DosPeekNmPipe() pipe states */

#define PIPE_STATE_DISCONNECTED 0x0001
#define PIPE_STATE_LISTENING    0x0002
#define PIPE_STATE_CONNECTED    0x0003
#define PIPE_STATE_CLOSING      0x0004

/* DosCreateNPipe and DosQueryNPHState state */

#define SMB_PIPE_READMODE_BYTE        0x0000
#define SMB_PIPE_READMODE_MESSAGE     0x0100
#define SMB_PIPE_TYPE_BYTE            0x0000
#define SMB_PIPE_TYPE_MESSAGE         0x0400
#define SMB_PIPE_END_CLIENT           0x0000
#define SMB_PIPE_END_SERVER           0x4000
#define SMB_PIPE_WAIT                 0x0000
#define SMB_PIPE_NOWAIT               0x8000
#define SMB_PIPE_UNLIMITED_INSTANCES  0x00FF


//
// Pipe name string for conversion between SMB and NT formats.
//

#define SMB_PIPE_PREFIX  "\\PIPE"
#define UNICODE_SMB_PIPE_PREFIX L"\\PIPE"
#define CANONICAL_PIPE_PREFIX "PIPE\\"
#define NT_PIPE_PREFIX   L"\\Device\\NamedPipe"

#define SMB_PIPE_PREFIX_LENGTH  (sizeof(SMB_PIPE_PREFIX) - 1)
#define UNICODE_SMB_PIPE_PREFIX_LENGTH \
                    (sizeof(UNICODE_SMB_PIPE_PREFIX) - sizeof(WCHAR))
#define CANONICAL_PIPE_PREFIX_LENGTH (sizeof(CANONICAL_PIPE_PREFIX) - 1)
#define NT_PIPE_PREFIX_LENGTH   (sizeof(NT_PIPE_PREFIX) - sizeof(WCHAR))

//
// Mailslot name strings.
//

#define SMB_MAILSLOT_PREFIX "\\MAILSLOT"
#define UNICODE_SMB_MAILSLOT_PREFIX L"\\MAILSLOT"

#define SMB_MAILSLOT_PREFIX_LENGTH (sizeof(SMB_MAILSLOT_PREFIX) - 1)
#define UNICODE_SMB_MAILSLOT_PREFIX_LENGTH \
                    (sizeof(UNICODE_SMB_MAILSLOT_PREFIX) - sizeof(WCHAR))

//
// NT Transaction subfunctions
//

#ifdef INCLUDE_SMB_OPEN_CLOSE

typedef struct _REQ_CREATE_WITH_SD_OR_EA {
    _ULONG( Flags );                   // Creation flags  NT_CREATE_xxx
    _ULONG( RootDirectoryFid );        // Optional directory for relative open
    ACCESS_MASK DesiredAccess;         // Desired access (NT format)
    LARGE_INTEGER AllocationSize;      // The initial allocation size in bytes
    _ULONG( FileAttributes );          // The file attributes
    _ULONG( ShareAccess );             // The share access
    _ULONG( CreateDisposition );       // Action to take if file exists or not
    _ULONG( CreateOptions );           // Options for creating a new file
    _ULONG( SecurityDescriptorLength );// Length of SD in bytes
    _ULONG( EaLength );                // Length of EA in bytes
    _ULONG( NameLength );              // Length of name in characters
    _ULONG( ImpersonationLevel );      // Security QOS information
    UCHAR SecurityFlags;               // Security QOS information
    UCHAR Buffer[1];
    //UCHAR Name[];                     // The name of the file (not NUL terminated)
} REQ_CREATE_WITH_SD_OR_EA;
typedef REQ_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PREQ_CREATE_WITH_SD_OR_EA;

//
// Data format:
//   UCHAR SecurityDesciptor[];
//   UCHAR Pad1[];        // Pad to LONG
//   UCHAR EaList[];
//

typedef struct _RESP_CREATE_WITH_SD_OR_EA {
    UCHAR OplockLevel;                  // The oplock level granted
    union {
        UCHAR Reserved;
        UCHAR ExtendedResponse;         // set to zero for standard response
    };
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    _ULONG( EaErrorOffset );            // Offset of the EA error
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    BOOLEAN Directory;                  // TRUE if this is a directory
} RESP_CREATE_WITH_SD_OR_EA;
typedef RESP_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PRESP_CREATE_WITH_SD_OR_EA;

// No data bytes for the response

typedef struct _RESP_EXTENDED_CREATE_WITH_SD_OR_EA {
    UCHAR OplockLevel;                  // The oplock level granted
    UCHAR ExtendedResponse;             // set to 1 for Extended response
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    _ULONG( EaErrorOffset );            // Offset of the EA error
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    BOOLEAN Directory;                  // TRUE if this is a directory
    UCHAR   VolumeGuid[16];             // the volume GUID
    UCHAR   FileId[8];                  // the file id
    _ULONG  ( MaximalAccessRights );        // the access rights for the session owner
    _ULONG  ( GuestMaximalAccessRights );   // the maximal access rights for guest
} RESP_EXTENDED_CREATE_WITH_SD_OR_EA;
typedef RESP_EXTENDED_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PRESP_EXTENDED_CREATE_WITH_SD_OR_EA;

#ifdef INCLUDE_SMB_IFMODIFIED

typedef struct _RESP_EXTENDED_CREATE_WITH_SD_OR_EA2 {
    UCHAR OplockLevel;                  // The oplock level granted
    UCHAR ExtendedResponse;             // set to 1 for Extended response
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    _ULONG( EaErrorOffset );            // Offset of the EA error
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    BOOLEAN Directory;                  // TRUE if this is a directory
    UCHAR   VolumeGuid[16];             // the volume GUID
    UCHAR   FileId[8];                  // the file id
    _ULONG  ( MaximalAccessRights );        // the access rights for the session owner
    _ULONG  ( GuestMaximalAccessRights );   // the maximal access rights for guest

    // below here is where it differs from RESP_EXTENDED_CREATE_WITH_SD_OR_EA

    LARGE_INTEGER UsnValue;             // The file's USN # in NTFS
    LARGE_INTEGER FileReferenceNumber;  //
    WCHAR ShortName[13];                // if not present, empty string.

    _USHORT( ByteCount );               // length of long name
    WCHAR Buffer[1];                    // long name goes here

} RESP_EXTENDED_CREATE_WITH_SD_OR_EA2;
typedef RESP_EXTENDED_CREATE_WITH_SD_OR_EA2 SMB_UNALIGNED *PRESP_EXTENDED_CREATE_WITH_SD_OR_EA2;

#endif  // def INCLUDE_SMB_IFMODIFIED

// No data bytes for the response


#endif //  INCLUDE_SMB_OPEN_CLOSE

//
// Setup words for NT I/O control request
//

typedef struct _REQ_NT_IO_CONTROL {
    _ULONG( FunctionCode );
    _USHORT( Fid );
    BOOLEAN IsFsctl;
    UCHAR   IsFlags;
} REQ_NT_IO_CONTROL;
typedef REQ_NT_IO_CONTROL SMB_UNALIGNED *PREQ_NT_IO_CONTROL;

//
// Request parameter bytes - The first buffer
// Request data bytes - The second buffer
//

//
// NT I/O Control response:
//
// Setup Words:  None.
// Parameter Bytes:  First buffer.
// Data Bytes: Second buffer.
//

//
// NT Notify directory change
//

// Request Setup Words

typedef struct _REQ_NOTIFY_CHANGE {
    _ULONG( CompletionFilter );              // Specifies operation to monitor
    _USHORT( Fid );                          // Fid of directory to monitor
    BOOLEAN WatchTree;                       // TRUE = watch all subdirectories too
    UCHAR Reserved;                          // MBZ
} REQ_NOTIFY_CHANGE;
typedef REQ_NOTIFY_CHANGE SMB_UNALIGNED *PREQ_NOTIFY_CHANGE;

//
// Request parameter bytes:  None
// Request data bytes:  None
//

//
// NT Notify directory change response
//
// Setup words:  None.
// Parameter bytes:  The change data buffer.
// Data bytes:  None.
//

//
// NT Set Security Descriptor request
//
// Setup words:  REQ_SET_SECURITY_DESCIPTOR.
// Parameter Bytes:  None.
// Data Bytes:  The Security Descriptor data.
//

typedef struct _REQ_SET_SECURITY_DESCRIPTOR {
    _USHORT( Fid );                    // FID of target
    _USHORT( Reserved );               // MBZ
    _ULONG( SecurityInformation );     // Fields of SD that to set
} REQ_SET_SECURITY_DESCRIPTOR;
typedef REQ_SET_SECURITY_DESCRIPTOR SMB_UNALIGNED *PREQ_SET_SECURITY_DESCRIPTOR;

//
// NT Set Security Desciptor response
//
// Setup words:  None.
// Parameter Bytes:  None.
// Data Bytes:  None.
//

//
// NT Query Security Descriptor request
//
// Setup words:  None.
// Parameter Bytes:  REQ_QUERY_SECURITY_DESCRIPTOR.
// Data Bytes:  None.
//

typedef struct _REQ_QUERY_SECURITY_DESCRIPTOR {
    _USHORT( Fid );                    // FID of target
    _USHORT( Reserved );               // MBZ
    _ULONG( SecurityInformation );     // Fields of SD that to query
} REQ_QUERY_SECURITY_DESCRIPTOR;
typedef REQ_QUERY_SECURITY_DESCRIPTOR SMB_UNALIGNED *PREQ_QUERY_SECURITY_DESCRIPTOR;

//
// NT Query Security Desciptor response
//
// Parameter bytes:  RESP_QUERY_SECURITY_DESCRIPTOR
// Data Bytes:  The Security Descriptor data.
//

typedef struct _RESP_QUERY_SECURITY_DESCRIPTOR {
    _ULONG( LengthNeeded );           // Size of data buffer required for SD
} RESP_QUERY_SECURITY_DESCRIPTOR;
typedef RESP_QUERY_SECURITY_DESCRIPTOR SMB_UNALIGNED *PRESP_QUERY_SECURITY_DESCRIPTOR;

//
// NT Rename file
//
// Setup words: None
// Parameters bytes:  REQ_NT_RENAME
// Data bytes: None
//

typedef struct _REQ_NT_RENAME {
    _USHORT( Fid );                    // FID of file to rename
    _USHORT( RenameFlags );            // defined below
    UCHAR NewName[];                   // New file name.
} REQ_NT_RENAME;
typedef REQ_NT_RENAME SMB_UNALIGNED *PREQ_NT_RENAME;

//
// Rename flags defined
//

#define SMB_RENAME_REPLACE_IF_EXISTS   1

//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING


#endif // ndef _SMBTRANS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\srvann.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    srvann.h

Abstract:

    Contains function prototypes for internal server announcement interfaces
    between services and the service controller.

Author:

    Dan Lafferty (danl)     31-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    31-Mar-1991     danl
        created
    15-Aug-1995     anirudhs
        Added I_ScGetCurrentGroupStateW.

--*/

#ifndef _SRVANN_INCLUDED
#define _SRVANN_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

//
// This entrypoint is exported by the service controller.  It is to be
// called by any service wishing to set up announcement bits.
//
// The service controller will then pass the information on to the
// server service when appropriate.
//
BOOL
I_ScSetServiceBitsW(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately,
    IN LPWSTR                   pszReserved
    );

BOOL
I_ScSetServiceBitsA (
    IN  SERVICE_STATUS_HANDLE hServiceStatus,
    IN  DWORD                 dwServiceBits,
    IN  BOOL                  bSetBitsOn,
    IN  BOOL                  bUpdateImmediately,
    IN  LPSTR                 pszReserved
    );

#ifdef UNICODE
#define I_ScSetServiceBits I_ScSetServiceBitsW
#else
#define I_ScSetServiceBits I_ScSetServiceBitsA
#endif


//
// These entrypoints are exported by the server service.  They are called
// by the service controller only.
//
NET_API_STATUS
I_NetServerSetServiceBits (
    IN  LPTSTR  servername,
    IN  LPTSTR  transport OPTIONAL,
    IN  DWORD   servicebits,
    IN  DWORD   updateimmediately
    );

NET_API_STATUS
I_NetServerSetServiceBitsEx (
    IN  LPWSTR  ServerName,
    IN  LPWSTR  EmulatedServerName OPTIONAL,
    IN  LPTSTR  TransportName      OPTIONAL,
    IN  DWORD   ServiceBitsOfInterest,
    IN  DWORD   ServiceBits,
    IN  DWORD   UpdateImmediately
    );


#ifdef __cplusplus
}       // extern "C"
#endif

#endif  // _SRVANN_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sxsapi_guids.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sxsapi_guids.h

Abstract:

    guids broken out of sxsapi.h

Author:

    Jay Krell (JayKrell) November 30, 2001

Environment:


Revision History:

--*/

#ifndef _SXSAPI_GUIDS_
#define _SXSAPI_GUIDS_

// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
DEFINE_GUID(
    SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY, 
    0x8cedc215, 
    0xac4b, 
    0x488b, 
    0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
DEFINE_GUID(
    SXS_INSTALL_REFERENCE_SCHEME_KEYFILE, 
    0xb02f9d65, 
    0xfb77, 
    0x4f7a, 
    0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
DEFINE_GUID(
    SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING, 
    0x2ec93463, 
    0xb0c3, 
    0x45e1, 
    0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);

// d16d444c-56d8-11d5-882d-0080c847b195
DEFINE_GUID(
    SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL,
    0xd16d444c,
    0x56d8,
    0x11d5,
    0x88, 0x2d, 0x00, 0x80, 0xc8, 0x47, 0xb1, 0x95);

//
// Guid for the "installed by sxsinstallassemblyw, who knows?"
// 27dec61e-b43c-4ac8-88db-e209a8242d90
//
DEFINE_GUID(
    SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY,
    0x27dec61e,
    0xb43c,
    0x4ac8,
    0x88, 0xdb, 0xe2, 0x09, 0xa8, 0x24, 0x2d, 0x90);

#endif /* _SXSAPI_GUIDS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sxsapi.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sxsapi.h

Abstract:

    Include file with definitions for calling into the sxs.dll private APIs

Author:

    Michael Grier (MGrier) 4-May-2000

Environment:


Revision History:

    Jay Krell (JayKrell) November 30, 2001
        seperated guids out into sxsapi_guids.h

--*/

#ifndef _SXSAPI_
#define _SXSAPI_

#if (_MSC_VER > 1020)
#pragma once
#endif

//
// bring in IStream / ISequentialStream
//
#if !defined(COM_NO_WINDOWS_H)
#define COM_NO_WINDOWS_H COM_NO_WINDOWS_H
#endif
#pragma push_macro("COM_NO_WINDOWS_H")
#undef COM_NO_WINDOWS_H
#include "objidl.h"
#pragma pop_macro("COM_NO_WINDOWS_H")

// from setupapi.h
typedef PVOID HSPFILEQ;

#include <sxstypes.h>
#include <sxs.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SXS_DLL_NAME_A      ( "sxs.dll")
#define SXS_DLL_NAME_W      (L"sxs.dll")
#define SXS_DLL_NAME   (TEXT( "sxs.dll"))

typedef struct _SXS_XML_DOCUMENT *PSXS_XML_DOCUMENT;
typedef const struct _SXS_XML_DOCUMENT *PCSXS_XML_DOCUMENT;

typedef struct _SXS_XML_STRING *PSXS_XML_STRING;
typedef const struct _SXS_XML_STRING *PCSXS_XML_STRING;

typedef struct _SXS_XML_LOCATION *PSXS_XML_LOCATION;
typedef const struct _SXS_XML_LOCATION *PCSXS_XML_LOCATION;

typedef struct _SXS_XML_NODE *PSXS_XML_NODE;
typedef const struct _SXS_XML_NODE *PCSXS_XML_NODE;

typedef struct _SXS_XML_ATTRIBUTE *PSXS_XML_ATTRIBUTE;
typedef const struct _SXS_XML_ATTRIBUTE *PCSXS_XML_ATTRIBUTE;

typedef struct _SXS_XML_DOCUMENT {
    ULONG Flags;
    ULONG StringCount;
    PCSXS_XML_STRING Strings;   // Note that index 0 is reserved to mean "no string" or "no value"
    LIST_ENTRY ElementListHead; // conceptually just one element, but PIs also appear in this list
} SXS_XML_DOCUMENT;

// Most will not be null terminated; if they happen to be this flag will be set; this can be used
// to avoid a string copy if you really need them to be null terminated.
#define SXS_XML_STRING_FLAG_NULL_TERMINATED (0x00000001)
#define SXS_XML_STRING_FLAG_INVALID (0x00000002)

typedef struct _SXS_XML_STRING {
    ULONG Flags;
    ULONG PseudoKey;
    ULONG Length; // in bytes
    const WCHAR *Buffer; // pointer to first character of non-null-terminated string
} SXS_XML_STRING;

typedef struct _SXS_XML_LOCATION {
    ULONG Flags;
    ULONG SourceString; // source file name
    ULONG BeginningLine;
    ULONG BeginningColumn;
    ULONG EndingLine;
    ULONG EndingColumn;
} SXS_XML_LOCATION;

#define SXS_XML_NODE_TYPE_INVALID   (0)
#define SXS_XML_NODE_TYPE_XML_DECL  (1)
#define SXS_XML_NODE_TYPE_PI        (2)
#define SXS_XML_NODE_TYPE_ELEMENT   (3)
#define SXS_XML_NODE_TYPE_PCDATA    (4)
#define SXS_XML_NODE_TYPE_CDATA     (5)

typedef struct _SXS_XML_NODE_XML_DECL_DATA {
    ULONG AttributeCount;
    PCSXS_XML_ATTRIBUTE Attributes;
} SXS_XML_NODE_XML_DECL_DATA;

typedef struct _SXS_XML_NODE_ELEMENT_DATA {
    ULONG NamespaceString;
    ULONG NameString;
    ULONG AttributeCount;
    PCSXS_XML_ATTRIBUTE Attributes;
    LIST_ENTRY ChildListHead;
} SXS_XML_NODE_ELEMENT_DATA;

typedef struct _SXS_XML_NODE {
    LIST_ENTRY SiblingLink;
    ULONG Flags;
    ULONG Type;
    PCSXS_XML_NODE Parent;
    union {
        SXS_XML_NODE_XML_DECL_DATA XMLDecl;
        ULONG PIString;
        SXS_XML_NODE_ELEMENT_DATA Element;
        ULONG PCDataString;
        ULONG CDataString;
    };
} SXS_XML_NODE;

#define SXS_XML_ATTRIBUTE_FLAG_NAMESPACE_ATTRIBUTE (0x00000001)

typedef struct _SXS_XML_ATTRIBUTE {
    ULONG Flags;
    ULONG NamespaceString;
    ULONG NameString;
    ULONG ValueString;
} SXS_XML_ATTRIBUTE;

//
//  structs for walking/locating things in the XML parse tree
//

typedef struct _SXS_XML_NAMED_REFERENCE *PSXS_XML_NAMED_REFERENCE;
typedef const struct _SXS_XML_NAMED_REFERENCE *PCSXS_XML_NAMED_REFERENCE;

typedef struct _SXS_XML_NODE_PATH *PSXS_XML_NODE_PATH;
typedef const struct _SXS_XML_NODE_PATH *PCSXS_XML_NODE_PATH;

typedef struct _SXS_XML_NAMED_REFERENCE {
    PCWSTR Namespace;
    ULONG NamespaceLength; // in bytes
    PCWSTR Name;
    ULONG NameLength; // in bytes
} SXS_XML_NAMED_REFERENCE;

typedef struct _SXS_XML_NODE_PATH {
    ULONG ElementCount;
    const PCSXS_XML_NAMED_REFERENCE *Elements;
} SXS_XML_NODE_PATH;

typedef VOID (WINAPI * PSXS_ENUM_XML_NODES_CALLBACK)(
    IN PVOID Context,
    IN PCSXS_XML_NODE Element,
    OUT BOOL *ContinueEnumeration
    );

BOOL
WINAPI
SxsEnumXmlNodes(
    IN ULONG Flags,
    IN PCSXS_XML_DOCUMENT Document,
    IN PCSXS_XML_NODE_PATH PathToMatch,
    IN PSXS_ENUM_XML_NODES_CALLBACK Callback,
    IN PVOID Context
    );

#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_COPIED (1)
#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED (2)
#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY (3)
#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_MOVE (4)

typedef struct _SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS {
    IN DWORD            cbSize;
    IN PVOID            pvContext;
    IN DWORD            dwFileFlags;
    IN PVOID            pAlternateSource;
    IN PCWSTR           pSourceFile;
    IN PCWSTR           pDestinationFile;
    IN ULONGLONG        nFileSize;
    OUT INT             nDisposition;
} SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS, *PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS;

typedef BOOL (WINAPI * PSXS_INSTALLATION_FILE_COPY_CALLBACK)(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS pParameters
    );

//
//  If SxsBeginAssemblyInstall() is called with SXS_INSTALL_ASSEMBLY_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE as the
//  InstallationCallback parameter, the InstallationContext parameter is assumed to be an
//  HSPFILEQ copy queue handle.  If SXS_INSTALL_ASSEMBLY_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE_EX,
//  the InstallationContext must point to a SXS_INSTALL_ASSEMBLY_SETUP_COPY_QUEUE_EX_PARAMETERS.
//
//  This provides an easy mechanism for someone maintaining a copy queue to interact with assembly installation.
//

#define SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE    ((PSXS_INSTALLATION_FILE_COPY_CALLBACK) 1)
#define SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE_EX ((PSXS_INSTALLATION_FILE_COPY_CALLBACK) 2)

//
// Parameters to Setupapi.dll::SetupQueueCopy
//
typedef struct _SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS {
    DWORD       cbSize;
    HSPFILEQ    hSetupCopyQueue; // SetupOpenFileQueue
    PCWSTR      pszSourceDescription;
    DWORD       dwCopyStyle;
} SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS, *PSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS;
typedef const SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS* PCSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS;

typedef BOOL (WINAPI * PSXS_IMPERSONATION_CALLBACK)(
    IN PVOID Context,
    IN BOOL Impersonate
    );

#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_MOVE                        (0x00000001)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_RESOURCE               (0x00000002)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY              (0x00000004)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE    (0x00000008)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL           (0x00000010)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY                   (0x00000020)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING            (0x00000040)

typedef BOOL (WINAPI * PSXS_BEGIN_ASSEMBLY_INSTALL)(
    IN DWORD Flags,
    IN PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback OPTIONAL,
    IN PVOID InstallationContext OPTIONAL,
    IN PSXS_IMPERSONATION_CALLBACK ImpersonationCallback OPTIONAL,
    IN PVOID ImpersonationContext OPTIONAL,
    OUT PVOID *InstallCookie
    );

#define SXS_BEGIN_ASSEMBLY_INSTALL ("SxsBeginAssemblyInstall")

BOOL
WINAPI
SxsBeginAssemblyInstall(
    IN DWORD Flags,
    IN PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback OPTIONAL,
    IN PVOID InstallationContext OPTIONAL,
    IN PSXS_IMPERSONATION_CALLBACK ImpersonationCallback OPTIONAL,
    IN PVOID ImpersonationContext OPTIONAL,
    OUT PVOID *InstallCookie
    );

#include <initguid.h>
#include "sxsapi_guids.h"

typedef struct tagSXS_INSTALL_REFERENCEW
{
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    PCWSTR lpIdentifier;
    PCWSTR lpNonCanonicalData;
} SXS_INSTALL_REFERENCEW, *PSXS_INSTALL_REFERENCEW;

typedef const struct tagSXS_INSTALL_REFERENCEW *PCSXS_INSTALL_REFERENCEW;

typedef struct tagSXS_INSTALLW
{
    DWORD cbSize;
    DWORD dwFlags;
    PCWSTR lpManifestPath;
    PVOID pvInstallCookie;
    PCWSTR lpCodebaseURL;
    PCWSTR lpRefreshPrompt;
    PCWSTR lpLogFileName;
    PCSXS_INSTALL_REFERENCEW lpReference;
} SXS_INSTALLW, *PSXS_INSTALLW;

typedef const struct tagSXS_INSTALLW *PCSXS_INSTALLW;

//
//  These flags are distinct from the begin install flags, but
//  we're assigning them unique numbers so that flag-reuse errors can
//  be caught more easily.
//

#define SXS_INSTALL_FLAG_CODEBASE_URL_VALID         (0x00000100)
#define SXS_INSTALL_FLAG_MOVE                       (0x00000200)
#define SXS_INSTALL_FLAG_FROM_RESOURCE              (0x00000400)
#define SXS_INSTALL_FLAG_FROM_DIRECTORY             (0x00000800)
#define SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE   (0x00001000)
#define SXS_INSTALL_FLAG_NOT_TRANSACTIONAL          (0x00002000)
#define SXS_INSTALL_FLAG_NO_VERIFY                  (0x00004000)
#define SXS_INSTALL_FLAG_REPLACE_EXISTING           (0x00008000)
#define SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID        (0x00010000)
#define SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN        (0x00020000)
#define SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP       (0x00040000)
#define SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID       (0x00080000)
#define SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID       (0x00100000)
#define SXS_INSTALL_FLAG_REFERENCE_VALID            (0x00200000)
#define SXS_INSTALL_FLAG_REFRESH                    (0x00400000)

typedef BOOL (WINAPI * PSXS_INSTALL_W)(
    IN OUT PSXS_INSTALLW lpInstall
    );
typedef PSXS_INSTALL_W PSXS_INSTALL_W_ROUTINE;

BOOL
WINAPI
SxsInstallW(
    IN OUT PSXS_INSTALLW lpInstall
    );

#define SXS_INSTALL_W                               ("SxsInstallW")

//
//  These flags are distinct from the begin assembly install flags, but
//  we're assigning them unique numbers so that flag-reuse errors can
//  be caught more easily.
//

#define SXS_INSTALL_ASSEMBLY_FLAG_CODEBASE_URL_VALID        (0x00000100)
#define SXS_INSTALL_ASSEMBLY_FLAG_MOVE                      (0x00000200)
#define SXS_INSTALL_ASSEMBLY_FLAG_FROM_RESOURCE             (0x00000400)
#define SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY            (0x00000800)
#define SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE  (0x00001000)
#define SXS_INSTALL_ASSEMBLY_FLAG_NOT_TRANSACTIONAL         (0x00002000)
#define SXS_INSTALL_ASSEMBLY_FLAG_NO_VERIFY                 (0x00004000)
#define SXS_INSTALL_ASSEMBLY_FLAG_REPLACE_EXISTING          (0x00008000)
#define SXS_INSTALL_ASSEMBLY_FLAG_LOG_FILE_NAME_VALID       (0x00010000)
#define SXS_INSTALL_ASSEMBLY_FLAG_INSTALLED_BY_DARWIN	    (0x00020000)
#define SXS_INSTALL_ASSEMBLY_FLAG_INSTALLED_BY_OSSETUP      (0x00040000)
#define SXS_INSTALL_ASSEMBLY_FLAG_INSTALL_COOKIE_VALID      (0x00080000)
#define SXS_INSTALL_ASSEMBLY_FLAG_REFRESH_PROMPT_VALID      (0x00100000)


#define SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE SXS_INSTALL_ASSEMBLY_FLAG_CODEBASE_URL_VALID
#define SXS_INSTALL_ASSEMBLY_FLAG_CREATE_LOGFILE SXS_INSTALL_ASSEMBLY_FLAG_LOG_FILE_NAME_VALID

typedef BOOL (WINAPI * PSXS_INSTALL_ASSEMBLY_W)(
    IN PVOID InstallCookie OPTIONAL,
    IN DWORD Flags,
    IN PCWSTR ManifestPath,
    IN OUT PVOID Reserved OPTIONAL
    );

#define SXS_INSTALL_ASSEMBLY_W ("SxsInstallAssemblyW")

BOOL
WINAPI
SxsInstallAssemblyW(
    IN PVOID InstallCookie OPTIONAL,
    IN DWORD Flags,
    IN PCWSTR ManifestPath,
    IN OUT PVOID Reserved OPTIONAL
    );

//
// If you've specified SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE, you must pass 
// a PSXS_INSTALL_SOURCE_INFO in the Reserved value of SxsInstallAssemblyW.
// This is the definition of that structure.
//
typedef struct _SXS_INSTALL_SOURCE_INFO {
    // Size of this structure.  Required.
    SIZE_T      cbSize;

    // Any combination of SXSINSTALLSOURCE_*
    DWORD       dwFlags;

    // Codebase to reinstall this assembly from.  Can be determined from the
    // manifest name that's being installed, but not preferrably.
    PCWSTR      pcwszCodebaseName;

    // What string (localized!) that should be presented to the user during
    // recovery to request the media that this assembly came from.
    PCWSTR      pcwszPromptOnRefresh;

    PCWSTR      pcwszLogFileName;
} SXS_INSTALL_SOURCE_INFO, *PSXS_INSTALL_SOURCE_INFO;

typedef const struct _SXS_INSTALL_SOURCE_INFO *PCSXS_INSTALL_SOURCE_INFO;

// The SXS_INSTALL_SOURCE_INFO structure has the pcwszCodebase member filled in.
#define SXSINSTALLSOURCE_HAS_CODEBASE       ( 0x00000001 )

// The SXS_INSTALL_SOURCE_INFO structure has the pcwszPromptOnRefresh member filled in.
#define SXSINSTALLSOURCE_HAS_PROMPT         ( 0x00000002 )

// The assembly has a catalog that must be present and copied over.  If missing, then the
// instaler will intuit whether it has a catalog or not.
#define SXSINSTALLSOURCE_HAS_CATALOG        ( 0x00000004 )

// This assembly is being installed as part of OS-setup, and so the codebase actually
// contains the source-relative path of the root directory of the assembly source
#define SXSINSTALLSOURCE_INSTALLING_SETUP   ( 0x00000008 )

// The installer should not attempt to autodetect whether or not there's a catalog
// associated with this assembly.
#define SXSINSTALLSOURCE_DONT_DETECT_CATALOG ( 0x0000010 )

#define SXSINSTALLSOURCE_CREATE_LOGFILE      ( 0x0000020 )
// for WFP recovery usage
#define SXSINSTALLSOURCE_INSTALL_BY_DARWIN   ( 0x0000040 )
#define SXSINSTALLSOURCE_INSTALL_BY_OSSETUP  ( 0x0000080 )


//
//  These flags are distinct from the begin assembly install flags, but
//  we're assigning them unique numbers so that flag-reuse errors can
//  be caught more easily.
//

#define SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT            (0x01000000)
#define SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT             (0x02000000)
#define SXS_END_ASSEMBLY_INSTALL_FLAG_NO_VERIFY         (0x04000000)
#define SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS        (0x08000000)

typedef BOOL (WINAPI * PSXS_END_ASSEMBLY_INSTALL)(
    IN PVOID InstallCookie,
    IN DWORD Flags,
    OUT DWORD *Reserved OPTIONAL
    );

#define SXS_END_ASSEMBLY_INSTALL ("SxsEndAssemblyInstall")

BOOL
WINAPI
SxsEndAssemblyInstall(
    IN PVOID InstallCookie,
    IN DWORD Flags,
    IN OUT PVOID Reserved OPTIONAL
    );

//
// Uninstallation of an assembly
//

typedef struct _tagSXS_UNINSTALLW {

    SIZE_T                      cbSize;
    DWORD                       dwFlags;
    LPCWSTR                     lpAssemblyIdentity;
    PCSXS_INSTALL_REFERENCEW    lpInstallReference;
    LPCWSTR                     lpInstallLogFile;
    
} SXS_UNINSTALLW, *PSXS_UNINSTALLW;

typedef const struct _tagSXS_UNINSTALLW *PCSXS_UNINSTALLW;

#define SXS_UNINSTALL_FLAG_REFERENCE_VALID          (0x00000001)
#define SXS_UNINSTALL_FLAG_FORCE_DELETE             (0x00000002)
#define SXS_UNINSTALL_FLAG_USE_INSTALL_LOG          (0x00000004)
#define SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED       (0x00000008)

//
// The reference to the assembly was removed
//
#define SXS_UNINSTALL_DISPOSITION_REMOVED_REFERENCE        (0x00000001)

//
// The actual assembly was removed because it ran out of references.
//
#define SXS_UNINSTALL_DISPOSITION_REMOVED_ASSEMBLY         (0x00000002)

typedef BOOL (WINAPI * PSXS_UNINSTALL_ASSEMBLYW)(
    IN  PCSXS_UNINSTALLW pcUnInstallData,
    OUT DWORD *pdwDisposition
    );
typedef PSXS_UNINSTALL_ASSEMBLYW PSXS_UNINSTALL_W_ROUTINE;

#define SXS_UNINSTALL_ASSEMBLYW ("SxsUninstallW")

BOOL
WINAPI
SxsUninstallW(
    IN  PCSXS_UNINSTALLW pcUnInstallData,
    OUT DWORD *pdwDisposition
    );

    

#define SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_NOT_INSTALLED   (0x00000001)
#define SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_INSTALLED       (0x00000002)
#define SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT        (0x00000004)

typedef BOOL (WINAPI * PSXS_PROBE_ASSEMBLY_INSTALLATION)(
    IN DWORD dwFlags,
    IN PCWSTR lpIdentity,
    OUT DWORD *plpDisposition
    );

#define SXS_PROBE_ASSEMBLY_INSTALLATION ("SxsProbeAssemblyInstallation")

BOOL
WINAPI
SxsProbeAssemblyInstallation(
    DWORD dwFlags,
    PCWSTR lpIdentity,
    PDWORD lpDisposition
    );

#define SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC  (1)

#define SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL   (0x00000001)

#define SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY   (0x00000001)
#define SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME  (0x00000002)

typedef struct _SXS_MANIFEST_INFORMATION_BASIC
{
    PCWSTR lpIdentity;
    PCWSTR lpShortName;
    ULONG ulFileCount;
} SXS_MANIFEST_INFORMATION_BASIC, *PSXS_MANIFEST_INFORMATION_BASIC;

#define SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID      (0x00000001)
#define SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID  (0x00000002)
#define SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID        (0x00000004)

typedef struct _SXS_MANIFEST_INFORMATION_SOURCE_DLL
{
    DWORD dwSize;
    DWORD dwFlags;
    PCWSTR pcwszDllPath;
    PCWSTR pcwszResourceType;
    PCWSTR pcwszResourceName;
    INT Language;
} SXS_MANIFEST_INFORMATION_SOURCE_DLL, *PSXS_MANIFEST_INFORMATION_SOURCE_DLL;
typedef const struct _SXS_MANIFEST_INFORMATION_SOURCE_DLL *PCSXS_MANIFEST_INFORMATION_SOURCE_DLL;


typedef BOOL (WINAPI * PSXS_QUERY_MANIFEST_INFORMATION)(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN ULONG ulInfoClass,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T cbWrittenOrRequired OPTIONAL
    );

BOOL
WINAPI
SxsQueryManifestInformation(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN ULONG ulInfoClass,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T cbWrittenOrRequired OPTIONAL
    );

//
// these flags are used for sxs.dll. when ActCtx generation for system default fails, there are two cases we could ignore this error :
// Case 1 : there is no system-default at all 
// Case 2 : the dependency of system-default could not be found: this case may happen during the GUImode setup, when system-default is 
//          installed before GUI assembly is installed 
//  SXS.dll would pass out these two failure cases using these flags
//

#define BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_NOT_FOUND                      (0x0001)
#define BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND  (0x0002)

#define SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SUPPRESS_EVENT_LOG         (0x00000001)
#define SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY  (0x00000002)
#define SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY                 (0x00000004)

typedef struct _SXS_GENERATE_ACTIVATION_CONTEXT_STREAM
{
    IStream* Stream;

    //
    // This is not necessarily a file system path, just something
    // for descriptive/debugging purposes.
    //
    // Still, when they are file system paths, we try to keep them as Win32 paths instead of Nt paths.
    //
    PCWSTR  Path;
    ULONG   PathType;
} SXS_GENERATE_ACTIVATION_CONTEXT_STREAM;

typedef struct _SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS
{
    IN DWORD    Flags;
    IN USHORT   ProcessorArchitecture;
    IN LANGID   LangId;
    IN PCWSTR   AssemblyDirectory; // should be a Win32 path
    IN PCWSTR   TextualAssemblyIdentity;

    IN SXS_GENERATE_ACTIVATION_CONTEXT_STREAM Manifest;
    IN SXS_GENERATE_ACTIVATION_CONTEXT_STREAM Policy; 

    OUT DWORD   SystemDefaultActCxtGenerationResult; // when generate activation context for system default fails, this mask shows whether it fails for some certain reason which we could ignore the error.
       
    PSXS_IMPERSONATION_CALLBACK ImpersonationCallback;
    PVOID                       ImpersonationContext;

    OUT HANDLE  SectionObjectHandle;
} SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS, *PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS;
typedef const SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS* PCSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS;

typedef
BOOL
(WINAPI*
PSXS_GENERATE_ACTIVATION_CONTEXT_FUNCTION)(
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    );

BOOL
WINAPI
SxsGenerateActivationContext(
    IN OUT PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    );

//
//  Opaque ASSEMBLY_IDENTITY structure
//

typedef struct _ASSEMBLY_IDENTITY *PASSEMBLY_IDENTITY;
typedef const struct _ASSEMBLY_IDENTITY *PCASSEMBLY_IDENTITY;

//
//  The types of assembly identities.
//
//  Definitions may not include wildcard attributes; definitions
//  match only if they are exactly equal.  A wildcard matches
//  a definition if for all the non-wildcarded attributes,
//  there is an exact match.  References may not contain
//  wildcarded attributes but may contain a different set of
//  attributes than a definition that they match.  (Example:
//  definitions carry the full public key of the publisher, but
//  references usually carry just the "strong name" which is
//  the first 8 bytes of the SHA-1 hash of the public key.)
//

#define ASSEMBLY_IDENTITY_TYPE_DEFINITION (1)
#define ASSEMBLY_IDENTITY_TYPE_REFERENCE (2)
#define ASSEMBLY_IDENTITY_TYPE_WILDCARD (3)

#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE L"urn:schemas-microsoft-com:asm.v1"
#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH (32)

#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY                     L"assembly"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_CCH                 (8)
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY            L"assemblyIdentity"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY_CCH        (16)

#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION L"configuration"
#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH (13)

#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION           L"manifestVersion"
#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION_CCH       (15)

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME                       L"name"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME_CCH                   (4)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION                    L"version"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION_CCH                (7)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE                   L"language"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE_CCH               (8)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY                 L"publicKey"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH             (9)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN           L"publicKeyToken"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN_CCH       (14)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE     L"processorArchitecture"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE_CCH (21)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE                       L"type"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE_CCH                   (4)

// Pseudo-value used in some places when the language= attribute is missing from the identity.
// An identity that does not have language is implicitly "worldwide".

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE          L"x-ww"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE_CCH      (4)

//
//  All win32 assemblies must have "win32" as their type.
//

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32                L"win32"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32_CCH            (5)

//
//  Global flags describing the assembly identity state
//

//
//  SXS_ASSEMBLY_IDENTITY_FLAG_FROZEN means that the assembly
//  identity's contents are frozen and are not subject to additional
//  change.
//

#define ASSEMBLY_IDENTITY_FLAG_FROZEN           (0x80000000)

//
//  ASSEMBLY_IDENTITY_ATTRIBUTE structure
//

typedef struct _ASSEMBLY_IDENTITY_ATTRIBUTE {
    DWORD Flags;
    SIZE_T NamespaceCch;
    SIZE_T NameCch;
    SIZE_T ValueCch;
    const WCHAR *Namespace;
    const WCHAR *Name;
    const WCHAR *Value;
} ASSEMBLY_IDENTITY_ATTRIBUTE, *PASSEMBLY_IDENTITY_ATTRIBUTE;

typedef const struct _ASSEMBLY_IDENTITY_ATTRIBUTE *PCASSEMBLY_IDENTITY_ATTRIBUTE;

typedef enum _ASSEMBLY_IDENTITY_INFORMATION_CLASS {
    AssemblyIdentityBasicInformation = 1,
} ASSEMBLY_IDENTITY_INFORMATION_CLASS;

typedef struct _ASSEMBLY_IDENTITY_BASIC_INFORMATION {
    DWORD Flags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
} ASSEMBLY_IDENTITY_BASIC_INFORMATION, *PASSEMBLY_IDENTITY_BASIC_INFORMATION;

#define SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE    (0x00000001)

BOOL
WINAPI
SxsCreateAssemblyIdentity(
    IN DWORD Flags,
    IN ULONG Type,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity,
    IN ULONG InitialAttributeCount OPTIONAL,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE const * InitialAttributes OPTIONAL
    );

typedef BOOL (WINAPI * PSXS_CREATE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN ULONG Type,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity,
    IN ULONG InitialAttributeCount OPTIONAL,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE const * InitialAttributes OPTIONAL
    );

BOOL
WINAPI
SxsHashAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG *Hash
    );

typedef BOOL (WINAPI * PSXS_HASH_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG *Hash
    );

#define SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF (0x00000001)

BOOL
WINAPI
SxsAreAssemblyIdentitiesEqual(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity1,
    IN PCASSEMBLY_IDENTITY AssemlbyIdentity2,
    OUT BOOL *Equal
    );

typedef BOOL (WINAPI * PSXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity1,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity2,
    OUT BOOL *Equal
    );

BOOL
WINAPI
SxsFreezeAssemblyIdentity(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

typedef BOOL (WINAPI *PSXS_FREEZE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

VOID
WINAPI
SxsDestroyAssemblyIdentity(
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

typedef VOID (WINAPI * PSXS_DESTROY_ASSEMBLY_IDENTITY_ROUTINE)(
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE    (0x00000001)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME         (0x00000002)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE        (0x00000004)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED   (0x00000008)

#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE    (0x00000001)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME         (0x00000002)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE        (0x00000004)

BOOL
WINAPI
SxsValidateAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

typedef BOOL (WINAPI * PSXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTES_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

BOOL
WINAPI
SxsHashAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT ULONG *HashValue
    );

typedef BOOL (WINAPI * PSXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTE_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT ULONG *HashValue
    );

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID          (0)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN        (1)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL            (2)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN     (3)

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE     (0x00000001)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME          (0x00000002)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE         (0x00000004)

BOOL
WINAPI
SxsCompareAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    );

typedef BOOL (WINAPI * PSXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    );

#define SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING (0x00000001)

BOOL
WINAPI
SxsInsertAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    );

typedef BOOL (WINAPI * PSXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_ROUTINE)(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    );

BOOL
WINAPI
SxsRemoveAssemblyIdentityAttributesByOrdinal(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal,
    IN ULONG AttributeCount
    );

typedef BOOL (WINAPI * PSXS_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTES_BY_ORDINAL_ROUTINE)(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal,
    IN ULONG AttributeCount
    );

#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE       (0x00000001)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME            (0x00000002)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE           (0x00000004)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS    (0x00000008)

BOOL
WINAPI
SxsFindAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AttributeToMatch,
    OUT ULONG *FirstMatchOrdinal OPTIONAL,
    OUT ULONG *MatchCount OPTIONAL
    );

typedef BOOL (WINAPI * PSXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AttributeToMatch,
    OUT ULONG *FirstMatchOrdinal OPTIONAL,
    OUT ULONG *MatchCount OPTIONAL
    );

//
//  Rather than making "n" heap allocations, the pattern for SxsGetAssemblyIdentityAttributeByOrdinal()
//  is to call once with BufferSize = 0 or some reasonable fixed number to get the size of the
//  buffer required, allocate the buffer if the buffer passed in was too small and call again.
//
//  The strings returned in the ASSEMBLY_IDENTITY_ATTRIBUTE are *not*
//  dynamically allocated, but are instead expected to fit in the buffer passed in.
//

BOOL
WINAPI
SxsGetAssemblyIdentityAttributeByOrdinal(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal, // 0-based
    IN SIZE_T BufferSize,
    OUT PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

typedef BOOL (WINAPI * PSXS_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_BY_ORDINAL_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal, // 0-based
    IN SIZE_T BufferSize,
    OUT PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE         (0x00000001)
#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL     (0x00000002)

BOOL
WINAPI
SxsDuplicateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY Source,
    OUT PASSEMBLY_IDENTITY *Destination
    );

typedef BOOL (WINAPI * PSXS_DUPLICATE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY Source,
    OUT PASSEMBLY_IDENTITY *Destination
    );

BOOL
WINAPI
SxsQueryInformationAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PVOID AssemblyIdentityInformation,
    IN SIZE_T AssemblyIdentityInformationLength,
    IN ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    );

typedef BOOL (WINAPI * PSXS_QUERY_INFORMATION_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PVOID AssemblyIdentityInformation,
    IN SIZE_T AssemblyIdentityInformationLength,
    IN ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    );

#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE (0x00000001)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME      (0x00000002)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE     (0x00000004)

typedef VOID (WINAPI * PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE)(
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PVOID Context
    );

BOOL
WINAPI
SxsEnumerateAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute OPTIONAL,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    );

typedef BOOL (WINAPI * PSXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute OPTIONAL,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    );

//
//  Assembly Identity encoding:
//
//  Assembly identities may be encoded in various forms.  The two usual ones
//  are either a binary stream, suitable for embedding in other data structures
//  or for persisting or a textual format that looks like:
//
//      name;[ns1,]n1="v1";[ns2,]n2="v2"[;...]
//

#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY (1)
#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL (2)

BOOL
SxsComputeAssemblyIdentityEncodedSize(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    );

typedef BOOL (WINAPI * PSXS_COMPUTE_ASSEMBLY_IDENTITY_ENCODED_SIZE_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    );

BOOL
WINAPI
SxsEncodeAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

typedef BOOL (WINAPI * PSXS_ENCODE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

#define SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE        (0x00000001)

BOOL
WINAPI
SxsDecodeAssemblyIdentity(
    IN ULONG Flags,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity
    );

typedef BOOL (WINAPI * PSXS_DECODE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity
    );

//
// These are the definitions that SFC requires to interact with SXS.
//

#define SXS_PROTECT_RECURSIVE       ( 0x00000001 )
#define SXS_PROTECT_SINGLE_LEVEL    ( 0x00000000 )
#define SXS_PROTECT_FILTER_DEFAULT ( FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES | FILE_NOTIFY_CHANGE_SIZE | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_LAST_ACCESS | FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_SECURITY )

typedef struct _SXS_PROTECT_DIRECTORY {
	WCHAR       pwszDirectory[MAX_PATH];
	PVOID       pvCookie;
	ULONG       ulRecursiveFlag;
	ULONG       ulNotifyFilter;
} SXS_PROTECT_DIRECTORY, *PSXS_PROTECT_DIRECTORY;
typedef const SXS_PROTECT_DIRECTORY* PCSXS_PROTECT_DIRECTORY;

typedef BOOL ( WINAPI * PSXS_PROTECT_NOTIFICATION )(
    PVOID pvCookie,
    PCWSTR  wsChangeText,
    SIZE_T  cchChangeText,
    DWORD   dwChangeAction
    );

BOOL 
WINAPI
SxsProtectionNotifyW( 
    PVOID pvCookie, 
    PCWSTR  wsChangeText,
    SIZE_T  cchChangeText,
    DWORD   dwChangeAction
    );


typedef BOOL ( WINAPI * PSXS_PROTECT_RETRIEVELISTS )(
    PCSXS_PROTECT_DIRECTORY *prgpProtectListing,
    SIZE_T *pcProtectEntries
    );

BOOL
WINAPI
SxsProtectionGatherEntriesW(
    PCSXS_PROTECT_DIRECTORY *prgpProtectListing,
    SIZE_T *pcProtectEntries
    );

//
// This is for both the Logon and the Logoff events
//
typedef BOOL ( WINAPI * PSXS_PROTECT_LOGIN_EVENT )(void);

BOOL
WINAPI
SxsProtectionUserLogonEvent(
    void
    );

BOOL
WINAPI
SxsProtectionUserLogoffEvent(
    void
    );

typedef BOOL ( WINAPI * PSXS_PROTECT_SCAN_ONCE )( HWND, BOOL, BOOL );

BOOL
WINAPI
SxsProtectionPerformScanNow(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    );

#define PFN_NAME_PROTECTION_GATHER_LISTS_W  ( "SxsProtectionGatherEntriesW" )
#define PFN_NAME_PROTECTION_NOTIFY_CHANGE_W ( "SxsProtectionNotifyW" )
#define PFN_NAME_PROTECTION_NOTIFY_LOGON    ( "SxsProtectionUserLogonEvent" )
#define PFN_NAME_PROTECTION_NOTIFY_LOGOFF   ( "SxsProtectionUserLogoffEvent" )
#define PFN_NAME_PROTECTION_SCAN_ONCE       ( "SxsProtectionPerformScanNow" )


//
//  Settings API
//

//
//  These APIs are deliberately designed to look like a subset of the registry
//  APIs; their behavior should match the documented registry behavior in general;
//  the major missing functionality includes security, the win16 compatibility
//  APIs, loading and unloading of keys/hives and change notification.
//
//  Settings are strictly local to the process; changes are not visible to other
//  processes until the settings are saved.
//

typedef struct _SXS_SETTINGS_KEY *PSXS_SETTINGS_KEY;
typedef const struct _SXS_SETTINGS_KEY *PCSXS_SETTINGS_KEY;

#define SXS_SETTINGS_USERSCOPE_INVALID (0)
#define SXS_SETTINGS_USERSCOPE_PER_USER (1)
#define SXS_SETTINGS_USERSCOPE_SYSTEM_WIDE (2)

#define SXS_SETTINGS_APPSCOPE_INVALID (0)
#define SXS_SETTINGS_APPSCOPE_PER_PROCESS_ROOT (1)
#define SXS_SETTINGS_APPSCOPE_PER_CONTEXT_ROOT (2)
#define SXS_SETTINGS_APPSCOPE_PER_COMPONENT (3)

#define SXS_SETTINGS_ITEMTYPE_INVALID (0)
#define SXS_SETTINGS_ITEMTYPE_KEY (1)
#define SXS_SETTINGS_ITEMTYPE_VALUE (2)

typedef VOID (WINAPI * PSXS_OPEN_SETTINGS_INITIALIZATION_CALLBACK)(
    IN PVOID pvContext,
    IN PSXS_SETTINGS_KEY lpUninitializedSettingsKey,
    OUT BOOL *pfFailed
    );

#define SXS_OPEN_SETTINGS_FLAG_RETURN_NULL_IF_NONE (0x00000001)

typedef LONG (WINAPI * PSXS_OPEN_SETTINGS_W)(
    IN DWORD dwFlags,
    IN ULONG ulUserScope,
    IN ULONG ulAppScope,
    IN PCWSTR lpAssemblyName,
    IN PSXS_OPEN_SETTINGS_INITIALIZATION_CALLBACK lpInitializationCallback OPTIONAL,
    IN PVOID pvContext,
    OUT PSXS_SETTINGS_KEY *lpKey
    );

LONG
WINAPI
SxsOpenSettingsW(
    IN DWORD dwFlags,
    IN ULONG ulUserScope,
    IN ULONG ulAppScope,
    IN PCWSTR lpAssemblyName,
    IN PSXS_OPEN_SETTINGS_INITIALIZATION_CALLBACK lpInitializationCallback OPTIONAL,
    IN PVOID pvContext,
    OUT PSXS_SETTINGS_KEY *lpKey
    );

#define SXS_MERGE_SETTINGS_KEYDISPOSITION_INVALID (0)
#define SXS_MERGE_SETTINGS_KEYDISPOSITION_COPY_ENTIRE_SUBTREE (1)
#define SXS_MERGE_SETTINGS_KEYDISPOSITION_COPY_KEY_WALK_SUBTREE (2)

typedef VOID (WINAPI * PSXS_MERGE_SETTINGS_KEY_CALLBACKW)(
    IN PVOID pvContext,
    IN PCWSTR lpKeyPath,
    OUT ULONG *lpKeyDisposition
    );

#define SXS_MERGE_SETTINGS_VALUEDISPOSITION_INVALID (0)
#define SXS_MERGE_SETTINGS_VALUEDISPOSITION_COPY (1)
#define SXS_MERGE_SETTINGS_VALUEDISPOSITION_DONT_COPY (2)

typedef VOID (WINAPI * PSXS_MERGE_SETTINGS_VALUE_CALLBACKW)(
    IN PVOID pvContext,
    IN PCWSTR lpKeyPath,
    IN LPCWSTR lpValueName,
    IN OUT LPDWORD lpType,
    IN OUT LPBYTE *lplpData, // pointer to replacable data pointer.  Allocate replacements using GlobalAlloc(GPTR, nBytes)
    IN DWORD dwDataBufferSize, // for modifying data you can write up to this many bytes
    OUT ULONG *lpValueDisposition
    );

typedef LONG (WINAPI * PSXS_MERGE_SETTINGS_W)(
    IN DWORD dwFlags,
    IN PCSXS_SETTINGS_KEY lpKeyToMergeFrom,
    IN PSXS_SETTINGS_KEY lpKeyToMergeInTo,
    IN PSXS_MERGE_SETTINGS_KEY_CALLBACKW lpKeyCallback,
    IN PSXS_MERGE_SETTINGS_VALUE_CALLBACKW lpValueCallback,
    LPVOID pvContext
    );

LONG
WINAPI
SxsMergeSettingsW(
    IN DWORD dwFlags,
    IN PCSXS_SETTINGS_KEY lpKeyToMergeFrom,
    IN PSXS_SETTINGS_KEY lpKeyToMergeInTo,
    IN PSXS_MERGE_SETTINGS_KEY_CALLBACKW lpKeyCallback,
    IN PSXS_MERGE_SETTINGS_VALUE_CALLBACKW lpValueCallback,
    LPVOID pvContext
    );

LONG
WINAPI
SxsCloseSettingsKey(
    PSXS_SETTINGS_KEY lpKey
    );

LONG
WINAPI
SxsCreateSettingsKeyExW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PSXS_SETTINGS_KEY *lplpKeyResult,
    LPDWORD lpdwDisposition
    );

LONG
WINAPI
SxsDeleteSettingsKeyW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey
    );

LONG
WINAPI
SxsDeleteSettingsValueW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpValueName
    );

LONG
WINAPI
SxsEnumSettingsKeyW(
    IN PSXS_SETTINGS_KEY lpKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

LONG
WINAPI
SxsEnumSettingsKeyExW(
    IN PSXS_SETTINGS_KEY lpKey,
    IN DWORD dwIndex,
    OUT PWSTR lpName,
    IN OUT LPDWORD lpcName,
    IN OUT LPDWORD lpReserved,
    OUT PWSTR lpClass,
    OUT LPDWORD lpcClass,
    OUT PFILETIME lpftLastWriteTime
    );

LONG
WINAPI
SxsEnumSettingsValueW(
    IN PSXS_SETTINGS_KEY lpKey,
    IN DWORD dwIndex,
    OUT PWSTR lpValueName,
    IN OUT LPDWORD lpcValueName,
    IN OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
WINAPI
SxsFlushSettingsKey(
    IN PSXS_SETTINGS_KEY lpKey
    );

LONG
WINAPI
SxsOpenSettingsKeyEx(
    IN PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PSXS_SETTINGS_KEY *lplpKeyResult
    );

LONG
WINAPI
SxsQuerySettingsInfoKeyW(
    IN PSXS_SETTINGS_KEY lpKey,
    OUT PWSTR lpClass,
    IN OUT LPDWORD lpcClass,
    IN OUT LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcMaxSubKeyLen,
    OUT LPDWORD lpcMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcMaxValueNameLen,
    OUT LPDWORD lpcMaxValueLen,
    OUT LPDWORD lpcSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    );

LONG
WINAPI
SxsQuerySettingsMultipleValuesW(
    IN PSXS_SETTINGS_KEY lpKey,
    PVALENT val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD lpdwTotsize
    );

LONG
WINAPI
SxsQuerySettingsValueExW(
    IN PSXS_SETTINGS_KEY lpKey,
    IN LPCWSTR lpValueName,
    IN OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

LONG
WINAPI
SxsSetSettingsValueExW(
    IN PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpValueName,
    DWORD dwReserved,
    DWORD dwType,
    CONST BYTE *lpData,
    DWORD cbData
    );


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _SXSAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\svcs.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    svcs.h

Abstract:

    This file contains definitions that may be used by service dlls that
    run in an instance of svchost.exe.

Author:

    Rajen Shah      rajens      12-Apr-1991

[Environment:]

    User Mode - Win32

Revision History:

    20-Sep-2000     JSchwart
        Split SVCS-specific data from SVCHOST-specific data.

    25-Oct-1993     Danl
        Used to be services.h in the net\inc directory.
        Made it non-network specific and moved to private\inc.

    12-Apr-1991     RajenS
        Created

--*/

#ifndef _SVCS_
#define _SVCS_

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>                    // RPC_IF_HANDLE

//
// Service DLLs loaded into services.exe all export the same main
// entry point.  SVCS_ENTRY_POINT defines that name.
//
// Note that SVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define SVCS_ENTRY_POINT        ServiceEntry
#define SVCS_ENTRY_POINT_STRING "ServiceEntry"


//
// Start and stop RPC server entry point prototype.
//

typedef
NTSTATUS
(*PSVCS_START_RPC_SERVER) (
    IN LPWSTR InterfaceName,
    IN RPC_IF_HANDLE InterfaceSpecification
    );

typedef
NTSTATUS
(*PSVCS_STOP_RPC_SERVER) (
    IN RPC_IF_HANDLE InterfaceSpecification
    );

typedef
NTSTATUS
(*PSVCS_STOP_RPC_SERVER_EX) (
    IN RPC_IF_HANDLE InterfaceSpecification
    );

typedef
VOID
(*PSVCS_NET_BIOS_OPEN) (
    VOID
    );

typedef
VOID
(*PSVCS_NET_BIOS_CLOSE) (
    VOID
    );

typedef
DWORD
(*PSVCS_NET_BIOS_RESET) (
    IN UCHAR LanAdapterNumber
    );


//
// Structure containing "global" data for the various DLLs.
//

typedef struct _SVCHOST_GLOBAL_DATA
{
    //
    // NT well-known SIDs
    //

    PSID NullSid;                   // No members SID
    PSID WorldSid;                  // All users SID
    PSID LocalSid;                  // NT local users SID
    PSID NetworkSid;                // NT remote users SID
    PSID LocalSystemSid;            // NT system processes SID
    PSID LocalServiceSid;           // NT LocalService SID
    PSID NetworkServiceSid;         // NT NetworkService SID
    PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
    PSID AuthenticatedUserSid;      // NT authenticated users SID
    PSID AnonymousLogonSid;         // Anonymous logon SID

    //
    // Well Known Aliases.
    //
    // These are aliases that are relative to the built-in domain.
    //

    PSID AliasAdminsSid;            // Administrator Sid
    PSID AliasUsersSid;             // User Sid
    PSID AliasGuestsSid;            // Guest Sid
    PSID AliasPowerUsersSid;        // Power User Sid
    PSID AliasAccountOpsSid;        // Account Operator Sid
    PSID AliasSystemOpsSid;         // System Operator Sid
    PSID AliasPrintOpsSid;          // Print Operator Sid
    PSID AliasBackupOpsSid;         // Backup Operator Sid

    //
    // Entry points provided by svchost.exe
    //

    PSVCS_START_RPC_SERVER    StartRpcServer;
    PSVCS_STOP_RPC_SERVER     StopRpcServer;
    PSVCS_STOP_RPC_SERVER_EX  StopRpcServerEx;
    PSVCS_NET_BIOS_OPEN       NetBiosOpen;
    PSVCS_NET_BIOS_CLOSE      NetBiosClose;
    PSVCS_NET_BIOS_RESET      NetBiosReset;
}
SVCHOST_GLOBAL_DATA, *PSVCHOST_GLOBAL_DATA;


//
// Service global entry point prototype.
//

typedef
VOID
(*LPSVCHOST_PUSH_GLOBAL_FUNCTION) (
    IN PSVCHOST_GLOBAL_DATA  g_pSvchostSharedGlobals
    );

#endif  // ndef _SVCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\status.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    status.h

Abstract:

    This module defines manifest constants for the LAN Manager server.

Author:

    David Treadwell (davidtr)    10-May-1990

Revision History:

--*/

#ifndef _STATUS_
#define _STATUS_



//
// The server has 16 bits available to it in each 32-bit status code.
// See \nt\sdk\inc\ntstatus.h for a description of the use of the
// high 16 bits of the status.
//
// The layout of the bits is:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------+-----------------------+
//  |Sev|C|   Facility--Server      | Class |        Code           |
//  +---+-+-------------------------+-------+-----------------------+
//
// Class values:
//     0 - a server-specific error code, not put directly on the wire.
//     1 - SMB error class DOS.  This includes those OS/2 errors
//             that share code values and meanings with the SMB protocol.
//     2 - SMB error class SERVER.
//     3 - SMB error class HARDWARE.
//     4 - other SMB error classes
//     5-E - undefined
//     F - an OS/2-specific error.  If the client is OS/2, then the
//              SMB error class is set to DOS and the code is set to
//              the actual OS/2 error code contained in the Code field.
//
// The meaning of the Code field depends on the Class value.  If the
// class is 00, then the code value is arbitrary.  For other classes,
// the code is the actual code of the error in the SMB or OS/2
// protocols.
//

#define SRV_STATUS_FACILITY_CODE 0x00980000L
#define SRV_SRV_STATUS                (0xC0000000L | SRV_STATUS_FACILITY_CODE)
#define SRV_DOS_STATUS                (0xC0001000L | SRV_STATUS_FACILITY_CODE)
#define SRV_SERVER_STATUS             (0xC0002000L | SRV_STATUS_FACILITY_CODE)
#define SRV_HARDWARE_STATUS           (0xC0003000L | SRV_STATUS_FACILITY_CODE)
#define SRV_WIN32_STATUS              (0xC000E000L | SRV_STATUS_FACILITY_CODE)
#define SRV_OS2_STATUS                (0xC000F000L | SRV_STATUS_FACILITY_CODE)

//++
//
// BOOLEAN
// SmbIsSrvStatus (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     Macro to determine whether a status code is one defined by the
//     server (has the server facility code).
//
// Arguments:
//
//     Status - the status code to check.
//
// Return Value:
//
//     BOOLEAN - TRUE if the facility code is the servers, FALSE
//         otherwise.
//
//--

#define SrvIsSrvStatus(Status) \
    ( ((Status) & 0x1FFF0000) == SRV_STATUS_FACILITY_CODE ? TRUE : FALSE )

//++
//
// UCHAR
// SmbErrorClass (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error class field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error class.
//
// Return Value:
//
//     UCHAR - the server error class of the status code.
//
//--

#define SrvErrorClass(Status) ((UCHAR)( ((Status) & 0x0000F000) >> 12 ))

//++
//
// UCHAR
// SmbErrorCode (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error code field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error code.
//
// Return Value:
//
//     UCHAR - the server error code of the status code.
//
//--

#define SrvErrorCode(Status) ((USHORT)( (Status) & 0xFFF) )

//
// Status codes unique to the server.  These error codes are used
// internally only.
//

#define STATUS_ENDPOINT_CLOSED              (SRV_SRV_STATUS | 0x01)
#define STATUS_DISCONNECTED                 (SRV_SRV_STATUS | 0x02)
#define STATUS_SERVER_ALREADY_STARTED       (SRV_SRV_STATUS | 0x04)
#define STATUS_SERVER_NOT_STARTED           (SRV_SRV_STATUS | 0x05)
#define STATUS_OPLOCK_BREAK_UNDERWAY        (SRV_SRV_STATUS | 0x06)
#define STATUS_NONEXISTENT_NET_NAME         (SRV_SRV_STATUS | 0x08)

//
// Error codes that exist in both the SMB protocol and OS/2 but not NT.
// Note that all SMB DOS-class error codes are defined in OS/2.
//

#define STATUS_OS2_INVALID_FUNCTION   (SRV_DOS_STATUS | ERROR_INVALID_FUNCTION)
#define STATUS_OS2_TOO_MANY_OPEN_FILES \
                                   (SRV_DOS_STATUS | ERROR_TOO_MANY_OPEN_FILES)
#define STATUS_OS2_INVALID_ACCESS     (SRV_DOS_STATUS | ERROR_INVALID_ACCESS)

//
// SMB SERVER-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_INVALID_SMB            (SRV_SERVER_STATUS | SMB_ERR_ERROR)
#define STATUS_SMB_BAD_NET_NAME       (SRV_SERVER_STATUS | SMB_ERR_BAD_NET_NAME)
#define STATUS_SMB_BAD_TID            (SRV_SERVER_STATUS | SMB_ERR_BAD_TID)
#define STATUS_SMB_BAD_UID            (SRV_SERVER_STATUS | SMB_ERR_BAD_UID)
#define STATUS_SMB_TOO_MANY_UIDS      (SRV_SERVER_STATUS | SMB_ERR_TOO_MANY_UIDS)
#define STATUS_SMB_USE_MPX            (SRV_SERVER_STATUS | SMB_ERR_USE_MPX)
#define STATUS_SMB_USE_STANDARD       (SRV_SERVER_STATUS | SMB_ERR_USE_STANDARD)
#define STATUS_SMB_CONTINUE_MPX       (SRV_SERVER_STATUS | SMB_ERR_CONTINUE_MPX)
#define STATUS_SMB_BAD_COMMAND        (SRV_SERVER_STATUS | SMB_ERR_BAD_COMMAND)
#define STATUS_SMB_NO_SUPPORT         (SRV_SERVER_STATUS | SMB_ERR_NO_SUPPORT_INTERNAL)

// *** because SMB_ERR_NO_SUPPORT uses 16 bits, but we have only 12 bits
//     available for error codes, it must be special-cased in the code.

//
// SMB HARDWARE-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_SMB_DATA               (SRV_HARDWARE_STATUS | SMB_ERR_DATA)

//
// OS/2 error codes that lack an NT or SMB equivalent.
//

#include <winerror.h>

#define STATUS_OS2_INVALID_LEVEL \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_INVALID_LEVEL)

#define STATUS_OS2_EA_LIST_INCONSISTENT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_LIST_INCONSISTENT)

#define STATUS_OS2_NEGATIVE_SEEK \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NEGATIVE_SEEK)

#define STATUS_OS2_NO_MORE_SIDS \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NO_MORE_SEARCH_HANDLES)

#define STATUS_OS2_EAS_DIDNT_FIT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EAS_DIDNT_FIT)

#define STATUS_OS2_EA_ACCESS_DENIED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_ACCESS_DENIED)

#define STATUS_OS2_CANCEL_VIOLATION \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANCEL_VIOLATION)

#define STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_ATOMIC_LOCKS_NOT_SUPPORTED)

#define STATUS_OS2_CANNOT_COPY \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANNOT_COPY)

#endif // ndef _STATUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\srvfsctl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    srvfsctl.h

Abstract:

    This module defines I/O control codes and structures for the File
    System Driver of the LAN Manager server.

Author:

    David Treadwell (davidtr) 22-May-1990

Revision History:

--*/

#ifndef _SRVFSCTL_
#define _SRVFSCTL_


//
// The name of the server device.
//

#define SERVER_DEVICE_NAME TEXT("\\Device\\LanmanServer")

//
// IRP control codes used to send requests to the server.  These are
// used as parameters to NtFsControlFile, and may be found in
// Irp->Parameters.FsControl.FsControlCode in the server dispatch
// routine.
//
// Note that the low two bits of this code indicate the "method" in
// which the IO system uses the buffers passed by the user to
// NtFsControlFile.  We use method 0--normal, buffered output (not
// DMA)--for non-API requests, and method 3--"neither" IO--for API
// requests that get processed in the server FSD.  For the APIs
// that are processed in the server FSP, use method 0.
//
// !!! Add more as necessary.

#define FSCTL_SRV_BASE                  FILE_DEVICE_NETWORK
#define FSCTL_SRV_API                   1 << 11

#define _SRV_CONTROL_CODE(request,method) \
                ((FSCTL_SRV_BASE)<<12 | (request<<2) | method)

#define _SRV_API_CONTROL_CODE(request) \
                ((FSCTL_SRV_BASE)<<12 | FSCTL_SRV_API | (request<<2) | METHOD_NEITHER )

#define SRV_API_INDEX(code) \
                ((code & ~(0xFFFFF000 | FSCTL_SRV_API)) >> 2)

//
// Standard FSCTLs.
//

#define FSCTL_SRV_STARTUP               _SRV_CONTROL_CODE(  0, METHOD_NEITHER )
#define FSCTL_SRV_SHUTDOWN              _SRV_CONTROL_CODE(  1, METHOD_NEITHER )
#define FSCTL_SRV_CLEAR_STATISTICS      _SRV_CONTROL_CODE(  2, METHOD_BUFFERED )
#define FSCTL_SRV_GET_STATISTICS        _SRV_CONTROL_CODE(  3, METHOD_BUFFERED )
#define FSCTL_SRV_SET_DEBUG             _SRV_CONTROL_CODE(  4, METHOD_BUFFERED )
#define FSCTL_SRV_XACTSRV_CONNECT       _SRV_CONTROL_CODE(  5, METHOD_BUFFERED )
#define FSCTL_SRV_SEND_DATAGRAM         _SRV_CONTROL_CODE(  6, METHOD_NEITHER )
#define FSCTL_SRV_SET_PASSWORD_SERVER   _SRV_CONTROL_CODE(  7, METHOD_BUFFERED )
#define FSCTL_SRV_START_SMBTRACE        _SRV_CONTROL_CODE(  8, METHOD_BUFFERED )
#define FSCTL_SRV_SMBTRACE_FREE_SMB     _SRV_CONTROL_CODE(  9, METHOD_BUFFERED )
#define FSCTL_SRV_END_SMBTRACE          _SRV_CONTROL_CODE( 10, METHOD_BUFFERED )
#define FSCTL_SRV_QUERY_CONNECTIONS     _SRV_CONTROL_CODE( 11, METHOD_BUFFERED )
#define FSCTL_SRV_PAUSE                 _SRV_CONTROL_CODE( 12, METHOD_NEITHER )
#define FSCTL_SRV_CONTINUE              _SRV_CONTROL_CODE( 13, METHOD_NEITHER )
#define FSCTL_SRV_GET_CHALLENGE         _SRV_CONTROL_CODE( 14, METHOD_BUFFERED )
#define FSCTL_SRV_GET_DEBUG_STATISTICS  _SRV_CONTROL_CODE( 15, METHOD_BUFFERED )
#define FSCTL_SRV_XACTSRV_DISCONNECT    _SRV_CONTROL_CODE( 16, METHOD_BUFFERED )
#define FSCTL_SRV_REGISTRY_CHANGE       _SRV_CONTROL_CODE( 17, METHOD_NEITHER )
#define FSCTL_SRV_GET_QUEUE_STATISTICS  _SRV_CONTROL_CODE( 18, METHOD_BUFFERED )
#define FSCTL_SRV_SHARE_STATE_CHANGE    _SRV_CONTROL_CODE( 19, METHOD_BUFFERED )
#define FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS _SRV_CONTROL_CODE(20, METHOD_BUFFERED )
#define FSCTL_SRV_CHANGE_DOMAIN_NAME    _SRV_CONTROL_CODE( 21, METHOD_BUFFERED )
#define FSCTL_SRV_INTERNAL_TEST_REAUTH  _SRV_CONTROL_CODE( 22, METHOD_BUFFERED )
#define FSCTL_SRV_CHANGE_DNS_DOMAIN_NAME _SRV_CONTROL_CODE( 23, METHOD_BUFFERED )
#define FSCTL_SRV_ENUMERATE_SNAPSHOTS   _SRV_CONTROL_CODE( 24, METHOD_BUFFERED )

//
// The following FSCTL can be issued by a kernel driver to hook into the server
//   for accelerated direct host IPX performance.  A pointer to an SRV_IPX_SMART_CARD
//   structure is given for the START fsctl as the InputBuffer.

#define FSCTL_SRV_IPX_SMART_CARD_START  _SRV_CONTROL_CODE( 21, METHOD_NEITHER )

//
// API FSCTLs.
//
// *** The order of these must match the order of API processors in
//     the SrvApiDispatchTable jump table defined in ntos\srv\srvdata.c!

#define FSCTL_SRV_NET_CONNECTION_ENUM   _SRV_API_CONTROL_CODE(  0 )
#define FSCTL_SRV_NET_FILE_CLOSE        _SRV_API_CONTROL_CODE(  1 )
#define FSCTL_SRV_NET_FILE_ENUM         _SRV_API_CONTROL_CODE(  2 )
#define FSCTL_SRV_NET_SERVER_DISK_ENUM  _SRV_API_CONTROL_CODE(  3 )
#define FSCTL_SRV_NET_SERVER_SET_INFO   _SRV_API_CONTROL_CODE(  4 )
#define FSCTL_SRV_NET_SERVER_XPORT_ADD  _SRV_API_CONTROL_CODE(  5 )
#define FSCTL_SRV_NET_SERVER_XPORT_DEL  _SRV_API_CONTROL_CODE(  6 )
#define FSCTL_SRV_NET_SERVER_XPORT_ENUM _SRV_API_CONTROL_CODE(  7 )
#define FSCTL_SRV_NET_SESSION_DEL       _SRV_API_CONTROL_CODE(  8 )
#define FSCTL_SRV_NET_SESSION_ENUM      _SRV_API_CONTROL_CODE(  9 )
#define FSCTL_SRV_NET_SHARE_ADD         _SRV_API_CONTROL_CODE( 10 )
#define FSCTL_SRV_NET_SHARE_DEL         _SRV_API_CONTROL_CODE( 11 )
#define FSCTL_SRV_NET_SHARE_ENUM        _SRV_API_CONTROL_CODE( 12 )
#define FSCTL_SRV_NET_SHARE_SET_INFO    _SRV_API_CONTROL_CODE( 13 )
#define FSCTL_SRV_NET_STATISTICS_GET    _SRV_API_CONTROL_CODE( 14 )
#define FSCTL_SRV_MAX_API_CODE FSCTL_SRV_NET_STATISTICS_GET

//
// Startup information level
//

#define SS_STARTUP_LEVEL    -1L

#ifdef  INCLUDE_SRV_IPX_SMART_CARD_INTERFACE

//
// Structure passed to the srv via the FSCTL_SRV_IPX_SMART_CARD_START call by an
//  intelligent direct host IPX card.  The Smart card fills in its own
//  Open, Close, Read, and DeRegister entry points - which the server
//  calls at the appropriate times.  The server fills in its own
//  ReadComplete entry point which the smart card calls when it is done
//  transferring the data to the client.
//
typedef struct {
    //
    // This routine is called by the server when it is opening a file on
    //  behalf of a direct host IPX client.  It gives the smart card a chance
    //  to decide it it wants to help with file access.  If the smart card is
    //  interested, it should return TRUE and set SmartCardContext to a
    //  non-zero value of its choice.
    //
    BOOLEAN (* Open)(
        IN PVOID SmbHeader,             // Points to request PNT_SMB_HEADER
        IN PFILE_OBJECT FileObject,     // FileObject opened by the client
        IN PUNICODE_STRING FileName,    // Name of the file opened by the client
        IN PTDI_ADDRESS_IPX IpxAddress, // Address of the client
        IN ULONG Flags,                 // FO_CACHE_SUPPORTED (for now)
        OUT PVOID *SmartCardContext     // Context value returned by this routine
        );

    //
    // This is called by the server when the file is being closed.  The context
    //  value received at Open time is passed to this routine.
    //
    VOID ( * Close )(
        IN PVOID SmartCardContext       // Same context returned by Open() above
        );

    //
    // This is called by the server to see if the smart card wishes to handle the
    //  client's read request.  If the card is handling the read, it should return
    //  TRUE and the server will discontinue processing the read.  When the card is
    //  finished handling the read, it must call ReadComplete (below) to inform the
    //  server. If Read returns FALSE, the server handles the read as usual.
    //
    BOOLEAN ( * Read )(
        IN PVOID SmbHeader,             // Points to request PNT_SMB_HEADER
        IN PVOID SmartCardContext,      // Same context returned by Open() above
        IN ULONG Key,                   // Key value needed to read through locks
        IN PVOID SrvContext             // Opaque value provided by the server
        );

    //
    // This is the server's entry point which the smart card must call when it is
    //  finished handling the Read request (above).
    //
    VOID ( * ReadComplete )(
        IN PVOID SrvContext,            // Same as SrvContext in Read() above
        IN PFILE_OBJECT FileObject,     // Client FileObject to which this applies
        IN PMDL Mdl OPTIONAL,           // Mdl smart card is now finished with
        IN ULONG Length                 // Length of data indicated by the MDL
        );

    //
    // This is called by the server when the server wishes to disconnect from the
    //  card.  Once this returns, the card should not call back into the server.
    //
    VOID ( *DeRegister )(
        VOID
        );


} SRV_IPX_SMART_CARD, *PSRV_IPX_SMART_CARD;

#endif

//
// SMB_STATISTICS holds the count of SMBs and total turn around for a
// class of SMBs.  For example, a single SMB_STATISTIC structure could
// hold information about all read SMBs: Read, ReadAndX, ReadRaw,
// and ReadMultiplexed.
//

typedef struct _SMB_STATISTICS {
    LARGE_INTEGER TotalTurnaroundTime;
    ULONG SmbCount;
} SMB_STATISTICS, *PSMB_STATISTICS;

//
// Used to record the number of times something happened and some
// pertinent time measure.
//

typedef struct _SRV_TIMED_COUNTER {
    LARGE_INTEGER Time;
    ULONG Count;
} SRV_TIMED_COUNTER, *PSRV_TIMED_COUNTER;

//
// SRV_POOL_STATISTICS is used for tracking server pool usage, paged and
// nonpaged.  It is only enabled with SRVDBG2 and is controlled in the
// server module heapmgr.c.
//

typedef struct _SRV_POOL_STATISTICS {
    ULONG TotalBlocksAllocated;
    ULONG TotalBytesAllocated;
    ULONG TotalBlocksFreed;
    ULONG TotalBytesFreed;
    ULONG BlocksInUse;
    ULONG BytesInUse;
    ULONG MaxBlocksInUse;
    ULONG MaxBytesInUse;
} SRV_POOL_STATISTICS, *PSRV_POOL_STATISTICS;

//
// BLOCK_COUNTS is used to maintain statistics on server block types
//

typedef struct _BLOCK_COUNTS {
    ULONG Allocations;
    ULONG Closes;
    ULONG Frees;
} BLOCK_COUNTS, *PBLOCK_COUNTS;

#define MAX_NON_TRANS_SMB 0x84

#ifndef TRANS2_MAX_FUNCTION
#define TRANS2_MAX_FUNCTION 0x11
#endif

#define MAX_STATISTICS_SMB MAX_NON_TRANS_SMB + TRANS2_MAX_FUNCTION + 1

//
// SRV_STATISTICS is the structure returned to the FSCTL_GET_STATISTICS
// fsctl.
//

typedef struct _SRV_STATISTICS {

    //
    // The time at which statistics gathering began (or stats were last
    // cleared).
    //

    TIME StatisticsStartTime;

    //
    // Large integer counts of bytes received and sent
    //

    LARGE_INTEGER TotalBytesReceived;
    LARGE_INTEGER TotalBytesSent;

    //
    // Causes of session termination
    //

    ULONG SessionLogonAttempts;
    ULONG SessionsTimedOut;
    ULONG SessionsErroredOut;
    ULONG SessionsLoggedOff;
    ULONG SessionsForcedLogOff;

    //
    // Misc. Errors
    //

    ULONG LogonErrors;
    ULONG AccessPermissionErrors;
    ULONG GrantedAccessErrors;
    ULONG SystemErrors;
    ULONG BlockingSmbsRejected;
    ULONG WorkItemShortages;

    //
    // Cumulative counts of various statistics.  Note that when stats are
    // cleared, those "Total" fields which have a "Current" equivalent
    // are set to the "Current" value to avoid situations where the
    // current count is greater than the total.
    //

    ULONG TotalFilesOpened;

    ULONG CurrentNumberOfOpenFiles;
    ULONG CurrentNumberOfSessions;
    ULONG CurrentNumberOfOpenSearches;

    //
    // Memory usage stats we want to xport
    //

    ULONG CurrentNonPagedPoolUsage;
    ULONG NonPagedPoolFailures;
    ULONG PeakNonPagedPoolUsage;

    ULONG CurrentPagedPoolUsage;
    ULONG PagedPoolFailures;
    ULONG PeakPagedPoolUsage;


    //
    // Used to record the number of times work context blocks were placed
    // on the server's FSP queue and the total amount of time they spent
    // there.
    //

    SRV_TIMED_COUNTER TotalWorkContextBlocksQueued;

    ULONG CompressedReads;
    ULONG CompressedReadsRejected;
    ULONG CompressedReadsFailed;

    ULONG CompressedWrites;
    ULONG CompressedWritesRejected;
    ULONG CompressedWritesFailed;
    ULONG CompressedWritesExpanded;

} SRV_STATISTICS, *PSRV_STATISTICS;

//
// Per work-queue statistics for the server.  There is a workqueue for each
// processor in the system for nonblocking work, and a single workqueue for
// blocking work.
//
// These statistics are retrieved via FSCTL_SRV_GET_QUEUE_STATISTICS to the
// server driver.  For an N-processor system, the first N structs are per-processor,
// the N+1'th struct is for the blocking work queue.
//
typedef struct _SRV_QUEUE_STATISTICS {
    ULONG   QueueLength;           // current length of the workitem queue
    ULONG   ActiveThreads;         // # of threads currently servicing requests
    ULONG   AvailableThreads;      // # of threads waiting for work
    ULONG   FreeWorkItems;         // # of free work items
    ULONG   StolenWorkItems;       // # of work items taken from this free list
                                   //   by another queue
    ULONG   NeedWorkItem;          // # of work items we are currently short for this queue
    ULONG   CurrentClients;        // # of clients being serviced by this queue
    LARGE_INTEGER BytesReceived;   // # of bytes in from the network to clients on this queue
    LARGE_INTEGER BytesSent;       // # of bytes sent to the network from clients on this queue
    LARGE_INTEGER ReadOperations;  // # file read operations by clients on this queue
    LARGE_INTEGER BytesRead;       // # of data bytes read from files by clients on this queue
    LARGE_INTEGER WriteOperations; // # of file write ops by clients on this queue
    LARGE_INTEGER BytesWritten;    // # of data bytes written to files by clients on this queue
    SRV_TIMED_COUNTER TotalWorkContextBlocksQueued; // as above, but per-queue

} SRV_QUEUE_STATISTICS, *PSRV_QUEUE_STATISTICS;

//
// SRV_STATISTICS_DEBUG is the structure used for the
// FSCTL_SRV_GET_DEBUG_STATISTICS fsctl. This structure is valid
// only when SRVDBG3 is set.
//

typedef struct _SRV_STATISTICS_DEBUG {

    //
    // Large integer counts of bytes read and written.
    //

    LARGE_INTEGER TotalBytesRead;
    LARGE_INTEGER TotalBytesWritten;

    //
    // Raw reads and writes statistics
    //

    ULONG RawWritesAttempted;
    ULONG RawWritesRejected;
    ULONG RawReadsAttempted;
    ULONG RawReadsRejected;

    //
    // Cumulative count of time spent opening files and closing handles.
    //

    LARGE_INTEGER TotalIoCreateFileTime;
    LARGE_INTEGER TotalNtCloseTime;

    ULONG TotalHandlesClosed;
    ULONG TotalOpenAttempts;
    ULONG TotalOpensForPathOperations;
    ULONG TotalOplocksGranted;
    ULONG TotalOplocksDenied;
    ULONG TotalOplocksBroken;
    ULONG OpensSatisfiedWithCachedRfcb;

    ULONG FastLocksAttempted;
    ULONG FastLocksFailed;
    ULONG FastReadsAttempted;
    ULONG FastReadsFailed;
    ULONG FastUnlocksAttempted;
    ULONG FastUnlocksFailed;
    ULONG FastWritesAttempted;
    ULONG FastWritesFailed;

    ULONG DirectSendsAttempted;

    ULONG LockViolations;
    ULONG LockDelays;

    ULONG CoreSearches;
    ULONG CompleteCoreSearches;

    //
    // information about block types
    //

    BLOCK_COUNTS ConnectionInfo;
    BLOCK_COUNTS EndpointInfo;
    BLOCK_COUNTS LfcbInfo;
    BLOCK_COUNTS MfcbInfo;
    BLOCK_COUNTS RfcbInfo;
    BLOCK_COUNTS SearchInfo;
    BLOCK_COUNTS SessionInfo;
    BLOCK_COUNTS ShareInfo;
    BLOCK_COUNTS TransactionInfo;
    BLOCK_COUNTS TreeConnectInfo;
    BLOCK_COUNTS WorkContextInfo;
    BLOCK_COUNTS WaitForOplockBreakInfo;

    //
    // Statistics for different read and write sizes.  Each element of
    // the array corresponds to a range of IO sizes; see srv\smbsupp.c
    // for exact correspondences.
    //

    SMB_STATISTICS ReadSize[17];
    SMB_STATISTICS WriteSize[17];

    //
    // Statistics for each SMB type by command code.
    //

    SMB_STATISTICS Smb[MAX_STATISTICS_SMB+2+TRANS2_MAX_FUNCTION+1];

    struct {
        ULONG Depth;
        ULONG Threads;
        ULONG ItemsQueued;
        ULONG MaximumDepth;
    } QueueStatistics[3];

} SRV_STATISTICS_DEBUG, *PSRV_STATISTICS_DEBUG;

//
// SET DEBUG input and output structure.  Contains off/on masks for SrvDebug
// and SmbDebug.  The off mask is applied first, then the on mask is
// applied.  To set the entire mask to a specific value, set the off
// mask to all ones, and set the on mask to the desired value.  To leave
// a mask unchanged, set both masks to 0.  SET DEBUG is also used
// to modify other server heuristics.  HeuristicsChangeMask is used to
// indicate which heuristics are being changed.
//
// On output, the structure is presented in such a way as to allow the
// original values to be restored easily.  The output data is simply
// passed back as input data.
//

typedef struct _FSCTL_SRV_SET_DEBUG_IN_OUT {
    ULONG SrvDebugOff;
    ULONG SrvDebugOn;
    ULONG SmbDebugOff;
    ULONG SmbDebugOn;
    ULONG CcDebugOff;
    ULONG CcDebugOn;
    ULONG PbDebugOff;
    ULONG PbDebugOn;
    ULONG FatDebugOff;
    ULONG FatDebugOn;
    ULONG HeuristicsChangeMask;
    ULONG MaxCopyReadLength;
    ULONG MaxCopyWriteLength;
    ULONG DumpVerbosity;
    ULONG DumpRawLength;
    BOOLEAN EnableOplocks;
    BOOLEAN EnableFcbOpens;
    BOOLEAN EnableSoftCompatibility;
    BOOLEAN EnableRawMode;
    BOOLEAN EnableDpcLevelProcessing;
    BOOLEAN EnableMdlIo;
    BOOLEAN EnableFastIo;
    BOOLEAN DumpRequests;
    BOOLEAN DumpResponses;
} FSCTL_SRV_SET_DEBUG_IN_OUT, *PFSCTL_SRV_SET_DEBUG_IN_OUT;

//
// Bit assignments for server heuristics change mask.  The first group
// contains those that are values, while the second group contains those
// that are booleans.
//

#define SRV_HEUR_MAX_COPY_READ          0x00000001
#define SRV_HEUR_MAX_COPY_WRITE         0x00000002
#define SRV_HEUR_DUMP_VERBOSITY         0x00000004
#define SRV_HEUR_DUMP_RAW_LENGTH        0x00000008

#define SRV_HEUR_OPLOCKS                0x00010000
#define SRV_HEUR_FCB_OPENS              0x00020000
#define SRV_HEUR_SOFT_COMPATIBILITY     0x00040000
#define SRV_HEUR_RAW_MODE               0x00080000
#define SRV_HEUR_DPC_LEVEL_PROCESSING   0x00100000
#define SRV_HEUR_MDL_IO                 0x00200000
#define SRV_HEUR_FAST_IO                0x00400000
#define SRV_HEUR_DUMP_REQUESTS          0x00800000
#define SRV_HEUR_DUMP_RESPONSES         0x01000000

//
// Structure returned in response to FSCTL_SRV_QUERY_CONNECTIONS.
//

typedef struct _BLOCK_INFORMATION {
    PVOID Block;
    ULONG BlockType;
    ULONG BlockState;
    ULONG ReferenceCount;
} BLOCK_INFORMATION, *PBLOCK_INFORMATION;

//
// Structure for communication between the file server and the server
// service.
//

typedef struct _SERVER_REQUEST_PACKET {

    UNICODE_STRING Name1;
    UNICODE_STRING Name2;
    ULONG Level;
    ULONG ErrorCode;
    ULONG Flags;

    union {

        struct {

            ULONG EntriesRead;
            ULONG TotalEntries;
            ULONG TotalBytesNeeded;
            ULONG ResumeHandle;

        } Get;

        struct {

            ULONG ErrorParameter;

            union {

                struct {
                    ULONG MaxUses;
                } ShareInfo;

            } Api;

        } Set;

    } Parameters;

} SERVER_REQUEST_PACKET, *PSERVER_REQUEST_PACKET;

//
// Flags for the Flags field of the server request packet.
//

#define SRP_RETURN_SINGLE_ENTRY 0x01
#define SRP_CLEAR_STATISTICS    0x02
#define SRP_SET_SHARE_IN_DFS    0x04
#define SRP_CLEAR_SHARE_IN_DFS  0x08

//
// Flags used in the XPORT_ADD function
//

#define SRP_XADD_PRIMARY_MACHINE    0x1     // this is the primary machine name
#define SRP_XADD_REMAP_PIPE_NAMES   0x2    // remap pipe names to separate dir

//
// The valid set of flags for the XPORT_ADD function
//
#define SRP_XADD_FLAGS  (SRP_XADD_PRIMARY_MACHINE | SRP_XADD_REMAP_PIPE_NAMES)

//
// #defines for the share GENERIC_MAPPING structure, which must be available
// to both the server and the server service.
//

#define SRVSVC_SHARE_CONNECT           0x0001
#define SRVSVC_PAUSED_SHARE_CONNECT    0x0002

#define SRVSVC_SHARE_CONNECT_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED        |  \
                                            SRVSVC_SHARE_CONNECT          |  \
                                            SRVSVC_PAUSED_SHARE_CONNECT )

#define GENERIC_SHARE_CONNECT_MAPPING { \
    STANDARD_RIGHTS_READ |              \
        SRVSVC_SHARE_CONNECT,           \
    STANDARD_RIGHTS_WRITE |             \
        SRVSVC_PAUSED_SHARE_CONNECT,    \
    STANDARD_RIGHTS_EXECUTE,            \
    SRVSVC_SHARE_CONNECT_ALL_ACCESS }

//
// #defines for the file GENERIC_MAPPING structure, which must be available
// to both the server and the server service.  This structure is identical
// to the io file generic mapping "IopFileMapping" defined in io\ioinit.c
//

#define GENERIC_SHARE_FILE_ACCESS_MAPPING {             \
    FILE_GENERIC_READ,                                  \
    FILE_GENERIC_WRITE,                                 \
    FILE_GENERIC_EXECUTE,                               \
    FILE_ALL_ACCESS }

//
// Special cases of STYPE_DISKTREE
//

#define STYPE_CDROM             104
#define STYPE_REMOVABLE         105

#ifdef INCLUDE_SMB_PERSISTENT
#define STYPE_PERSISTENT        0x40000000
#endif

#endif // ndef _SRVFSCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sysprep_.h ===
#ifndef _SYSPREP_H
#define _SYSPREP_H

#include <cfgmgr32.h>
#include <setupapi.h>

// ============================================================================
// USEFUL STRINGS
// ============================================================================

#define SYSCLONE_PART2              "setupcl.exe"
#define IDS_ADMINISTRATOR           1

// ============================================================================
// USEFUL CONSTANTS
// ============================================================================

#define SETUPTYPE                   1        // from winlogon\setup.h
#define SETUPTYPE_NOREBOOT          2
#define REGISTRY_QUOTA_BUMP         (10* (1024 * 1024))
#define DEFAULT_REGISTRY_QUOTA      (32 * (1024 * 1024))
#define SFC_DISABLE_NOPOPUPS        4        // from sfc.h
#define FILE_SRCLIENT_DLL           L"SRCLIENT.DLL"

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif // ARRAYSIZE

#define ARRAYSIZE(a)         ( sizeof(a) / sizeof(a[0]) )

#ifdef AS
#undef AS
#endif // AS

#define AS(a)               ARRAYSIZE(a)

// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

BOOL
IsDomainMember(
    VOID
    );

BOOL
ResetRegistryKey(
    IN HKEY   Rootkey,
    IN PCWSTR Subkey,
    IN PCWSTR Delkey
    );

BOOL
DeleteWinlogonDefaults(
    VOID
    );

VOID
FixDevicePaths(
    VOID
    );

BOOL
NukeUserSettings(
        VOID
        );

BOOL
NukeMruList(
    VOID
    );

BOOL
RemoveNetworkSettings(
    LPTSTR  lpszSysprepINFPath
    );

VOID
RunExternalUniqueness(
    VOID
    );

BOOL
IsSetupClPresent(
    VOID
    );

BOOL
CheckOSVersion(
    VOID
    );

//
// from spapip.h
//
BOOL
pSetupIsUserAdmin(
    VOID
    );

BOOL
pSetupDoesUserHavePrivilege(
    PCTSTR
    );

BOOL
EnablePrivilege(
    IN PCTSTR,
    IN BOOL
    );

VOID 
BuildMassStorageSection(
    IN BOOL
    );

DWORD
ReArm(
    VOID
    );

BOOL
AdjustRegistry(
    IN BOOL RemoveNetworkSettings
    );

BOOL
AdjustFiles(
    VOID
    );

BOOL
PopulateDeviceDatabase(
    OUT BOOL*
    );


BOOL
CleanDeviceDatabase(
    VOID
    );

BOOL
BackupHives(
    VOID
    );

VOID
FreeSysprepContext(
    IN PVOID SysprepContext
    );

PVOID
InitSysprepQueueCallback(
    VOID
    );

UINT
SysprepQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

VOID
LogRepairInfo(
    IN  PWSTR  Source,
    IN  PWSTR  Target,
    IN  PWSTR  DirectoryOnSourceDevice,
    IN  PWSTR  DiskDescription,
    IN  PWSTR  DiskTag
    );

BOOL
ChangeBootTimeout(
    IN UINT
    );

VOID 
DisableSR(
    VOID
    );

VOID 
EnableSR(
    VOID
    );

BOOL 
LocateWinBOM
(
    LPTSTR lpFileName
);

BOOL PrepForSidGen
(
    void
);

VOID
NukeEventLogs(
    VOID
    );

BOOL SetCloneTag
(
    void
);

BOOL SetupFirstRunApp
(
    void
);

BOOL SetOEMDuplicatorString
(
    LPTSTR  lpszSysprepINFPath
);

BOOL SetBigLbaSupport
(
    LPTSTR  lpszSysprepINFPath
);

BOOL RemoveTapiSettings
(
    LPTSTR  lpszSysprepINFPath
);

BOOL IsPnPDriver
(
    IN  LPTSTR ServiceName
);

LPTSTR OPKAddPathN
(
    LPTSTR lpPath, 
    LPCTSTR lpName, 
    DWORD cbPath
);

#endif // _SYSPREP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\sysprep_.c ===
#ifdef DEBUG_LOGLOG
#pragma message("*** Warning! This is a log-generating build.")
#endif

/*++

File Description:

    This file contains all the functions required to add a registry entry
    to force execution of the system clone worker upon reboot.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>

#include <windows.h>
#include <stdlib.h>
#include <time.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <lmapibuf.h>

#include <setupapi.h>
#include <spapip.h>
#include <ntsetup.h>
#include <imagehlp.h>
#include <coguid.h>
#include <cfg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <netcfgx.h>

#include <stdio.h>
#include <string.h>

#include <syssetup.h>
#include <spsyslib.h>
#include <sysprep_.h>
#include <userenv.h>
#include <userenvp.h>

#include <shlwapi.h>
#include <shlobj.h>
#include <shellapi.h>
#include <wininet.h>
#include <winineti.h>
#include "resource.h"       // shared string resource from riprep/sysprep
#include <strsafe.h>

#include <shlguid.h>        // Needed for CLSID_CUrlHistory
#define COBJMACROS
#include <urlhist.h>        // Needed for IUrlHistoryStg2 and IID_IUrlHistoryStg2

#if !(defined(AMD64) || defined(IA64))
#include <cleandrm.h>
#define CLEANDRM_LOGFILE            TEXT("cleandrm.log")
#endif // #if !(defined(AMD64) || defined(IA64))


extern BOOL    NoSidGen;
extern BOOL    PnP;
extern BOOL    bMiniSetup;
extern HINSTANCE ghInstance;

//
// Internal Defines
//
#define STR_REG_USERASSIST              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{75048700-EF1F-11D0-9888-006097DEACF9}")
#define STR_REG_USERASSIST_SHELL        STR_REG_USERASSIST TEXT("\\Count")
#define STR_REG_USERASSIST_IE           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{5E6AB780-7743-11CF-A12B-00AA004AE837}\\Count")
#define STR_REG_USERASSIST_DEFSHELL     TEXT(".DEFAULT\\") STR_REG_USERASSIST_SHELL
#define STR_REG_VAL_VERSION             TEXT("Version")
#define VAL_UEM_VERSION                 0x00000003
#define VAL_MAX_DATA                    16384
#define SYSPREPMASSSTORAGE_SECTION      TEXT("sysprepmassstorage")
#define SYSPREP_SECTION                 TEXT("sysprep")
#define SYSPREP_BUILDMASSSTORAGE_KEY    TEXT("BuildMassStorageSection")
#define STR_REG_VALUE_LASTALIVESTAMP    TEXT("LastAliveStamp")
#define STR_REG_KEY_RELIABILITY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Reliability")

#ifdef NULLSTR
#undef NULLSTR
#endif // NULLSTR
#define NULLSTR                 TEXT("\0")

#ifdef NULLCHR
#undef NULLCHR
#endif // NULLCHR
#define NULLCHR                 TEXT('\0')

#ifdef CHR_BACKSLASH
#undef CHR_BACKSLASH
#endif // CHR_BACKSLASH
#define CHR_BACKSLASH           TEXT('\\')

#ifdef CHR_SPACE
#undef CHR_SPACE
#endif // CHR_SPACE
#define CHR_SPACE               TEXT(' ')


//
// This is a string version of GUID_DEVCLASS_LEGACYDRIVER in devguid.h
//
#define LEGACYDRIVER_STRING     L"{8ECC055D-047F-11D1-A537-0000F8753ED1}"

//
// Context for file queues in SysSetup
//
typedef struct _SYSSETUP_QUEUE_CONTEXT {
    PVOID   DefaultContext;
    PWSTR   DirectoryOnSourceDevice;
    PWSTR   DiskDescription;
    PWSTR   DiskTag;
} SYSPREP_QUEUE_CONTEXT, *PSYSPREP_QUEUE_CONTEXT;

typedef struct _CLEANUP_NODE
{
    LPTSTR  pszService;
    struct _CLEANUP_NODE* pNext;
}CLEANUP_NODE, *PCLEANUP_NODE, **PPCLEANUP_NODE;

PCLEANUP_NODE   g_pCleanupListHead = NULL;

// String macros.
//
#ifndef LSTRCMPI
#define LSTRCMPI(x, y)        ( ( CompareString( LOCALE_INVARIANT, NORM_IGNORECASE, x, -1, y, -1 ) - CSTR_EQUAL ) )
#endif // LSTRCMPI

#ifdef DEBUG_LOGLOG

/*++
===============================================================================

    Debug logging for populating/depopulating the critical device
    database

===============================================================================
--*/

#define MAX_MSG_LEN                 2048

BOOL LOG_Init(LPCTSTR lpszLogFile);
BOOL LOG_DeInit();
BOOL LOG_Write(LPCTSTR lpszFormat,...);
BOOL LOG_WriteLastError();
int GetSystemErrorMessage(LPTSTR lpszMsg, int cbMsg);

static HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

BOOL LOG_Init(
    LPCTSTR lpszLogFile
    )
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
        return FALSE;

    g_hLogFile = CreateFile(
                        lpszLogFile,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                        NULL);

    if (g_hLogFile == INVALID_HANDLE_VALUE)
        return FALSE;

    return TRUE;
}

BOOL LOG_DeInit()
{
    BOOL bRet = LOG_Write(TEXT("\r\n"));

    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        bRet = CloseHandle(g_hLogFile) && bRet;
        g_hLogFile = INVALID_HANDLE_VALUE;
    }

    return bRet;
}

BOOL LOG_Write(
    LPCTSTR lpszFormat,
    ...
    )
{
    DWORD dwTemp;
    TCHAR szBuf[MAX_MSG_LEN];
    char szMsg[MAX_MSG_LEN];
    va_list arglist;
    int len;

    if (g_hLogFile == INVALID_HANDLE_VALUE)
        return FALSE;

    va_start(arglist, lpszFormat);
    _vsnwprintf(szBuf, MAX_MSG_LEN, lpszFormat, arglist);
    va_end(arglist);

    StringCchCat (szBuf, AS ( szBuf ), TEXT("\r\n"));

    len = WideCharToMultiByte(
                CP_ACP,
                0,
                szBuf,
                -1,
                szMsg,
                MAX_MSG_LEN,
                NULL,
                NULL
                );
    if (len == 0) {
        return FALSE;
    }

    SetFilePointer(g_hLogFile, 0L, 0L, FILE_END);
    return WriteFile(g_hLogFile, szMsg, len - 1, &dwTemp, NULL);
}

BOOL LOG_WriteLastError()
{
    TCHAR szBuf[MAX_MSG_LEN];
    GetSystemErrorMessage(szBuf, MAX_MSG_LEN);

    return LOG_Write(TEXT("ERROR - %s"), szBuf);
}

int
GetSystemErrorMessage(
    LPWSTR lpszMsg,
    int cbMsg
    )
{
    LPVOID lpMsgBuf;
    DWORD dwError = GetLastError();
    int len;

    len = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_SYSTEM |
                         FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwError,
                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                         (LPWSTR) &lpMsgBuf,
                         0,
                         NULL );

    if( len == 0 ) {
        //
        // We failed to get a message.  Just spew the error
        // code.
        //
        StringCchPrintf( lpszMsg, cbMsg, ( L"(0x%08X)", dwError);
        len = lstrlen((LPCWSTR) lpMsgBuf);
    } else {

        len = lstrlen((LPCWSTR) lpMsgBuf);
        StringCchPrintf( lpszMsg, cbMsg,  L"(0x%08X) ", dwError);
        lpszMsg += lstrlen(lpszMsg);
        cbMsg -= lstrlen(lpszMsg);

        lstrcpyn(lpszMsg, (LPCWSTR) lpMsgBuf, cbMsg);

        if (len >= cbMsg)
            lpszMsg[cbMsg - 1] = L'\0';

        LocalFree(lpMsgBuf);
    }

    // Reset the last error incase someone after logging wants 
    // to get last error again
    //
    SetLastError(dwError);

    return len;
}

#endif // DEBUG_LOGLOG

#define PRO 0
#define SRV 1
#define ADS 2
#define DAT 3
#define PER 4

#define BLA 5

// Returns 0 - Professional, 1 - Server, 2 - ADS, 3 - Data, 4 - Personal, 5 - Blade
//
DWORD GetProductFlavor()
{
    DWORD ProductFlavor = PRO;        // Default Professional
    OSVERSIONINFOEX osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO*)&osvi);
    if (osvi.wProductType == VER_NT_WORKSTATION)
    {
        if (osvi.wSuiteMask & VER_SUITE_PERSONAL)
        {
            ProductFlavor = PER;  // Personal
        }
    }
    else
    {
        ProductFlavor = SRV;  // In the server case assume normal server
        if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
        {
            ProductFlavor = DAT;  // Datacenter
        }
        else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            ProductFlavor = ADS;  // Advanced server
        }
        else if (osvi.wSuiteMask & VER_SUITE_BLADE)
        {
            ProductFlavor = BLA;  // Blade server
        }
    }
    return ProductFlavor;
}

// Check if Personal SKU
//
BOOL IsPersonalSKU()
{
    if (PER == GetProductFlavor())
        return TRUE;
    return FALSE;
}

// Check if Professional SKU
//
BOOL IsProfessionalSKU()
{
    if (PRO == GetProductFlavor())
        return TRUE;
    return FALSE;
}

// Check if Server SKU
//
BOOL IsServerSKU()
{
    int OS = GetProductFlavor();
    if (SRV == OS ||
        BLA == OS ||
        DAT == OS ||
        ADS == OS)
        return TRUE;
    return FALSE;
}

BOOL
IsDomainMember(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Detect if we're a member of a domain or not.

Arguments:

Return Value:

    TRUE - We're in a domain.

    FALSE - We're not in a domain.

===============================================================================
--*/

{
DWORD                   rc;
PWSTR                   SpecifiedDomain = NULL;
NETSETUP_JOIN_STATUS    JoinStatus;

    rc = NetGetJoinInformation( NULL,
                                &SpecifiedDomain,
                                &JoinStatus );

    if( SpecifiedDomain ) {
        NetApiBufferFree( SpecifiedDomain );
    }

    if( rc == NO_ERROR ) {

        if( JoinStatus == NetSetupDomainName ) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ResetRegistryKey(
    IN HKEY   Rootkey,
    IN PCWSTR Subkey,
    IN PCWSTR Delkey
    )
/*++
===============================================================================
Routine Description:

    Reset a registry key by deleting the key and all subvalues
    then recreate the key

Arguments:

Return Value:

===============================================================================
--*/

{
    HKEY hkey;
    HKEY nkey;
    DWORD rc;
    BOOL AnyErrors;
    DWORD disp;

    AnyErrors = FALSE;

    rc = RegCreateKeyEx(Rootkey, Subkey, 0L, NULL,
                    REG_OPTION_BACKUP_RESTORE,
                    KEY_CREATE_SUB_KEY, NULL, &hkey, NULL);
    if ( rc == NO_ERROR )
    {
        rc = SHDeleteKey(hkey, Delkey);
        if( (rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND) ) 
        {
            AnyErrors = TRUE;
        } 
        else 
        {
            rc = RegCreateKeyEx(hkey, Delkey, 0L, NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &nkey, &disp);
            if ( rc != NO_ERROR ) 
            {
                AnyErrors = TRUE;
            }
            //
            // BUGUG - Tries to close key even if rc != NO_ERROR
            //
            RegCloseKey(nkey);
        }
        //
        // BUGUG - Tries to close key even if rc != NO_ERROR
        //
        RegCloseKey(hkey);
    } 
    else 
    {
        AnyErrors = TRUE;
    }

    return (!AnyErrors);
}

BOOL
GetAdminAccountName(
    PWSTR AccountName
    )

/*++
===============================================================================
Routine Description:

    This routine retrieves the name of the Adminstrator account

Arguments:

    AccountName     This is a buffer that will recieve the name of the account.

Return Value:

    TRUE - success.

    FALSE - failed.

===============================================================================
--*/
{
    BOOL b = TRUE;
    LSA_HANDLE        hPolicy;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    UCHAR SubAuthCount;
    DWORD sidlen;
    PSID psid = NULL;
    WCHAR domainname[MAX_PATH];
    DWORD adminlen= MAX_PATH;
    DWORD domlen=MAX_PATH;
    SID_NAME_USE sidtype;


    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (!NT_SUCCESS(ntStatus)) {
        //
        // ISSUE-2002/02/26-brucegr: Do you close the handle if LsaOpenPolicy fails?
        //
        LsaClose(hPolicy);
        b = FALSE;
    }

    if( b ) {
        ntStatus = LsaQueryInformationPolicy( hPolicy,
                                              PolicyAccountDomainInformation,
                                              (PVOID *) &AccountDomainInfo );

        LsaClose( hPolicy );

        if (!NT_SUCCESS(ntStatus)) {
            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
            b = FALSE;
        }
    }

    if( b ) {
        //
        // calculate the size of a new sid with one more SubAuthority
        //
        SubAuthCount = *(GetSidSubAuthorityCount ( AccountDomainInfo->DomainSid ));
        SubAuthCount++; // for admin
        sidlen = GetSidLengthRequired ( SubAuthCount );

        //
        // allocate and copy the new new sid from the Domain SID
        //
        psid = (PSID)malloc(sidlen);
        if (psid) {
            memcpy(psid, AccountDomainInfo->DomainSid, GetLengthSid(AccountDomainInfo->DomainSid) );

            //
            // increment SubAuthority count and add Domain Admin RID
            //
            *(GetSidSubAuthorityCount( psid )) = SubAuthCount;
            *(GetSidSubAuthority( psid, SubAuthCount-1 )) = DOMAIN_USER_RID_ADMIN;

            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }

            //
            // get the admin account name from the new SID
            //
            b = LookupAccountSid( NULL,
                                  psid,
                                  AccountName,
                                  &adminlen,
                                  domainname,
                                  &domlen,
                                  &sidtype );

            free(psid);
        }
    }

    return( b );
}




BOOL
DeleteWinlogonDefaults(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Delete the following registry values:
        HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultDomainName
        HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultUserName

Arguments:

Return Value:

===============================================================================
--*/

{
    HKEY hkey;
    DWORD rc;
    BOOL AnyErrors;
    WCHAR AccountName[MAX_PATH];

    AnyErrors = FALSE;

    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                    0L, NULL,
                    REG_OPTION_BACKUP_RESTORE,
                    KEY_SET_VALUE, NULL, &hkey, NULL);
    if (rc == NO_ERROR) 
    {
        //
        // If Personal then reset the values
        //
        if (IsPersonalSKU()) {
            DWORD dwSize = MAX_PATH * sizeof(TCHAR);
            StringCchCopy ( AccountName, AS ( AccountName ), TEXT("Owner"));
            rc = RegSetValueEx( hkey,
                                TEXT("DefaultUserName"),
                                0,
                                REG_SZ,
                                (CONST BYTE *)AccountName,
                                (lstrlen( AccountName ) + 1) * sizeof(TCHAR) );
            if((rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND)) {
                AnyErrors = TRUE;
            }
        }
        else {
            //
            // All others sku
            //
            if(rc == NO_ERROR) {
                rc = RegDeleteValue( hkey, TEXT("DefaultDomainName") );
                if((rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND)) {
                    AnyErrors = TRUE;
                } else {
                    //
                    // Before we whack the DefaultUserName value, let's
                    // make sure we can replace it with the name of the
                    // administrator account.  So first go retrieve that
                    // name.  
                    //
                    if( GetAdminAccountName( AccountName ) ) {
                        //
                        // Got it.  Reset the value key.
                        //
                        rc = RegSetValueEx( hkey,
                                            TEXT("DefaultUserName"),
                                            0,
                                            REG_SZ,
                                            (CONST BYTE *)AccountName,
                                            (lstrlen( AccountName ) + 1) * sizeof(TCHAR) );

                        if((rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND)) {
                            AnyErrors = TRUE;
                        }
                    } else {
                        //
                        // Sniff...  We couldn't retrieve the name of the
                        // administrator account.  Very odd.  Better
                        // be safe and just leave the key as it is.
                        //
                    }
                }
            }    
        }
        RegCloseKey(hkey);
    }
    else {
        AnyErrors = TRUE;
    }

    return (!AnyErrors);
}


VOID
FixDevicePaths(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine checks to see if the user specified an oempnpdriverspath in
    his unattend file.  If so, we need to append it onto the DevicePath
    entry in the registry.

    If the user specified an InstallFilesPath in the unattend file, we
    will plug that value into the registry so that Lang files, ...
    can be obtained from this new directory.

Arguments:

    None.

Return Value:

===============================================================================
--*/
{
    LPTSTR  lpNewPath   = NULL,
            lpOldPath,
            lpSearch;
    DWORD   dwChars     = 512,
            dwReturn;
    TCHAR       NewPath[2048];
    TCHAR       FileName[2048];
    HKEY        hKey;
    DWORD       l;
    DWORD       Size;
    DWORD       Type;

    //
    // NOTE:  This function should call UpdateDevicePath() and UpdateSourcePath()
    //        from OPKLIB.  Those fuctions do the exact thing that the following
    //        code does.  But for now because I don't want to deal the whole riprep
    //        linking with OPKLIB, this duplicate code will just have to remain.
    //

    //
    // =================================
    // OemPnpDriversPath
    // =================================
    //

    //
    // First see if he's got the entry in the unattend file.
    //
    if (!GetWindowsDirectory( FileName, MAX_PATH ))
        return;

    StringCchCopy ( &FileName[3], AS ( FileName ) - 3, TEXT("sysprep\\sysprep.inf") );

    // Get the new string from the INF file.
    //
    do
    {
        // Start with 1k of characters, doubling each time.
        //
        dwChars *= 2;

        // Free the previous buffer, if there was one.
        //
        if ( lpNewPath )
            free(lpNewPath);

        // Allocate a new buffer.
        //
        if ( lpNewPath = (LPTSTR) malloc(dwChars * sizeof(TCHAR)) )
        {
            *lpNewPath = L'\0';
            dwReturn = GetPrivateProfileString(L"Unattended", L"OemPnPDriversPath", L"", lpNewPath, dwChars, FileName);
        }
        else
            dwReturn = 0;
    }
    while ( dwReturn >= (dwChars - 1) );

    if ( lpNewPath && *lpNewPath )
    {
        //
        // Got it.  Open the registry and get the original value.
        //

        //
        // Open HKLM\Software\Microsoft\Windows\CurrentVersion
        //
        l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
                          0,
                          KEY_ALL_ACCESS,
                          &hKey );
        if( l == NO_ERROR ) {
            //
            // Query the value of the DevicePath Key.
            //
            Size = 0;
            l = RegQueryValueEx( hKey,
                                 TEXT("DevicePath"),
                                 NULL,
                                 &Type,
                                 NULL,
                                 &Size );
            if ( ERROR_SUCCESS != l ) 
                Size = 0;

            // Need to count the number of paths in the new path buffer.
            //
            for ( dwChars = 1, lpSearch = lpNewPath; *lpSearch; lpSearch++ )
            {
                if ( L';' == *lpSearch )
                    dwChars++;
            }

            // The size of the old buffer needs to be the size of the registry key,
            // plus the size of the new buffer, plus room for the ";%systemdrive%\" we
            // are going to add to each path in the new buffer.
            //
            Size += (lstrlen(lpNewPath) + (dwChars * 16) + 1) * sizeof(TCHAR);

            if ( lpOldPath = (LPTSTR) malloc(Size) )
            {
                TCHAR   *BeginStrPtr;
                TCHAR   *EndStrPtr;
                BOOL    Done = FALSE;
                LPTSTR  lpAdd;
                DWORD   dwBufSize = Size;

                l = RegQueryValueEx( hKey,
                                     TEXT("DevicePath"),
                                     NULL,
                                     &Type,
                                     (LPBYTE) lpOldPath,
                                     &dwBufSize );
                if ( ERROR_SUCCESS != l )
                    *lpOldPath = L'\0';

                //
                // OemPnpDriversDirPath can have several entries, separated by
                // a semicolon.  For each entry, we need to:
                // 1. append a semicolon.
                // 2. append %SystemDrive%
                // 3. concatenate the entry.
                //

                BeginStrPtr = lpNewPath;
                do {
                    //
                    // Mark the end of this entry.
                    //
                    EndStrPtr = BeginStrPtr;
                    while( (*EndStrPtr) && (*EndStrPtr != L';') ) {
                        EndStrPtr++;
                    }

                    //
                    // Is this the last entry?
                    //
                    if( *EndStrPtr == 0 ) {
                        Done = TRUE;
                    }
                    *EndStrPtr = 0;

                    //
                    // Make sure that if you change anything here that
                    // has to do with the length of the extra data we add
                    // to each path in the new buffer, that you change the
                    // extra padding we give to the old path buffer (currenttly
                    // 16 chars for every different path in the new buffer).
                    //

                    // Save a pointer to part we are adding
                    // so it can be removed if already there.
                    //
                    lpAdd = lpOldPath + lstrlen(lpOldPath);

                    if ( *lpOldPath )
                        StringCchCat( lpAdd,  ( Size / sizeof ( TCHAR ) ) - lstrlen( lpOldPath ),  L";" );

                    // Save a pointer to the part we are going to
                    // search for in the old path (after the ;).
                    //
                    lpSearch = lpOldPath + lstrlen(lpOldPath);
                    StringCchCat( lpSearch, ( Size / sizeof ( TCHAR ) ) - lstrlen( lpOldPath ), L"%SystemDrive%\\" );

                    if ( L'\\' == *BeginStrPtr )
                        BeginStrPtr++;

                    lpSearch = lpOldPath + lstrlen(lpOldPath);
                    StringCchCat( lpSearch,  ( Size / sizeof ( TCHAR ) ) - lstrlen( lpOldPath ), BeginStrPtr);

                    BeginStrPtr = EndStrPtr + 1;

                    // Check to see if this new string is already
                    // in the old path.
                    //
                    EndStrPtr = lpOldPath;
                    do
                    {
                        // First check for our string we are adding.
                        //
                        if ( ( EndStrPtr = StrStrI(EndStrPtr, lpSearch) ) &&
                             ( EndStrPtr < lpAdd ) )
                        {
                            // If found, make sure the next character
                            // in our old path is a ; or null.
                            //
                            EndStrPtr += lstrlen(lpSearch);
                            if ( ( TEXT('\0') == *EndStrPtr ) ||
                                 ( TEXT(';')  == *EndStrPtr ) )
                            {
                                // If it is, it is already there and we
                                // need to get rid of the string we added.
                                //
                                *lpAdd = TEXT('\0');
                            }
                            else
                            {
                                // If it isn't, move the end pointer to the next
                                // ; so we can search the rest of the old path string.
                                //
                                while ( *EndStrPtr && ( TEXT(';') != *EndStrPtr ) )
                                    EndStrPtr++;
                            }
                        }
                    }
                    while ( EndStrPtr && ( EndStrPtr < lpAdd ) && *lpAdd );

                    //
                    // Take care of the case where the user ended the
                    // OemPnpDriversPath entry with a semicolon.
                    //
                    if( *BeginStrPtr == 0 ) {
                        Done = TRUE;
                    }
                } while( !Done );

                //
                // Now set the key with our new value.
                //
                l = RegSetValueEx( hKey,
                                   TEXT("DevicePath"),
                                   0,
                                   REG_EXPAND_SZ,
                                   (CONST BYTE *)lpOldPath,
                                   (lstrlen( lpOldPath ) + 1) * sizeof(TCHAR));

                free(lpOldPath);
            }

            RegCloseKey(hKey);
        }

        free(lpNewPath);
    }


    //
    // =================================
    // InstallFilesPath
    // =================================
    //

    //
    // First see if he's got the entry in the unattend file.
    //
    if (!GetWindowsDirectory( FileName, MAX_PATH ))
        return;

    StringCchCopy ( &FileName[3], AS ( FileName ) - 3, TEXT("sysprep\\sysprep.inf") );
    
    //
    // ISSUE-2002/02/26-brucegr: NewPath should be zero initialized for "if" check below
    //
    GetPrivateProfileString( TEXT( "Unattended" ),
                             TEXT( "InstallFilesPath" ),
                             L"",
                             NewPath,
                             sizeof(NewPath)/sizeof(NewPath[0]),
                             FileName );

    if( NewPath[0] ) {
        //
        // Got it.  Open the registry and get the original value.
        //

        //
        // Open HKLM\Software\Microsoft\Windows\CurrentVersion\\Setup
        //
        l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                          0,
                          KEY_ALL_ACCESS,
                          &hKey );
        if( l == NO_ERROR ) {
            //
            // Now set the key with our new value.
            //
            l = RegSetValueEx( hKey,
                               TEXT("SourcePath"),
                               0,
                               REG_SZ,
                               (CONST BYTE *)NewPath,
                               (lstrlen( NewPath ) + 1) * sizeof(TCHAR));

            //
            // ISSUE-2002/02/26-brucegr: Do we care about the return value?
            //

            RegCloseKey(hKey);
        }
    }
}

void DeleteAllValues(HKEY   hKey)
{
    DWORD   dwCount = 0;
    DWORD   dwMaxNameLen = 0;


    // Enumerate all the existing values and delete them all.
    //Let's get the number of Entries already present and the max size of value name.
    if(RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &dwCount, &dwMaxNameLen, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        LPTSTR lpValueName = (LPTSTR) LocalAlloc(LPTR, (dwMaxNameLen + 1)*sizeof(TCHAR));

        if(lpValueName)
        {
            //Let's remove all the values already present in the UEM database.
            while(dwCount--)
            {
                DWORD dwNameLen = dwMaxNameLen + 1;
                if(RegEnumValue(hKey, dwCount, lpValueName, &dwNameLen, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    RegDeleteValue(hKey, lpValueName);
                }
                else
                {
                    //If RegQueryInfoKey worked correct, this should never happen.
                    ASSERT(0);
                }
            }
            LocalFree((HLOCAL)lpValueName);
        }
    }
}

void ClearRecentApps()
{
    HKEY   hKeyCurrentUser,
            hKeyDefault;
    DWORD  dwDisposition;
    TCHAR  szName[MAX_PATH]      = TEXT("");
    LPTSTR lpszValue             = NULL;
    DWORD  dwNameSize            = (sizeof(szName) / sizeof(TCHAR)),
           dwRegIndex            = 0,
           dwUemVersion          = VAL_UEM_VERSION,
           dwValueSize,
           dwType;

    // Open the key for the Shell MFU list
    //
    if ( RegCreateKeyEx(HKEY_CURRENT_USER, STR_REG_USERASSIST_SHELL, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKeyCurrentUser, &dwDisposition) == ERROR_SUCCESS )
    {
        // Check to see if we opened an existing key, if so delete all of the values
        //
        if(dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            DeleteAllValues(hKeyCurrentUser);
        }

        // Write out the version value to the parent key
        //
        SHSetValue(HKEY_CURRENT_USER, STR_REG_USERASSIST, STR_REG_VAL_VERSION, REG_DWORD, &dwUemVersion, sizeof(dwUemVersion));

        // Copy all of the values from the .DEFAULT registry
        //
        if ( RegOpenKeyEx(HKEY_USERS, STR_REG_USERASSIST_DEFSHELL, 0, KEY_READ, &hKeyDefault) == ERROR_SUCCESS )
        {
            // Allocate the value buffer...
            //
            lpszValue = malloc(VAL_MAX_DATA * sizeof(TCHAR));

            if ( lpszValue )
            {
                dwValueSize = VAL_MAX_DATA * sizeof(TCHAR);

                // Enumerate each value
                //
                while (RegEnumValue(hKeyDefault, dwRegIndex, szName, &dwNameSize, NULL, &dwType, (LPBYTE)lpszValue, &dwValueSize ) == ERROR_SUCCESS)
                {
                    // Set the value in the current user key
                    //
                    RegSetValueEx(hKeyCurrentUser, szName, 0, dwType, (LPBYTE) lpszValue, dwValueSize);

                    // Reset the size of the name value
                    //
                    dwNameSize = sizeof(szName) / sizeof(TCHAR);
                    dwValueSize = VAL_MAX_DATA * sizeof(TCHAR);

                    // Increment to the next value
                    //
                    dwRegIndex++;
                }

                free( lpszValue );
            }

            // Clean up the registry keys
            //
            RegCloseKey(hKeyDefault);
        }

        // Clean up the registry keys
        //
        RegCloseKey(hKeyCurrentUser);
    }

    // Reset the disposition
    //
    dwDisposition = 0;

    // Open the second key containing information in the IE MFU list
    //
    if ( RegCreateKeyEx(HKEY_CURRENT_USER, STR_REG_USERASSIST_IE, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKeyCurrentUser, &dwDisposition) == ERROR_SUCCESS )
    {
        // Check to see if we opened an existing key, if so delete all of the values
        //
        if(dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            DeleteAllValues(hKeyCurrentUser);
        }

        // Clean up the registry keys
        //
        RegCloseKey(hKeyCurrentUser);
    }
}


BOOL 
NukeUserSettings(
    VOID
    )
/*++
===============================================================================
Routine Description:

    This routine clears user specific settings from all user profiles on system:
        - clears unique settings that identify Media Player.
        - resets the ICW Completed flag to force ICW to run again.
        - deletes the MS Messenger Software\Microsoft\MessengerService\PassportBalloon value
    
Arguments:

    None.

Return Value:  
      TRUE - on success
      FALSE - if there were any errors

Remarks:
    
      Media Player regenerates these settings when they don't exist, thus
      each installation of an image will have unique Media Player IDs.

===============================================================================
--*/
{
    HKEY hKey;
    HKEY oKey;
    DWORD dwSt;
    WCHAR szKeyname[1024];
    BOOL AnyErrors = FALSE;
    INT i = 0;    
    INT iElem = 0;

    typedef struct _REGVALUES
    {
        LPTSTR szKey;
        LPTSTR szValue;
    } REGVALUES;


    REGVALUES rvList[] = 
    {
        {   TEXT("Software\\Microsoft\\MediaPlayer\\Player\\Settings"),  TEXT("Client ID")        }, // Delete unique Media Player settings.
        {   TEXT("Software\\Microsoft\\Windows Media\\WMSDK\\General"),  TEXT("UniqueID")         }, // Delete unique Media Player settings.
        {   TEXT("Software\\Microsoft\\Internet Connection Wizard"),     TEXT("Completed")        }, // Delete this key to cause ICW to run again.
        {   TEXT("Software\\Microsoft\\MessengerService"),               TEXT("PassportBalloon")  }, // Cleanup for MS Messenger.
        {   TEXT("Software\\Microsoft\\MessengerService"),               TEXT("FirstTimeUser")    }, // Cleanup for MS Messenger.
        {   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects\\Fontsmoothing"),   TEXT("DefaultApplied")    },    // Makes it so clear type setting is applied again when user logs on.
    };
    
    //
    // Enumerate HKEY_USERS
    // For each key under HKEY_USERS do the following.
    //
    while ( RegEnumKey( HKEY_USERS, i++, szKeyname, 1024) == ERROR_SUCCESS ) 
    {
        // Open the key for this user.
        //
        if ( RegOpenKeyEx( HKEY_USERS, szKeyname, 0L, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS )
        {
            for ( iElem = 0; iElem < (sizeof( rvList ) / sizeof( rvList[0] )); iElem++ )
            {
                // Delete Values from each key.
                //
                if ( RegOpenKeyEx( hKey, rvList[iElem].szKey, 0L, KEY_ALL_ACCESS, &oKey ) == ERROR_SUCCESS )
                {
                    RegDeleteValue( oKey, rvList[iElem].szValue );
                    RegCloseKey( oKey );
                }
                else
                    AnyErrors = TRUE;
            }

            RegCloseKey(hKey);
        }
        else
            AnyErrors = TRUE;
    }        
            
    return (!AnyErrors);
}


BOOL
NukeMruList(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine clears the MRU lists on the machine.

Arguments:

    None.

Return Value:

===============================================================================
--*/

{
BOOL AnyErrors = FALSE;
BOOL b;
LONG rc;
WCHAR keyname[1024];
WCHAR netname[1024];
HKEY rkey;
HKEY ukey;
HKEY nkey;
HKEY hOpenKey;
INT  i;
INT  j;

    AnyErrors = FALSE;


    //
    // Enumerate HKEY_USERS
    // For each key under HKEY_USERS clean out MRU and Netconnections
    //
    i=0;
    while ( (rc = RegEnumKey( HKEY_USERS, i, keyname, 1024)) == ERROR_SUCCESS ) {

        //
        // open this user key
        //
        rc = RegCreateKeyEx(HKEY_USERS, keyname, 0L, NULL,
                REG_OPTION_BACKUP_RESTORE,
                KEY_CREATE_SUB_KEY, NULL, &ukey, NULL);
        if(rc == NO_ERROR) {

            //
            // special case Network because of subkeys
            //
            rc = RegCreateKeyEx(ukey, L"Network", 0L, NULL,
                    REG_OPTION_BACKUP_RESTORE,
                    KEY_CREATE_SUB_KEY, NULL, &nkey, NULL);
            if (rc == NO_ERROR) {
                j=0;
                while ( (rc = RegEnumKey( nkey, j, netname, 1024)) == ERROR_SUCCESS ) {
                    // HKEY_CURRENT_USER\Network
                    rc = RegDeleteKey( nkey, netname );
                    if((rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND))
                        AnyErrors = TRUE;
                    j++; // increment network key
                }
            }

            //
            // HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Network\Persistent Connections
            //
            if (!ResetRegistryKey(
                ukey,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Network",
                L"Persistent Connections") )
                AnyErrors = TRUE;

            //
            // HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs
            //
            if (!ResetRegistryKey(
                ukey,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer",
                L"RecentDocs") )
                AnyErrors = TRUE;

            //
            // HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced,StartMenuInit
            //
            if ( ERROR_SUCCESS == RegOpenKeyEx(ukey,
                                               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                               0,
                                               KEY_ALL_ACCESS,
                                               &hOpenKey) )
            {
                // Set the value in the registry
                //
                RegDeleteValue(hOpenKey,
                               TEXT("StartMenuInit"));
    
                // Close the key
                //
                RegCloseKey(hOpenKey);
            }

            //
            // HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
            //
            if (!ResetRegistryKey(
                ukey,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer",
                L"RunMRU") )
                AnyErrors = TRUE;
        }

        i++;
    }
    return (!AnyErrors);
}


VOID
NukeEventLogs(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine clears the eventlogs.  Ignore any errors here.

Arguments:

    None.

Return Value:

===============================================================================
--*/

{
HANDLE  hEventLog;

    hEventLog = OpenEventLog( NULL, TEXT("System") );
    if (hEventLog) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }

    hEventLog = OpenEventLog( NULL, TEXT("Application") );
    if (hEventLog) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }

    hEventLog = OpenEventLog( NULL, TEXT("Security") );
    if (hEventLog) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }

}

VOID
NukeSmsSettings(
    VOID
    )
/*++
===============================================================================
Routine Description:

    This routine clears the SMS client specific settings on system:
        - clears unique settings for SMS from the registry and ini files.
    
Arguments:

    None.

Return Value:  
      None. 

Remarks:
    
      Part of the clearing requires blanking out certain INI files.

===============================================================================
--*/
{
    HKEY  hkSms = NULL;
    TCHAR szWindowsDir[MAX_PATH] = TEXT("\0"),
          szIniFile[MAX_PATH] = TEXT("\0"),
          szDatFile[MAX_PATH] = TEXT("\0"),
          szDefaultValue[] = TEXT("\0");

    // Remove HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
    //
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\SMS\\Client\\Configuration\\Client Properties"), &hkSms)) {
        //
        // ISSUE-2002/02/26-brucegr: Should be adding one character to length field for null-terminator
        //
        RegSetValueEx(hkSms, TEXT("SMS Unique Identifier"), 0, REG_SZ, (LPBYTE)szDefaultValue, (lstrlen(szDefaultValue)*sizeof(TCHAR)));
        RegCloseKey(hkSms);
    }

    // Clear the SMS Unique ID from INI files
    //
    if ( GetWindowsDirectory(szWindowsDir, MAX_PATH) && *szWindowsDir )
    {
        StringCchCopy ( szIniFile, AS ( szIniFile ), szWindowsDir);
        OPKAddPathN (szIniFile, TEXT("ms\\sms\\core\\data"), AS ( szIniFile ) );

        if (PathIsDirectory(szIniFile)) {
            OPKAddPathN(szIniFile, TEXT("sms1x.ini"), AS ( szIniFile ));
            WritePrivateProfileString(TEXT("SMS"), TEXT("SMS Unique ID"), TEXT(""), szIniFile);
        }
        StringCchCopy ( szIniFile, AS ( szIniFile ), szWindowsDir);
        if (PathIsDirectory(szIniFile)) {
            OPKAddPathN(szIniFile, TEXT("smscfg.ini"), AS ( szIniFile ) );
            WritePrivateProfileString(TEXT("Configuration - Client Properties"), TEXT("SMS Unique Identifier"), TEXT(""), szIniFile);
        }
    
        // Make sure we can delete the file SMS Unique ID file 
        //
        StringCchCopy (szDatFile, AS ( szDatFile ), szWindowsDir);
        OPKAddPathN(szDatFile, TEXT("ms\\sms\\core\\data"), AS ( szDatFile ) );
        if (PathIsDirectory(szDatFile)) {
            OPKAddPathN(szDatFile, TEXT("smsuid.dat"), AS ( szDatFile ) );
            SetFileAttributes(szDatFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szDatFile);
        }
    }
}

void RemoveDir(LPCTSTR lpDirectory, BOOL fDeleteDir)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;

    // Validate the parameters.
    //
    if ( ( lpDirectory == NULL ) ||
         ( *lpDirectory == TEXT('\0') ) ||
         ( !SetCurrentDirectory(lpDirectory) ) )
    {
        return;
    }

    //
    // ISSUE-2002/02/26-brucegr: We just called SetCurrentDirectory above!
    //

    // Process all the files and directories in the directory passed in.
    //
    SetCurrentDirectory(lpDirectory);

    if ( (hFile = FindFirstFile(TEXT("*"), &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // First check to see if this is a file (not a directory).
            //
            if ( !( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                // Make sure we clear the readonly flag 
                //
                SetFileAttributes(FileFound.cFileName, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(FileFound.cFileName);
            }
            // Otherwise, make sure the directory is not "." or "..".
            //
            else if ( ( lstrcmp(FileFound.cFileName, TEXT(".")) ) &&
                      ( lstrcmp(FileFound.cFileName, TEXT("..")) ) )
            {
                RemoveDir(FileFound.cFileName, TRUE);
            }

        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    // Go to the parent directory and remove the current one.
    // We have to make sure and reset the readonly attributes
    // on the dir also.
    //
    SetCurrentDirectory(TEXT(".."));
    if (fDeleteDir)
    {
        SetFileAttributes(lpDirectory, FILE_ATTRIBUTE_NORMAL);
        RemoveDirectory(lpDirectory);
    }
}

//
//  DeleteCacheCookies was copy'n'pasted from Cachecpl.cpp
//
//     Any changes to either version should probably be transfered to both.
//     Minor difference from new/delete (.cpp) to LocalAlloc/LocalFree (.c).
//
BOOL DeleteCacheCookies()
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) LocalAlloc(LPTR, sizeof(BYTE) * dwEntrySize);
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        LocalFree(lpCacheEntry);
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                LocalAlloc(LPTR, sizeof(BYTE) * dwEntrySize );
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY)
            DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
            
        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            LocalFree(lpCacheEntry);
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    LocalAlloc(LPTR, sizeof(BYTE) * dwEntrySize );
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}

void ClearIEHistory (  
    VOID 
) 
/*++
===============================================================================
Routine Description:

    This routine clears the IE History.

Arguments:

    None.

Return Value:

===============================================================================
--*/

{
    IUrlHistoryStg2*    pHistory = NULL ;  // We need this interface for clearing the history.
    HRESULT             hr;
    HKEY                hkeyInternational = NULL;
    ULONG_PTR           lres = 0;

    // Remove all the entries here.
    RegDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"));
    RegDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"));

    // this broadcast will nuke the address bars
    SendMessageTimeoutW( HWND_BROADCAST, 
                         WM_SETTINGCHANGE, 
                         0, 
                         (LPARAM)TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"), 
                         SMTO_ABORTIFHUNG | SMTO_NOTIMEOUTIFNOTHUNG, 
                         30 * 1000, 
                         &lres);
    
    SendMessageTimeoutW( HWND_BROADCAST,
                         WM_SETTINGCHANGE, 
                         0, 
                         (LPARAM)TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"),
                         SMTO_ABORTIFHUNG | SMTO_NOTIMEOUTIFNOTHUNG, 
                         30 * 1000, 
                         &lres);
    
    // we remove these reg values when history is
    // cleared.  This will reset the encoding menu UI to the defaults.

    if (ERROR_SUCCESS == 
            RegOpenKeyEx(
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Internet Explorer\\International"),
                0,
                KEY_WRITE,
                &hkeyInternational))
    {
        ASSERT(hkeyInternational);

        RegDeleteValue(hkeyInternational, TEXT("CpCache"));
        RegDeleteValue(hkeyInternational, TEXT("CNum_CpCache"));
        
        RegCloseKey(hkeyInternational);
    }
    // 
    // Init the Com Library 
    //
    CoInitialize(NULL);

    // Load the correct Class and request IUrlHistoryStg2
    hr = CoCreateInstance( &CLSID_CUrlHistory,
                          NULL, 
                          CLSCTX_INPROC_SERVER,
                          &IID_IUrlHistoryStg2,
                          &pHistory );

    // 
    // If succeeded Clear the history
    if (SUCCEEDED(hr))
    {
         // Clear the IE History
         hr = IUrlHistoryStg2_ClearHistory(pHistory);
    }

    // Release our reference to the 
    if ( pHistory ) 
    {
        IUrlHistoryStg2_Release(pHistory);
    }

    // Un Init the Com Library 
    CoUninitialize();
}

void NukeTemporaryFiles(
    VOID
    ) 

/*++
===============================================================================
Routine Description:

    This routine clears the temporary folder and recycle bin for template user.

Arguments:

    None.

Return Value:

===============================================================================
--*/

{
    TCHAR   szTempDir[MAX_PATH]          = TEXT(""), 
            szTempInetFilesDir[MAX_PATH] = TEXT(""),
            szProfileDir[MAX_PATH]       = TEXT(""),
            szCurrentDir[MAX_PATH]       = TEXT("");
    DWORD   dwSize;
    HANDLE  hFile;
    WIN32_FIND_DATA FileFound;
        
    // 
    // Save our current directory, so we can set it back later.
    //
    GetCurrentDirectory(MAX_PATH, szCurrentDir);

    dwSize = sizeof(szProfileDir)/sizeof(szProfileDir[0]);
    if ( !GetProfilesDirectory(szProfileDir, &dwSize) && 
         !SetCurrentDirectory(szProfileDir) )
        return;

    //
    // ISSUE-2002/02/26-brucegr: We just called SetCurrentDirectory above!
    //

    //
    // Clear the I.E History folder.
    //
    ClearIEHistory (  ) ;

    //
    // Clear tmp files for all profile directories.
    //
    SetCurrentDirectory(szProfileDir);
    if ( (hFile = FindFirstFile(TEXT("*"), &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // Otherwise, make sure the directory is not "." or "..".
            //
            if ( (FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                ( lstrcmp(FileFound.cFileName, TEXT(".")) ) &&
                ( lstrcmp(FileFound.cFileName, TEXT("..")) ) )
            {
                TCHAR szTemp1[MAX_PATH] = TEXT("");

                //
                // Clear the Temp folder.
                //
                if ( LoadString(ghInstance, IDS_TEMP_DIR, szTemp1, MAX_PATH) )
                {
                    StringCchCopy (szTempDir, AS ( szTempDir ), szProfileDir);
                    OPKAddPathN(szTempDir, FileFound.cFileName, AS ( szTempDir ) );
                    OPKAddPathN(szTempDir, szTemp1, AS ( szTempDir ) );
                    RemoveDir(szTempDir, FALSE);
                }

                //
                // Clear the History.IE5 folder.
                //
                if ( LoadString(ghInstance, IDS_HISTORY_DIR_IE5, szTemp1, MAX_PATH) )
                {
                    StringCchCopy (szTempDir, AS ( szTempDir ), szProfileDir);
                    OPKAddPathN(szTempDir, FileFound.cFileName, AS ( szTempDir ) );
                    OPKAddPathN(szTempDir, szTemp1, AS ( szTempDir ) );
                    RemoveDir(szTempDir, TRUE);
                }
       
                //
                // Clear the History folder.
                //
                if ( LoadString(ghInstance, IDS_HISTORY_DIR, szTemp1, MAX_PATH) )
                {
                    StringCchCopy (szTempDir, AS ( szTempDir ), szProfileDir);
                    OPKAddPathN(szTempDir, FileFound.cFileName, AS ( szTempDir ) );
                    OPKAddPathN(szTempDir, szTemp1, AS ( szTempDir ) );
                    RemoveDir(szTempDir, FALSE);
                }
       
                //
                // Clear the Local Settings\Application Data\Microsoft\Credentials.
                //
                if ( LoadString(ghInstance, IDS_SID_DIR1, szTemp1, MAX_PATH) )
                {
                    StringCchCopy (szTempDir, AS ( szTempDir ), szProfileDir);
                    OPKAddPathN(szTempDir, FileFound.cFileName, AS ( szTempDir ) );
                    OPKAddPathN(szTempDir, szTemp1, AS ( szTempDir ) );
                    RemoveDir(szTempDir, FALSE);
                }

                //
                // Clear the Application Data\Microsoft\Credentials
                //
                if ( LoadString(ghInstance, IDS_SID_DIR2, szTemp1, MAX_PATH) )
                {
                    StringCchCopy (szTempDir, AS ( szTempDir ), szProfileDir);
                    OPKAddPathN(szTempDir, FileFound.cFileName, AS ( szTempDir ) );
                    OPKAddPathN(szTempDir, szTemp1, AS ( szTempDir ) );
                    RemoveDir(szTempDir, FALSE);
                }

                //
                // Clear the Application Data\Microsoft\Crypto\\RSA.
                //
                if ( LoadString(ghInstance, IDS_SID_DIR3, szTemp1, MAX_PATH) )
                {
                    StringCchCopy (szTempDir, AS ( szTempDir ), szProfileDir);
                    OPKAddPathN(szTempDir, FileFound.cFileName, AS ( szTempDir ) );
                    OPKAddPathN(szTempDir, szTemp1, AS ( szTempDir ) );
                    RemoveDir(szTempDir, FALSE);
                }

                //
                // Clear the Temporary Internet files and cookies.
                //
                if ( LoadString(ghInstance, IDS_TEMP_INTERNET_DIR, szTemp1, MAX_PATH) )
                {
                    StringCchCopy ( szTempInetFilesDir, AS ( szTempInetFilesDir), szProfileDir);
                    OPKAddPathN(szTempInetFilesDir, FileFound.cFileName, AS ( szTempInetFilesDir ) );
                    OPKAddPathN(szTempInetFilesDir, szTemp1, AS ( szTempInetFilesDir ) );
                    FreeUrlCacheSpace(szTempInetFilesDir, 100, 0 /*remove all*/);
                    DeleteCacheCookies();
                    RemoveDir(szTempInetFilesDir, FALSE);
                }
            }
        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    // 
    // Set back our current directory.
    //
    SetCurrentDirectory(szCurrentDir);

    //
    // Clear any recycle bin files.
    //
    SHEmptyRecycleBin(NULL, NULL, SHERB_NOSOUND|SHERB_NOCONFIRMATION|SHERB_NOPROGRESSUI);

}


DWORD NukeLKGControlSet(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine will delete the last known good control set from the registry.
    The reason is LKG doesn't make sense for the first boot. Also, if the BIOS
    clock of a cloned machine is earlier than the creation time of a cloned
    image, any change made to the CurrentControlSet before adjusting the clock
    will not sync to LKG.

    The code is adapted from base\screg\sc\server\bootcfg.cxx
    Since we can't delete LKG directly because quite a few of the subkeys are
    in use, this routine changes the system\select!LastKnownGood to a new Id
    instead.
    
Arguments:

    None.

Return Value:

    NO_ERROR or other WIN32 error.

===============================================================================
--*/

{
    //
    // ISSUE-2002/02/26-brucegr: Should rewrite to get highest DWORD value in Select key, then increment and write to LKG.
    //
#define SELECT_KEY      L"system\\select"

#define CURRENT_ID  0
#define DEFAULT_ID  1
#define LKG_ID      2
#define FAILED_ID   3
#define NUM_IDS     4

    //
    // ISSUE-2002/02/26-brucegr: Get rid of NUM_IDS and use ARRAYSIZE macro!
    //
    static const LPCWSTR SelectValueNames[NUM_IDS] =
    {
        L"Current",
        L"Default",
        L"LastKnownGood",
        L"Failed"
    };

    DWORD   idArray[NUM_IDS];
    HKEY    selectKey  = 0;
    DWORD   status     = NO_ERROR;
    DWORD   bufferSize = 0;
    DWORD   newId      = 0;
    DWORD   i          = 0;

    //
    // Get the Select Key
    //
    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                SELECT_KEY,
                0L,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &selectKey);

    if (status != NO_ERROR)
    {
        return status;
    }

    //
    // Fill in the idArray
    //
    for (i = 0; i < NUM_IDS; i++)
    {
        bufferSize = sizeof(DWORD);
        //
        // ISSUE-2002/02/26-brucegr: Check data type matches REG_DWORD
        //
        status = RegQueryValueEx(
            selectKey,
            SelectValueNames[i],
            NULL,
            NULL,
            (LPBYTE)&idArray[i],
            &bufferSize);

        if (status != NO_ERROR)
        {
            idArray[i] = 0;
        }
    }

    status = ERROR_NO_MORE_ITEMS;

    for(newId = 1; newId < 1000; newId++)
    {
        BOOL inArray = FALSE;

        for(i = 0; i < NUM_IDS; i++)
        {
            if(idArray[i] == newId)
            {
                inArray = TRUE;
                break;
            }
        }

        if (!inArray)
        {
            status = RegSetValueEx(
                        selectKey,
                        SelectValueNames[LKG_ID],
                        0,
                        REG_DWORD,
                        (LPBYTE)&newId,
                        sizeof(DWORD));
            break;
        }
    }

    RegCloseKey(selectKey);

    return status;

}

BOOL
DeleteAdapterGuidsKeys(
    VOID
    )
{
    HKEY  hKey, hSubKey;
    DWORD dwError = NO_ERROR;
    int   i = 0;
    TCHAR SubKeyName[MAX_PATH * 2];

    //
    // Open HKLM\System\CurrentControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}
    //
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );

    if(dwError != NO_ERROR)
    {
        SetLastError(dwError);
        return FALSE;
    }

    //
    // Now enumerate all subkeys.  For each subkey delete the adapter GUID.
    //
    while( (dwError = RegEnumKey( hKey, i, SubKeyName, sizeof(SubKeyName)/sizeof(SubKeyName[0]))) == ERROR_SUCCESS)
    {
        //
        // Check if the key is a probable GUID.
        // If it's a GUID key, delete the adapter GUIDs only
        //
        if (SubKeyName[0] == TEXT('{'))
        {
            
            //
            // If we were able to delete the key,then its okay, other wise 
            // increment the counter.
            //
            if ( ( dwError = SHDeleteKey(hKey, SubKeyName) )  !=  ERROR_SUCCESS ) 
                i++;
        }
        else
        {
            // 
            // If we didn't find one go to next subkey.
            //
            i++;
        }
    }

    RegCloseKey( hKey );

    return TRUE;
}

BOOL
RemoveNetworkSettings(
    LPTSTR  lpszSysprepINFPath
    )

/*++
===============================================================================
Routine Description:

    This routine will enumerate each physical NIC, call into the netsetup
    code to save the settings, and then delete the network card.
    When a new NIC is enumerated on the target machine, netsetup will apply the
    settings that were saved away

    If the LegacyNIC != 0 value exists in SYSPREP.INF in the [Unattended] section, then
    the previous behavior will be preserved, since removing a legacy NIC card
    will not work, because it will not be re-enumerated/detected on the next boot
Arguments:

    lpszSysprepINFPath  pointer to the SYSPREP.INF file. Can be NULL, in which case
    a non-legacy NIC is assumed

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/

{
    HDEVINFO        DeviceInfoSet;
    DWORD           dwIdx;
    SP_DEVINFO_DATA DevInfoData;
    HKEY            hDevRegKey;
    DWORD           dwChar;
    DWORD           dwSize;
    FARPROC pNetSetupPrepareSysPrep = NULL;
    BOOL            DoLegacy = FALSE;

    HMODULE hNetShell = LoadLibraryA( "netshell.dll" );

    if (hNetShell) {
        pNetSetupPrepareSysPrep = GetProcAddress( hNetShell, "NetSetupPrepareSysPrep" );
        if (!pNetSetupPrepareSysPrep) {
            DoLegacy = TRUE;
            FreeLibrary( hNetShell );
        }

    }
    else {
        return FALSE;
    }

    // See if we are dealing with a legacy NIC
    if ((lpszSysprepINFPath != NULL)
         && GetPrivateProfileInt( TEXT( "Unattended" ),
                                  TEXT( "LegacyNIC" ),
                                  0,
                                  lpszSysprepINFPath)) {
        //
        // ISSUE-2002/02/26-brucegr: If we set DoLegacy to TRUE, then we don't free hNetShell!
        //
        DoLegacy = TRUE;
    }

    if (!DoLegacy)
    {
        // Call the netcfg function to save the networking settings
        pNetSetupPrepareSysPrep();

        FreeLibrary( hNetShell );

        // Enumerate and delete all phyiscal NICs
        DeviceInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_NET,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT);

        if(DeviceInfoSet == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }

        dwIdx = 0;
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        while (SetupDiEnumDeviceInfo(DeviceInfoSet, dwIdx, &DevInfoData))
        {

            hDevRegKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                              &DevInfoData,
                                              DICS_FLAG_GLOBAL,
                                              0,
                                              DIREG_DRV,
                                              KEY_READ);
            if (hDevRegKey == INVALID_HANDLE_VALUE)
            {
                // Not sure why it would ever return INVALID_HANDLE_VALUE, but 
                // we don't care and should continue.
                ++dwIdx;
                continue;
            }

            dwChar = 0;
            dwSize = sizeof(DWORD);
            RegQueryValueEx(hDevRegKey,
                            L"Characteristics",
                            NULL,
                            NULL,
                            (LPBYTE) &dwChar,
                            &dwSize);
            RegCloseKey(hDevRegKey);
            if (dwChar & NCF_PHYSICAL)
            {
                // This is one to delete
                SetupDiCallClassInstaller(DIF_REMOVE, DeviceInfoSet, &DevInfoData);
            }
            ++dwIdx;
        }

        // Cleanup
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }
    
    //
    // Delete the adapter GUIDs keys so we don't get multiple Local Area Connection # displays.
    //
    return DeleteAdapterGuidsKeys();
}

BOOL
ProcessUniquenessValue(
    LPTSTR lpszDLLPath
    )
{
    BOOL bRet = FALSE;

    //
    // Make sure we were passed something valid...
    //
    if ( lpszDLLPath && *lpszDLLPath )
    {
        LPWSTR pSrch;
        
        //
        // Look for the comma that separates the DLL and the entrypoint...
        //
        if ( pSrch = wcschr( lpszDLLPath, L',' ) )
        {
            CHAR szEntryPointA[MAX_PATH] = {0};

            // We found one, now NULL the string at the comma...
            //
            *(pSrch++) = L'\0';

            //
            // If there's still something after the comma, and we can convert it 
            // into ANSI for GetProcAddress, then let's proceed...
            //
            if ( *pSrch &&
                 ( 0 != WideCharToMultiByte( CP_ACP,
                                             0,
                                             pSrch,
                                             -1,
                                             szEntryPointA,
                                             ARRAYSIZE(szEntryPointA),
                                             NULL,
                                             NULL ) ) )
            {
                HMODULE hModule = NULL;

                try 
                {
                    //
                    // Load and call the entry point.
                    //
                    if ( hModule = LoadLibrary( lpszDLLPath ) )
                    {
                        FARPROC fpEntryPoint;
                        
                        if ( fpEntryPoint = GetProcAddress(hModule, szEntryPointA) )
                        {
                            //
                            // Do it, ignoring any return value/errors
                            //
                            fpEntryPoint();

                            //
                            // We made it this far, consider this a success...
                            //
                            bRet = TRUE;
                        }
                    }
                } 
                except(EXCEPTION_EXECUTE_HANDLER) 
                {
                    //
                    // We don't do anything with the exception code...
                    //
                }

                //
                // Free the library outside the try/except block in case the function faulted.
                //
                if ( hModule ) 
                {
                    FreeLibrary( hModule );
                }
            }
        }
    }

    return bRet;
}

VOID 
ProcessUniquenessKey(
    BOOL fBeforeReseal
    )
{
    HKEY   hKey;
    TCHAR  szRegPath[MAX_PATH] = {0};
    LPTSTR lpszBasePath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\SysPrep\\");

    //
    // Build a path to the registry key we want to process...
    //
    lstrcpyn( szRegPath, lpszBasePath, ARRAYSIZE(szRegPath) );
    lstrcpyn( szRegPath + lstrlen(szRegPath), 
              fBeforeReseal ? TEXT("SysprepBeforeExecute") : TEXT("SysprepAfterExecute"),
              ARRAYSIZE(szRegPath) - lstrlen(szRegPath) );

    //
    // We want to make sure an Administrator is doing this, so get KEY_ALL_ACCESS
    //
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szRegPath,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey ) )
    {
        DWORD dwValues          = 0,
              dwMaxValueLen     = 0,
              dwMaxValueNameLen = 0;
        //
        // Query the key to find out some information we care about...
        //
        if ( ( ERROR_SUCCESS == RegQueryInfoKey( hKey,                  // hKey
                                                 NULL,                  // lpClass
                                                 NULL,                  // lpcClass
                                                 NULL,                  // lpReserved
                                                 NULL,                  // lpcSubKeys
                                                 NULL,                  // lpcMaxSubKeyLen
                                                 NULL,                  // lpcMaxClassLen
                                                 &dwValues,             // lpcValues
                                                 &dwMaxValueNameLen,    // lpcMaxValueNameLen
                                                 &dwMaxValueLen,        // lpcMaxValueLen
                                                 NULL,                  // lpcbSecurityDescriptor
                                                 NULL ) ) &&            // lpftLastWriteTime
             ( dwValues > 0 ) &&
             ( dwMaxValueNameLen > 0) &&
             ( dwMaxValueLen > 0 ) )
        {
            //
            // Allocate buffers large enough to hold the data we want...
            //
            LPBYTE lpData      = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwMaxValueLen );
            LPTSTR lpValueName = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, ( dwMaxValueNameLen + 1 ) * sizeof(TCHAR) );
            
            //
            // Make sure we could allocate our buffers... otherwise bail out
            //
            if ( lpData && lpValueName )
            {
                DWORD dwIndex   = 0;
                BOOL  bContinue = TRUE;

                //
                // Enumerate through the key values and call the DLL entrypoints...
                //
                while ( bContinue )
                {
                    DWORD dwType,
                          cbData         = dwMaxValueLen,
                          dwValueNameLen = dwMaxValueNameLen + 1;

                    bContinue = ( ERROR_SUCCESS == RegEnumValue( hKey,
                                                                 dwIndex++,
                                                                 lpValueName,
                                                                 &dwValueNameLen,
                                                                 NULL,
                                                                 &dwType,
                                                                 lpData,
                                                                 &cbData ) );

                    //
                    // Make sure we got some data of the correct format...
                    //
                    if ( bContinue && ( REG_SZ == dwType ) && ( cbData > 0 ) )
                    {
                        //
                        // Now split up the string and call the entrypoints...
                        //
                        ProcessUniquenessValue( (LPTSTR) lpData );
                    }
                }
            }

            //
            // Clean up any buffers we may have allocated...
            //
            if ( lpData )
            {
                HeapFree( GetProcessHeap(), 0, lpData );
            }

            if ( lpValueName )
            {
                HeapFree( GetProcessHeap(), 0, lpValueName );
            }
        }

        //
        // Close the key...
        //
        RegCloseKey( hKey );
    }
}

VOID
RunExternalUniqueness(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine will call out to any external dlls that will allow
    3rd party apps to make their stuff unique.

    We'll look in 2 inf files:
    %windir%\inf\minioc.inf
    %systemroot%\sysprep\provider.inf

    In each of these files, we'll look in the [SysprepBeforeExecute] section
    for any entries.  The entries must look like:
    dllname,entrypoint

    We'll load the dll and call into the entry point.  Errors are ignored.

Arguments:

    None.

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/

{
FARPROC     MyProc;
WCHAR       InfPath[MAX_PATH];
WCHAR       DllName[MAX_PATH];
WCHAR       EntryPointNameW[MAX_PATH];
CHAR        EntryPointNameA[MAX_PATH];
HINF        AnswerInf;
HMODULE     DllHandle;
INFCONTEXT  InfContext;
DWORD       i;
PCWSTR      SectionName = L"SysprepBeforeExecute";
BOOL        LineExists;

    //
    // =================================
    // Minioc.inf
    // =================================
    //

    //
    // Build the path.
    //
    if (!GetWindowsDirectory( InfPath, MAX_PATH ))
        return;

    StringCchCat( InfPath, AS ( InfPath ), TEXT("\\inf\\minioc.inf") );

    //
    // See if he's got an entry
    // section.
    //
    // NTRAID#NTBUG9-551511-2002/02/26-brucegr: We should make sure that MINIOC.INF is digitally signed before opening!
    // ISSUE-2002/02/26-brucegr: You can OR in both INF style bits! 
    //
    AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );
    if( AnswerInf == INVALID_HANDLE_VALUE ) {
        //
        // Try an old-style.
        //
        AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_OLDNT, NULL );
    }

    if( AnswerInf != INVALID_HANDLE_VALUE ) {
        //
        // Process each line in our section
        //
        LineExists = SetupFindFirstLine( AnswerInf, SectionName, NULL, &InfContext );

        while( LineExists ) {

            //
            // ISSUE-2002/02/26-brucegr: Why not use SetupGetStringFieldA with EntryPointNameA?
            //
            if( SetupGetStringField( &InfContext, 1, DllName, sizeof(DllName)/sizeof(TCHAR), NULL) ) {
                if( SetupGetStringField( &InfContext, 2, EntryPointNameW, sizeof(EntryPointNameW)/sizeof(TCHAR), NULL )) {

                    DllHandle = NULL;

                    //
                    // Load and call the entry point.
                    //
                    try {
                        if( DllHandle = LoadLibrary(DllName) ) {

                            //
                            // No Unicode version of GetProcAddress(). Convert string to ANSI.
                            //
                            i = WideCharToMultiByte(CP_ACP,0,EntryPointNameW,-1,EntryPointNameA,MAX_PATH,NULL,NULL);

                            if( MyProc = GetProcAddress(DllHandle, EntryPointNameA) ) {
                                //
                                // Do it, ignoring any return value/errors
                                //
                                MyProc();
                            }
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                    }

                    if( DllHandle ) {
                        FreeLibrary( DllHandle );
                    }

                }
            }

            LineExists = SetupFindNextLine(&InfContext,&InfContext);
        }

        SetupCloseInfFile( AnswerInf );
    }

    //
    // ISSUE-2002/02/26-brucegr: Why are we duplicating the same INF processing code from above?!!!!
    //


    //
    // =================================
    // Provider.inf
    // =================================
    //

    ProcessUniquenessKey( TRUE );
}

BOOL PrepForSidGen
(
    void
)
{
    DWORD           l;
    HKEY            hKey, hKeyNew;
    DWORD           d;
    DWORD           Size;
    DWORD           Type;
    TCHAR           SetupExecuteValue[1024];

    //
    // =================================
    // Set the value of the SetupExecute subkey.
    // =================================
    //

    //
    // Open the Session Manager key.
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );

    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }


    //
    // Set the Key.
    //
    StringCchCopy ( SetupExecuteValue, AS ( SetupExecuteValue ), TEXT(SYSCLONE_PART2) );
    SetupExecuteValue[lstrlen(SetupExecuteValue) + 1] = L'\0';

    //
    // ISSUE-2002/02/26-brucegr: Are we stomping anything that is already in SetupExecute?
    //
    l = RegSetValueEx(hKey,
                      TEXT("SetupExecute"),
                      0,
                      REG_MULTI_SZ,
                      (CONST BYTE *)SetupExecuteValue,
                      (lstrlen( SetupExecuteValue ) + 2) * sizeof(TCHAR));
    RegCloseKey(hKey);
    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    //
    // =================================
    // Let's bump the size of the registry quota a bit so that
    // setupcl.exe can run.  He'll pop it back down.
    // =================================
    //

    //
    // Open HKLM\System\CurrentControlSet\Control
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );
    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    //
    // Query the value of the RegistrySizeLimit Key.
    //
    l = RegQueryValueEx(hKey,
                        TEXT("RegistrySizeLimit"),
                        NULL,
                        &Type,
                        (LPBYTE)&d,
                        &Size);

    if( l == ERROR_SUCCESS )
    {
        //
        // Got it.  Bump the value.
        //
        d += REGISTRY_QUOTA_BUMP; //Increase by some amount to load the repair hives
        //
        // Set the key.
        //
        l = RegSetValueEx(hKey,
                          TEXT("RegistrySizeLimit"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&d,
                          sizeof(DWORD) );
        if(l != NO_ERROR)
        {
           SetLastError(l);
           //
           // ISSUE-2002/02/26-brucegr: Need to call RegCloseKey!
           //
           return FALSE;
        }
    }
    else
    {
         //
        // Darn!  The value probably doesn't exist.
        // Ignore it and expect stuff to work. Only repair hives cannot be fixed
        //

    }

    RegCloseKey(hKey);

    //
    // =================================
    // See if anyone wants to reset uniqueness
    // in their component.  
    // =================================
    //
    RunExternalUniqueness();

    return TRUE;
}

BOOL SetCloneTag
(
    void
)
{
    HKEY    hKey;
    DWORD   l;
    TCHAR   DateString[1024];
    time_t  ltime;
    LPTSTR  lpszDate;

    //
    // =================================
    // Put a unique identifier into the registry so we know this machine
    // has been cloned.
    // =================================
    //

    //
    // Open HKLM\System\Setup
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\Setup"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );

    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    //
    // Set HKLM\System\Setup\CloneTag.  We're going to
    // pickup a date string and write it out.
    //
    time( &ltime );
    ZeroMemory(DateString, sizeof(DateString));
    //
    // ISSUE-2002/02/26-brucegr: This function smells horrid!
    //
    lpszDate = _wctime( &ltime );
    if ( lpszDate )
    {
        StringCchCopy( DateString, AS ( DateString ), lpszDate );
        l = RegSetValueEx(hKey,
                            TEXT("CloneTag"),
                            0,
                            REG_MULTI_SZ,
                            (CONST BYTE *)DateString,
                            (lstrlen( DateString ) + 2) * sizeof(TCHAR));
    }

    RegCloseKey(hKey);
    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    return (TRUE);
}


BOOL SetBigLbaSupport
(
    LPTSTR lpszSysprepINFPath
)
{
    HKEY    hKey;
    DWORD   dwError, dwValue;
    TCHAR   szEnableBigLba[MAX_PATH] = TEXT("\0");

    
    if ( ( lpszSysprepINFPath ) && 
         ( *lpszSysprepINFPath ) &&
         ( GetPrivateProfileString( TEXT( "Unattended" ), TEXT( "EnableBigLba" ), L"", szEnableBigLba, sizeof(szEnableBigLba)/sizeof(TCHAR), lpszSysprepINFPath ) ) )
    {
        // They would like to enable BigLba support.  If the user does not specify "Yes" for this key, we do not
        // touch the key (even if they specify "No").  This is By Design
        //
        if (LSTRCMPI(szEnableBigLba, TEXT("YES")) == 0)
        {
            // Open base key and subkey
            //
            dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT("System\\CurrentControlSet\\Services\\Atapi\\Parameters"),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKey );
            
            // Determine if opening the key was successful
            //
            if(dwError != NO_ERROR)
            {
                SetLastError(dwError);
                return FALSE;
            }

            // Set the value in the registry
            //
            dwValue = 1;
            dwError = RegSetValueEx(hKey,
                              TEXT("EnableBigLba"),
                              0,
                              REG_DWORD,
                              (CONST BYTE *)&dwValue,
                              sizeof(DWORD));
            
            // Close the key
            //
            RegCloseKey(hKey);

            // Return the error if the SetValue failed
            //
            if(dwError != NO_ERROR)
            {
                SetLastError(dwError);
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL RemoveTapiSettings
(
    LPTSTR  lpszSysprepINFPath
)
{
    HKEY    hKey;
    DWORD   dwError, dwValue;
    TCHAR   szTapiConfigured[MAX_PATH]  = TEXT("\0"),
            szKeyPath[MAX_PATH]         = TEXT("\0");

    
    if ( ( lpszSysprepINFPath ) && 
         ( *lpszSysprepINFPath ) &&
         ( GetPrivateProfileString( TEXT( "Unattended" ), TEXT( "TapiConfigured" ), TEXT(""), szTapiConfigured, sizeof(szTapiConfigured)/sizeof(TCHAR), lpszSysprepINFPath ) ) )
    {

        // Only if the user specifies No will we remove the registry tapi settings
        //
        if (LSTRCMPI(szTapiConfigured, TEXT("NO")) == 0)
        {
            // Open base key and subkey
            //
            dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKey );
            
            // Determine if opening the key was successful
            //
            if(dwError != NO_ERROR)
            {
                SetLastError(dwError);
                return FALSE;
            }
            
            // We enumerate the locations keys and delete any subkeys
            //
            while ( RegEnumKey(hKey, 0, szKeyPath, sizeof(szKeyPath)/sizeof(TCHAR)) == ERROR_SUCCESS )
            {
                // Delete the key and all subkeys
                //
                //
                // NTRAID#NTBUG9-551815-2002/02/26-brucegr: If delete fails, should increment RegEnumKey index
                //
                SHDeleteKey(hKey, szKeyPath) ;
            }

            // Close the key
            //
            RegCloseKey(hKey);
        }
    }

    return TRUE;
}


//
// =================================
// Modify the HKLM\System\Setup\DiskDuplicator Key appropriately.
// =================================
//
BOOL SetOEMDuplicatorString
(
    LPTSTR  lpszSysprepINFPath
)
{
    TCHAR   szOEMDuplicatorString[256];
    DWORD   l;
    HKEY    hKey;

    ZeroMemory(szOEMDuplicatorString, sizeof(szOEMDuplicatorString));

    // See if the DiskDuplicator string is present in the
    // unattend file.
    GetPrivateProfileString( TEXT( "GuiUnattended" ),
                             TEXT( "OEMDuplicatorString" ),
                             L"",
                             szOEMDuplicatorString,
                             sizeof(szOEMDuplicatorString)/sizeof(TCHAR),
                             lpszSysprepINFPath );

    if( szOEMDuplicatorString[0] )
    {
        //
        // ISSUE-2002/02/26-brucegr: This doesn't ensure double termination for REG_MULTI_SZ...
        //
        // Ensure it is not bigger than 255 chars
        szOEMDuplicatorString[255] = TEXT('\0');

        // Open HKLM\System\Setup
        l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\Setup"),
                          0,
                          KEY_ALL_ACCESS,
                          &hKey );

        if(l != NO_ERROR)
        {
            SetLastError(l);
            return FALSE;
        }

        l = RegSetValueEx(hKey,
                          TEXT( "OEMDuplicatorString" ),
                          0,
                          REG_MULTI_SZ,
                          (CONST BYTE *)szOEMDuplicatorString,
                          (lstrlen( szOEMDuplicatorString ) + 2) * sizeof(TCHAR));
        RegCloseKey(hKey);
        if(l != NO_ERROR)
        {
            SetLastError(l);
            return FALSE;
        }
    }

    return (TRUE);
}

// Reset OOBE settings so it doesn't think it ran already
//
void ResetOobeSettings()
{
    HKEY hkOobe;
    TCHAR szOobeInfoFile[MAX_PATH];

    // Remove HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\OOBE
    //
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"), &hkOobe)) {
        //
        // ISSUE-2002/02/26-brucegr: Why get lError?  It's not used
        //
        LONG lError = SHDeleteKey(hkOobe, TEXT("OOBE"));
        RegCloseKey(hkOobe);
    }

    // Build the path to oobeinfo.ini if oobe directory exists for personal
    //
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No error checking for GetSystemDirectory
    //
    GetSystemDirectory(szOobeInfoFile, MAX_PATH);
    OPKAddPathN (szOobeInfoFile, TEXT("oobe"), AS ( szOobeInfoFile ) );
    if (PathIsDirectory(szOobeInfoFile)) {
        OPKAddPathN(szOobeInfoFile, TEXT("oobeinfo.ini"), AS ( szOobeInfoFile ) );

        // Remove the RetailOOBE key in oobeinfo.ini
        //
        WritePrivateProfileString(TEXT("StartupOptions"), TEXT("RetailOOBE"), NULL /*Remove it*/, szOobeInfoFile);
    }
}


/*++
===============================================================================
Routine Description:

    This routine will setup the first application to run when the machine
    with the image applied to it is run.

    The first run application will either be setup, in MiniSetup mode, or MSOOBE

    The decision for what it will be is based on the product type.

    For Personal/Professional, MSOOBE
    For Professional, default will be MSOOBE, but can be overriden by the OEM to be
    MiniSetup
    For Server, and DTC, MiniSetup


Arguments:

    None.

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/
BOOL SetupFirstRunApp
(
    void
)
{
    DWORD           dwError;
    DWORD           dwValue;
    HKEY            hKeySetup;
    TCHAR           Value[MAX_PATH + 1]; // +1 is for second NULL char at end of REG_MULTI_SZ reg type
    OSVERSIONINFOEX verInfo;
    BOOL            bUseMSOOBE = FALSE, bPro = FALSE;

    // Open HKLM\System\Setup
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\Setup"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKeySetup );

    if(dwError != NO_ERROR)
    {
        SetLastError(dwError);
        return FALSE;
    }


    // Check the product type, to determine what program we should run
    if (IsPersonalSKU() || (bPro = IsProfessionalSKU())) {
        bUseMSOOBE = TRUE;

        if (bMiniSetup == TRUE && bPro)
            bUseMSOOBE = FALSE;
    }
    else
        bUseMSOOBE = FALSE;

    // Start OOBE on next boot
    //
    if (bUseMSOOBE)
    {
        //
        // ISSUE-2002/02/26-brucegr: If anything fails, machine is screwed.  Should restore settings on failure?
        //

        // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
        dwValue = SETUPTYPE_NOREBOOT;
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SetupType"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(DWORD));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // Set these keys for OEM
        //
        dwValue = 1;
        dwError = RegSetValueEx(hKeySetup, TEXT("MiniSetupInProgress"), 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SystemSetupInProgress"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
        dwError = RegSetValueEx(hKeySetup, TEXT("OobeInProgress"), 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // =================================
        // Modify the HKLM\System\Setup\CmdLine key to run MSBOOBE
        // =================================
        ExpandEnvironmentStrings(TEXT("%SystemRoot%\\System32\\oobe\\msoobe.exe /f"), Value, sizeof(Value)/sizeof(Value[0]));
        Value[lstrlen(Value) + 1] = L'\0';

        dwError = RegSetValueEx(hKeySetup,
                          TEXT("CmdLine"),
                          0,
                          REG_MULTI_SZ,
                          (CONST BYTE *)Value,
                          (lstrlen( Value ) + 2) * sizeof(TCHAR));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
    }
    else
    {
        //
        // ISSUE-2002/02/26-brucegr: We are duplicating some of the above code again!
        //

        // Start MiniSetup on next boot
        //

        //
        // =================================
        // Modify the HKLM\System\Setup\SetupType Key appropriately (set it to 1 so we
        // go into GUI-mode setup as if this were a full install.
        // =================================
        //
        dwValue= SETUPTYPE;
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SetupType"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        //
        // =================================
        // Modify the HKLM\System\Setup\SystemSetupInProgress.
        // =================================
        //
        dwValue = 1;
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SystemSetupInProgress"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(dwValue));

        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // Setup for PnP
        if( PnP )
        {
            dwValue = 1;
            dwError = RegSetValueEx(hKeySetup,
                               TEXT("MiniSetupDoPnP"),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&dwValue,
                               sizeof(dwValue) );
            if(dwError != NO_ERROR)
            {
                RegCloseKey(hKeySetup);
                SetLastError(dwError);
                return FALSE;
            }
        }

        //
        // =================================
        // Create HKLM\System\Setup\MiniSetupInProgress key and set to 1.  This tells LSA to
        // skip generating a new SID.  He wants to because he thinks we're
        // setting up a machine for the first time.  This also tells
        // a few other people (networking, ...) that we're doing a
        // boot into the mini wizard.
        // =================================
        //
        dwValue = 1;
        dwError = RegSetValueEx( hKeySetup,
                           TEXT("MiniSetupInProgress"),
                           0,
                           REG_DWORD,
                           (CONST BYTE *)&dwValue,
                           sizeof(dwValue) );
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // =================================
        // Modify the HKLM\System\Setup\CmdLine key appropriately so we do a mini
        // version of gui-mode setup.
        // =================================

        StringCchCopy (Value, AS ( Value ), TEXT("setup.exe -newsetup -mini"));
        Value[lstrlen(Value) + 1] = L'\0';

        dwError = RegSetValueEx(hKeySetup,
                          TEXT("CmdLine"),
                          0,
                          REG_MULTI_SZ,
                          (CONST BYTE *)Value,
                          (lstrlen( Value ) + 2) * sizeof(TCHAR));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
    }

    RegCloseKey(hKeySetup);
    return (TRUE);
}

BOOL
IsSetupClPresent(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine tests to see if the SID generator is present on the system.
    The SID generator will be required to run on reboot, so if it's not here,
    we need to know.

Arguments:

    None.

Return Value:

    TRUE - The SID generator is present.

    FALSE - The SID generator is not present.

===============================================================================
--*/

{
WCHAR               NewFileName[MAX_PATH];
WCHAR               OldFileName[MAX_PATH];
WIN32_FIND_DATA     findData;
HANDLE              FindHandle;
UINT                OldMode;
DWORD               Error;
WCHAR               *wstr_ptr;


    //
    // First, try and copy a setupcl.exe into the system directory.
    // If there's not one in our current directory, forget about it and
    // keep going.  The user may already have one installed.
    //
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No checking for GetSystemDirectory failure
    //
    GetSystemDirectory( NewFileName, MAX_PATH );

    StringCchCat( NewFileName, AS ( NewFileName ),  TEXT( "\\" ) );
    StringCchCat( NewFileName, AS ( NewFileName ),  TEXT(SYSCLONE_PART2) );

    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No checking for GetModuleFileName failure
    //
    GetModuleFileName(NULL,OldFileName,MAX_PATH);
    //
    // ISSUE-2002/02/26-brucegr: Use PathRemoveFileSpec instead of this horrid code
    //
    wstr_ptr = wcsrchr( OldFileName, TEXT( '\\' ) );
    if (wstr_ptr)
        *wstr_ptr = 0;

    StringCchCat( OldFileName, AS ( OldFileName ), TEXT( "\\" ) );
    StringCchCat( OldFileName, AS ( OldFileName ), TEXT(SYSCLONE_PART2) );

    if( !CopyFile( OldFileName, NewFileName, FALSE ) ) {
        Sleep( 500 );
        if( !CopyFile( OldFileName, NewFileName, FALSE ) ) {
            //
            // ISSUE-2002/02/26-brucegr: Why get the error code if we overwrite it below?
            //
            Error = GetLastError();
        }
    }

    //
    // ISSUE-2002/02/26-brucegr: NewFileName should already be constructed... this seems redundant
    //

    //
    // Generate path to the system32 directory, then tack on the
    // name of the SID generator.
    //
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No checking for GetSystemDirectory failure
    //
    GetSystemDirectory( NewFileName, MAX_PATH );

    StringCchCat( NewFileName, AS ( NewFileName ), TEXT("\\") );
    StringCchCat( NewFileName, AS ( NewFileName ), TEXT(SYSCLONE_PART2) );

    //
    // Now see if he exists...
    //

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    //
    // ISSUE-2002/02/26-brucegr: Use GetFileAttributes instead of FindFirstFile
    //

    //
    // See if he's there.
    //
    FindHandle = FindFirstFile( NewFileName, &findData );

    if(FindHandle == INVALID_HANDLE_VALUE) {
        //
        // Nope...
        //
        Error = GetLastError();
    } else {
        //
        // Yep.  Close him.
        //
        FindClose(FindHandle);
        Error = NO_ERROR;
    }

    //
    // Restore error mode.
    //
    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);

}

BOOL
CheckOSVersion(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine returns TRUE if the OS that we're running on
    meets the specified criteria.

Arguments:

    NONE

Return Value:

    TRUE - OS meets all criteria.

    FALSE - Failed to meet some criteria.

===============================================================================
--*/

{
#include <lmaccess.h>
#include <lmserver.h>

OSVERSIONINFO       OsVersion;
NET_API_STATUS      RC;
PSERVER_INFO_101    pSI;

//
// ISSUE-2002/02/26-brucegr: Remove unused variables
//
DWORD               dwLength;
LPVOID              lpData;
TCHAR               pFile[MAX_PATH];
DWORD               dwTemp;
UINT                DataLength;
PWORD               Translation;
LANGID              TargetLocale = 0,
                    SourceLocale = 0;

                    //
                    // Pick a system file that's present on both NT and Win95.
                    //
TCHAR               TARGET_TEST_FILE[MAX_PATH] = TEXT("\\kernel32.dll");

    //
    // Get the OS version.  We need to make sure we're on NT5.
    //
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: Check if GetVersionEx fails!
    //
    GetVersionEx(&OsVersion);
    if(OsVersion.dwMajorVersion < 5) {
        return( FALSE );
    }


    //
    // Make sure we're not a Domain Controller (either primary or backup)
    //
    RC = NetServerGetInfo( NULL,    // local machine
                           101,
                           (LPBYTE *)&pSI );
    //
    // ISSUE-2002/02/26-brucegr: Change this to "NERR_Success == RC"
    //
    if( !RC ) {
        //
        // We got something.  See if this might be a DC.
        //
        if( (pSI->sv101_type & SV_TYPE_DOMAIN_CTRL   ) ||
            (pSI->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) {

            //
            // He's a DC.  Fail.
            //
            return( FALSE );
        }
    }

    return( TRUE );
}

BOOL FCheckBuildMassStorageSectionFlag(TCHAR* pszSysprepInf)
{
    TCHAR szValue[MAX_PATH];
    DWORD dwReturn = 0;
    BOOL  fReturn = FALSE;

    // If key is missing we default to no, we don't want to build the section
    // but we still process the section if user manually added keys to this
    // section.
    //
    //
    // ISSUE-2002/02/26-brucegr: dwReturn isn't really used
    //
    if (dwReturn = GetPrivateProfileString(SYSPREP_SECTION, SYSPREP_BUILDMASSSTORAGE_KEY,
                            TEXT("NO"), szValue, MAX_PATH, pszSysprepInf))
    {
        if (LSTRCMPI(szValue, TEXT("YES")) == 0)
            fReturn = TRUE;
        else if (LSTRCMPI(szValue, TEXT("NO")) == 0)
            fReturn = FALSE;
    }
    return fReturn;
}

VOID BuildMassStorageSection(BOOL fForceBuild)
{
    LPDEVIDLIST lpDeviceIDList = NULL;
    DWORD       dwNumDevIDs = 0, dwGuids = 0, dwIdxDevIDs = 0;
    TCHAR       szSysPrepInf[MAX_PATH];

    GUID    rgGuids[3];
    TCHAR   *prgInfs[] = { TEXT("machine.inf"), TEXT("pnpscsi.inf"), TEXT("scsi.inf"), TEXT("mshdc.inf") };

    /* Types of mass storage devices GUIDs  */
    rgGuids[0] = GUID_DEVCLASS_SYSTEM;          /* machine.inf  */
    rgGuids[1] = GUID_DEVCLASS_SCSIADAPTER;     /* scsi.inf     */
    rgGuids[2] = GUID_DEVCLASS_HDC;             /* mshdc.inf    */

    /* Only from these inf */
    
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: Need to check GetModuleFileName return value
    //
    GetModuleFileName(NULL, szSysPrepInf, MAX_PATH);
    PathRemoveFileSpec(szSysPrepInf);
    OPKAddPathN ( szSysPrepInf, TEXT("sysprep.inf"), AS ( szSysPrepInf ) );

    // Only build if user requested it
    //
    if (!fForceBuild && !FCheckBuildMassStorageSectionFlag(szSysPrepInf))
        return;

    //
    // =================================
    // Remove [sysprepcleanup] which will be added during PopulateDeviceDatabase().
    // =================================
    //
    WritePrivateProfileSection(L"sysprepcleanup", NULL, szSysPrepInf);

    // Loop thru all the mass storage devices
    //
    for (dwGuids = 0; dwGuids < (sizeof(rgGuids) / sizeof(rgGuids[0])); dwGuids++) {
        // Build a list of mass storage devices
        //
        if (BuildDeviceIDList(SYSPREPMASSSTORAGE_SECTION,
                           szSysPrepInf,
                           (LPGUID)&rgGuids[dwGuids],
                           &lpDeviceIDList,
                           &dwNumDevIDs,
                           TRUE,
                           FALSE))
        {
            // Write the mass storage info to sysprep.inf
            //
            for(dwIdxDevIDs = 0; dwIdxDevIDs < dwNumDevIDs; ++dwIdxDevIDs)
            {
                BOOL fInfFound = FALSE;

                // Check if this inf if in our Infs table
                //
                int iCmp = 0;
                for (iCmp = 0; iCmp < (sizeof(prgInfs)/sizeof(prgInfs[0])); iCmp++) {
                    //
                    // ISSUE-2002/02/26-brucegr: Can we use something better than StrStrI?
                    //
                    if (StrStrI(lpDeviceIDList[dwIdxDevIDs].szINFFileName, prgInfs[iCmp])) {
                        fInfFound = TRUE;
                        break;
                    }
                }

                if (fInfFound) 
                {
                    // Check HardwareID first then check the CompatID
                    //
                    if (lpDeviceIDList[dwIdxDevIDs].szHardwareID[0]) 
                    {
                        // Use only the infs we care about
                        //
                        WritePrivateProfileString(SYSPREPMASSSTORAGE_SECTION,
                                                  lpDeviceIDList[dwIdxDevIDs].szHardwareID,
                                                  lpDeviceIDList[dwIdxDevIDs].szINFFileName,
                                                  szSysPrepInf);
                    }
                    else if (lpDeviceIDList[dwIdxDevIDs].szCompatibleID[0])
                    {
                        // Use only the infs we care about
                        //
                        WritePrivateProfileString(SYSPREPMASSSTORAGE_SECTION,
                                                  lpDeviceIDList[dwIdxDevIDs].szCompatibleID,
                                                  lpDeviceIDList[dwIdxDevIDs].szINFFileName,
                                                  szSysPrepInf);
                    }
                }
            }

            // Free the allocated list
            //
            LocalFree(lpDeviceIDList);
        }
    }
}

DWORD
ReArm(
      VOID
      )
/*++
===============================================================================
Routine Description:

    This routine returns either the error code or success.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - ReArm succeeded and shortcut restored.

    Error code    - ReArm failed.

===============================================================================
--*/

{
    DWORD     dwError     = ERROR_FILE_NOT_FOUND;
    BYTE      bDummy      = 1;

    typedef DWORD (WINAPI* MYPROC)(BYTE*);

    // Use Loadlibrary/GetProcAddress because Riprep needs to support Windows 2000 
    //
    HINSTANCE   hInst   = LoadLibrary(L"syssetup.dll");
    if (hInst) {
        MYPROC fnProc;
        if ( fnProc = (MYPROC)GetProcAddress(hInst, "SetupOobeBnk") ) {
            dwError = fnProc(&bDummy);
        }

        FreeLibrary(hInst);
    }

    // Return error code or success
    //
    return dwError;
}


BOOL FCommonReseal
    (
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine is the common reseal code for both Riprep and Sysprep.

Arguments:

    None.

Return Value:

    TRUE  - success
    FALSE - failure

Remarks:

    This routine should only cleanup registry keys as it is being called by
    AdjustRegistry() which is the last step of Riprep after the network is
    removed.

===============================================================================
--*/

{
    HKEY hKey = NULL;
    SC_HANDLE schService;
    SC_HANDLE schSystem;
    TCHAR szUrllog[MAX_PATH];
    DWORD dwLen;

    //
    // ISSUE-2002/02/26-brucegr: Make sure all intermediate return points are necessary!
    //

    //
    // =================================
    // Clear the MRU list on the machine.
    // =================================
    //
    NukeMruList();

    //
    // =================================
    // Clear recent apps
    // =================================
    //

    ClearRecentApps();

    //
    // =================================
    // Delete User Specific Settings from all user profiles.
    // =================================
    //

    NukeUserSettings();

    //
    // =================================
    // Remove HKLM\System\MountedDevices key.
    // =================================
    //
    if ( NO_ERROR == (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   TEXT("System"),
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey)) )
    {
        RegDeleteKey(hKey, TEXT("MountedDevices"));
        RegCloseKey(hKey);
    }

    //
    // =================================
    // Remove Desktop Cleanup wizard registry key to reset cleanup timer
    // =================================
    //
    if ( NO_ERROR == (RegOpenKeyEx(HKEY_CURRENT_USER,
                                   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\CleanupWiz"),
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey)) )
    {
        RegDeleteValue(hKey, TEXT("Last used time"));
        RegCloseKey(hKey);
    }
  
    //
    // =================================
    // Windows Update Cleanup
    //
    // Do all of the following during SYSPREP -reseal before the system is rebooted:
    //
    // 1) stop the WUAUSERV service
    // 2) delete %ProgramFiles%\WindowsUpdate\urllog.dat (note WindowsUpdate is a hiiden directory.  I don't believe this will cause any issues).
    // 3) remove the following registry entries under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate
    //    Delete value/data pair: PingID
    //    DO NOT DELETE key subtree: Auto Update
    //    Delete value/data pair: Auto Update\AUState
    //    Delete value/data pair: Auto Update\LastWaitTimeout
    //    Delete key subtree: IUControl
    //    Delete key subtree: OemInfo  
    // =================================
    //
    // 1) stop the WUAUSERV service
    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if (schSystem)
    {
        schService = OpenService( schSystem,
                                  TEXT("WUAUSERV"),
                                  SC_MANAGER_ALL_ACCESS);
        if ( schService )
        {
            SERVICE_STATUS ss;
            ControlService( schService, SERVICE_CONTROL_STOP, &ss );
            CloseServiceHandle( schService );
        }
        CloseServiceHandle( schSystem );
    }

    // 2) delete %ProgramFiles%\WindowsUpdate\urllog.dat (note WindowsUpdate is a hiiden directory.  I don't believe this will cause any issues).
    dwLen=ExpandEnvironmentStrings(TEXT("%ProgramFiles%\\WindowsUpdate\\urllog.dat"),szUrllog,MAX_PATH);
    if (dwLen && dwLen < MAX_PATH)
        DeleteFile(szUrllog);

    // 3) remove the following registry entries under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate
    //    Delete value/data pair: PingID
    //    DO NOT DELETE key subtree: Auto Update
    //    Delete value/data pair: Auto Update\AUState
    //    Delete value/data pair: Auto Update\LastWaitTimeout
    //    Delete key subtree: IUControl
    //    Delete key subtree: OemInfo  
    if ( NO_ERROR == (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate"),
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey)) )
    {
        RegDeleteValue(hKey, TEXT("PingID"));
        RegDeleteValue(hKey, TEXT("Auto Update\\AUState"));
        RegDeleteValue(hKey, TEXT("Auto Update\\LastWaitTimeout"));
        RegDeleteKey(hKey, TEXT("IUControl"));
        RegDeleteKey(hKey, TEXT("OemInfo"));
        RegCloseKey(hKey);
    }
    
    //
    // =================================
    // Modify any install paths that may be required
    // for our reboot into gui-mode.
    // =================================
    //
    FixDevicePaths();

    //
    // =================================
    // Clear out winlogon's memory of the last user and domain.
    // =================================
    //
    if( !DeleteWinlogonDefaults() ) {
        return FALSE;
    }

    // Remove Cryptography key so it gets re-generated, only do this if the SIDS have been regenerated
    //
    if ( !NoSidGen )
    {
        if ( NO_ERROR == (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       TEXT("SOFTWARE\\Microsoft\\Cryptography"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKey)) )
        {
            RegDeleteValue(hKey, TEXT("MachineGuid"));
            RegCloseKey(hKey);
        }
    }

    // Set the cloned tag in the registry
    if (!SetCloneTag())
        return FALSE;

    // Sets whether msoobe or mini-setup on first end user boot
    //
    if (!SetupFirstRunApp())
        return FALSE;

    //
    // =================================
    // Clear the LastKnownGood ControlSet.
    // =================================
    //
    if (NO_ERROR != NukeLKGControlSet())
        return FALSE;

    //
    // =================================
    // Clear the eventlogs on the machine.
    // This is the last thing that we should do.
    // =================================
    //
    NukeEventLogs();

    // Common reseal succeeded
    //
    return TRUE;
}

BOOL
AdjustFiles(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine allows cleanup to happen before files are copied to the server
    by Riprep.  

Arguments:

    None.

Return Value:

    None.

Remarks:
    
    This routine should be called before AdjustRegistry() for Riprep.  Sysprep 
    needs to call this before FCommonReseal(). 

===============================================================================
--*/
{
    BOOL bUseMSOOBE = FALSE, 
         bPro = FALSE,
         fReturn = TRUE;

    TCHAR szSysprepFolder[MAX_PATH] = TEXT("\0");

    //
    // Make sure we've got the required privileges to update the registry.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    //
    // Check the product type.
    //
    if (IsPersonalSKU() || (bPro = IsProfessionalSKU())) {
        bUseMSOOBE = TRUE;

        if (bMiniSetup == TRUE && bPro)
            bUseMSOOBE = FALSE;
    }
    else
        bUseMSOOBE = FALSE;

    if (bUseMSOOBE)
    {
        //
        // Prepare for Oobe
        //
    }
    else
    {
        //
        // Prepare for MiniSetup
        //
    }

    //
    // =================================
    // Clear the SMS settings and INI file.
    // =================================
    //
    NukeSmsSettings();

    //
    // =================================
    // Clean up Digital Rights Media information.
    // =================================
    //
    
#if !(defined(AMD64) || defined(IA64))
    //
    // This only works on x86. There is no 64-bit library available for us
    // to call into right now.
    //
    if ( GetWindowsDirectory(szSysprepFolder, sizeof(szSysprepFolder)/sizeof(szSysprepFolder[0])) )
    {
        CHAR szLogFileA[MAX_PATH];
        BOOL bLog = TRUE;

        // This will look something like this: "c:\windows".  Make the character after the '\' NULL, and 
        // append the name of the file to it.
        //
        szSysprepFolder[3] = UNICODE_NULL;
        PathAppend(szSysprepFolder, TEXT("SYSPREP"));
             
        // Create the folder if it does not exist
        //
        if ( !PathFileExists(szSysprepFolder) ) 
        {
            bLog = CreateDirectory(szSysprepFolder, NULL);
        }
        
        PathAppend(szSysprepFolder, CLEANDRM_LOGFILE);

        // Convert UNICODE string to ANSI string.
        //
        if ( WideCharToMultiByte(CP_ACP, 0, szSysprepFolder, -1, szLogFileA, sizeof(szLogFileA), NULL, NULL) )
        {
            CleanDRM( bLog ? szLogFileA : NULL );
        }
        else 
        {
            fReturn = FALSE;
        }
    }
    else 
    {
        fReturn = FALSE;
    }


               
#endif // #if !(defined(AMD64) || defined(IA64))

    //
    // =================================
    // Clear OOBE settings for both minisetup and oobe.
    // =================================
    //
    ResetOobeSettings();

    //
    // =================================
    // Clear the eventlogs on the machine.
    // This is the last thing that we should do.
    // =================================
    //
    NukeEventLogs();

    //
    // =================================
    // Delete temporary files.
    // =================================
    //

    NukeTemporaryFiles();

    return fReturn;
}

BOOL
AdjustRegistry(
    IN BOOL fRemoveNetworkSettings
    )

/*++
===============================================================================
Routine Description:

    This routine actually adds in the registry entry to enable our second half
    to execute.

Arguments:

    fRemoveNetworkSettings - indicates if network settings should be removed

Return Value:

    None

===============================================================================
--*/

{
    HKEY            hKey;
    TCHAR           szSysprepINFPath[MAX_PATH];
    BOOL            fPopulated = FALSE;

    // Formulate the path to SYSPRE.INF, since we will need it later to look up
    // sysprep options
    if (!GetWindowsDirectory( szSysprepINFPath, MAX_PATH ))
        return FALSE;

    StringCchCopy ( &szSysprepINFPath[3], AS ( szSysprepINFPath ) - 3, TEXT("sysprep\\sysprep.inf") );

    //
    // Make sure we've got the required privileges to update the registry.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    // Set OEMDuplicatorString
    if (!SetOEMDuplicatorString(szSysprepINFPath))
        return (FALSE);

    // Fill in the [sysprepMassStorage] section for PopulateDeviceDatabase()
    //
    BuildMassStorageSection(FALSE);

    //
    // =================================
    // Fixup boot devices.
    // =================================
    //
    if (!PopulateDeviceDatabase(&fPopulated))
        return FALSE;

    //
    // Perform miscellaneous registry modifications
    //
	
    // Determine if we should set the BigLba support in registry
    //
    if ( !SetBigLbaSupport(szSysprepINFPath) )
    {
        return FALSE;
    }
    
    // Determine if we should remove the TAPI settings in registry
    //
    if ( !RemoveTapiSettings(szSysprepINFPath) )
    {
        return FALSE;
    }
    
    //
    // Remove the LastAliveStamp value so that we don't get erroneous entries into the even log
    // and avoid pop-ups on first boot saying that the machine has been shutdown improperly.
    //
    if ( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, STR_REG_KEY_RELIABILITY, &hKey) )
    {
        RegDeleteValue(hKey, STR_REG_VALUE_LASTALIVESTAMP);
        RegCloseKey(hKey);
    }

    //
    // =================================
    // Reset network settings last so if any errors happen before we still
    // have network access.
    // =================================
    //
    if (fRemoveNetworkSettings)
    {
        if (!RemoveNetworkSettings(szSysprepINFPath))
            return FALSE;
    }


    //
    // =================================
    // Change our boot timeout to 1.
    // =================================
    //
    ChangeBootTimeout( 1 );

    // Do common reseal code for both Sysprep and Riprep
    //
    if (!FCommonReseal())
        return FALSE;

    return TRUE;

}

BOOL 
CreateSysprepTemporaryDevnode(
    HDEVINFO*        phDevInfo, 
    SP_DEVINFO_DATA* pDeviceInfoData
    )
/*++
===============================================================================
Routine Description:

Arguments:

    None.

Return Value:

    TRUE if everything is OK, FALSE otherwise.

Assumptions:

    1. No HardwareID exceeds MAX_PATH characters.

===============================================================================
--*/
{
    if (phDevInfo) {
        //
        // Create a dummy devnode
        //
        *phDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
        if (*phDevInfo == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        //
        // Initialize the DriverInfoData struct
        //
        pDeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Create the devnode
        //
        if (pDeviceInfoData && !SetupDiCreateDeviceInfo(*phDevInfo,
                                     L"SYSPREP_TEMPORARY",
                                     (LPGUID)&GUID_NULL,
                                     NULL,
                                     NULL,
                                     DICD_GENERATE_ID,
                                     pDeviceInfoData)) {
            //
            // ISSUE-2002/02/26-brucegr: Destroy the info list and set phDevInfo to INVALID_HANDLE_VALUE?
            //
            return FALSE;
        }
    }
        
    return TRUE;
}

BOOL InsertCleanupNode(PPCLEANUP_NODE ppCleanupList, PCLEANUP_NODE pAddNode)
{
    PPCLEANUP_NODE ppl = ppCleanupList;
    while ( *ppl != NULL && (0 < lstrcmpi(pAddNode->pszService, (*ppl)->pszService))
          )
    {
        ppl = &((*ppl)->pNext);
    }
    if (*ppl && (0 == lstrcmpi(pAddNode->pszService, (*ppl)->pszService)))
    {
        free(pAddNode);
        return FALSE;
    }

    pAddNode->pNext = *ppl;
    *ppl = pAddNode;
    return TRUE;
}

PCLEANUP_NODE FindCleanupNode(PPCLEANUP_NODE ppCleanupList, LPTSTR pszServiceName)
{
    PCLEANUP_NODE pTemp = *ppCleanupList;
    while (pTemp) 
    {
        if (0 == lstrcmpi(pTemp->pszService, pszServiceName))
            return pTemp;

        pTemp = pTemp->pNext;
    }
    return NULL;
}

void FreeCleanupList(PPCLEANUP_NODE ppCleanupList)
{
    while (*ppCleanupList) 
    {
        PCLEANUP_NODE pTemp = *ppCleanupList;
        *ppCleanupList = (*ppCleanupList)->pNext;

        free(pTemp->pszService);
        free(pTemp);
    }
    *ppCleanupList = NULL;
}

BOOL AddCleanupNode(
    LPTSTR pszServiceName 
    )
/*++
===============================================================================
Routine Description:
    
    When populating the [SysprepCleanup] section we need to check if the service
    or filters already exists in the this section before we enter a duplicate
    entry.

Arguments:

    LPTSTR pszServiceName  - Service/Filter name.

Return Value:

    TRUE if a duplicate found, FALSE otherwise.

Assumptions:

    1. No duplicate entries in [SysprepCleanup] section.

===============================================================================
--*/
{
    BOOL fAdded = FALSE;

    // 
    // Find the Service in our list.
    //
    if (pszServiceName && (NULL == FindCleanupNode(&g_pCleanupListHead, pszServiceName))) 
    {
        PCLEANUP_NODE pNode = (PCLEANUP_NODE)malloc(sizeof(CLEANUP_NODE));
        if (pNode) 
        {
            int nLen = lstrlen ( pszServiceName ) + 1;
            pNode->pszService = (LPTSTR)malloc( nLen  * sizeof ( TCHAR ) );

            if ( pNode->pszService ) 
            {
                StringCchCopy (pNode->pszService, nLen, pszServiceName);
            }
            pNode->pNext = NULL;
       
            // 
            // We didn't find it so add it to our list.  
            // We will not add duplicates to our list.
            //
            fAdded = InsertCleanupNode(&g_pCleanupListHead, pNode);        
        }
    }
    
    return fAdded;
}

BOOL
PopulateDeviceDatabase(
    IN BOOL* pfPopulated
    )
/*++
===============================================================================
Routine Description:

    Parse the [SysprepMassStorage] section in the sysprep.inf file and
    populate the critical device database with the specified devices to ensure
    that we can boot into the miniwizard when moving the image to a target
    system with different boot storage devices.

    The installed services/upperfilters/lowerfilters will be recorded, so
    that on the next boot into the mini-wizard those without an associated
    device will be disabled (the cleanup stage) in order not to unnecessarily
    degrade Windows start time.

Arguments:

    None.

Return Value:

    TRUE if everything is OK, FALSE otherwise.

Assumptions:

    1. No HardwareID exceeds MAX_PATH characters.

    2. No field on a line in the [SysprepMassStorage] section exceeds MAX_PATH
       characters.

    3. No service's/upperfilter's/lowerfilter's name exceeds MAX_PATH characters.

    4. DirectoryOnSourceDevice, source DiskDescription, or source DiskTag
       (applying to vendor-supplied drivers) cannot exceed MAX_PATH characters.
===============================================================================
--*/

{
    BOOL                 bAllOK = TRUE;
    PCWSTR               pszSectionName = L"SysprepMassStorage";
    WCHAR                szSysprepInfFile[] = L"?:\\sysprep\\sysprep.inf";
#ifdef DEBUG_LOGLOG
    WCHAR                szLogFile[] = L"?:\\sysprep.log";
#endif
    WCHAR                szBuffer[MAX_PATH], *pszFilter;
    CHAR                 szOutBufferA[MAX_PATH];
    HANDLE               hInfFile = INVALID_HANDLE_VALUE;
    HINF                 hAnswerInf = INVALID_HANDLE_VALUE;
    BOOL                 bLineExists;
    INFCONTEXT           InfContext;
    HDEVINFO             hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA      DeviceInfoData;
    SP_DEVINSTALL_PARAMS DevInstallParams;
    SP_DRVINFO_DATA      DriverInfoData;
    HSPFILEQ             QueueHandle = INVALID_HANDLE_VALUE;
    DWORD                dwSize = 0;
    BOOL                 bNodeCreated = FALSE;
    WCHAR                DirectoryOnSourceDevice[MAX_PATH];
    WCHAR                DiskDescription[MAX_PATH];
    WCHAR                DiskTag[MAX_PATH];
    PSYSPREP_QUEUE_CONTEXT pSysprepContext;


    if (!GetWindowsDirectory(szBuffer, MAX_PATH))
        return FALSE;

    szSysprepInfFile[0] = szBuffer[0];

#ifdef DEBUG_LOGLOG
    szLogFile[0] = szBuffer[0];
    DeleteFile(szLogFile);
    LOG_Init(szLogFile);
    LOG_Write(L">>\r\n>> PopulateDeviceDatabase\r\n>>\r\n");
    LOG_Write(L"Sysprep.inf=%s", szSysprepInfFile);
#endif





    //
    // =================================
    // Open the sysprep.inf file.  Since we don't know what the user has in
    // here, so try opening as both styles.
    // =================================
    //

    //
    // ISSUE-2002/02/26-brucegr: You can specify both bits in one call...
    //
    hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_WIN4, NULL);
    if (hAnswerInf == INVALID_HANDLE_VALUE) {
        hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_OLDNT, NULL);
        if (hAnswerInf == INVALID_HANDLE_VALUE) {

            //
            // User didn't give us a sysprep.inf.  Return as if nothing
            // happened.
            //
            return TRUE;
        }
    }


    //
    // open the same inf file to record upper filters, lower filters, and
    // services of the added devices
    //
    hInfFile = CreateFile(szSysprepInfFile,
                          GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                          NULL);
    if (hInfFile == INVALID_HANDLE_VALUE) {
        goto PDD_Critical_Error_Handler;
    }

    //
    // =================================
    // Create/clear [sysprepcleanup] which should be at the bottom of the file.
    // =================================
    //
    WritePrivateProfileSection(L"sysprepcleanup", L"", szSysprepInfFile);


    //
    // =================================
    // Create a dummy devnode
    // =================================
    //

    bNodeCreated = CreateSysprepTemporaryDevnode(&hDevInfo, &DeviceInfoData);

    // Initialize the DriverInfoData struct
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!bNodeCreated)
        goto PDD_Critical_Error_Handler;

    //
    // =================================
    // Process each line in our section.  Each line should look like:
    // <hardware-id>=<inf pathname>
    // or in the case of drivers that aren't on the product CD:
    // <hardware-id>=<inf pathname>,<directory on recovery floppy>,<description of recovery floppy>,<disk tag of recovery floppy>
    //
    // If we see an entry like this, we'll know that in the case of system recovery, the
    // file should be retrived from a floppy, and not the Windows CD.
    // =================================
    //

    bLineExists = SetupFindFirstLine(hAnswerInf, pszSectionName, NULL, &InfContext);

    //
    // =================================
    // Let caller know we've go entries to populate.
    // =================================
    //
    if (pfPopulated)
        *pfPopulated = bLineExists;

    while (bLineExists) {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"");
#endif


        //
        // =================================
        // Step 1: Set the hardwareID of the devnode.
        // =================================
        //

        //
        // retrieve the hardwareID from the line
        //
        dwSize = MAX_PATH;
        if (!SetupGetStringField(&InfContext, 0, szBuffer, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

#ifdef DEBUG_LOGLOG
        LOG_Write(L"HardwareID=%s", szBuffer);
#endif

        //
        // and then set it to the devnode,
        //
        if (!SetupDiSetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_HARDWAREID,
                                              (PBYTE)szBuffer,
                                              AS ( szBuffer ) * sizeof(WCHAR))) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            // If someone removed the devnode, we need to re-create it and repeat this pnp device
            //
            if (ERROR_NO_SUCH_DEVINST == GetLastError()) {                

                // Re-create the SYSPREP_TEMPORARY devnode again
                //
                bAllOK = CreateSysprepTemporaryDevnode(&hDevInfo, &DeviceInfoData);
                bNodeCreated = bAllOK;

                // Set the hardwareID again
                //
                //
                // NTRAID#NTBUG9-551868-2002/02/26-brucegr: Need to increase size parameter by one WCHAR
                //
                if (bNodeCreated && !SetupDiSetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_HARDWAREID,
                                              (PBYTE)szBuffer,
                                              lstrlen(szBuffer) * sizeof(WCHAR))) {
                    // We failed again, then quit 
                    //
                    bAllOK = FALSE;
                    goto PDD_Critical_Error_Handler;
                }
            }
            else {
                bAllOK = FALSE;
                goto PDD_Next_Inf_Line;
            }
        }

        //
        // make sure that there's no existing compatible list, since we're reusing
        // the dummy devnode
        //
        if (!SetupDiDestroyDriverInfoList(hDevInfo, &DeviceInfoData, SPDIT_COMPATDRIVER)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Build the SP_DEVINSTALL_PARAMS for this node.
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if (!SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // set the Flags field: only search the INF file specified in DriverPath field;
        // don't create a copy queue, use the provided one in FileQueue; don't call the
        // Configuration Manager while populating the CriticalDeviceDatabase.
        //
        DevInstallParams.Flags |= DI_ENUMSINGLEINF;
        DevInstallParams.Flags |= DI_NOVCP;
        DevInstallParams.Flags |= DI_DONOTCALLCONFIGMG;

        //
        // set the file queue field
        //
        QueueHandle = SetupOpenFileQueue();
        if (QueueHandle == INVALID_HANDLE_VALUE) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }
        DevInstallParams.FileQueue = QueueHandle;

        //
        // set the device's inf pathname
        //
        dwSize = MAX_PATH;
        if (!SetupGetStringField(&InfContext, 1, szBuffer, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }
        ExpandEnvironmentStrings(szBuffer, DevInstallParams.DriverPath, MAX_PATH);

#ifdef DEBUG_LOGLOG
        LOG_Write(L"DriverPath=%s", DevInstallParams.DriverPath);
#endif

        if (!SetupDiSetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Register the newly created device instance with the PnP Manager.
        //
        if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 2: Perform a compatible driver search.
        // =================================
        //

        if (!SetupDiBuildDriverInfoList(hDevInfo, &DeviceInfoData, SPDIT_COMPATDRIVER)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        // Make sure there is at least 1 compat driver for this device.
        // If there is not, and then we just process the next one in the list
        if (!SetupDiEnumDriverInfo(hDevInfo,
                                   &DeviceInfoData,
                                   SPDIT_COMPATDRIVER,
                                   0,
                                   &DriverInfoData))
        {
            // Check to see what the error was. Any error other than ERROR_NO_MORE_ITEMS
            // will be flaged, by setting the bAllOK return value to FALSE
            if (ERROR_NO_MORE_ITEMS != GetLastError())
            {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
            }
            goto PDD_Next_Inf_Line;
        }

        //
        // =================================
        // Step 3: Select the best compatible driver.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 4: Install the driver files.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Need to commit the file queue here, so the later steps can properly
        // be executed in case the device doesn't use the already existing
        // coinstaller(s).
        //
        pSysprepContext = (PSYSPREP_QUEUE_CONTEXT) InitSysprepQueueCallback();

        //
        // Retrieve DirectoryOnSourceDevice from the inf line, if any
        //
        dwSize = MAX_PATH;
        DirectoryOnSourceDevice[0] = L'\0';
        if (!SetupGetStringField(&InfContext, 2, DirectoryOnSourceDevice, dwSize, &dwSize)) {
            DirectoryOnSourceDevice[0] = L'\0';
        }
        if (DirectoryOnSourceDevice[0] != L'\0') {
            pSysprepContext->DirectoryOnSourceDevice = DirectoryOnSourceDevice;
        }

        //
        // Retrieve DiskDescription from the inf line, if any
        //
        dwSize = MAX_PATH;
        DiskDescription[0] = L'\0';
        if (!SetupGetStringField(&InfContext, 3, DiskDescription, dwSize, &dwSize)) {
            DiskDescription[0] = L'\0';
        }
        if (DiskDescription[0] != L'\0') {
            pSysprepContext->DiskDescription = DiskDescription;
        }

        //
        // Retrieve DiskTag from the inf line, if any
        //
        dwSize = MAX_PATH;
        DiskTag[0] = L'\0';
        if (!SetupGetStringField(&InfContext, 4, DiskTag, dwSize, &dwSize)) {
            DiskTag[0] = L'\0';
        }
        if (DiskTag[0] != L'\0') {
            pSysprepContext->DiskTag = DiskTag;
        }

        //
        // Commit the file queue
        //
        if (!SetupCommitFileQueue(NULL,
                                  QueueHandle,
                                  SysprepQueueCallback,
                                  pSysprepContext)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
        }
        FreeSysprepContext(pSysprepContext);

        // 
        // =================================
        // Step 4a: Dis-associate file copy queue before we close
        //          the queue.
        // =================================
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if (!SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Remove the DI_NOVCP flag and NULL out the FileQueue.
        //
        DevInstallParams.Flags &= ~DI_NOVCP;
        DevInstallParams.FileQueue = NULL;
        if (!SetupDiSetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        SetupCloseFileQueue(QueueHandle);
        QueueHandle = INVALID_HANDLE_VALUE;





        //
        // =================================
        // Step 5: Register the device-specific coinstallers.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 6: Install the device.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 7: Retrieve upper filters, lower filters,
        //         and controlling service, save them back
        //         to the inf file.
        // =================================
        //

        //
        // retrieve device upperfilters (REG_MULTI_SZ)
        //
        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_UPPERFILTERS,
                                              NULL,
                                              (PBYTE)szBuffer,
                                              sizeof(szBuffer),
                                              NULL)) {
            szBuffer[0] = L'\0';
        }

        for (pszFilter = szBuffer; *pszFilter; pszFilter += (lstrlen(pszFilter) + 1)) {
            StringCchPrintfA(szOutBufferA, AS ( szOutBufferA ), "Upperfilter=%S\r\n", pszFilter);
            if (AddCleanupNode(pszFilter)) {
                SetFilePointer(hInfFile, 0L, 0L, FILE_END);
                WriteFile(hInfFile, szOutBufferA, strlen(szOutBufferA), &dwSize, NULL);
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Upperfilter=%s", pszFilter);
#endif
        }

        //
        // retrieve device lowerfilters (REG_MULTI_SZ)
        //
        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_LOWERFILTERS,
                                              NULL,
                                              (PBYTE)szBuffer,
                                              sizeof(szBuffer),
                                              NULL)) {
            szBuffer[0] = L'\0';
        }

        for (pszFilter = szBuffer; *pszFilter; pszFilter += (lstrlen(pszFilter) + 1)) {
            StringCchPrintfA(szOutBufferA, AS ( szOutBufferA ), "Lowerfilter=%S\r\n", pszFilter);
            if (AddCleanupNode(pszFilter)) {
                SetFilePointer(hInfFile, 0L, 0L, FILE_END);
                WriteFile(hInfFile, szOutBufferA, strlen(szOutBufferA), &dwSize, NULL);
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Lowerfilter=%s", pszFilter);
#endif
        }

        //
        // retrieve device its controlling service (REG_SZ)
        //
        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_SERVICE,
                                              NULL,
                                              (PBYTE)szBuffer,
                                              sizeof(szBuffer),
                                              NULL)) {
            szBuffer[0] = L'\0';
        }

        if (szBuffer[0] != L'\0') {
            StringCchPrintfA(szOutBufferA, AS ( szOutBufferA ), "Service=%S\r\n", szBuffer);
            if (AddCleanupNode(szBuffer)) {
                SetFilePointer(hInfFile, 0L, 0L, FILE_END);
                WriteFile(hInfFile, szOutBufferA, strlen(szOutBufferA), &dwSize, NULL);
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Service=%s", szBuffer);
#endif
        }

PDD_Next_Inf_Line:

        if (QueueHandle != INVALID_HANDLE_VALUE) {
            SetupCloseFileQueue(QueueHandle);
            QueueHandle = INVALID_HANDLE_VALUE;
        }

        //
        // Get the next line from the relevant section in the inf file.
        //
        bLineExists = SetupFindNextLine(&InfContext, &InfContext);
    }





    //
    // =================================
    // Cleanup for a successful run
    // =================================
    //

    //
    // remove the SYSPREP_TEMPORARY node under Root
    //
    SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &DeviceInfoData);

    SetupDiDestroyDeviceInfoList(hDevInfo);

    CloseHandle(hInfFile);

    SetupCloseInfFile(hAnswerInf);

    //
    // Backup the system hive to the Repair folder
    //
    if (!BackupHives()) {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"ERROR - Unable to backup the system hive.");
#endif
        bAllOK = FALSE;
    }

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    FreeCleanupList(&g_pCleanupListHead);

    return bAllOK;





//
// =================================
PDD_Critical_Error_Handler:
// =================================
//

#ifdef DEBUG_LOGLOG
    LOG_WriteLastError();
#endif

    if (QueueHandle != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(QueueHandle);
    }

    //
    // remove the SYSPREP_TEMPORARY node under Root
    //
    if (bNodeCreated) {
        SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &DeviceInfoData);
    }

    if (hDevInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    if (hInfFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hInfFile);
    }

    if (hAnswerInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hAnswerInf);
    }

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    FreeCleanupList(&g_pCleanupListHead);

    return FALSE;
}

/*++
===============================================================================
Routine Description:

    Check to see if the service name passed in is in use by a PnP enumerated
    device.

Arguments:

    lpszServiceName

Return Value:

    TRUE.   The service is in use, or will be in use by a device (as evidenced by
            the presence of the service name as a registry property for an enumerated
            device)

    FALSE.  The service is not in use.
            If LastError is set, then a bad thing happed, otherwise the service is
            just not being used

Assumptions:

===============================================================================
--*/
BOOL ServiceInUseByDevice
(
    LPTSTR  lpszServiceName
)
{
    HDEVINFO            DeviceInfoSet;
    HDEVINFO            NewDeviceInfoSet;
    DWORD               i;
    SP_DEVINFO_DATA     DevInfoData;
    TCHAR               szServiceName[MAX_PATH];
    TCHAR               szDeviceClass[MAX_PATH];
    BOOL                bRet = FALSE;
    TCHAR               szLegacyClass[MAX_CLASS_NAME_LEN];

    // Clear the last error
    SetLastError(0);

    // Get the Class description for LegacyDriver
    if (!SetupDiClassNameFromGuid(&GUID_DEVCLASS_LEGACYDRIVER,
                                  szLegacyClass,
                                  sizeof(szLegacyClass)/sizeof(TCHAR),
                                  NULL))
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Unable to get LegacyDriver Class NAME");
#endif
        // NOTE: LastError will be set to the appropriate error code by
        // SetupDiGetClassDescription
        return FALSE;
    }


    // Create a device information set that will be used to enumerate all
    // present devices
    DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Unable to Create a device info list");
#endif
        SetLastError(E_FAIL);
        return FALSE;
    }

    // Get a list of all present devices on the system
    NewDeviceInfoSet = SetupDiGetClassDevsEx(NULL,
                                             NULL,
                                             NULL,
                                             DIGCF_PRESENT | DIGCF_ALLCLASSES,
                                             DeviceInfoSet,
                                             NULL,
                                             NULL);

    if(NewDeviceInfoSet == INVALID_HANDLE_VALUE)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Unable to enumerate present devices");
#endif
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        SetLastError(E_FAIL);
        return FALSE;
    }

    // Enumerate the list of devices, checking to see if the service listed in the
    // registry matches the service we are interested in.
    i = 0;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    while (SetupDiEnumDeviceInfo(NewDeviceInfoSet, i, &DevInfoData))
    {
        // See if this is devnode is using the service we care about.
        // if so, then we will check to see if it is a legacy devnode. If it
        // is NOT a legacy devnode, then we will not mess with it, because
        // the service is in use by a real device.
        if (SetupDiGetDeviceRegistryProperty(NewDeviceInfoSet,
                                             &DevInfoData,
                                             SPDRP_SERVICE,
                                             NULL,
                                             (PBYTE) szServiceName,
                                             sizeof(szServiceName),
                                             NULL))
        {
            // See if this is the service we are looking for
            if (0 == lstrcmpiW(lpszServiceName, szServiceName))
            {
                // Check for a legacy class device
                if (SetupDiGetDeviceRegistryProperty(NewDeviceInfoSet,
                                                     &DevInfoData,
                                                     SPDRP_CLASS,
                                                     NULL,
                                                     (PBYTE) szDeviceClass,
                                                     sizeof(szDeviceClass),
                                                     NULL))
                {
                    // We have the class, lets see if it is a legacy device
                    if (0 != lstrcmpiW(szLegacyClass, szDeviceClass))
                    {
                        // it is NOT a legacy device, so this service is in use!
                        bRet = TRUE;
                        break;
                    }
                }
                else
                {
                    // We don't know the class, but it is not legacy (otherwise we
                    // would have gotten the class returned above, so assume it is
                    // is use!
                    bRet = TRUE;
                    break;
                }
            }
        }
        ++i;
    }

    // Clean up the device info sets that were allocated
    SetupDiDestroyDeviceInfoList(NewDeviceInfoSet);
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return bRet;
}

BOOL
CleanDeviceDatabase(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Parse the [SysprepCleanup] section in the sysprep.inf file, which was
    created during the PopulateDeviceDatabase stage, and disable those
    listed services/upperfilters/lowerfilters which don't have associated
    physical devices.

    The strategy here is that we try to stop each listed service/upperfilter/
    lowerfilter.  It will only be stopped if it's not currently running (so
    not controlling a PnP devnode), or is associated with a legacy devnode
    (Root\LEGACY_<SvcName>\0000).  Once it can be stopped, we can safely
    disable it.

Arguments:

    None.

Return Value:

    TRUE.   No errors encountered

    FALSE.  Some error occurred.  It's not likely that the call will be able
            to do much though.

Assumptions:

    1. All listed services/upperfilters/lowerfilters have no dependencies.

    2. No service's/upperfilter's/lowerfilter's name exceeds MAX_PATH characters.
===============================================================================
--*/

{
    BOOL             bAllOK = TRUE;
    PCWSTR           pszSectionName = L"SysprepCleanup";
    WCHAR            szSysprepInfFile[] = L"?:\\sysprep\\sysprep.inf";
#ifdef DEBUG_LOGLOG
    WCHAR            szLogFile[] = L"?:\\sysprep.log";
#endif
    WCHAR            szServiceName[MAX_PATH];
    WCHAR            szBuffer[MAX_PATH], *pszDevID;
    HINF             hAnswerInf = INVALID_HANDLE_VALUE;
    BOOL             bLineExists;
    INFCONTEXT       InfContext;
    DWORD            dwSize;
    CONFIGRET        cfgRetVal;
    HDEVINFO         hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA  DeviceInfoData;
    SC_HANDLE        hSC = NULL;
    SC_HANDLE        hSvc = NULL;
    LPQUERY_SERVICE_CONFIG psvcConfig = NULL;
    DWORD            Type, l;
    HKEY             hKey;


    if (!GetWindowsDirectory(szBuffer, MAX_PATH)) {
        //
        // Unable to get Windows Directory
        //
        return FALSE;
    }

    szSysprepInfFile[0] = szBuffer[0];

#ifdef DEBUG_LOGLOG
    szLogFile[0] = szBuffer[0];
    LOG_Init(szLogFile);
    LOG_Write(L">>\r\n>> CleanDeviceDatabase\r\n>>\r\n");
    LOG_Write(L"Sysprep.inf=%s", szSysprepInfFile);
#endif





    //
    // =================================
    // HACK.  Winlogon may erroneously append a ',' onto
    // the end of the path to explorer.  This would normally
    // get fixed up by ie.inf, but for the sysprep case,
    // this inf isn't run, so we'll continue to have this
    // bad path in the registry.  Fix it here.
    // =================================
    //

    //
    // Open HKLM\Software\Microsoft\Windows NT\CurrentVersion\WinLogon
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );
    if( l == NO_ERROR ) {
        //
        // Query the value of the Shell Key.
        //
        //
        // ISSUE-2002/02/26-brucegr: dwSize = sizeof(szBuffer);
        //
        dwSize = sizeof(szBuffer)/sizeof(szBuffer[0]);
        l = RegQueryValueEx( hKey,
                             TEXT("Shell"),
                             NULL,
                             &Type,
                             (LPBYTE)szBuffer,
                             &dwSize );

        if( l == NO_ERROR ) {
            pszDevID = wcschr( szBuffer, L',' );

            if( pszDevID ) {

                //
                // We hit, so we should set it back to "Explorer.exe"
                //
                StringCchCopy ( szBuffer, AS ( szBuffer ), L"Explorer.exe" );

                //
                // Now set the key with our new value.
                //
                l = RegSetValueEx( hKey,
                                   TEXT("Shell"),
                                   0,
                                   REG_SZ,
                                   (CONST BYTE *)szBuffer,
                                   (lstrlen( szBuffer ) + 1) * sizeof(WCHAR));
            }
        }

        RegCloseKey(hKey);
    }


    //
    // =================================
    // Open the sysprep.inf file.  Since we don't know what the user has in
    // here, so try opening as both styles.
    // =================================
    //

    //
    // ISSUE-2002/02/26-brucegr: You can pass in both bits in one call to SetupOpenInfFile
    //
    hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_WIN4, NULL);
    if (hAnswerInf == INVALID_HANDLE_VALUE) {
        hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_OLDNT, NULL);
        if (hAnswerInf == INVALID_HANDLE_VALUE) {

            //
            // User didn't give us a sysprep.inf.  Return as if nothing
            // happened.
            //
            return TRUE;
        }
    }

    //
    // =================================
    // Remove the buildmassstoragesection=yes if it exists.  
    // =================================
    //
    WritePrivateProfileString(SYSPREP_SECTION, SYSPREP_BUILDMASSSTORAGE_KEY, NULL, szSysprepInfFile);

    //
    // =================================
    // Establish a connection to the service control manager on the local
    // computer to retrieve status and reconfig services.
    // =================================
    //

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL) {
        goto CDD_Critical_Error_Handler;
    }





    //
    // =================================
    // Process each line in our section
    // =================================
    //

    bLineExists = SetupFindFirstLine(hAnswerInf, pszSectionName, NULL, &InfContext);

    while (bLineExists) {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"");
#endif
        //
        // We've got a line, and it should look like:
        //     <key>=<service name>
        //





        //
        // =================================
        // Retrieve the service name from the line
        // =================================
        //

        dwSize = MAX_PATH;
        if (!SetupGetStringField(&InfContext, 1, szServiceName, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }

#ifdef DEBUG_LOGLOG
        LOG_Write(L"Service=%s", szServiceName);
#endif

        //
        // ISSUE-2002/02/26-brucegr: EXPENSIVE!!!  Should build the in-use service list once and then loop through INF.
        //                        Code is currently enumerating all devices for every INF entry.  Bad times.
        //

        // Check to see if the service is in use by a currently present, enumerated
        // device. If it is, then skip it, otherwise try to stop it, etc
        if (ServiceInUseByDevice(szServiceName))
        {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Service is in use by a device. Skipping...");
#endif
            goto CDD_Next_Inf_Line;
        }
        else
        {
            if (E_FAIL == GetLastError())
            {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                goto CDD_Next_Inf_Line;
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Service is not in use by a device. Attempting to disable...");
#endif

        }

        //
        // =================================
        // Open the service to query its status, start type, and disable
        // it if it is not running and not yet disabled.
        // =================================
        //

        hSvc = OpenService(
                    hSC,
                    szServiceName,
                    SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG
                    );
        if (hSvc == NULL) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }


        //
        // =================================
        // If PnP driver then don't disable the service and continue.  
        // =================================
        //
        if (IsPnPDriver(szServiceName)) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"IsPnPDriver() returned TRUE.  Continue to next entry.");
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }
    

        //
        // =================================
        // Query the service start type.
        // =================================
        //

    psvcConfig = (LPQUERY_SERVICE_CONFIG) malloc(sizeof(QUERY_SERVICE_CONFIG));
        if (psvcConfig == NULL) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"ERROR@malloc - Not enough memory.");
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }

        if (!QueryServiceConfig(hSvc, psvcConfig, sizeof(QUERY_SERVICE_CONFIG), &dwSize)) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                goto CDD_Next_Inf_Line;
            }
            else {
                //
                // Need to expand the service configuration buffer and call the API again.
                //
                void *pTemp = realloc(psvcConfig, dwSize);
                if (pTemp == NULL) {
#ifdef DEBUG_LOGLOG
                    LOG_Write(L"ERROR@realloc - Not enough memory.");
#endif
                    bAllOK = FALSE;
                    goto CDD_Next_Inf_Line;
                }

                psvcConfig = (LPQUERY_SERVICE_CONFIG) pTemp;

                if (!QueryServiceConfig(hSvc, psvcConfig, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
                    LOG_WriteLastError();
#endif
                    bAllOK = FALSE;
                    goto CDD_Next_Inf_Line;
                }
            }
        }

#ifdef DEBUG_LOGLOG
        switch(psvcConfig->dwStartType) {
        case SERVICE_BOOT_START:
            LOG_Write(L"StartType=SERVICE_BOOT_START");
            break;
        case SERVICE_SYSTEM_START:
            LOG_Write(L"StartType=SERVICE_SYSTEM_START");
            break;
        case SERVICE_AUTO_START:
            LOG_Write(L"StartType=SERVICE_AUTO_START");
            break;
        case SERVICE_DEMAND_START:
            LOG_Write(L"StartType=SERVICE_DEMAND_START");
            break;
        case SERVICE_DISABLED:
            LOG_Write(L"StartType=SERVICE_DISABLED");
            break;
        }
#endif


        //
        // =================================
        // Retrieve device IDs for the device instances controlled by the service.
        // ISSUE-2002/02/26-brucegr: Need to call CM_Get_Device_ID_List_Size to get 
        // the required buffer size. But we're OK here, since by reaching this point, 
        // we know we have a single device instance.
        // =================================
        //

        cfgRetVal = CM_Get_Device_ID_List(
                            szServiceName,
                            szBuffer,
                            sizeof(szBuffer)/sizeof(WCHAR),
                            CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE
                            );
        if (cfgRetVal != CR_SUCCESS) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"ERROR@CM_Get_Device_ID_List - (%08X)", cfgRetVal);
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }


        //
        // =================================
        // Remove all "bogus" devnodes.
        // =================================
        //

        //
        // Create an empty device information set.
        //
        hDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
        if (hDevInfo == INVALID_HANDLE_VALUE) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }

        for (pszDevID = szBuffer; *pszDevID; pszDevID += (lstrlen(pszDevID) + 1)) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"--> removing %s...", pszDevID);
#endif

            //
            // Open a device instance into the hDevInfo set
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            if (!SetupDiOpenDeviceInfo(
                        hDevInfo,
                        pszDevID,
                        NULL,
                        0,
                        &DeviceInfoData)
                        ) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                continue;
            }

            if (!SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
            }

#ifdef DEBUG_LOGLOG
            LOG_Write(L"--> successfully done!");
#endif
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
        hDevInfo = INVALID_HANDLE_VALUE;


        //
        // =================================
        // Disable stopped and not-yet-disabled services
        // =================================
        //
#ifdef DEBUG_LOGLOG
        LOG_Write(L"--> changing StartType to SERVICE_DISABLED...");
#endif
        if (!ChangeServiceConfig(
                    hSvc,
                    SERVICE_NO_CHANGE,
                    SERVICE_DISABLED,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    psvcConfig->lpDisplayName)) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                goto CDD_Next_Inf_Line;
            }

#ifdef DEBUG_LOGLOG
        LOG_Write(L"--> successfully done!");
#endif

CDD_Next_Inf_Line:

        if (psvcConfig != NULL) {
            free(psvcConfig);
            psvcConfig = NULL;
        }

        if (hSvc != NULL) {
            CloseServiceHandle(hSvc);
            hSvc = NULL;
        }

        //
        // Get the next line from the relevant section in the inf file
        //
        bLineExists = SetupFindNextLine(&InfContext, &InfContext);
    }


    //
    // =================================
    // Cleanup for a successful run
    // =================================
    //

    CloseServiceHandle(hSC);

    SetupCloseInfFile(hAnswerInf);

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    return bAllOK;

//
// =================================
CDD_Critical_Error_Handler:
//
// =================================
#ifdef DEBUG_LOGLOG
    LOG_WriteLastError();
#endif

    if (hSvc != NULL) {
        CloseServiceHandle(hSvc);
    }

    if (hSC != NULL) {
        CloseServiceHandle(hSC);
    }

    if (hAnswerInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hAnswerInf);
    }

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    return FALSE;
}

BOOL
IsPnPDriver(
    IN  LPTSTR ServiceName
    )
/*++

Routine Description:

    This function checks whether a specified driver is a PnP driver

Arguments:

    ServiceName - Specifies the driver of interest.

Return Value:

    TRUE - if the driver is a PnP driver or if this cannot be determined.

    FALSE - if the service is not a PnP driver.

--*/
{
    CONFIGRET   Status;
    BOOL        fRetStatus = TRUE;
    WCHAR *     pBuffer;
    ULONG       cchLen, ulRegDataType;
    WCHAR       szClassGuid[MAX_GUID_STRING_LEN];
    DEVNODE     DevNode;

    //
    // Allocate a buffer for the list of device instances associated with
    // this service
    //
    Status = CM_Get_Device_ID_List_Size(
                    &cchLen,                        // list length in wchars
                    ServiceName,                    // pszFilter
                    CM_GETIDLIST_FILTER_SERVICE);   // filter is a service name

    if (Status != CR_SUCCESS)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"CM_Get_Device_ID_List_Size failed %#lx for service %ws\n",
                       Status, ServiceName);
#endif
        return TRUE;
    }

    //
    // If there are no devnodes, this is not a PnP driver
    //
    if (cchLen == 0)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"IsPnPDriver: %ws is not a PnP driver (no devnodes)\n",
                       ServiceName);
#endif
        return FALSE;
    }

    pBuffer = (WCHAR *) LocalAlloc(0, cchLen * sizeof(WCHAR));
    if (pBuffer == NULL)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Couldn't allocate buffer for device list, error %lu\n",
                      GetLastError());
#endif
        return TRUE;
    }

    //
    // Initialize parameters for CM_Get_Device_ID_List, the same way as is
    // normally done in the client side of the API
    //
    pBuffer[0] = L'\0';

    //
    // Get the list of device instances that are associated with this service
    //
    // (For legacy and PNP-aware services, we could get an empty device list.)
    //
    Status = CM_Get_Device_ID_List(
                    ServiceName,                    // pszFilter
                    pBuffer,                        // buffer for device list
                    cchLen,                         // buffer length in wchars
                    CM_GETIDLIST_FILTER_SERVICE |   // filter is a service name
                    CM_GETIDLIST_DONOTGENERATE      // do not generate an instance if none exists
                    );

    if (Status != CR_SUCCESS)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"CM_Get_Device_ID_List failed %#lx for service %ws\n",
                       Status, ServiceName);
#endif
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // If there's more than one devnode, this is a PnP driver
    //
    if (*(pBuffer + wcslen(pBuffer) + 1) != L'\0')
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"IsPnPDriver: %ws is a PnP driver (more than 1 devnode)\n",
                       ServiceName);
#endif
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // This has only one DevNode so lets check if it's legacy.
    // Use CM_LOCATE_DEVNODE_PHANTOM because the DevNode may not be considered alive but
    // exists in the registry.
    //
    if ( CR_SUCCESS == CM_Locate_DevNode(&DevNode, pBuffer, CM_LOCATE_DEVNODE_PHANTOM) )
    {
        //
        // Get the class GUID of this driver
        //
        cchLen = sizeof(szClassGuid);

        Status = CM_Get_DevNode_Registry_Property(
                        DevNode,                        // devnode
                        CM_DRP_CLASSGUID,               // property to get
                        &ulRegDataType,                 // pointer to REG_* type
                        szClassGuid,                    // return buffer
                        &cchLen,                        // buffer length in bytes
                        0                               // flags
                        );

        if (Status != CR_SUCCESS)
        {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"CM_Get_DevNode_Registry_Property failed %#lx for service %ws\n",
                           Status, ServiceName);
#endif
            LocalFree(pBuffer);
            return TRUE;
        }

        //
        // If the single devnode's class is LegacyDriver,
        // this is not a PnP driver
        //
        fRetStatus = (_wcsicmp(szClassGuid, LEGACYDRIVER_STRING) != 0);

#ifdef DEBUG_LOGLOG
            LOG_Write(L"IsPnPDriver: %ws %ws a PnP driver\n",
                       ServiceName, fRetStatus ? L"is" : L"is not");
#endif
    }

    LocalFree(pBuffer);
    return fRetStatus;
}

BOOL
BackupHives(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Copy the system hive over into the repair directory.  This is required
    if the user has asked us to fixup the critical device database (which
    will change the contents of the system hive).

Arguments:

    None.

Return Value:

    TRUE if the operation succeeds, FALSE otherwise.
===============================================================================
--*/
{
    WCHAR szRepairSystemHive[MAX_PATH];
    WCHAR szRepairSystemHiveBackup[MAX_PATH];
    HKEY  hkey;
    LONG  lStatus;


    //
    // Get the full pathname of the "system" file in the repair directory.
    //
    if (!GetWindowsDirectory(szRepairSystemHive, MAX_PATH))
        return FALSE;

    StringCchCat (szRepairSystemHive, AS ( szRepairSystemHive ), L"\\repair\\system");

    //
    // Generate the full pathname of the backup copy of the current "system" file.
    StringCchCopy (szRepairSystemHiveBackup, AS ( szRepairSystemHiveBackup ), szRepairSystemHive);
    //
    // ISSUE-2002/02/26-brucegr: This should be szRepairSystemHiveBackup!!!!
    //
    StringCchCat(szRepairSystemHive, AS ( szRepairSystemHive ),  L".bak");

    //
    //  Open the root of the system hive.
    //
    lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"system",
                           REG_OPTION_RESERVED,
                           READ_CONTROL,
                           &hkey);

    if (lStatus == ERROR_SUCCESS) {
        //
        // First, rename the current "system" file to "system.bak", so that
        // we can restore it if RegSaveKey fails.
        //
        SetFileAttributes(szRepairSystemHiveBackup, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szRepairSystemHiveBackup);
        SetFileAttributes(szRepairSystemHive, FILE_ATTRIBUTE_NORMAL);
        MoveFile(szRepairSystemHive, szRepairSystemHiveBackup);

        //
        // Save the registry system hive into the "system" file.
        //

        //
        // ISSUE-2002/02/26-brucegr: We need to make sure we have SE_BACKUP_NAME privilege
        //
        lStatus = RegSaveKey(hkey, szRepairSystemHive, NULL);

        if (lStatus == ERROR_SUCCESS) {
            //
            // Now we can safely delete the backup copy.
            //
            DeleteFile(szRepairSystemHiveBackup);
        }
        else {
            //
            // Otherwise we need to restore the system file from the backup.
            //
            MoveFile(szRepairSystemHiveBackup, szRepairSystemHive);
        }

        RegCloseKey(hkey);
    }

    return (lStatus == ERROR_SUCCESS);
}


VOID
FreeSysprepContext(
    IN PVOID SysprepContext
    )
{
    PSYSPREP_QUEUE_CONTEXT Context = SysprepContext;

    try {
        if(Context->DefaultContext) {
            SetupTermDefaultQueueCallback(Context->DefaultContext);
        }
        free(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


PVOID
InitSysprepQueueCallback(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Initialize the data structure used for the callback that fires when
    we commit the file copy queue.

Arguments:


Return Value:


===============================================================================
--*/
{
    PSYSPREP_QUEUE_CONTEXT SysprepContext;

    SysprepContext = malloc(sizeof(SYSPREP_QUEUE_CONTEXT));

    if(SysprepContext) {

        SysprepContext->DirectoryOnSourceDevice = NULL;
        SysprepContext->DiskDescription = NULL;
        SysprepContext->DiskTag = NULL;

        SysprepContext->DefaultContext = SetupInitDefaultQueueCallbackEx( NULL,
                                                                          INVALID_HANDLE_VALUE,
                                                                          0,
                                                                          0,
                                                                          NULL );
    }

    return SysprepContext;
}


UINT
SysprepQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
/*++
===============================================================================
Routine Description:

    Callback function for setupapi to use as he's copying files.

    We'll use this to ensure that the files we copy get appended to
    setup.log, which in turn may get used when/if the user ever tries to
    use Windows repair capabilities.

Arguments:


Return Value:


===============================================================================
--*/
{
UINT                    Status;
PSYSPREP_QUEUE_CONTEXT  SysprepContext = Context;
PFILEPATHS              FilePaths = (PFILEPATHS)Param1;

    // 
    // Make sure that if we get these notification to check Param1.
    //
    switch (Notification) {
        case SPFILENOTIFY_COPYERROR:
            {
                //
                // Copy error happened log and skip this file.
                //
#ifdef DEBUG_LOGLOG
                LOG_Write(L"SysprepQueueCallback: SPFILENOTIFY_COPYERROR - %s, %s, %s, %s, %s", 
                   (PWSTR) FilePaths->Source,
                   (PWSTR) FilePaths->Target,
                   SysprepContext->DirectoryOnSourceDevice,
                   SysprepContext->DiskDescription,
                   SysprepContext->DiskTag);
#endif
                return FILEOP_SKIP;
            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:        
            {
                //
                // If user specified an OEM driver file and path break and let 
                // the DefaultQueueCallback handle it.
                //
               PSOURCE_MEDIA pSourceMedia = (PSOURCE_MEDIA)Param1;
               if (pSourceMedia) {
#ifdef DEBUG_LOGLOG
                    LOG_Write(L"SysprepQueueCallback: SPFILENOTIFY_NEEDMEDIA - %s, %s, %s, %s, %s", 
                       (PWSTR) pSourceMedia->SourcePath,
                       (PWSTR) pSourceMedia->SourceFile,
                       (PWSTR) pSourceMedia->Tagfile,
                       (PWSTR) pSourceMedia->Description);
#endif
                    if (pSourceMedia->SourcePath && lstrlen(pSourceMedia->SourcePath) && 
                        pSourceMedia->SourceFile && lstrlen(pSourceMedia->SourceFile))
                        break; // continue if SourcePath and SourceFile is specified
                    else
                        return FILEOP_SKIP;
               }           
            }
            break;

        default:
            break;
    }

    //
    // Use default processing, then check for errors.
    //
    Status = SetupDefaultQueueCallback( SysprepContext->DefaultContext,
                                        Notification,
                                        Param1,
                                        Param2 );

    switch(Notification) {
        case SPFILENOTIFY_ENDCOPY:

            //
            // The copy just finished.  Let's log the
            // file.
            //
            LogRepairInfo( (PWSTR) FilePaths->Source,
                           (PWSTR) FilePaths->Target,
                           SysprepContext->DirectoryOnSourceDevice,
                           SysprepContext->DiskDescription,
                           SysprepContext->DiskTag );

            break;

        default:
            break;
    }

    return Status;

}


BOOL
ValidateAndChecksumFile(
    IN  PCWSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++
===============================================================================

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    Filename - supplies full NT path of file to check.

    IsNtImage - Receives flag indicating whether the file is an
                NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
            image (for nt images) and that we can read the image.

Return Value:

    BOOL - Returns TRUE if the flie was validated, and in this case,
           IsNtImage, Checksum, and Valid will contain the result of
           the validation.
           This function will return FALSE, if the file could not be
           validated, and in this case, the caller should call GetLastError()
           to find out why this function failed.

===============================================================================
--*/

{
DWORD           Error;
PVOID           BaseAddress;
ULONG           FileSize;
HANDLE          hFile;
HANDLE          hSection;
PIMAGE_NT_HEADERS NtHeaders;
ULONG           HeaderSum;


    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //

    Error = pSetupOpenAndMapFileForRead( Filename,
                                        &FileSize,
                                        &hFile,
                                        &hSection,
                                        &BaseAddress );

    if( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        return(FALSE);
    }

    if( FileSize == 0 ) {
        *IsNtImage = FALSE;
        *Checksum = 0;
        *Valid = TRUE;
        CloseHandle( hFile );
        return(TRUE);
    }


    try {
        NtHeaders = CheckSumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        *Checksum = 0;
        NtHeaders = NULL;
    }

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    pSetupUnmapAndCloseFile( hFile, hSection, BaseAddress );
    return( TRUE );
}


VOID
LogRepairInfo(
    IN  PWSTR  Source,
    IN  PWSTR  Target,
    IN  PWSTR  DirectoryOnSourceDevice,
    IN  PWSTR  DiskDescription,
    IN  PWSTR  DiskTag
    )
/*++
===============================================================================
Routine Description:

    This function will log the fact that a file was installed into the
    machine.  This will enable Windows repair functionality to be alerted
    that in case of a repair, this file will need to be restored.

Arguments:


Return Value:


===============================================================================
--*/
{
WCHAR           RepairLog[MAX_PATH];
BOOLEAN         IsNtImage;
ULONG           Checksum;
BOOLEAN         Valid;
WCHAR           Filename[MAX_PATH];
WCHAR           SourceName[MAX_PATH];
DWORD           LastSourceChar, LastTargetChar;
DWORD           LastSourcePeriod, LastTargetPeriod;
WCHAR           Line[MAX_PATH];
WCHAR           tmp[MAX_PATH];


    if (!GetWindowsDirectory( RepairLog, MAX_PATH ))
        return;

    StringCchCat( RepairLog, AS ( RepairLog ), L"\\repair\\setup.log" );

    if( ValidateAndChecksumFile( Target, &IsNtImage, &Checksum, &Valid )) {

        //
        // Strip off drive letter.
        //

        StringCchPrintf(
            Filename,
            AS ( Filename ),
            L"\"%s\"",
            Target+2
            );

        //
        // Convert source name to uncompressed form.
        //
        StringCchCopy ( SourceName, AS ( SourceName ), wcsrchr( Source, (WCHAR)'\\' ) + 1 );

        if(!SourceName [ 0 ] ) {
            return;
        }
        LastSourceChar = wcslen (SourceName) - 1;

        if(SourceName[LastSourceChar] == L'_') {
            LastSourcePeriod = (DWORD)(wcsrchr( SourceName, (WCHAR)'.' ) - SourceName);

            if(LastSourceChar - LastSourcePeriod == 1) {
                //
                // No extension - just truncate the "._"
                //
                SourceName[LastSourceChar-1] = L'\0';
            } else {
                //
                // Make sure the extensions on source and target match.
                // If this fails, we can't log the file copy
                //
                LastTargetChar = wcslen (Target) - 1;
                LastTargetPeriod = (ULONG)(wcsrchr( Target, (WCHAR)'.' ) - Target);

                if( _wcsnicmp(
                    SourceName + LastSourcePeriod,
                    Target + LastTargetPeriod,
                    LastSourceChar - LastSourcePeriod - 1 )) {
                    return;
                }

                if(LastTargetChar - LastTargetPeriod < 3) {
                    //
                    // Short extension - just truncate the "_"
                    //
                    SourceName[LastSourceChar] = L'\0';
                } else {
                    //
                    // Need to replace "_" with last character from target
                    //
                    SourceName[LastSourceChar] = Target[LastTargetChar];
                }
            }
        }





        //
        // Write the line.
        //
        if( (DirectoryOnSourceDevice) &&
            (DiskDescription) &&
            (DiskTag) ) {

            //
            // Treat this as an OEM file.
            //
            StringCchPrintf( Line,
                             AS ( Line ),
                             L"\"%s\",\"%x\",\"%s\",\"%s\",\"%s\"",
                             SourceName,
                             Checksum,
                             DirectoryOnSourceDevice,
                             DiskDescription,
                             DiskTag );

        } else {

            //
            // Treat this as an "in the box" file.
            //
            StringCchPrintf( Line,
                             AS ( Line ),      
                             L"\"%s\",\"%x\"",
                             SourceName,
                             Checksum );
        }

        if (GetPrivateProfileString(L"Files.WinNt",Filename,L"",tmp,sizeof(tmp)/sizeof(tmp[0]),RepairLog)) {
            //
            // there is already an entry for this file present (presumably
            // from textmode phase of setup.) Favor this entry over what we
            // are about to add
            //
        } else {
            WritePrivateProfileString(
                L"Files.WinNt",
                Filename,
                Line,
                RepairLog);
        }

    }
}




#ifdef _X86_

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    )

/*++
===============================================================================
Routine Description:

    Changes the boot countdown value in boot.ini.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.
===============================================================================
--*/

{
HFILE               hfile;
ULONG               FileSize;
PUCHAR              buf = NULL,p1,p2;
BOOL                b;
CHAR                TimeoutLine[256];
CHAR                szBootIni[] = "?:\\BOOT.INI";
UINT                OldMode;
WIN32_FIND_DATA     findData;
HANDLE              FindHandle;
WCHAR               DriveLetter;
WCHAR               tmpBuffer[MAX_PATH];

    //
    // Generate path to the boot.ini file.  This is actually more
    // complicated than one might think.  It will almost always
    // be located on c:, but the user may have remapped his drive
    // letters.
    //
    // We'll use a brute-force method here and look for the first
    // instance of boot.ini.  We've got two factors going for us
    // here:
    //   1. boot.ini be on the lower-drive letters, so look there
    //      first
    //   2. I can't think of a scenario where he would have multiple
    //      boot.ini files, so the first one we find is going to be
    //      the right one.
    //

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    StringCchCopy ( tmpBuffer, AS ( tmpBuffer ), TEXT( "?:\\BOOT.INI" ) );
    for( DriveLetter = 'c'; DriveLetter <= 'z'; DriveLetter++ ) {
        tmpBuffer[0] = DriveLetter;

        //
        // See if he's there.
        //
        //
        // ISSUE-2002/02/26-brucegr: Use GetFileAttributes/GetFileAttributesEx instead of FindFirstFile!
        //
        FindHandle = FindFirstFile( tmpBuffer, &findData );

        if(FindHandle != INVALID_HANDLE_VALUE) {

            //
            // Yep.  Close him and break the for-loop.
            //
            FindClose(FindHandle);
            break;
        }
    }
    SetErrorMode(OldMode);

    if( DriveLetter > 'z' ) {
        return FALSE;
    }

    szBootIni[0] = (CHAR)DriveLetter;

    StringCchPrintfA (TimeoutLine,AS ( TimeoutLine ), "timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //
    //
    // ISSUE-2002/02/26-brucegr: Why can't we use PrivateProfile APIs?
    //
    b = FALSE;
    hfile = _lopen(szBootIni,OF_READ);
    if(hfile != HFILE_ERROR) {

        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {

            if((_llseek(hfile,0,0) != -1)
            && (buf = malloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            free(buf);
        }
        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        free(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.
    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributesA(szBootIni,FILE_ATTRIBUTE_NORMAL);

    hfile = _lcreat(szBootIni,0);
    if(hfile == HFILE_ERROR) {
        free(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile,buf        ,p1-buf             ) != (UINT)(-1))
      &&  (_lwrite(hfile,TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile,p2         ,buf+FileSize-p2    ) != (UINT)(-1)));

    _lclose(hfile);
    free(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    SetFileAttributesA(
        szBootIni,
        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN
        );

    return(b);
}

#else

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    )

/*++
===============================================================================
Routine Description:

    Changes the boot timeout value in NVRAM.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.
===============================================================================
--*/

{
    NTSTATUS Status;
    BOOT_OPTIONS BootOptions;

    BootOptions.Version = BOOT_OPTIONS_VERSION;
    BootOptions.Length =  sizeof(BootOptions);
    BootOptions.Timeout = Timeout;

    pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE);
    Status = NtSetBootOptions(&BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
    return (NT_SUCCESS(Status));
}

#endif

// Disable System Restore
//
void DisableSR()
{
    HINSTANCE   hInst   = LoadLibrary(FILE_SRCLIENT_DLL);
    if (hInst) {
        FARPROC fnProc;
        if ( fnProc = GetProcAddress(hInst, "DisableSR") ) {
            fnProc(NULL);
        }

        FreeLibrary(hInst);
    }
}

// Enable System Restore
//
void EnableSR()
{
    HINSTANCE   hInst   = LoadLibrary(FILE_SRCLIENT_DLL);
    if (hInst) {
        FARPROC fnProc;
        if ( fnProc = GetProcAddress(hInst, "EnableSR") ) {
            fnProc(NULL);
        }

        FreeLibrary(hInst);
    }
}

LPTSTR OPKAddPathN(LPTSTR lpPath, LPCTSTR lpName, DWORD cbPath)
{
    LPTSTR lpTemp = lpPath;

    // Validate the parameters passed in.
    //
    if ( ( lpPath == NULL ) ||
         ( lpName == NULL ) )
    {
        return NULL;
    }

    // Find the end of the path.
    //
    while ( *lpTemp )
    {
        lpTemp = CharNext(lpTemp);
        if ( cbPath )
        {
            cbPath--;
        }
    }

    // If no trailing backslash on the path then add one.
    //
    if ( ( lpTemp > lpPath ) &&
         ( *CharPrev(lpPath, lpTemp) != CHR_BACKSLASH ) )
    {
        // Make sure there is room in the path buffer to
        // add the backslash and the null terminator.
        //
        if ( cbPath < 2 )
        {
            return NULL;
        }

        *lpTemp = CHR_BACKSLASH;
        lpTemp = CharNext(lpTemp);
        cbPath--;
    }
    else
    {
        // Make sure there is at least room for the null
        // terminator.
        //
        if ( cbPath < 1 )
        {
            return NULL;
        }
    }

    // Make sure there is no preceeding spaces or backslashes
    // on the name to add.
    //
    while ( ( *lpName == CHR_SPACE ) ||
            ( *lpName == CHR_BACKSLASH ) )
    {
        lpName = CharNext(lpName);
    }

    // Add the new name to existing path.
    //
    lstrcpyn(lpTemp, lpName, cbPath);

    // Trim trailing spaces from result.
    //
    while ( ( lpTemp > lpPath ) &&
            ( *(lpTemp = CharPrev(lpPath, lpTemp)) == CHR_SPACE ) )
    {
        *lpTemp = NULLCHR;
    }

    return lpPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization

Author:

    Richard Firth (rfirth) 15-May-1991

Revision History:

    03-Jan-1992 rfirth
        Added ILLEGAL_FAT_CHARS and ILLEGAL_HPFS_CHARS (from fsrtl\name.c)

    27-Sep-1991 JohnRo
        Changed TEXT macro usage to allow UNICODE.
--*/

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0   TEXT(    "\001\002\003\004\005\006\007")
#define CTRL_CHARS_1   TEXT("\010\011\012\013\014\015\016\017")
#define CTRL_CHARS_2   TEXT("\020\021\022\023\024\025\026\027")
#define CTRL_CHARS_3   TEXT("\030\031\032\033\034\035\036\037")

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets
//

#define NON_COMPONENT_CHARS TEXT("\\/:")
#define ILLEGAL_CHARS_STR   TEXT("\"<>|")
#define DOT_AND_SPACE_STR   TEXT(". ")
#define PATH_SEPARATORS     TEXT("\\/")

//
// Combinations of the above
//

#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  TEXT("\"/\\[]:|<>+=;,?") CTRL_CHARS_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |
//

#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR TEXT("\"*+,/:;<=>?[\\]|")

//
// Characters which may not appear in a canonicalized HPFS filename are:
//
//  0x00 - 0x1f " * / : < > ? \ |
//

#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR TEXT("\"*/:<>?\\|")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\undo.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    undo.h

Abstract:

    Declares the interfaces for osuninst.lib, a library of uninstall functions.

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef enum {
    Uninstall_Valid = 0,                    // uninstall is possible (backup image passed sanity check)
    Uninstall_DidNotFindRegistryEntries,    // reg entries that point to backup image/prev os data are gone
    Uninstall_DidNotFindDirOrFiles,         // one or more backup files are missing, or undo dir is gone
    Uninstall_InvalidOsVersion,             // api called on an unexpected platform (example: user copied dll to Win2k)
    Uninstall_NotEnoughPrivileges,          // can't evaluate backup image because of lack of authority
    Uninstall_FileWasModified,              // backup image was tampered with by someone
    Uninstall_Unsupported,                  // uninstall is not supported
    Uninstall_NewImage,                     // image is less than 7 days old (not exposed by osuninst.dll)
    Uninstall_CantRetrieveSystemInfo,       // cannot retrieve integrity information from registry
    Uninstall_WrongDrive,                   // user had changed layout,disk,file system.
    Uninstall_DifferentNumberOfDrives,      // user had added/removed drive(s)
    Uninstall_NotEnoughSpace,               // not enough space to perform uninstall
    Uninstall_Exception,                    // caller passed in invalid arg to an osuninst.dll api
    Uninstall_OldImage,                     // image is more than 30 days old
    Uninstall_NotEnoughMemory,              // not enough memory to perform uninstall
    Uninstall_DifferentDriveLetter,         // user has changed drive letter
    Uninstall_DifferentDriveFileSystem,     // user has changed drive file system
    Uninstall_DifferentDriveGeometry,       // drive geometry has been changed
    Uninstall_DifferentDrivePartitionInfo   // drive partition has changed
} UNINSTALLSTATUS;

typedef enum {
    Uninstall_DontCare = 0,                 // try to avoid using this value; instead expand this enum whenever possible
    Uninstall_FatToNtfsConversion,          // caller is going to convert FAT to NTFS
    Uninstall_PartitionChange,              // caller is going to alter the partition configuration
    Uninstall_Upgrade                       // caller is going to upgrade the OS
} UNINSTALLTESTCOMPONENT;


//
// NOTE: BackedUpOsVersion is filled only when Uninstall_Valid is returned
//

UNINSTALLSTATUS
IsUninstallImageValid (
    IN      UNINSTALLTESTCOMPONENT ComponentToTest,
    OUT     OSVERSIONINFOEX *BackedUpOsVersion              OPTIONAL
    );

BOOL
RemoveUninstallImage (
    VOID
    );

ULONGLONG
GetUninstallImageSize (
    VOID
    );

BOOL
ProvideUiAlerts (
    IN      HWND UiParent
    );

BOOL
ExecuteUninstall (
    VOID
    );


typedef UNINSTALLSTATUS(WINAPI * ISUNINSTALLIMAGEVALID)(UNINSTALLTESTCOMPONENT, OSVERSIONINFOEX *);
typedef ULONGLONG(WINAPI * GETUNINSTALLIMAGESIZE)(VOID);
typedef BOOL(WINAPI * REMOVEUNINSTALLIMAGE)(VOID);
typedef BOOL(WINAPI * PROVIDEUIALERTS)(HWND);
typedef BOOL(WINAPI * EXECUTEUNINSTALL)(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\vdm.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    vdm.h

Abstract:

    This include file defines the usermode visible portions of the vdm support

Author:

Revision History:

--*/

/* XLATOFF */

#ifndef _VDM_H_
#define _VDM_H_



typedef enum _VdmServiceClass {
    VdmStartExecution,         // is also defined in ntos\ke\i386\biosa.asm
    VdmQueueInterrupt,
    VdmDelayInterrupt,
    VdmInitialize,
    VdmFeatures,
    VdmSetInt21Handler,
    VdmQueryDir,
    VdmPrinterDirectIoOpen,
    VdmPrinterDirectIoClose,
    VdmPrinterInitialize,
    VdmSetLdtEntries,
    VdmSetProcessLdtInfo,
    VdmAdlibEmulation,
    VdmPMCliControl
} VDMSERVICECLASS, *PVDMSERVICECLASS;


#if defined (_NTDEF_)

NTSYSCALLAPI
NTSTATUS
NtVdmControl(
    IN VDMSERVICECLASS Service,
    IN OUT PVOID ServiceData
    );

typedef struct _VdmQueryDirInfo {
    HANDLE FileHandle;
    PVOID FileInformation;
    ULONG Length;
    PUNICODE_STRING FileName;
    ULONG FileIndex;
} VDMQUERYDIRINFO, *PVDMQUERYDIRINFO;

#endif


/*
 *  The Vdm Virtual Ica
 *  note: this structure definition is duplicated in
 *        mvdm\softpc\base\inc\ica.c. KEEP IN SYNC
 *
 */
typedef struct _VdmVirtualIca{
        LONG      ica_count[8]; /* Count of Irq pending not in irr      */
        LONG      ica_int_line; /* Current pending interrupt            */
        LONG      ica_cpu_int;  /* The state of the INT line to the CPU */
        USHORT    ica_base;     /* Interrupt base address for cpu       */
        USHORT    ica_hipri;    /* Line no. of highest priority line    */
        USHORT    ica_mode;     /* Various single-bit modes             */
        UCHAR     ica_master;   /* 1 = Master; 0 = Slave                */
        UCHAR     ica_irr;      /* Interrupt Request Register           */
        UCHAR     ica_isr;      /* In Service Register                  */
        UCHAR     ica_imr;      /* Interrupt Mask Register              */
        UCHAR     ica_ssr;      /* Slave Select Register                */
} VDMVIRTUALICA, *PVDMVIRTUALICA;


//
// copied from softpc\base\system\ica.c
//
#define ICA_AEOI 0x0020
#define ICA_SMM  0x0200
#define ICA_SFNM 0x0100


#if defined(i386)
#define VDM_PM_IRETBOPSEG  0x147
#define VDM_PM_IRETBOPOFF  0x6
#define VDM_PM_IRETBOPSIZE 8
#else
#define VDM_PM_IRETBOPSEG  0xd3
#define VDM_PM_IRETBOPOFF  0x0
#define VDM_PM_IRETBOPSIZE 4
#endif

#define VDM_RM_IRETBOPSIZE 4



// VDM state which was earlier in vdmtib->flags has been moved to
// dos arena at following fixed address.
#ifdef _VDMNTOS_

#define  FIXED_NTVDMSTATE_LINEAR    VdmFixedStateLinear
#define  FIXED_NTVDMSTATE_SIZE      4

#else  // _VDMNTOS_

/* XLATON */
#define  FIXED_NTVDMSTATE_SEGMENT   0x70

#define  FIXED_NTVDMSTATE_OFFSET    0x14
#define  FIXED_NTVDMSTATE_LINEAR    ((FIXED_NTVDMSTATE_SEGMENT << 4) + FIXED_NTVDMSTATE_OFFSET)
#define  FIXED_NTVDMSTATE_SIZE      4
/* XLATOFF */

#endif // _VDMNTOS_

#if defined (i386)
  // defined on x86 only since on mips we must reference thru sas
#define  pNtVDMState                ((PULONG)FIXED_NTVDMSTATE_LINEAR)
#endif

/* XLATON */
//
// Vdm State Flags
//
#define VDM_INT_HARDWARE        0x00000001
#define VDM_INT_TIMER           0x00000002
// defined as VDM_INTS_HOOKED_IN_PM in mvdm\inc\vint.h
#define VDM_INT_HOOK_IN_PM      0x00000004

   // A bitMask which includes all interrupts
#define VDM_INTERRUPT_PENDING   (VDM_INT_HARDWARE | VDM_INT_TIMER)

#define VDM_BREAK_EXCEPTIONS    0x00000008
#define VDM_BREAK_DEBUGGER      0x00000010
#define VDM_PROFILE             0x00000020
#define VDM_ANALYZE_PROFILE     0x00000040
#define VDM_TRACE_HISTORY       0x00000080

#define VDM_32BIT_APP           0x00000100
#define VDM_VIRTUAL_INTERRUPTS  0x00000200
#define VDM_ON_MIPS             0x00000400
#define VDM_EXEC                0x00000800
#define VDM_RM                  0x00001000
#define VDM_USE_DBG_VDMEVENT    0x00004000

#define VDM_WOWBLOCKED          0x00100000
#define VDM_IDLEACTIVITY        0x00200000
#define VDM_TIMECHANGE          0x00400000
#define VDM_WOWHUNGAPP          0x00800000

#define VDM_PE_MASK             0x80000000

/* XLATOFF */

#if DBG
#define INITIAL_VDM_TIB_FLAGS (VDM_USE_DBG_VDMEVENT | VDM_BREAK_DEBUGGER | VDM_TRACE_HISTORY)
#else
#define INITIAL_VDM_TIB_FLAGS (VDM_USE_DBG_VDMEVENT | VDM_BREAK_DEBUGGER)
#endif


//
// bits defined in Eflags
//
#define EFLAGS_TF_MASK  0x00000100
#define EFLAGS_IF_MASK  0x00000200
#define EFLAGS_PL_MASK  0x00003000
#define EFLAGS_NT_MASK  0x00004000
#define EFLAGS_RF_MASK  0x00010000
#define EFLAGS_VM_MASK  0x00020000
#define EFLAGS_AC_MASK  0x00040000

//
// If the size of the structure is changed, ke\i386\instemul.asm must
// be modified too.  If not, it will fail to build
//
#pragma pack(1)
typedef struct _Vdm_InterruptHandler {
    USHORT  CsSelector;
    USHORT  Flags;
    ULONG   Eip;
} VDM_INTERRUPTHANDLER, *PVDM_INTERRUPTHANDLER;
#pragma pack()

typedef struct _Vdm_FaultHandler {
    USHORT  CsSelector;
    USHORT  SsSelector;
    ULONG   Eip;
    ULONG   Esp;
    ULONG   Flags;
} VDM_FAULTHANDLER, *PVDM_FAULTHANDLER;

#pragma pack(1)
typedef struct _VdmDpmiInfo {        /* VDMTIB */
    USHORT LockCount;
    USHORT Flags;
    USHORT SsSelector;
    USHORT SaveSsSelector;
    ULONG  SaveEsp;
    ULONG  SaveEip;
    ULONG  DosxIntIret;
    ULONG  DosxIntIretD;
    ULONG  DosxFaultIret;
    ULONG  DosxFaultIretD;
    ULONG  DosxRmReflector;
} VDM_DPMIINFO, *PVDM_DPMIINFO;
#pragma pack()

//
// Interrupt handler flags
//

#define VDM_INT_INT_GATE        0x00000001
#define VDM_INT_TRAP_GATE       0x00000000
#define VDM_INT_32              0x00000002
#define VDM_INT_16              0x00000000
#define VDM_INT_HOOKED          0x00000004

#pragma pack(1)
//
// CAVEAT: This structure was designed to be exactly 64 bytes in size.
// There is code that assumes that an array of these structures
// will fit neatly into a 4096 byte page.
//
typedef struct _VdmTraceEntry {
    USHORT Type;
    USHORT wData;
    ULONG lData;
    ULONG Time;
    ULONG eax;
    ULONG ebx;
    ULONG ecx;
    ULONG edx;
    ULONG esi;
    ULONG edi;
    ULONG ebp;
    ULONG esp;
    ULONG eip;
    ULONG eflags;
    USHORT cs;
    USHORT ds;
    USHORT es;
    USHORT fs;
    USHORT gs;
    USHORT ss;
} VDM_TRACEENTRY, *PVDM_TRACEENTRY;
#pragma pack()

#pragma pack(1)
typedef struct _VdmTraceInfo {
    PVDM_TRACEENTRY pTraceTable;
    UCHAR Flags;
    UCHAR NumPages;             // size of trace buffer in 4k pages
    USHORT CurrentEntry;
    LARGE_INTEGER TimeStamp;
} VDM_TRACEINFO, *PVDM_TRACEINFO;
#pragma pack()

//
// Definitions for flags in VDM_TRACEINFO
//

#define VDMTI_TIMER_MODE    3
#define VDMTI_TIMER_TICK    1
#define VDMTI_TIMER_PERFCTR 2
#define VDMTI_TIMER_STAT    3
#define VDMTI_TIMER_PENTIUM 3

//
// Kernel trace entry types
//
#define VDMTR_KERNEL_OP_PM  1
#define VDMTR_KERNEL_OP_V86 2
#define VDMTR_KERNEL_HW_INT 3


#if defined(i386)

typedef struct _VdmIcaUserData {
    PVOID                  pIcaLock;       // rtl critical section
    PVDMVIRTUALICA         pIcaMaster;
    PVDMVIRTUALICA         pIcaSlave;
    PULONG                 pDelayIrq;
    PULONG                 pUndelayIrq;
    PULONG                 pDelayIret;
    PULONG                 pIretHooked;
    PULONG                 pAddrIretBopTable;
    PHANDLE                phWowIdleEvent;
}VDMICAUSERDATA, *PVDMICAUSERDATA;

typedef struct _VdmDelayIntsServiceData {
        ULONG       Delay;          /* Delay Time in usecs              */
        ULONG       DelayIrqLine;   /* IRQ Number of ints delayed       */
        HANDLE      hThread;        /* Thread Handle of CurrentMonitorTeb */
}VDMDELAYINTSDATA, *PVDMDELAYINTSDATA;

typedef struct _VDMSET_INT21_HANDLER_DATA {
        ULONG       Selector;
        ULONG       Offset;
        BOOLEAN     Gate32;
}VDMSET_INT21_HANDLER_DATA, *PVDMSET_INT21_HANDLER_DATA;

typedef struct _VDMSET_LDT_ENTRIES_DATA {
        ULONG Selector0;
        ULONG Entry0Low;
        ULONG Entry0Hi;
        ULONG Selector1;
        ULONG Entry1Low;
        ULONG Entry1Hi;
}VDMSET_LDT_ENTRIES_DATA, *PVDMSET_LDT_ENTRIES_DATA;

typedef struct _VDMSET_PROCESS_LDT_INFO_DATA {
        PVOID LdtInformation;
        ULONG LdtInformationLength;
}VDMSET_PROCESS_LDT_INFO_DATA, *PVDMSET_PROCESS_LDT_INFO_DATA;

//
// Define the action code of VDM_ADLIB_DATA
//

#define ADLIB_USER_EMULATION     0      // default action
#define ADLIB_DIRECT_IO          1
#define ADLIB_KERNEL_EMULATION   2

typedef struct _VDM_ADLIB_DATA {
        USHORT VirtualPortStart;
        USHORT VirtualPortEnd;
        USHORT PhysicalPortStart;
        USHORT PhysicalPortEnd;
        USHORT Action;
}VDM_ADLIB_DATA, *PVDM_ADLIB_DATA;

//
// Definitions for Protected Mode DOS apps cli control
//

#define PM_CLI_CONTROL_DISABLE  0
#define PM_CLI_CONTROL_ENABLE   1
#define PM_CLI_CONTROL_CHECK    2
#define PM_CLI_CONTROL_SET      3
#define PM_CLI_CONTROL_CLEAR    4

typedef struct _VDM_PM_CLI_DATA {
        ULONG Control;
}VDM_PM_CLI_DATA, *PVDM_PM_CLI_DATA;

//
// Definitions for VdmInitialize
//

typedef struct _VDM_INITIALIZE_DATA {
        PVOID           TrapcHandler;
        PVDMICAUSERDATA IcaUserData;
}VDM_INITIALIZE_DATA, *PVDM_INITIALIZE_DATA;

#if defined (_NTDEF_)
typedef enum _VdmEventClass {
    VdmIO,
    VdmStringIO,
    VdmMemAccess,
    VdmIntAck,
    VdmBop,
    VdmError,
    VdmIrq13,
    VdmMaxEvent
} VDMEVENTCLASS, *PVDMEVENTCLASS;

// VdmPrinterInfo

#define VDM_NUMBER_OF_LPT       3

#define PRT_MODE_NO_SIMULATION  1
#define PRT_MODE_SIMULATE_STATUS_PORT   2
#define PRT_MODE_DIRECT_IO      3
#define PRT_MODE_VDD_CONNECTED  4

#define PRT_DATA_BUFFER_SIZE    16

typedef struct _Vdm_Printer_Info {
    PUCHAR prt_State;
    PUCHAR prt_Control;
    PUCHAR prt_Status;
    PUCHAR prt_HostState;
    USHORT prt_PortAddr[VDM_NUMBER_OF_LPT];
    HANDLE prt_Handle[VDM_NUMBER_OF_LPT];
    UCHAR  prt_Mode[VDM_NUMBER_OF_LPT];
    USHORT prt_BytesInBuffer[VDM_NUMBER_OF_LPT];
    UCHAR  prt_Buffer[VDM_NUMBER_OF_LPT][PRT_DATA_BUFFER_SIZE];
    ULONG  prt_Scratch;
} VDM_PRINTER_INFO, *PVDM_PRINTER_INFO;


typedef struct _VdmIoInfo {
    USHORT PortNumber;
    USHORT Size;
    BOOLEAN Read;
} VDMIOINFO, *PVDMIOINFO;

typedef struct _VdmFaultInfo{
    ULONG  FaultAddr;
    ULONG  RWMode;
} VDMFAULTINFO, *PVDMFAULTINFO;


typedef struct _VdmStringIoInfo {
    USHORT PortNumber;
    USHORT Size;
    BOOLEAN Rep;
    BOOLEAN Read;
    ULONG Count;
    ULONG Address;
} VDMSTRINGIOINFO, *PVDMSTRINGIOINFO;

typedef ULONG VDMBOPINFO;
typedef NTSTATUS VDMERRORINFO;


typedef ULONG VDMINTACKINFO;
#define VDMINTACK_RAEOIMASK  0x0000ffff
#define VDMINTACK_SLAVE      0x00010000
#define VDMINTACK_AEOI       0x00020000


typedef struct _VdmEventInfo {
    ULONG Size;
    VDMEVENTCLASS Event;
    ULONG InstructionSize;
    union {
        VDMIOINFO IoInfo;
        VDMSTRINGIOINFO StringIoInfo;
        VDMBOPINFO BopNumber;
        VDMFAULTINFO FaultInfo;
        VDMERRORINFO ErrorStatus;
        VDMINTACKINFO IntAckInfo;
    };
} VDMEVENTINFO, *PVDMEVENTINFO;


// Sudeepb 12-Mar-1993
// Scratch areas are used from VDMTib to get user space while
// in kernel. This allows us to make Nt APIs (faster) from kernel
// rather than Zw apis (slower). These are currently being used
// for DOS read/write.

typedef struct _Vdm_Tib {
    ULONG Size;
    PVDM_INTERRUPTHANDLER VdmInterruptTable;
    PVDM_FAULTHANDLER VdmFaultTable;
    CONTEXT MonitorContext;
    CONTEXT VdmContext;
    VDMEVENTINFO EventInfo;
    VDM_PRINTER_INFO PrinterInfo;
    ULONG TempArea1[2];                 // Scratch area
    ULONG TempArea2[2];                 // Scratch aArea
    VDM_DPMIINFO DpmiInfo;
    VDM_TRACEINFO TraceInfo;
    ULONG IntelMSW;
    LONG NumTasks;
    BOOLEAN ContinueExecution;
} VDM_TIB, *PVDM_TIB;

//
// Feature flags returned by NtVdmControl(VdmFeatures...)
//

// System/processor supports fast emulation for IF instructions
#define V86_VIRTUAL_INT_EXTENSIONS 0x00000001   // in v86 mode
#define PM_VIRTUAL_INT_EXTENSIONS  0x00000002   // in protected mode (non-flat)

#endif   // if defined _NTDEF_
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\tape.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tape.h

Abstract:

    These are the structures and defines that are used in the
    SCSI tape class drivers. The tape class driver is separated
    into two modules. Tape.c contains code common to all tape
    class drivers including the driver's major entry points.
    The major entry point names each begin with the prefix
    'ScsiTape.' The second module is the device specific code.
    It provides support for a set of functions. Each device
    specific function name is prefixed by 'Tape.'

Author:

    Mike Glass

Revision History:

--*/

#include "scsi.h"
#include "class.h"

//
// Define the maximum inquiry data length.
//

#define MAXIMUM_TAPE_INQUIRY_DATA 252

//
// Tape device data
//

typedef struct _TAPE_DATA {
     ULONG        Flags;
     ULONG        CurrentPartition;
     PVOID        DeviceSpecificExtension;
     PSCSI_INQUIRY_DATA InquiryData;
} TAPE_DATA, *PTAPE_DATA;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION) + sizeof(TAPE_DATA)


//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;


//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;


//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;



//
// The following routines are the exported entry points for
// all tape class drivers. Note all these routines name start
// with 'ScsiTape.'
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ScsiTapeInitialize(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScsiTapeCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiTapeReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiTapeDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



//
// The following routines are provided by the tape
// device-specific module. Each routine name is
// prefixed with 'Tape.'

NTSTATUS
TapeCreatePartition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeErase(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TapeError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
TapeGetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapePrepare(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
TapeVerifyInquiry(
    IN PSCSI_INQUIRY_DATA LunInfo
    );

NTSTATUS
TapeWriteMarks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\vdmapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1998 Microsoft Corporation

Module Name:

    vdmapi.h

Abstract:

    This module defines the private MVDM APIs

Created:

    02-Apr-1992

Revision History:

    Created 02-Apr-1992 Sudeep Bharati

--*/

#define MAXIMUM_VDM_COMMAND_LENGTH	128
#define MAXIMUM_VDM_ENVIORNMENT 	32*1024
#define MAXIMUM_VDM_CURRENT_DIR 	64

// The following value can be used to allocate space for the largest possible
// path string in ansi, including directory, drive letter and file name.
// I originally coded this with 13 for the path name, but DOS seems to be
// able to handle one more, thus the 14.
#define MAXIMUM_VDM_PATH_STRING     MAXIMUM_VDM_CURRENT_DIR+3+14

// VDMState defines
#define ASKING_FOR_FIRST_COMMAND   0x1   // Very First call.
#define ASKING_FOR_WOW_BINARY      0x2   // Caller is WOWVDM
#define ASKING_FOR_DOS_BINARY      0x4   // Caller is DOSVDM
#define ASKING_FOR_SECOND_TIME     0x8   // Caller is asking second time after
#define INCREMENT_REENTER_COUNT   0x10   // Increment the re-entrancy count
#define DECREMENT_REENTER_COUNT   0x20   // Decrement the re-entrancy count
#define NO_PARENT_TO_WAKE         0x40   // Just get the next command, dont wake up anyone
                                         // allocating bigger buffers.
#define RETURN_ON_NO_COMMAND      0x80   // if there is no command return without blocking
#define ASKING_FOR_PIF           0x100   // To get the exe name to find out PIF
                                         // early in the VDM initialization.
#define STARTUP_INFO_RETURNED    0x200   // on return if this bit is set means
                                         // startupinfo structure was filled in.
#define ASKING_FOR_ENVIRONMENT   0x400   // ask for environment only
#define ASKING_FOR_SEPWOW_BINARY 0x800   // Caller is Separate WOW

typedef struct _VDMINFO {
    ULONG  iTask;
    ULONG  dwCreationFlags;
    ULONG  ErrorCode;
    ULONG  CodePage;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    LPVOID CmdLine;
    LPVOID AppName;
    LPVOID PifFile;
    LPVOID CurDirectory;
    LPVOID Enviornment;
    ULONG  EnviornmentSize;
    STARTUPINFOA StartupInfo;
    LPVOID Desktop;
    ULONG  DesktopLen;
    LPVOID Title;
    ULONG  TitleLen;
    LPVOID Reserved;
    ULONG  ReservedLen;
    USHORT CmdSize;
    USHORT AppLen;
    USHORT PifLen;
    USHORT CurDirectoryLen;
    USHORT VDMState;
    USHORT CurDrive;
    BOOLEAN fComingFromBat;
} VDMINFO, *PVDMINFO;


// for CmdBatNotification

#define CMD_BAT_OPERATION_TERMINATING   0
#define CMD_BAT_OPERATION_STARTING      1

//
// Message sent by BaseSrv to shared WOWEXEC to tell it to call
// GetNextVDMCommand.  No longer will a thread in WOW be blocked
// in GetNextVDMCommand all the time.
//

#define WM_WOWEXECSTARTAPP         (WM_USER)    // also in mvdm\inc\wowinfo.h

//
//  MVDM apis
//

VOID
APIENTRY
VDMOperationStarted(
    IN BOOL IsWowCaller
    );

BOOL
APIENTRY
GetNextVDMCommand(
    PVDMINFO pVDMInfo
    );

VOID
APIENTRY
ExitVDM(
    IN BOOL IsWowCaller,
    IN ULONG iWowTask
    );

BOOL
APIENTRY
SetVDMCurrentDirectories(
    IN ULONG  cchCurDir,
    IN CHAR   *lpszCurDir
);

ULONG
APIENTRY
GetVDMCurrentDirectories(
    IN ULONG  cchCurDir,
    IN CHAR   *lpszCurDir
);

VOID
APIENTRY
CmdBatNotification(
    IN ULONG    fBeginEnd
);

NTSTATUS
APIENTRY
RegisterWowExec(
    IN HANDLE   hwndWowExec
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\vdmtib.inc ===
IFDEF NEC_98
FIXED_NTVDMSTATE_SEGMENT equ 00060H
else
FIXED_NTVDMSTATE_SEGMENT equ 00070H
endif
FIXED_NTVDMSTATE_OFFSET equ 00014H
FIXED_NTVDMSTATE_LINEAR EQU     ((FIXED_NTVDMSTATE_SEGMENT  SHL  4 ) + FIXED_NTVDMSTATE_OFFSET)
FIXED_NTVDMSTATE_SIZE equ 00004H

;
;  VdmFlags
;

VDM_INT_HARDWARE equ 00001H
VDM_INT_TIMER equ 00002H
VDM_INTERRUPT_PENDING equ 00003H
VDM_INTS_HOOKED_IN_PM equ 00004H
VDM_BREAK_EXCEPTIONS equ 00008H
VDM_BREAK_DEBUGGER equ 00010H
VDM_PROFILE equ 00020H
VDM_ANALYZE_PROFILE equ 00040H
VDM_TRACE_HISTORY equ 00080H
VDM_32BIT_APP equ 00100H
VDM_VIRTUAL_INTERRUPTS equ 00200H
VDM_VIRTUAL_AC equ 040000H
VDM_VIRTUAL_NT equ 04000H
MIPS_BIT_MASK equ 00400H
VDM_ON_MIPS equ 00400H
VDM_EXEC equ 00800H
VDM_RM equ 01000H
VDM_USE_DBG_VDMEVENT equ 04000H
VDM_WOWBLOCKED equ 0100000H
VDM_IDLEACTIVITY equ 0200000H
VDM_WOWHUNGAPP equ 0800000H
VDM_PE_MASK equ 080000000H

;
;  Interrupt handler flags
;

VDM_INT_INT_GATE equ 00001H
VDM_INT_TRAP_GATE equ 00000H
VDM_INT_32 equ 00002H
VDM_INT_16 equ 00000H
VDM_INT_HOOKED equ 00004H

;
;  EFlags values
;

EFLAGS_TF_MASK equ 00100H
EFLAGS_INTERRUPT_MASK equ 00200H
EFLAGS_IOPL_MASK equ 03000H
EFLAGS_NT_MASK equ 04000H

;
;  Selector Flags
;

SEL_TYPE_READ equ 00001H
SEL_TYPE_WRITE equ 00002H
SEL_TYPE_EXECUTE equ 00004H
SEL_TYPE_BIG equ 00008H
SEL_TYPE_ED equ 00010H
SEL_TYPE_2GIG equ 00020H

;
;  VdmEvent Enumerations
;

VdmIO equ 00000H
VdmStringIO equ 00001H
VdmMemAccess equ 00002H
VdmIntAck equ 00003H
VdmBop equ 00004H
VdmError equ 00005H
VdmIrq13 equ 00006H
VdmMaxEvent equ 00007H

;
;  VdmTib offsets
;

VtMonitorContext equ 0000CH
VtVdmContext equ 002D8H
VtInterruptTable equ 00004H
VtFaultTable equ 00008H
VtEventInfo equ 005A4H
VtEIEvent equ 005A8H
VtEIInstSize equ 005ACH
VtEIBopNumber equ 005B0H
VtEIIntAckInfo equ 005B0H
VtDpmiInfo equ 00634H
EiEvent equ 00004H
EiInstructionSize equ 00008H
EiBopNumber equ 0000CH
EiIntAckInfo equ 0000CH

;
;  WOW TD offsets
;

WtdFastWowEsp equ 00008H

;
;  VdmInterrupHandler offsets
;

ViCsSelector equ 00000H
ViEip equ 00004H
ViFlags equ 00002H
VDM_INTERRUPT_HANDLER_SIZE equ 00008H

;
;  VdmFaultHandler offsets
;

VfCsSelector equ 00000H
VfEip equ 00004H
VfSsSelector equ 00002H
VfEsp equ 00008H
VfFlags equ 0000CH
VDM_FAULT_HANDLER_SIZE equ 00010H

;
;  VdmDpmiInfo offsets
;

VpLockCount equ 00000H
VpFlags equ 00002H
VpSsSelector equ 00004H
VpSaveSsSelector equ 00006H
VpSaveEsp equ 00008H
VpSaveEip equ 0000CH
VpDosxIntIret equ 00010H
VpDosxIntIretD equ 00014H
VpDosxFaultIret equ 00018H
VpDosxFaultIretD equ 0001CH
VpDosxRmReflector equ 00020H

;
;  VdmTrace codes
;

VDMTR_KERNEL_OP_PM equ 00001H
VDMTR_KERNEL_OP_V86 equ 00002H
VDMTR_KERNEL_HW_INT equ 00003H

;
;  Misc defines
;

DBG_SINGLESTEP equ 00005H
DBG_BREAK equ 00006H
DBG_GPFAULT equ 00007H
DBG_STACKFAULT equ 00010H
STATUS_VDM_EVENT equ 040000005H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wbasek.h ===
/************************************************************************
*                                                                       *
*   wbasek.h -- This header is included by ntuser\kernel\userk.h        *
*                                                                       *
*   Copyright (c) Microsoft Corp.  All rights reserved.                 *
*                                                                       *
************************************************************************/
#ifndef _WBASEK_
#define _WBASEK_


#define WINBASEAPI DECLSPEC_IMPORT
#define WAIT_FAILED ((DWORD)0xFFFFFFFF)
#define WAIT_OBJECT_0       ((STATUS_WAIT_0 ) + 0 )
#define WAIT_ABANDONED         ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_ABANDONED_0       ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_IO_COMPLETION                  STATUS_USER_APC
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;

//
// System time is represented with the following structure:
//


typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

#define INFINITE            0xFFFFFFFF  // Infinite timeout
#define MAXINTATOM 0xC000
#define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))
#define INVALID_ATOM ((ATOM)0)
#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_USECOUNTCHARS    0x00000008
#define STARTF_USEFILLATTRIBUTE 0x00000010
#define STARTF_RUNFULLSCREEN    0x00000020  // ignored for non-x86 platforms
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USESTDHANDLES    0x00000100
#define STARTF_USEHOTKEY        0x00000200
#define STARTF_HASSHELLDATA     0x00000400

#endif // _WBASEK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\winnlsp.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winnlsp.h

Abstract:

    Private procedure declarations, constant definitions, and macros for the
    NLS component.

--*/

#ifndef _WINNLSP_
#define _WINNLSP_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Flags for DLL Code Page Translation Function.
//
#define NLS_CP_CPINFO             0x10000000
#define NLS_CP_CPINFOEX           0x20000000
#define NLS_CP_MBTOWC             0x40000000
#define NLS_CP_WCTOMB             0x80000000


#define NORM_STOP_ON_NULL         0x10000000  // stop at the null termination

#define LCMAP_IGNOREDBCS          0x80000000  // don't casemap DBCS characters

#define LOCALE_IGEOID                 0x0000005B   // geographical location id
//
// LCType to represent the registry locale value
//
#define LOCALE_SLOCALE                (-1)
#define DATE_ADDHIJRIDATETEMP     0x80000000  // use AddHijriDateTemp reg value
WINBASEAPI
BOOL
WINAPI
InvalidateNLSCache(void);


//
//  This private API is only called by the Complex Script
//  Language Pack (CSLPK).
//
ULONG
WINAPI NlsGetCacheUpdateCount(void);


//
// This API is called only from intl.cpl when the user
// locale changes.
//
void
WINAPI
NlsResetProcessLocale(void);

//
// This API is called by system console Apps
//
LANGID
WINAPI
SetThreadUILanguage(WORD wReserved);

//
// This API can be used to verify if a UI language is installed.
//
BOOL
WINAPI
IsValidUILanguage(LANGID UILangID);
//
// These definitions are used by both winnls and base\server
//

//
//  Names of Registry Value Entries.
//
#define NLS_VALUE_ACP              L"ACP"
#define NLS_VALUE_OEMCP            L"OEMCP"
#define NLS_VALUE_MACCP            L"MACCP"
#define NLS_VALUE_DEFAULT          L"Default"

//  User Info
#define NLS_VALUE_LOCALE           L"Locale"
#define NLS_VALUE_SLANGUAGE        L"sLanguage"
#define NLS_VALUE_ICOUNTRY         L"iCountry"
#define NLS_VALUE_SCOUNTRY         L"sCountry"
#define NLS_VALUE_SLIST            L"sList"
#define NLS_VALUE_IMEASURE         L"iMeasure"
#define NLS_VALUE_IPAPERSIZE       L"iPaperSize"
#define NLS_VALUE_SDECIMAL         L"sDecimal"
#define NLS_VALUE_STHOUSAND        L"sThousand"
#define NLS_VALUE_SGROUPING        L"sGrouping"
#define NLS_VALUE_IDIGITS          L"iDigits"
#define NLS_VALUE_ILZERO           L"iLZero"
#define NLS_VALUE_INEGNUMBER       L"iNegNumber"
#define NLS_VALUE_SNATIVEDIGITS    L"sNativeDigits"
#define NLS_VALUE_IDIGITSUBST      L"NumShape"
#define NLS_VALUE_SCURRENCY        L"sCurrency"
#define NLS_VALUE_SMONDECIMALSEP   L"sMonDecimalSep"
#define NLS_VALUE_SMONTHOUSANDSEP  L"sMonThousandSep"
#define NLS_VALUE_SMONGROUPING     L"sMonGrouping"
#define NLS_VALUE_ICURRDIGITS      L"iCurrDigits"
#define NLS_VALUE_ICURRENCY        L"iCurrency"
#define NLS_VALUE_INEGCURR         L"iNegCurr"
#define NLS_VALUE_SPOSITIVESIGN    L"sPositiveSign"
#define NLS_VALUE_SNEGATIVESIGN    L"sNegativeSign"
#define NLS_VALUE_STIMEFORMAT      L"sTimeFormat"
#define NLS_VALUE_STIME            L"sTime"
#define NLS_VALUE_ITIME            L"iTime"
#define NLS_VALUE_ITLZERO          L"iTLZero"
#define NLS_VALUE_ITIMEMARKPOSN    L"iTimePrefix"
#define NLS_VALUE_S1159            L"s1159"
#define NLS_VALUE_S2359            L"s2359"
#define NLS_VALUE_SSHORTDATE       L"sShortDate"
#define NLS_VALUE_SDATE            L"sDate"
#define NLS_VALUE_IDATE            L"iDate"
#define NLS_VALUE_SYEARMONTH       L"sYearMonth"
#define NLS_VALUE_SLONGDATE        L"sLongDate"
#define NLS_VALUE_ICALENDARTYPE    L"iCalendarType"
#define NLS_VALUE_IFIRSTDAYOFWEEK  L"iFirstDayOfWeek"
#define NLS_VALUE_IFIRSTWEEKOFYEAR L"iFirstWeekOfYear"


//
//  String constants for CreateSection/OpenSection name string.
//
#define NLS_SECTION_CPPREFIX       L"\\NLS\\NlsSectionCP"
#define NLS_SECTION_LANGPREFIX     L"\\NLS\\NlsSectionLANG"

#define NLS_SECTION_UNICODE        L"\\NLS\\NlsSectionUnicode"
#define NLS_SECTION_LOCALE         L"\\NLS\\NlsSectionLocale"
#define NLS_SECTION_CTYPE          L"\\NLS\\NlsSectionCType"
#define NLS_SECTION_SORTKEY        L"\\NLS\\NlsSectionSortkey"
#define NLS_SECTION_SORTTBLS       L"\\NLS\\NlsSectionSortTbls"
#define NLS_SECTION_LANG_INTL      L"\\NLS\\NlsSectionLANG_INTL"
#define NLS_SECTION_LANG_EXCEPT    L"\\NLS\\NlsSectionLANG_EXCEPT"
#define NLS_SECTION_GEO            L"\\NLS\\NlsSectionGeo"

//
//  Unicode file names.
//  These files will always be installed by setup in the system directory,
//  so there is no need to put these names in the registry.
//
#define NLS_FILE_UNICODE           L"unicode.nls"
#define NLS_FILE_LOCALE            L"locale.nls"
#define NLS_FILE_CTYPE             L"ctype.nls"
#define NLS_FILE_SORTKEY           L"sortkey.nls"
#define NLS_FILE_SORTTBLS          L"sorttbls.nls"
#define NLS_FILE_LANG_INTL         L"l_intl.nls"
#define NLS_FILE_LANG_EXCEPT       L"l_except.nls"
#define NLS_FILE_GEO               L"geo.nls"

//
//  Default file names if registry is corrupt.
//
#define NLS_DEFAULT_FILE_ACP       L"c_1252.nls"
#define NLS_DEFAULT_FILE_OEMCP     L"c_437.nls"



//
//  Default section names if registry is corrupt.
//
#define NLS_DEFAULT_SECTION_ACP    L"\\NLS\\NlsSectionCP1252"
#define NLS_DEFAULT_SECTION_OEMCP  L"\\NLS\\NlsSectionCP437"

#ifdef _WINDOWS_BASE
//
//  winnls routines that are called from base\server.  The prototypes must
//  continue to match the typedefs.
//

typedef ULONG
(*PNLS_CONVERT_INTEGER_TO_STRING)(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);
ULONG
NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);

typedef BOOL
(*PGET_CP_FILE_NAME_FROM_REGISTRY)(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size);
BOOL
GetCPFileNameFromRegistry(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size);

typedef ULONG
(*PCREATE_NLS_SECURITY_DESCRIPTOR)(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    UINT                    SecurityDescriptorSize,
    ACCESS_MASK             AccessMask);

ULONG
CreateNlsSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    UINT                    SecurityDescriptorSize,
    ACCESS_MASK             AccessMask);

typedef ULONG
(*PGET_NLS_SECTION_NAME)(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName);
ULONG
GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName);


typedef WINBASEAPI BOOL
(WINAPI *PIS_VALID_CODEPAGE)(
    UINT CodePage);
WINBASEAPI BOOL WINAPI
IsValidCodePage(
    UINT CodePage);

typedef ULONG
(*POPEN_DATA_FILE)(HANDLE *phFile, LPWSTR pFile);
ULONG OpenDataFile(HANDLE *phFile, LPWSTR pFile);

typedef ULONG
(*PGET_DEFAULT_SORTKEY_SIZE)(PLARGE_INTEGER pSize);
ULONG GetDefaultSortkeySize(PLARGE_INTEGER pSize);

typedef ULONG
(*PGET_LINGUIST_LANG_SIZE)(PLARGE_INTEGER pSize);
ULONG GetLinguistLangSize(PLARGE_INTEGER pSize);

typedef BOOL
(*PVALIDATE_LOCALE)(LCID Locale);
BOOL ValidateLocale(LCID Locale);

typedef BOOL
(*PVALIDATE_LCTYPE)(PVOID pInfo, LCTYPE LCType, LPWSTR *ppwReg, LPWSTR *ppwCache);
BOOL ValidateLCType(PNLS_USER_INFO pInfo, LCTYPE LCType, LPWSTR *ppwReg, LPWSTR *ppwCache);

typedef BOOL
(*PNLS_LOAD_STRING_EX_W)(HMODULE hModule, UINT wID, LPWSTR lpBuffer, int cchBufferMax, WORD wLangId);
int NlsLoadStringExW(HMODULE hModule, UINT wID, LPWSTR lpBuffer, int cchBufferMax, WORD wLangId);

#endif // _WINDOWS_BASE

#ifdef __cplusplus
}
#endif

#endif // _WINNLSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\winbasep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winbasep.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the Base
    component.

--*/
#ifndef _WINBASEP_
#define _WINBASEP_
#ifdef __cplusplus
extern "C" {
#endif
#define FILE_FLAG_GLOBAL_HANDLE         0x00800000
#define FILE_FLAG_MM_CACHED_FILE_HANDLE 0x00400000
WINBASEAPI
DWORD
WINAPI
HeapCreateTagsW(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPCWSTR lpTagPrefix,
    IN LPCWSTR lpTagNames
    );

typedef struct _HEAP_TAG_INFO {
    DWORD dwNumberOfAllocations;
    DWORD dwNumberOfFrees;
    DWORD dwBytesAllocated;
} HEAP_TAG_INFO, *PHEAP_TAG_INFO;
typedef PHEAP_TAG_INFO LPHEAP_TAG_INFO;

WINBASEAPI
LPCWSTR
WINAPI
HeapQueryTagW(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN WORD wTagIndex,
    IN BOOL bResetCounters,
    OUT LPHEAP_TAG_INFO TagInfo
    );

typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

BOOL
WINAPI
HeapSummary(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    OUT LPHEAP_SUMMARY lpSummary
    );

BOOL
WINAPI
HeapExtend(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpBase,
    IN DWORD dwBytes
    );

typedef struct _HEAP_USAGE_ENTRY {
    struct _HEAP_USAGE_ENTRY *lpNext;
    PVOID lpAddress;
    DWORD dwBytes;
    DWORD dwReserved;
} HEAP_USAGE_ENTRY, *PHEAP_USAGE_ENTRY;

typedef struct _HEAP_USAGE {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
    PHEAP_USAGE_ENTRY lpEntries;
    PHEAP_USAGE_ENTRY lpAddedEntries;
    PHEAP_USAGE_ENTRY lpRemovedEntries;
    DWORD Reserved[ 8 ];
} HEAP_USAGE, *PHEAP_USAGE;

BOOL
WINAPI
HeapUsage(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN BOOL bFirstCall,
    IN BOOL bLastCall,
    OUT PHEAP_USAGE lpUsage
    );

#define HFINDFILE HANDLE                        //
#define INVALID_HFINDFILE       ((HFINDFILE)-1) //
typedef DWORD (*PFNWAITFORINPUTIDLE)(HANDLE hProcess, DWORD dwMilliseconds);
VOID RegisterWaitForInputIdle(PFNWAITFORINPUTIDLE);

#define STARTF_HASSHELLDATA     0x00000400
#define STARTF_TITLEISLINKNAME  0x00000800
WINBASEAPI
BOOL
WINAPI
CreateProcessInternalA(
    IN HANDLE hUserToken,
    IN LPCSTR lpApplicationName,
    IN LPSTR lpCommandLine,
    IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN BOOL bInheritHandles,
    IN DWORD dwCreationFlags,
    IN LPVOID lpEnvironment,
    IN LPCSTR lpCurrentDirectory,
    IN LPSTARTUPINFOA lpStartupInfo,
    OUT LPPROCESS_INFORMATION lpProcessInformation,
    OUT PHANDLE hRestrictedUserToken
    );
WINBASEAPI
BOOL
WINAPI
CreateProcessInternalW(
    IN HANDLE hUserToken,
    IN LPCWSTR lpApplicationName,
    IN LPWSTR lpCommandLine,
    IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN BOOL bInheritHandles,
    IN DWORD dwCreationFlags,
    IN LPVOID lpEnvironment,
    IN LPCWSTR lpCurrentDirectory,
    IN LPSTARTUPINFOW lpStartupInfo,
    OUT LPPROCESS_INFORMATION lpProcessInformation,
    OUT PHANDLE hRestrictedUserToken
    );
#ifdef UNICODE
#define CreateProcessInternal  CreateProcessInternalW
#else
#define CreateProcessInternal  CreateProcessInternalA
#endif // !UNICODE

#if (_WIN32_WINNT >= 0x0500)

#define PRIVCOPY_FILE_METADATA           0x010  // Copy compression, DACL, (encryption)
#define PRIVCOPY_FILE_SACL               0x020  // Copy SACL
#define PRIVCOPY_FILE_OWNER_GROUP        0x040  // Copy owner & group
#define PRIVCOPY_FILE_DIRECTORY          0x080  // Copy directory file like a file
#define PRIVCOPY_FILE_BACKUP_SEMANTICS   0x100  // Use FILE_FLAG_BACKUP_SEMANTICS on open/creates.
#define PRIVCOPY_FILE_SUPERSEDE          0x200  // Replace original dest with source
#define PRIVCOPY_FILE_SKIP_DACL          0x400  // Workaround for csc/roamprofs
#define PRIVCOPY_FILE_VALID_FLAGS   (PRIVCOPY_FILE_METADATA|PRIVCOPY_FILE_SACL|PRIVCOPY_FILE_OWNER_GROUP|PRIVCOPY_FILE_DIRECTORY|PRIVCOPY_FILE_SUPERSEDE|PRIVCOPY_FILE_BACKUP_SEMANTICS|PRIVCOPY_FILE_SKIP_DACL)

#define PRIVPROGRESS_REASON_NOT_HANDLED                 4

#define PRIVCALLBACK_STREAMS_NOT_SUPPORTED              2
#define PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED          5
#define PRIVCALLBACK_COMPRESSION_FAILED                 6
#define PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED           8
#define PRIVCALLBACK_ENCRYPTION_FAILED                  9
#define PRIVCALLBACK_EAS_NOT_SUPPORTED                  10
#define PRIVCALLBACK_SPARSE_NOT_SUPPORTED               11
#define PRIVCALLBACK_SPARSE_FAILED                      12
#define PRIVCALLBACK_DACL_ACCESS_DENIED                 13
#define PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED          14
#define PRIVCALLBACK_OWNER_GROUP_FAILED                 19
#define PRIVCALLBACK_SACL_ACCESS_DENIED                 15
#define PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED 16
#define PRIVCALLBACK_CANT_ENCRYPT_SYSTEM_FILE           17

#define PRIVMOVE_FILEID_DELETE_OLD_FILE     0x01
#define PRIVMOVE_FILEID_IGNORE_ID_ERRORS    0x02

BOOL
APIENTRY
PrivMoveFileIdentityW(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );

BOOL
APIENTRY
PrivCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    );
#endif // (_WIN32_WINNT >= 0x0500)

//#define ACTCTX_FLAG_LIKE_CREATEPROCESS            (0x00000100)

BOOL
WINAPI
CloseProfileUserMapping( VOID );

BOOL
WINAPI
OpenProfileUserMapping( VOID );


BOOL
WINAPI
QueryWin31IniFilesMappedToRegistry(
    IN DWORD Flags,
    OUT PWSTR Buffer,
    IN DWORD cchBuffer,
    OUT LPDWORD cchUsed
    );

#define WIN31_INIFILES_MAPPED_TO_SYSTEM 0x00000001
#define WIN31_INIFILES_MAPPED_TO_USER   0x00000002

typedef BOOL (WINAPI *PWIN31IO_STATUS_CALLBACK)(
    IN PWSTR Status,
    IN PVOID CallbackParameter
    );

typedef enum _WIN31IO_EVENT {
    Win31SystemStartEvent,
    Win31LogonEvent,
    Win31LogoffEvent
} WIN31IO_EVENT;

#define WIN31_MIGRATE_INIFILES  0x00000001
#define WIN31_MIGRATE_GROUPS    0x00000002
#define WIN31_MIGRATE_REGDAT    0x00000004
#define WIN31_MIGRATE_ALL      (WIN31_MIGRATE_INIFILES | WIN31_MIGRATE_GROUPS | WIN31_MIGRATE_REGDAT)

DWORD
WINAPI
QueryWindows31FilesMigration(
    IN WIN31IO_EVENT EventType
    );

BOOL
WINAPI
SynchronizeWindows31FilesAndWindowsNTRegistry(
    IN WIN31IO_EVENT EventType,
    IN DWORD Flags,
    IN PWIN31IO_STATUS_CALLBACK StatusCallBack,
    IN PVOID CallbackParameter
    );

typedef struct _VIRTUAL_BUFFER {
    PVOID Base;
    PVOID CommitLimit;
    PVOID ReserveLimit;
} VIRTUAL_BUFFER, *PVIRTUAL_BUFFER;

BOOLEAN
WINAPI
CreateVirtualBuffer(
    OUT PVIRTUAL_BUFFER Buffer,
    IN ULONG CommitSize OPTIONAL,
    IN ULONG ReserveSize OPTIONAL
    );

int
WINAPI
VirtualBufferExceptionHandler(
    IN ULONG ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PVIRTUAL_BUFFER Buffer
    );

BOOLEAN
WINAPI
ExtendVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer,
    IN PVOID Address
    );

BOOLEAN
WINAPI
TrimVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    );

BOOLEAN
WINAPI
FreeVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    );


//
// filefind stucture shared with ntvdm, jonle
// see mvdm\dos\dem\demsrch.c
//
typedef struct _FINDFILE_HANDLE {
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;
    ULONG FindBufferValidLength;
    RTL_CRITICAL_SECTION FindBufferLock;
} FINDFILE_HANDLE, *PFINDFILE_HANDLE;

#define BASE_FIND_FIRST_DEVICE_HANDLE (HANDLE)1

WINBASEAPI
BOOL
WINAPI
GetDaylightFlag(VOID);

WINBASEAPI
BOOL
WINAPI
SetDaylightFlag(
    BOOL fDaylight
    );

WINBASEAPI
BOOL
WINAPI
FreeLibrary16(
    HINSTANCE hLibModule
    );

WINBASEAPI
FARPROC
WINAPI
GetProcAddress16(
    HINSTANCE hModule,
    LPCSTR lpProcName
    );

WINBASEAPI
HINSTANCE
WINAPI
LoadLibrary16(
    LPCSTR lpLibFileName
    );

WINBASEAPI
BOOL
APIENTRY
NukeProcess(
    DWORD ppdb,
    UINT uExitCode,
    DWORD ulFlags);

WINBASEAPI
HGLOBAL
WINAPI
GlobalAlloc16(
    UINT uFlags,
    DWORD dwBytes
    );

WINBASEAPI
LPVOID
WINAPI
GlobalLock16(
    HGLOBAL hMem
    );

WINBASEAPI
BOOL
WINAPI
GlobalUnlock16(
    HGLOBAL hMem
    );

WINBASEAPI
HGLOBAL
WINAPI
GlobalFree16(
    HGLOBAL hMem
    );

WINBASEAPI
DWORD
WINAPI
GlobalSize16(
    HGLOBAL hMem
    );


WINBASEAPI
DWORD
WINAPI
RegisterServiceProcess(
    IN DWORD dwProcessId,
    IN DWORD dwServiceType
    );

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001



WINBASEAPI
VOID
WINAPI
ReinitializeCriticalSection(
    IN LPCRITICAL_SECTION lpCriticalSection
    );


//
// New Multi-User specific routines to support per session
// network driver mappings. Related to Wksvc changes
//

WINBASEAPI
BOOL
WINAPI
DosPathToSessionPathA(
    IN  DWORD   SessionId,
    IN  LPCSTR  pInPath,
    OUT LPSTR  *ppOutPath
    );
WINBASEAPI
BOOL
WINAPI
DosPathToSessionPathW(
    IN  DWORD   SessionId,
    IN  LPCWSTR  pInPath,
    OUT LPWSTR  *ppOutPath
    );

//terminal server time zone support
BOOL
WINAPI
SetClientTimeZoneInformation(
     IN CONST TIME_ZONE_INFORMATION *ptzi
     );

#ifdef UNICODE
#define DosPathToSessionPath DosPathToSessionPathW
#else
#define DosPathToSessionPath DosPathToSessionPathA
#endif // !UNICODE

#define COMPLUS_ENABLE_64BIT           0x00000001

#define COMPLUS_INSTALL_FLAGS_INVALID  (~(COMPLUS_ENABLE_64BIT))

ULONG
WINAPI
GetComPlusPackageInstallStatus(
    VOID
    );

BOOL
WINAPI
SetComPlusPackageInstallStatus(
    ULONG ComPlusPackage
    );
#ifdef __cplusplus
}
#endif
#endif  // ndef _WINBASEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\winperfp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winperfp.h

Abstract:

    Private header file used by various internal components related to perflib
    and associated tools.
    NOTE: At least one source file must include this with _INIT_WINPERFP_ defined
          and also include <initguid.h> so that storage for global variables and
          proper routines are included.

    To use debug tracing, just call WinPerfStartTrace(hKey), where hKey can be
    an opened key to HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib.
    If hKey is NULL, the routine will open it automatically.

--*/

#ifndef _WINPERFP_H_
#define _WINPERFP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack8.h>
#include <setupbat.h>

// Increasing debug trace levels. Higher level always includes tracing lower levels.
#define WINPERF_DBG_TRACE_NONE      0       // no trace
#define WINPERF_DBG_TRACE_FATAL     1       // Print fatal error traces only
#define WINPERF_DBG_TRACE_ERROR     2       // All errors
#define WINPERF_DBG_TRACE_WARNING   3       // Warnings as well
#define WINPERF_DBG_TRACE_INFO      4       // Informational traces as well
#define WINPERF_DBG_TRACE_ALL       255     // All traces

//  Data structure definitions.

//
// PERFLIB Tracing routines definition. Starts from 10
//

#define PERF_OPEN_KEY               10    // PerfOpenKey
#define PERF_REG_QUERY_VALUE        11    // PerfRegQueryValue
#define PERF_REG_CLOSE_KEY          12    // PerfRegCloseKey
#define PERF_REG_SET_VALUE          13    // PerfRegSetValue
#define PERG_REG_ENUM_KEY           14    // PerfRegEnumKey
#define PERF_REG_QUERY_INFO_KEY     15    // PerfRegQueryInfoKey
#define PERF_REG_ENUM_VALUE         16    // PerfRegEnumValue
#define PERF_ENUM_TEXT_VALUE        17    // PerfEnumTextValue
#define PERF_ALLOC_INIT_EXT         18    // AllocateAndInitializeExtObject
#define PERF_OPEN_EXT_OBJS          19    // OpenExtensibleObjects
#define PERF_SERVICE_IS_TRUSTED     20    // ServiceIsTrustedByDefault
#define PERF_CLOSE_EXTOBJLIB        21    // CloseExtObjectLibrary
#define PERF_OPEN_EXTOBJLIB         22    // OpenExtObjectLibrary
#define PERF_QUERY_EXTDATA          23    // QueryExtensibleData
#define PERF_GET_NAMES              24    // PerfGetNames
#define PERF_GET_PERFLIBVALUE       25    // GetPerflibKeyValue
#define PERF_TIMER_FUNCTION         26    // PerflibTimerFunction
#define PERF_START_TIMER_FUNCTION   27    // StartPerflibFunctionTimer
#define PERF_DESTROY_TIMER_FUNCTION 28    // DestroyPerflibFunctionTimer
#define PERF_GET_DDLINFO            29    // GetPerfDllFileInfo
#define PERF_DISABLE_PERFLIB        30    // DisablePerfLibrary
#define PERF_DISABLE_LIBRARY        31    // DisableLibrary
#define PERF_UPDATE_ERROR_COUNT     32    // PerfUpdateErrorCount

#define PERF_TIMERFUNCTION          33
#define PERF_STARTFUNCTIONTIMER     34
#define PERF_KILLFUNCTIONTIMER      35
#define PERF_DESTROYFUNCTIONTIMER   36

// LOADPERF trace routine definition, starts from 10
//
#define LOADPERF_DLLENTRYPOINT                 10
#define LOADPERF_GETSTRINGRESOURCE             11
#define LOADPERF_GETFORMATRESOURCE             12
#define LOADPERF_DISPLAYCOMMANDHELP            13
#define LOADPERF_TRIMSPACES                    14
#define LOADPERF_ISDELIMITER                   15
#define LOADPERF_GETITEMFROMSTRING             16
#define LOADPERF_REPORTLOADPERFEVENT           17
#define LOADPERF_LOADPERFGRABMUTEX             18
#define LOADPERF_LOADPERFSTARTEVENTLOG         19
#define LOADPERF_LOADPERFDBGTRACE              20
#define LOADPERF_VERIFYREGISTRY                21

#define LOADPERF_SIGNALWMIWITHNEWDATA          25
#define LOADPERF_LODCTRCOMPILEMOFFILE          26
#define LOADPERF_LODCTRCOMPILEMOFBUFFER        27

#define LOADPERF_DUMPNAMETABLE                 30
#define LOADPERF_DUMPPERFSERVICEENTRIES        31
#define LOADPERF_DUMPPERFLIBENTRIES            32
#define LOADPERF_BUILDSERVICELISTS             33
#define LOADPERF_BACKUPPERFREGISTRYTOFILEW     34
#define LOADPERF_RESTOREPERFREGISTRYFROMFILEW  35

#define LOADPERF_FORMATPERFNAME                40
#define LOADPERF_GETPERFTYPEINFO               41
#define LOADPERF_GETPERFOBJECTGUID             42
#define LOADPERF_GENERATEMOFHEADER             43
#define LOADPERF_GENERATEMOFOBJECT             44
#define LOADPERF_GENERATEMOFOBJECTTAIL         45
#define LOADPERF_GENERATEMOFCOUNTER            46
#define LOADPERF_GENERATEMOFINSTANCES          47

#define LOADPERF_UNLODCTR_BUILDNAMETABLE       50
#define LOADPERF_GETDRIVERFROMCOMMANDLINE      51
#define LOADPERF_FIXNAMES                      52
#define LOADPERF_UNLOADCOUNTERNAMES            53
#define LOADPERF_UNLOADPERFCOUNTERTEXTSTRINGS  54

#define LOADPERF_MAKETEMPFILENAME              60
#define LOADPERF_WRITEWIDESTRINGTOANSIFILE     61
#define LOADPERF_LODCTR_BUILDNAMETABLE         62
#define LOADPERF_MAKEBACKUPCOPYOFLANGUAGEFILES 63
#define LOADPERF_GETFILEFROMCOMMANDLINE        64
#define LOADPERF_LODCTRSERSERVICEASTRUSTED     65
#define LOADPERF_GETDRIVERNAME                 66
#define LOADPERF_BUILDLANGUAGETABLES           67
#define LOADPERF_LOADINCLUDEFILE               68
#define LOADPERF_PARSETEXTID                   69
#define LOADPERF_FINDLANGUAGE                  70
#define LOADPERF_GETVALUE                      71
#define LOADPERF_GETVALUEFROMINIKEY            72
#define LOADPERF_ADDENTRYTOLANGUAGE            73
#define LOADPERF_CREATEOBJECTLIST              74
#define LOADPERF_LOADLANGUAGELISTS             75
#define LOADPERF_SORTLANGUAGETABLES            76
#define LOADPERF_GETINSTALLEDLANGUAGELIST      77
#define LOADPERF_CHECKNAMETABLE                78
#define LOADPERF_UPDATEEACHLANGUAGE            79
#define LOADPERF_UPDATEREGISTRY                80
#define LOADPERF_GETMOFFILEFROMINI             81
#define LOADPERF_OPENCOUNTERANDBUILDMOFFILE    82
#define LOADPERF_INSTALLPERFDLL                83
#define LOADPERF_LOADPERFCOUNTERTEXTSTRINGS    84
#define LOADPERF_LOADMOFFROMINSTALLEDSERVICE   85
#define LOADPERF_UPDATEPERFNAMEFILES           86
#define LOADPERF_SETSERVICEASTRUSTED           87

//
// Convenient macros to determine string sizes
//

// Macro to compute the actual size of a WCHAR or DBCS string

#define WSTRSIZE(str) (ULONG) ( (str) ? ((PCHAR) &str[wcslen(str)] - (PCHAR)str) + sizeof(UNICODE_NULL) : 0 )
#define STRSIZE(str)  (ULONG) ( (str) ? ((PCHAR) &str[strlen(str)] - (PCHAR)str) + 1 : 0 )

#define TRACE_WSTR(str)       str, WSTRSIZE(str)
#define TRACE_STR(str)        str, STRSIZE(str)
#define TRACE_DWORD(dwValue)  & dwValue, sizeof(dwValue)

//
// For debug tracing
//
#define TRACE(L, X) if (g_dwTraceLevel >= L) WinPerfDbgTrace X

VOID
WinPerfDbgTrace(
    IN LPCGUID Guid,
    IN ULONG  LineNumber,
    IN ULONG  ModuleNumber,
    IN ULONG  OptArgs,
    IN ULONG  Status,
    ...
    );

#define ARG_TYPE_ULONG          0
#define ARG_TYPE_WSTR           1
#define ARG_TYPE_STR            2
#define ARG_TYPE_ULONG64        3

// n must be 1 through 8. x is the one of above types
#define ARG_DEF(x, n)  (x << ((n-1) * 4))

ULONG
WinPerfStartTrace(
    IN HKEY hKey
    );

DEFINE_GUID( /* 51af3adb-28b1-4ba5-b59a-3aeec16deb3c */
    PerflibGuid,
    0x51af3adb,
    0x28b1,
    0x4ba5,
    0xb5, 0x9a, 0x3a, 0xee, 0xc1, 0x6d, 0xeb, 0x3c
  );
DEFINE_GUID( /* 275a79bb-9980-42ba-bafe-a92ded1192cf */
        LoadPerfGuid,
        0x275a79bb,
        0x9980,
        0x42ba,
        0xba, 0xfe, 0xa9, 0x2d, 0xed, 0x11, 0x92, 0xcf);

extern const WCHAR cszTraceLevel[];
extern const WCHAR cszTraceLogName[];
extern const WCHAR cszTraceFileValue[];
extern const WCHAR cszDefaultTraceFileName[];

extern TRACEHANDLE g_hTraceHandle;
extern DWORD g_dwTraceLevel;

#ifdef _PERFLIB_H_
#define WinperfQueryValueEx(a,b,c,d,e,f) \
            PrivateRegQueryValueExT(a, (LPVOID)b, c, d, e, f, TRUE)
#else
#define WinperfQueryValueEx RegQueryValueExW
#endif

//
// Below is necessary for global variables and routine to
// be included to each dll or exe
//
#ifdef _INIT_WINPERFP_

const   WCHAR cszTraceLevel[] = L"DebugTraceLevel";
const   WCHAR cszTraceFileValue[] = L"DebugTraceFile";
const   WCHAR cszPerfDebugTraceLevel[] = L"PerfDebugTraceLevel";

const   WCHAR cszTraceLogName[] = L"PerfDbg Logger";
const   WCHAR cszDefaultTraceFile[] = L"PerfDbg.Etl";
const   WCHAR cszDefaultTraceFileName[] = L"C:\\perfdbg.etl";

TRACEHANDLE g_hTraceHandle = 0;
DWORD       g_dwTraceLevel = WINPERF_DBG_TRACE_NONE;
LONG        g_lDbgStarted  = 0;

ULONG
WinPerfStartTrace(
    IN HKEY hKey                // Key to Perflib or NULL
    )
{
    CHAR Buffer[1024];
    PCHAR ptr;
    DWORD status, dwType, dwSize;
    PEVENT_TRACE_PROPERTIES Properties;
    TRACEHANDLE TraceHandle;
    DWORD bLocalKey = 0;
    WCHAR FileName[MAX_PATH + 1];
    LPWSTR szTraceFileName = NULL;
    ULONG lFileNameSize = 0;
    DWORD dwTraceLevel = WINPERF_DBG_TRACE_NONE;
    HKEY  hKeySetup;
    DWORD dwUpgradeType     = 0;
    DWORD dwSetupInProgress = 0;

    if (InterlockedCompareExchange(& g_lDbgStarted, 1, 0) != 0) {
        return g_dwTraceLevel;
    }

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\Setup",
                           0L,
                           KEY_READ,
                           & hKeySetup);
    if (status == ERROR_SUCCESS) {
        dwSize = sizeof(DWORD);
        dwType = 0;
        status = WinperfQueryValueEx(hKeySetup,
                                     L"SystemSetupInProgress",
                                     NULL,
                                     & dwType,
                                     (LPBYTE) & dwSetupInProgress,
                                     & dwSize);
        if (status == ERROR_SUCCESS && dwType == REG_DWORD
                                    && dwSetupInProgress != 0) {
            // System setup in progress, check whether "PerfDebugTraceLevel"
            // is defined in [UserData] section of setup answer file
            // $winnt$.inf;
            //
            WCHAR szAnswerFile[MAX_PATH];

            ZeroMemory(szAnswerFile, sizeof(WCHAR) * MAX_PATH);
            GetSystemDirectoryW(szAnswerFile, MAX_PATH);
            lstrcatW(szAnswerFile, L"\\");
            lstrcatW(szAnswerFile, WINNT_GUI_FILE_W);

            dwTraceLevel = GetPrivateProfileIntW(WINNT_USERDATA_W,
                                                 cszPerfDebugTraceLevel,
                                                 WINPERF_DBG_TRACE_NONE,
                                                 szAnswerFile);
#if 0
            DbgPrint("GetPrivateProfileIntW(\"%ws\",\"%ws\",\"%ws\")(%d,%d)\n",
                    szAnswerFile,WINNT_USERDATA_W,cszPerfDebugTraceLevel,
                    dwTraceLevel, GetLastError());
#endif
        }
        CloseHandle(hKeySetup);
    }

    status = ERROR_SUCCESS;
    if (dwTraceLevel == WINPERF_DBG_TRACE_NONE) {
        if (hKey == NULL) {
            status = RegOpenKeyExW (
                 HKEY_LOCAL_MACHINE,
                 L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib",
                 0L,
                 KEY_READ,
                 & hKey);
            bLocalKey = TRUE;
        }
        if (status == ERROR_SUCCESS) {
            dwSize = sizeof(DWORD);
            dwType = 0;
            status = WinperfQueryValueEx(hKey,
                        cszTraceLevel,
                        NULL,
                        & dwType,
                        (LPBYTE) & dwTraceLevel,
                        & dwSize);
            if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                dwTraceLevel = WINPERF_DBG_TRACE_NONE;
                if (bLocalKey) {
                    CloseHandle(hKey);
                }
            }
        }
    }

    if (dwTraceLevel == WINPERF_DBG_TRACE_NONE)
        return WINPERF_DBG_TRACE_NONE;

    dwType = 0;
    dwSize = (MAX_PATH + 1) * sizeof(WCHAR);
    status = WinperfQueryValueEx(hKey,
                cszTraceFileValue,
                NULL,
                &dwType,
                (LPBYTE) FileName,
                &dwSize);
    if (bLocalKey) {
        CloseHandle(hKey);
    }
    if ((status == ERROR_SUCCESS) && (dwType == REG_SZ)) {
        szTraceFileName = & FileName[0];
        lFileNameSize = WSTRSIZE(FileName);
    }
    else {
        if (GetSystemWindowsDirectoryW(FileName, MAX_PATH) > 0) {
            lstrcatW(FileName, L"\\");
            lstrcatW(FileName, cszDefaultTraceFile);
            szTraceFileName = & FileName[0];
            lFileNameSize   = WSTRSIZE(FileName);
        }
        else {
            szTraceFileName = (LPWSTR) &cszDefaultTraceFileName[0];
            lFileNameSize = sizeof(cszDefaultTraceFileName);
        }
    }

    g_dwTraceLevel = dwTraceLevel;
    RtlZeroMemory(Buffer, 1024);
    Properties = (PEVENT_TRACE_PROPERTIES) &Buffer[0];
    Properties->Wnode.BufferSize = 1024;
    Properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                    sizeof(cszTraceLogName);
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LoggerNameOffset);
    RtlCopyMemory(ptr, cszTraceLogName, sizeof(cszTraceLogName));
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LogFileNameOffset);
    RtlCopyMemory(ptr, szTraceFileName, lFileNameSize);
    status = QueryTraceW(0, cszTraceLogName, Properties);
    if (status == ERROR_SUCCESS) {
        g_hTraceHandle = (TRACEHANDLE) Properties->Wnode.HistoricalContext;
        return dwTraceLevel;
    }

    //
    // Reinitialize structure again for StartTrace()
    //
    RtlZeroMemory(Buffer, 1024);
    Properties->Wnode.BufferSize = 1024;
    Properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Properties->BufferSize  = 64;
    Properties->LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL |
                              EVENT_TRACE_USE_PAGED_MEMORY |
                              EVENT_TRACE_FILE_MODE_APPEND;
    Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                    sizeof(cszTraceLogName);
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LoggerNameOffset);
    RtlCopyMemory(ptr, cszTraceLogName, sizeof(cszTraceLogName));
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LogFileNameOffset);
    RtlCopyMemory(ptr, szTraceFileName, lFileNameSize);
    status = StartTraceW(& TraceHandle, cszTraceLogName, Properties);
    if (status == ERROR_SUCCESS) {
        g_hTraceHandle = TraceHandle;
        return dwTraceLevel;
    }

    g_dwTraceLevel = WINPERF_DBG_TRACE_NONE;
    g_hTraceHandle = (TRACEHANDLE) 0;
    return WINPERF_DBG_TRACE_NONE;
}

VOID
WinPerfDbgTrace(
    IN LPCGUID Guid,
    IN ULONG  LineNumber,
    IN ULONG  ModuleNumber,
    IN ULONG  OptArgs,
    IN ULONG  Status,
    ...
    )
{
    ULONG ErrorCode;
    struct _MY_EVENT {
        EVENT_TRACE_HEADER Header;
        MOF_FIELD MofField[MAX_MOF_FIELDS];
    } MyEvent;
    ULONG i;
    va_list ArgList;
    PVOID source;
    SIZE_T len;
    DWORD  dwLastError;

    dwLastError = GetLastError();

    RtlZeroMemory(& MyEvent, sizeof(EVENT_TRACE_HEADER));

    va_start(ArgList, Status);
    for (i = 3; i < MAX_MOF_FIELDS; i ++) {
        source = va_arg(ArgList, PVOID);
        if (source == NULL)
            break;
        len = va_arg(ArgList, SIZE_T);
        if (len == 0)
            break;
        MyEvent.MofField[i].DataPtr = (ULONGLONG) source;
        MyEvent.MofField[i].Length  = (ULONG) len;
    }
    va_end(ArgList);

    MyEvent.Header.Class.Type   = (UCHAR) ModuleNumber;
    MyEvent.Header.Size         = (USHORT) (sizeof(EVENT_TRACE_HEADER) + (i * sizeof(MOF_FIELD)));
    MyEvent.Header.Flags        = WNODE_FLAG_TRACED_GUID |
                                  WNODE_FLAG_USE_MOF_PTR |
                                  WNODE_FLAG_USE_GUID_PTR;
    MyEvent.Header.GuidPtr      = (ULONGLONG) Guid;
    MyEvent.MofField[0].DataPtr = (ULONGLONG) &LineNumber;
    MyEvent.MofField[0].Length  = sizeof(LineNumber);
    MyEvent.MofField[1].DataPtr = (ULONGLONG) &Status;
    MyEvent.MofField[1].Length  = sizeof(Status);
    MyEvent.MofField[2].DataPtr = (ULONGLONG) &OptArgs;
    MyEvent.MofField[2].Length  = sizeof(OptArgs);

    __try {
        ErrorCode = TraceEvent(g_hTraceHandle, (PEVENT_TRACE_HEADER) & MyEvent);
//        ErrorCode = TraceMessage(g_hTraceHandle, TRACE_FLAGS, (LPGUID) &PerflibGuid,
//                    ModuleNumber, ArgList);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = GetLastError();
    }

    if (ErrorCode != ERROR_SUCCESS) {
/*  Use the following to debug the trace statements that are failing
        DbgPrint("ErrorCode=%d Module=%d Line %d Status 0X%X\n", ErrorCode, ModuleNumber,
            LineNumber, Status); */

/* should continue tracing, no need to turn off
        g_dwTraceLevel = WINPERF_DBG_TRACE_NONE;
        g_hTraceHandle = (TRACEHANDLE) 0; */
    }

    SetLastError(dwLastError);
}

#endif // _INIT_WINPERFP_

#include <poppack.h>

#endif // _WINPERFP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\winsvcp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winsvcp.h

Abstract:

    Contains internal interfaces exported by the service controller.

Author:

    Anirudh Sahni (anirudhs)        14-Feb-1996

Environment:

    User Mode -Win32

Revision History:

    14-Feb-1996     anirudhs
        Created.

--*/

#ifndef _WINSVCP_INCLUDED
#define _WINSVCP_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

//
// Name of event to pulse to request a device-arrival broadcast,
// deliberately cryptic
//
#define SC_BSM_EVENT_NAME   L"ScNetDrvMsg"

//
// Name of event the SCM will set once service auto-start is
// complete.  It will never be reset.
//
#define SC_AUTOSTART_EVENT_NAME   L"SC_AutoStartComplete"

//
// Named events the SCM uses for handshaking with setup.exe
// during OOBE setup.
//
#define SC_OOBE_PNP_DONE             L"OOBE_PNP_DONE"
#define SC_OOBE_MACHINE_NAME_DONE    L"OOBE_MACHINE_NAME_DONE"

//
// This is the same as EnumServicesStatus except for the additional
// parameter pszGroupName.  The enumerated services are restricted
// to those belonging to the group named in pszGroupName.
// If pszGroupName is NULL this API is identical to EnumServicesStatus.
//
// If we decide to publish this API we should modify the parameter
// list to be extensible to future types of enumerations without needing
// to add a new API for each type of enumeration.
//
// This API is not supported on machines running Windows NT version 3.51
// or earlier, except if pszGroupName is NULL, in which case the call
// maps to EnumServicesStatus.
//
WINADVAPI
BOOL
WINAPI
EnumServiceGroupW(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle,
    LPCWSTR                 pszGroupName
    );

//
// Callback function passed to PnP for them to call when a service
// needs to receive notification of PnP events
//
typedef DWORD (*PSCMCALLBACK_ROUTINE)(
    SERVICE_STATUS_HANDLE    hServiceStatus,
    DWORD                    OpCode,
    DWORD                    dwEventType,
    LPARAM                   EventData,
    LPDWORD                  lpdwHandlerRetVal
    );

//
// Callback function passed to PnP for them to call to validate
// a service calling RegisterDeviceNotification
//
typedef DWORD (*PSCMAUTHENTICATION_CALLBACK)(
    IN  LPWSTR                   lpServiceName,
    OUT SERVICE_STATUS_HANDLE    *lphServiceStatus
    );

//
// Private client-side API for RegisterDeviceNotification to look
// up a service's display name given its SERVICE_STATUS_HANDLE
//
DWORD
I_ScPnPGetServiceName(
    IN  SERVICE_STATUS_HANDLE  hServiceStatus,
    OUT LPWSTR                 lpServiceName,
    IN  DWORD                  cchBufSize
    );

//
// Private API for Terminal Server to tell the SCM to send
// console switch notification to services that are interested
//
DWORD
I_ScSendTSMessage(
    DWORD        OpCode,
    DWORD        dwEvent,
    DWORD        cbData,
    LPBYTE       lpData
    );

#if DBG
void
SccInit(
    DWORD dwReason
    );
#endif // DBG

#ifdef __cplusplus
}   // extern "C"
#endif

#endif  // _WINSVCP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\winbrand.h ===
/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    winbrand.h

Abstract:

    Definitions for Windows Branding Resources

Notes:

    1 ) Window Branding resource DLL will be shared by multiple components, thus component owners have to 
    do their best practices to avoid resource id and name conflicts. 

    To avoid id conflicts, owners should use RESOURCE_ID_BLOCK_SiZE as the base resource id 
    range unit, and define component resource base ID and block numbers for each resource 
    type as appropriate. Before adding resources, owners have to make sure newly defined IDs 
    are not overlapping other components' id ranges

    For resource id name defines, owner should include the component name in name define to
    avoid conflicts. 

    See below for an example of defining string IDs for foo.dll

    #define IDS_BASE_FOO_DLL        1000
    #define IDS_BLOCK_NUM_FOO_DLL   2

    //
    // Foo.dll occupies resource string id range 1000 - 1199 
    //

    #define IDS_XXX_FOO_DLL     1000
    ... 
    #define IDS_YYY_FOO_DLL     1101



Revision History:



*/


#ifndef __WINBRAND_H_
#define __WINBRAND_H_

#define RESOURCE_ID_BLOCK_SiZE     100



//
// msgina.dll occupies resource bitmap ID range 1000-1099
//

#define IDB_BASE_MSGINA_DLL                                 1000
#define IDB_BLOCK_NUM_MSGINA_DLL                            1

#define IDB_SMALL_PROTAB_8_MSGINA_DLL                       1000
#define IDB_MEDIUM_PROTAB_8_MSGINA_DLL                      1001
#define IDB_MEDIUM_PROTAB_4_MSGINA_DLL                      1002
#define IDB_SMALL_PROTAB_4_MSGINA_DLL                       1003
#define IDB_SMALL_PROMED_8_MSGINA_DLL                       1004
#define IDB_MEDIUM_PROMED_8_MSGINA_DLL                      1005
#define IDB_MEDIUM_PROMED_4_MSGINA_DLL                      1006
#define IDB_SMALL_PROMED_4_MSGINA_DLL                       1007

//
// shell32.dll occupies resource bitmap ID range 1100-1199
//

#define IDB_BASE_SHELL32_DLL                                1100
#define IDB_BLOCK_NUM_SHELL32_DLL                           1

#define IDB_ABOUTTABLETPC16_SHELL32_DLL                     1100
#define IDB_ABOUTTABLETPC256_SHELL32_DLL                    1101
#define IDB_ABOUTMEDIACENTER16_SHELL32_DLL                  1102
#define IDB_ABOUTMEDIACENTER256_SHELL32_DLL                 1103

//
// logon.scr occupies resource bitmap ID range 1200-1299
//
#define IDB_TABLETPC_LOGON_SCR                              1200
#define IDB_MEDIACENTER_LOGON_SCR                           1201


#define IDB_BASE_EXPLORER_EXE               1300

#define IDB_TABLETPC_STARTBKG               1301
#define IDB_MEDIACENTER_STARTBKG            1302


//
// sysdm.cpl occupies resource string ID range 2000-2099
//

#define IDS_BASE_SYSDM_CPL                                  2000
#define IDS_BLOCK_NUM_SYSDM_CPL                             1

#define IDS_WINVER_TABLETPC_SYSDM_CPL                       2000
#define IDS_WINVER_MEDIACENTER_SYSDM_CPL                    2001


#endif //__WINBRAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\winnt32p.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winnt32p.h

Abstract:

    Header file for winnt32 plug-in down-level-side DLLs.

Author:

    Ted Miller (tedm) 6 December 1996

Revision History:

--*/
#ifndef WINNT32P_H
#define WINNT32P_H

#include <prsht.h>


//
// winnt32 dll main exported routine prototype
//
DWORD
WINAPI
winnt32 (
    IN      PCSTR DefaultSourcePath,    OPTIONAL
    IN      HWND Dlg,                   OPTIONAL
    IN      HANDLE WinNT32Stub,         OPTIONAL
    OUT     PCSTR* RestartCmdLine       OPTIONAL
    );

typedef
DWORD
(WINAPI* PWINNT32) (
    IN      PCTSTR DefaultSourcePath,   OPTIONAL
    IN      HWND Dlg,                   OPTIONAL
    IN      HANDLE WinNT32Stub,         OPTIONAL
    OUT     PCSTR* RestartCmdLine       OPTIONAL
    );

//
// WMX_ACTIVATEPAGE is sent when a page is being activated or deactivated.
//
// (The plug-in's pages do not receive WM_NOTIFY with PSN_SETACTIVE and
// PSN_KILLACTIVE -- they get a WMX_ACTIVATEPAGE instead.)
//
// wParam non-0: activating
// wParam 0    : deactivating
// lParam      : unused.
//
// Return non-0 to accept (de)activation, 0 to not accept it. The semantics
// of not accepting (de)activation are exactly the same as for the
// PSN_SETACTIVE/PSN_KILLACTIVE case.
//
#define WMX_ACTIVATEPAGE        (WM_APP+0)

//
// WMX_BBTEXT can be send by a page when is want's to hide and start the billboard
//
// wParam non-0: start billboard, the wizard page will hide itself
// wParam 0    : Stop billboard, The wizard page will call this if it shows again.
// lParam      : unused.
//
// If the SendMessage returns TRUE, the billboard is started/stopped
//
#define WMX_BBTEXT             (WM_APP+1)

//
// WMX_BBPROGRESSGAUGE send by the page when is wants to show/hide the progress gauge on the billboard
//
// wParam non-0: show the progerss gauge on the billboard
// wParam 0    : hide the progerss gauge on the billboard
// lParam      : unused.
// 
#define WMX_BBPROGRESSGAUGE    (WM_APP+2)

//
// WMX_PBM_* private progress bar messages for the billboard.
#define WMX_PBM_SETRANGE       (WM_APP+3)
#define WMX_PBM_SETPOS         (WM_APP+4)
#define WMX_PBM_DELTAPOS       (WM_APP+5)
#define WMX_PBM_SETSTEP        (WM_APP+6)
#define WMX_PBM_STEPIT         (WM_APP+7)
//
// WMX_BB_SETINFOTEXT sets the text in the info window on the billboard
//
// wParam not used
// lParam pointer to the text which should be displayed on the billboard info window
//
// This message should only be used with SendMessage. The billboard makes a copy of the text
// passed in.
//        
#define WMX_BB_SETINFOTEXT     (WM_APP+8)

//
// WMX_BB_ADVANCE_SETUPPHASE lets the wizard/billboard know that a setup phase is finished
// and the time estimate can advance to the next phase. 
// In the win9x upgrade, there can be 2 phases. 1. create/update the hardware compatibility
// database. 2. Create the upgrade report.
// Phase 1 does not need to run if the db which comes with the products is still correct.
//
#define WMX_BB_ADVANCE_SETUPPHASE (WM_APP+9)


//
#define WMX_SETPROGRESSTEXT (WM_APP+10)

//
// WMX_QUERYCANCEL is sent to allow a page to do a custom processing of QueryCancel
//
// wParam      : unused
// lParam      : pointer to a BOOL variable indicating outcome (when return==TRUE)
//               *lParam == TRUE means user wants to cancel the wizard
//               *lParam == FALSE means user may continue
//
// Return non-0 to specify the QueryCancel was handled by the page and the
// answer to the QueryCancel request is in *lParam (see above)
// Return 0 to specify that the default QueryCancel action must be taken
//
#define WMX_QUERYCANCEL         (WM_APP+11)

// More progress message for the billboard
#define WMX_PBM_SETBARCOLOR     (WM_APP+12)

//
// First custom window message a plug-in can use.
// Do NOT use any below this value.
//
#define WMX_PLUGIN_FIRST        (WM_APP+1000)

//
// IDs the plug-in must use for its title and subtitle text on each
// wizard page.
//
#define ID_TITLE_TEXT           1000
#define ID_SUBTITLE_TEXT        1029

//
// Define types for routines that the plug-in DLL must export.
//



//
// Maximum source count..
//
#define MAX_SOURCE_COUNT 8


/*
    This structure contains the information that is passed to a Winnt32 plug-in in
    its Init function.

    UnattendedFlag - Supplies the address of the global attended flag within
        winnt32 itself. A plugin should react accordingly to setup being in
        unattended mode.

    CancelledFlag - supplies the address of a global variable within
        winnt32 itself. If the plug-in encounters a fatal error while
        processing later it should inform the user, set the BOOL to which
        this parameter points to TRUE, and do the following:

        PropSheet_PressButton(WizardDialogBox,PSBTN_CANCEL);

        where WizardDialogBox is the window handle of the wizard dialog box
        (typically obtained via GetParent(hdlg) where hdlg is the
        window handle of a page in the wizard).

    AbortedFlag - supplies the address of a global variable within winnt32 itself.
        If the plugin would like to exit setup, but not show the unsuccessfull
        completion page, it should set both CancelledFlag and AbortedFlag to TRUE.

    UpgradeFlag - supplies the address of a global variable that will
        indicate whether the user is upgrading or installing a new fresh
        copy of NT. The plug-in must sample this value when it is asked to
        activate its pages and take appropriate action (ie, not activating
        if the user is not upgrading). The value this pointer points to
        is NOT valid until after the plug-in's pages are first
        activated.

    LocalSourceModeFlag - supplies the address of a global variable that will
        indicate whether the user is installing via local source mode or not.
        This parameter is not valid until after the plug-in's pages are first
        activated.

    CdRomInstallFlag - supplies the address of a global variable that will
        indicate whetherthe user is installing via CdRom or not. This
        parameter is not valid until after the plug-in's pages are first
        activated.

    NotEnoughSpaceBlockFlag - supplies the address of a global variable that will
        indicate wether setup should halt setup and exit if it detects that
        there is not enough space to complete setup (not enough space for the ~ls dir.)

    LocalSourceDrive - supplies the address of a global variable that will indicate
        the drive number of the local source directory. (2 = C, 3 = D, etc...) This is
        not valid until after winnt32 builds the copy list. 0 indicates an invalid drive.

    LocalSourceSpaceRequired - supplies the address of a global variable that indicates the amount
        of space on the LocalSourceDrive required by winnt32. This is not valid until after
        winnt32 builds the copy list.

    UnattendedScriptFile - supplies the address of a global variable that will
        contain the unattend script file (such as passed in on the command line.)
        This parameter is not valid until after the plug-in's pages are first
        activated.

    SourcePath - supplies an array of SourcePaths that indicate where the
        NT source files exist. This parameter is not valid until after the
        plug-in's pages are first activated.

    SourceCount - supplies the count of SourcePaths in the above array.
        This parameter is not valid until after the plug-in's pages are first
        activated.

    UpgradeOptions - supplies a multistring of special Upgrade commandline options
        to the dll. These options are of the form /#U:[Option] so, for example,
        if someone started winnt32 with the commandline winnt32 /#U:FOO /#U:BAR,
        this string would eventually contain "FOO\0BAR\0\0" This parameter is not
        valid untila after the upgrade plug-in's pages are first activated.

    ProductType - Specifies the type of product being installed.  The value this pointer
        points to is NOT valid until after the plug-in's pages are first activated.

    BuildNumber - Specifies the build of NT being installed.

    ProductVersion - Specifies the version of NT being installed.  The major version is
        in the high byte, and the minor version is in the low byte.

    Debug - Specifies if WINNT32 is the checked build (TRUE) or the free build (FALSE).

    PreRelease - Specifies if the current build is a pre-release (TRUE) or final release (FALSE).

*/

typedef enum {
    UNKNOWN,
    NT_WORKSTATION,
    NT_SERVER
} PRODUCTTYPE;

// UPD_FLAGS_* can be set in SetupFlags to let the upgrade DLL know somethings about setup
// 
// Setup is run in Typical mode. The upgrade DLL should proceed with defaults 
// and not ask the user any question if possible.
#define UPG_FLAG_TYPICAL    0x1



//
// What are the ProductType values in dosnet.inf?
//
#define PROFESSIONAL_PRODUCTTYPE (0)
#define SERVER_PRODUCTTYPE (1)
#define ADVANCEDSERVER_PRODUCTTYPE (2)
#define DATACENTER_PRODUCTTYPE (3)
#define PERSONAL_PRODUCTTYPE (4)
#define BLADESERVER_PRODUCTTYPE (5)

//
// This value is for coding purposes only
//
#define UNKNOWN_PRODUCTTYPE ((UINT)(-1))


typedef struct tagWINNT32_PLUGIN_INIT_INFORMATION_BLOCK {
    UINT        Size;
    BOOL     *  UnattendedFlag;
    BOOL     *  CancelledFlag;
    BOOL     *  AbortedFlag;
    BOOL     *  UpgradeFlag;
    BOOL     *  LocalSourceModeFlag;
    BOOL     *  CdRomInstallFlag;
    BOOL     *  NotEnoughSpaceBlockFlag;
    DWORD    *  LocalSourceDrive;
    LONGLONG *  LocalSourceSpaceRequired;
    LPCTSTR  *  UnattendedScriptFile;
    LPCTSTR  *  SourceDirectories;
    DWORD    *  SourceDirectoryCount;
    LPCTSTR  *  UpgradeOptions;
    PRODUCTTYPE * ProductType;
    DWORD       BuildNumber;
    WORD        ProductVersion;         // i.e., MAKEWORD(5,0)
    BOOL        Debug;
    BOOL        PreRelease;
    BOOL     *  ForceNTFSConversion;
    UINT     *  Boot16;                 // Win9x upgrade only
    UINT     *  ProductFlavor;          // See *_PRODUCTTYPE above
    DWORD    *  SetupFlags;             // See UPD_FLAGS_  above
    BOOL     *  UnattendSwitchSpecified;
} WINNT32_PLUGIN_INIT_INFORMATION_BLOCK,*PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK;


typedef BOOL (*READ_DISK_SECTORS_PROC) (TCHAR,UINT,UINT,UINT,PBYTE);

typedef struct tagWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK {



    UINT      Size;
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK BaseInfo;
    LPCTSTR   UpgradeSourcePath;
    PLONGLONG WinDirSpace;
    PUINT     RequiredMb;
    PUINT     AvailableMb;
    LPCTSTR * OptionalDirectories;
    DWORD   * OptionalDirectoryCount;
    UINT    * UpgradeFailureReason;
    READ_DISK_SECTORS_PROC ReadDiskSectors;
    PCTSTR    DynamicUpdateLocalDir;
    PCTSTR    DynamicUpdateDrivers;
    BOOL    * UpginfsUpdated;

} WINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK, *PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK;


/*++

UPGRADEFAILURES is a list of reasons that an upgrade cannot be performed. This list allows winnt32 to own certain messages
for failures, but for the upgrade dll to do the actual checking for those failures.

If you define a FAILREASON(<x>) you need to add a MSG_<x> to the winnt32 dll message.mc file.

This macro expansion list will create an enumerated type FAILREASON_<x> as well as populate an array of potential
failure messages.


++*/
#define UPGRADEFAILURES                         \
    FAILREASON(UPGRADE_OK)                      \
    FAILREASON(UPGRADE_OTHER_OS_FOUND)          \

#define FAILREASON(x) REASON_##x,

enum {UPGRADEFAILURES /*,*/ REASON_LAST_REASON};

#undef FAILREASON

typedef
DWORD
(CALLBACK WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE)(
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK Info
    );

typedef WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_INIT_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to initialize the plug-in dll.

Arguments:

    Info - A WINNT32_PLUGIN_INIT_INFORMATION_BLOCK. See above for details.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
DWORD
(CALLBACK WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE)(
    PUINT            PageCount1,
    LPPROPSHEETPAGE *Pages1,
    PUINT            PageCount2,
    LPPROPSHEETPAGE *Pages2,
    PUINT            PageCount3,
    LPPROPSHEETPAGE *Pages3
    );

typedef WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_GETPAGES_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to retrieve wizard pages from the
    plug-in dll.

    Note that the plug-in does NOT need to worry about drawing watermarks
    or background bitmaps, or the separator between a header-area watermark
    and the body of its pages. Winnt32 does all this automatically.

    The plugin should, however, have regular static text controls in the
    header area. Static text controls in that area should use the reserved
    IDs (see above) for the title and subtitle, since winnt32 will automatically
    change the font and size of that text when the page is displayed.

Arguments:

    PageCount1 - receives the number of pages in the first set of contiguous
        pages.

    Pages1 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

    PageCount2 - receives the number of pages in the second set of contiguous
        pages.

    Pages2 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

    PageCount3 - receives the number of pages in the third set of contiguous
        pages.

    Pages3 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
DWORD
(CALLBACK WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE)(
    LPCTSTR FileName
    );

typedef WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_WRITEPARAMS_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to request the plug-in write to the
    parameters file that will be passed to text mode setup (ie, winnt.sif).

Arguments:

    FileName - supplies the filename of the .ini-style file to be written to.
        This file is the parameters file plus any user-specified unattend file.
        The plug-in should make whatever modifications are meaningful to it.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
VOID
(CALLBACK WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_CLEANUP_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 in the case where installation is
    aborted after the wizard has been started.

    The plug-in should silently perform whatever cleanup is needs to
    to undo any changes it made to the user's system.

Arguments:

    None.

Return Value:

    None.

--*/

typedef
BOOL
(CALLBACK WINNT32_PLUGIN_VIRUSSCANNER_CHECK_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_VIRUSSCANNER_CHECK_PROTOTYPE * PWINNT32_PLUGIN_VIRUSSCANNER_CHECK_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 when running on win9x machines.

    The plugin should do a check for any virus scanners on the machine that could cause setup
    to be unable to complete installation (locking the MBR, for instance.) The plugin is also
    responsible for communicating any problems to the user.

Arguments:

    None.

Return Value:

    TRUE if there are no virus scanners to worry about, FALSE otherwise.

--*/



typedef
PTSTR
(CALLBACK WINNT32_PLUGIN_OPTIONAL_DIRS_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_OPTIONAL_DIRS_PROTOTYPE * PWINNT32_PLUGIN_OPTIONAL_DIRS_ROUTINE;


//
// Names of routines that must be exported by the plug-in dll.
//
#define WINNT32_PLUGIN_INIT_NAME        "Winnt32PluginInit"
#define WINNT32_PLUGIN_GETPAGES_NAME    "Winnt32PluginGetPages"
#define WINNT32_PLUGIN_WRITEPARAMS_NAME "Winnt32WriteParams"
#define WINNT32_PLUGIN_CLEANUP_NAME     "Winnt32Cleanup"
#define WINNT32_PLUGIN_VIRUSSCANCHECK_NAME "Winnt32VirusScannerCheck"
#define WINNT32_PLUGIN_GETOPTIONALDIRS_NAME "Winnt32GetOptionalDirectories"

//
// Names of routines that must be exported by the Dynamic Update dll.
//
#define API_DU_ISSUPPORTED          "DuIsSupported"
#define API_DU_INITIALIZEA          "DuInitializeA"
#define API_DU_INITIALIZEW          "DuInitializeW"
#define API_DU_QUERYUNSUPDRVSA      "DuQueryUnsupportedDriversA"
#define API_DU_QUERYUNSUPDRVSW      "DuQueryUnsupportedDriversW"
#define API_DU_DODETECTION          "DuDoDetection"
#define API_DU_BEGINDOWNLOAD        "DuBeginDownload"
#define API_DU_ABORTDOWNLOAD        "DuAbortDownload"
#define API_DU_UNINITIALIZE         "DuUninitialize"

#ifdef UNICODE
#define API_DU_INITIALIZE           API_DU_INITIALIZEW
#define API_DU_QUERYUNSUPDRVS       API_DU_QUERYUNSUPDRVSW
#else
#define API_DU_INITIALIZE           API_DU_INITIALIZEA
#define API_DU_QUERYUNSUPDRVS       API_DU_QUERYUNSUPDRVSA
#endif

//
// Messages that must be sent by the Dynamic Update dll.
//
#define WMX_SETUPUPDATE_PROGRESS_NOTIFY WMX_PLUGIN_FIRST+1001
// WPARAM will be the updated Total Size (shouldn't change, but could possibly)
// LPARAM will be the updated downloaded size
// Time remaining after the initial estimate will need to be calculated by setup.

#define WMX_SETUPUPDATE_RESULT          WMX_PLUGIN_FIRST+1000
// WPARAM will be the result code of the operation (one of the DU_STATUS_* below)
// LPARAM is meaningful only if wParam==DU_STATUS_FAILED and gives more info about the error

#define DU_STATUS_SUCCESS           1
#define DU_STATUS_ABORT             2
#define DU_STATUS_FAILED            3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wmikm.h ===
/*++ BUILD Version: 0013    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wmikm.h

Abstract:

    This module defines the WMI types, constants, and functions that are
    exposed to internal device drivers.

Revision History:

--*/

#ifndef _WMIKM_H_
#define _WMIKM_H_

#include <evntrace.h>
#include <wmistr.h>

#define IRP_MN_SET_TRACE_NOTIFY             0x0A

//
// The following is set for a KM provider who is considered private to
// kernel tracing
//
#define WMIREG_FLAG_TRACE_PROVIDER          0x00010000

//
// The following mask is to extract the trace callout class
//
#define WMIREG_FLAG_TRACE_NOTIFY_MASK       0x00F00000

//
// We use 4 bits for the trace callout classes.
//
#define WMIREG_NOTIFY_DISK_IO               1 << 20
#define WMIREG_NOTIFY_TDI_IO                2 << 20

//
// Public routines to break down the Loggerhandle
//
#define KERNEL_LOGGER_ID                      0xFFFF    // USHORT only

typedef struct _TRACE_ENABLE_CONTEXT {
    USHORT  LoggerId;           // Actual Id of the logger
    UCHAR   Level;              // Enable level passed by control caller
    UCHAR   InternalFlag;       // Reserved
    ULONG   EnableFlags;        // Enable flags passed by control caller
} TRACE_ENABLE_CONTEXT, *PTRACE_ENABLE_CONTEXT;


#define WmiGetLoggerId(LoggerContext) \
    (((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->LoggerId == \
        (USHORT)KERNEL_LOGGER_ID) ? \
        KERNEL_LOGGER_ID : \
        ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->LoggerId

#define WmiGetLoggerEnableFlags(LoggerContext) \
   ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->EnableFlags
#define WmiGetLoggerEnableLevel(LoggerContext) \
    ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->Level

#define WmiSetLoggerId(Id, Context) \
     (((PTRACE_ENABLE_CONTEXT)Context)->LoggerId = (Id  ? \
                           (USHORT)Id: (USHORT)KERNEL_LOGGER_ID));

typedef struct _WMI_LOGGER_INFORMATION {
    WNODE_HEADER Wnode;       // Had to do this since wmium.h comes later
//
// data provider by caller
    ULONG BufferSize;                   // buffer size for logging (in kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // aging decay time, in minutes
    union {
        HANDLE  LogFileHandle;          // handle to logfile
        ULONG64 LogFileHandle64;
    };

// data returned to caller
        ULONG NumberOfBuffers;          // no of buffers in use
        ULONG FreeBuffers;              // no of buffers free
        ULONG EventsLost;               // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    union {
        HANDLE  LoggerThreadId;         // thread id of Logger
        ULONG64 LoggerThreadId64;       // thread is of Logger
    };
    union {
        UNICODE_STRING LogFileName;     // used only in WIN64
        UNICODE_STRING64 LogFileName64; // Logfile name: only in WIN32
    };

// mandatory data provided by caller
    union {
        UNICODE_STRING LoggerName;      // Logger instance name in WIN64
        UNICODE_STRING64 LoggerName64;  // Logger Instance name in WIN32
    };

// private
    union {
        PVOID   Checksum;
        ULONG64 Checksum64;
    };
    union {
        PVOID   LoggerExtension;
        ULONG64 LoggerExtension64;
    };
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;

//
// structure for NTDLL tracing
//

typedef struct
{
        BOOLEAN IsGet;
        PWMI_LOGGER_INFORMATION LoggerInfo;
} WMINTDLLLOGGERINFO, *PWMINTDLLLOGGERINFO;

typedef struct _TIMED_TRACE_HEADER {
    USHORT          Size;
    USHORT          Marker;
    ULONG32         EventId;
    union {
        LARGE_INTEGER   TimeStamp;
        ULONG64         LoggerId;
    };
} TIMED_TRACE_HEADER, *PTIMED_TRACE_HEADER;

typedef enum tagWMI_CLOCK_TYPE {
    WMICT_DEFAULT,
    WMICT_SYSTEMTIME,
    WMICT_PERFCOUNTER,
    WMICT_PROCESS,
    WMICT_THREAD,
    WMICT_CPUCYCLE
} WMI_CLOCK_TYPE;

//
// Trace Control APIs
//
NTKERNELAPI
NTSTATUS
WmiStartTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiQueryTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiStopTrace(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiUpdateTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiFlushTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );
//
// Trace Provider APIs
//
NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceEvent(
    IN PWNODE_HEADER Wnode,
    IN KPROCESSOR_MODE RequestorMode
    );

NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceFastEvent(
    IN PWNODE_HEADER Wnode
    );

NTKERNELAPI
LONG64
FASTCALL
WmiGetClock(
    IN WMI_CLOCK_TYPE ClockType,
    IN PVOID Context
    );

NTKERNELAPI
NTSTATUS
FASTCALL
WmiGetClockType(
    IN TRACEHANDLE LoggerHandle,
    OUT WMI_CLOCK_TYPE *ClockType
    );

// begin_ntddk begin_wdm

#ifdef RUN_WPP

NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN ...
    );

NTKERNELAPI
NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
    );


#endif // #ifdef RUN_WPP

#ifndef TRACE_INFORMATION_CLASS_DEFINE
typedef enum _TRACE_INFORMATION_CLASS {
    TraceIdClass,
    TraceHandleClass,
    TraceEnableFlagsClass,
    TraceEnableLevelClass,
    GlobalLoggerHandleClass,
    EventLoggerHandleClass,
    AllLoggerHandlesClass,
    TraceHandleByNameClass
} TRACE_INFORMATION_CLASS;

NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    IN TRACE_INFORMATION_CLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength OPTIONAL,
    IN PVOID Buffer OPTIONAL
    );
#define TRACE_INFORMATION_CLASS_DEFINE
#endif // TRACE_INFOPRMATION_CLASS_DEFINE


#endif // _WMIKM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wmitrace.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wmiTrace.h

Abstract:

    WMI-based TRACEing kd extension header file

Author:

    Glenn R. Peterson (glennp) 2000 Apr 27

Revision History:

--*/

#ifndef _WMITRACE_H
#define _WMITRACE_H


//
//  Data Structures
//
typedef struct sttWmiTracingKdSortEntry
{
    ULONGLONG   Address;
    union {
        LARGE_INTEGER   Key;
        ULONGLONG       Keyll;  // Sort Key 2
    };
    ULONG       SequenceNo;     // Sort Key 1
    ULONG       Ordinal;        // Sort Key 3
    ULONG       Offset;
    ULONG       Length;
    WMI_HEADER_TYPE HeaderType;
    WMI_BUFFER_SOURCE BufferSource;
    USHORT      CpuNo;
}  WMITRACING_KD_SORTENTRY,  *PWMITRACING_KD_SORTENTRY;


//
//  Procedure Parameters
//
typedef ULONGLONG (__cdecl *WMITRACING_KD_FILTER) (
    PVOID               UserContext,
    const PEVENT_TRACE  pstHeader
    );

typedef int       (__cdecl *WMITRACING_KD_COMPARE) (
    const WMITRACING_KD_SORTENTRY  *SortElement1,
    const WMITRACING_KD_SORTENTRY  *SortElement2
    );

typedef void      (__cdecl *WMITRACING_KD_OUTPUT) (
    PVOID                           UserContext,
    PLIST_ENTRY                     GuidListHeadPtr,
    const WMITRACING_KD_SORTENTRY  *SortInfo,
    const PEVENT_TRACE              pstEvent
    );

//
//  Procedures
//


VOID
wmiTraceDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    );

VOID
wmiLogDump(
    ULONG                   LoggerId,
    PVOID                   UserContext,
    PLIST_ENTRY             GuidListHeadPtr,
    WMITRACING_KD_FILTER    Filter,
    WMITRACING_KD_COMPARE   Compare,
    WMITRACING_KD_OUTPUT    Output
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wmiumkm.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiumkm.h

Abstract:

    Private definitions for WMI communications between user and kernel modes

Author:

    AlanWar

Environment:

    Kernel and User modes

Revision History:


--*/

#ifndef _WMIUMKM_
#define _WMIUMKM_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

//
// This defines the guid under which the default WMI security descriptor
// is maintained.
DEFINE_GUID(DefaultSecurityGuid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#define DefaultSecurityGuidName L"00000000-0000-0000-0000-000000000000"

#ifndef _WMIKM_

//
// This defines the codes used to define what a request must do. These
// definitions must match the same in wmium.h
//

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = 0,
    WmiGetSingleInstance = 1,
    WmiChangeSingleInstance = 2,
    WmiChangeSingleItem = 3,
    WmiEnableEvents = 4,
    WmiDisableEvents  = 5,
    WmiEnableCollection = 6,
    WmiDisableCollection = 7,
    WmiRegisterInfo = 8,
    WmiExecuteMethodCall = 9,
    WmiSetTraceNotify = 10
} WMIACTIONCODE;

#endif

#if defined(_WINNT_) || defined(WINNT)

typedef enum
{
    WmiStartLoggerCode = 32,
    WmiStopLoggerCode = 33,
    WmiQueryLoggerCode = 34,
    WmiTraceEventCode = 35,
    WmiUpdateLoggerCode = 36,
    WmiFlushLoggerCode = 37,
    WmiMBRequest = 38,
    WmiRequestDied = 39,
    WmiTraceMessageCode = 40,
    WmiSetMarkCode = 41,
    WmiNtdllLoggerCode = 42,
    WmiClockTypeCode = 43

#ifdef NTPERF
    ,
    WmiSwitchBufferCode = 63
#endif
} WMITRACECODE;
#endif

typedef enum
{
    WmiReadNotifications = 64,
    WmiGetNextRegistrant = 65,
#ifndef MEMPHIS    
    WmiOpenGuid = 66,
#endif    
    WmiNotifyUser = 67,
    WmiGetAllRegistrant = 68,
    WmiGenerateEvent = 69,

    WmiTranslateFileHandle = 71,
    WmiGetVersion = 73,
    WmiCheckAccess = 74,
        
    WmiQueryAllMultiple = 75,
    WmiQuerySingleMultiple = 76,
    WmiEnumerateGuidList = 77,
    WmiQueryDataBlockInformation = 78,
    WmiOpenGuidForQuerySet = 79,
    WmiOpenGuidForEvents = 80,
    WmiReceiveNotif = 81,
    WmiEnableDisableTracelogProvider = 82,
    WmiRegisterGuids = 83,
    WmiCreateUMLogger = 84,
    WmiMBReply = 85,
    WmiEnumerateMofResouces = 86,
    WmiUnregisterDP = 87,
    WmiEnumerateGuidListAndProperties = 88,
    WmiNotifyLanguageChange = 89,
    WmiMarkHandleAsClosed = 90
} WMISERVICECODES;

//
// This defines the name of the WMI device that manages service IOCTLS
#define WMIServiceDeviceObjectName       L"\\Device\\WMIDataDevice"
#define WMIServiceDeviceName TEXT("\\\\.\\WMIDataDevice")
#define WMIServiceSymbolicLinkName TEXT("\\DosDevices\\WMIDataDevice")

#ifdef MEMPHIS
//
// This id the name of the device that handles query/set IOCTLS. On memphis
// it is the same as the service device name.
#define WMIDataDeviceObjectName       L"\\Device\\WMIDevice"
#define WMIDataDeviceName TEXT("\\\\.\\WMIServiceDevice")
#define WMIDataSymbolicLinkName TEXT("\\DosDevices\\WMIServiceDevice")
#else
#define WMIDataDeviceObjectName       WMIServiceDeviceObjectName
#define WMIDataDeviceName WMIServiceDeviceName
#define WMIDataSymbolicLinkName WMIServiceSymbolicLinkName
#endif




//
// This defines the data structure that is used to pass a handle from
// um to km. In 32bit code a handle has 32bits and in 64bit code a handle 
// has 64 bits and both call into the kernel which is 64bits. In order to
// insure that the data structures compile to the same size on 32 and 64
// bit systems we define the union with a dummy 64bit value so the field is
// forced to be 64 bits in all code. Note that the object manager always
// ignores the top 32bits of the handle in order to support 32 bit code
// that only maintains 32 bit handles
//
typedef union
{
    HANDLE Handle;
    ULONG64 Handle64;
    ULONG32 Handle32;
} HANDLE3264, *PHANDLE3264;

typedef HANDLE3264 PVOID3264;

#ifdef _WIN64
#define WmipSetHandle3264(Handle3264, XHandle) \
    (Handle3264).Handle = XHandle
#else
#define WmipSetHandle3264(Handle3264, XHandle) \
{ (Handle3264).Handle64 = 0; (Handle3264).Handle32 = (ULONG32)XHandle; }
#endif
#define WmipSetPVoid3264 WmipSetHandle3264

//
// This IOCTL will return when a KM notification has been generated that
// requires user mode attention.
//   BufferIn - Not used
//   BufferOut - Buffer to return notification information
#define IOCTL_WMI_READ_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReadNotifications, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return with the next set of unprocessed registration info
// BufferIn - Not used
// BufferOut - Buffer to return registration information
#define IOCTL_WMI_GET_NEXT_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetNextRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

#ifndef MEMPHIS        
//
// This IOCTL will return a handle to a guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_OPEN_GUID \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuid, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_WMI_OPEN_GUID_FOR_QUERYSET \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuidForQuerySet, METHOD_BUFFERED, FILE_READ_ACCESS)
              
#define IOCTL_WMI_OPEN_GUID_FOR_EVENTS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuidForEvents, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif
        
// This IOCTL will perform a query for all data items of a data block
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_ALL_DATA \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllData, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will query for a single instance
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetSingleInstance, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will set a single instance
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleInstance, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will set a single item
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_ITEM \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleItem, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable an event
// BufferIn - Incoming WNODE event item to enable
#define IOCTL_WMI_ENABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable an event
// BufferIn - Incoming WNODE event item to disable
#define IOCTL_WMI_DISABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable collection
// BufferIn - Incoming WNODE describing what to enable for collection
#define IOCTL_WMI_ENABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable collection
// BufferIn - Incoming WNODE describing what to disable for collection
#define IOCTL_WMI_DISABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will return the registration information for a specific provider
// BufferIn - Provider handle
// BufferOut - Buffer to return WMI information
#define IOCTL_WMI_GET_REGINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterInfo, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will execute a method on a device
// BufferIn - WNODE_METHOD_ITEM
// BufferOut - WNODE_METHOD_ITEM
#define IOCTL_WMI_EXECUTE_METHOD \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiExecuteMethodCall, METHOD_BUFFERED, FILE_WRITE_ACCESS)

          
// This IOCTL will do a query all data multiple
// BufferIn - WMIQADMULTIPLE
// BufferOut - Linked WNODE_ALL_DATA with results
#define IOCTL_WMI_QAD_MULTIPLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryAllMultiple, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This specifies the maxiumum number of handles that can be passed to
// query all data multiple and query single instance multiple
//
#define QUERYMULIPLEHANDLELIMIT  0x1000

typedef struct 
{
    ULONG HandleCount;
    HANDLE3264 Handles[1];
} WMIQADMULTIPLE, *PWMIQADMULTIPLE;

// This IOCTL will do a query single instance multiple
// BufferIn - WMIQSIMULTIPLE
// BufferOut - Linked WNODE_SINGLE_INSTANCE with results
#define IOCTL_WMI_QSI_MULTIPLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQuerySingleMultiple, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#ifndef MEMPHIS
typedef struct
{
    USHORT Length;
    USHORT MaximumLength;
    union
    {
        PWSTR  Buffer;
        ULONG64 Dummy;
    };  
} UNICODE_STRING3264, *PUNICODE_STRING3264;

typedef struct
{
    HANDLE3264 Handle;
    UNICODE_STRING3264 InstanceName;
} WMIQSIINFO, *PWMIQSIINFO;
typedef struct
{
    ULONG QueryCount;
    WMIQSIINFO QsiInfo[1];
} WMIQSIMULTIPLE, *PWMIQSIMULTIPLE;
#endif        
          
// This IOCTL will mark the object as not longer able to receive events
// BufferIn - WMIMARKASCLOSED
// BufferOut - 
#define IOCTL_WMI_MARK_HANDLE_AS_CLOSED \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiMarkHandleAsClosed, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct
{
    HANDLE3264 Handle;
} WMIMARKASCLOSED, *PWMIMARKASCLOSED;


// This IOCTL will register for receiving an event
// BufferIn - WMIRECEIVENOTIFICATIONS
// BufferOut - WMIRECEIVENOTIFICATIONS
#define IOCTL_WMI_RECEIVE_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReceiveNotif, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// WmiReceiveNotification
//

#define RECEIVE_ACTION_NONE             1   // No special action required
#define RECEIVE_ACTION_CREATE_THREAD    2   // Mark guid objects as requiring
                                            // a new thread to be
                                            // created
typedef struct
{
    //
    // List of guid notification handles
    //
    ULONG HandleCount;
    ULONG Action;
    PVOID3264 /* PUSER_THREAD_START_ROUTINE */ UserModeCallback;
    HANDLE3264 UserModeProcess;
    HANDLE3264 Handles[1];
} WMIRECEIVENOTIFICATION, *PWMIRECEIVENOTIFICATION;       
          
          
// This IOCTL will cause a registration notification to be generated
// BufferIn - Not used
// BufferOut - Not used
#define IOCTL_WMI_NOTIFY_USER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyUser, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will return with the all registration info
// BufferIn - Not used
// BufferOut - Buffer to return all registration information
#define IOCTL_WMI_GET_ALL_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will cause certain data providers to generate events
// BufferIn - WnodeEventItem to use in firing event
// BufferOut - Not Used
#define IOCTL_WMI_GENERATE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGenerateEvent, METHOD_BUFFERED, FILE_WRITE_ACCESS)


// This IOCTL will translate a File Object into a device object
// BufferIn - pointer to incoming WMIFILETODEVICE structure
// BufferOut - outgoing WMIFILETODEVICE structure
#define IOCTL_WMI_TRANSLATE_FILE_HANDLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTranslateFileHandle, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will check if the caller has desired access to the guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_CHECK_ACCESS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCheckAccess, METHOD_BUFFERED, FILE_READ_ACCESS)
        
//
// This IOCTL will determine the version of WMI
// BufferIn - Not used
// BufferOut - WMIVERSIONINFO
#define IOCTL_WMI_GET_VERSION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetVersion, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return a list of guids registered with WMI
// BufferIn - Not used
// BufferOut - WMIGUIDLISTINFO
//
#define IOCTL_WMI_ENUMERATE_GUIDS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateGuidList, METHOD_BUFFERED, FILE_READ_ACCESS)
          
//
// This IOCTL will return a list of guids registered with WMI
// BufferIn - Not used
// BufferOut - WMIGUIDLISTINFO
//
#define IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateGuidListAndProperties, METHOD_BUFFERED, FILE_READ_ACCESS)
          
//
// WmiEnumerateGuidList - Enumerate guids

//
// WMIGUIDPROPERTIES structure is used to return the properties of 
// all the registered guids in the EnumerateGuids call. The properties
// GuidType - ( 0-TraceControlGuid, 1-TraceGuid, 2-DataGuid, 3-EventGuid )
// LoggerId - If Trace guid and enabled, indicates the LoggerId to which this
//            Guid is currently logging data
// EnableLevel - If Trace guid and enabled, indicates the level of logging
// EnableFlags - If Trace guid and enabled, indicates the flags used in logging.
// IsEnabled   - Indicates whether this Guid is enabled currently. For data
//               guids this means if collection is enabled, 
//               For event guids this means if events are enabled,
//               For trace guids this means trace logging is enabled. 
// 

typedef struct 
{
    GUID Guid;
    ULONG GuidType; // 0-TraceControlGuid, 1-TraceGuid, 2-DataGuid, 3-EventGuid
    ULONG LoggerId;   
    ULONG EnableLevel;
    ULONG EnableFlags;
    BOOLEAN IsEnabled; 
} WMIGUIDPROPERTIES, *PWMIGUIDPROPERTIES;


typedef struct
{
    ULONG TotalGuidCount;
    ULONG ReturnedGuidCount;
    WMIGUIDPROPERTIES GuidList[1];
} WMIGUIDLISTINFO, *PWMIGUIDLISTINFO;
          
//
// This IOCTL will return a list of guids registered with WMI
// BufferIn - WMIGUIDINFO
// BufferOut - WMIGUIDINFO
//
#define IOCTL_WMI_QUERY_GUID_INFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryDataBlockInformation, METHOD_BUFFERED, FILE_READ_ACCESS)
          
//
// This IOCTL will return the list of mof resources registered
//
// BufferIn - not used
// BufferOut - WMIMOFLIST
#define IOCTL_WMI_ENUMERATE_MOF_RESOURCES \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateMofResouces, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct
{
    ULONG RegPathOffset;
    ULONG ResourceOffset;
    ULONG Flags;
} WMIMOFENTRY, *PWMIMOFENTRY;
#define WMIMOFENTRY_FLAG_USERMODE   0x00000001

          
typedef struct
{
    ULONG MofListCount;
    WMIMOFENTRY MofEntry[1];
} WMIMOFLIST, *PWMIMOFLIST;


//
// This IOCTL notifies the kernel that a language has been added or
// removed on a MUI system
//
// BufferIn - WMILANGUAGECHANGE
// BufferOut - not used
#define IOCTL_WMI_NOTIFY_LANGUAGE_CHANGE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyLanguageChange, METHOD_BUFFERED, FILE_READ_ACCESS)

#define MAX_LANGUAGE_SIZE 0x100
typedef struct
{
    WCHAR Language[MAX_LANGUAGE_SIZE];
    ULONG Flags;
} WMILANGUAGECHANGE, *PWMILANGUAGECHANGE;
#define WMILANGUAGECHANGE_FLAG_ADDED   0x00000001
#define WMILANGUAGECHANGE_FLAG_REMOVED 0x00000002


#define MOFEVENT_ACTION_IMAGE_PATH 0
#define MOFEVENT_ACTION_REGISTRY_PATH 1
#define MOFEVENT_ACTION_LANGUAGE_CHANGE 2
#define MOFEVENT_ACTION_BINARY_MOF 3

#if defined(_WINNT_) || defined(WINNT)

#ifndef MEMPHIS       

#define WMIMAXREGGUIDCOUNT          65536

//
// This IOCTL will Register a set of guids with WMI
//
// BufferIn - WMIREGREQUEST followed by WMIREGINFOW 
// BufferOut - TRACEGUIDMAP[GuidCount] followed by WMIUMREGRESULTS.
//
#define IOCTL_WMI_REGISTER_GUIDS CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterGuids, METHOD_BUFFERED, FILE_READ_ACCESS)


typedef struct
{
    union {
        POBJECT_ATTRIBUTES ObjectAttributes;
        ULONG64 Dummy;
    };
    ULONG Cookie;
    ULONG GuidCount;
    ULONG WmiRegInfo32Size;
    ULONG WmiRegGuid32Size;
} WMIREGREQUEST, *PWMIREGREQUEST;

typedef struct
{
    HANDLE3264 RequestHandle;
    ULONG64 LoggerContext;
} WMIREGRESULTS, *PWMIREGRESULTS;

//
// This IOCTL will unregister a data provider
//
// BufferIn - WMIUNREGGUIDS
// BufferOut - WMIUNREGGUIDS
//
#define IOCTL_WMI_UNREGISTER_GUIDS CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUnregisterDP, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct
{
    IN GUID Guid;
    IN HANDLE3264 RequestHandle;    
    OUT ULONG64 LoggerContext;
} WMIUNREGGUIDS, *PWMIUNREGGUIDS;

//
// This IOCTL will Create a user mode logger
//
// BufferIn - PWMICREATEUMLOGGER
// BufferOut - PWMICREATEUMLOGGER

typedef struct
{
    IN  POBJECT_ATTRIBUTES ObjectAttributes;
    IN  GUID ControlGuid;
    OUT HANDLE3264 ReplyHandle;
    OUT ULONG ReplyCount;
} WMICREATEUMLOGGER, *PWMICREATEUMLOGGER;

typedef struct
{
    IN  ULONG ObjectAttributes;
    IN  GUID ControlGuid;
    OUT HANDLE3264 ReplyHandle;
    OUT ULONG ReplyCount;
} WMICREATEUMLOGGER32, *PWMICREATEUMLOGGER32;

#define IOCTL_WMI_CREATE_UM_LOGGER CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCreateUMLogger, METHOD_BUFFERED, FILE_READ_ACCESS)


//
// This IOCTL will reply to a MB request
//
// BufferIn - WMIMBREPLY
// BufferOut - not used

typedef struct
{
    HANDLE3264 Handle;
    ULONG ReplyIndex;
    UCHAR Message[1];
} WMIMBREPLY, *PWMIMBREPLY;

#define IOCTL_WMI_MB_REPLY CTL_CODE(FILE_DEVICE_UNKNOWN, WmiMBReply, METHOD_BUFFERED, FILE_READ_ACCESS)


//
// This IOCTL will start an instance of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is started
#define IOCTL_WMI_START_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStartLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will stop an instance of a logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information when logger is stopped
#define IOCTL_WMI_STOP_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStopLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will update an existing logger attributes
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_UPDATE_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUpdateLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will flush all buffers of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is flushed
#define IOCTL_WMI_FLUSH_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiFlushLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will query a logger for its information
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_QUERY_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will synchronize a trace record to the logger
// BufferIn - Trace record, with handle set
// BufferOut - Not used
#define IOCTL_WMI_TRACE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceEventCode, METHOD_NEITHER, FILE_WRITE_ACCESS)
          
//
// This IOCTL will synchronize a trace Message to the logger
// BufferIn - Trace record, with handle 
// BufferOut - Not used
#define IOCTL_WMI_TRACE_MESSAGE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceMessageCode, METHOD_NEITHER, FILE_WRITE_ACCESS)

//
// This IOCTL will set a mark in kernel logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Not used
#define IOCTL_WMI_SET_MARK \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiSetMarkCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will set/get the logger information in the GuidEntry
// in case we are starting NTDLL heap or crit sec tracing
// BufferIn - WMINTDLLLOGGERINFO structure
// BufferOut - updated WMINTDLLLOGGERINFO in case of Get.

#define IOCTL_WMI_NTDLL_LOGGERINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNtdllLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_WMI_CLOCK_TYPE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiClockTypeCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifdef NTPERF
//
// This IOCTL will switch a buffer for UserMode Logging
// BufferIn - WMI_SWITCH_PERFMEM_BUFFER_INFORMATION structure
// BufferOut - Not used
#define IOCTL_WMI_SWITCH_BUFFER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiSwitchBufferCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif //NTPERF
#endif
#endif // WINNT

//
// Notifications from kernel mode WMI to user mode WMI
//
#define NOTIFICATIONTYPES ULONG

                                    // A new data provider is being registered
#define RegistrationAdd       0x00000001
                                    // A data provider is being removed
#define RegistrationDelete    0x00000002
                                    // A data provider is being updated
#define RegistrationUpdate    0x00000004
                                    // An event is fired by a data provider
#define EventNotification     0x00000008

#define NOTIFICATIONSLOT_MASK_NOTIFICATIONTYPES (RegistrationAdd | \
                                                 RegistrationDelete | \
                                                 RegistrationUpdate)

#define INTERNALNOTIFICATIONSIZE (sizeof(WNODE_HEADER) + sizeof(KMREGINFO))


//
// This is used in IOCTL_WMI_GET_ALL_REGISTRANT to report the list of
// registered KM data providers to the WMI service
typedef struct
{
    OUT ULONG ProviderId;    // Provider Id (or device object pointer)
    OUT ULONG Flags;        // REGENTRY_FLAG_*
} KMREGINFO, *PKMREGINFO;

#define REGENTRY_FLAG_NEWREGINFO 0x00000004   // Entry has new registration info
#define REGENTRY_FLAG_UPDREGINFO 0x00000008   // Entry has updated registration info

//
// This structure is used in IOCTL_WMI_TRANSLATE_FILE_HANDLE
typedef struct
{
    union
    {
        IN HANDLE3264 FileHandle;  // File handle whose instance name is needed
        OUT ULONG SizeNeeded;      // If incoming buffer too small then this
                                   // returns with number bytes needed.
    };
    IN HANDLE3264 KernelHandle;    // Kernel handle for data block
    OUT ULONG BaseIndex;           // 
    OUT USHORT InstanceNameLength; // Length of instance name in bytes
    OUT WCHAR InstanceNames[1];    // Instance name in unicode
} WMIFHTOINSTANCENAME, *PWMIFHTOINSTANCENAME;

#ifndef MEMPHIS

//
// This is used in IOCTL_WMI_OPEN_GUID

// Guid must be in the form \WmiGuid\00000000-0000-0000-0000-000000000000

#define WmiGuidObjectNameLength 45
#define WmiGuidObjectDirectory L"\\WmiGuid\\"
#define WmiGuidObjectDirectoryLength  (sizeof(WmiGuidObjectDirectory) / sizeof(WCHAR))

typedef struct
{
    IN POBJECT_ATTRIBUTES ObjectAttributes;
    IN ACCESS_MASK DesiredAccess;

    OUT HANDLE3264 Handle;
} WMIOPENGUIDBLOCK, *PWMIOPENGUIDBLOCK;

typedef struct
{
    IN UINT32 /* POBJECT_ATTRIBUTES32 */ ObjectAttributes;
    IN ACCESS_MASK DesiredAccess;

    OUT HANDLE3264 Handle;
} WMIOPENGUIDBLOCK32, *PWMIOPENGUIDBLOCK32;

typedef struct
{
    GUID Guid;
    ACCESS_MASK DesiredAccess;
} WMICHECKGUIDACCESS, *PWMICHECKGUIDACCESS;
#endif

//
// This is the header in front of a WNODE request
typedef struct
{
    ULONG ProviderId;       // Provider Id of target device
} WMITARGET, *PWMITARGET;


typedef struct
{
    ULONG Length;               // Length of this header
    ULONG Count;                // Count of device object to target
    UCHAR Template[sizeof(WNODE_ALL_DATA)];    // Template WNODE_ALL_DATA
    WMITARGET Target[1];        // Provider ids for device object targets
} WMITARGETHEADER, *PWMITARGETHEADER;

//
// This is used to retrieve the internal version of WMI in IOCTL_WMI_GET_VERSION

#define WMI_CURRENT_VERSION 1

typedef struct
{
    ULONG32 Version;
} WMIVERSIONINFO, *PWMIVERSIONINFO;


//
// WmiQueryGuidInfo
typedef struct
{
       HANDLE3264 KernelHandle;
    BOOLEAN IsExpensive;
}  WMIQUERYGUIDINFO, *PWMIQUERYGUIDINFO;


#if defined(_WINNT_) || defined(WINNT)

//
// Used to enable and disable a tracelog provider
//
// BufferIn - WmiTraceEnableDisableInfo
// BufferOut - 
#define IOCTL_WMI_ENABLE_DISABLE_TRACELOG \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableDisableTracelogProvider, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct
{
    GUID Guid;
    ULONG64 LoggerContext;
    BOOLEAN Enable;
} WMITRACEENABLEDISABLEINFO, *PWMITRACEENABLEDISABLEINFO;
              
#define EVENT_TRACE_INTERNAL_FLAG_PRIVATE   0x01

#endif // WINNT

typedef struct
{
    ULONGLONG   GuidMapHandle; 
    GUID        Guid;
    ULONGLONG   SystemTime;
} TRACEGUIDMAP, *PTRACEGUIDMAP;

typedef struct
{
    WNODE_HEADER Wnode;
    ULONG64      LoggerContext;
    ULONG64      SecurityToken;
} WMITRACE_NOTIFY_HEADER, *PWMITRACE_NOTIFY_HEADER;

#ifndef MEMPHIS

#define ENABLECRITSECTRACE          0x1
#define DISABLECRITSECTRACE         0xFFFFFFFE
#define ENABLEHEAPTRACE             0x2
#define DISABLEHEAPTRACE            0xFFFFFFFD
#define DISABLENTDLLTRACE           0xFFFFFFFC

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default: 4200 )
#endif

#endif // _WMIUMKM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wow64t.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wow64t.h

Abstract:

    32-bit structure definitions for 64-bit NT.

Author:

    Barry Bond (barrybo)   20-Jun-1998

Revision History:

--*/

#ifndef _WOW64T_
#define _WOW64T_


//
// Page size on x86 NT
//
#define PAGE_SIZE_X86NT    0x1000
#define PAGE_SHIFT_X86NT   12L

//
// Conver the number of native pages to sub x86-pages
//
#define Wow64GetNumberOfX86Pages(NativePages)    \
        (NativePages * (PAGE_SIZE >> PAGE_SHIFT_X86NT))


// The name of the 32-bit system directory, which is a child of %SystemRoot%
#define WOW64_SYSTEM_DIRECTORY      "syswow64"
#define WOW64_SYSTEM_DIRECTORY_U   L"syswow64"

// Length in bytes of the new system directory, not counting a
// null terminator
//
#define WOW64_SYSTEM_DIRECTORY_SIZE (sizeof(WOW64_SYSTEM_DIRECTORY)-sizeof(CHAR))
#define WOW64_SYSTEM_DIRECTORY_U_SIZE (sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof(WCHAR))

#define WOW64_X86_TAG               " (x86)"
#define WOW64_X86_TAG_U            L" (x86)"

#define TYPE32(x)   ULONG
#define TYPE64(x)   ULONGLONG

//
// Wow64Info structure is shared between 32-bit and 64-bit modules inside a Wow64 process.
// NOTE : This structure shouldn't contain any pointer-dependent data, as 
// it is viewed from 32-bit and 64-bit code.
//
typedef struct _WOW64INFO {

    ULONG NativeSystemPageSize;         // Page size of the native system the emulator is running on.
    
    ULONG CpuFlags;

} WOW64INFO, *PWOW64INFO;


typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    TYPE32(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    TYPE32(PVOID) EntryInProgress;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _GDI_TEB_BATCH32 {
    ULONG    Offset;
    TYPE32(ULONG_PTR) HDC;
    ULONG    Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32,*PGDI_TEB_BATCH32;


typedef struct _GDI_TEB_BATCH64 {
    ULONG    Offset;
    TYPE64(ULONG_PTR) HDC;
    ULONG    Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH64,*PGDI_TEB_BATCH64;


typedef struct _Wx86ThreadState32 {
    TYPE32(PULONG)  CallBx86Eip;
    TYPE32(PVOID)   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD32, *PWX86THREAD32;

typedef struct _Wx86ThreadState64 {
    TYPE64(PULONG)  CallBx86Eip;
    TYPE64(PVOID)   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD64, *PWX86THREAD64;

typedef struct _CLIENT_ID32 {
    TYPE32(HANDLE)  UniqueProcess;
    TYPE32(HANDLE)  UniqueThread;
} CLIENT_ID32;

typedef CLIENT_ID32 *PCLIENT_ID32;

#if !defined(CLIENT_ID64_DEFINED)

typedef struct _CLIENT_ID64 {
    TYPE64(HANDLE)  UniqueProcess;
    TYPE64(HANDLE)  UniqueThread;
} CLIENT_ID64;

typedef CLIENT_ID64 *PCLIENT_ID64;

#define CLIENT_ID64_DEFINED

#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];

#define PEBTEB_BITS 32
#include "pebteb.h"
#undef PEBTEB_BITS

#define PEBTEB_BITS 64
#include "pebteb.h"
#undef PEBTEB_BITS

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;


typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    TYPE32(HANDLE) Handle;
} CURDIR32, *PCURDIR32;



typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    TYPE32(HANDLE) ConsoleHandle;
    ULONG  ConsoleFlags;
    TYPE32(HANDLE) StandardInput;
    TYPE32(HANDLE) StandardOutput;
    TYPE32(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;        // ProcessParameters
    UNICODE_STRING32 DllPath;         // ProcessParameters
    UNICODE_STRING32 ImagePathName;   // ProcessParameters
    UNICODE_STRING32 CommandLine;     // ProcessParameters
    TYPE32(PVOID) Environment;              // NtAllocateVirtualMemory

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;     // ProcessParameters
    UNICODE_STRING32 DesktopInfo;     // ProcessParameters
    UNICODE_STRING32 ShellInfo;       // ProcessParameters
    UNICODE_STRING32 RuntimeData;     // ProcessParameters
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[ RTL_MAX_DRIVE_LETTERS ];
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

#if !defined(BUILD_WOW6432)

//
// Macros to encapsulate fields that are used to store the TEB.
// They are kernel safe since the 64BIT TEB is locked down in memory
// and cann't be moved or decommited until the thread dies.

#define WOW64_GET_TEB32(teb64) \
        ((PTEB32)((teb64)->NtTib.ExceptionList))

//
// Update the first qword in the 64-bit TEB.  The 32-bit rdteb instruction
// reads the TEB32 pointer value directly from this field.
//
#define WOW64_SET_TEB32(teb64, teb32) \
   (teb64)->NtTib.ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)(teb32);


#define WOW64_TEB32_POINTER_ADDRESS(teb64) \
        (PVOID)&((teb64)->NtTib.ExceptionList)


#endif

//
// Thunk macros

#define UStr32ToUStr(dst, src) { (dst)->Length = (src)->Length; \
                                 (dst)->MaximumLength = (src)->MaximumLength; \
                                 (dst)->Buffer = (PWSTR) ((src)->Buffer); }

#define UStrToUStr32(dst, src) { (dst)->Length = (src)->Length; \
                                 (dst)->MaximumLength = (src)->MaximumLength; \
                                 (dst)->Buffer = (ULONG) ((src)->Buffer); }

#define NtCurrentTeb32()  ((PTEB32) (NtCurrentTeb()->NtTib.ExceptionList) )
#define NtCurrentPeb32()  ((PPEB32) (NtCurrentTeb32()->ProcessEnvironmentBlock) )


// This is currently defined in windows\core\w32inc\w32wow64.h:
#define NtCurrentTeb64()   ((PTEB64)((PTEB32)NtCurrentTeb())->GdiBatchCount)

// This is currently defined in base\wow64\inc\wow64.h:
#define WOW64_TLS_FILESYSREDIR      8   // Used to enable/disable the filesystem
#define WOW64_TLS_WOW64INFO        10   // Used to access native system information for wow64 processes.


// These should only be called from Win32 code known to be running on Win64.
#if !_WIN64
#define Wow64EnableFilesystemRedirector()   \
    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = 0;

#define Wow64DisableFilesystemRedirector(filename)  \
    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = (ULONGLONG)(ULONG)filename;

//
// Wow64Info is accessed only from compiled code for x86 on win64.
// NOTE: Only Wow64 processes are allowed to call these macros.
//

#define Wow64GetSharedInfo()    ((PWOW64INFO)NtCurrentTeb64()->TlsSlots[WOW64_TLS_WOW64INFO])

#define Wow64GetSystemNativePageSize() \
    ((PWOW64INFO)(NtCurrentTeb64()->TlsSlots[WOW64_TLS_WOW64INFO]))->NativeSystemPageSize
    
#else

#define Wow64GetSharedInfo()    ((PWOW64INFO)NtCurrentTeb()->TlsSlots[WOW64_TLS_WOW64INFO])

#endif


#endif  // _WOW64T_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wowcmndg.h ===
/******************************Module*Header*******************************\
* Module Name: wowcmndg.h                                                  *
*                                                                          *
* Defines used between WOW and common dialogs.                             *
*                                                                          *
* Created: 6-July-1994                                                     *
*                                                                          *
* Copyright (c) 1994-1998 Microsoft Corporation                            *
\**************************************************************************/

#ifndef _WOWCMNDG_H_
#define _WOWCMNDG_H_

//
// Used by various common dialogs to know that a WOW app
// is calling it.
//

#define PD_WOWAPP       0x80000000
#define CD_WOWAPP       PD_WOWAPP

// Enable WOW to tell ComDlg32 which type of struct we want to thunk
// via Ssync_ANSI_UNICODE_Struct_For_WOW() export
#define WOW_CHOOSECOLOR  1
#define WOW_CHOOSEFONT   2
#define WOW_OPENFILENAME 3
#define WOW_PRINTDLG     4

//
// Used by Wx86 whcdlg32.dll to know that a Wx86 app
// is calling it.  See windows\shell\comdlg\fileopen.h for the
// reason why it is not 0x40000000.
//

#define CD_WX86APP      0x04000000

#endif      // ifndef _WOWCMNDG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wowshlp.h ===
/******************************Module*Header*******************************\
* Module Name: wowshlp.h                                                   *
*                                                                          *
* Declarations of Shell services provided to WOW.                          *
*                                                                          *
* Created: 9-June-1993                                                     *
*                                                                          *
* Copyright (c) 1993-1998 Microsoft Corporation                            *
\**************************************************************************/

typedef DWORD (APIENTRY *LPFNWOWSHELLEXECCB) (LPSZ, WORD, LPSZ);
typedef DWORD (APIENTRY *LPFNWOWSHELLEXECCB_NT4) (LPSZ, WORD);


UINT APIENTRY DragQueryFileAorW(
   HDROP hDrop,
   UINT wFile,
   PVOID lpFile,
   UINT cb,
   BOOL fNeedAnsi,
   BOOL fShorten);

HINSTANCE APIENTRY WOWShellExecute(
   HWND hwnd,
   LPCSTR lpOperation,
   LPCSTR lpFile,
   LPSTR lpParameters,
   LPCSTR lpDirectory,
   INT nShowCmd,
   LPVOID lpfnWowShellExecCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wow64reg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wow64reg.c

Abstract:

    This module define some APIs a client can use to access the registry in the mix mode.

    The possible scenario is

    1. 32 bit Apps need to access 64 bit registry key.
    2. 64 bit Apps need to access 32-bit registry key.
    3. The actual redirected path from a given path.

Author:

    ATM Shafiqul Khalid (askhalid) 10-Nov-1999

Revision History:

--*/ 

 

#ifndef __WOW64REG_H__
#define __WOW64REG_H__

//#define LOG_REGISTRY  //define this to turn on logging for registry

#define WOW64_REGISTRY_SETUP_KEY_NAME L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64\\ISN Nodes"
#define WOW64_REGISTRY_SETUP_KEY_NAME_REL_PARENT L"SOFTWARE\\Microsoft\\WOW64"
#define WOW64_REGISTRY_SETUP_KEY_NAME_REL L"SOFTWARE\\Microsoft\\WOW64\\ISN Nodes"
#define MACHINE_CLASSES_ROOT L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"
#define WOW64_REGISTRY_ISN_NODE_NAME L"ISN Nodes"
#define WOW64_RUNONCE_SUBSTR L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"

#define WOW64_32BIT_MACHINE_CLASSES_ROOT L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node"

#define WOW64_SYSTEM_DIRECTORY_NAME L"SysWow64"
#define NODE_NAME_32BIT L"Wow6432Node"
#define NODE_NAME_32BIT_LEN ((sizeof (NODE_NAME_32BIT)-sizeof(UNICODE_NULL))/sizeof (WCHAR))

#define WOW6432_VALUE_KEY_NAME L"Wow6432KeyValue"

#define ISN_NODE_MAX_LEN 256
#define ISN_NODE_MAX_NUM 30

#define SHRED_MEMORY_NAME L"Wow64svc Shared Memory"                 // different process can open this for possible interaction
#define WOW64_SVC_REFLECTOR_EVENT_NAME L"Wow64svc reflector Event"  // different process can use this to ping wow64svc
#define WOW64_SVC_REFLECTOR_MUTEX_NAME L"Wow64svc reflector Mutex"  // different process can use this to synchronize 


#define TAG_KEY_ATTRIBUTE_32BIT_WRITE 0x00000001 //written by 32bit apps
#define TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE   0x00000002 //written by reflector

#define WOW64_REFLECTOR_DISABLE  0x00000001
#define WOW64_REFLECTOR_ENABLE   0x00000002


typedef struct _IsnNode {
    WCHAR NodeName [ISN_NODE_MAX_LEN];
    WCHAR NodeValue [ISN_NODE_MAX_LEN];
    DWORD Flag;
    HKEY   hKey;
}ISN_NODE_TYPE;

typedef enum _WOW6432VALUEKEY_TYPE { 
        None=0,
        Copy,       // it's a copy
        Reflected,    // if it's not a cpoy then it has been reflected on the otherside
        NonMergeable  // This key should not be merged.
}WOW6432_VALUEKEY_TYPE;

typedef struct _WOW6432VALUEKEY {

    WOW6432_VALUEKEY_TYPE ValueType; //define if it's a copy from the other side
    SIZE_T Reserve;
    ULONGLONG TimeStamp;  // time() stamp to track time when it was copied etc.

}WOW6432_VALUEKEY;

typedef WCHAR NODETYPE[ISN_NODE_MAX_LEN];

#define REG_OPTION_OPEN_32BITKEY  KEY_WOW64_32KEY              
#define REG_OPTION_OPEN_64BITKEY  KEY_WOW64_64KEY           

#define KEY_WOW64_OPEN             KEY_WOW64_64KEY
                                                    // This bit is set to make
                                                    // special meaning to Wow64
#ifndef KEY_WOW64_RES
#define KEY_WOW64_RES              (KEY_WOW64_64KEY | KEY_WOW64_32KEY)
#endif


#define WOW64_MAX_PATH 2048 
#ifdef __cplusplus
extern "C" {
#endif

LONG 
Wow64RegOpenKeyEx(
  IN  HKEY hKey,         // handle to open key
  IN  LPCWSTR lpSubKey,  // address of name of subkey to open
  IN  DWORD ulOptions,   // reserved    current implementation is zero means default.
  IN  REGSAM samDesired, // security access mask
  OUT PHKEY phkResult    // address of handle to open key
);

LONG 
Wow64RegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCWSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPWSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition   // address of disposition value buffer
);

BOOL
HandleToKeyName ( 
    IN HANDLE Key,
    IN PWCHAR KeyName,
    IN OUT DWORD * dwSize
    );

BOOL
CreateNode (
    PWCHAR Path
    );

HKEY
OpenNode (
    IN PWCHAR NodeName
    );

BOOL
CheckAndCreateNode (
    IN PWCHAR Name
    );

LONG 
RegReflectKey (
  HKEY hKey,         // handle to open key
  LPCTSTR lpSubKey,   // subkey name
  DWORD   dwOption   // option flag
);

BOOL 
Map64bitTo32bitKeyName (
    IN  PWCHAR Name64Key,
    OUT PWCHAR Name32Key
    );

BOOL 
Map32bitTo64bitKeyName (
    IN  PWCHAR Name32Key,
    OUT PWCHAR Name64Key
    );

// API called from wow64services

BOOL
InitReflector ();

BOOL 
StartReflector ();

BOOL 
StopReflector ();

BOOL
Wow64RegNotifyLoadHive (
    PWCHAR Name
    );

BOOL
Wow64RegNotifyUnloadHive (
    PWCHAR Name
    );

BOOL
Wow64RegNotifyLoadHiveByHandle (
    HKEY hKey
    );

BOOL
Wow64RegNotifyUnloadHiveByHandle (
    HKEY hKey
    );

BOOL
Wow64RegNotifyLoadHiveUserSid (
    PWCHAR lpwUserSid
    );

BOOL
Wow64RegNotifyUnloadHiveUserSid (
    PWCHAR lpwUserSid
    );

//Called from advapi32 to set a key dirty or need cleanup.
BOOL 
Wow64RegSetKeyDirty (
    HANDLE hKeyBase
    );
//Called from advapi32 to sync a key in case that need synchronization.
BOOL
Wow64RegCloseKey (
    HANDLE hKeyBase
    );
//Called from advapi32 to delete a key on the mirror side.
BOOL
Wow64RegDeleteKey (
    HKEY hBase,
    WCHAR  *SubKey
    );

//Called from advapi to get an handle to remapped key that is on reflection list.
HKEY
Wow64OpenRemappedKeyOnReflection (
    HKEY hKey
    );

void
InitializeWow64OnBoot(
    DWORD dwFlag
    );

BOOL
QueryKeyTag (
    HKEY hBase,
    DWORD *dwAttribute
    );

BOOL
Wow64SyncCLSID();

BOOL
IsExemptRedirectedKey (
    IN  PWCHAR SrcKey,
    OUT PWCHAR DestKey
    );

BOOL
IsOnReflectionByHandle ( 
    HKEY KeyHandle 
    );

#ifdef __cplusplus
}
#endif

#endif //__WOW64REG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wow64thk.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wow64thk.h

Abstract:

    Declarations shared between wow64.dll and the Win32 thunks in wow64win.dll

Author:

    29-Oct-1999 BarryBo

Revision History:

--*/

#ifndef _WOW64THK_INCLUDE
#define _WOW64THK_INCLUDE

#include <setjmp.h>

//
// Make wow64.dll exports __declspec(dllimport) when this header is included
// by non-wow64 components
//
#if !defined(_WOW64DLLAPI_)
#define WOW64DLLAPI DECLSPEC_IMPORT
#else
#define WOW64DLLAPI
#endif

typedef enum _WOW64_API_ERROR_ACTION {
    ApiErrorNTSTATUS,           //Return exception code as return value
    ApiErrorNTSTATUSTebCode,    //Some as above with SetLastError on exception code
    ApiErrorRetval,             //Return a constant parameter
    ApiErrorRetvalTebCode       //Some as above with SetLastError on exception code
} WOW64_API_ERROR_ACTION, *PWOW64_API_ERROR_ACTION;

//
// This structure describes what action should occure when
// thunks hit an unhandled exception.
//
typedef struct _WOW64_SERVICE_ERROR_CASE {
    WOW64_API_ERROR_ACTION ErrorAction;
    LONG ErrorActionParam;
} WOW64_SERVICE_ERROR_CASE, *PWOW64_SERVICE_ERROR_CASE;

// This is an extension of KSERVICE_TABLE_DESCRIPTOR
typedef struct _WOW64SERVICE_TABLE_DESCRIPTOR {
    PULONG_PTR Base;
    PULONG Count;
    ULONG Limit;
#if defined(_IA64_)
    LONG TableBaseGpOffset;
#endif
    PUCHAR Number;
    WOW64_API_ERROR_ACTION DefaultErrorAction;  //Action if ErrorCases is NULL.
    LONG DefaultErrorActionParam;               //Action parameter if ErrorCases is NULL.
    PWOW64_SERVICE_ERROR_CASE ErrorCases;
} WOW64SERVICE_TABLE_DESCRIPTOR, *PWOW64SERVICE_TABLE_DESCRIPTOR;

// Used to log hit counts for APIs.
typedef struct _WOW64SERVICE_PROFILE_TABLE WOW64SERVICE_PROFILE_TABLE;
typedef struct _WOW64SERVICE_PROFILE_TABLE *PWOW64SERVICE_PROFILE_TABLE;

typedef struct _WOW64SERVICE_PROFILE_TABLE_ELEMENT {
    PWSTR ApiName;
    SIZE_T HitCount;
    PWOW64SERVICE_PROFILE_TABLE SubTable;
    BOOLEAN ApiEnabled;
} WOW64SERVICE_PROFILE_TABLE_ELEMENT, *PWOW64SERVICE_PROFILE_TABLE_ELEMENT;

typedef struct _WOW64SERVICE_PROFILE_TABLE {
    PWSTR TableName;           //OPTIONAL
    PWSTR FriendlyTableName;   //OPTIONAL
    CONST PWOW64SERVICE_PROFILE_TABLE_ELEMENT ProfileTableElements;
    SIZE_T NumberProfileTableElements;
} WOW64SERVICE_PROFILE_TABLE, *PWOW64SERVICE_PROFILE_TABLE;

typedef struct UserCallbackData {
    jmp_buf JumpBuffer;
    PVOID   PreviousUserCallbackData;
    PVOID   OutputBuffer;
    ULONG   OutputLength;
    NTSTATUS Status;
    PVOID   UserBuffer;
} USERCALLBACKDATA, *PUSERCALLBACKDATA;

ULONG
WOW64DLLAPI
Wow64KiUserCallbackDispatcher(
    PUSERCALLBACKDATA pUserCallbackData,
    ULONG ApiNumber,
    ULONG ApiArgument,
    ULONG ApiSize
    );

PVOID
WOW64DLLAPI
Wow64AllocateTemp(
    SIZE_T Size
    );

WOW64DLLAPI
PVOID
Wow64AllocateHeap(
    SIZE_T Size
    );

WOW64DLLAPI
VOID
Wow64FreeHeap(
    PVOID BaseAddress
    );

//
// Logging mechanism.  Usage:
//  LOGPRINT((verbosity, format, ...))
//
#define LOGPRINT(args)  Wow64LogPrint args
#define ERRORLOG    LF_ERROR    // Always output to debugger.  Use for *unexpected*
                                // errors only
#define TRACELOG    LF_TRACE    // application trace information
#define INFOLOG     LF_TRACE    // misc. informational log
#define VERBOSELOG  LF_NONE     // practically never output to debugger

#if defined DBG
#define WOW64DOPROFILE
#endif

void
WOW64DLLAPI
Wow64LogPrint(
   UCHAR LogLevel,
   char *format,
   ...
   );

//
// WOW64 Assertion Mechanism.  Usage:
//  - put an ASSERTNAME macro at the top of each .C file
//  - WOW64ASSERT(expression)
//  - WOW64ASSERTMSG(expression, message)
//
//

VOID
WOW64DLLAPI
Wow64Assert(
    IN CONST PSZ exp,
    OPTIONAL IN CONST PSZ msg,
    IN CONST PSZ mod,
    IN LONG LINE
    );

#if DBG

#undef ASSERTNAME
#define ASSERTNAME static CONST PSZ szModule = __FILE__;

#define WOWASSERT(exp)                                  \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, NULL, szModule, __LINE__);   \
    }

#define WOWASSERTMSG(exp, msg)                          \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, msg, szModule, __LINE__);    \
    }

#else   // !DBG

#define WOWASSERT(exp)
#define WOWASSERTMSG(exp, msg)

#endif  // !DBG

#define WOWASSERT_PTR32(ptr) WOWASSERT((ULONGLONG)ptr < 0xFFFFFFFF)



// Defines the argsize of the emulated machine
#define ARGSIZE 4

// Determines if a pointer points to a item or is a special value.
// If it is a special value it should be copied without dereferencing.
#define WOW64_ISPTR(a) ((void *)a != NULL)

//
//  Helper thunk functions called by all the thunks to thunk common types.
//

NT32SIZE_T*
Wow64ShallowThunkSIZE_T64TO32(
     OUT NT32SIZE_T *dst,
     IN PSIZE_T src
     );

PSIZE_T
Wow64ShallowThunkSIZE_T32TO64(
     OUT PSIZE_T dst,
     IN NT32SIZE_T *src
     );

#define Wow64ThunkSIZE_T32TO64(src) \
     (SIZE_T)(src)

#define Wow64ThunkSIZE_T64TO32(src) \
     (NT32SIZE_T)min((src), 0xFFFFFFFF)

#define Wow64ShallowThunkUnicodeString32TO64(dst, src) \
     ((PUNICODE_STRING)(dst))->Length = ((NT32UNICODE_STRING *)(src))->Length; \
     ((PUNICODE_STRING)(dst))->MaximumLength = ((NT32UNICODE_STRING *)(src))->MaximumLength; \
     ((PUNICODE_STRING)(dst))->Buffer = (PWSTR)((NT32UNICODE_STRING *)(src))->Buffer;

#define Wow64ShallowThunkUnicodeString64TO32(dst, src) \
     ((NT32UNICODE_STRING *)(dst))->Length = ((PUNICODE_STRING)(src))->Length; \
     ((NT32UNICODE_STRING *)(dst))->MaximumLength = ((PUNICODE_STRING)(src))->MaximumLength; \
     ((NT32UNICODE_STRING *)(dst))->Buffer = (NT32PWSTR)((PUNICODE_STRING)(src))->Buffer;

#define Wow64ShallowThunkAllocUnicodeString32TO64(src) \
     Wow64ShallowThunkAllocUnicodeString32TO64_FNC((NT32UNICODE_STRING *)(src))

PUNICODE_STRING
Wow64ShallowThunkAllocUnicodeString32TO64_FNC(
    IN NT32UNICODE_STRING *src
    );

#define Wow64ShallowThunkAllocSecurityDescriptor32TO64(src) \
    Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC((NT32SECURITY_DESCRIPTOR *)(src))

PSECURITY_DESCRIPTOR
Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC(
    IN NT32SECURITY_DESCRIPTOR *src
    );

#define Wow64ShallowThunkAllocSecurityTokenProxyData32TO64(src) \
    Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC((NT32SECURITY_TOKEN_PROXY_DATA *)(src))

PSECURITY_TOKEN_PROXY_DATA
Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC(
    IN NT32SECURITY_TOKEN_PROXY_DATA *src
    );

#define Wow64ShallowThunkAllocSecurityQualityOfService32TO64(src) \
    Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC((NT32SECURITY_QUALITY_OF_SERVICE *)(src))

PSECURITY_QUALITY_OF_SERVICE
Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC(
    IN NT32SECURITY_QUALITY_OF_SERVICE *src
    );

#define Wow64ShallowThunkAllocObjectAttributes32TO64(src) \
    Wow64ShallowThunkAllocObjectAttributes32TO64_FNC((NT32OBJECT_ATTRIBUTES *)(src))

POBJECT_ATTRIBUTES
Wow64ShallowThunkAllocObjectAttributes32TO64_FNC(
    IN NT32OBJECT_ATTRIBUTES *src
    );

ULONG
Wow64ThunkAffinityMask64TO32(
    IN ULONG_PTR Affinity64
    );

ULONG_PTR
Wow64ThunkAffinityMask32TO64(
    IN ULONG Affinity32
    );

VOID WriteReturnLengthSilent(PULONG ReturnLength, ULONG Length);
VOID WriteReturnLengthStatus(PULONG ReturnLength, NTSTATUS *pStatus, ULONG Length);


//
// Log flags
//
#define LF_NONE                0x00000000
#define LF_ERROR               0x00000001
#define LF_TRACE               0x00000002
#define LF_NTBASE_NAME         0x00000004
#define LF_NTBASE_FULL         0x00000008
#define LF_WIN32_NAME          0x00000010
#define LF_WIN32_FULL          0x00000020
#define LF_NTCON_NAME          0x00000040
#define LF_NTCON_FULL          0x00000080
#define LF_ExCEPTION           0x80000000

//
// Supported data types for logging
//
#define TypeHex                0x00UI64
#define TypePULongPtrInOut     0x01UI64
#define TypePULongOut          0x02UI64
#define TypePHandleOut         0x03UI64
#define TypeUnicodeStringIn    0x04UI64
#define TypeObjectAttributesIn 0x05UI64
#define TypeIoStatusBlockOut   0x06UI64
#define TypePwstrIn            0x07UI64
#define TypePRectIn            0x08UI64
#define TypePLargeIntegerIn    0x09UI64


#undef WOW64DLLAPI

#endif	// _WOW64THK_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wx86pri.h ===
#ifndef _WX86PRI_H_
#define _WX86PRI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Flags used to communicate with Ole32 via Wx86Tib->Flags

#define WX86FLAG_CALLTHUNKED    0x80
#define WX86FLAG_QIFROMX86      0x40
#define WX86FLAG_QIFROMXNATIVE  0x20

//
typedef PVOID *(*PFNWX86GETOLEFUNCTIONTABLE)(void);
#define WX86GETOLEFUNCTIONTABLENAME "Wx86GetOleFunctionTable"

//
typedef PVOID *(*PFNWX86INITIALIZEOLE)(void);
#define WX86INITIALIZEOLENAME "Wx86InitializeOle"

//
typedef void (*PFNWX86DEINITIALIZEOLE)(void);
#define WX86DEINITIALIZEOLENAME "Wx86DeinitializeOle"

// apvWholeFunctions is a data export that is a pointer to a table of function
// pointers with entrypoints into whole32. Below are friendly names, corresponding
// indicies within the table, prototypes and useful macros. It is assumed 
// that apvWholeFuncs points to the array of function pointers returned.

#define WholeMapIFacePtrIdx                 1
#define WholeCheckFreeTempProxyIdx          3
#define WholeIID2IIDIDXIdx                  4
#define WholeDllGetClassObjectThunkIdx      5
#define WholeInitializeIdx                  6
#define WholeDeinitializeIdx                7
#define WholeNeedX86PSFactoryIdx            8
#define WholeIsN2XProxyIdx                  9
#define WholeThunkDllGetClassObjectIdx      10	    
#define WholeThunkDllCanUnloadNowIdx        11
#define WholeModuleLogFlagsIdx              12
#define WholeUnmarshalledInSameApt          13  
#define WholeAggregateProxyIdx              14
#define WholeIUnknownAddRefInternalIdx      15
#define Wx86LoadX86DllIdx                   16
#define Wx86FreeX86DllIdx                   17
#define WholeResolveProxyIdx                18
#define WholePatchOuterUnknownIdx           19

#define WHOLEFUNCTIONTABLESIZE              19

//
// types of interface proxy
typedef enum _proxytype
{
    X86toNative = 0,        // proxy for x86 calling native interface
    NativetoX86 = 1,         // proxy for native calling x86 interface
    ProxyAvail = 2         // proxy is not currently in use
} PROXYTYPE;

typedef enum {
    ResolvedToProxy,             // interface mapping resolved with proxy
    ResolvedToActual,            // iface mapping resolved with actual iface
} IFACERESOLVETYPE;


typedef struct _cifaceproxy *PCIP;


typedef HRESULT (*PFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);
typedef HRESULT (*PFNDLLCANUNLOADNOW)(void);

typedef void* (*WHOLEMAPIFACEPTR)(IUnknown*, IUnknown*, PROXYTYPE, int, BOOL, BOOL, HRESULT*, BOOL, PCIP);
typedef void (*WHOLECHECKFREETEMPPROXY)(void*);
typedef int (*WHOLEIID2IIDIDX)(const IID*);
typedef HRESULT (*WHOLELDLLGETCLASSOBJECTTHUNK)(IID *piid, LPVOID *ppv, HRESULT hr, BOOL fNativetoX86);
typedef BOOL (*WHOLEINITIALIZE)(void);
typedef void (*WHOLEDEINITIALIZE)(void);
typedef BOOL (*WHOLENEEDX86PSFACTORY)(IUnknown*, REFIID);
typedef BOOL (*WHOLEISN2XPROXY)(IUnknown *punk);
typedef PFNDLLGETCLASSOBJECT (*WHOLETHUNKDLLGETCLASSOBJECT)(PFNDLLGETCLASSOBJECT pv);
typedef PFNDLLCANUNLOADNOW (*WHOLETHUNKDLLCANUNLOADNOW)(PFNDLLCANUNLOADNOW pv);
typedef PVOID (*WHOLEUNMARSHALLEDINSAMEAPT)(PVOID, REFIID);
typedef void (*WHOLEAGGREGATEPROXY)(IUnknown *, IUnknown *);
typedef DWORD (*WHOLEIUNKNOWNADDREFINTERNAL)(IUnknown *, IUnknown *, BOOL, IFACERESOLVETYPE);
typedef HMODULE (*PFNWX86LOADX86DLL)(LPCWSTR, DWORD);
typedef BOOL (*PFNWX86FREEX86DLL)(HMODULE);
typedef IUnknown* (*WHOLERESOLVEPROXY)(IUnknown*, PROXYTYPE);
typedef void (*WHOLEPATCHOUTERUNKNOWN)(IUnknown*);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\xactsrv.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xactsrv.h

Abstract:

    Header file for XACTSRV.  Defines structures common to the server and
    XACTSRV.

Author:

    David Treadwell (davidtr) 07-Jan-1991

Revision History:

--*/

#ifndef _XACTSRV_
#define _XACTSRV_

//
// Structures for messages that are passed across the LPC port between
// the server and XACTSRV.
//
// *** The PORT_MESSAGE structure *must* be the first element of these
//     structures!

typedef struct _XACTSRV_REQUEST_MESSAGE {
    PORT_MESSAGE PortMessage;
    PTRANSACTION Transaction;
    WCHAR ClientMachineName[CNLEN + 1];
} XACTSRV_REQUEST_MESSAGE, *PXACTSRV_REQUEST_MESSAGE;

typedef struct _XACTSRV_REPLY_MESSAGE {
    PORT_MESSAGE PortMessage;
    NTSTATUS Status;
} XACTSRV_REPLY_MESSAGE, *PXACTSRV_REPLY_MESSAGE;

#endif // ndef _XACTSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\wsclus.h ===
/*
 *   wsclus.h
 *
 *   Microsoft Windows
 *   Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *   Windows Sockets include file for the Microsoft Cluster Network
 *   Protocol suite. Include this header file after winsock.h.
 *
 *   To open a Cluster Datagram Protocol socket, call socket() with an
 *   address family of AF_CLUSTER, a socket type of SOCK_DGRAM, and
 *   protocol CLUSPROTO_CDP.
 *
 *   The Cluster Network Protocol suite uses little endian byte
 *   ordering in its address components.
 */

#ifndef _WSCLUS_INCLUDED
#define _WSCLUS_INCLUDED

/*
 *   This is the structure of the SOCKADDR structure for the Microsoft
 *   Cluster Network Protocol.
 */

typedef struct sockaddr_cluster {
    u_short sac_family;
    u_short sac_port;
    u_long  sac_node;
    u_long  sac_zero;
} SOCKADDR_CLUSTER, *PSOCKADDR_CLUSTER, FAR *LPSOCKADDR_CLUSTER;

/*
 *  Node address constants
 */
#define CLUSADDR_ANY   0


/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 */

#define CLUSPROTO_CDP  2


/*
 *   Protocol-specific IOCTLs
 *
 */

#define WSVENDOR_MSFT    0x00010000

#define WSCLUS_IOCTL(_code)    (_WSAIO(IOC_VENDOR, (_code)) | WSVENDOR_MSFT)

#define SIO_CLUS_IGNORE_NODE_STATE   WSCLUS_IOCTL(1)



#endif // ifndef _WSCLUS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\x86new.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86new.h

Abstract:

    This module contains the public header file that describes the
    HAL interfaces to the 386/486 BIOS emulation.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _X86NEW_
#define _X86NEW_

//
// PCI Bios function code defintitions.
//
// AH:
//

#define PCI_FUNCTION_ID         0xb1

//
// AL:
//

#define PCI_BIOS_PRESENT        0x01
#define PCI_FIND_DEVICE         0x02
#define PCI_FIND_CLASS_CODE     0x03
#define PCI_GENERATE_CYCLE      0x06
#define PCI_READ_CONFIG_BYTE    0x08
#define PCI_READ_CONFIG_WORD    0x09
#define PCI_READ_CONFIG_DWORD   0x0a
#define PCI_WRITE_CONFIG_BYTE   0x0b
#define PCI_WRITE_CONFIG_WORD   0x0c
#define PCI_WRITE_CONFIG_DWORD  0x0d
#define PCI_GET_IRQ_ROUTING     0x0e
#define PCI_SET_IRQ             0x0f

//
// PCI Bios function return code values.
//

#define PCI_SUCCESS             0x00
#define PCI_NOT_SUPPORTED       0x81
#define PCI_BAD_VENDOR_ID       0x83
#define PCI_DEVICE_NOT_FOUND    0x86
#define PCI_BAD_REGISTER        0x87
#define PCI_SET_FAILED          0x88
#define PCI_BUFFER_TOO_SMALL    0x89

//
// Miscellaneous PCI codes.
//

#define PCI_CONFIG_MECHANISM_2  0x02
#define PCI_ILLEGAL_VENDOR_ID   0xffff

//
// Define PCI get/set function type.
//

typedef
ULONG
(*PGETSETPCIBUSDATA)(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define BIOS emulation interfaces.
//

VOID
x86BiosInitializeBios (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory
    );

VOID
x86BiosInitializeBiosEx (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosTransferMemory,
    IN ULONG TransferLength
    );

VOID
x86BiosInitializeBiosShadowed (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer
    );

VOID
x86BiosInitializeBiosShadowedPci (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowed (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowedPci (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosInitializeAdapter (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowed (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowedPci(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

#endif // _X86NEW_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\x86mboot.h ===
#define X86PC98BOOTCODE_SIZE 2048


unsigned char x86PC98BootCode[] = {
235,10,144,144,73,80,76,49,0,0,0,30,160,132,5,180,
142,205,27,168,32,116,34,50,219,180,20,205,27,114,26,128,
251,132,117,21,232,150,0,115,3,235,107,144,180,36,187,0,
4,185,48,18,186,64,1,205,27,187,0,1,180,132,205,27,
180,6,51,201,51,210,80,140,200,45,192,3,142,192,88,51,
237,205,27,114,65,180,6,186,1,0,129,197,0,8,205,27,
114,52,186,4,0,247,195,0,170,116,3,186,2,0,180,6,
187,0,28,129,197,0,8,205,27,114,27,80,139,197,177,4,
211,232,140,193,3,193,139,240,88,232,21,0,46,137,54,10,
0,46,255,30,8,0,232,8,0,180,14,205,27,185,1,0,
203,86,160,132,5,50,219,180,20,205,27,114,14,128,251,132,
117,9,46,198,6,212,0,0,232,2,0,94,195,180,176,190,
208,0,186,6,0,30,14,31,205,27,180,176,205,27,31,195,
30,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170
};
#define X86PC98BOOTMENU_SIZE 8192


unsigned char x86PC98BootMenu[] = {
233,209,2,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,78,69,67,32,202,223,176,191,197,217,186,221,203,
223,173,176,192,140,197,146,232,131,102,131,66,131,88,131,78,
139,78,147,174,131,129,131,106,131,133,129,91,131,118,131,141,
131,79,131,137,131,128,32,202,222,176,188,222,174,221,32,50,
46,55,48,32,67,111,112,121,114,105,103,104,116,32,40,67,
41,32,78,69,67,32,67,111,114,112,111,114,97,116,105,111,
110,32,49,57,56,53,44,49,57,57,53,143,136,32,32,151,
157,129,70,151,204,136,230,130,204,145,73,145,240,129,105,139,
78,147,174,129,106,145,149,146,117,130,204,145,73,145,240,140,
197,146,232,131,102,131,66,131,88,131,78,83,67,83,73,140,
197,146,232,131,102,131,66,131,88,131,78,140,245,131,102,131,
66,131,88,131,78,129,148,131,129,129,64,131,106,129,64,131,
133,129,64,129,91,129,64,143,73,129,64,151,185,149,87,143,
128,131,116,131,72,129,91,131,125,131,98,131,103,150,162,131,
116,131,72,129,91,131,125,131,98,131,103,144,224,150,190,129,
70,129,170,129,69,129,171,131,76,129,91,129,129,151,204,136,
230,130,204,145,73,145,240,129,64,129,169,131,76,129,91,129,
129,145,149,146,117,130,204,145,73,145,240,129,64,131,138,131,
94,129,91,131,147,131,76,129,91,129,129,139,78,147,174,139,
78,147,174,137,194,148,92,130,200,151,204,136,230,130,170,130,
160,130,232,130,220,130,185,130,241,144,224,150,190,129,70,129,
170,129,69,129,171,131,76,129,91,129,129,145,149,146,117,130,
204,145,73,145,240,129,64,129,168,131,76,129,91,129,129,151,
204,136,230,130,204,145,73,145,240,129,94,139,78,147,174,129,
64,129,64,129,64,129,64,129,64,129,64,129,64,129,64,129,
64,129,64,129,64,129,64,129,64,129,64,129,64,129,64,131,
138,131,94,129,91,131,147,131,76,129,91,129,129,151,204,136,
230,130,204,149,92,142,166,131,71,131,137,129,91,129,70,131,
102,131,66,131,88,131,78,147,199,130,221,142,230,130,232,130,
201,142,184,148,115,130,181,130,220,130,181,130,189,131,71,131,
137,129,91,129,70,131,102,131,67,131,88,131,78,143,145,130,
171,141,158,130,221,130,201,142,184,148,115,130,181,130,220,130,
181,130,189,130,199,130,234,130,169,131,76,129,91,130,240,137,
159,130,181,130,196,130,173,130,190,130,179,130,162,129,150,144,
224,150,190,129,70,129,150,130,205,142,169,147,174,139,78,147,
174,130,201,144,221,146,232,130,179,130,234,130,189,151,204,136,
230,130,197,130,183,32,32,130,134,129,69,130,80,131,76,129,
91,129,129,142,169,147,174,139,78,147,174,130,204,144,221,146,
232,32,32,130,134,129,69,130,80,131,76,129,91,129,129,142,
169,147,174,139,78,147,174,130,204,137,240,143,156,30,0,0,
0,0,0,0,232,212,6,131,249,1,117,6,46,198,6,211,
2,1,246,6,1,5,8,117,3,235,123,144,246,6,2,4,
31,117,3,235,113,144,160,132,5,180,132,205,27,115,3,233,
109,4,185,8,0,129,251,0,1,116,3,185,16,0,6,232,
120,18,140,199,7,190,0,8,209,227,38,139,4,37,128,128,
61,128,128,117,57,38,138,4,138,38,2,4,37,31,31,58,
224,117,43,160,132,5,180,6,38,139,84,4,38,139,76,6,
232,94,18,142,199,51,237,205,27,115,3,233,33,4,209,235,
129,238,0,8,3,243,6,85,12,128,232,132,16,203,131,198,
32,226,183,233,9,4,187,0,1,160,132,5,180,132,205,27,
115,6,232,108,16,233,71,14,156,80,6,184,232,248,142,192,
38,129,62,0,0,152,33,117,38,38,246,6,5,0,64,116,
30,7,88,157,176,128,232,245,2,115,3,233,33,14,233,229,
18,144,144,144,144,144,144,144,144,144,144,144,144,144,144,7,
88,157,246,6,1,5,8,116,3,233,13,3,6,184,0,160,
142,192,38,246,6,242,63,240,7,116,3,235,28,144,83,180,
1,205,24,128,255,0,91,116,16,61,27,0,117,3,233,232,
2,61,9,15,117,3,233,224,2,232,57,0,10,192,117,3,
233,214,2,232,187,15,38,139,84,4,38,139,76,6,232,121,
15,162,132,5,232,131,17,129,238,0,8,3,243,209,227,160,
132,5,232,140,17,51,237,180,6,205,27,114,2,6,85,12,
128,232,189,15,203,6,184,0,160,142,192,38,160,242,63,7,
36,240,60,0,117,27,232,67,0,10,192,117,62,232,135,0,
10,192,117,55,232,214,0,10,192,117,48,232,234,1,235,43,
144,60,160,117,6,232,36,0,235,33,144,60,176,117,6,232,
101,0,235,23,144,60,192,117,6,232,177,0,235,13,144,60,
96,117,6,232,194,1,235,3,144,50,192,195,180,1,176,128,
132,38,93,5,116,38,232,5,2,114,33,38,139,87,250,128,
250,128,116,3,235,22,144,138,214,80,232,169,14,131,238,16,
38,139,4,232,200,14,88,117,3,235,27,144,144,144,144,144,
144,144,144,246,196,1,116,6,208,228,176,129,235,194,160,132,
5,232,202,1,50,192,195,180,2,176,129,144,144,144,144,144,
144,144,180,4,176,130,132,38,93,5,116,38,232,175,1,114,
33,38,139,87,250,128,250,128,116,3,235,22,144,138,214,80,
232,83,14,131,238,16,38,139,4,232,114,14,88,117,3,235,
27,144,144,144,144,144,144,144,144,246,196,4,116,6,208,228,
176,131,235,194,160,132,5,232,116,1,50,192,195,180,1,176,
160,128,62,124,4,0,116,3,233,207,0,246,6,130,4,128,
116,3,233,197,0,131,62,126,4,0,117,3,233,187,0,30,
14,31,46,132,38,65,22,31,116,38,232,65,1,114,33,38,
139,87,250,128,250,128,116,3,235,22,144,138,214,80,232,229,
13,131,238,16,38,139,4,232,4,14,88,117,3,233,137,0,
208,228,254,192,246,196,128,116,198,176,160,180,1,132,38,130,
4,116,44,132,38,125,4,117,38,232,2,1,114,33,38,139,
87,250,128,250,128,116,3,235,22,144,138,214,80,232,166,13,
131,238,16,38,139,4,232,197,13,88,117,3,235,75,144,208,
228,254,192,246,196,128,116,197,176,168,180,1,132,38,127,4,
116,38,232,201,0,114,33,38,139,87,250,128,250,128,116,3,
235,22,144,138,214,80,232,109,13,131,238,16,38,139,4,232,
140,13,88,117,3,235,18,144,208,228,254,192,246,196,128,116,
203,160,132,5,232,151,0,50,192,195,132,38,130,4,116,38,
232,139,0,114,33,38,139,87,250,128,250,128,116,3,235,22,
144,138,214,80,232,47,13,131,238,16,38,139,4,232,78,13,
88,117,3,235,18,144,208,228,254,192,246,196,128,116,203,160,
132,5,232,89,0,50,192,195,176,160,51,219,138,216,128,227,
15,208,227,208,227,129,195,96,4,128,63,0,116,53,180,20,
50,219,205,27,128,251,132,117,42,232,50,0,115,5,232,45,
0,114,32,38,139,87,250,128,250,128,116,2,235,21,138,214,
80,232,210,12,131,238,16,38,139,4,232,241,12,88,117,3,
235,11,144,254,192,60,167,116,2,235,175,50,192,195,80,81,
82,187,0,1,180,132,205,27,36,127,51,201,51,210,51,237,
180,6,205,27,114,11,180,6,185,1,0,129,197,0,8,205,
27,90,89,88,195,80,187,0,1,180,132,205,27,51,201,51,
210,51,237,180,5,205,27,88,195,232,169,0,10,192,117,3,
233,156,0,46,246,6,211,2,1,116,17,128,253,1,117,12,
46,198,6,211,2,0,232,140,0,233,7,253,46,198,6,211,
2,0,232,188,12,252,184,0,10,205,24,180,22,186,32,225,
205,24,180,12,205,24,180,18,205,24,30,14,31,190,100,0,
191,14,0,185,48,0,232,42,11,190,148,0,191,174,0,185,
39,0,232,30,11,190,187,0,191,238,1,185,8,0,232,18,
11,190,195,0,191,254,1,185,18,0,232,6,11,31,232,52,
0,81,82,232,24,3,90,254,202,232,232,12,185,16,0,232,
193,11,89,82,81,232,197,3,89,138,209,138,226,232,177,12,
185,22,0,232,191,11,232,75,13,90,182,1,233,228,8,12,
128,232,109,12,203,51,201,180,1,176,128,132,38,93,5,116,
21,254,193,232,8,255,114,14,81,232,43,1,89,10,210,116,
5,2,234,233,30,1,246,196,8,117,6,208,228,254,192,235,
218,180,1,176,160,128,62,124,4,0,116,3,233,156,0,246,
6,130,4,128,116,3,233,146,0,131,62,126,4,0,117,3,
233,136,0,30,14,31,46,132,38,65,22,31,116,21,254,193,
232,187,254,114,14,81,232,222,0,89,10,210,116,5,2,234,
233,209,0,208,228,254,192,246,196,128,117,2,235,213,180,1,
176,160,132,38,130,4,116,27,132,38,125,4,117,21,254,193,
232,139,254,114,14,81,232,174,0,89,10,210,116,5,2,234,
233,161,0,208,228,254,192,246,196,128,117,2,235,212,180,1,
176,168,132,38,127,4,116,21,254,193,232,97,254,114,14,81,
232,132,0,89,10,210,116,5,2,234,235,120,144,208,228,254,
192,246,196,128,117,2,235,218,235,39,144,132,38,130,4,116,
21,254,193,232,56,254,114,14,81,232,91,0,89,10,210,116,
5,2,234,235,79,144,208,228,254,192,246,196,128,117,2,235,
218,176,160,83,51,219,138,216,128,227,15,208,227,208,227,129,
195,96,4,128,63,0,116,33,180,20,50,219,205,27,128,251,
132,117,22,254,193,232,246,253,114,15,81,232,25,0,89,10,
210,116,6,91,2,234,233,176,13,91,254,192,60,167,116,2,
235,193,50,192,254,201,195,80,38,129,127,254,85,170,117,47,
190,0,8,185,8,0,50,210,129,251,0,1,116,3,185,16,
0,38,139,4,131,198,32,232,148,10,116,6,233,128,13,235,
14,144,254,194,46,246,6,211,2,1,116,3,73,117,226,131,
238,32,88,195,80,30,51,192,142,216,180,1,51,201,132,38,
93,5,116,1,65,246,196,8,117,4,208,228,235,240,31,88,
195,80,30,51,192,142,216,180,1,51,201,128,62,124,4,0,
116,3,235,61,144,246,6,130,4,128,116,3,235,51,144,131,
62,126,4,0,117,3,235,41,144,30,14,31,46,132,38,65,
22,31,116,1,65,246,196,64,117,4,208,228,235,235,184,1,
0,133,6,126,4,116,1,65,169,0,64,117,20,233,148,15,
144,132,38,130,4,116,1,65,246,196,64,117,4,208,228,235,
240,31,88,195,80,83,30,51,192,142,216,176,160,51,201,51,
219,138,216,128,227,15,208,227,208,227,129,195,96,4,128,63,
0,116,12,180,20,50,219,205,27,128,251,132,117,1,65,60,
166,116,4,254,192,235,216,31,91,88,195,80,30,51,201,51,
192,142,216,180,1,176,128,132,38,93,5,116,7,80,180,142,
205,27,88,65,246,196,8,117,6,208,228,254,192,235,232,31,
83,30,51,192,142,216,176,160,51,219,138,216,128,227,15,208,
227,208,227,129,195,96,4,128,63,0,116,36,180,20,50,219,
205,27,128,251,132,116,9,128,251,0,117,20,65,235,17,144,
65,81,180,36,187,0,4,185,48,18,186,64,1,205,27,89,
60,166,116,4,254,192,235,192,128,62,124,4,0,116,3,235,
57,144,246,6,130,4,128,116,3,235,47,144,131,62,126,4,
0,117,3,235,37,144,83,138,30,130,4,34,30,125,4,30,
14,31,136,30,65,22,31,91,180,1,132,38,127,4,116,10,
65,246,196,64,117,4,208,228,235,240,31,91,88,195,38,129,
127,254,85,170,117,114,80,50,210,232,218,8,131,239,6,6,
86,51,246,190,0,160,246,6,1,5,8,116,3,190,0,224,
142,198,50,228,128,250,9,114,21,176,49,128,234,10,171,50,
228,138,194,4,48,254,192,171,128,194,10,235,13,144,50,228,
176,32,171,138,194,4,48,254,192,171,176,58,171,94,7,30,
6,31,232,142,7,31,254,194,129,251,0,1,117,7,128,250,
7,119,9,235,164,128,250,15,119,2,235,157,232,172,10,117,
3,232,215,7,88,50,228,195,51,201,186,2,0,51,237,180,
6,205,27,114,37,38,129,62,0,0,86,79,117,28,38,129,
62,2,0,76,49,117,19,180,1,190,29,1,191,124,3,185,
16,0,30,14,31,232,59,7,31,195,180,2,190,45,1,185,
14,0,191,124,3,30,14,31,232,40,7,31,195,80,83,51,
219,232,208,253,3,217,232,232,253,3,217,232,70,254,233,76,
11,144,81,232,26,1,30,14,31,232,7,7,80,190,5,1,
191,82,3,128,251,8,118,8,191,178,2,176,80,235,3,144,
176,160,246,226,209,224,3,248,88,185,2,0,232,228,6,80,
134,224,128,228,15,30,80,51,192,142,216,88,128,62,124,4,
0,117,64,246,6,130,4,128,117,57,131,62,126,4,0,117,
3,235,48,144,246,196,8,116,8,128,236,8,176,255,235,35,
144,81,181,1,138,204,210,229,132,46,125,4,89,117,20,176,
1,81,50,201,132,6,125,4,116,6,254,193,208,224,235,244,
42,225,89,31,254,196,60,255,116,10,50,192,128,252,10,114,
70,235,6,144,50,192,128,196,10,80,184,49,0,6,51,246,
142,198,190,0,160,38,246,6,1,5,8,116,3,190,0,224,
142,198,171,7,88,128,236,10,128,196,48,134,224,6,51,246,
142,198,190,0,160,38,246,6,1,5,8,116,3,190,0,224,
142,198,171,7,235,31,144,5,3,48,6,51,246,142,198,190,
0,160,38,246,6,1,5,8,116,3,190,0,224,142,198,171,
128,204,128,171,7,254,194,88,31,89,73,131,249,0,116,3,
233,255,254,6,51,246,142,198,38,246,6,1,5,8,117,12,
7,6,232,11,0,30,14,31,232,248,5,31,7,91,88,195,
83,51,219,232,158,252,3,217,232,182,252,3,217,232,20,253,
3,217,58,211,118,15,246,6,1,5,8,117,2,254,195,58,
211,118,2,50,210,180,1,176,128,51,201,132,38,93,5,116,
8,58,209,117,3,233,245,0,65,246,196,8,117,6,254,192,
208,228,235,231,176,160,180,1,128,62,124,4,0,116,3,235,
112,144,246,6,130,4,128,116,3,235,102,144,131,62,126,4,
0,117,3,235,92,144,30,14,31,46,132,38,65,22,31,116,
8,58,209,117,3,233,181,0,65,246,196,64,117,6,254,192,
208,228,235,226,180,1,176,160,132,38,130,4,116,14,132,38,
125,4,117,8,58,209,117,3,233,146,0,65,246,196,64,117,
6,254,192,208,228,235,225,180,1,176,168,132,38,127,4,116,
5,58,209,116,120,65,246,196,64,117,28,254,192,208,228,235,
234,132,38,130,4,116,5,58,209,116,98,65,246,196,64,117,
6,254,192,208,228,235,234,176,160,83,51,219,138,216,128,227,
15,208,227,208,227,129,195,96,4,128,63,0,91,116,18,83,
180,20,50,219,205,27,128,251,132,91,117,5,58,209,116,45,
65,60,166,116,6,254,192,208,228,235,206,190,7,1,191,46,
3,128,251,8,118,8,191,142,2,176,80,235,3,144,176,160,
246,226,209,224,3,248,185,22,0,91,50,192,195,168,32,116,
118,128,62,124,4,0,117,55,246,6,130,4,128,117,48,131,
62,126,4,0,117,3,235,39,144,83,51,219,138,62,125,4,
246,199,1,116,6,254,195,208,239,235,245,128,195,160,58,195,
91,115,3,235,10,144,190,47,22,185,18,0,235,63,144,83,
51,219,138,216,128,227,15,208,227,208,227,129,195,96,4,128,
63,0,91,117,3,233,121,255,83,180,20,50,219,205,27,128,
251,132,91,117,9,190,251,0,185,10,0,235,16,144,190,235,
0,185,16,0,235,7,144,190,223,0,185,12,0,80,191,46,
3,128,251,8,118,8,191,142,2,176,80,235,3,144,176,160,
246,226,209,224,3,248,88,91,195,128,254,0,117,3,233,50,
2,232,16,6,185,16,0,232,242,4,232,66,6,30,14,31,
190,3,0,191,254,1,185,18,0,232,7,4,190,213,0,191,
254,1,185,10,0,232,251,3,232,186,6,232,85,6,232,192,
5,185,22,0,232,188,4,182,0,138,212,82,80,232,226,7,
88,80,232,124,5,88,90,31,233,232,1,128,254,0,116,3,
233,224,1,232,5,7,116,3,235,11,144,232,203,5,58,202,
117,3,233,206,1,82,80,232,229,5,232,195,253,232,33,5,
232,251,247,138,208,88,138,194,90,115,15,232,74,6,232,150,
6,232,255,5,232,58,5,233,169,1,80,83,82,232,174,251,
90,91,138,204,88,128,249,2,116,8,128,249,1,116,18,235,
38,144,232,35,6,232,90,6,232,216,5,232,19,5,233,130,
1,144,246,6,1,5,8,117,233,191,124,3,185,16,0,232,
49,4,178,0,235,48,144,80,83,82,232,202,249,138,202,90,
91,88,128,249,0,116,3,235,16,144,232,235,5,232,34,6,
232,160,5,232,219,4,233,74,1,138,209,254,202,232,36,5,
185,16,0,232,253,3,30,14,31,190,3,0,191,254,1,185,
10,0,232,30,3,190,195,0,191,254,1,185,18,0,232,18,
3,232,180,5,232,125,5,232,215,4,185,22,0,232,229,3,
182,1,31,233,13,1,128,254,1,116,3,235,80,144,38,129,
62,0,0,86,79,117,12,38,129,62,2,0,76,49,117,3,
233,240,0,232,159,5,232,75,5,138,202,128,249,0,116,5,
254,201,235,11,144,177,7,129,251,0,1,116,2,177,15,232,
219,4,117,231,232,173,4,81,185,16,0,232,142,3,89,138,
209,232,160,4,185,16,0,232,121,3,233,182,0,232,169,4,
232,216,5,117,2,254,193,128,250,0,116,5,254,202,235,5,
144,138,209,254,202,232,89,4,185,22,0,232,94,3,138,226,
232,78,4,185,22,0,232,74,3,232,163,4,233,132,0,128,
254,1,116,3,235,81,144,38,129,62,0,0,86,79,117,12,
38,129,62,2,0,76,49,117,3,235,104,144,232,22,5,232,
194,4,138,202,181,7,129,251,0,1,116,2,181,15,58,205,
116,5,254,193,235,3,144,177,0,232,81,4,117,240,232,35,
4,81,185,16,0,232,4,3,89,138,209,232,22,4,185,16,
0,232,239,2,235,45,144,232,31,4,232,78,5,117,2,254,
193,254,194,58,209,117,2,178,0,232,213,3,185,22,0,232,
218,2,138,226,232,202,3,185,22,0,232,198,2,232,31,4,
235,1,144,80,180,0,205,24,139,200,88,129,249,0,58,117,
3,233,226,254,129,249,0,59,117,3,233,172,253,129,249,0,
60,117,3,233,245,253,129,249,0,61,117,3,233,80,255,129,
249,13,28,116,46,129,249,0,98,116,2,235,198,128,254,1,
117,193,38,129,62,0,0,86,79,117,11,38,129,62,2,0,
76,49,117,2,235,173,232,210,4,117,168,232,42,1,232,3,
4,235,160,128,254,0,116,3,235,94,144,232,189,4,116,3,
235,25,144,232,131,3,58,202,117,17,180,22,186,32,225,205,
24,232,122,5,144,117,2,205,31,205,30,138,226,82,80,232,
141,3,232,107,251,232,166,245,138,208,88,138,194,90,115,28,
82,80,232,91,251,232,150,245,138,208,88,138,194,90,115,12,
232,229,3,232,49,4,232,154,3,233,71,255,80,83,82,232,
76,249,90,91,88,233,59,255,38,129,62,0,0,86,79,117,
85,38,129,62,2,0,76,49,117,76,12,128,162,132,5,80,
82,6,184,192,31,246,6,1,5,8,116,3,184,192,63,142,
192,160,132,5,209,227,51,210,51,201,51,237,180,6,205,27,
115,17,7,90,88,232,173,3,232,220,3,232,86,3,209,235,
233,240,254,80,184,0,10,205,24,180,22,186,32,225,205,24,
88,139,215,6,85,203,80,232,204,1,88,80,82,6,131,238,
16,38,139,84,4,139,250,38,139,76,6,232,236,1,139,250,
12,128,162,132,5,232,242,3,129,238,0,8,3,243,209,227,
160,132,5,51,237,232,249,3,180,6,205,27,115,17,7,90,
88,232,81,3,232,128,3,232,250,2,209,235,233,148,254,12,
128,232,29,2,90,80,184,0,10,205,24,180,22,186,32,225,
205,24,88,139,215,6,85,203,80,82,38,128,127,250,0,116,
11,38,198,71,250,0,232,1,4,235,9,144,233,166,6,144,
144,144,144,144,82,51,201,51,210,51,237,180,5,205,27,90,
115,31,82,51,210,180,5,205,27,90,115,21,38,128,119,250,
128,30,14,31,232,117,0,232,50,3,232,151,2,31,235,27,
144,38,128,127,250,128,117,19,30,14,31,232,94,0,232,131,
2,144,144,144,144,144,144,144,144,144,31,232,109,0,90,88,
233,16,254,80,6,51,192,142,192,184,0,160,38,246,6,1,
5,8,116,3,184,0,224,142,192,173,232,114,0,115,13,50,
228,168,224,117,2,176,32,171,78,235,28,144,44,32,60,9,
116,11,60,10,116,7,60,11,116,3,235,5,144,171,235,7,
144,171,128,204,128,171,73,226,208,7,88,195,80,30,14,31,
190,3,0,191,104,14,185,80,0,232,167,255,190,3,0,191,
8,15,185,80,0,232,155,255,31,88,195,82,38,139,87,250,
134,214,232,145,0,131,199,36,185,2,0,190,3,0,128,254,
0,116,3,190,109,2,90,30,14,31,232,118,255,31,195,60,
128,114,11,60,160,114,9,60,224,114,3,235,3,144,249,195,
134,196,128,252,128,116,40,128,252,160,115,6,128,236,112,235,
9,144,128,252,240,115,24,128,236,176,10,192,121,2,254,200,
2,228,60,158,114,5,44,94,235,3,144,254,204,44,31,134,
196,248,195,80,184,229,0,232,20,0,88,195,80,184,225,0,
232,11,0,88,195,80,184,233,0,232,2,0,88,195,6,80,
184,0,160,232,69,2,116,3,184,0,224,142,192,88,129,199,
0,32,243,171,7,195,138,194,180,32,246,228,190,0,8,131,
198,16,3,240,191,124,3,129,251,0,1,116,5,176,80,235,
3,144,176,160,246,226,209,224,3,248,185,16,0,195,37,176,
128,61,144,128,116,3,61,160,128,195,83,82,81,51,219,180,
132,205,27,129,251,0,8,116,9,129,251,0,4,117,3,187,
0,2,89,90,11,219,117,23,128,252,3,117,18,246,6,1,
5,8,117,11,247,193,1,0,116,3,128,198,4,209,233,91,
195,86,80,83,82,12,128,50,219,180,20,205,27,114,29,128,
251,132,117,24,46,198,6,209,2,1,180,176,190,205,2,186,
6,0,30,14,31,205,27,180,176,205,27,31,90,91,88,94,
195,86,80,83,82,12,128,50,219,180,20,205,27,114,29,128,
251,132,117,24,46,198,6,209,2,0,180,176,190,205,2,186,
6,0,30,14,31,205,27,180,176,205,27,31,90,91,88,94,
195,80,138,196,177,160,246,225,232,46,0,131,249,8,119,2,
209,224,131,249,8,119,6,5,46,3,235,4,144,5,142,2,
139,248,88,195,80,176,160,246,226,129,251,0,1,117,2,209,
224,139,248,88,129,199,124,3,195,80,232,167,244,139,249,232,
191,244,3,249,83,232,28,245,91,3,207,88,195,80,176,32,
246,225,190,0,8,3,240,38,139,4,232,1,255,88,195,185,
8,0,129,251,0,1,116,3,185,16,0,191,118,3,81,190,
3,0,185,23,0,30,14,31,87,232,183,253,95,31,129,251,
0,1,116,7,129,199,160,0,235,5,144,129,199,64,1,89,
226,220,195,30,14,31,190,153,1,191,104,14,185,110,0,232,
145,253,31,195,30,14,31,190,59,1,191,104,14,185,68,0,
232,128,253,38,129,127,254,85,170,117,27,232,173,0,117,22,
190,149,2,38,246,71,250,128,116,3,233,1,1,191,20,15,
185,28,0,232,93,253,31,195,30,14,31,190,3,0,191,104,
14,185,56,0,232,76,253,190,3,0,191,20,15,185,24,0,
232,64,253,31,195,30,14,31,190,3,0,191,104,14,185,68,
0,232,47,253,190,3,0,191,20,15,185,62,0,232,35,253,
31,195,30,14,31,190,127,1,191,104,14,185,26,0,232,18,
253,191,160,14,235,40,144,30,14,31,190,7,2,191,104,14,
185,38,0,232,253,252,191,184,14,235,19,144,30,14,31,190,
45,2,191,104,14,185,38,0,232,232,252,191,184,14,190,83,
2,185,26,0,232,220,252,80,180,0,205,24,88,190,3,0,
191,96,14,185,80,0,232,202,252,31,195,6,81,51,201,142,
193,38,246,6,1,5,8,89,7,195,80,83,140,200,5,192,
1,5,0,1,209,235,209,235,209,235,43,195,142,192,91,88,
195,83,80,168,32,116,52,180,20,50,219,205,27,128,251,132,
117,41,82,81,180,132,205,27,139,218,50,228,138,198,89,247,
225,89,81,138,205,50,237,3,193,50,255,247,227,89,50,237,
3,193,131,210,0,139,200,88,36,127,80,88,91,195,190,241,
21,191,20,15,185,62,0,233,249,254,232,159,252,232,196,254,
195,32,32,130,134,129,69,130,80,131,76,129,91,129,129,142,
169,147,174,139,78,147,174,130,204,137,240,143,156,32,32,129,
150,130,205,142,169,147,174,139,78,147,174,130,201,144,221,146,
232,130,179,130,234,130,189,151,204,136,230,130,197,130,183,131,
102,131,66,131,88,131,78,131,65,131,140,131,67,32,32,32,
32,0,30,80,51,192,142,216,88,232,4,246,31,195,199,6,
120,0,0,0,228,49,168,1,195,187,0,4,233,85,242,46,
246,6,211,2,1,116,9,73,117,3,233,114,242,233,97,242,
254,194,73,117,5,50,210,233,101,242,233,84,242,3,217,139,
203,50,210,233,172,244,186,0,0,80,232,185,252,131,238,16,
38,139,4,232,216,252,88,116,3,235,4,144,233,84,237,228,
160,168,32,116,250,176,1,230,164,184,0,10,205,24,180,22,
186,32,65,205,24,180,18,205,24,180,12,205,24,252,184,0,
160,142,192,191,108,5,232,89,0,191,12,6,232,150,0,191,
172,6,232,199,0,191,76,7,232,248,0,191,236,7,232,47,
1,191,140,8,232,89,1,51,192,142,192,38,246,6,1,5,
128,186,223,63,176,118,238,116,6,184,230,3,235,4,144,184,
205,4,186,219,63,238,138,196,238,176,6,230,55,185,8,0,
81,185,255,255,230,95,226,252,89,226,245,176,7,230,55,244,
235,253,184,5,79,232,56,1,184,1,60,232,50,1,184,5,
73,232,44,1,184,5,71,232,38,1,184,5,35,232,32,1,
184,5,57,232,26,1,184,5,47,232,20,1,184,21,47,232,
14,1,184,38,48,232,8,1,184,27,126,232,2,1,184,4,
75,232,252,0,195,184,30,99,232,245,0,184,19,50,232,239,
0,184,4,44,232,233,0,184,40,47,232,227,0,184,32,56,
232,221,0,184,4,55,232,215,0,184,4,94,232,209,0,184,
4,55,232,203,0,184,4,63,232,197,0,195,184,5,102,232,
190,0,184,1,60,232,184,0,184,5,54,232,178,0,184,1,
60,232,172,0,184,5,58,232,166,0,184,5,44,232,160,0,
184,5,36,232,154,0,184,5,73,232,148,0,184,4,114,232,
142,0,195,184,27,50,232,135,0,184,30,72,232,129,0,184,
4,55,232,123,0,184,1,34,232,117,0,184,37,44,232,111,
0,184,32,90,232,105,0,184,4,74,232,99,0,184,34,80,
232,93,0,184,26,118,232,87,0,184,4,114,232,81,0,195,
184,28,66,232,74,0,184,27,92,232,68,0,184,4,55,232,
62,0,184,4,70,232,56,0,184,4,47,232,50,0,184,4,
64,232,44,0,184,4,53,232,38,0,184,4,36,232,32,0,
195,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,
144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,
171,12,128,171,195,145,73,145,240,130,181,130,189,151,204,136,
230,130,240,142,169,147,174,139,78,147,174,130,201,144,221,146,
232,130,181,130,220,130,183,130,169,129,105,130,120,129,94,130,
109,129,106,129,72,80,83,81,82,30,232,239,249,14,31,190,
101,24,191,126,14,185,48,0,232,152,249,180,0,205,24,139,
200,129,249,121,21,116,6,129,249,89,21,117,22,232,204,249,
232,241,251,31,90,89,91,88,177,128,138,234,38,137,79,250,
233,33,249,129,249,110,46,116,6,129,249,78,46,117,14,232,
170,249,232,207,251,31,90,89,91,88,233,78,249,31,90,89,
91,88,235,161,169,64,0,116,2,209,224,209,224,233,81,240,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\xm86.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    xm86.h

Abstract:

    This module contains the public header file that describes the
    interfaces to the 386/486 real mode emulator.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _XM86_
#define _XM86_

//
// Define internal error codes.
//

typedef enum _XM_STATUS {
    XM_SUCCESS = 1,
    XM_DIVIDE_BY_ZERO,
    XM_DIVIDE_QUOTIENT_OVERFLOW,
    XM_EMULATOR_NOT_INITIALIZED,
    XM_HALT_INSTRUCTION,
    XM_ILLEGAL_CODE_SEGMENT,
    XM_ILLEGAL_INDEX_SPECIFIER,
    XM_ILLEGAL_LEVEL_NUMBER,
    XM_ILLEGAL_PORT_NUMBER,
    XM_ILLEGAL_GENERAL_SPECIFIER,
    XM_ILLEGAL_REGISTER_SPECIFIER,
    XM_ILLEGAL_INSTRUCTION_OPCODE,
    XM_INDEX_OUT_OF_BOUNDS,
    XM_SEGMENT_LIMIT_VIOLATION,
    XM_STACK_OVERFLOW,
    XM_STACK_UNDERFLOW,
    XM_MAXIMUM_INTERNAL_CODE
} XM_STATUS;

//
// Define operand data types.
//

typedef enum _XM_OPERATION_DATATYPE {
    BYTE_DATA = 0,
    WORD_DATA = 1,
    LONG_DATA = 3
} XM_OPERATION_DATATYPE;

//
// Define emulator context structure.
//

typedef struct _XM86_CONTEXT {
    ULONG Eax;
    ULONG Ecx;
    ULONG Edx;
    ULONG Ebx;
    ULONG Ebp;
    ULONG Esi;
    ULONG Edi;
    USHORT SegDs;
    USHORT SegEs;
} XM86_CONTEXT, *PXM86_CONTEXT;

//
// Define address translation callback function type.
//

typedef
PVOID
(*PXM_TRANSLATE_ADDRESS) (
    IN USHORT Segment,
    IN USHORT Offset
    );

//
// Define read and write I/O space callback function types.
//

typedef
ULONG
(*PXM_READ_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    );

typedef
VOID
(*PXM_WRITE_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    );

//
// Define emulator public interface function prototypes.
//

XM_STATUS
XmEmulateFarCall (
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    );

XM_STATUS
XmEmulateInterrupt (
    IN UCHAR Interrupt,
    IN OUT PXM86_CONTEXT Context
    );

VOID
XmInitializeEmulator (
    IN USHORT StackSegment,
    IN USHORT StackOffset,
    IN PXM_READ_IO_SPACE ReadIoSpace,
    IN PXM_WRITE_IO_SPACE WriteIoSpace,
    IN PXM_TRANSLATE_ADDRESS TranslateAddress
    );

#endif // _XM86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\xactsrv2.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xactsrv.h

Abstract:

    Header file for XACTSRV.  Defines structures common to the server and
    XACTSRV.

Author:

    David Treadwell (davidtr) 07-Jan-1991

Revision History:

--*/

#ifndef _XACTSRV_
#define _XACTSRV_

//
// Structures for messages that are passed across the LPC port between
// the server and XACTSRV.
//
// *** The PORT_MESSAGE structure *must* be the first element of these
//     structures!

typedef struct _XACTSRV_REQUEST_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG MessageType;

    union {

        struct {
            struct _TRANSACTION *Transaction;
            WCHAR ClientMachineName[CNLEN + 1];
            UCHAR ServerName[ NETBIOS_NAME_LEN ];
            ULONG TransportNameLength;
            PWSTR TransportName;
            UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
            ULONG Flags;
        } DownLevelApi;

        struct {
            PSZ PrinterName;
        } OpenPrinter;

        struct {
            HANDLE hPrinter;
            PVOID Buffer;
            ULONG BufferLength;
            WCHAR ClientMachineName[CNLEN + 1];
        } AddPrintJob;

        struct {
            HANDLE hPrinter;
            ULONG JobId;
        } SchedulePrintJob;

        struct {
            HANDLE hPrinter;
        } ClosePrinter;

        struct {
            PSZ Receipient;
            PVOID Buffer;
            USHORT BufferLength;
        } MessageBufferSend;

        struct {
            PWSTR UserName;
            BOOL  IsAdmin;
        } LSRequest;

        struct {
            HANDLE hLicense;
        } LSRelease;

        struct {
            BOOLEAN Bind;
            UNICODE_STRING TransportName;
        } Pnp;
    
    } Message;


} XACTSRV_REQUEST_MESSAGE, *PXACTSRV_REQUEST_MESSAGE;

typedef struct _XACTSRV_REPLY_MESSAGE {

    PORT_MESSAGE PortMessage;

    union {

        struct {
            NTSTATUS Status;
        } DownLevelApi;

        struct {
            ULONG Error;
            HANDLE hPrinter;
        } OpenPrinter;

        struct {
            ULONG Error;
            USHORT BufferLength;
            ULONG JobId;
        } AddPrintJob;

        struct {
            ULONG Error;
        } SchedulePrintJob;

        struct {
            ULONG Error;
        } ClosePrinter;

        struct {
            ULONG Error;
        } MessageBufferSend;

        struct {
            NTSTATUS Status;
            HANDLE   hLicense;
        } LSRequest;

    } Message;

} XACTSRV_REPLY_MESSAGE, *PXACTSRV_REPLY_MESSAGE;

//
// Message types that can be sent to XACTSRV.
//

#define XACTSRV_MESSAGE_DOWN_LEVEL_API       0
#define XACTSRV_MESSAGE_OPEN_PRINTER         1
#define XACTSRV_MESSAGE_ADD_JOB_PRINTER      2
#define XACTSRV_MESSAGE_SCHD_JOB_PRINTER     4
#define XACTSRV_MESSAGE_CLOSE_PRINTER        5
#define XACTSRV_MESSAGE_MESSAGE_SEND         6
#define XACTSRV_MESSAGE_WAKEUP               7
#define XACTSRV_MESSAGE_LSREQUEST            8
#define XACTSRV_MESSAGE_LSRELEASE            9
#define XACTSRV_MESSAGE_PNP                 10

//
// Request Flags definitions
//

#define XS_FLAGS_NT_CLIENT                  0x00000001

#endif // ndef _XACTSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\activate.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for activate.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activate_h__
#define __activate_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISystemActivator_FWD_DEFINED__
#define __ISystemActivator_FWD_DEFINED__
typedef interface ISystemActivator ISystemActivator;
#endif 	/* __ISystemActivator_FWD_DEFINED__ */


#ifndef __IInitActivationPropertiesIn_FWD_DEFINED__
#define __IInitActivationPropertiesIn_FWD_DEFINED__
typedef interface IInitActivationPropertiesIn IInitActivationPropertiesIn;
#endif 	/* __IInitActivationPropertiesIn_FWD_DEFINED__ */


#ifndef __IActivationPropertiesIn_FWD_DEFINED__
#define __IActivationPropertiesIn_FWD_DEFINED__
typedef interface IActivationPropertiesIn IActivationPropertiesIn;
#endif 	/* __IActivationPropertiesIn_FWD_DEFINED__ */


#ifndef __IActivationPropertiesOut_FWD_DEFINED__
#define __IActivationPropertiesOut_FWD_DEFINED__
typedef interface IActivationPropertiesOut IActivationPropertiesOut;
#endif 	/* __IActivationPropertiesOut_FWD_DEFINED__ */


#ifndef __IActivationStageInfo_FWD_DEFINED__
#define __IActivationStageInfo_FWD_DEFINED__
typedef interface IActivationStageInfo IActivationStageInfo;
#endif 	/* __IActivationStageInfo_FWD_DEFINED__ */


#ifndef __IServerLocationInfo_FWD_DEFINED__
#define __IServerLocationInfo_FWD_DEFINED__
typedef interface IServerLocationInfo IServerLocationInfo;
#endif 	/* __IServerLocationInfo_FWD_DEFINED__ */


#ifndef __IActivationContextInfo_FWD_DEFINED__
#define __IActivationContextInfo_FWD_DEFINED__
typedef interface IActivationContextInfo IActivationContextInfo;
#endif 	/* __IActivationContextInfo_FWD_DEFINED__ */


#ifndef __IOverrideTargetContext_FWD_DEFINED__
#define __IOverrideTargetContext_FWD_DEFINED__
typedef interface IOverrideTargetContext IOverrideTargetContext;
#endif 	/* __IOverrideTargetContext_FWD_DEFINED__ */


#ifndef __IActivationSecurityInfo_FWD_DEFINED__
#define __IActivationSecurityInfo_FWD_DEFINED__
typedef interface IActivationSecurityInfo IActivationSecurityInfo;
#endif 	/* __IActivationSecurityInfo_FWD_DEFINED__ */


#ifndef __IActivationAgentInfo_FWD_DEFINED__
#define __IActivationAgentInfo_FWD_DEFINED__
typedef interface IActivationAgentInfo IActivationAgentInfo;
#endif 	/* __IActivationAgentInfo_FWD_DEFINED__ */


#ifndef __IEnumSCMProcessInfo_FWD_DEFINED__
#define __IEnumSCMProcessInfo_FWD_DEFINED__
typedef interface IEnumSCMProcessInfo IEnumSCMProcessInfo;
#endif 	/* __IEnumSCMProcessInfo_FWD_DEFINED__ */


#ifndef __ISCMProcessControl_FWD_DEFINED__
#define __ISCMProcessControl_FWD_DEFINED__
typedef interface ISCMProcessControl ISCMProcessControl;
#endif 	/* __ISCMProcessControl_FWD_DEFINED__ */


/* header files for imported files */
#include "obase.h"
#include "objidl.h"
#include "contxt.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_activate_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_activate_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0000_ServerIfHandle;

#ifndef __ISystemActivator_INTERFACE_DEFINED__
#define __ISystemActivator_INTERFACE_DEFINED__

/* interface ISystemActivator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISystemActivator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A0-0000-0000-C000-000000000046")
    ISystemActivator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassObject( 
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemActivatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISystemActivator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISystemActivator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISystemActivator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassObject )( 
            ISystemActivator * This,
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ISystemActivator * This,
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties);
        
        END_INTERFACE
    } ISystemActivatorVtbl;

    interface ISystemActivator
    {
        CONST_VTBL struct ISystemActivatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemActivator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISystemActivator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISystemActivator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISystemActivator_GetClassObject(This,pActProperties,ppActProperties)	\
    (This)->lpVtbl -> GetClassObject(This,pActProperties,ppActProperties)

#define ISystemActivator_CreateInstance(This,pUnkOuter,pActProperties,ppActProperties)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,pActProperties,ppActProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISystemActivator_GetClassObject_Proxy( 
    ISystemActivator * This,
    /* [unique][in] */ IActivationPropertiesIn *pActProperties,
    /* [out] */ IActivationPropertiesOut **ppActProperties);


void __RPC_STUB ISystemActivator_GetClassObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemActivator_CreateInstance_Proxy( 
    ISystemActivator * This,
    /* [unique][in] */ IUnknown *pUnkOuter,
    /* [unique][in] */ IActivationPropertiesIn *pActProperties,
    /* [out] */ IActivationPropertiesOut **ppActProperties);


void __RPC_STUB ISystemActivator_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISystemActivator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0116 */
/* [local] */ 

typedef 
enum tagACTIVATION_FLAGS
    {	ACTVFLAGS_NONE	= 0,
	ACTVFLAGS_WX86_CALLER	= 1,
	ACTVFLAGS_DISABLE_AAA	= 2
    } 	ACTIVATION_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_activate_0116_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0116_ServerIfHandle;

#ifndef __IInitActivationPropertiesIn_INTERFACE_DEFINED__
#define __IInitActivationPropertiesIn_INTERFACE_DEFINED__

/* interface IInitActivationPropertiesIn */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IInitActivationPropertiesIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A1-0000-0000-C000-000000000046")
    IInitActivationPropertiesIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClsctx( 
            /* [in] */ DWORD clsctx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivationFlags( 
            /* [in] */ DWORD actvflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassInfo( 
            /* [unique][in] */ IUnknown *pUnkClassInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextInfo( 
            /* [unique][in] */ IContext *pClientContext,
            /* [in] */ IContext *pPrototypeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConstructFromStorage( 
            /* [unique][in] */ IStorage *pStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConstructFromFile( 
            /* [in] */ WCHAR *wszFileName,
            /* [in] */ DWORD dwMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitActivationPropertiesInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitActivationPropertiesIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitActivationPropertiesIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClsctx )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ DWORD clsctx);
        
        HRESULT ( STDMETHODCALLTYPE *SetActivationFlags )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ DWORD actvflags);
        
        HRESULT ( STDMETHODCALLTYPE *SetClassInfo )( 
            IInitActivationPropertiesIn * This,
            /* [unique][in] */ IUnknown *pUnkClassInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextInfo )( 
            IInitActivationPropertiesIn * This,
            /* [unique][in] */ IContext *pClientContext,
            /* [in] */ IContext *pPrototypeContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetConstructFromStorage )( 
            IInitActivationPropertiesIn * This,
            /* [unique][in] */ IStorage *pStorage);
        
        HRESULT ( STDMETHODCALLTYPE *SetConstructFromFile )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ WCHAR *wszFileName,
            /* [in] */ DWORD dwMode);
        
        END_INTERFACE
    } IInitActivationPropertiesInVtbl;

    interface IInitActivationPropertiesIn
    {
        CONST_VTBL struct IInitActivationPropertiesInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitActivationPropertiesIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInitActivationPropertiesIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInitActivationPropertiesIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInitActivationPropertiesIn_SetClsctx(This,clsctx)	\
    (This)->lpVtbl -> SetClsctx(This,clsctx)

#define IInitActivationPropertiesIn_SetActivationFlags(This,actvflags)	\
    (This)->lpVtbl -> SetActivationFlags(This,actvflags)

#define IInitActivationPropertiesIn_SetClassInfo(This,pUnkClassInfo)	\
    (This)->lpVtbl -> SetClassInfo(This,pUnkClassInfo)

#define IInitActivationPropertiesIn_SetContextInfo(This,pClientContext,pPrototypeContext)	\
    (This)->lpVtbl -> SetContextInfo(This,pClientContext,pPrototypeContext)

#define IInitActivationPropertiesIn_SetConstructFromStorage(This,pStorage)	\
    (This)->lpVtbl -> SetConstructFromStorage(This,pStorage)

#define IInitActivationPropertiesIn_SetConstructFromFile(This,wszFileName,dwMode)	\
    (This)->lpVtbl -> SetConstructFromFile(This,wszFileName,dwMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetClsctx_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [in] */ DWORD clsctx);


void __RPC_STUB IInitActivationPropertiesIn_SetClsctx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetActivationFlags_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [in] */ DWORD actvflags);


void __RPC_STUB IInitActivationPropertiesIn_SetActivationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetClassInfo_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [unique][in] */ IUnknown *pUnkClassInfo);


void __RPC_STUB IInitActivationPropertiesIn_SetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetContextInfo_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [unique][in] */ IContext *pClientContext,
    /* [in] */ IContext *pPrototypeContext);


void __RPC_STUB IInitActivationPropertiesIn_SetContextInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetConstructFromStorage_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [unique][in] */ IStorage *pStorage);


void __RPC_STUB IInitActivationPropertiesIn_SetConstructFromStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetConstructFromFile_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [in] */ WCHAR *wszFileName,
    /* [in] */ DWORD dwMode);


void __RPC_STUB IInitActivationPropertiesIn_SetConstructFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitActivationPropertiesIn_INTERFACE_DEFINED__ */


#ifndef __IActivationPropertiesIn_INTERFACE_DEFINED__
#define __IActivationPropertiesIn_INTERFACE_DEFINED__

/* interface IActivationPropertiesIn */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationPropertiesIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A2-0000-0000-C000-000000000046")
    IActivationPropertiesIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivationID( 
            /* [out] */ GUID *pActivationID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClsctx( 
            /* [out] */ DWORD *pclsctx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationFlags( 
            /* [out] */ DWORD *pactvflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRequestedIIDs( 
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestedIIDs( 
            /* [out] */ ULONG *pulCount,
            /* [out] */ IID **prgIID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelegateGetClassObject( 
            /* [out] */ IActivationPropertiesOut **pActPropsOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelegateCreateInstance( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelegateCIAndGetCF( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut,
            /* [out] */ IClassFactory **ppCf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReturnActivationProperties( 
            /* [in] */ IUnknown *pUnk,
            /* [out] */ IActivationPropertiesOut **ppActOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationPropertiesInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationPropertiesIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationPropertiesIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IActivationPropertiesIn * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClsctx )( 
            IActivationPropertiesIn * This,
            /* [out] */ DWORD *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationFlags )( 
            IActivationPropertiesIn * This,
            /* [out] */ DWORD *pactvflags);
        
        HRESULT ( STDMETHODCALLTYPE *AddRequestedIIDs )( 
            IActivationPropertiesIn * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestedIIDs )( 
            IActivationPropertiesIn * This,
            /* [out] */ ULONG *pulCount,
            /* [out] */ IID **prgIID);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateGetClassObject )( 
            IActivationPropertiesIn * This,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCreateInstance )( 
            IActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCIAndGetCF )( 
            IActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut,
            /* [out] */ IClassFactory **ppCf);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnActivationProperties )( 
            IActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnk,
            /* [out] */ IActivationPropertiesOut **ppActOut);
        
        END_INTERFACE
    } IActivationPropertiesInVtbl;

    interface IActivationPropertiesIn
    {
        CONST_VTBL struct IActivationPropertiesInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationPropertiesIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationPropertiesIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationPropertiesIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationPropertiesIn_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IActivationPropertiesIn_GetClassInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,riid,ppv)

#define IActivationPropertiesIn_GetClsctx(This,pclsctx)	\
    (This)->lpVtbl -> GetClsctx(This,pclsctx)

#define IActivationPropertiesIn_GetActivationFlags(This,pactvflags)	\
    (This)->lpVtbl -> GetActivationFlags(This,pactvflags)

#define IActivationPropertiesIn_AddRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> AddRequestedIIDs(This,cIfs,rgIID)

#define IActivationPropertiesIn_GetRequestedIIDs(This,pulCount,prgIID)	\
    (This)->lpVtbl -> GetRequestedIIDs(This,pulCount,prgIID)

#define IActivationPropertiesIn_DelegateGetClassObject(This,pActPropsOut)	\
    (This)->lpVtbl -> DelegateGetClassObject(This,pActPropsOut)

#define IActivationPropertiesIn_DelegateCreateInstance(This,pUnkOuter,pActPropsOut)	\
    (This)->lpVtbl -> DelegateCreateInstance(This,pUnkOuter,pActPropsOut)

#define IActivationPropertiesIn_DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)	\
    (This)->lpVtbl -> DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)

#define IActivationPropertiesIn_GetReturnActivationProperties(This,pUnk,ppActOut)	\
    (This)->lpVtbl -> GetReturnActivationProperties(This,pUnk,ppActOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetActivationID_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ GUID *pActivationID);


void __RPC_STUB IActivationPropertiesIn_GetActivationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetClassInfo_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IActivationPropertiesIn_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetClsctx_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ DWORD *pclsctx);


void __RPC_STUB IActivationPropertiesIn_GetClsctx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetActivationFlags_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ DWORD *pactvflags);


void __RPC_STUB IActivationPropertiesIn_GetActivationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_AddRequestedIIDs_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ DWORD cIfs,
    /* [size_is][in] */ IID *rgIID);


void __RPC_STUB IActivationPropertiesIn_AddRequestedIIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetRequestedIIDs_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ ULONG *pulCount,
    /* [out] */ IID **prgIID);


void __RPC_STUB IActivationPropertiesIn_GetRequestedIIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_DelegateGetClassObject_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ IActivationPropertiesOut **pActPropsOut);


void __RPC_STUB IActivationPropertiesIn_DelegateGetClassObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_DelegateCreateInstance_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [out] */ IActivationPropertiesOut **pActPropsOut);


void __RPC_STUB IActivationPropertiesIn_DelegateCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_DelegateCIAndGetCF_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [out] */ IActivationPropertiesOut **pActPropsOut,
    /* [out] */ IClassFactory **ppCf);


void __RPC_STUB IActivationPropertiesIn_DelegateCIAndGetCF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetReturnActivationProperties_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ IUnknown *pUnk,
    /* [out] */ IActivationPropertiesOut **ppActOut);


void __RPC_STUB IActivationPropertiesIn_GetReturnActivationProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationPropertiesIn_INTERFACE_DEFINED__ */


#ifndef __IActivationPropertiesOut_INTERFACE_DEFINED__
#define __IActivationPropertiesOut_INTERFACE_DEFINED__

/* interface IActivationPropertiesOut */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationPropertiesOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A3-0000-0000-C000-000000000046")
    IActivationPropertiesOut : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivationID( 
            /* [out] */ GUID *pActivationID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectInterface( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD actvflags,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectInterfaces( 
            /* [in] */ DWORD cIfs,
            /* [in] */ DWORD actvflags,
            /* [size_is][in] */ MULTI_QI *multiQi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRequestedIIDs( 
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationPropertiesOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationPropertiesOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationPropertiesOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IActivationPropertiesOut * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterface )( 
            IActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD actvflags,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterfaces )( 
            IActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ DWORD actvflags,
            /* [size_is][in] */ MULTI_QI *multiQi);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRequestedIIDs )( 
            IActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        END_INTERFACE
    } IActivationPropertiesOutVtbl;

    interface IActivationPropertiesOut
    {
        CONST_VTBL struct IActivationPropertiesOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationPropertiesOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationPropertiesOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationPropertiesOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationPropertiesOut_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IActivationPropertiesOut_GetObjectInterface(This,riid,actvflags,ppv)	\
    (This)->lpVtbl -> GetObjectInterface(This,riid,actvflags,ppv)

#define IActivationPropertiesOut_GetObjectInterfaces(This,cIfs,actvflags,multiQi)	\
    (This)->lpVtbl -> GetObjectInterfaces(This,cIfs,actvflags,multiQi)

#define IActivationPropertiesOut_RemoveRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> RemoveRequestedIIDs(This,cIfs,rgIID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_GetActivationID_Proxy( 
    IActivationPropertiesOut * This,
    /* [out] */ GUID *pActivationID);


void __RPC_STUB IActivationPropertiesOut_GetActivationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_GetObjectInterface_Proxy( 
    IActivationPropertiesOut * This,
    /* [in] */ REFIID riid,
    /* [in] */ DWORD actvflags,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IActivationPropertiesOut_GetObjectInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_GetObjectInterfaces_Proxy( 
    IActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [in] */ DWORD actvflags,
    /* [size_is][in] */ MULTI_QI *multiQi);


void __RPC_STUB IActivationPropertiesOut_GetObjectInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_RemoveRequestedIIDs_Proxy( 
    IActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [size_is][in] */ IID *rgIID);


void __RPC_STUB IActivationPropertiesOut_RemoveRequestedIIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationPropertiesOut_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0119 */
/* [local] */ 

typedef 
enum tagACTIVATION_STAGE
    {	CLIENT_CONTEXT_STAGE	= 1,
	CLIENT_MACHINE_STAGE	= 2,
	SERVER_MACHINE_STAGE	= 3,
	SERVER_PROCESS_STAGE	= 4,
	SERVER_CONTEXT_STAGE	= 5
    } 	ACTIVATION_STAGE;



extern RPC_IF_HANDLE __MIDL_itf_activate_0119_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0119_ServerIfHandle;

#ifndef __IActivationStageInfo_INTERFACE_DEFINED__
#define __IActivationStageInfo_INTERFACE_DEFINED__

/* interface IActivationStageInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActivationStageInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A8-0000-0000-C000-000000000046")
    IActivationStageInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStageAndIndex( 
            /* [in] */ ACTIVATION_STAGE stage,
            /* [in] */ int index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStage( 
            /* [out] */ ACTIVATION_STAGE *pstage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [out] */ int *pindex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationStageInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationStageInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationStageInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationStageInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStageAndIndex )( 
            IActivationStageInfo * This,
            /* [in] */ ACTIVATION_STAGE stage,
            /* [in] */ int index);
        
        HRESULT ( STDMETHODCALLTYPE *GetStage )( 
            IActivationStageInfo * This,
            /* [out] */ ACTIVATION_STAGE *pstage);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            IActivationStageInfo * This,
            /* [out] */ int *pindex);
        
        END_INTERFACE
    } IActivationStageInfoVtbl;

    interface IActivationStageInfo
    {
        CONST_VTBL struct IActivationStageInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationStageInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationStageInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationStageInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationStageInfo_SetStageAndIndex(This,stage,index)	\
    (This)->lpVtbl -> SetStageAndIndex(This,stage,index)

#define IActivationStageInfo_GetStage(This,pstage)	\
    (This)->lpVtbl -> GetStage(This,pstage)

#define IActivationStageInfo_GetIndex(This,pindex)	\
    (This)->lpVtbl -> GetIndex(This,pindex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationStageInfo_SetStageAndIndex_Proxy( 
    IActivationStageInfo * This,
    /* [in] */ ACTIVATION_STAGE stage,
    /* [in] */ int index);


void __RPC_STUB IActivationStageInfo_SetStageAndIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationStageInfo_GetStage_Proxy( 
    IActivationStageInfo * This,
    /* [out] */ ACTIVATION_STAGE *pstage);


void __RPC_STUB IActivationStageInfo_GetStage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationStageInfo_GetIndex_Proxy( 
    IActivationStageInfo * This,
    /* [out] */ int *pindex);


void __RPC_STUB IActivationStageInfo_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationStageInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0120 */
/* [local] */ 

typedef 
enum _PRT
    {	PRT_IGNORE	= 0,
	PRT_CREATE_NEW	= 1,
	PRT_USE_THIS	= 2,
	PRT_USE_THIS_ONLY	= 3
    } 	PROCESS_REQUEST_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_activate_0120_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0120_ServerIfHandle;

#ifndef __IServerLocationInfo_INTERFACE_DEFINED__
#define __IServerLocationInfo_INTERFACE_DEFINED__

/* interface IServerLocationInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IServerLocationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A4-0000-0000-C000-000000000046")
    IServerLocationInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRemoteServerName( 
            /* [unique][string][in] */ WCHAR *pswzMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteServerName( 
            /* [string][out] */ WCHAR **pswzMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProcess( 
            /* [in] */ DWORD pid,
            DWORD dwPRT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ DWORD *ppid,
            DWORD *pdwPRT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetApartment( 
            /* [in] */ APTID apartmentId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApartment( 
            /* [out] */ APTID *pApartmentId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ IObjContext *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ IObjContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerLocationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServerLocationInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServerLocationInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServerLocationInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteServerName )( 
            IServerLocationInfo * This,
            /* [unique][string][in] */ WCHAR *pswzMachineName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IServerLocationInfo * This,
            /* [string][out] */ WCHAR **pswzMachineName);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcess )( 
            IServerLocationInfo * This,
            /* [in] */ DWORD pid,
            DWORD dwPRT);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            IServerLocationInfo * This,
            /* [out] */ DWORD *ppid,
            DWORD *pdwPRT);
        
        HRESULT ( STDMETHODCALLTYPE *SetApartment )( 
            IServerLocationInfo * This,
            /* [in] */ APTID apartmentId);
        
        HRESULT ( STDMETHODCALLTYPE *GetApartment )( 
            IServerLocationInfo * This,
            /* [out] */ APTID *pApartmentId);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IServerLocationInfo * This,
            /* [in] */ IObjContext *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IServerLocationInfo * This,
            /* [out] */ IObjContext **ppContext);
        
        END_INTERFACE
    } IServerLocationInfoVtbl;

    interface IServerLocationInfo
    {
        CONST_VTBL struct IServerLocationInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerLocationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerLocationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerLocationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerLocationInfo_SetRemoteServerName(This,pswzMachineName)	\
    (This)->lpVtbl -> SetRemoteServerName(This,pswzMachineName)

#define IServerLocationInfo_GetRemoteServerName(This,pswzMachineName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pswzMachineName)

#define IServerLocationInfo_SetProcess(This,pid,dwPRT)	\
    (This)->lpVtbl -> SetProcess(This,pid,dwPRT)

#define IServerLocationInfo_GetProcess(This,ppid,pdwPRT)	\
    (This)->lpVtbl -> GetProcess(This,ppid,pdwPRT)

#define IServerLocationInfo_SetApartment(This,apartmentId)	\
    (This)->lpVtbl -> SetApartment(This,apartmentId)

#define IServerLocationInfo_GetApartment(This,pApartmentId)	\
    (This)->lpVtbl -> GetApartment(This,pApartmentId)

#define IServerLocationInfo_SetContext(This,pContext)	\
    (This)->lpVtbl -> SetContext(This,pContext)

#define IServerLocationInfo_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetRemoteServerName_Proxy( 
    IServerLocationInfo * This,
    /* [unique][string][in] */ WCHAR *pswzMachineName);


void __RPC_STUB IServerLocationInfo_SetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetRemoteServerName_Proxy( 
    IServerLocationInfo * This,
    /* [string][out] */ WCHAR **pswzMachineName);


void __RPC_STUB IServerLocationInfo_GetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetProcess_Proxy( 
    IServerLocationInfo * This,
    /* [in] */ DWORD pid,
    DWORD dwPRT);


void __RPC_STUB IServerLocationInfo_SetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetProcess_Proxy( 
    IServerLocationInfo * This,
    /* [out] */ DWORD *ppid,
    DWORD *pdwPRT);


void __RPC_STUB IServerLocationInfo_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetApartment_Proxy( 
    IServerLocationInfo * This,
    /* [in] */ APTID apartmentId);


void __RPC_STUB IServerLocationInfo_SetApartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetApartment_Proxy( 
    IServerLocationInfo * This,
    /* [out] */ APTID *pApartmentId);


void __RPC_STUB IServerLocationInfo_GetApartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetContext_Proxy( 
    IServerLocationInfo * This,
    /* [in] */ IObjContext *pContext);


void __RPC_STUB IServerLocationInfo_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetContext_Proxy( 
    IServerLocationInfo * This,
    /* [out] */ IObjContext **ppContext);


void __RPC_STUB IServerLocationInfo_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerLocationInfo_INTERFACE_DEFINED__ */


#ifndef __IActivationContextInfo_INTERFACE_DEFINED__
#define __IActivationContextInfo_INTERFACE_DEFINED__

/* interface IActivationContextInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationContextInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A5-0000-0000-C000-000000000046")
    IActivationContextInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientContext( 
            /* [out] */ IContext **ppClientContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrototypeContext( 
            /* [out] */ IContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClientContextOK( 
            /* [out] */ BOOL *fYes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientContextNotOK( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationContextInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationContextInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationContextInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientContext )( 
            IActivationContextInfo * This,
            /* [out] */ IContext **ppClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrototypeContext )( 
            IActivationContextInfo * This,
            /* [out] */ IContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsClientContextOK )( 
            IActivationContextInfo * This,
            /* [out] */ BOOL *fYes);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientContextNotOK )( 
            IActivationContextInfo * This);
        
        END_INTERFACE
    } IActivationContextInfoVtbl;

    interface IActivationContextInfo
    {
        CONST_VTBL struct IActivationContextInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationContextInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationContextInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationContextInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationContextInfo_GetClientContext(This,ppClientContext)	\
    (This)->lpVtbl -> GetClientContext(This,ppClientContext)

#define IActivationContextInfo_GetPrototypeContext(This,ppContext)	\
    (This)->lpVtbl -> GetPrototypeContext(This,ppContext)

#define IActivationContextInfo_IsClientContextOK(This,fYes)	\
    (This)->lpVtbl -> IsClientContextOK(This,fYes)

#define IActivationContextInfo_SetClientContextNotOK(This)	\
    (This)->lpVtbl -> SetClientContextNotOK(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationContextInfo_GetClientContext_Proxy( 
    IActivationContextInfo * This,
    /* [out] */ IContext **ppClientContext);


void __RPC_STUB IActivationContextInfo_GetClientContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationContextInfo_GetPrototypeContext_Proxy( 
    IActivationContextInfo * This,
    /* [out] */ IContext **ppContext);


void __RPC_STUB IActivationContextInfo_GetPrototypeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationContextInfo_IsClientContextOK_Proxy( 
    IActivationContextInfo * This,
    /* [out] */ BOOL *fYes);


void __RPC_STUB IActivationContextInfo_IsClientContextOK_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationContextInfo_SetClientContextNotOK_Proxy( 
    IActivationContextInfo * This);


void __RPC_STUB IActivationContextInfo_SetClientContextNotOK_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationContextInfo_INTERFACE_DEFINED__ */


#ifndef __IOverrideTargetContext_INTERFACE_DEFINED__
#define __IOverrideTargetContext_INTERFACE_DEFINED__

/* interface IOverrideTargetContext */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverrideTargetContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001BA-0000-0000-C000-000000000046")
    IOverrideTargetContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OverrideTargetContext( 
            /* [in] */ REFGUID guidTargetCtxtId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverrideTargetContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverrideTargetContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverrideTargetContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverrideTargetContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *OverrideTargetContext )( 
            IOverrideTargetContext * This,
            /* [in] */ REFGUID guidTargetCtxtId);
        
        END_INTERFACE
    } IOverrideTargetContextVtbl;

    interface IOverrideTargetContext
    {
        CONST_VTBL struct IOverrideTargetContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverrideTargetContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOverrideTargetContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOverrideTargetContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOverrideTargetContext_OverrideTargetContext(This,guidTargetCtxtId)	\
    (This)->lpVtbl -> OverrideTargetContext(This,guidTargetCtxtId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOverrideTargetContext_OverrideTargetContext_Proxy( 
    IOverrideTargetContext * This,
    /* [in] */ REFGUID guidTargetCtxtId);


void __RPC_STUB IOverrideTargetContext_OverrideTargetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOverrideTargetContext_INTERFACE_DEFINED__ */


#ifndef __IActivationSecurityInfo_INTERFACE_DEFINED__
#define __IActivationSecurityInfo_INTERFACE_DEFINED__

/* interface IActivationSecurityInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationSecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A6-0000-0000-C000-000000000046")
    IActivationSecurityInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAuthnFlags( 
            /* [in] */ DWORD dwAuthnFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthnFlags( 
            /* [out] */ DWORD *pdwAuthnFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthnSvc( 
            /* [in] */ DWORD dwAuthnSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthnSvc( 
            /* [out] */ DWORD *pdwAuthnSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthzSvc( 
            /* [in] */ DWORD dwAuthzSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthzSvc( 
            /* [out] */ DWORD *pdwAuthzSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthnLevel( 
            /* [in] */ DWORD dwAuthnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthnLevel( 
            /* [out] */ DWORD *pdwAuthnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImpLevel( 
            /* [in] */ DWORD dwImpLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImpLevel( 
            /* [out] */ DWORD *pdwImpLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCapabilities( 
            /* [in] */ DWORD dwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pdwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthIdentity( 
            /* [unique][in] */ COAUTHIDENTITY *pAuthIdentityData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthIdentity( 
            /* [out] */ COAUTHIDENTITY **pAuthIdentityData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServerPrincipalName( 
            /* [unique][in] */ WCHAR *pwszServerPrincName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerPrincipalName( 
            /* [out] */ WCHAR **pwszServerPrincName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationSecurityInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationSecurityInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationSecurityInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationSecurityInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthnFlags )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthnFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthnFlags )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthnFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthnSvc )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthnSvc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthnSvc )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthnSvc);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthzSvc )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthzSvc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthzSvc )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthzSvc);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthnLevel )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthnLevel )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetImpLevel )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpLevel )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetCapabilities )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthIdentity )( 
            IActivationSecurityInfo * This,
            /* [unique][in] */ COAUTHIDENTITY *pAuthIdentityData);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthIdentity )( 
            IActivationSecurityInfo * This,
            /* [out] */ COAUTHIDENTITY **pAuthIdentityData);
        
        HRESULT ( STDMETHODCALLTYPE *SetServerPrincipalName )( 
            IActivationSecurityInfo * This,
            /* [unique][in] */ WCHAR *pwszServerPrincName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerPrincipalName )( 
            IActivationSecurityInfo * This,
            /* [out] */ WCHAR **pwszServerPrincName);
        
        END_INTERFACE
    } IActivationSecurityInfoVtbl;

    interface IActivationSecurityInfo
    {
        CONST_VTBL struct IActivationSecurityInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationSecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationSecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationSecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationSecurityInfo_SetAuthnFlags(This,dwAuthnFlags)	\
    (This)->lpVtbl -> SetAuthnFlags(This,dwAuthnFlags)

#define IActivationSecurityInfo_GetAuthnFlags(This,pdwAuthnFlags)	\
    (This)->lpVtbl -> GetAuthnFlags(This,pdwAuthnFlags)

#define IActivationSecurityInfo_SetAuthnSvc(This,dwAuthnSvc)	\
    (This)->lpVtbl -> SetAuthnSvc(This,dwAuthnSvc)

#define IActivationSecurityInfo_GetAuthnSvc(This,pdwAuthnSvc)	\
    (This)->lpVtbl -> GetAuthnSvc(This,pdwAuthnSvc)

#define IActivationSecurityInfo_SetAuthzSvc(This,dwAuthzSvc)	\
    (This)->lpVtbl -> SetAuthzSvc(This,dwAuthzSvc)

#define IActivationSecurityInfo_GetAuthzSvc(This,pdwAuthzSvc)	\
    (This)->lpVtbl -> GetAuthzSvc(This,pdwAuthzSvc)

#define IActivationSecurityInfo_SetAuthnLevel(This,dwAuthnLevel)	\
    (This)->lpVtbl -> SetAuthnLevel(This,dwAuthnLevel)

#define IActivationSecurityInfo_GetAuthnLevel(This,pdwAuthnLevel)	\
    (This)->lpVtbl -> GetAuthnLevel(This,pdwAuthnLevel)

#define IActivationSecurityInfo_SetImpLevel(This,dwImpLevel)	\
    (This)->lpVtbl -> SetImpLevel(This,dwImpLevel)

#define IActivationSecurityInfo_GetImpLevel(This,pdwImpLevel)	\
    (This)->lpVtbl -> GetImpLevel(This,pdwImpLevel)

#define IActivationSecurityInfo_SetCapabilities(This,dwCapabilities)	\
    (This)->lpVtbl -> SetCapabilities(This,dwCapabilities)

#define IActivationSecurityInfo_GetCapabilities(This,pdwCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities)

#define IActivationSecurityInfo_SetAuthIdentity(This,pAuthIdentityData)	\
    (This)->lpVtbl -> SetAuthIdentity(This,pAuthIdentityData)

#define IActivationSecurityInfo_GetAuthIdentity(This,pAuthIdentityData)	\
    (This)->lpVtbl -> GetAuthIdentity(This,pAuthIdentityData)

#define IActivationSecurityInfo_SetServerPrincipalName(This,pwszServerPrincName)	\
    (This)->lpVtbl -> SetServerPrincipalName(This,pwszServerPrincName)

#define IActivationSecurityInfo_GetServerPrincipalName(This,pwszServerPrincName)	\
    (This)->lpVtbl -> GetServerPrincipalName(This,pwszServerPrincName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthnFlags_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthnFlags);


void __RPC_STUB IActivationSecurityInfo_SetAuthnFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthnFlags_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthnFlags);


void __RPC_STUB IActivationSecurityInfo_GetAuthnFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthnSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthnSvc);


void __RPC_STUB IActivationSecurityInfo_SetAuthnSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthnSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthnSvc);


void __RPC_STUB IActivationSecurityInfo_GetAuthnSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthzSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthzSvc);


void __RPC_STUB IActivationSecurityInfo_SetAuthzSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthzSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthzSvc);


void __RPC_STUB IActivationSecurityInfo_GetAuthzSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthnLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthnLevel);


void __RPC_STUB IActivationSecurityInfo_SetAuthnLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthnLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthnLevel);


void __RPC_STUB IActivationSecurityInfo_GetAuthnLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetImpLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwImpLevel);


void __RPC_STUB IActivationSecurityInfo_SetImpLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetImpLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwImpLevel);


void __RPC_STUB IActivationSecurityInfo_GetImpLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetCapabilities_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwCapabilities);


void __RPC_STUB IActivationSecurityInfo_SetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetCapabilities_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwCapabilities);


void __RPC_STUB IActivationSecurityInfo_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthIdentity_Proxy( 
    IActivationSecurityInfo * This,
    /* [unique][in] */ COAUTHIDENTITY *pAuthIdentityData);


void __RPC_STUB IActivationSecurityInfo_SetAuthIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthIdentity_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ COAUTHIDENTITY **pAuthIdentityData);


void __RPC_STUB IActivationSecurityInfo_GetAuthIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetServerPrincipalName_Proxy( 
    IActivationSecurityInfo * This,
    /* [unique][in] */ WCHAR *pwszServerPrincName);


void __RPC_STUB IActivationSecurityInfo_SetServerPrincipalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetServerPrincipalName_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ WCHAR **pwszServerPrincName);


void __RPC_STUB IActivationSecurityInfo_GetServerPrincipalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationSecurityInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0124 */
/* [local] */ 

typedef LONG *PSIDLIST;



extern RPC_IF_HANDLE __MIDL_itf_activate_0124_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0124_ServerIfHandle;

#ifndef __IActivationAgentInfo_INTERFACE_DEFINED__
#define __IActivationAgentInfo_INTERFACE_DEFINED__

/* interface IActivationAgentInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActivationAgentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A7-0000-0000-C000-000000000046")
    IActivationAgentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddActivationAgent( 
            /* [in] */ PSIDLIST pSidList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationAgentCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationAgents( 
            /* [out] */ PSIDLIST **prgSidList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationAgentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationAgentInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationAgentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationAgentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddActivationAgent )( 
            IActivationAgentInfo * This,
            /* [in] */ PSIDLIST pSidList);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationAgentCount )( 
            IActivationAgentInfo * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationAgents )( 
            IActivationAgentInfo * This,
            /* [out] */ PSIDLIST **prgSidList);
        
        END_INTERFACE
    } IActivationAgentInfoVtbl;

    interface IActivationAgentInfo
    {
        CONST_VTBL struct IActivationAgentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationAgentInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationAgentInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationAgentInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationAgentInfo_AddActivationAgent(This,pSidList)	\
    (This)->lpVtbl -> AddActivationAgent(This,pSidList)

#define IActivationAgentInfo_GetActivationAgentCount(This,pulCount)	\
    (This)->lpVtbl -> GetActivationAgentCount(This,pulCount)

#define IA