                           &ErrorInfo,
                                         xErrorInfo.GetPPointer() );

        // Post IErrorInfo only if we have a valid pointer to it.

        if ( SUCCEEDED( hr2 ) && !xErrorInfo.IsNull() )
            hr = ErrorInfo.hrError;

        return hr;
    }

    // Create an accessor, so data can be retrieved from the rowset.

    XInterface<IAccessor> xIAccessor;
    hr = xIRowset->QueryInterface( IID_IAccessor,
                                   xIAccessor.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Count the number of output columns and make bindings for them.

    ULONG cColumns = 1;
    WCHAR const *pwc = pwcColumns;
    while ( 0 != *pwc )
    {
        if ( L',' == *pwc )
            cColumns++;
        pwc++;
    }

    // Column iOrdinals are parallel with those passed to CiTextToFullTree,
    // so MapColumnIDs isn't necessary.  These binding values for dwPart,
    // dwMemOwner, and wType are the most optimal bindings for Indexing
    // Service.

    XPtr<DBBINDING> xBindings( cColumns );
    if ( xBindings.IsNull() )
        return E_OUTOFMEMORY;

    memset( xBindings.Get(), 0, sizeof DBBINDING * cColumns );

    for ( ULONG i = 0; i < cColumns; i++ )
    {
        xBindings[i].iOrdinal   = 1 + i; // 1-based column number
        xBindings[i].obValue    = i * sizeof( PROPVARIANT * ); // offset
        xBindings[i].dwPart     = DBPART_VALUE; // retrieve value, not status
        xBindings[i].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // provider owned
        xBindings[i].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT *
    }

    HACCESSOR hAccessor;
    hr = xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor
                                     cColumns,           // # of columns
                                     xBindings.Get(),    // columns
                                     0,                  // ignored
                                     &hAccessor,         // result
                                     0 );                // no status
    if ( FAILED( hr ) )
        return hr;

    DBORDINAL iPathColumn = ~0;

    if ( fSearchHit )
    {
        const DBID dbcolPath =  { PSGUID_STORAGE,
                                  DBKIND_GUID_PROPID,
                                  (LPWSTR) (ULONG_PTR) PID_STG_PATH };

        XInterface<IColumnsInfo> xColInfo;

        hr = xIRowset->QueryInterface( IID_IColumnsInfo, xColInfo.GetQIPointer() );
        if ( FAILED( hr ) )
            return hr;

        hr = xColInfo->MapColumnIDs( 1,
                                     & dbcolPath,
                                     & iPathColumn );

        if ( FAILED( hr ) )
            return hr;

        // Change from 1-based to 0-based.

        iPathColumn--;
    }

    // Display the results of the query.

    XPtr<PROPVARIANT *> xData( cColumns );
    if ( xData.IsNull() )
        hr = E_OUTOFMEMORY;
    else
    {
        DBCOUNTITEM cRowsSoFar = 0;

        do
        {
            DBCOUNTITEM cRowsReturned = 0;
            const ULONG cRowsAtATime = 20;
            HROW aHRow[cRowsAtATime];
            HROW * pgrHRows = aHRow;
            hr = xIRowset->GetNextRows( 0,              // no chapter
                                        0,              // no rows to skip
                                        cRowsAtATime,   // # rows to get
                                        &cRowsReturned, // # rows returned
                                        &pgrHRows);     // resulting hrows
            if ( FAILED( hr ) )
                break;

            for ( DBCOUNTITEM iRow = 0; iRow < cRowsReturned; iRow++ )
            {
                HRESULT hr2 = xIRowset->GetData( aHRow[iRow],   // hrow being accessed
                                                 hAccessor,     // accessor to use
                                                 xData.Get() ); // resulting data
                if ( FAILED( hr2 ) )
                {
                    hr = hr2;
                    break;
                }

                if ( ( 1 != cColumns ) || !fSearchHit )
                {
                    for ( ULONG iCol = 0; iCol < cColumns; iCol++ )
                    {
                        if ( 0 != iCol )
                            wprintf( L"  " );
                        DisplayValue( xData[ iCol ] );
                    }

                    wprintf( L"\n" );
                }


                if ( fSearchHit )
                {
                    PROPVARIANT * pPropVar = xData[ (unsigned int)iPathColumn ];
                    if ( ( VT_LPWSTR == pPropVar->vt ) &&
                         ( 0 != pPropVar->pwszVal ) )
                    {
                        DoISearch( pwcQueryRestriction,
                                   pPropVar->pwszVal,
                                   ( 1 == cColumns ),
                                   fDefineCPP,
                                   lcid );
                    }
                }
            }

            // Release the HROWs retrived in GetNextRows

            if ( 0 != cRowsReturned )
            {
                cRowsSoFar += cRowsReturned;
                xIRowset->ReleaseRows( cRowsReturned, // # of rows to release
                                       aHRow,         // rows to release
                                       0,             // no options
                                       0,             // no refcounts
                                       0 );           // no status
            }

            // Check if all rows are now retrieved.

            if ( DB_S_ENDOFROWSET == hr || DB_S_ROWLIMITEXCEEDED == hr )
            {
                hr = S_OK; // succeeded, return S_OK from DoQuery
                break;
            }

            // Check if the query aborted because it was too costly.

            if ( DB_S_STOPLIMITREACHED == hr )
            {
                CResString str( IDS_QUERYTIMEDOUT );
                wprintf( L"%ws\n", str.Get() );
                hr = S_OK;
                break;
            }

            if ( FAILED( hr ) )
                break;
        } while ( TRUE );

        if ( !fQuiet )
        {
            CResString str( IDS_QUERYDONE );
            wprintf( str.Get(), cRowsSoFar, pwcQueryRestriction );
        }
    }

    xIAccessor->ReleaseAccessor( hAccessor, 0 );

    // Get query status information

    if ( SUCCEEDED( hr ) && !fQuiet )
        hr = DisplayRowsetStatus( xIRowset );

    return hr;
} //IssueQuery

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Issues a query and displays an error message on failure
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcQueryRestrition]    - The actual query string
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [fSearchHit]            - if TRUE invoke isrchdmp.exe
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [fFirstHits]            - TRUE for first N or FALSE for best N
//              [lcid]                  - Locale for the query
//              [fDefineCPP]            - TRUE to define func and class props
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    WCHAR const * pwcScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcRestriction,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    BOOL          fSearchHit,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    BOOL          fFirstHits,
    LCID          lcid,
    BOOL          fDefineCPP )
{
    HRESULT hr = IssueQuery( pwcCatalog,
                             pwcMachine,
                             pwcScope,
                             dwScopeFlags,
                             pwcRestriction,
                             pwcColumns,
                             pwcSort,
                             fDisplayTree,
                             fQuiet,
                             fForceUseContentIndex,
                             fNoQuery,
                             fSearchHit,
                             ulDialect,
                             cMaxHits,
                             fFirstHits,
                             lcid,
                             fDefineCPP );

    if ( FAILED( hr ) )
        DisplayError( IDS_QUERYFAILED, pwcRestriction, hr, lcid );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   DoQueryFile
//
//  Synopsis:   Issues each query in the specified query file.  A query file
//              is just a text file where each line contains a query.
//
//  Arguments:  [pwcQueryCatalog]       - Catalog name over which query is run
//              [pwcQueryMachine]       - Machine name on which query is run
//              [pwcQueryScope]         - Scope of the query
//              [dwScopeFlags]          - Scope flags
//              [pwcColumns]            - Output column names
//              [pwcSort]               - Sort order names, may be 0
//              [fDisplayTree]          - TRUE to display the command tree
//              [fQuiet]                - if TRUE, don't display hitcount
//              [fForceUseContentIndex] - TRUE to always use index
//                                        FALSE to allow directory enumeration
//              [fNoQuery]              - if TRUE, just parse and display query
//              [fSearchHit]            - if TRUE invoke isrchdmp.exe
//              [ulDialect]             - Query dialect (1 or 2)
//              [cMaxHits]              - Maximum # of hits, or 0 for no limit
//              [fFirstHits]            - TRUE for first N or FALSE for best N
//              [lcid]                  - Locale for the query
//              [pwcQueryFile]          - File containing queries, 1 per line
//              [fDefineCPP]            - TRUE to define func and class props
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQueryFile(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryScope,
    DWORD         dwScopeFlags,
    WCHAR const * pwcColumns,
    WCHAR const * pwcSort,
    BOOL          fDisplayTree,
    BOOL          fQuiet,
    BOOL          fForceUseContentIndex,
    BOOL          fNoQuery,
    BOOL          fSearchHit,
    ULONG         ulDialect,
    ULONG         cMaxHits,
    BOOL          fFirstHits,
    LCID          lcid,
    WCHAR const * pwcQueryFile,
    BOOL          fDefineCPP )
{
    // Open and read the query file

    HANDLE hFile = CreateFile( pwcQueryFile,
                               FILE_GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_DELETE,
                               0,
                               OPEN_EXISTING,
                               0,
                               0 );

    if ( 0 == hFile || INVALID_HANDLE_VALUE == hFile )
        return DisplayWin32Error( IDS_CANTOPENFILE,
                                  pwcQueryFile,
                                  lcid );

    DWORD cbFile = GetFileSize( hFile, 0 );

    if ( 0xffffffff == cbFile )
    {
        CloseHandle( hFile );
        return DisplayWin32Error( IDS_CANTGETFILESIZE,
                                  pwcQueryFile,
                                  lcid );
    }

    // Allocate a buffer for the file

    XPtr<BYTE> xQueries( cbFile + sizeof WCHAR );
    if ( xQueries.IsNull() )
    {
        CloseHandle( hFile );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return DisplayWin32Error( IDS_CANTGETMEMORY,
                                  pwcQueryFile,
                                  lcid );
    }

    // Read the file into the buffer

    DWORD cbRead;
    BOOL fRead = ReadFile( hFile, xQueries.Get(), cbFile, &cbRead, 0 );

    CloseHandle( hFile );

    if ( ! fRead )
        return DisplayWin32Error( IDS_CANTREADFROMFILE,
                                  pwcQueryFile,
                                  lcid );

    // Check if the file is Unicode already

    BOOL fUnicode = ( 0xfeff == ( * (WCHAR *) xQueries.Get() ) );

    WCHAR * pwcIn = 0;
    DWORD cwcIn = 0;

    if ( fUnicode )
    {
        pwcIn = (WCHAR *) xQueries.Get();

        // skip past the Unicode marker

        pwcIn++;
        cwcIn = ( cbFile / sizeof WCHAR ) - 1;
    }
    else
    {
        // Convert to Unicode.  Leave a little room for slack.

        DWORD cbTmp = cbFile * sizeof WCHAR + cbFile / 8;
        XPtr<BYTE> xTmp( cbTmp + sizeof WCHAR );
        if ( xTmp.IsNull() )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return DisplayWin32Error( IDS_CANTGETMEMORY,
                                      pwcQueryFile,
                                      lcid );
        }

        cwcIn = MultiByteToWideChar( LocaleToCodepage( lcid ),
                                     0,
                                     (const char *) xQueries.Get(),
                                     cbFile,
                                     (WCHAR *) xTmp.Get(),
                                     cbTmp );
        if ( 0 == cwcIn )
            return DisplayWin32Error( IDS_CANTCONVERTTOUNICODE,
                                      pwcQueryFile,
                                      lcid );

        pwcIn = (WCHAR *) xTmp.Get();
        xQueries.Free();
        xQueries.Set( xTmp.Acquire() );
    }

    // Read each line in the file and issue the query

    pwcIn[ cwcIn ] = 0;
    WCHAR * pwc = pwcIn;

    do
    {
        while ( 0     != *pwcIn &&
                L'\r' != *pwcIn &&
                L'\n' != *pwcIn )
            pwcIn++;

        BOOL fEOF = ( 0 == *pwcIn );

        *pwcIn = 0;

        if ( pwc != pwcIn )
        {
            DoQuery( pwcQueryCatalog,
                     pwcQueryMachine,
                     pwcQueryScope,
                     dwScopeFlags,
                     pwc,
                     pwcColumns,
                     pwcSort,
                     fDisplayTree,
                     fQuiet,
                     fForceUseContentIndex,
                     fNoQuery,
                     fSearchHit,
                     ulDialect,
                     cMaxHits,
                     fFirstHits,
                     lcid,
                     fDefineCPP );
            wprintf( L"\n\n" );
        }

        if ( fEOF )
            break;

        pwcIn++;
        while ( '\r' == *pwcIn || '\n' == *pwcIn )
            pwcIn++;
        pwc = pwcIn;
    } while ( TRUE );

    return S_OK;
} //DoQueryFile

//+-------------------------------------------------------------------------
//
//  Function:   LookupCatalog
//
//  Synopsis:   Looks for a catalog and machine matching the scope
//
//  Arguments:  [pwcScope]   - The scope used to find the catalog
//              [pwcMachine] - Returns the machine name
//              [cwcMachine] - In/Out: Count of characters in pwcMachine
//              [pwcCatalog] - Returns the catalog name
//              [cwcCatalog] - In/Out: Count of characters in pwcCatalog
//              [lcid]       - Locale to use for errors
//
//--------------------------------------------------------------------------

HRESULT LookupCatalog(
    WCHAR const * pwcScope,
    WCHAR *       pwcMachine,
    ULONG &       cwcMachine,
    WCHAR *       pwcCatalog,
    ULONG &       cwcCatalog,
    LCID          lcid )
{
    HRESULT hr = LocateCatalogs( pwcScope,       // scope to lookup
                                 0,              // go with the first match
                                 pwcMachine,     // returns the machine
                                 &cwcMachine,    // buffer size in/out
                                 pwcCatalog,     // returns the catalog
                                 &cwcCatalog );  // buffer size in/out

    if ( FAILED( hr ) || ( S_FALSE == hr ) )
    {
        DisplayError( IDS_CANTFINDCATALOG, pwcScope, hr, lcid );
        hr = E_FAIL;
    }

    return hr;
} //LookupCatalog

//+-------------------------------------------------------------------------
//
//  Function:   NormalizeScope
//
//  Synopsis:   Normalizes a scope and sets scope flags.
//
//  Arguments:  [pwcIn]        - The scope for the query
//              [pwcOut]       - Returns the scope for the query
//              [dwScopeFlags] - Returns the scope flags for the query
//
//--------------------------------------------------------------------------

HRESULT NormalizeScope(
    WCHAR const * pwcIn,
    WCHAR *       pwcOut,
    BOOL          fShallow,
    DWORD &       dwScopeFlags )
{
    if ( wcslen( pwcIn ) >= MAX_PATH )
        return E_INVALIDARG;

    if ( fShallow )
        dwScopeFlags = QUERY_SHALLOW;
    else
        dwScopeFlags = QUERY_DEEP;

    wcscpy( pwcOut, pwcIn );

    // Check if the scope is an IIS virtual scope.

    WCHAR wc = pwcIn[0];

    if ( L'/' == wc )
    {
        // Set the virtual scope flag and flip the slashes.

        dwScopeFlags |= QUERY_VIRTUAL_PATH;
        for ( WCHAR * pwc = pwcOut; *pwc; pwc++ )
            if ( '/' == *pwc )
                *pwc = '\\';
    }
    else if ( ( !( L'\\' == wc && L'\\' == pwcIn[1] ) ) &&
              ( !( L'\\' == wc && 0 == pwcIn[1] ) ) &&
              L':' != pwcIn[1] &&
              0 != wc )
    {
        // Turn the relative path into a full path based on the current dir.

        _wfullpath( pwcOut, pwcIn, MAX_PATH );
    }

    return S_OK;
} //NormalizeScope

//+-------------------------------------------------------------------------
//
//  Function:   DisplayStatus
//
//  Synopsis:   Displays status information about a catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT DisplayStatus(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    CI_STATE state;
    state.cbStruct = sizeof state;

    DisplayStat( pwcMachine, IDS_STAT_MACHINE );
    DisplayStat( pwcCatalog, IDS_STAT_CATALOG );

    HRESULT hr = CIState( pwcCatalog, pwcMachine, &state );

    if ( SUCCEEDED( hr ) )
    {
        DisplayStat( state.cTotalDocuments, IDS_STAT_TOTALDOCUMENTS );
        DisplayStat( state.cFreshTest, IDS_STAT_FRESHTEST );
        DisplayStat( state.cFilteredDocuments, IDS_STAT_FILTEREDDOCUMENTS );
        DisplayStat( state.cDocuments, IDS_STAT_DOCUMENTS );
        DisplayStat( state.cSecQDocuments, IDS_STAT_SECQDOCUMENTS );
        DisplayStat( state.cUniqueKeys, IDS_STAT_UNIQUEKEYS );
        DisplayStat( state.cWordList, IDS_STAT_WORDLIST );
        DisplayStat( state.cPersistentIndex, IDS_STAT_PERSISTENTINDEX );
        DisplayStat( state.cQueries, IDS_STAT_QUERIES );
        DisplayStat( state.dwIndexSize, IDS_STAT_INDEXSIZE );
        DisplayStat( state.dwPropCacheSize / 1024, IDS_STAT_PROPCACHESIZE );

        DisplayStat( ( state.eState & CI_STATE_SCANNING ) ?
                     state.cPendingScans : 0,
                     IDS_STAT_SCANS );

        const DWORD ALL_CI_MERGE = ( CI_STATE_SHADOW_MERGE |
                                     CI_STATE_ANNEALING_MERGE |
                                     CI_STATE_INDEX_MIGRATION_MERGE |
                                     CI_STATE_MASTER_MERGE |
                                     CI_STATE_MASTER_MERGE_PAUSED );

        if ( 0 != ( ALL_CI_MERGE & state.eState ) )
        {
            UINT idStr;
            if ( state.eState & CI_STATE_SHADOW_MERGE )
                idStr = IDS_STAT_MERGE_SHADOW;
            else if ( state.eState & CI_STATE_ANNEALING_MERGE )
                idStr = IDS_STAT_MERGE_ANNEALING;
            else if ( state.eState & CI_STATE_INDEX_MIGRATION_MERGE )
                idStr = IDS_STAT_MERGE_INDEX_MIGRATION;
            else if ( state.eState & CI_STATE_MASTER_MERGE )
                idStr = IDS_STAT_MERGE_MASTER;
            else
                idStr = IDS_STAT_MERGE_MASTER_PAUSED;

            DisplayStat( state.dwMergeProgress, idStr );
        }

        if ( CI_STATE_READ_ONLY & state.eState )
            DisplayStat( IDS_STAT_READ_ONLY );
        if ( CI_STATE_RECOVERING & state.eState )
            DisplayStat( IDS_STAT_RECOVERING );
        if ( CI_STATE_LOW_MEMORY & state.eState )
            DisplayStat( IDS_STAT_LOW_MEMORY );
        if ( CI_STATE_HIGH_IO & state.eState )
            DisplayStat( IDS_STAT_HIGH_IO );
        if ( CI_STATE_BATTERY_POWER & state.eState )
            DisplayStat( IDS_STAT_BATTERY_POWER );
        if ( CI_STATE_USER_ACTIVE & state.eState )
            DisplayStat( IDS_STAT_USER_ACTIVE );
        if ( CI_STATE_STARTING & state.eState )
            DisplayStat( IDS_STAT_STARTING );
        if ( CI_STATE_READING_USNS & state.eState )
            DisplayStat( IDS_STAT_READING_USNS );
    }
    else
    {
        DisplayError( IDS_CANTDISPLAYSTATUS, pwcCatalog, hr, lcid );
    }

    return hr;
} //DisplayStatus

//+-------------------------------------------------------------------------
//
//  Function:   ForceMerge
//
//  Synopsis:   Forces a master merge on the catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT ForceMerge(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    // Create the main Indexing Service administration object.

    CLSID clsid;
    HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    XInterface<IAdminIndexServer> xAdmin;
    hr = CoCreateInstance( clsid,
                           0,
                           CLSCTX_INPROC_SERVER,
                           __uuidof(IAdminIndexServer),
                           xAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    // Set the machine name.

    BSTR bstrMachine = SysAllocString( pwcMachine );
    if ( 0 == bstrMachine )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             E_OUTOFMEMORY,
                             lcid );

    XBStr xbstr( bstrMachine );
    hr = xAdmin->put_MachineName( bstrMachine );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    // Get a catalog administration object.

    BSTR bstrCatalog = SysAllocString( pwcCatalog );
    if ( 0 == bstrCatalog )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             E_OUTOFMEMORY,
                             lcid );

    xbstr.Free();
    xbstr.Set( bstrCatalog );
    XInterface<ICatAdm> xCatAdmin;
    hr = xAdmin->GetCatalogByName( bstrCatalog,
                                   (IDispatch **) xCatAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    // Force the merge.

    hr = xCatAdmin->ForceMasterMerge();
    if ( FAILED( hr ) )
        return DisplayError( IDS_CANTFORCEMERGE,
                             pwcCatalog,
                             hr,
                             lcid );

    return hr;
} //ForceMerge

//+-------------------------------------------------------------------------
//
//  Function:   DisplayUpToDate
//
//  Synopsis:   Checks if the index is up to date.
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//              [lcid]       - Locale to use
//
//--------------------------------------------------------------------------

HRESULT DisplayUpToDate(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine,
    LCID          lcid )
{
    CI_STATE state;
    state.cbStruct = sizeof state;

    HRESULT hr = CIState( pwcCatalog, pwcMachine, &state );

    if ( SUCCEEDED( hr ) )
    {
        // It's up to date if there are no documents to filter, no scans or
        // usn activity, and the index isn't starting or recovering.

        BOOL fUpToDate = ( ( 0 == state.cDocuments ) &&
                           ( 0 == ( state.eState & CI_STATE_SCANNING ) ) &&
                           ( 0 == ( state.eState & CI_STATE_READING_USNS ) ) &&
                           ( 0 == ( state.eState & CI_STATE_STARTING ) ) &&
                           ( 0 == ( state.eState & CI_STATE_RECOVERING ) ) );

        DisplayStat( fUpToDate ? IDS_STAT_UP_TO_DATE :
                                 IDS_STAT_NOT_UP_TO_DATE );
    }
    else
    {
        DisplayError( IDS_CANTDISPLAYSTATUS, pwcCatalog, hr, lcid );
    }

    return hr;
} //DisplayUpToDate

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments and
//              issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcCatalog     = 0;         // default: lookup catalog
    WCHAR const * pwcMachine     = L".";      // default: local machine
    WCHAR const * pwcScope       = L"\\";     // default: entire catalog
    WCHAR const * pwcRestriction = 0;         // no default restriction
    WCHAR const * pwcColumns     = L"path";   // default output column(s)
    WCHAR const * pwcSort        = 0;         // no sort is the default
    WCHAR const * pwcQueryFile   = 0;         // no query file specified
    WCHAR const * pwcLocale      = 0;         // default: system locale
    BOOL fDisplayTree            = FALSE;     // don't display the tree
    BOOL fForceUseContentIndex   = TRUE;      // always use the index
    ULONG ulDialect              = 1;         // old tripolish dialect
    BOOL fQuiet                  = FALSE;     // show the hitcount
    ULONG cMaxHits               = 0;         // default: retrieve all hits
    BOOL fFirstHits              = FALSE;     // First vs Best N hits
    BOOL fDisplayStatus          = FALSE;     // default: don't show status
    BOOL fDisplayUpToDate        = FALSE;     // default: don't show up to date
    ULONG cRepetitions           = 1;         // # of times to repeat command
    BOOL fShallow                = FALSE;     // default: all subdirectories
    BOOL fNoQuery                = FALSE;     // default: execute query
    BOOL fSearchHit              = FALSE;     // default: don't isrchdmp.exe
    BOOL fDefineCPP              = FALSE;     // default: don't define props
    BOOL fForceMerge             = FALSE;     // default: don't force a MM

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( (char) argv[i][1] );

            if ( ':' != argv[i][2] &&
                 'D' != wc &&
                 'G' != wc &&
                 'H' != wc &&
                 'J' != wc &&
                 'N' != wc &&
                 'Q' != wc &&
                 'U' != wc &&
                 'T' != wc &&
                 'Z' != wc )
                Usage();

            if ( 'C' == wc )
                pwcCatalog = argv[i] + 3;
            else if ( 'M' == wc )
                pwcMachine = argv[i] + 3;
            else if ( 'P' == wc )
                pwcScope = argv[i] + 3;
            else if ( 'O' == wc )
                pwcColumns = argv[i] + 3;
            else if ( 'S' == wc )
                pwcSort = argv[i] + 3;
            else if ( 'X' == wc )
                cMaxHits = _wtoi( argv[i] + 3 );
            else if ( 'Y' == wc )
            {
                cMaxHits = _wtoi( argv[i] + 3 );
                fFirstHits = TRUE;
            }
            else if ( 'I' == wc )
            {
                if ( 0 != pwcRestriction )
                    Usage();
                pwcQueryFile = argv[i] + 3;
            }
            else if ( 'R' == wc)
            {
                // get the next arg as a number
                cRepetitions = _wtol(argv[i]+3);
            }
            else if ( 'D' == wc )
                fDisplayTree = TRUE;
            else if ( 'G' == wc )
                fForceMerge = TRUE;
            else if ( 'H' == wc )
                fSearchHit = TRUE;
            else if ( 'J' == wc )
                fShallow = TRUE;
            else if ( 'N' == wc )
                fNoQuery = TRUE;
            else if ( 'Q' == wc )
                fQuiet = TRUE;
            else if ( 'T' == wc )
                fDisplayStatus = TRUE;
            else if ( 'U' == wc )
                fDisplayUpToDate = TRUE;
            else if ( 'E' == wc )
                pwcLocale = argv[i] + 3;
            else if ( 'L' == wc )
            {
                if ( '1' == argv[i][3] )
                    ulDialect = 1;
                else if ( '2' == argv[i][3] )
                    ulDialect = 2;
                else
                    Usage();
            }
            else if ( 'F' == wc )
            {
                if ( '+' == argv[i][3] )
                    fForceUseContentIndex = TRUE;
                else if ( '-' == argv[i][3] )
                    fForceUseContentIndex = FALSE;
                else
                    Usage();
            }
            else if ( 'Z' == wc )
                fDefineCPP = TRUE;
            else
                Usage();
        }
        else if ( 0 != pwcRestriction || 0 != pwcQueryFile )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction, query file, or status request is necessary.

    if ( 0 == pwcRestriction && 0 == pwcQueryFile &&
         !fDisplayStatus && !fDisplayUpToDate && !fForceMerge )
        Usage();

    // Normalize relative and virtual scopes

    WCHAR awcScope[ MAX_PATH ];
    DWORD dwScopeFlags;
    HRESULT hr = NormalizeScope( pwcScope, awcScope, fShallow, dwScopeFlags );

    // Initialize OLE

    BOOL fCoInit = FALSE;

    if ( SUCCEEDED( hr ) )
    {
        hr = CoInitialize( 0 );
        if ( SUCCEEDED( hr ) )
            fCoInit = TRUE;
    }

    // Get the locale identifier to use for the query

    LCID lcid = LcidFromHttpAcceptLanguage( pwcLocale );

    HINSTANCE hISearch = 0;

    if ( fSearchHit )
    {
        hISearch = PrepareForISearch();

        if ( 0 == hISearch )
            Usage();
    }

    // If no catalog was specified, infer one based on the scope

    WCHAR awcMachine[ MAX_PATH ], awcCatalog[ MAX_PATH ];

    if ( SUCCEEDED( hr ) && ( 0 == pwcCatalog ) && !fNoQuery )
    {
        ULONG cwcMachine = sizeof awcMachine / sizeof WCHAR;
        ULONG cwcCatalog = sizeof awcCatalog / sizeof WCHAR;
        hr = LookupCatalog( awcScope,
                            awcMachine,
                            cwcMachine,
                            awcCatalog,
                            cwcCatalog,
                            lcid );
        pwcMachine = awcMachine;
        pwcCatalog = awcCatalog;

        // Turn scopes like \\machine into \ now that the lookup is done
        // and we've found a catalog and machine name.

        if ( SUCCEEDED( hr ) &&
             L'\\' == awcScope[0] && L'\\' == awcScope[1] &&
             0 == wcschr( awcScope + 2, L'\\' ) )
            awcScope[1] = 0;
    }

    if ( SUCCEEDED( hr ) )
    {
        for (ULONG j = 0; j < cRepetitions; j++)
        {
            if ( 0 != pwcQueryFile )
                hr = DoQueryFile( fNoQuery ? L"::_noquery" : pwcCatalog,
                                  pwcMachine,
                                  awcScope,
                                  dwScopeFlags,
                                  pwcColumns,
                                  pwcSort,
                                  fDisplayTree,
                                  fQuiet,
                                  fForceUseContentIndex,
                                  fNoQuery,
                                  fSearchHit,
                                  ulDialect,
                                  cMaxHits,
                                  fFirstHits,
                                  lcid,
                                  pwcQueryFile,
                                  fDefineCPP );
            else if ( 0 != pwcRestriction )
                hr = DoQuery( fNoQuery ? L"::_noquery" : pwcCatalog,
                              pwcMachine,
                              awcScope,
                              dwScopeFlags,
                              pwcRestriction,
                              pwcColumns,
                              pwcSort,
                              fDisplayTree,
                              fQuiet,
                              fForceUseContentIndex,
                              fNoQuery,
                              fSearchHit,
                              ulDialect,
                              cMaxHits,
                              fFirstHits,
                              lcid,
                              fDefineCPP );

            if ( SUCCEEDED( hr ) && fForceMerge )
                hr = ForceMerge( pwcCatalog, pwcMachine, lcid );

            if ( SUCCEEDED( hr ) && fDisplayStatus )
                hr = DisplayStatus( pwcCatalog, pwcMachine, lcid );

            if ( SUCCEEDED( hr ) && fDisplayUpToDate )
                hr = DisplayUpToDate( pwcCatalog, pwcMachine, lcid );
        }
    }

    if ( fCoInit )
        CoUninitialize();

    if ( 0 != hISearch )
        DoneWithISearch( hISearch );

    if ( FAILED( hr ) )
        return -1;

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\admin\strings.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       Strings.cxx
//
//  Contents:   Localizable string resources.
//
//  History:    26-Jan-1998     KyleP   Added header
//              20-Jan-1999     SLarimor Modified rescan interface to include 
//                                      Full and Incremental options separatly
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciares.h>
#include "ntverp.h"

//-----------------------------------------------------------------------------

StringResource srAnnealing        = { MSG_STATE_ANNEALING_MERGE };
StringResource srBattery          = { MSG_STATE_BATTERY_POWER };
StringResource srCMAddCatalog     = { MSG_CM_ADD_CATALOG };
StringResource srCMAddCatalogHelp = { MSG_CM_ADD_CATALOG_HELP };
StringResource srCMDelCatalog     = { MSG_CM_DEL_CATALOG };
StringResource srCMDelCatalogHelp = { MSG_CM_DEL_CATALOG_HELP };
StringResource srCMDelScope       = { MSG_CM_DEL_SCOPE };
StringResource srCMDelScopeHelp   = { MSG_CM_DEL_SCOPE_HELP };
StringResource srCMMerge          = { MSG_CM_MERGE };
StringResource srCMMergeHelp      = { MSG_CM_MERGE_HELP };
StringResource srCMPauseCI        = { MSG_CM_PAUSE_CI };
StringResource srCMPauseCIHelp    = { MSG_CM_PAUSE_CI_HELP };
StringResource srCMRescanFull     = { MSG_CM_SCAN_FULL_SCOPE };
StringResource srCMRescanFullHelp = { MSG_CM_SCAN_FULL_SCOPE_HELP };
StringResource srCMRescanIncremental = { MSG_CM_SCAN_INCREMENTAL_SCOPE };
StringResource srCMRescanIncrementalHelp = { MSG_CM_SCAN_INCREMENTAL_SCOPE_HELP };
StringResource srCMScope          = { MSG_CM_ADD_SCOPE };
StringResource srCMScopeHelp      = { MSG_CM_ADD_SCOPE_HELP };
StringResource srCMStartCI        = { MSG_CM_START_CI };
StringResource srCMStartCIHelp    = { MSG_CM_START_CI_HELP };
StringResource srCMStopCI         = { MSG_CM_STOP_CI };
StringResource srCMStopCIHelp     = { MSG_CM_STOP_CI_HELP };
StringResource srCMEmptyCatalog   = { MSG_CM_EMPTY_CATALOG };
StringResource srCMEmptyCatalogHelp = { MSG_CM_EMPTY_CATALOG_HELP };
StringResource srCMInvalidScope     = { MSG_CM_INVALID_SCOPE };
StringResource srCMUnexpectedError  = { MSG_CM_UNEXPECTED_ERROR };
StringResource srCMShutdownService  = { MSG_CM_SHUTDOWN_SERVICE };
StringResource srCMShutdownServiceTitle   = { MSG_CM_SHUTDOWN_SERVICE_TITLE };
StringResource srCMCantShutdownService    = { MSG_CM_CANT_SHUTDOWN_SERVICE };
StringResource srCMCantSaveSettings       = { MSG_CM_CANT_SAVE_SETTINGS };

StringResource srGenericError     = { MSG_GENERIC_ERROR };
StringResource srGenericErrorTitle= { MSG_ERROR_TITLE };
StringResource srInvalidComputerName = { MSG_INVALID_COMPUTER_NAME };
StringResource srHighIo           = { MSG_STATE_HIGH_IO };
StringResource srIndexServer      = { MSG_INDEX_SERVER };
StringResource srIndexServerCmpManage = { MSG_INDEX_SERVER_CMPMANAGE };
StringResource srLM               = { MSG_LOCAL_MACHINE };
StringResource srLowMemory        = { MSG_STATE_LOW_MEMORY };
StringResource srMaster           = { MSG_STATE_MASTER_MERGE };
StringResource srMMPaused         = { MSG_STATE_MASTER_MERGE_PAUSED };
StringResource srMsgCantDeleteCatalog = { MSG_CANT_DELETE_CATALOG };
StringResource srMsgDeleteCatalog = { MSG_DELETE_CATALOG };
StringResource srMsgDeleteCatalogAsk = { MSG_DELETE_CATALOG_ASK };
StringResource srMsgCatalogPartialDeletion = { MSG_CATALOG_PARTIAL_DELETION };
StringResource srMsgDeleteCatalogTitle = { MSG_DELETE_CATALOG_TITLE };
StringResource srMsgEnableCI      = { MSG_ENABLE_CI };
StringResource srMsgEnableCITitle = { MSG_ENABLE_CI_TITLE };
StringResource srMsgMerge         = { MSG_MERGE_CATALOG };
StringResource srMsgRescanFull    = { MSG_RESCAN_FULL_SCOPE };
StringResource srMsgRescanIncremental = { MSG_RESCAN_INCREMENTAL_SCOPE };
StringResource srMsgRescanFullExplain = { MSG_RESCAN_FULL_SCOPE_EXPLAIN };
StringResource srMsgRescanIncrementalExplain = { MSG_RESCAN_INCREMENTAL_SCOPE_EXPLAIN };
StringResource srNC               = { MSG_NEW_CATALOG };
StringResource srNCError          = { MSG_CANT_ADD_CATALOG };
StringResource srNCT              = { MSG_NEW_CATALOG_TITLE };
StringResource srNCErrorT         = { MSG_CANT_ADD_CATALOG_TITLE };
StringResource srNo               = { MSG_NO };
StringResource srNodeDirectories  = { MSG_NODE_DIRECTORIES };
StringResource srNodeProperties   = { MSG_NODE_PROPERTIES };
StringResource srNodeUnfiltered   = { MSG_NODE_UNFILTERED };
StringResource srPendingProps     = { MSG_PENDING_PROP_CHANGE };
StringResource srPendingPropsTitle= { MSG_PENDING_PROP_CHANGE_TITLE };
StringResource srRecovering       = { MSG_STATE_RECOVERING };
StringResource srScanReq          = { MSG_STATE_CONTENT_SCAN_REQUIRED };
StringResource srScanning         = { MSG_STATE_SCANNING };
StringResource srShadow           = { MSG_STATE_SHADOW_MERGE };
StringResource srStarting         = { MSG_STATE_STARTING };
StringResource srReadingUsns      = { MSG_STATE_READING_USNS };
StringResource srUserActive       = { MSG_STATE_USER_ACTIVE };
StringResource srStarted          = { MSG_STATE_STARTED };
StringResource srStopped          = { MSG_STATE_STOPPED };
StringResource srYes              = { MSG_YES };
StringResource srPrimaryStore     = { MSG_STORELEVEL_PRIMARY };
StringResource srSecondaryStore   = { MSG_STORELEVEL_SECONDARY };
StringResource srPropCommitErrorT = { MSG_ERROR_PROP_COMMIT};
StringResource srProductDescription = { MSG_PRODUCT_DESCRIPTION };
StringResource srVendorCopyright    = { MSG_VENDOR_COPYRIGHT };
StringResource srVendorName         = { MSG_VENDOR_NAME };
StringResource srProviderName       = { MSG_PROVIDER_NAME };
StringResource srRefreshProperties  = { MSG_CM_PROPERTIES_REFRESH };
StringResource srRefreshPropertiesHelp = { MSG_CM_PROPERTIES_REFRESH_HELP };
StringResource srNoneSelected          = { MSG_NONE_SELECTED };
StringResource srReadOnly              = { MSG_STATE_READ_ONLY };
StringResource srMsgEmptyCatalogAsk    = { MSG_EMPTY_CATALOG_TITLE };
StringResource srMsgEmptyCatalogPrompt = { MSG_EMPTY_CATALOG_PROMPT };
StringResource srType                  = { MSG_TYPE };
StringResource srCMTunePerformance     = { MSG_CM_TUNE_PERFORMANCE };
StringResource srCMTunePerformanceHelp = { MSG_CM_TUNE_PERFORMANCE_HELP };
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
StringResource srSnapinNameStringIndirect = { MSG_SNAPIN_NAME_STRING_INDIRECT };
#endif

void InitStrings( HINSTANCE hInstance )
{
    srAnnealing.Init( hInstance );
    srBattery.Init( hInstance );
    srCMAddCatalog.Init( hInstance );
    srCMAddCatalogHelp.Init( hInstance );
    srCMDelCatalog.Init( hInstance );
    srCMDelCatalogHelp.Init( hInstance );
    srCMDelScope.Init( hInstance );
    srCMDelScopeHelp.Init( hInstance );
    srCMMerge.Init( hInstance );
    srCMMergeHelp.Init( hInstance );
    srCMPauseCI.Init( hInstance );
    srCMPauseCIHelp.Init( hInstance );
    srCMRescanFull.Init( hInstance );
    srCMRescanFullHelp.Init( hInstance );
    srCMRescanIncremental.Init( hInstance );
    srCMRescanIncrementalHelp.Init( hInstance );
    srCMScope.Init( hInstance );
    srCMScopeHelp.Init( hInstance );
    srCMStartCI.Init( hInstance );
    srCMStartCIHelp.Init( hInstance );
    srCMStopCI.Init( hInstance );
    srCMStopCIHelp.Init( hInstance );
    srCMEmptyCatalog.Init( hInstance );
    srCMEmptyCatalogHelp.Init( hInstance );
    srCMInvalidScope.Init( hInstance );
    srCMUnexpectedError.Init( hInstance );
    srGenericError.Init( hInstance );
    srGenericErrorTitle.Init( hInstance );
    srInvalidComputerName.Init( hInstance );
    srHighIo.Init( hInstance );
    srIndexServer.Init( hInstance );
    srIndexServerCmpManage.Init( hInstance );
    srLM.Init( hInstance );
    srLowMemory.Init( hInstance );
    srMaster.Init( hInstance );
    srMMPaused.Init( hInstance );
    srMsgCantDeleteCatalog.Init( hInstance );
    srMsgDeleteCatalog.Init( hInstance );
    srMsgCatalogPartialDeletion.Init( hInstance );
    srMsgDeleteCatalogAsk.Init( hInstance );
    srMsgDeleteCatalogTitle.Init( hInstance );
    srMsgEnableCI.Init( hInstance );
    srMsgEnableCITitle.Init( hInstance );
    srMsgMerge.Init( hInstance );
    srMsgRescanFull.Init( hInstance );
    srMsgRescanIncremental.Init( hInstance );
    srMsgRescanFullExplain.Init( hInstance );
    srMsgRescanIncrementalExplain.Init( hInstance );
    srNC.Init( hInstance );
    srNCError.Init( hInstance );
    srNCT.Init( hInstance );
    srNCErrorT.Init( hInstance );
    srNo.Init( hInstance );
    srNodeDirectories.Init( hInstance );
    srNodeProperties.Init( hInstance );
    srNodeUnfiltered.Init( hInstance );
    srPendingProps.Init( hInstance );
    srPendingPropsTitle.Init( hInstance );
    srRecovering.Init( hInstance );
    srScanReq.Init( hInstance );
    srScanning.Init( hInstance );
    srUserActive.Init( hInstance );
    srShadow.Init( hInstance );
    srStarting.Init( hInstance );
    srReadingUsns.Init( hInstance );
    srStarted.Init( hInstance );
    srStopped.Init( hInstance );
    srYes.Init( hInstance );
    srPrimaryStore.Init( hInstance );
    srSecondaryStore.Init( hInstance );
    srPropCommitErrorT.Init( hInstance );
    srProductDescription.Init( hInstance );
    srVendorName.Init( hInstance );
    srProviderName.Init( hInstance );
    srVendorCopyright.Init( hInstance );
    srRefreshProperties.Init( hInstance );
    srRefreshPropertiesHelp.Init( hInstance );
    srNoneSelected.Init( hInstance );
    srReadOnly.Init( hInstance );
    srMsgEmptyCatalogAsk.Init( hInstance );
    srMsgEmptyCatalogPrompt.Init( hInstance );
    srType.Init( hInstance );
    srCMTunePerformance.Init( hInstance );
    srCMTunePerformanceHelp.Init( hInstance );
    srCMShutdownService.Init( hInstance );
    srCMShutdownServiceTitle.Init( hInstance );
    srCMCantSaveSettings.Init( hInstance );
    srCMCantShutdownService.Init( hInstance );
#if 0   
    // NTRAID#DB-NTBUG9-97218-2000/10/17-kitmanh MUI:MMC:Index Service snap-in stores its name string in the registry
    // the change is backed out due to localization issues
    srSnapinNameStringIndirect.Init( hInstance );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\ci\isearch.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __isearch_h__
#define __isearch_h__

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif  /* __ISearchQueryHits_FWD_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchQueryHits __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchQueryHits __RPC_FAR * This);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitMoniker )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitOffset )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchQueryHits_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISearchQueryHits_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISearchQueryHits_Init(This,pflt,ulFlags)        \
    (This)->lpVtbl -> Init(This,pflt,ulFlags)

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)      \
    (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk)

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)  \
    (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion)

#endif /* COBJMACROS */


#endif  /* C style interface */



SCODE STDMETHODCALLTYPE ISearchQueryHits_Init_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [in] */ IFilter __RPC_FAR *pflt,
    /* [in] */ ULONG ulFlags);


void __RPC_STUB ISearchQueryHits_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitMoniker_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcMnk,
    /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);


void __RPC_STUB ISearchQueryHits_NextHitMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitOffset_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcRegion,
    /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);


void __RPC_STUB ISearchQueryHits_NextHitOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISearchQueryHits_INTERFACE_DEFINED__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\chgstate\chgstate.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  ChgState.cxx
//
// PURPOSE:  To change the state of a catalog (on local machine) 
//
// PLATFORM: Windows NT
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>

#include <ntquery.h>

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "Usage: ChgState /a:<RO|RW|Stop|GetState> /c:<Catalog Name>\n" ); 
    printf( "    /m:<Machine Name>\n\n" );
    printf( "    ChgState            Change the state of a catalog\n" );
    printf( "    /a:<Action>         the action to be taken, default is RO\n" );
    printf( "    The three actions are states RO (ReadOnly), RW (Read\\Write)\n" );
    printf( "    and Stop (Stopped)\n" );
    printf( "    You can also specify GetState to check the state of a catalog\n" ); 
    printf( "    /c:<Catalog Name>   name of the catalog, default is SYSTEM\n" );
    printf( "    /m:<Machine Name>   name of the machine, default is local machine\n" );
    exit( -1 );
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcsCatalog     = L"system"; // default: system
    WCHAR const * pwcsMachine     = L".";      // default: local machine
    WCHAR const * pwcsAction      = L"RO";     // default: ReadOnly
    DWORD dwNewState              = CICAT_READONLY;
    DWORD dwOldState;

    SCODE sc = S_OK;

    // Parse the command for arguments
    if ( argc > 1 )
    {
        for ( int i = 1; i < argc; i++ )
        {
            if ( L'/' == argv[i][0] )
            {
                WCHAR wc = (WCHAR) toupper( argv[i][1] );

                if ( ':' != argv[i][2] )
                    Usage();

                if ( 'A' == wc )  
                    pwcsAction = argv[i] + 3;
                else if ( 'C' == wc )
                    pwcsCatalog = argv[i] + 3;
                else if ( 'M' == wc )
                    pwcsMachine = argv[i] + 3;
                else
                    Usage();
            }
            else 
                Usage();
        }
    }
    else
    {
        Usage();
    }

    if ( !wcscmp( pwcsAction, L"RO" ) )          // ReadOnly
        dwNewState = CICAT_READONLY;
    else if ( !wcscmp( pwcsAction, L"RW" ) )     // ReadWrite
        dwNewState = CICAT_WRITABLE;   
    else if ( !wcscmp( pwcsAction, L"Stop" ) )   // Stop
        dwNewState = CICAT_STOPPED;
    else if ( !wcscmp( pwcsAction, L"GetState" ) ) // Get the current state 
        dwNewState = CICAT_GET_STATE;
    else
    {
        fprintf( stderr, "Action undefined!\n" );
        exit(-1);
    }

    // call the API
    sc = SetCatalogState ( pwcsCatalog,
                           pwcsMachine,  
                           dwNewState,
                           &dwOldState );   

    if ( FAILED( sc ) )
    {
        printf( "ChangeState for catalog %ws failed with error %#x\n", pwcsCatalog ,sc );
        return -1;
    }

    printf(" Old State is " );
    if ( CICAT_STOPPED == dwOldState ) 
        printf( "CICAT_STOPPED.\n" );
    else
    {
        if ( CICAT_WRITABLE & dwOldState ) 
            printf( "CICAT_WRITABLE.\n" );
        else if ( CICAT_READONLY & dwOldState )
            printf( "CICAT_READONLY.\n" );
        else printf( "Error obtaining oldState. The return value is %d\n", dwOldState );
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\ci\disptree.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1997 - 1999.  All Rights Reserved.
//
// FILE:     disptree.cxx
//
// PURPOSE:  Displays a command tree, for debugging.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <windows.h>

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayVariant
//
//  Synopsis:   Displays a PROPVARIANT.  This is not a complete
//              implementation; many VT_ types are not complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayVariant( PROPVARIANT * pVar )
{
    if ( 0 == pVar )
    {
        printf( "NULL" );
        return;
    }

    PROPVARIANT & v = *pVar;

    switch ( v.vt )
    {
        case VT_I4 : printf( "VT_I4 %d", v.lVal ); break;
        case VT_UI1 : printf( "VT_UI1 %d", v.bVal ); break;
        case VT_I2 : printf( "VT_I2 %d", v.iVal ); break;
        case VT_R4 : printf( "VT_R4 %f", v.fltVal ); break;
        case VT_R8 : printf( "VT_R8 %lf", v.dblVal ); break;
        case VT_BOOL : printf( "VT_BOOL %d", v.boolVal ); break;
        case VT_ERROR : printf( "VT_ERROR %#x", v.scode ); break;
        case VT_CY :
        {
            double dbl;
            VarR8FromCy( pVar->cyVal, &dbl );

            printf( "VT_CY %lf", dbl );
            break;
        }
        case VT_DATE : printf( "VT_DATE " ); break;
        case VT_FILETIME : printf( "VT_FILETIME %#I64x ", v.filetime ); break;
        case VT_BSTR : printf( "VT_BSTR '%ws'", v.bstrVal ); break;
        case VT_UNKNOWN : printf( "VT_UNKNOWN " ); break;
        case VT_DISPATCH : printf( "VT_DISPATCH " ); break;
        case VT_BYREF|VT_UI1 : printf( "VT_BYREF|VT_UI1 " ); break;
        case VT_BYREF|VT_I2 : printf( "VT_BYREF|VT_I2 " ); break;
        case VT_BYREF|VT_I4 : printf( "VT_BYREF|VT_I4 " ); break;
        case VT_BYREF|VT_R4 : printf( "VT_BYREF|VT_R4 " ); break;
        case VT_BYREF|VT_R8 : printf( "VT_BYREF|VT_R8 " ); break;
        case VT_BYREF|VT_BOOL : printf( "VT_BYREF|VT_BOOL " ); break;
        case VT_BYREF|VT_ERROR : printf( "VT_BYREF|VT_ERROR " ); break;
        case VT_BYREF|VT_CY : printf( "VT_BYREF|VT_CY " ); break;
        case VT_BYREF|VT_DATE : printf( "VT_BYREF|VT_DATE " ); break;
        case VT_BYREF|VT_BSTR : printf( "VT_BYREF|VT_BSTR " ); break;
        case VT_BYREF|VT_UNKNOWN : printf( "VT_BYREF|VT_UNKNOWN " ); break;
        case VT_BYREF|VT_DISPATCH : printf( "VT_BYREF|VT_DISPATCH " ); break;
        case VT_BYREF|VT_ARRAY : printf( "VT_BYREF|VT_ARRAY " ); break;
        case VT_BYREF|VT_VARIANT : printf( "VT_BYREF|VT_VARIANT " ); break;
        case VT_I1 : printf( "VT_I1 %d", v.bVal ); break;
        case VT_UI2 : printf( "VT_UI2 %u", v.uiVal ); break;
        case VT_UI4 : printf( "VT_UI4 %u", v.ulVal ); break;
        case VT_INT : printf( "VT_INT %d", v.lVal ); break;
        case VT_UINT : printf( "VT_UINT %u", v.ulVal ); break;
        case VT_BYREF|VT_DECIMAL : printf( "VT_BYREF|VT_DECIMAL " ); break;
        case VT_BYREF|VT_I1 : printf( "VT_BYREF|VT_I1 " ); break;
        case VT_BYREF|VT_UI2 : printf( "VT_BYREF|VT_UI2 " ); break;
        case VT_BYREF|VT_UI4 : printf( "VT_BYREF|VT_UI4 " ); break;
        case VT_BYREF|VT_INT : printf( "VT_BYREF|VT_INT " ); break;
        case VT_BYREF|VT_UINT : printf( "VT_BYREF|VT_UINT " ); break;
        case VT_LPSTR : printf( "VT_LPSTR '%s'", v.pszVal ); break;
        case VT_LPWSTR : printf( "VT_LPWSTR '%ws'", v.pwszVal ); break;
        case VT_I8 : printf( "VT_I8 %I64d", v.hVal ); break;
        case VT_UI8 : printf( "VT_I8 %I64u", v.hVal ); break;
        case VT_VECTOR | VT_I1:
            printf( "VT_VECTOR | VT_I1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I2:
            printf( "VT_VECTOR | VT_I2 " );
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I4:
            printf( "VT_VECTOR | VT_I4 " );
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" );
            break;
        case VT_VECTOR | VT_I8:
            printf( "VT_VECTOR | VT_I8 " );
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" );
            break;
        case VT_VECTOR | VT_UI1:
            printf( "VT_VECTOR | VT_UI1 " );
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI2:
            printf( "VT_VECTOR | VT_UI2 " );
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI4:
            printf( "VT_VECTOR | VT_UI4 " );
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" );
            break;
        case VT_VECTOR | VT_UI8:
            printf( "VT_VECTOR | VT_UI8 " );
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" );
            break;
        case VT_VECTOR | VT_BSTR:
            printf( "VT_VECTOR | VT_BSTR " );
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_LPSTR:
            printf( "VT_VECTOR | VT_LPSTR " );
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%s" );
            break;
        case VT_VECTOR | VT_LPWSTR:
            printf( "VT_VECTOR | VT_LPWSTR " );
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" );
            break;
        case VT_VECTOR | VT_R4:
            printf( "VT_VECTOR | VT_R4 " );
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" );
            break;
        case VT_VECTOR | VT_R8:
            printf( "VT_VECTOR | VT_R8 " );
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" );
            break;
        default : printf( "unknown vt %#x", v.vt );
    }
} //DisplayVariant

//+-------------------------------------------------------------------------
//
//  Function:   PrintSpace
//
//  Synopsis:   Prints white space.
//
//  Arguments:  [cPlaces] - Number of levels to print
//
//--------------------------------------------------------------------------

void PrintSpace( ULONG cPlaces )
{
    for( ULONG iPlace = 0; iPlace < cPlaces; iPlace++ )
        printf( "  " );
} //PrintSpace

//+-------------------------------------------------------------------------
//
//  Function:   DisplayCommandTree
//
//  Synopsis:   Displays the command tree, useful for debugging.  This is
//              not a complete implementation; many DBVALUEKINDs are not
//              complete.
//
//  Arguments:  [pNode]  - The command tree node
//              [iLevel] - The 0-based level in the tree
//
//--------------------------------------------------------------------------

void DisplayCommandTree(
    DBCOMMANDTREE * pNode,
    ULONG           iLevel )
{
    PrintSpace( iLevel );
    printf( "op: (%d) ", pNode->op );
    switch ( pNode->op )
    {
        case DBOP_scalar_constant : printf( "DBOP_scalar_constant" ); break;
        case DBOP_DEFAULT : printf( "DBOP_DEFAULT" ); break;
        case DBOP_NULL : printf( "DBOP_NULL" ); break;
        case DBOP_bookmark_name : printf( "DBOP_bookmark_name" ); break;
        case DBOP_catalog_name : printf( "DBOP_catalog_name" ); break;
        case DBOP_column_name : printf( "DBOP_column_name" ); break;
        case DBOP_schema_name : printf( "DBOP_schema_name" ); break;
        case DBOP_outall_name : printf( "DBOP_outall_name" ); break;
        case DBOP_qualifier_name : printf( "DBOP_qualifier_name" ); break;
        case DBOP_qualified_column_name : printf( "DBOP_qualified_column_name" ); break;
        case DBOP_table_name : printf( "DBOP_table_name" ); break;
        case DBOP_nested_table_name : printf( "DBOP_nested_table_name" ); break;
        case DBOP_nested_column_name : printf( "DBOP_nested_column_name" ); break;
        case DBOP_row : printf( "DBOP_row" ); break;
        case DBOP_table : printf( "DBOP_table" ); break;
        case DBOP_sort : printf( "DBOP_sort" ); break;
        case DBOP_distinct : printf( "DBOP_distinct" ); break;
        case DBOP_distinct_order_preserving : printf( "DBOP_distinct_order_preserving" ); break;
        case DBOP_alias : printf( "DBOP_alias" ); break;
        case DBOP_cross_join : printf( "DBOP_cross_join" ); break;
        case DBOP_union_join : printf( "DBOP_union_join" ); break;
        case DBOP_inner_join : printf( "DBOP_inner_join" ); break;
        case DBOP_left_semi_join : printf( "DBOP_left_semi_join" ); break;
        case DBOP_right_semi_join : printf( "DBOP_right_semi_join" ); break;
        case DBOP_left_anti_semi_join : printf( "DBOP_left_anti_semi_join" ); break;
        case DBOP_right_anti_semi_join : printf( "DBOP_right_anti_semi_join" ); break;
        case DBOP_left_outer_join : printf( "DBOP_left_outer_join" ); break;
        case DBOP_right_outer_join : printf( "DBOP_right_outer_join" ); break;
        case DBOP_full_outer_join : printf( "DBOP_full_outer_join" ); break;
        case DBOP_natural_join : printf( "DBOP_natural_join" ); break;
        case DBOP_natural_left_outer_join : printf( "DBOP_natural_left_outer_join" ); break;
        case DBOP_natural_right_outer_join : printf( "DBOP_natural_right_outer_join" ); break;
        case DBOP_natural_full_outer_join : printf( "DBOP_natural_full_outer_join" ); break;
        case DBOP_set_intersection : printf( "DBOP_set_intersection" ); break;
        case DBOP_set_union : printf( "DBOP_set_union" ); break;
        case DBOP_set_left_difference : printf( "DBOP_set_left_difference" ); break;
        case DBOP_set_right_difference : printf( "DBOP_set_right_difference" ); break;
        case DBOP_set_anti_difference : printf( "DBOP_set_anti_difference" ); break;
        case DBOP_bag_intersection : printf( "DBOP_bag_intersection" ); break;
        case DBOP_bag_union : printf( "DBOP_bag_union" ); break;
        case DBOP_bag_left_difference : printf( "DBOP_bag_left_difference" ); break;
        case DBOP_bag_right_difference : printf( "DBOP_bag_right_difference" ); break;
        case DBOP_bag_anti_difference : printf( "DBOP_bag_anti_difference" ); break;
        case DBOP_division : printf( "DBOP_division" ); break;
        case DBOP_relative_sampling : printf( "DBOP_relative_sampling" ); break;
        case DBOP_absolute_sampling : printf( "DBOP_absolute_sampling" ); break;
        case DBOP_transitive_closure : printf( "DBOP_transitive_closure" ); break;
        case DBOP_recursive_union : printf( "DBOP_recursive_union" ); break;
        case DBOP_aggregate : printf( "DBOP_aggregate" ); break;
        case DBOP_remote_table : printf( "DBOP_remote_table" ); break;
        case DBOP_select : printf( "DBOP_select" ); break;
        case DBOP_order_preserving_select : printf( "DBOP_order_preserving_select" ); break;
        case DBOP_project : printf( "DBOP_project" ); break;
        case DBOP_project_order_preserving : printf( "DBOP_project_order_preserving" ); break;
        case DBOP_top : printf( "DBOP_top" ); break;
        case DBOP_top_percent : printf( "DBOP_top_percent" ); break;
        case DBOP_top_plus_ties : printf( "DBOP_top_plus_ties" ); break;
        case DBOP_top_percent_plus_ties : printf( "DBOP_top_percent_plus_ties" ); break;
        case DBOP_rank : printf( "DBOP_rank" ); break;
        case DBOP_rank_ties_equally : printf( "DBOP_rank_ties_equally" ); break;
        case DBOP_rank_ties_equally_and_skip : printf( "DBOP_rank_ties_equally_and_skip" ); break;
        case DBOP_navigate : printf( "DBOP_navigate" ); break;
        case DBOP_nesting : printf( "DBOP_nesting" ); break;
        case DBOP_unnesting : printf( "DBOP_unnesting" ); break;
        case DBOP_nested_apply : printf( "DBOP_nested_apply" ); break;
        case DBOP_cross_tab : printf( "DBOP_cross_tab" ); break;
        case DBOP_is_NULL : printf( "DBOP_is_NULL" ); break;
        case DBOP_is_NOT_NULL : printf( "DBOP_is_NOT_NULL" ); break;
        case DBOP_equal : printf( "DBOP_equal" ); break;
        case DBOP_not_equal : printf( "DBOP_not_equal" ); break;
        case DBOP_less : printf( "DBOP_less" ); break;
        case DBOP_less_equal : printf( "DBOP_less_equal" ); break;
        case DBOP_greater : printf( "DBOP_greater" ); break;
        case DBOP_greater_equal : printf( "DBOP_greater_equal" ); break;
        case DBOP_equal_all : printf( "DBOP_equal_all" ); break;
        case DBOP_not_equal_all : printf( "DBOP_not_equal_all" ); break;
        case DBOP_less_all : printf( "DBOP_less_all" ); break;
        case DBOP_less_equal_all : printf( "DBOP_less_equal_all" ); break;
        case DBOP_greater_all : printf( "DBOP_greater_all" ); break;
        case DBOP_greater_equal_all : printf( "DBOP_greater_equal_all" ); break;
        case DBOP_equal_any : printf( "DBOP_equal_any" ); break;
        case DBOP_not_equal_any : printf( "DBOP_not_equal_any" ); break;
        case DBOP_less_any : printf( "DBOP_less_any" ); break;
        case DBOP_less_equal_any : printf( "DBOP_less_equal_any" ); break;
        case DBOP_greater_any : printf( "DBOP_greater_any" ); break;
        case DBOP_greater_equal_any : printf( "DBOP_greater_equal_any" ); break;
        case DBOP_anybits : printf( "DBOP_anybits" ); break;
        case DBOP_allbits : printf( "DBOP_allbits" ); break;
        case DBOP_anybits_any : printf( "DBOP_anybits_any" ); break;
        case DBOP_allbits_any : printf( "DBOP_allbits_any" ); break;
        case DBOP_anybits_all : printf( "DBOP_anybits_all" ); break;
        case DBOP_allbits_all : printf( "DBOP_allbits_all" ); break;
        case DBOP_between : printf( "DBOP_between" ); break;
        case DBOP_between_unordered : printf( "DBOP_between_unordered" ); break;
        case DBOP_match : printf( "DBOP_match" ); break;
        case DBOP_match_unique : printf( "DBOP_match_unique" ); break;
        case DBOP_match_partial : printf( "DBOP_match_partial" ); break;
        case DBOP_match_partial_unique : printf( "DBOP_match_partial_unique" ); break;
        case DBOP_match_full : printf( "DBOP_match_full" ); break;
        case DBOP_match_full_unique : printf( "DBOP_match_full_unique" ); break;
        case DBOP_scalar_parameter : printf( "DBOP_scalar_parameter" ); break;
        case DBOP_scalar_function : printf( "DBOP_scalar_function" ); break;
        case DBOP_plus : printf( "DBOP_plus" ); break;
        case DBOP_minus : printf( "DBOP_minus" ); break;
        case DBOP_times : printf( "DBOP_times" ); break;
        case DBOP_over : printf( "DBOP_over" ); break;
        case DBOP_div : printf( "DBOP_div" ); break;
        case DBOP_modulo : printf( "DBOP_modulo" ); break;
        case DBOP_power : printf( "DBOP_power" ); break;
        case DBOP_like : printf( "DBOP_like" ); break;
        case DBOP_sounds_like : printf( "DBOP_sounds_like" ); break;
        case DBOP_like_any : printf( "DBOP_like_any" ); break;
        case DBOP_like_all : printf( "DBOP_like_all" ); break;
        case DBOP_is_INVALID : printf( "DBOP_is_INVALID" ); break;
        case DBOP_is_TRUE : printf( "DBOP_is_TRUE" ); break;
        case DBOP_is_FALSE : printf( "DBOP_is_FALSE" ); break;
        case DBOP_and : printf( "DBOP_and" ); break;
        case DBOP_or : printf( "DBOP_or" ); break;
        case DBOP_xor : printf( "DBOP_xor" ); break;
        case DBOP_equivalent : printf( "DBOP_equivalent" ); break;
        case DBOP_not : printf( "DBOP_not" ); break;
        case DBOP_implies : printf( "DBOP_implies" ); break;
        case DBOP_overlaps : printf( "DBOP_overlaps" ); break;
        case DBOP_case_condition : printf( "DBOP_case_condition" ); break;
        case DBOP_case_value : printf( "DBOP_case_value" ); break;
        case DBOP_nullif : printf( "DBOP_nullif" ); break;
        case DBOP_cast : printf( "DBOP_cast" ); break;
        case DBOP_coalesce : printf( "DBOP_coalesce" ); break;
        case DBOP_position : printf( "DBOP_position" ); break;
        case DBOP_extract : printf( "DBOP_extract" ); break;
        case DBOP_char_length : printf( "DBOP_char_length" ); break;
        case DBOP_octet_length : printf( "DBOP_octet_length" ); break;
        case DBOP_bit_length : printf( "DBOP_bit_length" ); break;
        case DBOP_substring : printf( "DBOP_substring" ); break;
        case DBOP_upper : printf( "DBOP_upper" ); break;
        case DBOP_lower : printf( "DBOP_lower" ); break;
        case DBOP_trim : printf( "DBOP_trim" ); break;
        case DBOP_translate : printf( "DBOP_translate" ); break;
        case DBOP_convert : printf( "DBOP_convert" ); break;
        case DBOP_string_concat : printf( "DBOP_string_concat" ); break;
        case DBOP_current_date : printf( "DBOP_current_date" ); break;
        case DBOP_current_time : printf( "DBOP_current_time" ); break;
        case DBOP_current_timestamp : printf( "DBOP_current_timestamp" ); break;
        case DBOP_content_select : printf( "DBOP_content_select" ); break;
        case DBOP_content : printf( "DBOP_content" ); break;
        case DBOP_content_freetext : printf( "DBOP_content_freetext" ); break;
        case DBOP_content_proximity : printf( "DBOP_content_proximity" ); break;
        case DBOP_content_vector_or : printf( "DBOP_content_vector_or" ); break;
        case DBOP_delete : printf( "DBOP_delete" ); break;
        case DBOP_update : printf( "DBOP_update" ); break;
        case DBOP_insert : printf( "DBOP_insert" ); break;
        case DBOP_min : printf( "DBOP_min" ); break;
        case DBOP_max : printf( "DBOP_max" ); break;
        case DBOP_count : printf( "DBOP_count" ); break;
        case DBOP_sum : printf( "DBOP_sum" ); break;
        case DBOP_avg : printf( "DBOP_avg" ); break;
        case DBOP_any_sample : printf( "DBOP_any_sample" ); break;
        case DBOP_stddev : printf( "DBOP_stddev" ); break;
        case DBOP_stddev_pop : printf( "DBOP_stddev_pop" ); break;
        case DBOP_var : printf( "DBOP_var" ); break;
        case DBOP_var_pop : printf( "DBOP_var_pop" ); break;
        case DBOP_first : printf( "DBOP_first" ); break;
        case DBOP_last : printf( "DBOP_last" ); break;
        case DBOP_in : printf( "DBOP_in" ); break;
        case DBOP_exists : printf( "DBOP_exists" ); break;
        case DBOP_unique : printf( "DBOP_unique" ); break;
        case DBOP_subset : printf( "DBOP_subset" ); break;
        case DBOP_proper_subset : printf( "DBOP_proper_subset" ); break;
        case DBOP_superset : printf( "DBOP_superset" ); break;
        case DBOP_proper_superset : printf( "DBOP_proper_superset" ); break;
        case DBOP_disjoint : printf( "DBOP_disjoint" ); break;
        case DBOP_pass_through : printf( "DBOP_pass_through" ); break;
        case DBOP_defined_by_GUID : printf( "DBOP_defined_by_GUID" ); break;
        case DBOP_text_command : printf( "DBOP_text_command" ); break;
        case DBOP_SQL_select : printf( "DBOP_SQL_select" ); break;
        case DBOP_prior_command_tree : printf( "DBOP_prior_command_tree" ); break;
        case DBOP_add_columns : printf( "DBOP_add_columns" ); break;
        case DBOP_column_list_anchor : printf( "DBOP_column_list_anchor" ); break;
        case DBOP_column_list_element : printf( "DBOP_column_list_element" ); break;
        case DBOP_command_list_anchor : printf( "DBOP_command_list_anchor" ); break;
        case DBOP_command_list_element : printf( "DBOP_command_list_element" ); break;
        case DBOP_from_list_anchor : printf( "DBOP_from_list_anchor" ); break;
        case DBOP_from_list_element : printf( "DBOP_from_list_element" ); break;
        case DBOP_project_list_anchor : printf( "DBOP_project_list_anchor" ); break;
        case DBOP_project_list_element : printf( "DBOP_project_list_element" ); break;
        case DBOP_row_list_anchor : printf( "DBOP_row_list_anchor" ); break;
        case DBOP_row_list_element : printf( "DBOP_row_list_element" ); break;
        case DBOP_scalar_list_anchor : printf( "DBOP_scalar_list_anchor" ); break;
        case DBOP_scalar_list_element : printf( "DBOP_scalar_list_element" ); break;
        case DBOP_set_list_anchor : printf( "DBOP_set_list_anchor" ); break;
        case DBOP_set_list_element : printf( "DBOP_set_list_element" ); break;
        case DBOP_sort_list_anchor : printf( "DBOP_sort_list_anchor" ); break;
        case DBOP_sort_list_element : printf( "DBOP_sort_list_element" ); break;
        case DBOP_alter_character_set : printf( "DBOP_alter_character_set" ); break;
        case DBOP_alter_collation : printf( "DBOP_alter_collation" ); break;
        case DBOP_alter_domain : printf( "DBOP_alter_domain" ); break;
        case DBOP_alter_index : printf( "DBOP_alter_index" ); break;
        case DBOP_alter_procedure : printf( "DBOP_alter_procedure" ); break;
        case DBOP_alter_schema : printf( "DBOP_alter_schema" ); break;
        case DBOP_alter_table : printf( "DBOP_alter_table" ); break;
        case DBOP_alter_trigger : printf( "DBOP_alter_trigger" ); break;
        case DBOP_alter_view : printf( "DBOP_alter_view" ); break;
        case DBOP_coldef_list_anchor : printf( "DBOP_coldef_list_anchor" ); break;
        case DBOP_coldef_list_element : printf( "DBOP_coldef_list_element" ); break;
        case DBOP_create_assertion : printf( "DBOP_create_assertion" ); break;
        case DBOP_create_character_set : printf( "DBOP_create_character_set" ); break;
        case DBOP_create_collation : printf( "DBOP_create_collation" ); break;
        case DBOP_create_domain : printf( "DBOP_create_domain" ); break;
        case DBOP_create_index : printf( "DBOP_create_index" ); break;
        case DBOP_create_procedure : printf( "DBOP_create_procedure" ); break;
        case DBOP_create_schema : printf( "DBOP_create_schema" ); break;
        case DBOP_create_synonym : printf( "DBOP_create_synonym" ); break;
        case DBOP_create_table : printf( "DBOP_create_table" ); break;
        case DBOP_create_temporary_table : printf( "DBOP_create_temporary_table" ); break;
        case DBOP_create_translation : printf( "DBOP_create_translation" ); break;
        case DBOP_create_trigger : printf( "DBOP_create_trigger" ); break;
        case DBOP_create_view : printf( "DBOP_create_view" ); break;
        case DBOP_drop_assertion : printf( "DBOP_drop_assertion" ); break;
        case DBOP_drop_character_set : printf( "DBOP_drop_character_set" ); break;
        case DBOP_drop_collation : printf( "DBOP_drop_collation" ); break;
        case DBOP_drop_domain : printf( "DBOP_drop_domain" ); break;
        case DBOP_drop_index : printf( "DBOP_drop_index" ); break;
        case DBOP_drop_procedure : printf( "DBOP_drop_procedure" ); break;
        case DBOP_drop_schema : printf( "DBOP_drop_schema" ); break;
        case DBOP_drop_synonym : printf( "DBOP_drop_synonym" ); break;
        case DBOP_drop_table : printf( "DBOP_drop_table" ); break;
        case DBOP_drop_translation : printf( "DBOP_drop_translation" ); break;
        case DBOP_drop_trigger : printf( "DBOP_drop_trigger" ); break;
        case DBOP_drop_view : printf( "DBOP_drop_view" ); break;
        case DBOP_foreign_key : printf( "DBOP_foreign_key" ); break;
        case DBOP_grant_privileges : printf( "DBOP_grant_privileges" ); break;
        case DBOP_index_list_anchor : printf( "DBOP_index_list_anchor" ); break;
        case DBOP_index_list_element : printf( "DBOP_index_list_element" ); break;
        case DBOP_primary_key : printf( "DBOP_primary_key" ); break;
        case DBOP_property_list_anchor : printf( "DBOP_property_list_anchor" ); break;
        case DBOP_property_list_element : printf( "DBOP_property_list_element" ); break;
        case DBOP_referenced_table : printf( "DBOP_referenced_table" ); break;
        case DBOP_rename_object : printf( "DBOP_rename_object" ); break;
        case DBOP_revoke_privileges : printf( "DBOP_revoke_privileges" ); break;
        case DBOP_schema_authorization : printf( "DBOP_schema_authorization" ); break;
        case DBOP_unique_key : printf( "DBOP_unique_key" ); break;
        case DBOP_scope_list_anchor : printf( "DBOP_scope_list_anchor" ); break;
        case DBOP_scope_list_element : printf( "DBOP_scope_list_element" ); break;
        case DBOP_content_table : printf( "DBOP_content_table" ); break;

        default : printf( "unknown DBOP" ); break;
    }

    printf( "\n" );

    PrintSpace( iLevel );
    printf( "wKind: (%d) ", pNode->wKind );
    switch( pNode->wKind )
    {
        case DBVALUEKIND_BYGUID :
        {
            printf( "DBVALUEKIND_BYGUID " );
            break;
        }
        case DBVALUEKIND_COLDESC :
        {
            printf( "DBVALUEKIND_COLDESC " );
            break;
        }
        case DBVALUEKIND_ID :
        {
            printf( "DBVALUEKIND_ID: " );
            if ( 0 == pNode->value.pdbidValue )
                printf( "NULL" );
            else
            {
                DBKIND kind = pNode->value.pdbidValue->eKind;

                if ( DBKIND_GUID        == kind ||
                     DBKIND_GUID_NAME   == kind ||
                     DBKIND_GUID_PROPID == kind )
                {
                    GUID &g = pNode->value.pdbidValue->uGuid.guid;
                    printf( "%8.8x-%4.4x-%4.4x-%2.2x%2.2x-"
                            "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                            g.Data1,g.Data2,g.Data3,g.Data4[0],
                            g.Data4[1],g.Data4[2],g.Data4[3],g.Data4[4],
                            g.Data4[5],g.Data4[6],g.Data4[7] );
                }
                if ( DBKIND_GUID_PROPID == kind ||
                     DBKIND_PROPID      == kind )
                    printf( " %d", pNode->value.pdbidValue->uName.ulPropid );
                if ( DBKIND_GUID_NAME == kind ||
                     DBKIND_NAME      == kind )
                    printf( " '%ws'", pNode->value.pdbidValue->uName.pwszName );
            }
            break;
        }
        case DBVALUEKIND_CONTENT :
        {
            printf( "DBVALUEKIND_CONTENT: " );
            if ( 0 == pNode->value.pdbcntntValue )
                printf( "NULL" );
            else
                printf( "'%ws', method %d, weight %d, lcid %#x",
                        pNode->value.pdbcntntValue->pwszPhrase,
                        pNode->value.pdbcntntValue->dwGenerateMethod,
                        pNode->value.pdbcntntValue->lWeight,
                        pNode->value.pdbcntntValue->lcid );
            break;
        }
        case DBVALUEKIND_CONTENTVECTOR :
        {
            printf( "DBVALUEKIND_CONTENTVECTOR: " );
            DBCONTENTVECTOR *p = pNode->value.pdbcntntvcValue;
            if ( 0 == p )
                printf( "NULL" );
            else
            {
                printf( "method %d, weight %d ",
                         p->dwRankingMethod,
                         p->lWeight );
            }
            break;
        }
        case DBVALUEKIND_GROUPINFO :
        {
            printf( "DBVALUEKIND_GROUPINFO " );
            break;
        }
        case DBVALUEKIND_PARAMETER :
        {
            printf( "DBVALUEKIND_PARAMETER " );
            break;
        }
        case DBVALUEKIND_PROPERTY :
        {
            printf( "DBVALUEKIND_PROPERTY " );
            break;
        }
        case DBVALUEKIND_SETFUNC :
        {
            printf( "DBVALUEKIND_SETFUNC " );
            break;
        }
        case DBVALUEKIND_SORTINFO :
        {
            printf( "DBVALUEKIND_SORTINFO: " );
            if ( 0 == pNode->value.pdbsrtinfValue )
                printf( "NULL" );
            else
                printf( "fDesc %d, lcid %#x",
                        pNode->value.pdbsrtinfValue->fDesc,
                        pNode->value.pdbsrtinfValue->lcid );
            break;
        }
        case DBVALUEKIND_TEXT :
        {
            printf( "DBVALUEKIND_TEXT " );
            break;
        }
        case DBVALUEKIND_COMMAND :
        {
            printf( "DBVALUEKIND_COMMAND " );
            break;
        }
        case DBVALUEKIND_MONIKER :
        {
            printf( "DBVALUEKIND_MONIKER " );
            break;
        }
        case DBVALUEKIND_ROWSET :
        {
            printf( "DBVALUEKIND_ROWSET " );
            break;
        }
        case DBVALUEKIND_LIKE :
        {
            printf( "DBVALUEKIND_LIKE " );
            break;
        }
        case DBVALUEKIND_CONTENTPROXIMITY :
        {
            printf( "DBVALUEKIND_CONTENTPROXIMITY " );
            break;
        }
        case DBVALUEKIND_CONTENTSCOPE :
        {
            printf( "DBVALUEKIND_CONTENTSCOPE " );
            if ( 0 == pNode->value.pdbcntntscpValue )
                printf( "NULL" );
            else
                printf( "dwFlags %#x, pwszElementValue %ws",
                        pNode->value.pdbcntntscpValue->dwFlags,
                        pNode->value.pdbcntntscpValue->pwszElementValue );
            break;
        }
        case DBVALUEKIND_CONTENTTABLE :
        {
            printf( "DBVALUEKIND_CONTENTTABLE " );
            if ( 0 == pNode->value.pdbcntnttblValue )
                printf( "NULL" );
            else
                printf( "machine %ws, catalog %ws",
                        pNode->value.pdbcntnttblValue->pwszMachine,
                        pNode->value.pdbcntnttblValue->pwszCatalog );
            break;
        }
        case DBVALUEKIND_IDISPATCH :
        {
            printf( "DBVALUEKIND_IDISPATCH " );
            break;
        }
        case DBVALUEKIND_IUNKNOWN :
        {
            printf( "DBVALUEKIND_IUNKNOWN " );
            break;
        }
        case DBVALUEKIND_EMPTY :
        {
            printf( "DBVALUEKIND_EMPTY " );
            break;
        }
        case DBVALUEKIND_NULL :
        {
            printf( "DBVALUEKIND_NULL " );
            break;
        }
        case DBVALUEKIND_I2 :
        {
            printf( "DBVALUEKIND_I2: %d", pNode->value.sValue );
            break;
        }
        case DBVALUEKIND_I4 :
        {
            printf( "DBVALUEKIND_I4: %d", pNode->value.lValue );
            break;
        }
        case DBVALUEKIND_R4 :
        {
            printf( "DBVALUEKIND_R4: %f", pNode->value.flValue );
            break;
        }
        case DBVALUEKIND_R8 :
        {
            printf( "DBVALUEKIND_R8: %lf", pNode->value.dblValue );
            break;
        }
        case DBVALUEKIND_CY :
        {
            printf( "DBVALUEKIND_CY " );
            break;
        }
        case DBVALUEKIND_DATE :
        {
            printf( "DBVALUEKIND_DATE " );
            break;
        }
        case DBVALUEKIND_BSTR :
        {
            printf( "DBVALUEKIND_BSTR: '%ws'", pNode->value.pbstrValue );
            break;
        }
        case DBVALUEKIND_ERROR :
        {
            printf( "DBVALUEKIND_ERROR: %d", pNode->value.scodeValue );
            break;
        }
        case DBVALUEKIND_BOOL :
        {
            printf( "DBVALUEKIND_BOOL: %d", pNode->value.fValue );
            break;
        }
        case DBVALUEKIND_VARIANT :
        {
            printf( "DBVALUEKIND_VARIANT " );

            // Indexing Service uses PROPVARIANTs (extended VARIANTs)

            DisplayVariant( (PROPVARIANT *) pNode->value.pvarValue );
            break;
        }
        case DBVALUEKIND_I1 :
        {
            printf( "DBVALUEKIND_I1: %d", pNode->value.schValue );
            break;
        }
        case DBVALUEKIND_UI1 :
        {
            printf( "DBVALUEKIND_UI1: %u", pNode->value.uchValue );
            break;
        }
        case DBVALUEKIND_UI2 :
        {
            printf( "DBVALUEKIND_UI2: %u", pNode->value.usValue );
            break;
        }
        case DBVALUEKIND_UI4 :
        {
            printf( "DBVALUEKIND_UI4: %u", pNode->value.ulValue );
            break;
        }
        case DBVALUEKIND_I8 :
        {
            printf( "DBVALUEKIND_I8: %I64d", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_UI8 :
        {
            printf( "DBVALUEKIND_UI8: %I64u", pNode->value.llValue );
            break;
        }
        case DBVALUEKIND_GUID :
        {
            printf( "DBVALUEKIND_GUID " );
            break;
        }
        case DBVALUEKIND_BYTES :
        {
            printf( "DBVALUEKIND_BYTES " );
            break;
        }
        case DBVALUEKIND_STR :
        {
            printf( "DBVALUEKIND_STR: '%s'", pNode->value.pzValue );
            break;
        }
        case DBVALUEKIND_WSTR :
        {
            printf( "DBVALUEKIND_WSTR: '%ws'", pNode->value.pwszValue );
            break;
        }
        case DBVALUEKIND_NUMERIC :
        {
            printf( "DBVALUEKIND_NUMERIC " );
            break;
        }
        case DBVALUEKIND_DBDATE :
        {
            printf( "DBVALUEKIND_DBDATE " );
            break;
        }
        case DBVALUEKIND_DBTIME :
        {
            printf( "DBVALUEKIND_DBTIME " );
            break;
        }
        case DBVALUEKIND_DBTIMESTAMP :
        {
            printf( "DBVALUEKIND_DBTIMESTAMP " );
            break;
        }
        default :
        {
            printf( "unknown DBVALUEKIND " );
            break;
        }
    }

    printf( "\n" );

    if ( pNode->pctFirstChild )
    {
        PrintSpace( iLevel );
        printf( "first child:\n" );
        DisplayCommandTree( pNode->pctFirstChild, iLevel + 1 );
    }

    if ( pNode->pctNextSibling )
    {
        PrintSpace( iLevel );
        printf( "next sibling:\n" );
        DisplayCommandTree( pNode->pctNextSibling, iLevel + 1 );
    }

    if ( 0 == iLevel )
        printf( "\n" );
} //DisplayCommandTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cipt\cipt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cipt.cxx
//
//  Contents:   Pipe tracing
//
//  History:    21 Nov 1997     DLee    Created
//
//--------------------------------------------------------------------------

#include <windows.h>

STDAPI Before(
    HANDLE  hPipe,
    ULONG   cbWrite,
    void *  pvWrite,
    ULONG & rcbWritten,
    void *& rpvWritten )
{
    rcbWritten = cbWrite;
    rpvWritten = pvWrite;

    return S_OK;
} //Before

STDAPI After(
    HANDLE hPipe,
    ULONG  cbWrite,
    void * pvWrite,
    ULONG  cbWritten,
    void * pvWritten,
    ULONG  cbRead,
    void * pvRead )
{
    return S_OK;
} //After

extern "C"
{
BOOL APIENTRY DllInit(HANDLE hInst, DWORD fdwReason, LPVOID lpReserved)
{
    return TRUE;
} //DllInit
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cidump\cidump.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1997-1998
//
//  File:       cidump.cxx
//
//  Contents:   CI catalog dump utility
//
//  History:    09-Apr-97       SitaramR          Created
//
//----------------------------------------------------------------------------

#define _OLE32_
#define __QUERY__

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <stddef.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <imagehlp.h>
#include <lmcons.h>

#define _DCOM_
#define _CAIROSTG_

#include <cidebnot.h>
#include <cierror.h>

#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <oleext.h>
#include <oledberr.h>
#include <oledb.h>
#include <query.h>
#include <stgprop.h>
#include <filter.h>
#include <filterr.h>
#include <vquery.hxx>
#include <restrict.hxx>

//
// Base services
//

#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <dynarray.hxx>
#include <dynstack.hxx>
#include <dblink.hxx>
#include <cisem.hxx>
#include <thrd32.hxx>
#include <readwrit.hxx>
#include <ci.h>

//
// Debug files from
//

#include <cidebug.hxx>
#include <vqdebug.hxx>

//
// CI-specific
//

#include <align.hxx>
#include <memser.hxx>
#include <memdeser.hxx>

#include <tgrow.hxx>
#include <funypath.hxx>
#include <params.hxx>
#include <key.hxx>
#include <keyarray.hxx>
#include <irest.hxx>
#include <cursor.hxx>
#include <idxids.hxx>
#include <dberror.hxx>

// property-related macros and includes

#include <propapi.h>
#include <propstm.hxx>
extern UNICODECALLOUTS UnicodeCallouts;
#define DebugTrace( x, y, z )
#ifdef PROPASSERTMSG
#undef PROPASSERTMSG
#endif
#define PROPASSERTMSG( x, y )

#include <rcstrmhd.hxx>
#include <xact.hxx>
#include <pidxtbl.hxx>

#include "cistore.hxx"
#include "physidx.hxx"

#include "pcomp.hxx"
#include "cidir.hxx"

DECLARE_INFOLEVEL(ci)
//DECLARE_INFOLEVEL(vq)


//extern BOOL ExceptDllMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved );

unsigned fVerbose = 0;        // Verbose mode dumps all keys, wids and occurrences
unsigned fStats = 0;          // Just dump wid/occ counts.
unsigned fFullStats = 0;          // Just dump wid/occ counts.
unsigned fKeys = 0;           // Key info
unsigned fDistribution = 0;           // Key distribution info
unsigned fOccurrences = 0;           // Occurrence distribution info

extern "C" GUID CLSID_CTextIFilter = CLSID_TextIFilter;

DWORD Bytes( BitOffset & boff )
{
    return ( boff.Page() * CI_PAGE_SIZE ) + ( ( boff.Offset() + 7 ) / 8 );
}

ULONGLONG BitDistance( BitOffset & b1, BitOffset & b2 )
{
    ULONGLONG bA = ((ULONGLONG) b1.Page() * (ULONGLONG) ( CI_PAGE_SIZE * 8) ) + b1.Offset();
    ULONGLONG bB = ((ULONGLONG) b2.Page() * (ULONGLONG) ( CI_PAGE_SIZE * 8) ) + b2.Offset();

    return ( bB - bA );
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Purpose:    Returns a codepage from a locale
//
//  Arguments:  [lcid]  --  Locale
//
//  History:    09-Apr-97   SitaramR    Created
//
//----------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    const BUFFER_LENGTH = 10;
    WCHAR wcsCodePage[BUFFER_LENGTH];

    int cwc = GetLocaleInfoW( lcid, LOCALE_IDEFAULTANSICODEPAGE, wcsCodePage, BUFFER_LENGTH );

    //
    // If error, return Ansi code page
    //
    if ( cwc == 0 )
    {
         ciDebugOut(( DEB_ERROR, "GetLocaleInfoW for lcid %d returned %d\n", lcid, GetLastError() ));

         return CP_ACP;
    }

    return wcstoul( wcsCodePage, 0 , 10 );
}

void Usage()
{
    printf( "Usage: cidump <catalog path> [-e indexid] [-d] [-s] [-f] [-v] [-w workid]\n"
            "       -d : Distribution of keys in documents (key, wid, occ)\n"
            "       -e : Exclude this index\n"
            "       -k : Print keys with #files, #occ, pid, size\n"
            "       -s : Stats only\n"
            "       -f : Full Stats only (for all keys)\n"
            "       -v : Verbose (full occurrence information)\n"
            "       -w : Data for this workid only\n\n"
            "Example: cidump e:\\testdump\\catalog.wci\n" );
}

void DumpDirectoryKey( unsigned i, CDirectoryKey & Key )
{
    BitOffset bo;
    Key.Offset( bo );
    printf( "  key %d  cb 0x%x, PropId 0x%x, opage 0x%x, obits 0x%x\n",
            i,
            Key.Count(),
            Key.PropId(),
            bo.Page(),
            bo.Offset() );
} //DumpDirectoryKey

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Purpose:    Main dump routine
//
//  History:    09-Apr-97   SitaramR    Created
//              02-Nov-98   KLam        Passed disk space to leave to CiStorage
//
//----------------------------------------------------------------------------

int __cdecl main( int argc, char * argv[] )
{
    char * pszCatDir = argv[1];
    WORKID widTarget = 0xFFFFFFFF;

    INDEXID  aExclude[100];
    unsigned cExclude = 0;

    if ( argc < 2 )
    {
        Usage();
        return 0;
    }

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'e':
            case 'E':
                i++;
                aExclude[cExclude] = strtoul( argv[i], 0, 16 );
                cExclude++;
                break;

            case 's':
            case 'S':
                fStats = 1;
                break;

            case 'd':
            case 'D':
                fDistribution = 1;
                break;

            case 'f':
            case 'F':
                fFullStats = 1;
                break;

            case 'k':
            case 'K':
                fKeys = 1;
                break;

            case 'o':
            case 'O':
                fOccurrences = 1;
                break;

            case 'v':
            case 'V':
                fVerbose = 1;
                break;

            case 'w':
            case 'W':
                i++;
                widTarget = strtoul( argv[i], 0, 10 );
                break;

            default:
                Usage();
                return 0;
            }
        }
        else
            pszCatDir = argv[i];
    }

    if ( fKeys )
    {
        fFullStats = 0;
        fStats = 0;
        fVerbose = 0;
    }

    if ( fDistribution )
    {
        fFullStats = 0;
        fStats = 0;
        fVerbose = 0;
        fKeys = 0;
        fOccurrences = 0;
    }

    if ( fOccurrences )
    {
        fFullStats = 0;
        fStats = 0;
        fVerbose = 0;
        fKeys = 0;
        fDistribution = 0;
    }

    if ( (pszCatDir[0] != '\\' || pszCatDir[1] != '\\') &&
         (pszCatDir[0] == '\0' || pszCatDir[1] != ':' || pszCatDir[2] != '\\') )
    {
        printf("Use full path name for catalog path!\n\n");
        Usage();
        return 1;
    }

    WCHAR wszCatDir[MAX_PATH];

    LocaleToCodepage( GetSystemDefaultLCID() );

    ULONG cwcActual = MultiByteToWideChar( LocaleToCodepage( GetSystemDefaultLCID() ),
                                           0,
                                           pszCatDir,
                                           strlen( pszCatDir ) + 1,
                                           wszCatDir,
                                           MAX_PATH );

    //ExceptDllMain( 0, DLL_PROCESS_ATTACH, 0 );

    //
    // Keep stats on where we are when we die...
    //

    CIndexRecord recCrash;
    CKeyBuf      keyCrash;
    BitOffset    boffCrash;

    ULONG maxOccCounts = 1024;

    TRY
    {
        ULONGLONG * aOccCounts = new ULONGLONG[ maxOccCounts ];
        ULONGLONG * acbOccCounts = new ULONGLONG[ maxOccCounts ];

        CTransaction xact;
        XPtr<CiStorage> xStorage( new CiStorage( wszCatDir,
                                                 *((ICiCAdviseStatus *)0),
                                                 CI_MIN_DISK_SPACE_TO_LEAVE_DEFAULT ) );

        XPtr<PIndexTable> xIndexTable( xStorage->QueryIndexTable( xact ) );

        SIndexTabIter xIndexIter( xIndexTable->QueryIterator() );

        if ( xIndexIter->Begin() )
        {
            CIndexRecord record;

            while ( xIndexIter->NextRecord( record ) )
            {
                if ( record.Type() == itMaster || record.Type() == itShadow )
                {
                    //
                    // Do we want to skip this one?
                    //

                    for ( unsigned i = 0; i < cExclude; i++ )
                    {
                        if ( aExclude[i] == record.Iid() )
                            break;
                    }

                    if ( i < cExclude )
                        continue;

                    recCrash = record;
                    boffCrash.Init( 0, 0 );

                    if ( !fKeys && !fDistribution && !fOccurrences )
                    {
                        if ( record.Type() == itMaster )
                            printf( "Index master: " );
                        else
                            printf( "Index shadow: " );

                        printf( "Object id = 0x%x, Index id = 0x%x, MaxWorkid = 0x%x\n",
                                record.ObjectId(),
                                record.Iid(),
                                record.MaxWorkId() );
                    }

                    ULONG maxWid = record.MaxWorkId();

                    SStorageObject xStorageObj( xStorage->QueryObject( record.ObjectId() ) );

                    PMmStream * pStream = xStorage->QueryExistingIndexStream( xStorageObj.GetObj(),
                                                                          PStorage::eOpenForRead  );
                    XPtr<PMmStream> xStream( pStream );
                    CPhysIndex *pPhysIndex = new CPhysIndex ( *xStorage.GetPointer(),
                                                              xStorageObj.GetObj(),
                                                              record.ObjectId(),
                                                              PStorage::eOpenForRead,
                                                              xStream );
                    Win4Assert( 0 == xStream.GetPointer() );

                    XPtr<CPhysIndex> xPhysIndex( pPhysIndex );

                    CiDirectory *pDir = (CiDirectory *) xStorage->QueryExistingDirectory( xStorageObj.GetObj(),
                                                                                      PStorage::eOpenForRead );
                    XPtr<CiDirectory> xDir( pDir);

                    unsigned cLevel1 = xDir->Level1Count();
                    unsigned cLevel2 = xDir->Level2Count();

                    if ( !fKeys && !fDistribution && !fOccurrences )
                    {
                        printf( "directory has %d level 1 and %d level 2 keys\n",
                                cLevel1, cLevel2 );

                        if ( fVerbose )
                        {
                            for ( unsigned i = 0; i < cLevel1; i++ )
                                DumpDirectoryKey( i, xDir->GetLevel1Key( i ) );

                            for ( i = 0; i < cLevel2; i++ )
                                DumpDirectoryKey( i, xDir->GetLevel2Key( i ) );
                        }
                    }

                    ULONGLONG cOccInIndex = 0;
                    ULONGLONG cWidsWithOneOcc = 0;
                    ULONGLONG cWidsWith5OrLessOcc = 0;
                    ULONGLONG cWidsWithOcc = 0;
                    ULONG cKeysWithOneWid = 0;
                    ULONG cKeysInIndex = 0;
                    ULONG cbMinimumKey = 100000;
                    ULONG cbMaximumKey = 0;
                    ULONGLONG cBitsForOcc = 0;
                    ULONGLONG cBitsForWid = 0;
                    ULONGLONG cBitsForKey = 0;
                    ULONG cKeysInMoreThanHalfWids = 0;
                    ULONG cOccMinOverall = 0xffffffff;
                    ULONG cOccMaxOverall = 0;

                    ZeroMemory( aOccCounts, sizeof( ULONGLONG ) * maxOccCounts );
                    ZeroMemory( acbOccCounts, sizeof( ULONGLONG ) * maxOccCounts );

                    CPersDeComp *pDecomp = new CPersDeComp( *xDir.GetPointer(),
                                                            record.Iid(),
                                                            *xPhysIndex.GetPointer(),
                                                            record.MaxWorkId(),
                                                            TRUE,
                                                            TRUE );
                    XPtr<CPersDeComp> xDecomp( pDecomp );

                    const CKeyBuf *pKey;
                    BitOffset off;
                    xDecomp->GetOffset( off );

                    BitOffset boffBefore;
                    boffBefore.Init( 0, 0 );

                    for ( pKey = xDecomp->GetKey();
                          pKey != NULL;
                          pKey = xDecomp->GetNextKey() )
                    {
                        BitOffset boAfterKey;
                        xDecomp->GetOffset( boAfterKey );
                        cBitsForKey += BitDistance( boffBefore, boAfterKey );

                        cKeysInIndex++;

                        keyCrash = *pKey;
                        xDecomp->GetOffset( boffCrash );
                        BOOL fFirst = TRUE;

                        unsigned cWid = 0;
                        unsigned cOccTotal = 0;
                        unsigned cOccMin = 0xFFFFFFFF;
                        unsigned cOccMax = 0;

                        BitOffset boBeforeWid;
                        xDecomp->GetOffset( boBeforeWid );

                        if ( fDistribution )
                            printf( "%ws", pKey->GetStr() );

                        for ( WORKID wid = xDecomp->WorkId();
                              wid != widInvalid;
                              wid = xDecomp->NextWorkId() )
                        {
                            BitOffset boAfterWid;
                            xDecomp->GetOffset( boAfterWid );
                            cBitsForWid += BitDistance( boBeforeWid, boAfterWid );

                            cWidsWithOcc++;

                            xDecomp->GetOffset( boffCrash );
                            cWid++;
                            if ( fFirst )
                            {
                                if ( fVerbose || fFullStats || wid == widTarget )
                                {
                                    printf( "     Key size = 0x%x, pid = 0x%x, buffer = %ws, "
                                            "near page %u (0x%x), bit offset %u (0x%x) --> File offset 0x%x\n",
                                            pKey->Count(),
                                            pKey->Pid(),
                                            pKey->GetStr(),
                                            boffCrash.Page(), boffCrash.Page(),
                                            boffCrash.Offset(), boffCrash.Offset(),
                                            boffCrash.Page() * CI_PAGE_SIZE + (boffCrash.Offset() + 7)/8 );

                                    if ( !fKeys )
                                        fFirst = FALSE;
                                }
                            }

                            if ( (fVerbose && 0 == widTarget) ||
                                 wid == widTarget )
                                printf( "\t  wid = 0x%x, MaxOcc = 0x%x, OccCount = 0x%x, "
                                        "near page %u (0x%x), bit offset %u (0x%x) --> File offset 0x%x, "
                                        "\n\t  Occurrences = ",
                                        wid,
                                        xDecomp->MaxOccurrence(),
                                        xDecomp->OccurrenceCount(),
                                        boffCrash.Page(), boffCrash.Page(),
                                        boffCrash.Offset(), boffCrash.Offset(),
                                        boffCrash.Page() * CI_PAGE_SIZE + (boffCrash.Offset() + 7)/8 );

                            unsigned cOcc = 0;

                            BitOffset bo1;
                            xDecomp->GetOffset( bo1 );

                            for ( OCCURRENCE occ = xDecomp->Occurrence();
                                  occ != OCC_INVALID;
                                  occ = xDecomp->NextOccurrence() )
                            {
                                xDecomp->GetOffset( boffCrash );
                                cOcc++;

                                if ( (fVerbose && 0 == widTarget) ||
                                     wid == widTarget )
                                    printf( "0x%x ", occ );
                            }

                            if ( cOcc >= maxOccCounts )
                            {
                                ULONG newMax = cOcc * 2;

                                ULONGLONG *a1 = new ULONGLONG[ newMax ];
                                ULONGLONG *a2 = new ULONGLONG[ newMax ];

                                ZeroMemory( a1, sizeof( ULONGLONG ) * newMax );
                                ZeroMemory( a2, sizeof( ULONGLONG ) * newMax );

                                RtlCopyMemory( a1, aOccCounts, sizeof( ULONGLONG ) * maxOccCounts );
                                RtlCopyMemory( a2, acbOccCounts, sizeof( ULONGLONG ) * maxOccCounts );

                                delete [] aOccCounts;
                                delete [] acbOccCounts;
                                aOccCounts = a1;
                                acbOccCounts = a2;

                                maxOccCounts = newMax;
                            }

#if 0
                            if ( cOcc >= 500 )
                            {
                                printf( "cocc %d in wid %d, pid %#x, len %d, %ws\n",
                                        cOcc, wid, pKey->Pid(),
                                        pKey->StrLen(),
                                        pKey->GetStr() );

                                printf( "  cb %d: ", pKey->Count() );
                                BYTE const * pb = pKey->GetBuf();
                                for ( ULONG i = 0; i < pKey->Count(); i++ )
                                    printf( "  %#x", pb[i] );
                                printf( "\n" );
                            }
#endif

                            BitOffset bo2;
                            xDecomp->GetOffset( bo2 );
                            ULONG cDelta = (ULONG) BitDistance( bo1, bo2 );
                            cBitsForOcc += cDelta;

                            aOccCounts[ cOcc ]++;
                            acbOccCounts[ cOcc ] += cDelta;

//                            if ( fOccurrences )
//                                printf( "%d, %d\n", cOcc, cDelta );

                            cOccInIndex += cOcc;

                            if ( 1 == cOcc )
                                cWidsWithOneOcc++;

                            if ( cOcc <= 5 )
                                cWidsWith5OrLessOcc++;

                            if ( (fVerbose && 0 == widTarget) ||
                                 wid == widTarget )
                                printf( "\n" );

                            cOccTotal += cOcc;

                            if ( cOcc > cOccMax )
                                cOccMax = cOcc;

                            if ( cOcc < cOccMin )
                                cOccMin = cOcc;

                            xDecomp->GetOffset( boBeforeWid );
                        }

                        if ( 1 == cWid )
                            cKeysWithOneWid++;

                        if ( cWid >= ( maxWid/2 ) )
                        {
                            printf( "key with >= half wids (%u):\n", cWid );

                            printf( "  pid %#x, len %d, %ws\n",
                                    pKey->Pid(),
                                    pKey->StrLen(),
                                    pKey->GetStr() );

                            printf( "  cb %d: ", pKey->Count() );
                            BYTE const * pb = pKey->GetBuf();
                            for ( ULONG i = 0; i < pKey->Count(); i++ )
                                printf( "  %#x", pb[i] );
                            printf( "\n" );

                            cKeysInMoreThanHalfWids++;
                        }

                        BitOffset boffAfter;
                        xDecomp->GetOffset( boffAfter );

                        DWORD b = Bytes( boffAfter ) - Bytes( boffBefore );

                        if ( b < cbMinimumKey )
                            cbMinimumKey = b;

                        if ( b > cbMaximumKey )
                            cbMaximumKey = b;

                        // Print this data:
                        //   # of files with the key
                        //   # of occurrences of key in all files
                        //   property id
                        //   # of bytes taken by this key in the index
                        //   string form of the key
                        //

                        if ( fKeys )
                            printf( "%7u %10u %4u %7u %ws\n",
                                    cWid,
                                    cOccTotal,
                                    pKey->Pid(),
                                    b,
                                    pKey->GetStr() );

                        boffBefore = boffAfter;

                        if ( cOccMin < cOccMinOverall )
                            cOccMinOverall = cOccMin;

                        if ( cOccMax > cOccMaxOverall )
                            cOccMaxOverall = cOccMax;

                        if ( fFullStats )
                            printf( "%u Workid(s), Total Occ = %u, Min Occ = %u, Max Occ = %u\n",
                                    cWid, cOccTotal, cOccMin, cOccMax );

                        if ( fDistribution )
                            printf( "! %d! %d\n", cWid, cOccTotal );
                    }

                    BitOffset boEnd;
                    xDecomp->GetOffset( boEnd );
                    BitOffset boStart;

                    if ( fOccurrences )
                        for ( ULONG i = 0; i <= cOccMaxOverall; i++ )
                        {
                            printf( "%I64u, ", aOccCounts[ i ] );
                            printf( "%I64u\n", acbOccCounts[ i ] / 8 );
                        }

                    if ( !fDistribution && !fKeys )
                    {
                        printf( "cWidsWithOcc %I64u\n", cWidsWithOcc );
                        printf( "bytes in index: %I64u\n", BitDistance( boStart, boEnd ) / 8 );

                        printf( "max workid %d\n", maxWid );
                        printf( "cKeysInIndex: %d\n", cKeysInIndex );
                        printf( "cOccInIndex %I64u\n", cOccInIndex );
                        printf( "cWidsWithOneOcc %I64u\n", cWidsWithOneOcc );
                        printf( "cWidsWith5OrLessOcc %I64u\n", cWidsWith5OrLessOcc );
                        printf( "cKeysWithOneWid %d\n", cKeysWithOneWid );
                        printf( "cKeysInMoreThanHalfWids %d\n", cKeysInMoreThanHalfWids );

                        printf( "cOccMaxOverall %d\n", cOccMaxOverall );
                        printf( "cOccMinOverall %d\n", cOccMinOverall );

                        printf( "maximum key bytes %d\n", cbMaximumKey );
                        printf( "minimum key bytes %d\n", cbMinimumKey );
                        printf( "bytes for occ data: %I64u\n", ( cBitsForOcc / 8 ) );
                        printf( "bytes for key data: %I64u\n", ( cBitsForKey / 8 ) );
                        printf( "bytes for wid data: %I64u\n", ( cBitsForWid / 8 ) );

                        printf( "total for o+k+w data: %I64u\n", ( cBitsForOcc/8 + cBitsForKey/8 + cBitsForWid/8 ) );
                    }
                }
                else if ( !fKeys && !fDistribution && !fOccurrences )
                {
                    switch ( record.Type() )
                    {
                    case itZombie:
                        printf( "Zombie:       " );
                        break;

                    case itDeleted:
                        printf( "Deleted:      " );
                        break;

                    case itPartition:
                         printf( "Partition:    " );
                         break;

                    case itChangeLog:
                        printf( "ChangeLog:    " );
                        break;

                    case itFreshLog:
                        printf( "FreshLog:     " );
                        break;

                    case itPhraseLat:
                        printf( "Phrase Lat:   " );
                        break;

                    case itKeyList:
                        printf( "Key List:     " );
                        break;

                    case itMMLog:
                        printf( "MM Log:       " );
                        break;

                    case itNewMaster:
                        printf( "New Master:   " );
                        break;

                    case itMMKeyList:
                        printf( "MM Key List:  " );
                        break;
                    } // switch

                    printf( "Object id = 0x%x, Index id = 0x%x, MaxWorkid = 0x%x\n",
                            record.ObjectId(),
                            record.Iid(),
                            record.MaxWorkId() );
                }  // if
            } // while
        } // if
        else
            printf( "0 records found in index table\n" );

        delete [] aOccCounts;
        delete [] acbOccCounts;
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == e.GetErrorCode() )
        {
            printf("Sharing violation -- Is cisvc running?\n");
        }
        else
        {
            printf( "Caught exception 0x%x in %s 0x%x\n",
                    e.GetErrorCode(),
                    ( recCrash.Type() == itMaster ) ? "master index" : "shadow index",
                    recCrash.Iid() );

            printf( "\tProcessing key: %ws (pid = 0x%x)\n", keyCrash.GetStr(), keyCrash.Pid() );

            printf( "\tNear page %u (0x%x), bit offset %u (0x%x) --> File offset 0x%x\n",
                    boffCrash.Page(), boffCrash.Page(),
                    boffCrash.Offset(), boffCrash.Offset(),
                    boffCrash.Page() * CI_PAGE_SIZE + (boffCrash.Offset() + 7)/8 );
        }
    }
    END_CATCH

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\cxxifilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       cxxifilt.cxx
//
//  Contents:   C++ filter 'class factory'.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <filtreg.hxx>

long gulcInstances = 0;

extern "C" CLSID TYPID_CxxIFilter = {
    0x96fe75e0,
    0xa581,
    0x101a,
    { 0xb5, 0x53, 0x08, 0x00, 0x2b, 0x33, 0xb0, 0xe6 }
};

extern "C" CLSID CLSID_CxxIFilter = {
    0xC1BCD320,
    0xBF96,
    0x11CD,
    { 0xB5, 0x79, 0x08, 0x00, 0x2B, 0x30, 0xBF, 0xEB }
};

extern "C" CLSID CLSID_CxxClass = {
    0x96fe75e1,
    0xa581,
    0x101a,
    { 0xb5, 0x53, 0x08, 0x00, 0x2b, 0x33, 0xb0, 0xe6 }
};

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::CxxIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterBase::CxxIFilterBase()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::~CxxIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterBase::~CxxIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterBase::QueryInterface( REFIID riid,
                                                        void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterBase::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::CxxIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterCF::CxxIFilterCF()
{
    _uRefs = 1;
    long c = InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::~CxxIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CxxIFilterCF::~CxxIFilterCF()
{
    long c = InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterCF::QueryInterface( REFIID riid,
                                                      void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOTIMPL;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CxxIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CxxIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        pIUnk = new CxxIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        if( SUCCEEDED(sc) )
            pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CxxIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( memcmp( &cid, &CLSID_CxxIFilter, sizeof(cid) ) == 0
          || memcmp( &cid, &CLSID_CxxClass, sizeof(cid) ) == 0 )
            pResult = (IUnknown *) new CxxIFilterCF;
        else
            sc = E_NOINTERFACE;

        if( pResult )
        {
            sc = pResult->QueryInterface( iid, ppvObj );
            pResult->Release(); // Release extra refcount from QueryInterface
        }
    }
    CATCH(CException, e)
    {
        if ( pResult )
            pResult->Release();

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( 0 == gulcInstances )
        return( S_OK );
    else
        return( S_FALSE );
}

SClassEntry const aCxxClasses[] =
{
    { L".cpp", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".hpp", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".cxx", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".hxx", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".c",   L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".h",   L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".w",   L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".acf", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".idl", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".inl", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
    { L".odl", L"CxxFile", L"Class for C and C++ Files", L"{96fe75e1-a581-101a-b553-08002b33b0e6}", L"Class for C and C++ Files" },
};

SHandlerEntry const CxxHandler =
{
    L"{5f2cb400-bf96-11cd-b579-08002b30bfeb}",
    L"C++ persistent handler",
    L"{c1bcd320-bf96-11cd-b579-08002b30bfeb}",
};

SFilterEntry const CxxFilter =
{
    L"{c1bcd320-bf96-11cd-b579-08002b30bfeb}",
    L"C++ IFilter",
    L"cxxflt.dll",
    L"Both"
};

DEFINE_DLLREGISTERFILTER( CxxHandler, CxxFilter, aCxxClasses )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\cxxflt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       CXXFLT.CXX
//
//  Contents:   C and Cxx Filter
//
//  History:    07-Oct-93   AmyA        Created
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

extern "C" GUID CLSID_CxxIFilter;

GUID guidCPlusPlus = { 0x8DEE0300, \
                       0x16C2, 0x101B, \
                       0xB1, 0x21, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 };

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::CxxIFilter, public
//
//  Synopsis:   Constructor
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CxxIFilter::CxxIFilter()
        : _state(FilterDone),
          _ulLastTextChunkID(0),
          _ulChunkID(0),
          _pTextFilt(0),
          _pPersFile(0),
          _cAttrib(0),
          _pAttrib(0),
          _pTextStream(0),
          _locale(0)         // the default locale
{
}

const FULLPROPSPEC fpsContents = { PSGUID_STORAGE, PRSPEC_PROPID, PID_STG_CONTENTS };

BOOL IsContents( FULLPROPSPEC const & fps )
{
   return ( !memcmp( &fps, &fpsContents, sizeof fpsContents ) );
} //IsContents

BOOL FPSMatch( FULLPROPSPEC const & fpsA, FULLPROPSPEC const & fpsB )
{
    if ( fpsA.guidPropSet != fpsB.guidPropSet )
        return FALSE;

    if ( fpsA.psProperty.ulKind != fpsB.psProperty.ulKind )
        return FALSE;

    if ( PRSPEC_PROPID == fpsA.psProperty.ulKind )
        return ( fpsA.psProperty.propid == fpsB.psProperty.propid );

    if ( PRSPEC_LPWSTR != fpsA.psProperty.ulKind )
        return FALSE;

    return ( !wcscmp( fpsA.psProperty.lpwstr,
                      fpsB.psProperty.lpwstr ) );
} //FPSMatch

void FPSCopy( FULLPROPSPEC & fpsTo, FULLPROPSPEC const & fpsFrom )
{
    fpsTo.guidPropSet = fpsFrom.guidPropSet;
    fpsTo.psProperty.ulKind = fpsFrom.psProperty.ulKind;

    if ( PRSPEC_PROPID == fpsFrom.psProperty.ulKind )
    {
        fpsTo.psProperty.propid = fpsFrom.psProperty.propid;
        return;
    }

    if ( PRSPEC_LPWSTR == fpsFrom.psProperty.ulKind )
    {
        unsigned cwc = 1 + wcslen( fpsFrom.psProperty.lpwstr );
        fpsTo.psProperty.lpwstr = (LPWSTR) CoTaskMemAlloc( cwc );
        wcscpy( fpsTo.psProperty.lpwstr, fpsFrom.psProperty.lpwstr );
    }
} //FPSCopy

void FPSFree( FULLPROPSPEC &fps )
{
    if ( ( PRSPEC_LPWSTR == fps.psProperty.ulKind ) &&
         ( 0 != fps.psProperty.lpwstr ) )
    {
        CoTaskMemFree( fps.psProperty.lpwstr );
        fps.psProperty.lpwstr = 0;
    }
} //FPSFree

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::~CxxIFilter, public
//
//  Synopsis:   Destructor
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CxxIFilter::~CxxIFilter()
{
    delete [] _pAttrib;

    if ( _pTextFilt )
        _pTextFilt->Release();

    if ( _pPersFile )
        _pPersFile->Release();

    delete _pTextStream;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::Init, public
//
//  Synopsis:   Initializes instance of text filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array aAttributes
//              [aAttributes] -- array of attributes
//              [pfBulkyObject] -- indicates whether this object is a
//                                 bulky object
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::Init( ULONG grfFlags,
                                          ULONG cAttributes,
                                          FULLPROPSPEC const * aAttributes,
                                          ULONG * pFlags )
{
    CTranslateSystemExceptions translate;

    SCODE sc = S_OK;

    TRY
    {
        _ulLastTextChunkID = 0;
        _ulChunkID = 0;

        if( cAttributes > 0 )
        {
            _state = FilterProp;

            _cAttrib = cAttributes;
            if ( 0 != _pAttrib )
            {
                delete [] _pAttrib;
                _pAttrib = 0;
            }

            _pAttrib = new CFps [_cAttrib];

            for ( ULONG i = 0; i < cAttributes; i++ )
            {
                if ( _state != FilterContents && IsContents( aAttributes[i] ) )
                    _state = FilterContents;

                _pAttrib[i].Copy( aAttributes[i] );
            }
        }
        else if ( 0 == grfFlags || (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
        {
            _state = FilterContents;
        }
        else
        {
            _state = FilterDone;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if ( FAILED( sc ) )
        return sc;

    return _pTextFilt->Init( 0,
                             1,
                             &fpsContents,
                             pFlags );
} //Init

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetChunk, public
//
//  Synopsis:   Gets the next chunk and returns chunk information in pStat
//
//  Arguments:  [pStat] -- for chunk information
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetChunk( STAT_CHUNK * pStat )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if (_state == FilterNextProp)
        {
            _state = FilterProp;
        }
        //
        // All chunks of plain text come first.
        //

        if ( _state == FilterContents )
        {
            sc = _pTextFilt->GetChunk( pStat );

            if ( SUCCEEDED(sc) )
            {
                pStat->locale = 0;  // use the default word breaker
                _locale = 0;
                _ulLastTextChunkID = pStat->idChunk;
            }
            else if ( sc == FILTER_E_END_OF_CHUNKS )
            {
                _ulChunkID = _ulLastTextChunkID;

                ULONG Flags;

                sc = _pTextFilt->Init( 0,
                                       1,
                                       &fpsContents,
                                       &Flags );

                if ( SUCCEEDED(sc) )
                {
                    delete _pTextStream;
                    _pTextStream = new CFilterTextStream (_pTextFilt);
                    if (SUCCEEDED (_pTextStream->GetStatus()))
                    {
                        _cxxParse.Init( _pTextStream );
                        _state = FilterProp;
                    }
                    else
                        _state = FilterDone;
                }
                else
                    _state = FilterDone;
            }
        }

        if ( _state == FilterProp && SUCCEEDED(sc) )
        {
            while ( TRUE )
            {
                if (_cxxParse.Parse())
                {
                    pStat->attribute.guidPropSet = guidCPlusPlus;
                    pStat->attribute.psProperty = _cxxParse.GetAttribute();

                    for ( unsigned i = 0; i < _cAttrib; i++ )
                        if ( _pAttrib[i].IsMatch( pStat->attribute ) )
                            break;

                    if ( _cAttrib == 0 || i < _cAttrib )     // Property should be returned
                    {
                        pStat->idChunk = ++_ulChunkID;
                        pStat->breakType = CHUNK_EOS;
                        pStat->flags = CHUNK_TEXT;
                        pStat->locale = _locale;

                        FILTERREGION regionSource;
                        // what's the source of this derived property?
                        _cxxParse.GetRegion ( regionSource );
                        pStat->idChunkSource = regionSource.idChunk;
                        pStat->cwcStartSource = regionSource.cwcStart;
                        pStat->cwcLenSource = regionSource.cwcExtent;

                        sc = S_OK;
                        break;
                    }
                }
                else
                {
                    _state = FilterValue;
                    break;
                }
            }
        }

        if ( _state == FilterNextValue )
        {
            _cxxParse.SkipValue();
            _state = FilterValue;
        }

        if ( _state == FilterValue )
        {
            while ( TRUE )
            {
                if ( _cxxParse.GetValueAttribute( pStat->attribute.psProperty ) )
                {
                    pStat->attribute.guidPropSet = guidCPlusPlus;

                    for ( unsigned i = 0; i < _cAttrib; i++ )
                        if ( _pAttrib[i].IsMatch( pStat->attribute ) )
                            break;

                    if ( _cAttrib == 0 || i < _cAttrib )     // Property should be returned
                    {
                        pStat->flags = CHUNK_VALUE;
                        pStat->locale = _locale;

                        _state = FilterNextValue;
                        sc = S_OK;
                        break;
                    }
                    else
                        _cxxParse.SkipValue();
                }
                else
                {
                    _state = FilterDone;
                    break;
                }
            }
        }

        if (_state == FilterDone || !SUCCEEDED(sc))
        {
            sc = FILTER_E_END_OF_CHUNKS;
            _state = FilterDone;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetText, public
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of characters in buffer
//              [awcBuffer] -- buffer for text
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetText( ULONG * pcwcBuffer,
                                             WCHAR * awcBuffer )
{
    if ( _state == FilterValue || _state == FilterNextValue )
        return FILTER_E_NO_TEXT;

    if ( _state == FilterContents )
    {
        return _pTextFilt->GetText( pcwcBuffer, awcBuffer );
    }
    else if ( _state == FilterProp )
    {

        if ( _cxxParse.GetTokens( pcwcBuffer, awcBuffer ))
        {
            _state = FilterNextProp;
            return FILTER_S_LAST_TEXT;
        }
        else
            return S_OK;
    }
    else if ( _state == FilterNextProp )
    {
        return FILTER_E_NO_MORE_TEXT;
    }
    else
    {
        Win4Assert ( _state == FilterDone );
        return FILTER_E_NO_MORE_TEXT;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetValue, public
//
//  Synopsis:   Not implemented for the text filter
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    if ( _state == FilterContents )
        return _pTextFilt->GetValue( ppPropValue );

    if ( _state == FilterDone )
        return FILTER_E_NO_MORE_VALUES;

    if ( _state != FilterNextValue )
        return FILTER_E_NO_VALUES;

    *ppPropValue = _cxxParse.GetValue();
    _state = FilterValue;

    if ( 0 == *ppPropValue )
        return FILTER_E_NO_MORE_VALUES;
    else
        return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- location of text
//              [riid]    -- Interface Id
//              [ppunk]   -- returned interface
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::BindRegion( FILTERREGION origPos,
                                                REFIID riid,
                                                void ** ppunk )
{
    return _pTextFilt->BindRegion( origPos, riid, ppunk );
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_CxxIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    07-Oct-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnLoadTextFilter g_pLoadTextFilter = 0;

SCODE MyLoadTextFilter( WCHAR const *pwc, IFilter **ppFilter )
{
    if ( 0 == g_pLoadTextFilter )
    {
        // Dummy call to CIState to force query.dll to be always loaded

        CIState( 0, 0, 0 );

        g_pLoadTextFilter = (PFnLoadTextFilter) GetProcAddress( GetModuleHandle( L"query.dll" ), "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return g_pLoadTextFilter( pwc, ppFilter );
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode]      -- the mode to load the file in
//
//  History:    07-Oct-93   AmyA           Created.
//
//  Notes:      dwMode must be either 0 or STGM_READ.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    SCODE sc = MyLoadTextFilter( pszFileName, &_pTextFilt );

    if ( SUCCEEDED(sc) )
    {
        //
        // Load file
        //

        sc = _pTextFilt->QueryInterface( IID_IPersistFile, (void **) &_pPersFile );

        if ( SUCCEEDED(sc) )
        {
            sc = _pPersFile->Load( pszFileName, dwMode );
        }
        else
        {
            _pTextFilt->Release();
            _pTextFilt = 0;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::SaveCompleted(LPCWSTR pszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned.
//
//  History:    09-Aug-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CxxIFilter::GetCurFile(LPWSTR * ppszFileName)
{
    return _pPersFile->GetCurFile( ppszFileName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\ci\isrch.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  isrchdmp.cx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//
// PLATFORM: Windows 2000
//
//--------------------------------------------------------------------------

#ifndef UNICODE
#define UNICODE
#endif

#include <stdio.h>
#include <windows.h>

#define DBINITCONSTANTS

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

#include <ntquery.h>
#include <filter.h>
#include <filterr.h>

#include "isearch.h"
#include "array.hxx"

extern CIPROPERTYDEF aCPPProperties[];

extern unsigned cCPPProperties;

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

const GUID guidStorage = PSGUID_STORAGE;

typedef void (__stdcall * PFnCIShutdown)(void);
typedef HRESULT (__stdcall * PFnMakeISearch)( ISearchQueryHits ** ppSearch,
                                              DBCOMMANDTREE * pRst,
                                              WCHAR const * pwcPath );
typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnCIShutdown g_pCIShutdown = 0;
PFnMakeISearch g_pMakeISearch = 0;
PFnLoadTextFilter g_pLoadTextFilter = 0;

#define UNICODE_PARAGRAPH_SEPARATOR 0x2029

ULONG CountCR( WCHAR * pCur, ULONG cwc, WCHAR * &pwcPrev )
{
    pwcPrev = pCur;
    WCHAR * pEnd = pCur + cwc;
    ULONG cCR = 0;

    while ( pCur < pEnd )
    {
        WCHAR c = *pCur;

        if ( L'\r' == c ||
             L'\n' == c ||
             UNICODE_PARAGRAPH_SEPARATOR == c )
        {
            cCR++;

            if ( ( L'\r' == c ) &&
                 ( (pCur+1) < pEnd ) &&
                 ( L'\n' == *(pCur+1) ) )
                pCur++;

            pwcPrev = pCur + 1;
        }

        pCur++;
    }

    return cCR;
} //CountCR

HRESULT WalkFile(
    TArray<FILTERREGION> & aHits,
    XInterface<IFilter> &  xIFilter,
    WCHAR const *          pwcFile,
    BOOL                   fPrintFile )
{
    ULONG ulFlags;

    HRESULT hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                                 IFILTER_INIT_CANON_HYPHENS |
                                 IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                                 0,
                                 0,
                                 &ulFlags );
    if ( FAILED( hr ) )
        return hr;

    ULONG lenSoFar = 0;
    int cChunk = 0;
    BOOL fSeenProp = FALSE;
    ULONG iHit = 0;
    ULONG cLines = 1;

    const ULONG cwcBufSize = 65536;
    WCHAR *pwc = new WCHAR[cwcBufSize + 1];

    if ( 0 == pwc )
        return E_OUTOFMEMORY;

    STAT_CHUNK statChunk;
    hr = xIFilter->GetChunk( &statChunk );

    while( SUCCEEDED( hr ) ||
           ( FILTER_E_LINK_UNAVAILABLE == hr ) ||
           ( FILTER_E_EMBEDDING_UNAVAILABLE == hr ) )
    {
        if ( SUCCEEDED( hr ) && (statChunk.flags & CHUNK_TEXT) )
        {
            // read the contents only

            if ( ( guidStorage == statChunk.attribute.guidPropSet ) &&
                 ( PRSPEC_PROPID == statChunk.attribute.psProperty.ulKind ) &&
                 ( PID_STG_CONTENTS == statChunk.attribute.psProperty.propid ) )
            {
                if ( CHUNK_NO_BREAK != statChunk.breakType )
                {
                    switch( statChunk.breakType )
                    {
                        case CHUNK_EOW:
                        case CHUNK_EOS:
                            break;
                        case CHUNK_EOP:
                        case CHUNK_EOC:
                            cLines++;
                            break;
                    }
                }

                ULONG iIntoChunk = 0;
                ULONG cwcRetrieved;
                ULONG iPrevLine = ~0;

                do
                {
                    cwcRetrieved = cwcBufSize;
                    hr = xIFilter->GetText( &cwcRetrieved, pwc );

                    pwc[cwcRetrieved] = 0;

                    // The buffer may be filled with zeroes.  Nice filter.
    
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( 0 != cwcRetrieved )
                            cwcRetrieved = __min( cwcRetrieved,
                                                  wcslen( pwc ) );

                        while ( ( iHit < aHits.Count() ) &&
                                ( aHits[iHit].idChunk == statChunk.idChunk ) &&
                                ( aHits[iHit].cwcStart >= iIntoChunk ) &&
                                ( aHits[iHit].cwcStart < ( iIntoChunk + cwcRetrieved ) ) )
                        {
                            WCHAR *pwcStart;

                            ULONG iLine = cLines +
                                          CountCR( pwc,
                                                   aHits[iHit].cwcStart - iIntoChunk,
                                                   pwcStart );

                            WCHAR *pwcEnd = wcschr( pwcStart, L'\r' );

                            if ( 0 == pwcEnd )
                                pwcEnd = wcschr( pwcStart, L'\n' );

                            if ( 0 != pwcEnd )
                                *pwcEnd = 0;

                            if ( iLine != iPrevLine )
                            {
                                if ( fPrintFile )
                                    wprintf( L"%ws", pwcFile );

                                wprintf( L"(%u): %ws\n", iLine, pwcStart );
                                iPrevLine = iLine;
                            }

                            if ( 0 != pwcEnd )
                                *pwcEnd = '\r';

                            iHit++;
                        }

                        WCHAR * pwcDummy;
                        cLines += CountCR( pwc, cwcRetrieved, pwcDummy );

                        iIntoChunk += cwcRetrieved;
                    }
                } while( SUCCEEDED( hr ) );
            }
        }

        hr = xIFilter->GetChunk ( &statChunk );
    }

    delete [] pwc;

    if ( FILTER_E_END_OF_CHUNKS == hr )
        hr = S_OK;

    return hr;
} //WalkFile

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcFilename]        - Name of the file
//              [pwcQueryRestrition] - The actual query string
//              [fPrintFile]         - whether to print the filename
//              [lcid]               - Locale of the query
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcFilename,
    WCHAR const * pwcQueryRestriction,
    BOOL          fPrintFile,
    BOOL          fDefineCPP,
    LCID          lcid )
{
    // Create an OLE DB query tree from a text restriction

    DBCOMMANDTREE * pTree;
    ULONG cDefinedProperties = fDefineCPP ? cCPPProperties : 0;
    HRESULT hr = CITextToSelectTree( pwcQueryRestriction,      // the query itself
                                     &pTree,                   // resulting tree
                                     cDefinedProperties,  // C++ properties
                                     aCPPProperties,      // C++ properties
                                     lcid );                   // default locale
    if ( FAILED( hr ) )
        return hr;

    // Make the ISearchQueryHits object

    XInterface<ISearchQueryHits> xISearch;
    hr = g_pMakeISearch( xISearch.GetPPointer(),
                         pTree,
                         0 );
    if ( FAILED( hr ) )
        return hr;

    XInterface<IFilter> xIFilter;
    hr = LoadIFilter( pwcFilename, 0, xIFilter.GetQIPointer() );
    if ( FAILED( hr ) )
    {
        // Fall back on the plain text filter

        hr = g_pLoadTextFilter( pwcFilename, xIFilter.GetPPointer() );
        if ( FAILED( hr ) )
            return hr;
    }

    ULONG ulFlags;
    hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         0,
                         0,
                         &ulFlags );
    if ( FAILED( hr ) )
        return hr;

    hr = xISearch->Init( xIFilter.GetPointer(), ulFlags );
    if ( FAILED( hr ) )
        return hr;

    //
    // Retrieve all the hit info.  the info is wrt output from the IFilter.
    // a separate pass over a different IFilter is needed to match up
    // text to the hit info.
    //

    TArray<FILTERREGION> aHits;

    ULONG cRegions;
    FILTERREGION* aRegion;
    hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    
    while ( S_OK == hr )
    {
        for ( ULONG i = 0; i < cRegions; i++ )
            aHits.Append( aRegion[i] );

        CoTaskMemFree( aRegion );
        hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    }

#if 0
    for ( ULONG i = 0; i < aHits.Count(); i++ )
        printf( "hit %d, chunk %d start %d extent %d\n",
                i, aHits[i].idChunk, aHits[i].cwcStart, aHits[i].cwcExtent );
#endif

    return WalkFile( aHits, xIFilter, pwcFilename, fPrintFile );
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   GetQueryFunctions
//
//  Synopsis:   Loads needed undocumented functions from query.dll.
//
//  Returns:    The module handle or 0 on failure.
//
//--------------------------------------------------------------------------

HINSTANCE GetQueryFunctions()
{
    HINSTANCE h = LoadLibrary( L"query.dll" );

    if ( 0 != h )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YAJPEAPEAUISearchQueryHits@@PEAVCDbRestriction@@PEBG@Z";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YGJPAPAUISearchQueryHits@@PAVCDbRestriction@@PBG@Z";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( h, pcCIShutdown );

        if ( 0 == g_pCIShutdown )
        {
            FreeLibrary( h );
            return 0;
        }

        g_pMakeISearch = (PFnMakeISearch) GetProcAddress( h, pcMakeISearch );

        if ( 0 == g_pMakeISearch )
        {
            FreeLibrary( h );
            return 0;
        }

        g_pLoadTextFilter = (PFnLoadTextFilter) GetProcAddress( h, "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
        {
            FreeLibrary( h );
            return 0;
        }
    }

    return h;
} //GetQueryFunctions

HINSTANCE PrepareForISearch()
{
    return GetQueryFunctions();
} //DoneWithISearch

void DoneWithISearch( HINSTANCE h )
{
    g_pCIShutdown();
    FreeLibrary( h );
} //DoneWithISearch

//+-------------------------------------------------------------------------
//
//  Function:   DoISearch
//
//  Synopsis:   Invoke ISearch on the file
//
//  Arguments:  [pwcRestriction] -- the query
//              [pwcFilename]    -- the file
//              [fPrintFile]     -- whether to print the filename
//              [lcid]           -- locale of the query
//
//--------------------------------------------------------------------------

HRESULT DoISearch(
    WCHAR const * pwcRestriction,
    WCHAR const * pwcFilename,
    BOOL          fPrintFile,
    BOOL          fDefineCPP,
    LCID          lcid )
{
    // Run the query

    return DoQuery( pwcFilename, pwcRestriction, fPrintFile, fDefineCPP, lcid );
} //DoISearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\cxx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       CXX.CXX
//
//  Contents:   C and C++ Filter
//
//  Classes:    CxxFilter
//
//  History:    26-Jun-92   BartoszM    Created
//              17-Oct-94   BartoszM    Rewrote
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::CxxScanner, public
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

CxxScanner::CxxScanner ()
        : _pStream(0),
          _fIgnorePreamble(FALSE),
          _fScanningPrepro(FALSE),
          _fIdFound(FALSE),
          _cLines( 0 )
{
    _buf[0] = L'\0';
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::Init, public
//
//  Arguments:  [pStream] -- stream for text
//
//  History:    24-Nov-93  AmyA            Created
//
//----------------------------------------------------------------------------

void CxxScanner::Init ( CFilterTextStream * pStream )
{
    _pStream = pStream;
    // Position scanner on a token
    Accept();
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::NextToken, public
//
//  Arguments:  [c] -- lookahead character
//
//  Returns:    Recognized token
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

CToken CxxScanner::NextToken( int c )
{
    BOOL fFirstTime = TRUE;

    // Loop until a token is recognized
    for(;;)
    {
        switch (c)
        {
        case -1:  // UNICODE EOF
            _token = tEnd;
            return _token;

        case L'\n':
            _cLines++;
            _fScanningPrepro = FALSE;
            c = _pStream->GetChar();
            break;

        case L'{':
            _token = tLBrace;
            return _token;

        case L'}':
            _token = tRBrace;
            return _token;

        case L';':
            _token = tSemi;
            return _token;

        case L',':
            if ( _fIgnorePreamble )
            {
                // skip comma in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tComma;
            return _token;

        case L'*':
            if ( _fIgnorePreamble )
            {
                // skip star in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tStar;
            return _token;

        case L'#':  // not a token!
            // consume preprocessor command
            _fScanningPrepro = TRUE;
            c = _pStream->GetChar();
            break;

        case L'(':
            if ( _fIgnorePreamble )
            {
                // skip parentheses in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tLParen;
            return _token;

        case L')':
            if ( _fIgnorePreamble )
            {
                // skip parentheses in the preamble
                c = _pStream->GetChar();
                break;
            }
            _token = tRParen;
            return _token;

        case L':':
            c = _pStream->GetChar();
            // ignore colons in the preamble
            if ( !_fIgnorePreamble && c == L':')
            {
               _token = tDoubleColon;
               return _token;
            }
            break;

        case L'/':  // not a token!
            // consume comment
            c = EatComment();
            break;

        case L'"':  // not a token!
            // consume string literal
            c = EatString();
            break;

        case L'\'':  // not a token!
            // consume character literal
            c = EatCharLiteral();
            break;

        default:

            // We don't really care about indentifiers.
            // We store them in the buffer so that when
            // we recognize a real token like :: or (
            // we can retrieve them.
            // Look out for 'class' 'struct' and 'union' though.

            if ( iswalpha((wint_t)c) || (c == L'_') || (c == L'~') )
            {
                _fIdFound = TRUE;
                
                // in preamble skip names except for the first
                // one, which is the name of the procedure

                if ( _fIgnorePreamble && !fFirstTime )
                {
                    c = SkipName(c);
                    continue;
                }
                else
                {
                    c = LoadName (c);
                    fFirstTime = FALSE;
                }

                if (!_fIgnorePreamble)
                {
                    // look for class/struct/union keywords

                    if ( wcscmp(_buf, L"class" ) == 0 )
                    {
                        _token = tClass;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"struct") == 0 )
                    {
                        _token = tStruct;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"union" ) == 0 )
                    {
                        _token = tUnion;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"interface" ) == 0 )
                    {
                        _token = tInterface;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"typedef" ) == 0 )
                    {
                        _token = tTypedef;
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"enum" ) == 0 )
                    {
                        _token = tEnum;
                        return _token;
                    }
                }

                if ( _fScanningPrepro )
                {
                    if ( wcscmp(_buf, L"define" ) == 0 )
                    {
                        _token = tDefine;
                        c = LoadName(c);
                        return _token;
                    }
                    else if ( wcscmp(_buf, L"include" ) == 0 )
                    {
                        _token = tInclude;
                        c = LoadIncludeFileName(c);
                        return _token;
                    }
                    else
                    {
                        c = EatPrepro();
                        _fScanningPrepro = FALSE;
                    }
                }
            }
            else // not recognized, continue scanning
            {
                c = _pStream->GetChar();
            }
            break;
        }   // end of switch
    }   // end of infinite loop

    return _token;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::SkipName, public
//
//  Returns:    Next character after identifier
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::SkipName(int c)
{
   int i = 0;

   do
   {
      c = _pStream->GetChar();
      i++;
   }
   while ( (iswalnum((wint_t)c) || (c == L'_')) && (i < MAXIDENTIFIER) );

   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::LoadName, public
//
//  Synopsis:   Scans and copies identifier into scanner's buffer
//
//  Arguments:  [c] -- GetChar character
//
//  Returns:    Next character after identifier
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::LoadName(int c)
{
   WCHAR * pCur = _buf;
   _pStream->GetRegion ( _region, -1, 0 );
   int i = 0;
   do
   {
      _buf[i++] = (WCHAR)c;
      c = _pStream->GetChar();
   }
   while ( (iswalnum((wint_t)c) || (c == L'_')) && (i < MAXIDENTIFIER));

   _region.cwcExtent = i;
   // c is not a symbol character

   _buf[i] = L'\0';

   //DbgPrint("LoadName: =================>  %ws\n", _buf);
   
   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::LoadIncludeFileName, public
//
//  Synopsis:   Scans and copies a file name following a
//              #include statement to internal buffer
//              If a path exists, it is ignored.
//              A '.' is converted to '_' because searching an id
//              with a '.' does not seem to work with ci.
//              For example, 
//              #include <\foo\bar\fname.h>  --> fname_h
//
//  Arguments:  [c] -- GetChar character
//
//  Returns:    Next character after the #include stmt
//
//  History:    10-June-2000 kumarp        Created
//
//----------------------------------------------------------------------------

int CxxScanner::LoadIncludeFileName(int c)
{
   WCHAR * pCur = _buf;
   int i = 0;

   // skip chars preceeding the file name
   do
   {
      c = _pStream->GetChar();       
   }
   while ((c == L'\t') || (c == L' ') || (c == L'"') || (c == L'<'));
       
   _pStream->GetRegion ( _region, -1, 0 );

   do
   {
      _buf[i++] = (WCHAR)c;
      if ((c == L'\\') || (c == L'/'))
      {
          // ignore path
          i = 0;
          _pStream->GetRegion ( _region, 0, 0 );
      }

      c = _pStream->GetChar();
//       if (c == L'.')
//       {
//           c = L'_';
//       }
   }
   while ((iswalnum((wint_t)c) || ( c == L'.' ) ||
           (c == L'_') || (c == L'\\') || (c == L'/')) &&
          (i < MAXIDENTIFIER));
   
   _region.cwcExtent = i;
   _buf[i] = L'\0';

   c = EatPrepro();

   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatComment, public
//
//  Synopsis:   Eats comments
//
//  Returns:    First non-comment character
//
//  Requires:   Leading '/' found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatComment()
{
   int c = _pStream->GetChar();

    if ( c == L'*')
    {
        // C style comment
        while ((c = _pStream->GetChar()) != EOF )
        {
            while ( c == L'*' )
            {
                c = _pStream->GetChar();

                if ( c == EOF )
                   return EOF;

                if ( c == L'/' )
                   return _pStream->GetChar();

            }
        }
    }
    else if ( c == L'/' )
    {
        // C++ style comment
        while ((c = _pStream->GetChar()) != EOF )
        {
            if ( c == L'\n' )
                break;
        }
    }

    return c;
}
//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatString, public
//
//  Synopsis:   Eats string literal
//
//  Returns:    First non-string character
//
//  Requires:   Leading '"' found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatString()
{
   int c;

   while ((c = _pStream->GetChar()) != EOF )
   {
      if ( c == L'"' )
      {
         c = _pStream->GetChar();
         break;
      }

      // eat backslashes
      // skip escaped quotes

      if ( c == L'\\' )
      {
         c = _pStream->GetChar();
         if ( c == EOF )
            return EOF;
      }
   }
   return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatCharLiteral, public
//
//  Synopsis:   Eats character literal
//
//  Returns:    First non-char-literal character
//
//  Requires:   Leading apostrophe ' found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatCharLiteral()
{
    int c;

    while ((c = _pStream->GetChar()) != EOF )
    {
        if ( c == L'\'' )
        {
            c = _pStream->GetChar();
            break;
        }

        // eat backslashes
        // skip escaped quotes

        if ( c == L'\\' )
        {
            c = _pStream->GetChar();
            if ( c == EOF )
                return EOF;
        }
    }
    return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxScanner::EatPrepro, public
//
//  Synopsis:   Eats preprocessor commands. Possibly multi-line.
//
//  Returns:    First non-preprocessor character
//
//  Requires:   Leading # found and scanned
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

int CxxScanner::EatPrepro()
{
    int c;

    _fScanningPrepro = FALSE;

    while ((c = _pStream->GetChar()) != EOF && (c != L'\n'))
    {
        if ( c == L'\\' ) // skip whatever follows backslash
        {
            c = _pStream->GetChar();
            if (c == L'\r')
                c = _pStream->GetChar();
            if ( c == EOF )
                return EOF;
        }
    }
    return c;
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxParser::CxxParser, public
//
//  Synopsis:   Initialize parser
//
//  Arguments:  [pStm] -- stream
//              [drep] -- data repository
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

CxxParser::CxxParser ()
        : _scope(0),
          _inClass(0),
          _fParsingTypedef(FALSE),
          _fParsingFnPtrTypedef(FALSE),
          _iVal(0)
{
    _strClass[0] = L'\0';
    _strName[0]  = L'\0';
    _attribute.ulKind = PRSPEC_LPWSTR;
    _attribute.lpwstr = PROP_CLASS;

    _psVal[Function].ulKind = PRSPEC_LPWSTR;
    _psVal[Function].lpwstr = PROP_FUNC;

    _psVal[Class].ulKind = PRSPEC_LPWSTR;
    _psVal[Class].lpwstr = PROP_CLASS;

    _psVal[Lines].ulKind = PRSPEC_LPWSTR;
    _psVal[Lines].lpwstr = PROP_LINES;

    _aVal[Function] = 0;
    _aVal[Class]    = 0;
    _aVal[Lines]    = 0;
}

CxxParser::~CxxParser()
{
    delete _aVal[Function];
    delete _aVal[Class];
    delete _aVal[Lines];
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxParser::Init, public
//
//  Synopsis:   Initialize parser
//
//  Arguments:  [pStream] -- stream
//
//  History:    24-Nov-93  AmyA            Created
//
//----------------------------------------------------------------------------

void CxxParser::Init ( CFilterTextStream * pStream )
{
    _scan.Init(pStream);
    _token = _scan.Token();
}

//+---------------------------------------------------------------------------
//
//  Member:     CxxParser::Parse, public
//
//  Synopsis:   Parse the file
//
//  History:    26-Jun-92  BartoszM        Created
//
//----------------------------------------------------------------------------

BOOL CxxParser::Parse()
{
    _cwcCopiedClass = 0;
    _cwcCopiedName = 0;

    while ( _token != tEnd)
    {
        switch ( _token )
        {
        case tTypedef:
            if ( !_fParsingTypedef )
            {
                _fParsingTypedef = TRUE;
                _typedefScope = _scope;
            }
            _token = _scan.Accept();
            break;

        case tSemi:
            if ( _fParsingTypedef && ( _scope == _typedefScope ))
            {
                ASSERT(_fParsingFnPtrTypedef == FALSE);
                SetName();
                //DbgPrint("tSemi: name: %ws, scope: %d\n", _strName, _scope);
                PutFunction();
                _fParsingTypedef = FALSE;
                _token = _scan.Accept();
                return TRUE;
            }
            _token = _scan.Accept();
            break;

        case tComma:
            if ( _fParsingTypedef && ( _scope == _typedefScope ))
            {
                ASSERT(_fParsingFnPtrTypedef == FALSE);
                SetName();
                //DbgPrint("tComma: name: %ws, scope: %d\n", _strName, _scope);
                PutFunction();
                _token = _scan.Accept();
                return TRUE;
            }
            _token = _scan.Accept();
            break;

        case tEnum:
            //DbgPrint("tEnum\n");
            //_scan.IgnorePreamble(TRUE);
            _token = _scan.Accept();
            //_scan.IgnorePreamble(FALSE);

            if ( _token == tLBrace )
            {
                // Good, we're inside a enum definition

                _scope++;
                SetName();
                //DbgPrint("tEnum: %ws\n", _strName);
                PutFunction();
                _token = _scan.Accept();
                return TRUE;
            }
            // otherwise it was a false alarm
            break;
            
        case tClass:
        case tStruct:
        case tUnion:
        case tInterface:

            // We have to recognize stuff like this:
            // class FOO : public bar:a, private b {
            // -----                               --
            // text between 'class' and left brace is
            // a preamble that the scanner will skip
            // If it's only a forward declaration, we
            // will stop at a semicolon and ignore the
            // whole business.

#if CIDBG == 1
            _classToken = _token;
#endif // CIDBG == 1

            // scan through stuff like
            // : public foo, private bar

            _scan.IgnorePreamble(TRUE);
            _token = _scan.Accept();
            _scan.IgnorePreamble(FALSE);

            // Ignore embedded classes
            if ( _inClass == 0 )
               SetClass();     // record class name for later

            if ( _token == tLBrace )
            {
                // Good, we're inside a class definition

                _inClass++;
                _scope++;
                PutClass ();
                _token = _scan.Accept();
                return TRUE;
            }
            // otherwise it was a false alarm

            break;

        case tDoubleColon:

            // Here we deal with constructs like
            // FOO::FOO ( int x ) : bar(state::ok), (true) {
            //    --    -                                  --
            // Text between left paren and left brace is preamble
            // and the scanner skips it. If we hit a semicolon
            // rather than left brace, we ignore the whole
            // construct (it was an invocation or something)

            SetClass();     // record class name just in case
            _token = _scan.Accept();
            if ( _token == tLParen )
            {
                SetName();  // record method name just in case

                _scan.IgnorePreamble(TRUE);
                _token = _scan.Accept();
                _scan.IgnorePreamble(FALSE);

                if ( _token == tLBrace )
                {
                    // Yes, we have method definition
                    _scope++;
                    _token = _scan.Accept();
                    PutMethod();
                    return TRUE;
                }
                // otherwise it was a false alarm
            }
            break;

        case tLParen:
            if ( _fParsingTypedef && ( _scope == _typedefScope ))
            {
                //
                // at present we only support fn-ptr typedefs
                // of the following type:
                // 
                // typedef void (*FnPtr1) ( int i, float f );
                // 

                //SetName();
                //DbgPrint("tLParen: name: %ws, scope: %d\n", _strName, _scope);
                _scan.SetIdFound(FALSE);
                _token = _scan.Accept();
                if ( ( _token == tStar ) && !_scan.IdFound() )
                {
                    _fParsingFnPtrTypedef = TRUE;
                }
                else
                {
                    //PutFunction();
                    _fParsingTypedef      = FALSE;
                    _fParsingFnPtrTypedef = FALSE;
                }
                
                _token = _scan.Accept();
            }
            else
            {
                SetName(); // record procedure name just in case

                // It may be an inline constructor
                // skip argument list and constructor stuff like
                // : Parent(blah), member(blah)

                _scan.IgnorePreamble(TRUE);
                _token = _scan.Accept();
                _scan.IgnorePreamble(FALSE);

                if ( _token == tLBrace )
                {
                    // Yes, it's a definition

                    if ( _inClass )
                    {
                        // inline method definition inside class definition
                        _scope++;
                        _token = _scan.Accept();
                        PutInlineMethod();
                        return TRUE;
                    }
                    else if ( _scope == 0 )
                    {
                        // function definitions
                        // in outer scope

                        _scope++;
                        PutFunction();
                        _token = _scan.Accept();
                        return TRUE;
                    }
                    // else continue--false alarm
                }
            }
            break;

        case tRParen:
            if ( _fParsingFnPtrTypedef && ( _scope == _typedefScope ))
            {
                SetName();
                //DbgPrint("tRParen: name: %ws, scope: %d\n", _strName, _scope);
                PutFunction();
                _fParsingTypedef      = FALSE;
                _fParsingFnPtrTypedef = FALSE;
                _token = _scan.Accept();
                return TRUE;
            }
            _token = _scan.Accept();
            break;
                
        case tEnd:
            return FALSE;

        case tLBrace:
            // keep track of scope
            _scope++;
            _token = _scan.Accept();
            break;

        case tRBrace:
            // keep track of scope and (nested) class scope
            _scope--;
            if ( _inClass > _scope )
            {
               _inClass--;
            }
            _token = _scan.Accept();
            break;

        case tDefine:
            SetName();
            PutFunction();
            _scan.EatPrepro();
            _token = _scan.Accept();
            return TRUE;

        case tInclude:
            SetName();
            PutFunction();
            _token = _scan.Accept();
            return TRUE;
                
        default:
            _token = _scan.Accept();
        }
    }

    if ( _aVal[Lines] == 0 )
    {
        _aVal[Lines] = new CPropVar;
        if ( 0 == _aVal[Lines] )
            THROW( CException( E_OUTOFMEMORY ) );
    }
    
    _aVal[Lines]->SetUI4( _scan.Lines() );

    return FALSE;   // we only end up here if _token == tEnd
}

void CxxParser::PutClass ()
{
    _tokenType = ttClass;
    _attribute.lpwstr = PROP_CLASS;
    _strName[0] = L'\0';

#if 0

    if ( _aVal[Class] == 0 )
    {
        _aVal[Class] = new CPropVar;
        if ( 0 == _aVal[Class] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Class]->SetLPWSTR( _strClass, _aVal[Class]->Count() );

#endif

    // PROP_CLASS, _strClass

    //DbgPrint("PutClass: class: %ws\n", _strClass);

#if CIDBG == 1
    if ( _classToken == tClass )
    {

        cxxDebugOut((DEB_ITRACE,"class %ws\n", _strClass ));
    }
    else if ( _classToken == tStruct )
    {

        cxxDebugOut((DEB_ITRACE, "struct %ws\n", _strClass ));
    }
    else if ( _classToken == tUnion )
    {

        cxxDebugOut((DEB_ITRACE, "union %ws\n", _strClass ));
    }
    else if ( _classToken == tInterface )
    {

        cxxDebugOut((DEB_ITRACE, "interface %ws\n", _strClass ));
    }
#endif // CIDBG == 1
}

void CxxParser::PutMethod ()
{
    _tokenType = ttMethod;
    _attribute.lpwstr = PROP_FUNC;

#if 0

    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CPropVar;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );

#endif

    cxxDebugOut((DEB_ITRACE, "%ws::%ws\n", _strClass, _strName ));
}

void CxxParser::PutInlineMethod ()
{
    _tokenType = ttInlineMethod;
    _attribute.lpwstr = PROP_FUNC;

#if 0

    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CPropVar;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );

#endif

    cxxDebugOut((DEB_ITRACE, "%ws::%ws\n", _strClass, _strName ));
}

void CxxParser::PutFunction ()
{
    _tokenType = ttFunction;
    _attribute.lpwstr = PROP_FUNC;
    _strClass[0] = L'\0';

#if 0
    if ( _aVal[Function] == 0 )
    {
        _aVal[Function] = new CPropVar;
        if ( 0 == _aVal[Function] )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    _aVal[Function]->SetLPWSTR( _strName, _aVal[Function]->Count() );
#endif

    //DbgPrint("PutFunction: func: %ws\n", _strName);
    cxxDebugOut((DEB_ITRACE, "function %ws\n", _strName ));
}

void CxxParser::GetRegion ( FILTERREGION& region )
{
    switch (_tokenType)
    {
    case ttClass:
        region = _regionClass;
        break;
    case ttFunction:
    case ttInlineMethod:
    case ttMethod:
        region = _regionName;
        break;
    }
}

BOOL CxxParser::GetTokens ( ULONG * pcwcBuffer, WCHAR * awcBuffer )
{
    ULONG cwc = *pcwcBuffer;
    *pcwcBuffer = 0;

    if (_strClass[0] != L'\0')
    {
        // We have a class name

        WCHAR * strClass = _strClass + _cwcCopiedClass;

        ULONG cwcClass = wcslen( strClass );
        if ( cwcClass > cwc )
        {
            wcsncpy( awcBuffer, strClass, cwc );
            _cwcCopiedClass += cwc;
            return FALSE;
        }
        wcscpy( awcBuffer, strClass );
        *pcwcBuffer = cwcClass;
        _cwcCopiedClass += cwcClass;
        awcBuffer[(*pcwcBuffer)++] = L' ';
    }

    if (_strName[0] == L'\0')
    {
        // it was only a class name
        awcBuffer[*pcwcBuffer] = L'\0';
        return TRUE;
    }

    cwc -= *pcwcBuffer;
    WCHAR * awc = awcBuffer + *pcwcBuffer;
    WCHAR * strName = _strName + _cwcCopiedName;
    ULONG cwcName = wcslen( strName );

    if ( cwcName > cwc )
    {
        wcsncpy( awc, strName, cwc );
        _cwcCopiedName += cwc;
        return FALSE;
    }
    wcscpy( awc, strName );
    *pcwcBuffer += cwcName;
    _cwcCopiedName += cwcName;
    return TRUE;
}

BOOL CxxParser::GetValueAttribute( PROPSPEC & ps )
{
    for ( ; _iVal <= Lines && 0 == _aVal[_iVal];  _iVal++ )
        continue;

    if ( _iVal > Lines )
        return FALSE;
    else
    {
        ps = _psVal[_iVal];

        return TRUE;
    }
}

PROPVARIANT * CxxParser::GetValue()
{
    if ( _iVal > Lines )
        return 0;

    CPropVar * pTemp = _aVal[_iVal];
    _aVal[_iVal] = 0;
    _iVal++;

    return (PROPVARIANT *)(void *)pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\fstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1994, Microsoft Corporation.
//
//  File:       fstrm.cxx
//
//  Contents:   Stream for transporting text from IFilter to cxx parser.
//
//  Classes:    CFilterTextStream
//
//  History:    01-Aug-93       AmyA        Created
//              17-Oct-94       BartoszM    Rewrote
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CFilterTextStream::CFilterTextStream, public
//
//  Synopsis:   Constructor
//
//  History:    01-Aug-93       AmyA        Created
//              17-Oct-94       BartoszM    Rewrote
//
//--------------------------------------------------------------------------

CFilterTextStream::CFilterTextStream(IFilter* pIFilter)
: CTextSource(_statChunk)
{
    iEnd = 0;
    iCur = 0;
    Win4Assert (pIFilter != 0);
    awcBuffer = _awcFilterBuffer;
    _sc = pIFilter->GetChunk( &_statChunk );
    if (SUCCEEDED(_sc))
    {
        _pFilter = pIFilter;
        pfnFillTextBuffer = CTextSource::FillBuf;
        _mapper.NewChunk ( _statChunk.idChunk, 0 );
        _pMapper = &_mapper;
        _sc = CTextSource::FillBuf( this );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterTextStream::GetMore, public
//
//  Synopsis:   Try to replenish the buffer
//
//  History:    16-Nov-94  BartoszM         Created
//
//----------------------------------------------------------------------------

int CFilterTextStream::GetMore()
{
    if (iCur == iEnd - 1)
    {
        _sc = FillBuf( this );
        // if there was no more data
        // the last lookahead was moved
        // to the beginning and
        // iCur == iEnd - 1
        // next time around it will be
        // iCur == iEnd
    }
    else
    {
        Win4Assert(iCur == iEnd);
        return -1;  // EOF
    }
    return awcBuffer[iCur++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    10-Aug-93       AmyA            Created
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <limits.h>
    #include <string.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <ctype.h>
}

#include <windows.h>

#include <oleext.h>
#include <ntquery.h>
#include <olectl.h>

#include <eh.h>

#include "minici.hxx"
#include "oledberr.h"
#include "filterr.h"
#include "cierror.h"
#include "query.h"
#include "tsource.hxx"
#include "mapper.hxx"
#include "pfilter.hxx"

#include "propwrap.hxx"
#include "cxxifilt.hxx"
#include "tmpprop.hxx"
#include "fstrm.hxx"
#include "cxx.hxx"
#include "cxxflt.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   MAPPER.CXX
//
//  Contents:   Search Key Repository
//
//  Classes:    CSourceMapper
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::Advance
//
//  Synopsis:   Advance the mapper after processing ccDelta characters
//
//  History:    30-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::Advance ( ULONG ccProcessed )
{
    _offInChunk += ccProcessed;
    if (_offSplit != 0)
    {
        // split buffer situation (two current chunks)
        if (ccProcessed >= _offSplit)
        {
            // got rid of leftover chunk
            _offInChunk = ccProcessed - _offSplit;
            _offSplit = 0;
            _idChunk = _idNewChunk;
        }
        else
            _offSplit -= ccProcessed;
    }
}

void CSourceMapper::NewChunk ( ULONG idChunk, ULONG ccBegin )
{
    if (ccBegin != 0)
    {
        _offSplit = ccBegin;
        _idNewChunk = idChunk;
    }
    else
    {
        _offSplit = 0;
        _idChunk = idChunk;
        _offInChunk = 0;
    }
    _ccLen = 0;
}

void CSourceMapper::NewDerivedChunk ( ULONG idChunkSource, ULONG ccBeginSource, ULONG ccLen )
{
    _idChunk = idChunkSource;
    _offInChunk = ccBeginSource;
    _offSplit = 0;
    _ccLen = ccLen;
}
//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::GetSrcRegion
//
//  Synopsis:   Returns source filter region for current position
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::GetSrcRegion ( FILTERREGION& region, ULONG len, ULONG ccOffsetInBuf )
{
    if (_offSplit == 0 || ccOffsetInBuf < _offSplit)
    {
        region.idChunk = _idChunk;
        if (_ccLen == 0)  // direct mapping
        {
            region.cwcStart = _offInChunk + ccOffsetInBuf;
            region.cwcExtent = len;
        }
        else  // map to whole region
        {
            region.cwcStart = _offInChunk;
            region.cwcExtent = _ccLen;
        }
    }
    else
    {
        region.idChunk = _idNewChunk;
        region.cwcStart = ccOffsetInBuf - _offSplit;
        region.cwcExtent = len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\cxxflt\tsource.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1994.
//
//  File:       TSource.cxx
//
//  Contents:   TEXT_SOURCE implementation
//
//  Classes:    CTextSource
//
//  History:    14-Apr-94   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::CTextSource, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pFilter] -- IFilter (source of data)
//              [Stat]    -- Chunk statistics
//
//  History:    01-Aug-93 AmyA      Created
//              14-Apr-94 KyleP     Sync with wordbreaker spec
//
//--------------------------------------------------------------------------

CTextSource::CTextSource( IFilter * pFilter, STAT_CHUNK & Stat, CSourceMapper* pMapper )
        : _pMapper (pMapper),
          _pFilter(pFilter),
          _Stat( Stat ),
          _sc( S_OK )
{
    iEnd = 0;
    iCur = 0;
    awcBuffer = _awcFilterBuffer;
    pfnFillTextBuffer = CTextSource::FillBuf;

    if (_pMapper)
    {
        if (_Stat.idChunk == _Stat.idChunkSource)
        {
            _pMapper->NewChunk ( _Stat.idChunk, 0 );
        }
        else
        {
            _pMapper->NewDerivedChunk (
                _Stat.idChunkSource,
                _Stat.cwcStartSource,
                _Stat.cwcLenSource);
        }
    }

    FillBuf( this );
}



//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::FillBuf, public
//
//  Synopsis:   Fills buffer with IFilter::GetText and IFilter::GetChunk
//
//  History:    01-Aug-93 AmyA      Created
//              20-Apr-94 KyleP     Sync with spec
//
//  Notes:      NOTE! In several places, this function casts const away
//              from awcBuffer.  This is an acceptable cast from const to
//              non-const. The buffer is const to the client but non-const
//              to the server.
//
//--------------------------------------------------------------------------

SCODE CTextSource::FillBuf( TEXT_SOURCE * pTextSource )
{
    CTextSource * pthis = (CTextSource *)pTextSource;

    //
    // Never continue past an error condition other than FILTER_E_NO_MORE_TEXT
    //

    if ( FAILED( pthis->_sc ) && pthis->_sc != FILTER_E_NO_MORE_TEXT )
        return( pthis->_sc );

    //
    // Move any existing text to beginning of buffer.
    //

    Win4Assert ( pthis->iEnd >= pthis->iCur );

    ULONG ccLeftOver = pthis->iEnd - pthis->iCur;

    if ( ccLeftOver > 0 )
    {
        RtlMoveMemory( (WCHAR *)pthis->awcBuffer,
                       &pthis->awcBuffer[pthis->iCur],
                       ccLeftOver * sizeof (WCHAR) );
    }

    if (pthis->_pMapper)
    {
        // this much has been processed from the current chunk
        pthis->_pMapper->Advance ( pthis->iCur );
    }

    pthis->iCur = 0;
    pthis->iEnd = ccLeftOver;
    ULONG ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
    const BUFFER_SLOP = 10;  // Buffer is attempted to be filled until BUFFER_SLOP remains

    //
    // Get some more text.  If *previous* call to GetText returned
    // FILTER_S_LAST_TEXT, or FILTER_E_NO_MORE_TEXT then don't even
    // bother trying.
    //

    if ( pthis->_sc == FILTER_S_LAST_TEXT || pthis->_sc == FILTER_E_NO_MORE_TEXT )
        pthis->_sc = FILTER_E_NO_MORE_TEXT;
    else
    {
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if 0
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }

        if ( pthis->_sc != FILTER_E_NO_MORE_TEXT )
        {
            //
            // Weird failure, hence return, else goto next chunk
            //
            return pthis->_sc;
        }
    }

    //
    // Go to next chunk, if necessary.
    //

    while ( pthis->_sc == FILTER_E_NO_MORE_TEXT )
    {
        pthis->_sc = pthis->_pFilter->GetChunk( &pthis->_Stat );

        if ( pthis->_sc == FILTER_E_END_OF_CHUNKS )
            return WBREAK_E_END_OF_TEXT;

        if ( FAILED( pthis->_sc ) )
            return( pthis->_sc );

        if ( pthis->_Stat.flags & CHUNK_VALUE )
        {
            pthis->_sc = FILTER_E_NO_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

        if ( pthis->_Stat.breakType != CHUNK_NO_BREAK )
        {
            pthis->_sc = WBREAK_E_END_OF_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

#if 0
        ciDebugOut(( DEB_WORDS, "TEXT SOURCE: NoBreak chunk\n" ));
#endif

        if (pthis->_pMapper)
        {
            ULONG idChunk = pthis->_Stat.idChunk;
            if (idChunk == pthis->_Stat.idChunkSource)
            {
                pthis->_pMapper->NewChunk ( idChunk, ccLeftOver );
            }
            else
            {
                pthis->_sc = WBREAK_E_END_OF_TEXT;
                return WBREAK_E_END_OF_TEXT;
            }
        }

        ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if 0
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }
    }

    if ( FAILED( pthis->_sc ) )
        return( pthis->_sc );

    if ( ccRead == 0 )
        return WBREAK_E_END_OF_TEXT;

    Win4Assert( pthis->iCur == 0 );
    Win4Assert( pthis->iEnd == ccLeftOver );

#if 0
    ciDebugOut(( DEB_WORDS, "TEXT SOURCE: Fill buffer with %d characters. %d left over\n",
                 pthis->iEnd, ccLeftOver ));
#endif

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::DebugPrintBuffer
//
//  Synopsis:   Debug print the text buffer
//
//  Arguments:  [pThis] -- Pointer to text source
//
//  History:    08-Apr-97   SitaramR      Created
//
//--------------------------------------------------------------------------

void CTextSource::DebugPrintBuffer( CTextSource *pthis )
{
#if 0
   if ( ciInfoLevel & DEB_WORDS )
      {
          ciDebugOut(( DEB_WORDS, "CTextSource::FillBuf -- iCur = %u, iEnd = %u\n",
                       pthis->iCur, pthis->iEnd ));

          BOOL fOk = TRUE;
          for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
          {
              if ( pthis->awcBuffer[i] > 0xFF )
              {
                  fOk = FALSE;
                  break;
              }
          }

          if ( fOk )
          {
              unsigned j = 0;
              WCHAR awcTemp[71];

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  awcTemp[j] = pthis->awcBuffer[i];
                  j++;

                  if ( j == sizeof(awcTemp)/sizeof(awcTemp[0]) - 1 )
                  {
                      awcTemp[j] = 0;
                      ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
                      j = 0;
                  }
              }

              awcTemp[j] = 0;
              ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
          }
          else
          {
              unsigned j = 0;

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  if ( 0 == j )
                      ciDebugOut(( DEB_WORDS, "%04X", pthis->awcBuffer[i] ));
                  else if ( 14 == j )
                  {
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X\n", pthis->awcBuffer[i] ));
                  }
                  else
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X", pthis->awcBuffer[i] ));

                  j++;

                  if ( j > 14 )
                      j = 0;
              }

              ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, "\n" ));
          }

      }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\isrchdmp\isearch.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __isearch_h__
#define __isearch_h__

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif  /* __ISearchQueryHits_FWD_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchQueryHits __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchQueryHits __RPC_FAR * This);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [in] */ IFilter __RPC_FAR *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitMoniker )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcMnk,
            /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *NextHitOffset )( 
            ISearchQueryHits __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcRegion,
            /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchQueryHits_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISearchQueryHits_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISearchQueryHits_Init(This,pflt,ulFlags)        \
    (This)->lpVtbl -> Init(This,pflt,ulFlags)

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)      \
    (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk)

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)  \
    (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion)

#endif /* COBJMACROS */


#endif  /* C style interface */



SCODE STDMETHODCALLTYPE ISearchQueryHits_Init_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [in] */ IFilter __RPC_FAR *pflt,
    /* [in] */ ULONG ulFlags);


void __RPC_STUB ISearchQueryHits_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitMoniker_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcMnk,
    /* [size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *__RPC_FAR *papMnk);


void __RPC_STUB ISearchQueryHits_NextHitMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE ISearchQueryHits_NextHitOffset_Proxy( 
    ISearchQueryHits __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcRegion,
    /* [size_is][out] */ FILTERREGION __RPC_FAR *__RPC_FAR *paRegion);


void __RPC_STUB ISearchQueryHits_NextHitOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISearchQueryHits_INTERFACE_DEFINED__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\filtdump\filtdump.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       filtdump.cxx
//
//  Contents:   IFilter dump utility
//
//  History:    30-Dec-97 KyleP     Added header
//
//--------------------------------------------------------------------------

#include <stdio.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <filterr.h>
#include <filter.h>
#include <ntquery.h>
#include <vquery.hxx>

BOOL fContentOnly = FALSE;
BOOL fOutputFile = FALSE;

void * pProtectedStart;
WCHAR * pwszProtectedBuf;
unsigned ccProtectedBuf = 100;

void Usage();

int _cdecl main( int argc, char * argv[] )
{
    if ( argc < 2 )
    {
        Usage();
        exit( 0 );
    }

    WCHAR wszBuffer[4096];
    WCHAR wszBuffer2[4096];
    char  szBuffer[4096];
    char  szOutputFile[MAX_PATH];
    ULONG cbWritten;
    char szDefault[] = "?";

    HRESULT hr = CoInitialize( 0 );

    if ( FAILED( hr ) )
        return 1;

    HANDLE hFile = GetStdHandle( STD_OUTPUT_HANDLE );

    int iFile = 1;

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'b':
            case 'B':
                iFile = i+1;
                fContentOnly = 1;
                break;

            case 'o':
            case 'O':
                fOutputFile = 1;
                if ( strlen( argv[i+1] ) >= sizeof szOutputFile ) 
                {
                    Usage();
                    return 1;
                }
                strcpy(szOutputFile, argv[i+1]);
                iFile = i+2;
                break;

            case 's':
            case 'S':
                iFile = i+2;
                i++;
                ccProtectedBuf = atoi( argv[i] );
                break;

            default:
                Usage();
                return 0;
            }
        }
    }

    if ( fOutputFile )
    {
        hFile = CreateFileA( szOutputFile,         // pointer to name of the file
                             GENERIC_WRITE,        // access (read-write) mode
                             FILE_SHARE_READ,      // share mode
                             0,                    // pointer to security attributes
                             CREATE_ALWAYS,        // how to create
                             0,                    // file attributes
                             0 );                  // template

        if ( INVALID_HANDLE_VALUE == hFile )
        {
            sprintf( szBuffer, "Error %d opening %s\n", GetLastError(), argv[iFile] );
            WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, strlen(szBuffer), &cbWritten, 0 );

            exit( 1 );
        }

        wszBuffer[0] = 0xFEFF;
        if (!fContentOnly)
            WriteFile( hFile, wszBuffer, sizeof(WCHAR), &cbWritten, 0 );
    }

    //
    // Allocate protected buffer
    //

    int cbProtectedBuf = ccProtectedBuf * sizeof(WCHAR);
    pProtectedStart = VirtualAlloc( 0, cbProtectedBuf + 4096 + 1, MEM_RESERVE, PAGE_READWRITE );
    VirtualAlloc( pProtectedStart, ((cbProtectedBuf + 4095) / 4096) * 4096, MEM_COMMIT, PAGE_READWRITE );
    pwszProtectedBuf = (WCHAR *) ((BYTE *)pProtectedStart + ((cbProtectedBuf + 4095) / 4096) * 4096 - cbProtectedBuf);


    for ( ; iFile < argc; iFile++ )
    {
        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
        {
            sprintf( szBuffer, "FILE: %s\n", argv[iFile] );

            if (!fContentOnly)
                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
        }
        else
        {
            mbstowcs( wszBuffer2, argv[iFile], sizeof(wszBuffer2)/sizeof(WCHAR) );
            swprintf( wszBuffer, L"FILE: %s\r\n", wszBuffer2 );

            if (!fContentOnly)
                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
        }

        WCHAR wcsPath[MAX_PATH];
        mbstowcs( wcsPath, argv[iFile], sizeof(wcsPath)/sizeof(WCHAR) );
        IFilter * pFilt = 0;

        SCODE sc = LoadIFilter( wcsPath, 0, (void **)&pFilt );

        if ( FAILED(sc) )
        {
            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                sprintf( szBuffer, "Error 0x%x loading IFilter\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
            }
            else
            {
                swprintf( wszBuffer, L"Error 0x%x loading IFilter\r\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
            }

            CIShutdown();

            exit( 1 );
        }

        //
        // Initialize filter.
        //

        ULONG Flags = 0;

        sc = pFilt->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                          IFILTER_INIT_HARD_LINE_BREAKS |
                          IFILTER_INIT_CANON_HYPHENS |
                          IFILTER_INIT_CANON_SPACES |
                          IFILTER_INIT_INDEXING_ONLY |
                          IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                          0,
                          NULL,
                          &Flags );


        if( FAILED(sc) )
        {
            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                sprintf( szBuffer, "Error 0x%x from IFilter::Init.\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
            }
            else
            {
                swprintf( wszBuffer, L"Error 0x%x from IFilter::Init.\r\n", sc );

                if (!fContentOnly)
                    WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
            }

            pFilt->Release();
            CIShutdown();
            exit( 1 );
        }

        if ( !fContentOnly && (Flags & IFILTER_FLAGS_OLE_PROPERTIES) )
        {
            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                sprintf( szBuffer, "**Additional Properties available via IPropertyStorage.\n\n", sc );
                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
            }
            else
            {
                swprintf( wszBuffer, L"**Additional Properties available via IPropertyStorage.\r\n\r\n", sc );
                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
            }
        }

        //
        // Loop through the chunks.
        //

        BOOL fText;
        STAT_CHUNK StatChunk;
        StatChunk.attribute.psProperty.ulKind = PRSPEC_PROPID;

        while (1)
        {
            WCHAR wcsBuffer[2048];

            sc = pFilt->GetChunk( &StatChunk );

            if ( FILTER_E_EMBEDDING_UNAVAILABLE == sc || FILTER_E_LINK_UNAVAILABLE == sc )
            {
                if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                {
                    sprintf( szBuffer, "Encountered an embed/link for which filter is not available.\n" );

                    if (!fContentOnly)
                        WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                }
                else
                {
                    swprintf( wszBuffer, L"Encountered an embed/link for which filter is not available.\r\n" );

                    if (!fContentOnly)
                        WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                }

                continue; //continue with other chunks.
            }

            if ( FAILED(sc) && sc != FILTER_E_END_OF_CHUNKS )
            {
                if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                {
                    sprintf( szBuffer, "IFilter::GetChunk returned 0x%x\n", sc );

                    if (!fContentOnly)
                        WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                }
                else
                {
                    swprintf( wszBuffer, L"IFilter::GetChunk returned 0x%x\r\n", sc );

                    if (!fContentOnly)
                        WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                }

                break;
            }

            if ( sc == FILTER_E_END_OF_CHUNKS )
                break;

            if ( CHUNK_TEXT == StatChunk.flags )
                fText = TRUE;
            if ( CHUNK_VALUE == StatChunk.flags )
                fText = FALSE;

            //
            // Put in the struct of chunk into the file if requested
            //

            int cc = 0;

            cc += swprintf( wszBuffer + cc, L"\r\n----------------------------------------------------------------------\r\n" );

            cc += swprintf( wszBuffer + cc, L"\t\tAttribute = %08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\\",
                         StatChunk.attribute.guidPropSet.Data1,
                         StatChunk.attribute.guidPropSet.Data2,
                         StatChunk.attribute.guidPropSet.Data3,
                         StatChunk.attribute.guidPropSet.Data4[0], StatChunk.attribute.guidPropSet.Data4[1],
                         StatChunk.attribute.guidPropSet.Data4[2], StatChunk.attribute.guidPropSet.Data4[3],
                         StatChunk.attribute.guidPropSet.Data4[4], StatChunk.attribute.guidPropSet.Data4[5],
                         StatChunk.attribute.guidPropSet.Data4[6], StatChunk.attribute.guidPropSet.Data4[7] );

            if ( StatChunk.attribute.psProperty.ulKind == PRSPEC_PROPID )
                cc += swprintf( wszBuffer + cc, L"%d\r\n", StatChunk.attribute.psProperty.propid );
            else
                cc += swprintf( wszBuffer + cc, L"%ws\r\n", StatChunk.attribute.psProperty.lpwstr );

            cc += swprintf( wszBuffer + cc, L"\t\tidChunk = %d\r\n", StatChunk.idChunk );
            cc += swprintf( wszBuffer + cc, L"\t\tBreakType = %d", StatChunk.breakType );

            switch ( StatChunk.breakType )
            {
            case CHUNK_NO_BREAK:
                cc += swprintf( wszBuffer + cc, L" (No Break)\r\n" );
                break;

            case CHUNK_EOW:
                cc += swprintf( wszBuffer + cc, L" (Word)\r\n" );
                break;

            case CHUNK_EOS:
                cc += swprintf( wszBuffer + cc, L" (Sentence)\r\n" );
                break;

            case CHUNK_EOP:
                cc += swprintf( wszBuffer + cc, L" (Paragraph)\r\n" );
                break;

            case CHUNK_EOC:
                cc += swprintf( wszBuffer + cc, L" (Chapter)\r\n" );
                break;
            }

            cc += swprintf( wszBuffer + cc, L"\t\tFlags(chunkstate) = 0x%x", StatChunk.flags );

            if ( CHUNK_TEXT & StatChunk.flags )
                cc += swprintf( wszBuffer + cc, L" (Text) " );

            if ( CHUNK_VALUE & StatChunk.flags )
                cc += swprintf( wszBuffer + cc, L" (Value) " );

            cc += swprintf( wszBuffer + cc, L"\r\n" );
            cc += swprintf( wszBuffer + cc, L"\t\tLocale = %d (0x%x)\r\n", StatChunk.locale, StatChunk.locale );
            cc += swprintf( wszBuffer + cc, L"\t\tIdChunkSource = %d\r\n", StatChunk.idChunkSource );
            cc += swprintf( wszBuffer + cc, L"\t\tcwcStartSource = %d\r\n", StatChunk.cwcStartSource );
            cc += swprintf( wszBuffer + cc, L"\t\tcwcLenSource = %d\r\n", StatChunk.cwcLenSource );

            cc += swprintf( wszBuffer + cc, L"----------------------------------------------------------------------\r\n" );

            if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
            {
                int cc2 = WideCharToMultiByte( CP_ACP,
                                               WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                               wszBuffer,
                                               cc,
                                               szBuffer,
                                               sizeof(szBuffer),
                                               szDefault,
                                               0 );

                if (!fContentOnly)
                    WriteFile( hFile, szBuffer, cc2, &cbWritten, 0 );
            }
            else
            {
                if (!fContentOnly)
                    WriteFile( hFile, wszBuffer, cc*sizeof(WCHAR), &cbWritten, 0 );
            }

            PROPVARIANT * pPropValue;

            while ( TRUE )
            {
                if( fText )
                {
                    ULONG ccBuffer = ccProtectedBuf;
                    sc = pFilt->GetText( &ccBuffer, pwszProtectedBuf );

//printf ("sc: %#x, ccBuffer: %d, buffer %#x\n", sc, ccBuffer, pwszProtectedBuf );
//DebugBreak();

                    if ( FAILED(sc) && (sc != FILTER_E_NO_MORE_TEXT) )
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "Error 0x%x from IFilter::GetText.\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"Error 0x%x from IFilter::GetText.\r\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }

                        break;
                    }

                    if ( sc == FILTER_E_NO_MORE_TEXT )
                        break; //go, fetch another chunk

                    //
                    // write the buffer to file
                    //

#if 0

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
                        sprintf( szBuffer, "\n------\nGetText returned %d characters\n------\n", ccBuffer );

                        if (!fContentOnly)
                            WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                    }
                    else
                    {
                        swprintf( wszBuffer, L"\n------\nGetText returned %d characters\n------\n", ccBuffer );

                        if (!fContentOnly)
                            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                    }
#endif

                    if ( 0 == ccBuffer )
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "<empty ::GetText>\r\n", ccBuffer );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"<empty ::GetText>\r\n", ccBuffer );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }
                    }

                    wcsBuffer[ccBuffer] = 0;

                    //
                    // Convert to MBCS
                    //

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
//printf( "copy to %#x, from %#x, cc %d\n", wcsBuffer, pwszProtectedBuf, ccBuffer );
//DebugBreak();
                        for ( unsigned i = 0; i < ccBuffer; i++ )
                        {
                            if ( 0xd == pwszProtectedBuf[i] ||
                                 0xb == pwszProtectedBuf[i] )
                                WriteFile( hFile, "\r\n", 2, &cbWritten, 0 );
                            else
                                WriteFile( hFile, &pwszProtectedBuf[i], sizeof BYTE, &cbWritten, 0 );
                        }
//                        RtlCopyMemory( wcsBuffer, pwszProtectedBuf, ccBuffer * sizeof WCHAR );
//                        printf( "%ws", wcsBuffer );
                    }
                    else
                    {
                        WriteFile( hFile, pwszProtectedBuf, ccBuffer * sizeof(WCHAR), &cbWritten, 0 );
                    }
                }

                if( !fText )
                {
                    sc = pFilt->GetValue( &pPropValue );

                    if ( FAILED(sc) && (sc != FILTER_E_NO_MORE_VALUES) )
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "IFilter::GetValue returned 0x%x\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"IFilter::GetValue returned 0x%x\r\n", sc );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }
                        break;
                    }

                    if ( sc == FILTER_E_NO_MORE_VALUES )
                        break; //go, fetch another chunk

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
                        sprintf( szBuffer, "Type = %d (0x%x): ", pPropValue->vt, pPropValue->vt );

                        if (!fContentOnly)
                            WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                    }
                    else
                    {
                        swprintf( wszBuffer, L"Type = %d (0x%x): ", pPropValue->vt, pPropValue->vt );

                        if (!fContentOnly)
                            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                    }

                    switch( pPropValue->vt )
                    {
                    case VT_LPWSTR:
                    case VT_BSTR:
                    {
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            int cc = WideCharToMultiByte( CP_ACP,
                                                          WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                                          pPropValue->pwszVal,
                                                          wcslen( pPropValue->pwszVal ),
                                                          szBuffer,
                                                          sizeof(szBuffer),
                                                          szDefault,
                                                          0 );

                            WriteFile( hFile, szBuffer, cc, &cbWritten, 0 );
                        }
                        else
                        {
                            WriteFile( hFile, pPropValue->pwszVal, wcslen(pPropValue->pwszVal) * sizeof(WCHAR), &cbWritten, 0 );
                        }
                        break;
                    }

                    case VT_LPSTR:
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            WriteFile( hFile, pPropValue->pszVal, strlen(pPropValue->pszVal), &cbWritten, 0 );
                        }
                        else
                        {
                            wszBuffer[0] = 0;

                            MultiByteToWideChar( CP_ACP,
                                                 0,
                                                 pPropValue->pszVal,
                                                 -1,
                                                 wszBuffer,
                                                 sizeof wszBuffer / sizeof wszBuffer[0] );

                            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }
                        break;

                    default:
                        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                        {
                            sprintf( szBuffer, "Unprintable type" );

                            if (!fContentOnly)
                                WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                        }
                        else
                        {
                            swprintf( wszBuffer, L"Unprintable type" );

                            if (!fContentOnly)
                                WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                        }

                        break;
                    }

                    if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
                    {
                        sprintf( szBuffer, "\n" );
                        WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
                    }
                    else
                    {
                        swprintf( wszBuffer, L"\r\n" );
                        WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
                    }

                    if( pPropValue )
                    {
                        PropVariantClear( pPropValue );

                        CoTaskMemFree( pPropValue );

                        pPropValue = 0;
                    }
                }
            }//while
        }//while

        pFilt->Release();


        if ( hFile == GetStdHandle( STD_OUTPUT_HANDLE ) )
        {
            sprintf( szBuffer, "\n\n" );
            WriteFile( hFile, szBuffer, strlen(szBuffer), &cbWritten, 0 );
        }
        else
        {
            swprintf( wszBuffer, L"\r\n\r\n" );
            WriteFile( hFile, wszBuffer, wcslen(wszBuffer)*sizeof(WCHAR), &cbWritten, 0 );
        }
    }

    CloseHandle( hFile );

    CIShutdown();

    CoUninitialize();

    if ( hFile != GetStdHandle( STD_OUTPUT_HANDLE ) )
    {
        CloseHandle( hFile );
    }

    return 0;
}

void Usage()
{
    printf( "Usage: FiltDump [-b] [-o Unicode output file] [-s buffer size] <file> <file> <file> ...\n" );
    printf( "Use -b to print only the contents of the file without additional commentary.\n");
    printf( "Use -s to control text buffer size (guard page at end)\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\enumprop\enumprop.cxx ===
#define UNICODE
#define _OLE32_

#include <windows.h>
#include <shlobj.h>

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <eh.h>

#include "minici.hxx"

typedef HRESULT (STDAPICALLTYPE * LPStgOpenStorageEx) (
    const WCHAR* pwcsName,
    DWORD grfMode,
    DWORD stgfmt,              // enum
    DWORD grfAttrs,             // reserved
    STGOPTIONS * pStgOptions,
    void * reserved,
    REFIID riid,
    void ** ppObjectOpen );

typedef HRESULT (STDAPICALLTYPE * PSHGetDesktopFolder) (
    IShellFolder ** ppshf );

typedef HRESULT (STDAPICALLTYPE * PSHBindToParent) (
    LPCITEMIDLIST pidl,
    REFIID riid,
    void **ppv,
    LPCITEMIDLIST *ppidlLast);

PSHGetDesktopFolder pShGetDesktopFolder = 0;
PSHBindToParent pShBindToParent = 0;

void Usage()
{
    printf( "usage: enumprop [-s] filename\n" );
    printf( "       -s   -- use the shell's property code instead of OLE\n" );
    exit( 1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   Render
//
//  Synopsis:   Prints an item in a safearray
//
//  Arguments:  [vt]  - type of the element
//              [pa]  - pointer to the item
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa );

void Render( VARTYPE vt, void * pv )
{
    if ( VT_ARRAY & vt )
    {
        PrintSafeArray( vt - VT_ARRAY, *(SAFEARRAY **) pv );
        return;
    }

    switch ( vt )
    {
        case VT_UI1: wprintf( L"%u", (unsigned) *(BYTE *)pv ); break;
        case VT_I1: wprintf( L"%d", (int) *(CHAR *)pv ); break;
        case VT_UI2: wprintf( L"%u", (unsigned) *(USHORT *)pv ); break;
        case VT_I2: wprintf( L"%d", (int) *(SHORT *)pv ); break;
        case VT_UI4:
        case VT_UINT: wprintf( L"%u", (unsigned) *(ULONG *)pv ); break;
        case VT_I4:
        case VT_ERROR:
        case VT_INT: wprintf( L"%d", *(LONG *)pv ); break;
        case VT_UI8: wprintf( L"%I64u", *(unsigned __int64 *)pv ); break;
        case VT_I8: wprintf( L"%I64d", *(__int64 *)pv ); break;
        case VT_R4: wprintf( L"%f", *(float *)pv ); break;
        case VT_R8: wprintf( L"%lf", *(double *)pv ); break;
        case VT_DECIMAL:
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) pv, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( * (CY *) pv, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_BOOL: wprintf( *(VARIANT_BOOL *)pv ? L"TRUE" : L"FALSE" ); break;
        case VT_BSTR: wprintf( L"%ws", *(BSTR *) pv ); break;
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME st;
            VariantTimeToSystemTime( *(DATE *)pv, &st );
            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_EMPTY:
        case VT_NULL:
            break;
        default :
        {
            wprintf( L"(vt 0x%x)", (int) vt );
            break;
        }
    }
} //Render

//+-------------------------------------------------------------------------
//
//  Function:   PrintSafeArray
//
//  Synopsis:   Prints items in a safearray
//
//  Arguments:  [vt]  - type of elements in the safearray
//              [pa]  - pointer to the safearray
//
//--------------------------------------------------------------------------

void PrintSafeArray( VARTYPE vt, LPSAFEARRAY pa )
{
    // Get the dimensions of the array

    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XPtr<LONG> xDim( cDim );
    XPtr<LONG> xLo( cDim );
    XPtr<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        wprintf( L"{" );
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            wprintf( L"," );

        // Get the element and render it

        void *pv;
        SafeArrayPtrOfIndex( pa, xDim.Get(), &pv );
        Render( vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            wprintf( L"}" );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            wprintf( L"{" );
    }
} //PrintSafeArray

//+-------------------------------------------------------------------------
//
//  Function:   PrintVectorItems
//
//  Synopsis:   Prints items in a PROPVARIANT vector
//
//  Arguments:  [pVal]  - The array of values
//              [cVals] - The count of values
//              [pcFmt] - The format string
//
//--------------------------------------------------------------------------

template<class T> void PrintVectorItems(
    T *     pVal,
    ULONG   cVals,
    char *  pcFmt )
{
    printf( "{ " );

    for( ULONG iVal = 0; iVal < cVals; iVal++ )
    {
        if ( 0 != iVal )
            printf( "," );
        printf( pcFmt, *pVal++ );
    }

    printf( " }" );
} //PrintVectorItems

//+-------------------------------------------------------------------------
//
//  Function:   DisplayValue
//
//  Synopsis:   Displays a PROPVARIANT value.  Limited formatting is done.
//
//  Arguments:  [pVar] - The value to display
//
//--------------------------------------------------------------------------

void DisplayValue( PROPVARIANT const * pVar )
{
    if ( 0 == pVar )
    {
        wprintf( L"NULL" );
        return;
    }

    // Display the most typical variant types

    PROPVARIANT const & v = *pVar;

    switch ( v.vt )
    {
        case VT_EMPTY : wprintf( L"vt_empty" ); break;
        case VT_NULL : wprintf( L"vt_null" ); break;
        case VT_I4 : wprintf( L"%10d", v.lVal ); break;
        case VT_UI1 : wprintf( L"%10d", v.bVal ); break;
        case VT_I2 : wprintf( L"%10d", v.iVal ); break;
        case VT_R4 : wprintf( L"%10f", v.fltVal ); break;
        case VT_R8 : wprintf( L"%10lf", v.dblVal ); break;
        case VT_BOOL : wprintf( v.boolVal ? L"TRUE" : L"FALSE" ); break;
        case VT_I1 : wprintf( L"%10d", v.cVal ); break;
        case VT_UI2 : wprintf( L"%10u", v.uiVal ); break;
        case VT_UI4 : wprintf( L"%10u", v.ulVal ); break;
        case VT_INT : wprintf( L"%10d", v.lVal ); break;
        case VT_UINT : wprintf( L"%10u", v.ulVal ); break;
        case VT_I8 : wprintf( L"%20I64d", v.hVal ); break;
        case VT_UI8 : wprintf( L"%20I64u", v.hVal ); break;
        case VT_ERROR : wprintf( L"%#x", v.scode ); break;
        case VT_LPSTR : wprintf( L"%S", v.pszVal ); break;
        case VT_LPWSTR : wprintf( L"%ws", v.pwszVal ); break;
        case VT_BSTR : wprintf( L"%ws", v.bstrVal ); break;
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( v.cyVal, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_DECIMAL :
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) &v.decVal, &dbl );
            wprintf( L"%lf", dbl );
            break;
        }
        case VT_FILETIME :
        case VT_DATE :
        {
            SYSTEMTIME st;

            if ( VT_DATE == v.vt )
            {
                VariantTimeToSystemTime( v.date, &st );
            }
            else
            {
#if 0
                FILETIME ft;
                FileTimeToLocalFileTime( &v.filetime, &ft );
                FileTimeToSystemTime( &ft, &st );
#else
                FileTimeToSystemTime( &v.filetime, &st );
#endif
            }

            BOOL pm = st.wHour >= 12;

            if ( st.wHour > 12 )
                st.wHour -= 12;
            else if ( 0 == st.wHour )
                st.wHour = 12;

            wprintf( L"%2d-%02d-%04d %2d:%02d%wc",
                    (DWORD) st.wMonth,
                    (DWORD) st.wDay,
                    (DWORD) st.wYear,
                    (DWORD) st.wHour,
                    (DWORD) st.wMinute,
                    pm ? L'p' : L'a' );
            break;
        }
        case VT_VECTOR | VT_I1:
            PrintVectorItems( v.cac.pElems, v.cac.cElems, "%d" ); break;
        case VT_VECTOR | VT_I2:
            PrintVectorItems( v.cai.pElems, v.cai.cElems, "%d" ); break;
        case VT_VECTOR | VT_I4:
            PrintVectorItems( v.cal.pElems, v.cal.cElems, "%d" ); break;
        case VT_VECTOR | VT_I8:
            PrintVectorItems( v.cah.pElems, v.cah.cElems, "%I64d" ); break;
        case VT_VECTOR | VT_UI1:
            PrintVectorItems( v.caub.pElems, v.caub.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI2:
            PrintVectorItems( v.caui.pElems, v.caui.cElems, "%u" ); break;
        case VT_VECTOR | VT_UI4:
            PrintVectorItems( v.caul.pElems, v.caul.cElems, "%u" ); break;
        case VT_VECTOR | VT_ERROR:
            PrintVectorItems( v.cascode.pElems, v.cascode.cElems, "%#x" ); break;
        case VT_VECTOR | VT_UI8:
            PrintVectorItems( v.cauh.pElems, v.cauh.cElems, "%I64u" ); break;
        case VT_VECTOR | VT_BSTR:
            PrintVectorItems( v.cabstr.pElems, v.cabstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_LPSTR:
            PrintVectorItems( v.calpstr.pElems, v.calpstr.cElems, "%S" ); break;
        case VT_VECTOR | VT_LPWSTR:
            PrintVectorItems( v.calpwstr.pElems, v.calpwstr.cElems, "%ws" ); break;
        case VT_VECTOR | VT_R4:
            PrintVectorItems( v.caflt.pElems, v.caflt.cElems, "%f" ); break;
        case VT_VECTOR | VT_R8:
            PrintVectorItems( v.cadbl.pElems, v.cadbl.cElems, "%lf" ); break;
        default : 
        {
            if ( VT_ARRAY & v.vt )
                PrintSafeArray( v.vt - VT_ARRAY, v.parray );
            else
                wprintf( L"vt 0x%05x", v.vt );
            break;
        }
    }
} //DisplayValue

void DumpProps(
    XInterface<IPropertySetStorage> & xPropSetStorage,
    BOOL                              fBonusProperties )
{
    // Get enumerator for property set

    XInterface<IEnumSTATPROPSETSTG> xPropSetEnum;

    HRESULT hr = xPropSetStorage->Enum( xPropSetEnum.GetPPointer() );
    if ( FAILED( hr ) )
    {
        printf( "IPropertySetStorage::Enum failed: %#x\n", hr );
        exit( 1 );
    }

    STATPROPSETSTG propset;
    BOOL fUserProp = !fBonusProperties;
    
    while( ( (hr = xPropSetEnum->Next(1, &propset, NULL)) == S_OK ) ||
           !fUserProp)
    {
        GUID FormatID;
        if ( S_OK == hr )
        {
            FormatID = propset.fmtid;
        }
        else
        {
            FormatID = FMTID_UserDefinedProperties;
            fUserProp = TRUE;
        }
        
        XInterface<IPropertyStorage> xPropStorage;

        hr = xPropSetStorage->Open( FormatID,
                                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                                    xPropStorage.GetPPointer() );

        if ( ( ( E_FAIL == hr ) || ( STG_E_FILENOTFOUND == hr ) ) &&
             ( FMTID_UserDefinedProperties == FormatID ) )
        {
            printf( "IPropertySetStorage::Open failed with %#x\n", hr );
            hr = S_OK;
            continue;
        }
        else if ( FAILED( hr ) )
        {
            printf( "IPropertySetStorage::Open failed badly with %#x\n", hr );
            exit( 1 );
        }

        printf( "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                FormatID.Data1,
                FormatID.Data2,
                FormatID.Data3,
                FormatID.Data4[0], FormatID.Data4[1],
                FormatID.Data4[2], FormatID.Data4[3],
                FormatID.Data4[4], FormatID.Data4[5],
                FormatID.Data4[6], FormatID.Data4[7] );

        XInterface<IEnumSTATPROPSTG> xEnumStatPropStg;
        
        // Get enumerator for property

        hr = xPropStorage->Enum( xEnumStatPropStg.GetPPointer() );

        if ( FAILED( hr ) )
        {
            printf( "IPropertyStorage::Enum failed %#x\n", hr );
            continue;
        }
        
        PROPVARIANT prop;
        PropVariantInit( &prop );
        
        // Get the locale for properties

        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = PID_LOCALE;

        hr = xPropStorage->ReadMultiple( 1, 
                                         &ps,
                                         &prop );

        if ( SUCCEEDED( hr ) )
        {
            if ( VT_EMPTY == prop.vt )
            {
                printf( "  no lcid, so using system default\n" );
            }
            else
            {
                printf( "  locale: %d (%#x)\n", prop.ulVal, prop.ulVal );
                PropVariantClear(&prop);
            }
        }
        else
        {
            printf( "  can't read the locale: %#x\n", hr );
        }
        
        // Get the code page for properties

        PROPSPEC psCodePage = { PRSPEC_PROPID, PID_CODEPAGE };
        
        hr = xPropStorage->ReadMultiple(1, &psCodePage, &prop);
        
        if ( SUCCEEDED( hr ) )
        {
            if(VT_I2 == prop.vt)
                printf( "  codepage: %d (%#x)\n", (UINT)prop.uiVal, (UINT) prop.uiVal );
            else
                printf( "  vt of codepage: %d (%#x)\n", prop.vt, prop.vt );

            PropVariantClear( &prop );
        }
        else
        {
            printf( "  no codepage, assume ansi\n" );
        }
        
        // Enumerate all properties in the property set

        STATPROPSTG statPS;
        ULONG ul;

        if ( S_OK != hr )
        {
            hr = S_OK;
        }

        while ( ( S_OK == xEnumStatPropStg->Next( 1, &statPS, &ul ) ) &&
                ( 1 == ul ) &&
                ( SUCCEEDED( hr ) ) )
        {
            if ( 0 != statPS.lpwstrName )
            {
                printf( "  name: '%ws', ", statPS.lpwstrName );

                ps.ulKind = PRSPEC_LPWSTR;
                ps.lpwstr = statPS.lpwstrName;
            }
            else
            {
                printf( "  pid: %d (%#x), ", statPS.propid, statPS.propid );

                ps.ulKind = PRSPEC_PROPID;
                ps.propid = statPS.propid;
            }

            hr = xPropStorage->ReadMultiple( 1, 
                                             &ps,
                                             &prop );

            if ( SUCCEEDED( hr ) )
            {
                if ( S_FALSE == hr )
                    printf( "readmultiple returned S_FALSE!\n" );

                printf( "vt: %d (%#x), ", prop.vt, prop.vt );

                DisplayValue( &prop );
                printf( "\n" );

                PropVariantClear( &prop );
            }
            else
            {
                printf( "  IPropertyStorage::ReadMultiple failed: %#x\n", hr );
                hr = S_OK;
            }
        }
    }
} //DumpProps

HRESULT BindToItemByName(
    WCHAR const * pszFile,
    REFIID        riid,
    void **       ppv )
{
    XInterface<IShellFolder> xDesktop;
    HRESULT hr = pShGetDesktopFolder( xDesktop.GetPPointer() );

    if ( SUCCEEDED( hr ) )
    {
        XInterface<IBindCtx> xBindCtx;

        hr = CreateBindCtx( 0, xBindCtx.GetPPointer() );
        if ( FAILED( hr ) )
            return hr;

        BIND_OPTS bo = {sizeof(bo), 0};
        bo.grfFlags = BIND_JUSTTESTEXISTENCE;   // skip all junctions

        hr = xBindCtx->SetBindOptions( &bo );

        if ( FAILED( hr ) )
            return hr;

        LPITEMIDLIST pidl;

        // cast needed for bad interface def
    
        hr = xDesktop->ParseDisplayName( 0,
                                         xBindCtx.GetPointer(),
                                         (LPWSTR) pszFile,
                                         0,
                                         &pidl,
                                         0 );
        if ( SUCCEEDED( hr ) )
        {
            XInterface<IShellFolder> xSF;
            LPCITEMIDLIST pidlChild;
    
            hr = pShBindToParent( pidl,
                                  IID_IShellFolder,
                                  xSF.GetQIPointer(),
                                  &pidlChild );
            if (SUCCEEDED(hr))
                hr = xSF->BindToObject( pidlChild, 0, riid, ppv );
            else
                printf( "SHBindToParent failed: %#x\n", hr );
    
            CoTaskMemFree( pidl );
        }
        else
        {
            printf( "IShellFolder::ParseDisplayNamed failed %#x\n", hr );
        }
    }
    else
    {
        printf( "SHGetDesktopFolder failed: %#x\n", hr );
    }

    return hr;
} //BindToItemByName

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( 2 != argc && 3 != argc )
        Usage();

    BOOL fUseOLE = TRUE;

    if ( ( 3 == argc ) && !_wcsicmp( L"-s", argv[1] ) )
        fUseOLE = FALSE;

    WCHAR awcPath[MAX_PATH];

    _wfullpath( awcPath, argv[ (2 == argc) ? 1 : 2 ], MAX_PATH );

    HRESULT hr = CoInitialize( 0 );

    if ( FAILED( hr ) )
    {
        printf( "can't init com: %#x\n", hr );
        exit( 1 );
    }

    if ( fUseOLE )
    {
        BOOL fWindows2000Plus = FALSE;

        OSVERSIONINFOA ovi;
        ovi.dwOSVersionInfoSize = sizeof ovi;
        GetVersionExA( &ovi );

        if ( ( VER_PLATFORM_WIN32_NT == ovi.dwPlatformId ) &&
             ( ovi.dwMajorVersion >= 5 ) )
            fWindows2000Plus = TRUE;

        HINSTANCE h = LoadLibraryA( "ole32.dll" );
        if ( 0 == h )
        {
            printf( "can't load ole32.dll\n" );
            exit( 1 );
        }

        LPStgOpenStorageEx pOpen = (LPStgOpenStorageEx) GetProcAddress( h, "StgOpenStorageEx" );

        // Note: on some platforms closing the IStorage before finishing with
        // the IPropertySetStorage will result in the object going away.  It's a bug
        // in OLE.
    
        XInterface<IStorage> xStorage;
        XInterface<IPropertySetStorage> xPropSetStorage;
    
        if ( fWindows2000Plus && 0 != pOpen )
        {
            HRESULT hr = pOpen( awcPath,
                                STGM_DIRECT |
                                    STGM_READ |
                                    STGM_SHARE_DENY_WRITE,
                                STGFMT_ANY,
                                0,
                                0,
                                0,
                                IID_IPropertySetStorage,      
                                xPropSetStorage.GetQIPointer() );
            if ( FAILED( hr ) )
            {
                printf( "failed to openEx the file: %#x\n", hr );
                exit( 1 );
            }
        }
        else
        {
            HRESULT hr = StgOpenStorage( awcPath,
                                         0,
                                         STGM_READ | STGM_SHARE_DENY_WRITE,
                                         0,
                                         0, 
                                         xStorage.GetPPointer() );
            if ( FAILED( hr ) )
            {
                printf( "StgOpenStorage failed to open the file: %#x\n", hr );
                exit( 1 );
            }

            // Rely on iprop.dll on Win9x, since OLE32 doesn't have the code
        
            hr = StgCreatePropSetStg( xStorage.GetPointer(),
                                      0,
                                      xPropSetStorage.GetPPointer() );
            
            if ( FAILED( hr ) )
            {
                printf( "StgCreatePropSetStg failed: %#x\n", hr );
                exit( 1 );
            }
        }
    
        DumpProps( xPropSetStorage, TRUE );

        FreeLibrary( h );
    }
    else
    {
        HINSTANCE h = LoadLibrary( L"shell32.dll" );
        if ( 0 == h )
        {
            printf( "can't load shell32.dll\n" );
            exit( 1 );
        }

        pShGetDesktopFolder = (PSHGetDesktopFolder) GetProcAddress( h, "SHGetDesktopFolder" );
        if ( 0 == pShGetDesktopFolder )
        {
            printf( "can't find SHGetDesktopFolder in shell32.dll\n" );
            exit( 1 );
        }

        pShBindToParent = (PSHBindToParent) GetProcAddress( h, "SHBindToParent" );
        if ( 0 == pShBindToParent )
        {
            printf( "can't find SHBindToParent in shell32.dll\n" );
            exit( 1 );
        }

        XInterface<IPropertySetStorage> xPropSetStorage;
    
        CLSID clsidPSS = IID_IPropertySetStorage;

        hr = BindToItemByName( awcPath,
                               clsidPSS,
                               xPropSetStorage.GetQIPointer() );
        if ( FAILED( hr ) )
            printf( "couldn't bind to item %ws by name: %#x\n", awcPath, hr );
        else
            DumpProps( xPropSetStorage, FALSE );

        FreeLibrary( h );
    }

    CoUninitialize();

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\dumpsec\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       Main.cxx
//
//  Contents:   Main file for CI security dump utility
//
//  History:    29-Jul-1998   KyleP    Created
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <aclapi.h>

typedef ULONG SDID;

//
// Copied from SecCache.hxx (NtCiUtil directory)
//

const USHORT SECSTORE_REC_SIZE = 64;
const ULONG SECSTORE_HASH_SIZE = 199;

struct SSdHeaderRecord
{
    ULONG       cbSD;           // size in bytes of the security descriptor
    ULONG       ulHash;         // the hash of the security descriptor
    SDID        iHashChain;     // index to previous entry for hash bucket
};

//
// Used for mapping bitmasks to text.
//

struct SPermDisplay
{
    DWORD  Perm;
    char * Display;
};

//
// Local constants and function prototypes
//

unsigned const SixtyFourK = 1024 * 64;

void DisplayTrustee( TRUSTEE const & Trustee );
void DisplayACE( char const * pszPreface, unsigned cACE, EXPLICIT_ACCESS * pACE );
void DisplayMode( DWORD mode );
void DisplayInheritance( DWORD Inherit );
void DisplayPerms( DWORD grfAccess );
void Display( DWORD grfAccess, SPermDisplay aPerm[], unsigned cPerm, unsigned cDisplay = 0 );
void Usage();

//+---------------------------------------------------------------------------
//
//  Function:   wmain, public
//
//  Synopsis:   Program entry point.  Iterates and displays SDID mapping.
//
//  Arguments:  [argc] -- Argument count
//              [argv] -- Program arguments
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( argc != 2 )
    {
        Usage();
        return 1;
    }

    //
    // Open handle
    //

    WCHAR wszSecFile[MAX_PATH];
    wcscpy( wszSecFile, argv[1] );
    wcscat( wszSecFile, L"\\CiST0000.001" );

    HANDLE h = CreateFile( wszSecFile,
                           GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %ws. Error %u\n", wszSecFile, GetLastError() );
        return GetLastError();
    }

    //
    // Read until done.
    //

    BYTE abTemp[SixtyFourK];
    DWORD cbRead;
    int i = 0;

    SSdHeaderRecord Header;

    while ( ReadFile( h,
                      &Header,
                      sizeof(Header),
                      &cbRead,
                      0 ) )
    {
        if ( 0 == Header.cbSD )
            break;

        i++;
        printf( "SDID %u / 0x%x (cbSD = %u bytes)\n", i, i, Header.cbSD );

        //
        // Read rest of first record.
        //

        if ( !ReadFile( h,
                        abTemp,
                        SECSTORE_REC_SIZE - sizeof(Header) + 4,
                        &cbRead,
                        0 ) )
        {
            printf( "Error %u reading file\n", GetLastError() );
            return 1;
        }

        //
        // Read additional records, which together create one security descriptor
        //

        if ( Header.cbSD > (SECSTORE_REC_SIZE - sizeof(Header)) )
        {
            unsigned iCurrent = SECSTORE_REC_SIZE - sizeof(Header);

            for ( unsigned cLeft = (Header.cbSD - SECSTORE_REC_SIZE + sizeof(Header) - 1) / SECSTORE_REC_SIZE + 1;
                  cLeft > 0;
                  cLeft-- )
            {
                if ( !ReadFile( h,
                                abTemp + iCurrent,
                                SECSTORE_REC_SIZE + 4,
                                &cbRead,
                                0 ) )
                {
                    printf( "Error %u reading file\n", GetLastError() );
                    return 1;
                }

                i++;
                iCurrent += SECSTORE_REC_SIZE;
            }
        }

        SECURITY_DESCRIPTOR * pSD = (SECURITY_DESCRIPTOR *)abTemp;

        //
        // Create a human-readable descriptor
        //

        TRUSTEE * pOwner;
        TRUSTEE * pGroup;
        DWORD     cACE;
        EXPLICIT_ACCESS * pACE;

        DWORD dwError = LookupSecurityDescriptorParts( &pOwner,
                                                       &pGroup,
                                                       &cACE,
                                                       &pACE,
                                                       0,
                                                       0,
                                                       pSD );

        //
        // And display it.
        //

        if ( ERROR_SUCCESS == dwError )
        {
            if ( 0 != pOwner )
            {
                printf( "Owner: " );
                DisplayTrustee( *pOwner );
                LocalFree( pOwner );
            }

            if ( 0 != pGroup )
            {
                printf( "Group: " );
                DisplayTrustee( *pGroup );
                LocalFree( pGroup );
            }

            if ( cACE > 0 )
            {
                printf( "Access: " );
                DisplayACE( "        ", cACE, pACE );
                LocalFree( pACE );
            }
        }
        else
            printf( "LookupSecurityDescriptorParts returned %u\n", dwError );

        printf( "\n\n" );
    }

    CloseHandle( h );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayTrustee
//
//  Synopsis:   Prints out trustee (user, group, etc.)
//
//  Arguments:  [Trustee] -- Trustee description
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

char * aszTrusteeType[] = { "Unknown",   // TRUSTEE_IS_UNKNOWN
                            "User",      // TRUSTEE_IS_USER,
                            "Group",     // TRUSTEE_IS_GROUP,
                            "Domain",    // TRUSTEE_IS_DOMAIN,
                            "Alias",     // TRUSTEE_IS_ALIAS,
                            "Group",     // TRUSTEE_IS_WELL_KNOWN_GROUP,
                            "Deleted",   // TRUSTEE_IS_DELETED,
                            "Invalid" }; // TRUSTEE_IS_INVALID

void DisplayTrustee( TRUSTEE const & Trustee )
{
    if ( TRUSTEE_IS_NAME == Trustee.TrusteeForm )
    {
        printf( "%ws (%s)", Trustee.ptstrName, aszTrusteeType[Trustee.TrusteeType] );
    }
    else if ( TRUSTEE_IS_SID == Trustee.TrusteeForm )
    {
    }
    else
        printf( "Invalid Trustee form\n" );
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayACE
//
//  Synopsis:   Prints out Access Control Entry(ies)
//
//  Arguments:  [pszPreface] -- String to append at beginning of each line.
//              [cACE]       -- Count of entries
//              [pACE]       -- Array of entries
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void DisplayACE( char const * pszPreface, unsigned cACE, EXPLICIT_ACCESS * pACE )
{
    for ( unsigned i = 0; i < cACE; i++ )
    {
        if ( 0 != i )
            printf( "%s", pszPreface );

        DisplayTrustee( pACE[i].Trustee );

        printf( " : " );

        DisplayMode( pACE[i].grfAccessMode );

        printf( " /" );

        DisplayInheritance( pACE[i].grfInheritance );

        printf( " /" );

        DisplayPerms( pACE[i].grfAccessPermissions );

        printf( "\n" );
    }
    //ACCESS_MODE  grfAccessMode;    DWORD        grfInheritance;
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayMode, private
//
//  Synopsis:   Prints out access mode (Set or Deny access)
//
//  Arguments:  [mode] -- Access mode
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

char * aszAccessDisplay[] = { "NOT_USED",
                              "GRANT_ACCESS",
                              "SET_ACCESS",
                              "DENY_ACCESS",
                              "REVOKE_ACCESS",
                              "SET_AUDIT_SUCCESS",
                              "SET_AUDIT_FAILURE" };

void DisplayMode( DWORD mode )
{
    printf( "%s", aszAccessDisplay[mode] );
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayInheritance, private
//
//  Synopsis:   Prints out inheritance, both up (to parent) and down (to children)
//
//  Arguments:  [Inherit] -- Inheritance bitmask
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

SPermDisplay aInheritDisplay[] = {
  //{ INHERITED_ACCESS_ENTRY,             "(inherited)" },
  { INHERITED_PARENT,                   "(inherited from parent)" },
  { INHERITED_GRANDPARENT,              "(inherited from grandparent)" },
  { SUB_OBJECTS_ONLY_INHERIT,           "SUB_OBJECTS_ONLY" },
  { SUB_CONTAINERS_ONLY_INHERIT,        "SUB_CONTAINERS_ONLY" },
  { SUB_CONTAINERS_AND_OBJECTS_INHERIT, "SUB_CONTAINERS_AND_OBJECTS" },
  { INHERIT_NO_PROPAGATE,               "INHERIT_NO_PROPAGATE" },
  { INHERIT_ONLY,                       "INHERIT_ONLY" } };

void DisplayInheritance( DWORD Inherit )
{
    if ( NO_INHERITANCE == Inherit )
        printf( "\n\t\t(not inherited)" );
    else
        Display( Inherit, aInheritDisplay, sizeof(aInheritDisplay)/sizeof(aInheritDisplay[0]) );
}

//+---------------------------------------------------------------------------
//
//  Function:   DisplayPerms
//
//  Synopsis:   Displays file permissions
//
//  Arguments:  [grfAccess] -- Access permission bitmask
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

SPermDisplay aPermDisplay[] = {
  { FILE_READ_DATA,        "READ_DATA" },
  { FILE_WRITE_DATA,       "WRITE_DATA" },
  { FILE_ADD_FILE,         "ADD_FILE" },
  { FILE_APPEND_DATA,      "APPEND_DATA" },
  { FILE_ADD_SUBDIRECTORY, "ADD_SUBDIRECTORY" },
  { FILE_CREATE_PIPE_INSTANCE, "CREATE_PIPE_INSTANCE" },
  { FILE_READ_EA,              "READ_EA" },
  { FILE_WRITE_EA,             "WRITE_EA" },
  { FILE_EXECUTE,              "EXECUTE" },
  { FILE_TRAVERSE,             "TRAVERSE" },
  { FILE_DELETE_CHILD,         "DELETE_CHILD" },
  { FILE_READ_ATTRIBUTES,      "READ_ATTRIBUTES" },
  { FILE_WRITE_ATTRIBUTES,     "WRITE_ATTRIBUTES" },
  { DELETE,                    "DELETE" },
  { READ_CONTROL,              "READ_CONTROL" },
  { WRITE_DAC,                 "WRITE_DAC" },
  { WRITE_OWNER,               "WRITE_OWNER" },
  { SYNCHRONIZE,               "SYNCHRONIZE" },
  { GENERIC_READ,              "GENERIC_READ" },
  { GENERIC_WRITE,             "GENERIC_WRITE" },
  { GENERIC_EXECUTE,           "GENERIC_EXECUTE" } };


void DisplayPerms( DWORD grfAccess )
{
    BOOL  cDisplay = 0;
    DWORD grfRemove = 0;

    printf( "\n\t\t" );

    //
    // First, get rid of the basics...
    //

    if ( (grfAccess & FILE_GENERIC_READ) == FILE_GENERIC_READ )
    {
        printf( "GENERIC_READ" );
        grfRemove = FILE_GENERIC_READ;
        cDisplay++;
    }

    if ( (grfAccess & FILE_GENERIC_WRITE) == FILE_GENERIC_WRITE )
    {
        if ( 0 != cDisplay )
            printf( " | " );

        printf( "GENERIC_WRITE" );
        grfRemove = grfRemove | FILE_GENERIC_WRITE;
        cDisplay++;
    }

    if ( (grfAccess & FILE_GENERIC_EXECUTE) == FILE_GENERIC_EXECUTE )
    {
        if ( 0 != cDisplay )
            printf( " | " );

        if ( 0 == (cDisplay % 2) )
            printf( " \n\t\t" );

        printf( "GENERIC_EXECUTE" );
        grfRemove = grfRemove | FILE_GENERIC_EXECUTE;
        cDisplay++;
    }

    //
    // Now, individual permissions.
    //

    DWORD grfRemainder = grfAccess & ~grfRemove;

    Display( grfRemainder, aPermDisplay, sizeof(aPermDisplay)/sizeof(aPermDisplay[0]), cDisplay );

    printf( " (0x%x)", grfAccess );
}

//+---------------------------------------------------------------------------
//
//  Function:   Display, private
//
//  Synopsis:   Print bit masks
//
//  Arguments:  [grfAccess] -- Bit mask
//              [aPerm]     -- Description of bits
//              [cPerm]     -- Count of entries in [aPerm]
//              [cDisplay]  -- Number of entries already displayed on
//                             current line by caller.
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void Display( DWORD grfAccess, SPermDisplay aPerm[], unsigned cPerm, unsigned cDisplay )
{
    for ( unsigned i = 0; i < cPerm ; i++ )
    {
        if ( grfAccess & aPerm[i].Perm )
        {
            if ( 0 != cDisplay )
                printf( " | " );

            if ( 0 == (cDisplay % 2) )
                printf( " \n\t\t" );

            printf( "%s", aPerm[i].Display );

            cDisplay++;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays program usage
//
//  History:    29-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

void Usage()
{
    printf( "Usage: DumpSec <Path to catalog>\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\filtreg\filtreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       filtreg.cxx
//
//  Contents:   Filter registration utility
//
//  History:    02 Dec 1997     KyleP   Created
//
//--------------------------------------------------------------------------

#include <stdio.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

//
// From smart.hxx
//

class SRegKey
{
public:
    SRegKey( HKEY key ) : _key( key ) {}
    SRegKey() : _key( 0 ) {}
    ~SRegKey() { Free(); }
    void Set( HKEY key ) { _key = key; }
    HKEY Acquire() { HKEY tmp = _key; _key = 0; return tmp; }
    void Free() { if ( 0 != _key ) { RegCloseKey( _key ); _key = 0; } }

private:
    HKEY _key;
};

void Usage();
void PrintExtensions( HKEY hkeyCLSID, WCHAR const * wcsTargetCLSID );
void LocateByExtension( HKEY hkeyCLSID );
void LocateByCLSID( HKEY hkeyCLSID );
BOOL LocateFilter( HKEY hkeyBase,
                   HKEY hkeyCLSID,
                   WCHAR const * wcsClassOrExt,
                   WCHAR * wcsFilterName,
                   WCHAR * wcsFilterDll );
LONG Replicate( WCHAR const * wszDstExt, WCHAR const * wszSrcExt );

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( argc > 1 )
    {
        if ( argc != 3 )
            Usage();
        else
            Replicate( argv[1], argv[2] );
    }
    else
    {
        //
        // Enumerate, looking for extensions and classes with a persistent handler.
        //

        HKEY hkeyCLSID;

        LONG dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                     L"CLSID",
                                     0,
                                     KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                     &hkeyCLSID );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "RegOpenKey( \"CLSID\" ) returned %d\n", dwError );
        }
        else
        {
            SRegKey xkeyCLSID( hkeyCLSID );

            printf( "Filters loaded by extension:\n" );
            LocateByExtension( hkeyCLSID );

            printf( "\n\nFilters loaded by class:\n" );
            LocateByCLSID( hkeyCLSID );
        }
    }

    return 0;
}

void Usage()
{
    printf( "Usage: filtreg [dstExt] [srcExt]\n"
            "  Displays IFilter registrations.  If [dstExt] and [srcExt]\n"
            "  are specified then [dstExt] is registered to act like [srcExt].\n" );
}

void LocateByExtension( HKEY hkeyCLSID )
{
    DWORD dwExtIndex;

    DWORD dwError = RegQueryInfoKey (  HKEY_CLASSES_ROOT,
                                       0,
                                       0,
                                       0,
                                       &dwExtIndex,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0 );

    if ( ERROR_SUCCESS != dwError )
    {
        printf( "RegQueryInfoKey( HKCR ) returned %d\n", dwError );
    }
    else
    {
        for ( DWORD dwIndex = 0; dwIndex < dwExtIndex; dwIndex++ )
        {
            WCHAR wcsExt[100];
            DWORD ccExt = sizeof(wcsExt)/sizeof(WCHAR);

            dwError = RegEnumKeyEx( HKEY_CLASSES_ROOT,
                                    dwIndex,
                                    wcsExt,
                                    &ccExt,
                                    0,
                                    0,
                                    0,
                                    0 );

            //
            // All the extensions come first.
            //

            if ( ERROR_SUCCESS != dwError || ( wcsExt[0] != L'.' && wcsExt[0] != L'*' ) )
                break;

            WCHAR wcsFilterName[MAX_PATH];
            WCHAR wcsFilterDll[MAX_PATH]; 

            if ( LocateFilter( HKEY_CLASSES_ROOT,
                               hkeyCLSID,
                               wcsExt,
                               wcsFilterName,
                               wcsFilterDll ) )
            {
                printf( "%ws --> %ws (%ws)\n", wcsExt, wcsFilterName, wcsFilterDll );
            }
        }
    }
}

void LocateByCLSID( HKEY hkeyCLSID )
{
    DWORD dwClsidIndex;

    DWORD dwError = RegQueryInfoKey (  hkeyCLSID,
                                       0,
                                       0,
                                       0,
                                       &dwClsidIndex,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0 );

    if ( ERROR_SUCCESS != dwError )
    {
        printf( "RegQueryInfoKey( \"CLSID\" ) returned %d\n", dwError );
    }
    else
    {
        for ( DWORD dwIndex = dwClsidIndex - 2; dwIndex != 0xFFFFFFFF; dwIndex-- )
        {
            WCHAR wcsCLSID[100];
            DWORD ccCLSID = sizeof(wcsCLSID)/sizeof(WCHAR);

            dwError = RegEnumKeyEx( hkeyCLSID,
                                    dwIndex,
                                    wcsCLSID,
                                    &ccCLSID,
                                    0,
                                    0,
                                    0,
                                    0 );

            if ( ERROR_SUCCESS == dwError )
            {
                //
                // Look for a filter.
                //

                WCHAR wcsFilterName[MAX_PATH]; 
                WCHAR wcsFilterDll[MAX_PATH]; 

                if ( LocateFilter( hkeyCLSID,
                                   hkeyCLSID,
                                   wcsCLSID,
                                   wcsFilterName,
                                   wcsFilterDll ) )
                {
                    //
                    // Find a decent name for the class.
                    //

                    HKEY hkeyClass;

                    RegOpenKeyEx( hkeyCLSID,
                                  wcsCLSID,
                                  0,
                                  KEY_READ,
                                  &hkeyClass );

                    SRegKey xkeyClass( hkeyClass );

                    WCHAR wcsClassName[500];
                    DWORD dwType;
                    DWORD cbClassName = sizeof(wcsClassName);

                    dwError = RegQueryValueEx( hkeyClass,
                                               0,
                                               0,
                                               &dwType,
                                               (BYTE *)wcsClassName,
                                               &cbClassName );

                    if ( ERROR_SUCCESS != dwError || dwType != REG_SZ || wcsClassName[0] == 0)
                    {
                        wcscpy( wcsClassName, wcsCLSID );
                    }

                    printf( "%ws\n\tFilter: %ws (%ws)\n", wcsClassName, wcsFilterName, wcsFilterDll );

                    PrintExtensions( hkeyCLSID, wcsCLSID );
                    printf( "\n\n" );
                }
            }
        }
    }
}

BOOL LocateFilter( HKEY hkeyBase,
                   HKEY hkeyCLSID,
                   WCHAR const * wcsClassOrExt,
                   WCHAR * wcsFilterName,
                   WCHAR * wcsFilterDll )
{
    BOOL fOk = FALSE;

    do
    {
        //
        // Look for a persistent handler
        //

        HKEY hkeyPH;
        WCHAR wcsTemp[MAX_PATH];

        wcscpy( wcsTemp, wcsClassOrExt );
        wcscat( wcsTemp, L"\\PersistentHandler" );

        DWORD dwError = RegOpenKeyEx( hkeyBase,
                                      wcsTemp,
                                      0,
                                      KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                      &hkeyPH );

        if ( ERROR_SUCCESS != dwError )
            break;

        SRegKey xkeyPH( hkeyPH );

        //
        // Find the name of the persistent handler
        //

        wcscat( wcsFilterName, L"Unknown" );
        wcscat( wcsFilterDll, L"Unknown" );

        WCHAR wcsPHClass[1000];
        DWORD cbPHClass = sizeof(wcsPHClass);
        DWORD dwType;

        dwError = RegQueryValueEx( hkeyPH,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsPHClass,
                                   &cbPHClass );

        if ( ERROR_SUCCESS != dwError )
            break;

        HKEY hkeyPHClass;

        wcscat( wcsPHClass, L"\\PersistentAddinsRegistered\\{89BCB740-6119-101A-BCB7-00DD010655AF}" );

        RegOpenKeyEx( hkeyCLSID,
                      wcsPHClass,
                      0,
                      KEY_READ,
                      &hkeyPHClass );

        SRegKey xkeyPHClass( hkeyPHClass );

        //
        // Now open the filter class and look for a name.
        //

        if ( ERROR_SUCCESS != dwError )
            break;

        WCHAR wcsFilterClass[1000];
        DWORD cbFilterClass = sizeof(wcsFilterClass);

        dwError = RegQueryValueEx( hkeyPHClass,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsFilterClass,
                                   &cbFilterClass );

        if ( ERROR_SUCCESS != dwError || dwType != REG_SZ )
            break;

        HKEY hkeyFilterClass;

        dwError = RegOpenKeyEx( hkeyCLSID,
                                wcsFilterClass,
                                0,
                                KEY_READ,
                                &hkeyFilterClass );

        if ( ERROR_SUCCESS != dwError )
            break;

        SRegKey xkeyFilterClass( hkeyFilterClass );

        DWORD cbFilterName = MAX_PATH;

        dwError = RegQueryValueEx( hkeyFilterClass,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsFilterName,
                                   &cbFilterName );

        //
        // Don't check for error, because "Unknown was already in wcsFiltername
        //

        HKEY hkeyFilterIPS;

        dwError = RegOpenKeyEx( hkeyFilterClass,
                                L"InprocServer32",
                                0,
                                KEY_READ,
                                &hkeyFilterIPS );

        if ( ERROR_SUCCESS != dwError )
            break;

        DWORD cbFilterDll = MAX_PATH;

        dwError = RegQueryValueEx( hkeyFilterIPS,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsFilterDll,
                                   &cbFilterDll );

        //
        // Don't check for error, because "Unknown was already in wcsFiltername
        //

        fOk = TRUE;

    } while( FALSE );

    return fOk;
}


void PrintExtensions( HKEY hkeyCLSID, WCHAR const * wcsTargetCLSID )
{
    unsigned cExt = 0;

    //
    // Re-used vars
    //

    DWORD ccTemp;  // Size for RegQueryValueEx
    DWORD dwType;  // Type for RegQueryValueEx


    DWORD dwClassIndex;

    DWORD dwError = RegQueryInfoKey (  HKEY_CLASSES_ROOT,
                                       0,
                                       0,
                                       0,
                                       &dwClassIndex,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0 );

    if ( ERROR_SUCCESS != dwError )
    {
        printf( "RegQueryInfoKey( \"CLSID\" ) returned %d\n", dwError );
    }
    else
    {
        //
        // Outer loop looks for items registered with this class id
        //

        WCHAR wcsShortName[100];
        WCHAR wcsShortName2[sizeof(wcsShortName)/sizeof(WCHAR)];
        wcsShortName2[0] = 0;

        for ( DWORD dwIndex = dwClassIndex - 2; dwIndex != 0xFFFFFFFF; dwIndex-- )
        {
            ccTemp = sizeof(wcsShortName)/sizeof(WCHAR);


            dwError = RegEnumKeyEx( HKEY_CLASSES_ROOT,
                                    dwIndex,
                                    wcsShortName,
                                    &ccTemp,
                                    0,
                                    0,
                                    0,
                                    0 );

            if ( ERROR_SUCCESS != dwError )
                continue;

            HKEY hkeyClsid;
            WCHAR wcsTemp[sizeof(wcsShortName)/sizeof(WCHAR) + 50];

            wcscpy( wcsTemp, wcsShortName );
            wcscat( wcsTemp, L"\\CLSID" );

            dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                    wcsTemp,
                                    0,
                                    KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                    &hkeyClsid );

            if ( ERROR_SUCCESS != dwError )
                continue;

            //
            // This is a short name. Now get the Class Id and see if
            // it matches.
            //

            SRegKey xkeyClsid( hkeyClsid );

            WCHAR wcsClsid[100];
            DWORD cbTemp = sizeof(wcsClsid);

            dwError = RegQueryValueEx( hkeyClsid,
                                       0,
                                       0,
                                       &dwType,
                                       (BYTE *)wcsClsid,
                                       &cbTemp );

            if ( ERROR_SUCCESS != dwError ||
                 0 != _wcsicmp( wcsClsid, wcsTargetCLSID ) )
            {
                continue;
            }

            //
            // This is a matching short name.  Now, go back and look for
            // extensions.
            //

            for ( DWORD dwIndex2 = 0; dwIndex2 < dwClassIndex; dwIndex2++ )
            {
                WCHAR wcsExtension[100];
                DWORD ccExtension = sizeof(wcsExtension)/sizeof(WCHAR);

                dwError = RegEnumKeyEx( HKEY_CLASSES_ROOT,
                                        dwIndex2,
                                        wcsExtension,
                                        &ccExtension,
                                        0,
                                        0,
                                        0,
                                        0 );

                //
                // All the extensions come first.
                //

                if ( ERROR_SUCCESS != dwError || (wcsExtension[0] != L'.' && wcsExtension[0] != L'*') )
                    break;

                //
                // Potential extension...
                //

                HKEY hkeyExtension;

                dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                        wcsExtension,
                                        0,
                                        KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                        &hkeyExtension );

                if ( ERROR_SUCCESS != dwError )
                    continue;

                SRegKey xkeyExtension( hkeyExtension );
                WCHAR wcsShortName3[sizeof(wcsShortName)/sizeof(WCHAR)];
                cbTemp = sizeof(wcsShortName3);

                dwError = RegQueryValueEx( hkeyExtension,
                                           0,
                                           0,
                                           &dwType,
                                           (BYTE *)wcsShortName3,
                                           &cbTemp );

                if ( ERROR_SUCCESS == dwError && 0 == _wcsicmp( wcsShortName, wcsShortName3 ) )
                {
                    //
                    // Work around wierd anomalies in registry enumeration.
                    //

                    #if 0
                    if ( 0 == _wcsicmp( wcsShortName2, wcsShortName3 ) )
                        continue;
                    else
                        wcscpy( wcsShortName2, wcsShortName3 );
                    #endif

                    //
                    // Is this extension covered by an override?
                    //

                    WCHAR wcsFilterName[MAX_PATH]; 
                    WCHAR wcsFilterDll[MAX_PATH]; 

                    if ( !LocateFilter( HKEY_CLASSES_ROOT,
                                        hkeyCLSID,
                                        wcsExtension,
                                        wcsFilterName,
                                        wcsFilterDll ) )
                    {
                        if ( cExt % 2 == 0 )
                        {
                            if ( 0 != cExt )
                                printf( "\n" );

                            printf( "\tExtensions: %ws (%ws) ", wcsExtension, wcsShortName );
                        }
                        else
                            printf( "%ws (%ws) ", wcsExtension, wcsShortName );

                        cExt++;
                    }
                }
            }
        }
    }
}

LONG Replicate( WCHAR const * wszDstExt, WCHAR const * wszSrcExt )
{
    DWORD dwError;

    do
    {
        //
        // First, look up the old one...
        //

        HKEY hkeyPH;
        WCHAR wcsTemp[MAX_PATH]; 

        wcscpy( wcsTemp, wszSrcExt );
        wcscat( wcsTemp, L"\\PersistentHandler" );

        dwError = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                                wcsTemp,
                                0,
                                KEY_READ | KEY_ENUMERATE_SUB_KEYS,
                                &hkeyPH );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u opening HKCR\\%ws\n", dwError, wcsTemp );
            break;
        }

        SRegKey xkeyPH( hkeyPH );

        DWORD dwType;
        WCHAR wcsPH[100];
        DWORD cbTemp = sizeof(wcsPH);

        dwError = RegQueryValueEx( hkeyPH,
                                   0,
                                   0,
                                   &dwType,
                                   (BYTE *)wcsPH,
                                   &cbTemp );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u reading persistent handler class.\n", dwError );
            break;
        }

        //
        // Now append to new extension.
        //

        HKEY  hkeyDstPH;
        DWORD dwDisposition;

        wcscpy( wcsTemp, wszDstExt );
        wcscat( wcsTemp, L"\\PersistentHandler" );

        dwError = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                                   wcsTemp,              // Sub key
                                   0,                    // Reserved
                                   0,                    // Class
                                   0,                    // Flags
                                   KEY_ALL_ACCESS,       // Access
                                   0,                    // Security
                                   &hkeyDstPH,           // Handle
                                   &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u creating persistent handler key HKCR\\%ws\n", dwError, wcsTemp );
            break;
        }

        SRegKey xkeyDstPH( hkeyDstPH );

        dwError = RegSetValueExW( hkeyDstPH,                // Key
                                  0,                        // Name
                                  0,                        // Reserved
                                  REG_SZ,                   // Type
                                  (BYTE *)wcsPH,            // Value
                                  (1 + wcslen(wcsPH)) * sizeof(WCHAR) );

        if ( ERROR_SUCCESS != dwError )
        {
            printf( "Error %u creating persistent handler key HKCR\\%ws\n", dwError, wcsTemp );
            break;
        }

    } while( FALSE );

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\filtstat\filtstat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       TxtSinkDump.cxx
//
//  Contents:   Contains an implementation of ICiCTextSink interface.
//
//  History:    Jan-13-97   KLam   Created
//
//----------------------------------------------------------------------------

#define WIN32_LEAN_AND_MEAN

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <cierror.h>
#include <query.h>

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <tgrow.hxx>
#include <regacc.hxx>
#include <ciregkey.hxx>
#include <filtreg.hxx>      // registration functions
#include "FiltStat.hxx"

static long glcInstances = 0;
static WCHAR gwszModule[MAX_PATH];
static WCHAR gwszFilterStatusDumpCLSID[] = L"{3ce7c910-8d72-11d1-8f76-00a0c91917f5}";
static GUID CLSID_CFilterStatusDump = { 0x3ce7c910, 0x8d72, 0x11d1,
                                        { 0x8f, 0x76, 0x00, 0xa0, 0xc9, 0x19, 0x17, 0xf5 } };
static const WCHAR gwszDescription [] = L"Filtering Status Dumper";

//
// CFilterStatusDump Methods
//

CFilterStatusDump::CFilterStatusDump ()
        : _pfOutput(0),
          _fSuccessReport( FALSE ),
          _cRefs ( 1 )
{
    InterlockedIncrement ( &glcInstances );
}

CFilterStatusDump::~CFilterStatusDump ()
{
    if ( 0 != _pfOutput )
        fclose( _pfOutput );

    InterlockedDecrement( &glcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::QueryInterface
//
//  Synopsis:   Returns interfaces to IID_IUknown, IID_ICiCTextSink
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CFilterStatusDump::QueryInterface ( REFIID riid,
                                             void ** ppvObject )
{
    //Win4Assert ( 0 != ppvObject );

    if ( IID_IUnknown == riid )
    {
        AddRef ();
        *ppvObject = (void *)(IUnknown *) this;
        return S_OK;
    }
    else if ( IID_IFilterStatus == riid )
    {
        AddRef ();
        *ppvObject = (void *)(IFilterStatus *) this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::AddRef
//
//  Synopsis:   Increments the reference count on the object
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusDump::AddRef ()
{
    return InterlockedIncrement ( (long *)&_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::Release
//
//  Synopsis:   Decrements the reference count on the object.
//              If the reference count reaches 0, the object is deleted.
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusDump::Release ()
{
    ULONG cTemp = InterlockedDecrement ( (long *)&_cRefs );

    if ( 0 == cTemp )
        delete this;

    return cTemp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusDump::Initialize
//
//  Synopsis:   Creates or opens the text sink dump file.  If the file already
//              exists, it sets the file pointer to the end of the file.
//
//  Arguments:  [pwszSessionId]     --  String identifying current session
//              [pwszSessionPath]   --  Path containing current session catalog
//              [pIndexClientInfo]  --  Pointer to Client Info context
//              [fQuery]            --  Boolean indicating whether the incoming
//                                      text is a query
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CFilterStatusDump::Initialize ( WCHAR const * pwszCatalog,
                                             WCHAR const * pwszCatalogPath )
{
    CLock lock( _mutex );

    SCODE sc = E_FAIL;

    //
    // Clean up from previous state, if any.
    //

    if ( 0 != _pfOutput )
    {
        fclose( _pfOutput );
        _pfOutput = 0;
    }

    CTranslateSystemExceptions translate;
    TRY
    {
        //
        // Locate path of dump file in registry.
        //

        unsigned ccCat = wcslen( pwszCatalog );
        unsigned const ccBase = sizeof(wcsRegJustCatalogsSubKey)/sizeof(WCHAR) - 1;

        XGrowable<WCHAR> xTemp;

        xTemp.SetSize( ccBase + ccCat + 2 );

        RtlCopyMemory( xTemp.Get(), wcsRegJustCatalogsSubKey, ccBase * sizeof(WCHAR) );
        xTemp[ccBase] = L'\\';
        RtlCopyMemory( xTemp.Get() + ccBase + 1, pwszCatalog, (ccCat + 1) * sizeof(WCHAR) );  // 1 for null

        CRegAccess reg( RTL_REGISTRY_CONTROL, xTemp.Get() );

        XGrowable<WCHAR> xFile;
        reg.Get( L"FilterStatusLog", xFile.Get(), xFile.Count() );

        _fSuccessReport = (reg.Read( L"FilterStatusReportSuccess", 0, 0, 1 ) != 0);

        //
        // Open file
        //

        _pfOutput = _wfopen( xFile.Get(), L"a+" );

        if ( 0 == _pfOutput )
        {
            THROW( CException( ERROR_FILE_NOT_FOUND ) );
        }

        sc = S_OK;
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}

STDMETHODIMP CFilterStatusDump::PreFilter( WCHAR const * pwszPath )
{
    return S_OK;
}

STDMETHODIMP CFilterStatusDump::FilterLoad( WCHAR const * pwszPath, SCODE scFilterStatus )
{
    if ( FAILED(scFilterStatus) && 0 != _pfOutput )
    {
        //
        // Convert to narrow string.
        //

        XGrowable<char, MAX_PATH*2> xTemp;

        DWORD cbConvert = WideCharToMultiByte( CP_ACP,
                                               WC_COMPOSITECHECK,
                                               pwszPath,
                                               wcslen( pwszPath ) + 1,
                                               xTemp.Get(),
                                               xTemp.Count(),
                                               0,
                                               0 );

        CLock lock( _mutex );

        if ( 0 == cbConvert )
        {
            xTemp[cbConvert] = 0;
            fprintf( _pfOutput, "Error %#x loading filter for \"%ws\"\n", scFilterStatus, pwszPath );
        }
        else
        {
            xTemp[cbConvert] = 0;
            fprintf( _pfOutput, "Error %#x loading filter for \"%s\"\n", scFilterStatus, xTemp.Get() );
        }

        fflush( _pfOutput );
    }

    return S_OK;
}

STDMETHODIMP CFilterStatusDump::PostFilter( WCHAR const * pwszPath, SCODE scFilterStatus )
{
    if ( (_fSuccessReport || FAILED(scFilterStatus)) && 0 != _pfOutput )
    {
        //
        // Convert to narrow string.
        //

        XGrowable<char, MAX_PATH*2> xTemp;

        DWORD cbConvert = WideCharToMultiByte( CP_ACP,
                                               WC_COMPOSITECHECK,
                                               pwszPath,
                                               wcslen( pwszPath ) + 1,
                                               xTemp.Get(),
                                               xTemp.Count(),
                                               0,
                                               0 );

        CLock lock( _mutex );

        if ( 0 == cbConvert )
        {
            xTemp[cbConvert] = 0;

            if ( SUCCEEDED(scFilterStatus) )
                fprintf( _pfOutput, "ok: \"%ws\"\n", pwszPath );
            else
                fprintf( _pfOutput, "Error %#x indexing \"%ws\"\n", scFilterStatus, pwszPath );
        }
        else
        {
            xTemp[cbConvert] = 0;

            if ( SUCCEEDED(scFilterStatus) )
                fprintf( _pfOutput, "ok \"%s\"\n", xTemp.Get() );
            else
                fprintf( _pfOutput, "Error %#x indexing \"%s\"\n", scFilterStatus, xTemp.Get() );
        }

        fflush( _pfOutput );
    }

    return S_OK;
}

//
// CFilterStatusCF Methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::CFilterStatusCF
//
//  Synopsis:   Constructor
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

CFilterStatusCF::CFilterStatusCF () : _cRefs (1)
{
    InterlockedIncrement ( &glcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::~CFilterStatusCF
//
//  Synopsis:   Destructor
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

CFilterStatusCF::~CFilterStatusCF ()
{
    //Win4Assert( _cRefs == 0);
    //Win4Assert( glcInstances != 0 );

    InterlockedDecrement( &glcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CFilterStatusCF::QueryInterface ( REFIID riid,
                                               void ** ppvObject )
{
    //Win4Assert ( NULL != ppvObject );

    if ( IID_IUnknown == riid )
    {
        AddRef ();
        *ppvObject = (void *) ((IUnknown *) this);
        return S_OK;
    }
    else if ( IID_IClassFactory == riid )
    {
        AddRef ();
        *ppvObject = (void *) ((IClassFactory *) this);
        return S_OK;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::AddRef
//
//  Synopsis:   Increments the reference count on the object
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusCF::AddRef ()
{
    return InterlockedIncrement ( (long *)&_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterStatusCF::Release
//
//  Synopsis:   Decrements the reference count on the object.
//              If the reference count reaches 0, the object is deleted.
//
//  History:    Jan-13-98   KLam   Created
//
//----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CFilterStatusCF::Release ()
{
    //Win4Assert ( 0 < _cRefs );
    unsigned long cTemp = InterlockedDecrement ( (long *)&_cRefs );

    if ( 0 == cTemp )
        delete this;

    return cTemp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFilterStatusCF::CreateInstance
//
//  Synopsis:   Create new CFilterStatus instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    Jan-13-1998  KLam   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CFilterStatusCF::CreateInstance ( IUnknown * pUnkOuter,
                                               REFIID riid,
                                               void ** ppvObject )
{
    if ( 0 != pUnkOuter )
        return ResultFromScode ( CLASS_E_NOAGGREGATION );

    CFilterStatusDump *pSink = NULL;
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        // Create a new CFilterStatus
        pSink = new CFilterStatusDump;

        // Query the object to see if it supports the desired interface
        sc = pSink->QueryInterface ( riid, ppvObject );

        // Release the class factory's instance of the object
        pSink->Release ();
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pSink );

        sc = GetOleError( e );
    }
    END_CATCH;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFilterStatusCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE to lock ther server. FALSE to unlock the server
//
//  History:    Jan-13-1998  KLam   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CFilterStatusCF::LockServer ( BOOL fLock )
{
    if ( fLock )
        InterlockedIncrement ( &glcInstances );
    else
        InterlockedDecrement ( &glcInstances );

    return S_OK;
}

//
// Exported Routines
//

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]       -- Class to load
//              [iid]       -- Interface to bind to on class object
//              [ppvObject] -- Interface pointer returned here
//
//  Returns:    Text sink dump object
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllGetClassObject( REFCLSID cid,
                          REFIID iid,
                          void ** ppvObject )
{
    CFilterStatusCF * pFactory = NULL;
    SCODE sResult = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        if ( CLSID_CFilterStatusDump == cid )
        {
            pFactory = new CFilterStatusCF;
            if ( NULL != pFactory )
            {
                sResult = pFactory->QueryInterface( iid, ppvObject );
                pFactory->Release ( );
            }
            else
                sResult = E_OUTOFMEMORY;
        }
        else
            sResult = E_NOINTERFACE;
    }
    CATCH(CException, e)
    {
        sResult = GetOleError(e);
    }
    END_CATCH;

    return sResult;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Queries DLL to see if it can be unloaded
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllCanUnloadNow ( )
{
    return ( glcInstances <= 0 ) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllRegisterServer
//
//  Synopsis:   Registers this server with the registry
//
//  Returns:    S_OK if registration succeeded, otherwise SELFREG_E_CLASS
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllRegisterServer ()
{
    WCHAR const * aKeyValues[4] = { gwszFilterStatusDumpCLSID,
                                    gwszDescription,
                                    L"InprocServer32",
                                    gwszModule };

    long retVal = BuildKeyValues( aKeyValues, sizeof(aKeyValues)/sizeof(aKeyValues[0]) );

    if ( ERROR_SUCCESS == retVal )
        retVal = AddThreadingModel( L"{3ce7c910-8d72-11d1-8f76-00a0c91917f5}",
                                    L"Both" );

    if ( ERROR_SUCCESS == retVal )
        return S_OK;
    else
        return SELFREG_E_CLASS;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllUnregisterServer
//
//  Synopsis:   Unregisters this server
//
//  Returns:    S_OK if unregistration succeeded, otherwise SELFREG_E_CLASS
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

STDAPI DllUnregisterServer ()
{
    WCHAR const * aKeyValues[4] = { gwszFilterStatusDumpCLSID,
                                    gwszDescription,
                                    L"InprocServer32",
                                    gwszModule };

    long retval = DestroyKeyValues( aKeyValues,
                                    sizeof(aKeyValues)/sizeof(aKeyValues[0]) );

    if ( ERROR_SUCCESS == retval )
        return S_OK;
    else
        return SELFREG_E_CLASS;
}

//+-------------------------------------------------------------------------
//
//  Method:     DllMain
//
//  Synopsis:   Main routine for DLL.  Saves the module name for this dll.
//
//  Returns:    TRUE
//
//  History:    13-Jan-1998     KLam    Created
//
//--------------------------------------------------------------------------

BOOL APIENTRY DllMain ( HANDLE hModule,
                        DWORD dwReason,
                        void * pReserved )
{
    if ( DLL_PROCESS_ATTACH == dwReason )
    {
        DisableThreadLibraryCalls( (HINSTANCE)hModule );

        //
        // Get the name of the module
        //
        DWORD dwResult = GetModuleFileName ( (HMODULE)hModule,
                                             gwszModule,
                                             sizeof(gwszModule)/sizeof(WCHAR) );
        //Win4Assert( 0 != dwResult );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\loccat\loccat.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation, 1999 - 1999.  All Rights Reserved.
//
// PROGRAM:  loccat.cxx
//
// PURPOSE:  Illustrates LocateCatalogs usage
//
// PLATFORM: Windows
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <ole2.h>
#include <ntquery.h>

void Usage()
{
    printf( "usage: loccat path\n" );
    exit( 1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   LookupCatalogs
//
//  Synopsis:   Looks for catalogs and machines matching the scope
//
//  Arguments:  [pwcScope]   - The scope used to find the catalog(s)
//
//  Returns:    Result of the operation
//
//--------------------------------------------------------------------------

HRESULT LookupCatalog( WCHAR const * pwcScope )
{
    HRESULT hr;
    int iBmk = 0;

    do
    {
        WCHAR awcMachine[ MAX_PATH ], awcCatalog[ MAX_PATH ];
        ULONG cwcMachine = sizeof awcMachine / sizeof WCHAR;
        ULONG cwcCatalog = sizeof awcCatalog / sizeof WCHAR;

        hr = LocateCatalogs( pwcScope,       // scope to lookup
                             iBmk,           // go with the first match
                             awcMachine,     // returns the machine
                             &cwcMachine,    // buffer size in/out
                             awcCatalog,     // returns the catalog
                             &cwcCatalog );  // buffer size in/out

        if ( S_OK == hr )
        {
            printf( "machine: '%ws', catalog: '%ws'\n", awcMachine, awcCatalog );
            iBmk++;
        }
        else if ( S_FALSE == hr )
        {
            // no more catalogs...

            if ( 0 == iBmk )
                printf( "no catalogs matched the path %ws\n", pwcScope );
        }
        else if ( FAILED( hr ) )
        {
            printf( "LocateCatalogs failed: %#x\n", hr );
        }
    } while ( S_OK == hr );

    return hr;
} //LookupCatalogs

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( 2 != argc )
        Usage();

    HRESULT hr = LookupCatalog( argv[1] );

    if ( FAILED( hr ) )
        return -1;

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\pch\empty.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       empty.cxx
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\pch\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>

#include <ddeml.h>

#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <crt\io.h>

#define _CAIROSTG_
#define _DCOM_

//#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <cidebnot.h>
#include <cierror.h>

#include <oleext.h>
#include <oledberr.h>
#include <oledb.h>
#include <dbcmdtre.hxx>
#include <cmdtree.h>
#include <query.h>

#include <filterr.h>            // used in webhits!

//
// Query-specific
//

#include <stgprop.h>

#include <restrict.hxx>
#include <stgvar.hxx>
#include <vquery.hxx>


#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <dynarray.hxx>
#include <dynstack.hxx>
#include <dblink.hxx>
#include <cisem.hxx>
#include <thrd32.hxx>
#include <readwrit.hxx>
#include <ci.h>
#include <ci64.hxx>

#include <qutildbg.hxx>
#include <cidebug.hxx>

#include <align.hxx>

#include <tgrow.hxx>
#include <funypath.hxx>
#include <params.hxx>
//#include <key.hxx>
//#include <keyarray.hxx>
//#include <irest.hxx>
#include <propspec.hxx>
#include <qmemdes.hxx>

#include <dbqrslt.hxx>
#include <tfilt.hxx>

#include <qlibutil.hxx>
#include <parser.hxx>
#include <catstate.hxx>
#include <doquery.hxx>
#include <scanner.hxx>
#include <lgplist.hxx>
#include <plist.hxx>
//#include <wcstoi64.hxx>
#include <strrest.hxx>

#include <string.hxx>
#include <fmapio.hxx>
#include <mbutil.hxx>
#include <qcanon.hxx>
#include <gibralt.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\isrchdmp\isrchdmp.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  isrchdmp.cx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//
// PLATFORM: Windows NT
//
//--------------------------------------------------------------------------

#ifndef UNICODE
#define UNICODE
#endif //ndef UNICODE

#include <stdio.h>
#include <windows.h>

#define OLEDBVER 0x0250 // need the command tree definitions
#define DBINITCONSTANTS

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

#include <ntquery.h>
#include <filter.h>

#include "isearch.h"
#include "array.hxx"

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

typedef void (__stdcall * PFnCIShutdown)(void);
typedef HRESULT (__stdcall * PFnMakeISearch)( ISearchQueryHits ** ppSearch,
                                              DBCOMMANDTREE * pRst,
                                              WCHAR const * pwcPath );

PFnCIShutdown g_pCIShutdown = 0;
PFnMakeISearch g_pMakeISearch = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryCatalog]    - Catalog name over which query is run
//              [pwcQueryMachine]    - Machine name on which query is run
//              [pwcQueryRestrition] - The actual query string
//              [fDisplayTree]       - TRUE to display the command tree
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcFilename,
    WCHAR const * pwcQueryRestriction )
{
    // Create an OLE DB query tree from a text restriction

    DBCOMMANDTREE * pTree;
    HRESULT hr = CITextToSelectTree( pwcQueryRestriction,      // the query itself
                                     &pTree,                   // resulting tree
                                     0,                        // no custom properties
                                     0,                        // no custom properties
                                     GetSystemDefaultLCID() ); // default locale
    if ( FAILED( hr ) )
        return hr;

    // Make the ISearchQueryHits object

    XInterface<ISearchQueryHits> xISearch;
    hr = g_pMakeISearch( xISearch.GetPPointer(),
                         pTree,
                         0 );
    if ( FAILED( hr ) )
        return hr;

    XInterface<IFilter> xIFilter;
    hr = LoadIFilter( pwcFilename, 0, xIFilter.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG ulFlags;
    hr = xIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         0,
                         0,
                         &ulFlags );
    if ( FAILED( hr ) )
        return hr;

    hr = xISearch->Init( xIFilter.GetPointer(), ulFlags );
    if ( FAILED( hr ) )
        return hr;

    //
    // Retrieve all the hit info.  the info is wrt output from the IFilter.
    // a separate pass over a different IFilter is needed to match up
    // text to the hit info.
    //

    TArray<FILTERREGION> aHits;

    ULONG cRegions;
    FILTERREGION* aRegion;
    hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    
    while ( S_OK == hr )
    {
        for ( ULONG i = 0; i < cRegions; i++ )
            aHits.Append( aRegion[i] );

        CoTaskMemFree( aRegion );
        hr = xISearch->NextHitOffset( &cRegions, &aRegion );
    }

    for ( ULONG i = 0; i < aHits.Count(); i++ )
        printf( "hit %d, chunk %d start %d extent %d\n",
                i, aHits[i].idChunk, aHits[i].cwcStart, aHits[i].cwcExtent );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "usage: isrchdmp query [/f:filename]\n\n" );
    printf( "    query        an Indexing Service query\n" );
    printf( "    /f:filename  filename to search\n" );
    exit( -1 );
} //Usage

HINSTANCE GetFunctions()
{
    HINSTANCE h = LoadLibrary( L"query.dll" );

    if ( 0 != h )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YAJPEAPEAUISearchQueryHits@@PEAVCDbRestriction@@PEBG@Z";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
            char const * pcMakeISearch = "?MakeISearch@@YGJPAPAUISearchQueryHits@@PAVCDbRestriction@@PBG@Z";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( h, pcCIShutdown );

        if ( 0 == g_pCIShutdown )
        {
            FreeLibrary( h );
            return 0;
        }

        g_pMakeISearch = (PFnMakeISearch) GetProcAddress( h, pcMakeISearch );

        if ( 0 == g_pMakeISearch )
        {
            FreeLibrary( h );
            return 0;
        }
    }

    return h;
} //GetFunctions

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments
//              and issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcFilename    = 0;
    WCHAR const * pwcRestriction = 0;         // no default restriction

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( argv[i][1] );

            if ( ':' != argv[i][2] && 'D' != wc )
                Usage();

            if ( 'F' == wc )
                pwcFilename = argv[i] + 3;
            else
                Usage();
        }
        else if ( 0 != pwcRestriction )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction is necessary.  Fail if none is given.

    if ( 0 == pwcRestriction )
        Usage();

    // Load query.dll entrypoints

    HINSTANCE h = GetFunctions();

    if ( 0 == h )
    {
        printf( "can't load query.dll entrypoints\n" );
        return -1;
    }

    HRESULT hr = CoInitialize( 0 );

    // Run the query

    if ( SUCCEEDED( hr ) )
    {
        hr = DoQuery( pwcFilename, pwcRestriction );

        g_pCIShutdown();
        CoUninitialize();
    }

    if ( FAILED( hr ) )
    {
        printf( "the query '%ws' failed with error %#x\n",
                pwcRestriction, hr );
        return -1;
    }

    FreeLibrary( h );

    printf( "done!\n" );

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\idtopath\idtopath.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       idtopath.cxx
//
//  Contents:   Convert file ID to path name
//
//  History:    16 Jul 1997     DLee    Created
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <process.h>
#include <fcntl.h>
#include <string.h>

void die( char * pc, NTSTATUS s )
{
    printf( "fail: 0x%x, '%s'\n", s, pc );
    exit( 1 );
} //die

void OpenById( HANDLE hVol, LONGLONG ll, WCHAR wcVol )
{
    UNICODE_STRING uScope;
    uScope.Buffer = (WCHAR *) &ll;
    uScope.Length = sizeof ll;
    uScope.MaximumLength = sizeof ll;

    OBJECT_ATTRIBUTES ObjectAttr;
    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                hVol,                 // Root
                                0 );                  // Security

    IO_STATUS_BLOCK IoStatus;
    HANDLE h = INVALID_HANDLE_VALUE;
    NTSTATUS Status = NtOpenFile( &h,                
                                  FILE_READ_ATTRIBUTES,
                                  &ObjectAttr,       
                                  &IoStatus,         
                                  FILE_SHARE_READ |
                                      FILE_SHARE_WRITE |
                                      FILE_SHARE_DELETE,
                                  FILE_OPEN_BY_FILE_ID );

    if ( NT_ERROR( Status ) )
    {
        if ( STATUS_INVALID_PARAMETER == Status )
        {
            printf( "no file exists with fileid %#I64x on volume %wc\n", ll, wcVol );
            exit( 1 );
        }
        else
            die( "can't open file", Status );
    }

    unsigned cbMax = 32768 * sizeof WCHAR + sizeof FILE_NAME_INFORMATION;

    BYTE * pBuf = new BYTE[cbMax];
    if ( 0 == pBuf )
        return;

    PFILE_NAME_INFORMATION FileName = (PFILE_NAME_INFORMATION) pBuf;
    FileName->FileNameLength = cbMax - sizeof FILE_NAME_INFORMATION;

    Status = NtQueryInformationFile( h,
                                     &IoStatus,
                                     FileName, 
                                     cbMax,
                                     FileNameInformation );
                                            
    if ( NT_ERROR( Status ) )
       die( "can't get filename", Status );

    // This is actually the full path, not the filename

    FileName->FileName[ FileName->FileNameLength / sizeof WCHAR ] = 0;

    printf( "fileid %#I64x: '%wc:%ws'\n", ll, wcVol, FileName->FileName );

    delete [] pBuf;

    NtClose( h );
} //OpenById

void Usage()
{
    printf( "usage: idtopath /v:volume /i:fileid\n" );
    printf( "  e.g.: idtopath /v:c /i:2000000001a99\n" );
    exit( 1 );
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const *pwcId = 0;
    WCHAR wcVol = 0;

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( argv[i][1] );

            if ( ':' != argv[i][2] )
                Usage();

            if ( 'V' == wc )
                wcVol = argv[i][3];
            else if ( 'I' == wc )
                pwcId = argv[i] + 3;
            else
                Usage();
        }
        else
            Usage();
    }

    if ( 0 == wcVol || 0 == pwcId )
        Usage();

    LONGLONG ll = 0;
    swscanf( pwcId, L"%I64x", &ll );

    WCHAR awcVol[20];
    wcscpy( awcVol, L"\\\\.\\k:" );
    awcVol[4] = wcVol;

    HANDLE h = CreateFileW( awcVol,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            0, 0 );
                                  
    if ( INVALID_HANDLE_VALUE == h )
        die( "can't open volume", GetLastError() );

    OpenById( h, ll, wcVol );

    CloseHandle( h );
    return 0;
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\pd1.1\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       main.cxx
//
//  Contents:   Index Server V1.x property file dumper.
//
//  History:    29 Oct 1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proprec.hxx>
#include <propdesc.hxx>


DECLARE_INFOLEVEL(ci)

unsigned const SixtyFourK = 1024 * 64;
unsigned const cMaxFields = 10;

unsigned fVerbose = 0;

enum eRecType
{
    Virgin,
    Top,
    Overflow,
    Free
};

struct SmallInfo
{
    ULONG Type;
    ULONG Length;
    ULONG ulPrev;
    ULONG ulNext;
    ULONG ulChainLength;
};

int __cdecl main( int argc, char * argv[] )
{
    char *   pszFile = argv[1];
    BOOL     fReadMetadata = 0;
    unsigned cField = 0;
    int      aiField[cMaxFields];

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'v':
            case 'V':
                fVerbose = 1;
                break;

            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField < cMaxFields )
                    aiField[cField++] = strtol( argv[i], 0, 10 );
                break;
            }
        }
        else
            pszFile = argv[i];

    }

    BYTE abTemp[SixtyFourK];

    //
    // First, read out the metadata
    //

    unsigned cFixed = 0;
    unsigned cTotal = 0;
    unsigned culFixed = 0;
    CPropDesc aFieldRec[cMaxFields];

    if ( fReadMetadata || cField != 0 )
    {
        //
        // Build path.
        //

        char szPath[MAX_PATH];
        strcpy( szPath, pszFile );
        char * pLastSlash = strrchr( szPath, '\\' );
        pLastSlash++;
        strcpy( pLastSlash, "CIPS0000.001" );

        HANDLE h = CreateFileA( szPath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                0,
                                OPEN_EXISTING,
                                0,
                                0 );

        if ( INVALID_HANDLE_VALUE == h )
        {
            printf( "Can't open file %s. Error %u\n", szPath, GetLastError() );
            return 0;
        }

        ULONG cbRead;

        if ( ReadFile( h,
                       abTemp,
                       sizeof(abTemp),
                       &cbRead,
                       0 ) )
        {
            //
            // Loop through records
            //

            CPropDesc * pPropDesc = (CPropDesc *)abTemp;

            if ( fReadMetadata )
                printf( "Record\tPid\t\tType\t\tOffset\tSize\tOrdinal\tMask\n" );

            for ( unsigned i = 0; i < cbRead/sizeof(CPropDesc); i++, pPropDesc++ )
            {
                if ( pPropDesc->Pid() != 0 )
                {
                    if ( fReadMetadata )
                        printf( "%u:\t%u (0x%x)%s\t%u (0x%x)\t%d\t%u\t%u\t0x%x\n",
                                pPropDesc->Record(),
                                pPropDesc->Pid(), pPropDesc->Pid(),
                                (pPropDesc->Pid() > 10) ? "" : "\t",
                                pPropDesc->Type(), pPropDesc->Type(),
                                pPropDesc->Offset(),
                                pPropDesc->Size(),
                                pPropDesc->Ordinal(),
                                pPropDesc->Mask() );

                    cTotal++;

                    if ( pPropDesc->Offset() != -1 )
                    {
                        cFixed++;
                        culFixed += (pPropDesc->Size() / sizeof(DWORD));
                    }

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        if ( aiField[j] == (int)pPropDesc->Record() )
                            memcpy( &aFieldRec[j], pPropDesc, sizeof(aFieldRec[0]) );
                    }
                }
            }

            printf( "\n%u Properties, %u Fixed totaling %u bytes\n\n", cTotal, cFixed, culFixed * sizeof(DWORD) );
        }
        else
        {
            printf( "Can't read file %s.  Error %u\n", szPath, GetLastError() );
            return 0;
        }
    }


    HANDLE h = CreateFileA( pszFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszFile, GetLastError() );
        return 0;
    }

    BY_HANDLE_FILE_INFORMATION fi;

    if ( !GetFileInformationByHandle( h, &fi ) )
    {
        printf( "Error %u getting size from handle\n", GetLastError() );
        return 0;
    }

    ULONG oFile = 0;
    ULONG cbRec = 0;
    ULONG cRecPerBuf;
    ULONG cRecTotal;
    ULONG cTotalSections = 0;

    HANDLE hSmallInfo;
    SmallInfo * aSmallInfo = 0;

    ULONG iSection = 0;

    BOOL fFirst = TRUE;

    ULONG iCurrentPct = 0;

    for (;;)
    {
        ULONG cbRead;

        if ( ReadFile( h,
                       abTemp,
                       sizeof(abTemp),
                       &cbRead,
                       0 ) )
        {
            if (fVerbose)
                printf( "READ: 0x%x bytes, offset %0x%x\n", cbRead, oFile );

            if ( 0 == cbRead )
                break;

            if ( fFirst )
            {
                //
                // Determine record size
                //

                if ( abTemp[0] != 0 || abTemp[1] != 0 )
                {
                    printf( "Record 0 not blank.  File corrupt!\n" );
                    break;
                }

                for ( unsigned i = 0; i < cbRead && abTemp[i] == 0; i++ )
                    continue;

                if ( i == cbRead )
                {
                    printf( "First %uK segment all zero!.  File corrupt!\n", sizeof(abTemp)/1024 );
                    break;
                }

                switch ( *(USHORT *)&abTemp[i] )
                {
                case 0x5555:
                case 0xAAAA:
                case 0xBBBB:
                    cbRec = i;

                    if ( cbRec % 4 != 0 )
                    {
                        printf( "Record size (%u bytes) not DWORD aligned!\n\n", cbRec );
                        return 0;
                    }

                    cRecPerBuf = sizeof(abTemp) / cbRec;
                    printf( "Record size: %u bytes (%u / %uK)\n", i, cRecPerBuf, sizeof(abTemp)/1024 );
                    cTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;

                    hSmallInfo = LocalAlloc( LMEM_MOVEABLE,
                                             ((fi.nFileSizeLow / sizeof(abTemp)) + 1) * cRecPerBuf * sizeof(SmallInfo) );
                    aSmallInfo = (SmallInfo *)LocalLock( hSmallInfo );

                    break;

                default:
                    printf( "First non-zero byte is not a proper signature (%u)!\n", *(SHORT *)&abTemp[i] );
                    return 0;
                }

                fFirst = FALSE;
            }

            ULONG iRec = 0;

            while ( iRec < cRecPerBuf )
            {
                COnDiskPropertyRecord * pRec = new( iRec, abTemp, cbRec/4 ) COnDiskPropertyRecord;

                if ( !pRec->IsValidType() )
                {
                    printf( "Record 0x%x (%u:%u) (file offset 0x%x) is corrupt!\n",
                            iSection * cRecPerBuf + iRec,
                            iSection, iRec,
                            iSection * sizeof(abTemp) + iRec * cbRec );
                }

                if (fVerbose )
                    printf( "%u:%u, %s, length = %u record(s)",
                        iSection, iRec,
                        pRec->IsTopLevel() ? "Top Level" :
                            pRec->IsOverflow() ? "Overflow" :
                                pRec->IsFreeRecord() ? "Free" :
                                    "Virgin",
                        pRec->CountRecords() );

                aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = 0;

                if ( pRec->IsOverflow() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Overflow;

                    /* printf( ", Previous = %u:%u (file offset 0x%x)",
                            pRec->PreviousBlock() / cRecPerBuf,
                            pRec->PreviousBlock() % cRecPerBuf,
                            (pRec->PreviousBlock() / cRecPerBuf) * sizeof(abTemp) +
                                (pRec->PreviousBlock() % cRecPerBuf) * cbRec ); */
                }
                else if ( pRec->IsTopLevel() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Top;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = pRec->GetOverflowChainLength();

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        if ( aFieldRec[j].IsFixedSize() )
                        {
                            pRec->ReadFixed( aFieldRec[j].Ordinal(),
                                             aFieldRec[j].Mask(),
                                             aFieldRec[j].Offset(),
                                             cTotal,
                                             aFieldRec[j].Type(),
                                             var,
                                             abExtra,
                                             &cbExtra );

                            switch ( var.vt )
                            {
                            case VT_EMPTY:
                                printf( "n/a " );
                                break;

                            case VT_I4:
                                printf( "%8d ", var.iVal );
                                break;

                            case VT_UI4:
                                printf( "%8u ", var.uiVal );
                                break;

                            case VT_FILETIME:
                                printf( "%8u,%8u ",
                                        var.filetime.dwHighDateTime,
                                        var.filetime.dwLowDateTime );
                                break;

                            case VT_I8:
                                printf( "%12hu ", var.hVal );
                                break;
                            }
                        }
                        else
                        {
                            BOOL fOk = pRec->ReadVariable( aFieldRec[j].Ordinal(),
                                                           aFieldRec[j].Mask(),
                                                           culFixed,
                                                           cTotal,
                                                           cFixed,
                                                           var,
                                                           abExtra,
                                                           &cbExtra );

                            if ( fOk )
                            {
                                switch ( var.vt )
                                {
                                case VT_LPSTR:
                                    printf( "%s ", var.pszVal );
                                    break;

                                case VT_LPWSTR:
                                    printf( "%ws ", var.pwszVal );
                                    break;
                                }
                            }
                        }
                    }

                    if ( 0 != cField )
                        printf( "\n" );
                }
                else if ( pRec->IsFreeRecord() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Free;
                }
                else
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Virgin;
                }

                // 1.1 vs 2.0 change // aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = pRec->ToplevelBlock();
                aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = pRec->OverflowBlock();
                aSmallInfo[iSection*cRecPerBuf + iRec].Length = pRec->CountRecords();

                if ( pRec->CountRecords() == 0 )
                {
                    printf( "Record %u (file offset 0x%x) is zero length!\n",
                            iSection * cRecPerBuf + iRec,
                            iSection * sizeof(abTemp) + iRec * cbRec );
                }

                if ( pRec->OverflowBlock() != 0 )
                {
                    /* printf( ", Overflow = %u:%u (file offset 0x%x)",
                            pRec->OverflowBlock() / cRecPerBuf,
                            pRec->OverflowBlock() % cRecPerBuf,
                            (pRec->OverflowBlock() / cRecPerBuf) * sizeof(abTemp) +
                                (pRec->OverflowBlock() % cRecPerBuf) * cbRec ); */
                }

                if (fVerbose)
                    printf( "\n" );

                if ( pRec->IsValidType() )
                    iRec += pRec->CountRecords();
                else
                    iRec++;

                ULONG iPct = (iSection * (100/5) / cTotalSections) * 5;
                if (iPct != iCurrentPct)
                {
                    iCurrentPct = iPct;
                    printf( "Read %u%%\n", iCurrentPct );
                }

            }

            iSection++;
            oFile += cbRead;
        }
        else
        {
            ULONG Status = GetLastError();

            if ( Status == ERROR_HANDLE_EOF )
                break;
            else
            {
                printf( "Error %u reading file.\n", Status );
            }
        }
    }

    printf( "Read 100%%\n" );

    CloseHandle( h );

    //
    // Now check inter-record state
    //

    unsigned iRec = 0;
    unsigned iCurrentSection = 0;
    iCurrentPct = 0;

    while ( iRec < iSection * cRecPerBuf )
    {
        if ( aSmallInfo[iRec].Type == Top )
        {
            unsigned iOverflowRec = aSmallInfo[iRec].ulNext;
            unsigned cOverflowRec = 0;

            while ( 0 != iOverflowRec )
            {
                if ( aSmallInfo[iOverflowRec].Type != Overflow )
                {
                    printf( "Record 0x%x (%u:%u) (file offset 0x%x) should be overflow and is not!\n   Top level = 0x%x (%u:%u) (file offset 0x%x)\n",
                            iOverflowRec,
                            iOverflowRec / cRecPerBuf,
                            iOverflowRec % cRecPerBuf,
                            (iOverflowRec / cRecPerBuf) * sizeof(abTemp) +
                                (iOverflowRec % cRecPerBuf) * cbRec,
                            iRec,
                            iRec / cRecPerBuf,
                            iRec % cRecPerBuf,
                            (iRec / cRecPerBuf) * sizeof(abTemp) +
                                (iRec % cRecPerBuf) * cbRec );

                    break;
                }

                iOverflowRec = aSmallInfo[iOverflowRec].ulNext;
                cOverflowRec++;
                if ( cOverflowRec > aSmallInfo[iRec].ulChainLength )
                    break;
            }

            if ( aSmallInfo[iRec].ulChainLength != cOverflowRec )
            {
                printf( "Record 0x%x (%u:%u) (file offset 0x%x) chain length mismatch %d,%d!\n",
                        iRec,
                        iRec / cRecPerBuf,
                        iRec % cRecPerBuf,
                        (iRec / cRecPerBuf) * sizeof(abTemp) +
                                (iRec % cRecPerBuf) * cbRec,
                        aSmallInfo[iRec].ulChainLength, cOverflowRec );
            }
        }

        if (aSmallInfo[iRec].Length == 0)
        {
            printf( "%u:%u (file offset 0x%x) zero length record!\n",
                    iRec / cRecPerBuf,
                    iRec % cRecPerBuf,
                    (iRec / cRecPerBuf) * sizeof(abTemp) +
                        (iRec % cRecPerBuf) * cbRec );

            iRec++;
        } else {
            iRec += aSmallInfo[iRec].Length;
        }

        if ( (iRec / cRecPerBuf) != iCurrentSection )
        {
            if (fVerbose)
                printf( "Checked section %u\n", iCurrentSection );

            ULONG iPct = (iCurrentSection * (100/5) / iSection) * 5;
            if (iPct != iCurrentPct)
            {
                iCurrentPct = iPct;
                printf( "Checked %u%%\n", iCurrentPct );
            }

            iCurrentSection = (iRec / cRecPerBuf);
        }
    }

    printf( "Checked 100%%\n" );

    LocalUnlock( hSmallInfo );
    LocalFree( hSmallInfo );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\pd1.1\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------


// CoTaskAllocator is 'extern' to items in query.dll except where defined,
// where it is __declspec(dllexport).
// To all other dlls, it is __declspec(dllimport)
//

#define COTASKDECLSPEC extern

// Define this so Win4ExceptionLevel is exported in query.dll, and
// imported elsewhere.

#if CIDBG==1
#define __QEXCEPT__
#endif // CIDBG==1

#define _OLE32_
#define __QUERY__

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

    #include <ctype.h>
    #include <float.h>
    #include <limits.h>
    #include <malloc.h>
    #include <math.h>
    #include <memory.h>
    #include <stddef.h>
    #include <string.h>
    #include <stdarg.h>
    #include <stdio.h>
    #include <stdlib.h>

#include <windows.h>
#include <imagehlp.h>

#define _DCOM_
#define _CAIROSTG_

#include <cidebnot.h>

#include <cierror.h>
#include <stgprop.h>
#include <restrict.hxx>

//
// Base services
//

#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <dynarray.hxx>
#include <dynstack.hxx>
#include <dblink.hxx>
#include <cisem.hxx>
#include <thrd32.hxx>
#include <ci.h>

//
// Debug files from
//

#include <cidebug.hxx>
#include <vqdebug.hxx>

// property-related macros and includes

#include <propapi.h>
#include <propstm.hxx>
extern UNICODECALLOUTS UnicodeCallouts;
#define DebugTrace( x, y, z )
#ifdef PROPASSERTMSG
#undef PROPASSERTMSG
#endif
#define PROPASSERTMSG( x, y )

//
// Special, for this .exe
//

typedef ULONG WORKID;       // From ci.h

inline void ReportCorruptComponent( WCHAR const * pwszArea )
{
    printf( "Corruption detected! Area %ws\n", pwszArea );
}

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\pd1.1\proprec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       PropRec.cxx
//
//  Contents:   Record format for persistent property store
//
//  Classes:    CPropertyRecord
//
//  History:    28-Dec-19   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <stgvar.hxx>
#include <propvar.h>
#include <propstm.hxx>
#include <proprec.hxx>
#include <eventlog.hxx>

class CCTMABufferAllocator : public PMemoryAllocator
{
public:

    void *Allocate(ULONG cbSize)
    {
        return CoTaskMemAlloc( cbSize );
    }

    void Free(void *pv)
    {
        CoTaskMemFree( pv );
    }
};

class CNonAlignAllocator : public PMemoryAllocator
{
public:
    inline CNonAlignAllocator(ULONG cbBuffer, VOID *pvBuffer)
    {
        _cbFree = cbBuffer;
        _pvCur = _pvBuffer = pvBuffer;
    }

    VOID *Allocate(ULONG cb)
    {
        VOID *pv;

        cb = (cb + sizeof(LONGLONG) - 1) & ~(sizeof(LONGLONG) - 1);
        if (cb > _cbFree)
        {
            return(NULL);
        }
        pv = _pvCur;
        _pvCur = (BYTE *) _pvCur + cb;
        _cbFree -= cb;
        return(pv);
    }

    VOID Free(VOID *pv) { }

    inline ULONG GetFreeSize(VOID) { return(_cbFree); }

private:
    ULONG  _cbFree;
    VOID  *_pvCur;
    VOID  *_pvBuffer;
};


//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::ReadFixed, public
//
//  Synopsis:   Read fixed-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of specific fixed property.
//              [cTotal]   -- Total number of properties in record.
//              [Type]     -- Data type of value
//              [var]      -- Value returned here.
//              [pbExtra]  -- Indirect data stored here
//              [pcbExtra] -- On input, size of [pbExtra].  On output,
//                            amount used.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::ReadFixed( ULONG Ordinal,
                                       ULONG Mask,
                                       ULONG oStart,
                                       ULONG cTotal,
                                       ULONG Type,
                                       PROPVARIANT & var,
                                       BYTE * pbExtra,
                                       unsigned * pcbExtra )
{
    if ( !IsStored( Ordinal, Mask ) )
    {
        var.vt = VT_EMPTY;
        *pcbExtra = 0;
    }
    else
    {
        var.vt = (USHORT)Type;

        //
        // Start is after existance bitmap
        //

        ULONG const * pulStart = &_aul[ (cTotal-1) / 16 + 1 + oStart];

        switch ( Type )
        {
        case VT_I1:
        case VT_UI1:
            var.bVal = *(BYTE *)pulStart;
            *pcbExtra = 0;
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            var.uiVal = *(USHORT *)pulStart;
            *pcbExtra = 0;
            break;

        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
            var.ulVal = *pulStart;
            *pcbExtra = 0;
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            RtlCopyMemory( &var.hVal, pulStart, sizeof(var.hVal) );
            *pcbExtra = 0;
            break;

        case VT_CLSID:
            if ( *pcbExtra < sizeof(CLSID) )
            {
                *pcbExtra = sizeof(CLSID);
                return;
            }

            if ( *pcbExtra == 0xFFFFFFFF )
                var.puuid = (CLSID *)CoTaskMemAlloc( sizeof(CLSID) );
            else
            {
                *pcbExtra = sizeof(CLSID);
                var.puuid = (CLSID *)pbExtra;
            }
            RtlCopyMemory( var.puuid, pulStart, sizeof(CLSID) );
            break;

        default:
            ciDebugOut(( DEB_ERROR, "PROPSTORE: Reading invalid fixed type %d.\n", Type ));
            Win4Assert( !"How did I get here?" );
            ReportCorruptComponent( L"PropertyRecord1" );
            THROW( CException( CI_CORRUPT_DATABASE ) );
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::ReadVariable, public
//
//  Synopsis:   Read variable-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of variable storage area.
//              [cTotal]   -- Total number of properties in record.
//              [cFixed]   -- Count of fixed length properties
//              [var]      -- Value returned here.
//              [pbExtra]  -- Indirect data stored here
//              [pcbExtra] -- On input, size of [pbExtra].  On output,
//                            amount used.
//
//  Returns:    FALSE if value must be stored in overflow record.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL COnDiskPropertyRecord::ReadVariable( ULONG Ordinal,
                                          ULONG Mask,
                                          ULONG oStart,
                                          ULONG cTotal,
                                          ULONG cFixed,
                                          PROPVARIANT & var,
                                          BYTE * pbExtra,
                                          unsigned * pcbExtra )
{
    if ( !IsStored( Ordinal, Mask ) )
    {
        var.vt = VT_EMPTY;
        *pcbExtra = 0;
    }
    else
    {
        //
        // Check for overflow.
        //

        if ( IsStoredOnOverflow( Ordinal, Mask ) )
            return FALSE;

        //
        // Start is after existance bitmap and fixed properties.
        //

        ULONG * pulStart = FindVariableProp( Ordinal, cFixed, cTotal, oStart );

        Win4Assert( !IsOverflow( *pulStart ) );

        //
        // Compute the length of the property.
        //

        ULONG cbProp = UsedSize( *pulStart ) * 4;
        pulStart++;  // Skip size field.

        ciDebugOut(( DEB_PROPSTORE,
                     "Reading variable prop, ordinal %d at offset 0x%x (%d) in record. Size = %d bytes.\n",
                     Ordinal,
                     (ULONG)pulStart - (ULONG)this,
                     (ULONG)pulStart - (ULONG)this,
                     cbProp ));

        ULONG cb = PropertyLengthAsVariant( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                            cbProp,
                                            CP_WINUNICODE,
                                            0 );

        if ( cb <= *pcbExtra )
        {
            if ( *pcbExtra == 0xFFFFFFFF )
            {
                //
                // Unmarshall the property.  Extra allocation via CoTaskMemAlloc
                //

                CCTMABufferAllocator BufferMgr;

                RtlConvertPropertyToVariant( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                             CP_WINUNICODE,
                                             &var,
                                             &BufferMgr );

#if CIDBG==1
                if ( (var.vt&0x0fff) > VT_CLSID )
                {
                    ciDebugOut(( DEB_ERROR, "Bad Variant Type 0x%X\n", var.vt ));
                    Win4Assert( !"Call KyleP" );
                }
#endif  // CIDBG==1

            }
            else
            {
                //
                // Unmarshall the property.
                //

                CNonAlignAllocator BufferMgr( *pcbExtra, pbExtra );

                RtlConvertPropertyToVariant( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                             CP_WINUNICODE,
                                             &var,
                                             &BufferMgr );
#if CIDBG==1
                if ( (var.vt&0x0fff) > VT_CLSID )
                {
                    ciDebugOut(( DEB_ERROR, "Bad Variant Type 0x%X\n", var.vt ));
                    Win4Assert( !"Call KyleP" );
                }
#endif  // CIDBG==1

            }
        }
        *pcbExtra = cb;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::WriteFixed, public
//
//  Synopsis:   Write fixed-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of specific property.
//              [Type]     -- Expected data type (for type checking)
//              [cTotal]   -- Total number of properties in record.
//              [var]      -- Value to store.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::WriteFixed( ULONG Ordinal,
                                        ULONG Mask,
                                        ULONG oStart,
                                        ULONG Type,
                                        ULONG cTotal,
                                        CStorageVariant const & var )
{
    if ( var.Type() != (VARENUM)Type )
    {
#       if CIDBG == 1
            if ( var.Type() != VT_EMPTY )
                ciDebugOut(( DEB_WARN, "Type mismatch (%d vs. %d) writing fixed property\n",
                             var.Type(), Type ));
#       endif

        ClearStored( Ordinal, Mask );
        return;
    }

    //
    // Start is after existance bitmap
    //

    ULONG * pulStart = &_aul[ (cTotal-1) / 16 + 1 + oStart];

    ciDebugOut(( DEB_PROPSTORE,
                 "Writing fixed prop, ordinal %d (type %d) at offset 0x%x (%d) in record.\n",
                 Ordinal,
                 var.Type(),
                 (ULONG)pulStart - (ULONG)this,
                 (ULONG)pulStart - (ULONG)this ));

    switch ( var.Type() )
    {
    case VT_I1:
    case VT_UI1:
        Win4Assert( !"Fix this!" );
        //*(BYTE *)pulStart = var.GetUI1();
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        {
            ULONG ul = var.GetUI2();
            *pulStart = ul;
        }
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        *pulStart = var.GetUI4();
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        {
            ULARGE_INTEGER uli = var.GetUI8();
            RtlCopyMemory( pulStart, &uli, sizeof(uli) );
        }
        break;

    case VT_CLSID:
        RtlCopyMemory( pulStart, var.GetCLSID(), sizeof(CLSID) );
        break;

    default:
        Win4Assert( !"How did I get here?" );
        ClearStored( Ordinal, Mask );
        break;
    }

    SetStored( Ordinal, Mask );
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::WriteVariable, public
//
//  Synopsis:   Write variable-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of variable length area.
//              [cTotal]   -- Total number of properties in record.
//              [cFixed]   -- Count of fixed length properties
//              [culRec]   -- Size (in dwords) of record
//              [var]      -- Value to store.
//
//  Returns:    FALSE if record must be stored in overflow record.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL COnDiskPropertyRecord::WriteVariable( ULONG Ordinal,
                                           ULONG Mask,
                                           ULONG oStart,
                                           ULONG cTotal,
                                           ULONG cFixed,
                                           ULONG culRec,
                                           CStorageVariant const & var )
{
    ULONG * pulStart = FindVariableProp( Ordinal, cFixed, cTotal, oStart );

    //
    // Are we freeing this property?
    //

    if ( var.Type() == VT_EMPTY )
    {
        ClearStored( Ordinal, Mask );
        ClearStoredOnOverflow( Ordinal, Mask );

        //
        // Overflow case: We need to fake the overflow to clean up linked records.
        //

        if ( IsOverflow( *pulStart ) )
        {
            SetUsedSize( pulStart, 0 );
            return FALSE;
        }
        else
        {
            //
            // Adjust size field, and total variable space for record.
            //

            Win4Assert( _culVariableUsed >= UsedSize( *pulStart ) );
            _culVariableUsed -= UsedSize( *pulStart );

            SetUsedSize( pulStart, 0 );

            return TRUE;
        }
    }

    //
    // No matter what happens, we want to indicate the property was stored.
    //

    SetStored( Ordinal, Mask );
    ClearStoredOnOverflow( Ordinal, Mask );


    //
    // Compute the length of the property.
    //

    ULONG cul = 0;
    RtlConvertVariantToProperty( (PROPVARIANT *)(ULONG)&var,
                                 CP_WINUNICODE,
                                 0,
                                 &cul,
                                 pidInvalid,
                                 FALSE,
                                 0 );

    Win4Assert( cul > 0 );
    cul = (cul - 1) / 4 + 1;

    ULONG culPrevUsed = UsedSize( *pulStart );

    //
    // Do we fit?
    //

    if ( cul > AllocatedSize( *pulStart ) )
    {
        //
        // Can we fit?
        //

        if ( cul >
             UsedSize( *pulStart ) + FreeVariableSpace( cTotal, cFixed, oStart, culRec ) )
        {
            ciDebugOut(( DEB_PROPSTORE, "Need overflow buffer for ordinal %u\n", Ordinal ));

            //
            // If we had a previous value, adjust total variable space for record.
            //

            if ( !IsOverflow( *pulStart ) )
            {
                Win4Assert( _culVariableUsed >= UsedSize( *pulStart ) );
                _culVariableUsed -= UsedSize( *pulStart );
            }

            MarkOverflow( pulStart );
            SetStoredOnOverflow( Ordinal, Mask );
            return FALSE;
        }

        //
        // Need to move properties, but there *is* room in record for the shift.
        //

        //
        // First, compress previous properties.
        //

        #if CIDBG
            ULONG * pulOldStart = pulStart;
        #endif

        pulStart = LeftCompress( FindVariableProp( cFixed, cFixed, cTotal, oStart ),
                                 0,
                                 pulStart );

        ciDebugOut(( DEB_PROPSTORE,
                     "Freeing up %d bytes for variable prop %d via left compression\n",
                     (pulOldStart - pulStart) * 4,
                     Ordinal ));

        //
        // Then, if needed, push additional properties farther out.
        //

        if ( cul > AllocatedSize( *pulStart ) )
        {
            ULONG * pulNext = pulStart + AllocatedSize(*pulStart) + 1;
            ULONG   culDelta = cul - AllocatedSize(*pulStart);

            ciDebugOut(( DEB_PROPSTORE,
                         "Freeing up %d bytes for variable prop %d, starting at offset 0x%x (%d) via right compression\n",
                         culDelta * 4,
                         Ordinal,
                         (ULONG)pulNext - (ULONG)this,
                         (ULONG)pulNext - (ULONG)this ));

            Win4Assert( Ordinal < cTotal );

            RightCompress( pulNext,                  // Next property
                           culDelta,                 // Amount to shift
                           cTotal - Ordinal - 1 );   // # props left in record

            SetAllocatedSize( pulStart, cul );
        }

        Win4Assert( cul <= AllocatedSize( *pulStart ) );
    }

    //
    // Adjust size field, and total variable space for record.
    //

    _culVariableUsed += cul - culPrevUsed;

    SetUsedSize( pulStart, cul );
    pulStart++;  // Skip size field

    Win4Assert( AllocatedSize( *(pulStart - 1)) >= UsedSize( *(pulStart - 1) ) );
    ciDebugOut(( DEB_PROPSTORE,
                 "Writing variable prop, ordinal %d at offset 0x%x (%d) in record. Size = %d bytes.\n",
                 Ordinal,
                 (ULONG)pulStart - (ULONG)this,
                 (ULONG)pulStart - (ULONG)this,
                 UsedSize(*(pulStart - 1)) * 4 ));

    cul *= 4;
    if ( 0 == RtlConvertVariantToProperty( (PROPVARIANT *)(ULONG)&var,
                                           CP_WINUNICODE,
                                           (SERIALIZEDPROPERTYVALUE *)pulStart,
                                           &cul,
                                           pidInvalid,
                                           FALSE,
                                           0 ) )
    {
        ciDebugOut(( DEB_ERROR, "Error marshalling property!\n" ));
        ReportCorruptComponent( L"PropertyRecord2" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::CountRecordsToStore, public
//
//  Synopsis:   Compute size of value
//
//  Arguments:  [cTotal]   -- Total number of properties in record.
//              [culRec]   -- Size (in dwords) of record
//              [var]      -- Value to store.
//
//  Returns:    Size in records needed to store property.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG COnDiskPropertyRecord::CountRecordsToStore( ULONG cTotal,
                                                  ULONG culRec,
                                                  CStorageVariant const & var )
{
    //
    // Compute the length of the property.
    //

    ULONG cul = 0;
    RtlConvertVariantToProperty( (PROPVARIANT *)(ULONG)&var,
                                 CP_WINUNICODE,
                                 0,
                                 &cul,
                                 pidInvalid,
                                 FALSE,
                                 0 );

    Win4Assert( cul > 0 );
    cul = (cul - 1) / 4 + 1;

    //
    // Add on the fixed overhead.
    //

    cul += FixedOverhead() +       // Fixed overhead
           (cTotal - 1) / 16 + 1 + // Existence bitmap
           cTotal;                 // Used/Alloc sizes

    return (cul - 1) / culRec + 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::RightCompress, public
//
//  Synopsis:   Moves data from [pul], [cul] dwords up.
//
//  Arguments:  [pul]        -- Start of area to move.
//              [cul]        -- Count of dwords to move
//              [cRemaining] -- Count of values remaining in buffer.  Needed
//                              because it is impossible to distinguish
//                              used/alloc blocks from empty space.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::RightCompress( ULONG * pul, ULONG cul, ULONG cRemaining )
{
    //
    // Termination condition for recursion: We've scanned all variable
    // properties in this record.  Any remaining space in record is
    // guaranteed to be free.
    //

    if ( 0 == cRemaining )
        return;

    ULONG FreeSpace = AllocatedSize(*pul) - UsedSize(*pul);
    if ( FreeSpace >= cul )
    {
        SetAllocatedSize( pul, AllocatedSize(*pul) - cul );
    }
    else
    {
        RightCompress( pul + AllocatedSize(*pul) + 1, cul - FreeSpace, cRemaining - 1 );
        SetAllocatedSize( pul, UsedSize(*pul) );
    }
    RtlMoveMemory( pul + cul, pul, (UsedSize(*pul) + 1) * 4 );
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::LeftCompress, public
//
//  Synopsis:   Moves data from [pul], [cul] dwords down.
//
//  Arguments:  [pul]    -- Start of area to move.
//              [cul]    -- Count of dwords to move
//              [pulEnd] -- Terminating property.  This property will have
//                          it's allocated size increased with all the slack
//                          from previous properties and have its used size
//                          set to 0.
//
//  Returns:    New pointer to pulEnd (which moved down by [cul] bytes).
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG * COnDiskPropertyRecord::LeftCompress( ULONG * pul, ULONG cul, ULONG * pulEnd )
{
    //
    // Terminating recursion? Just copy the allocated info.  Used size is
    // zero, because data isn't copied.
    //

    if ( pul == pulEnd )
    {
        pul -= cul;

        SetAllocatedSize( pul, AllocatedSize(*pulEnd) + cul );
        SetUsedSize( pul, 0 );

        return pul;
    }

    //
    // First, move current record.
    //

    if ( cul > 0 )
    {
        RtlMoveMemory( pul - cul, pul, (UsedSize(*pul) + 1) * 4 );
        pul -= cul;
    }

    //
    // Adjust allocation size.
    //

    cul += ( AllocatedSize(*pul) - UsedSize(*pul) );
    SetAllocatedSize( pul, UsedSize(*pul) );

    return LeftCompress( pul + cul + UsedSize(*pul) + 1, cul, pulEnd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propci\proprec_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "proprec.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propdump\clogdump.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       clogdump.cxx
//
//  Contents:   Changelog dump utility
//
//  History:    04 Mar 1998     AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <changlog.hxx>


DECLARE_INFOLEVEL(ci)

unsigned fVerbose = 0;

int ChangeLogDump( char * pszPath );

int __cdecl main( int argc, char * argv[] )
{
    char *   pszFile = argv[1];
    unsigned cFail = 0;

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'v':
            case 'V':
                fVerbose = 1;
                break;

#if 0
            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField < cMaxFields )
                    aiField[cField++] = strtol( argv[i], 0, 10 );
                break;
#endif // 0

            default:
                fprintf(stderr, "Usage: file ...\n");
                exit(2);
            }
            continue;
        }
        else
        {
            pszFile = argv[i];

            cFail += ChangeLogDump(pszFile);
        }
    }

    return cFail != 0;
}


int ChangeLogDump( char * pszPath )
{
    HANDLE h = CreateFileA( pszPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszPath, GetLastError() );
        return 1;
    }

    printf( "fileaddr  rec\t\tUSN\tWorkID\tVolID\tAction\tRetries\n" );

    ULONG cbRead;
    struct ChangeRecord {
        CDocNotification aRecord[cDocInChunk];
        ULONG ulChecksum;
    } ChangeRecord;


    for ( unsigned i = 0; ; i++ )
    {
        if ( ! ReadFile( h, &ChangeRecord, sizeof ChangeRecord, &cbRead, 0 ) )
        {
            fprintf(stderr, "Error %d reading %s\n", GetLastError(), pszPath );
            CloseHandle( h );
            return 1;
        }

        if (cbRead == 0)
            break;

        for ( unsigned j = 0; j < cDocInChunk; j++ )
        {
            CDocNotification * pRecord = &ChangeRecord.aRecord[j];

            if (0 == pRecord->Wid())
                continue;

            printf("%08x  %d.\t",
                   i*sizeof ChangeRecord + j*sizeof (CDocNotification),
                   i*cDocInChunk + j );

            if ( widInvalid == pRecord->Wid() )
            {
                printf( "<unused>\n" );
                continue;
            }

            char szUSN[40];
            _i64toa( pRecord->Usn(), szUSN, 10 );
            printf("%11s\t%6d\t%5d\t%5d\t%5d\n",
                   szUSN, pRecord->Wid(),
                   pRecord->VolumeId(), pRecord->Action(), pRecord->Retries() );
        }
    }
    CloseHandle( h );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propci\mmfile.cxx ===
//
// Class for reading memory mapped files with a standard
// stream interface like the fX C runtime.  In NT 404
// this class is at least 50% faster than the fopen routines.
//

#include <pch.cxx>
#pragma hdrstop

#include "mmfile.hxx"

#define _CR 13
#define _LF 10

CMMFile::CMMFile(WCHAR const *szFile,BOOL fWrite)
{
  ULONG ulSizeHigh;
  DWORD dwAccess,dwProtect,dwFileAccess,dwCreate;

  _hfFile = 0;
  _hMapping = 0;
  _pvView = 0;
  _fWrite = fWrite;
  _ulFileSize = 0;
  _ulChunk = MMF_CHUNK;

  if (fWrite)
    {
      dwFileAccess = GENERIC_READ | GENERIC_WRITE;
      dwCreate = OPEN_ALWAYS;
      dwProtect = PAGE_READWRITE;
      dwAccess = FILE_MAP_ALL_ACCESS;
    }
  else
    {
      dwFileAccess = GENERIC_READ;
      dwCreate = OPEN_EXISTING;
      dwProtect = PAGE_READONLY;
      dwAccess = FILE_MAP_READ;
    }

  if (INVALID_HANDLE_VALUE !=
      (_hfFile = CreateFile(szFile,dwFileAccess,FILE_SHARE_READ,0,dwCreate,FILE_ATTRIBUTE_NORMAL,0)))
    {
      if (_ulFileSize = GetFileSize(_hfFile,&ulSizeHigh))
        {
          if (_hMapping = CreateFileMapping((HANDLE) _hfFile,NULL,dwProtect,0,0,NULL))
            _pvView = (BYTE *) MapViewOfFile(_hMapping,dwAccess,0,0,0);
          if (!(_hMapping && _pvView))
            {
              if (_pvView)
                UnmapViewOfFile(_pvView);
              _pvView = 0;
              if (_hMapping)
                CloseHandle(_hMapping);
              _hMapping = 0;
              if (_hfFile)
                CloseHandle(_hfFile);
              _hfFile = 0;
            }
        }
    }

   if ( INVALID_HANDLE_VALUE == _hfFile )
       _hfFile = 0;

  _pcCurrent = (char *) _pvView;
} //CMMFile

CMMFile::~CMMFile(void)
{
  if (_pvView)
    UnmapViewOfFile(_pvView);
  if (_hMapping)
    CloseHandle(_hMapping);
  if (_hfFile)
    CloseHandle(_hfFile);
  _hfFile = 0;
} //~CMMFile

//
// clone c runtime fgets()
//
BOOL CMMFile::GetS(char *sz,int iMaxLen)
{
  BOOL fRet;
  int i,ic;

  if (iMaxLen)
    {
      *sz = 0;
      iMaxLen--;
    }

  if (isEOF())
    fRet = FALSE;
  else
    {
      fRet = TRUE;
      for (i=0; (i < iMaxLen) &&
                ((sz[i] = (char) GetChar()) != MMF_EOF) &&
                (sz[i] != _CR) &&
                (sz[i] != _LF);
           i++)
        ;

      if (sz[i] == MMF_EOF)
        sz[i] = 0;
      else
        {
          if ((ic = GetChar()) != _LF)
            UnGetChar(ic);
          if (sz[i] == _CR)
            sz[i] = _LF;
          sz[i+1] = 0;
        }
    }
  return(fRet);
} //GetS

ULONG CMMFile::Grow(ULONG ulNewSize)
{
  ULONG ulOffset;

  ulNewSize = _RoundUpToChunk(ulNewSize);

  if (_ulFileSize < ulNewSize)
    {
      if (_pvView)
        {
          ulOffset = (ULONG) (_pcCurrent - (char *) _pvView);
          UnmapViewOfFile(_pvView);
          _pvView = NULL;
        }
      else ulOffset = 0L;

      if (_hMapping)
        {
          CloseHandle(_hMapping);
          _hMapping = 0;
        }
      _ulFileSize = ulNewSize;
      if (_hMapping = CreateFileMapping(_hfFile,NULL,PAGE_READWRITE,0,_ulFileSize,NULL))
        _pvView = MapViewOfFile(_hMapping,FILE_MAP_ALL_ACCESS,0,0,0);
      _pcCurrent = (char *) _pvView + ulOffset;
    }
  return(_ulFileSize);
} //Grow

int CMMFile::PutJustS(char *sz)
{
  ULONG ulLen = strlen(sz);

  Grow(Tell() + ulLen);

  memcpy(_pcCurrent,sz,ulLen);
  _pcCurrent += ulLen;

  return((int) ulLen);
} //PutS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propci\propci.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       main.cxx
//
//  Contents:   Fixes a catalog after propagating from one machine to another.
//
//  History:    12 Jan 2000    dlee   Created from propdump
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proprec.hxx>
#include <propdesc.hxx>
#include "mmfile.hxx"

DECLARE_INFOLEVEL(ci)

unsigned const SixtyFourK = 1024 * 64;

//#define LOG

CCoTaskAllocator CoTaskAllocator; // exported data definition

void * CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return CoTaskMemAlloc( cbSize );
}

void CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

void Usage()
{
    printf( "Usage: PropCi directory\n");
    printf( "       directory specifies the directory where the catalog exists.\n");
    printf( "\n" );
    printf( "This application converts file indexes in the catalog specified.\n" );
    exit( 1 );
}

WCHAR const * wcsistr( WCHAR const * wcsString, WCHAR const * wcsPattern )
{
    if ( (wcsPattern == 0) || (*wcsPattern == 0) )
        return wcsString;

    ULONG cwcPattern = wcslen(wcsPattern);

    while ( *wcsString != 0 )
    {
        while ( (*wcsString != 0) &&
                (towupper(*wcsString) != towupper(*wcsPattern)) )
            wcsString++;

        if ( 0 == *wcsString )
            return 0;

        if ( _wcsnicmp( wcsString, wcsPattern, cwcPattern) == 0 )
            return wcsString;

        wcsString++;
    }

    return 0;
} //wcsistr

void AppendBackslash( WCHAR *p )
{
    int x = wcslen( p );
    if ( 0 != x && L'\\' != p[x-1] )
    {
        p[x] = L'\\';
        p[x+1] = 0;
    }
} //AppendBackslash


void FindFieldRec(
    WCHAR const * pwcFile,
    PROPID        pid,
    CPropDesc &   prop,
    ULONG &       cTotal,
    ULONG &       cFixed,
    ULONG &       culFixed )
{
    cTotal = 0;
    cFixed = 0;
    culFixed = 0;

    HANDLE h = CreateFile( pwcFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %ws. Error %u\n", pwcFile, GetLastError() );
        exit( 1 );
    }

    ULONG cbRead;
    static BYTE abTemp[SixtyFourK];
    if ( ReadFile( h,
                   abTemp,
                   sizeof abTemp ,
                   &cbRead,
                   0 ) )
    {
        // Loop through records

        BOOL fFound = FALSE;
        CPropDesc * pPropDesc = (CPropDesc *)abTemp;

        for ( unsigned i = 0;
              i < cbRead/(sizeof(CPropDesc) + sizeof(ULONG));
              i++, pPropDesc = (CPropDesc *)(((BYTE *)pPropDesc) + sizeof(CPropDesc) + sizeof(ULONG)) )
        {
            if ( 0 != pPropDesc->Pid() )
            {
                if ( pPropDesc->Pid() == pid )
                {
                    memcpy( &prop, pPropDesc, sizeof prop );
                    fFound = TRUE;
                }

                cTotal++;

                if ( pPropDesc->Offset() != -1 )
                {
                    cFixed++;
                    culFixed += (pPropDesc->Size() / sizeof(DWORD));
                }
            }
        }

        if ( !fFound )
        {
            printf( "can't find pid %#x\n", pid );
            exit( 1 );
        }
    }
    else
    {
        printf( "Can't read file %ws.  Error %u\n", pwcFile, GetLastError() );
        exit( 1 );
    }

#ifdef LOG
    printf( "pid %d, total %d, fixed %d\n", pid, cTotal, cFixed );

    printf( "  pid %d, vt %d, ostart %d, cbmax %d, ordinal %d, mask %d, rec %d, fmodify %d\n",
               prop.Pid(),
               prop.Type(),
               prop.Offset(),
               prop.Size(),
               prop.Ordinal(),
               prop.Mask(),
               prop.Record(),
               prop.Modifiable() );
#endif

    CloseHandle( h );
} //FindFieldRec

NTSTATUS CiNtOpenNoThrow(
    HANDLE & h,
    WCHAR const * pwcsPath,
    ACCESS_MASK DesiredAccess,
    ULONG ShareAccess,
    ULONG OpenOptions )
{
    h = INVALID_HANDLE_VALUE;
    UNICODE_STRING uScope;

    if ( !RtlDosPathNameToNtPathName_U( pwcsPath,
                                       &uScope,
                                        0,
                                        0 ) )
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Open the file
    //

    OBJECT_ATTRIBUTES ObjectAttr;

    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = NtOpenFile( &h,                 // Handle
                                  DesiredAccess,      // Access
                                  &ObjectAttr,        // Object Attributes
                                  &IoStatus,          // I/O Status block
                                  ShareAccess,        // Shared access
                                  OpenOptions );      // Flags

    RtlFreeHeap( RtlProcessHeap(), 0, uScope.Buffer );

    return Status;
} //CiNtOpenNoThrow

FILEID GetFileId( WCHAR * pwcPath )
{
    if ( 2 == wcslen( pwcPath ) )
        wcscat( pwcPath, L"\\" );

    HANDLE h;
    NTSTATUS status = CiNtOpenNoThrow( h,
                                       pwcPath,
                                       FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                       0 );

    if ( FAILED( status ) )
    {
        printf( "Can't open file %ws to get fileid. Error %#x\n", pwcPath, status );
        return 0;
    }

    FILE_INTERNAL_INFORMATION fii;
    IO_STATUS_BLOCK IoStatus;
    status = NtQueryInformationFile( h,
                                     &IoStatus,
                                     &fii,
                                     sizeof fii,
                                     FileInternalInformation );

    NtClose( h );

    if ( NT_SUCCESS( status ) )
        status = IoStatus.Status;

    if ( NT_SUCCESS( status ) )
        return fii.IndexNumber.QuadPart;

    return 0;
} //GetFileId

void GetRecordInformation(
    WCHAR const * pwcFile,
    ULONG &       cRecPerBuf,
    ULONG &       cbRec )
{
    cRecPerBuf = 0;
    cbRec = 0;

    HANDLE h = CreateFile( pwcFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           0,
                           OPEN_EXISTING,
                           0,
                           0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %ws. Error %u\n", pwcFile, GetLastError() );
        exit( 1 );
    }

    ULONG cbRead;

    static BYTE abTemp[SixtyFourK];
    if ( ReadFile( h,
                   abTemp,
                   sizeof(abTemp),
                   &cbRead,
                   0 ) )
    {
        //
        // Determine record size
        //

        if ( abTemp[0] != 0 || abTemp[1] != 0 )
        {
            printf( "Record 0 not blank.  File corrupt!\n" );
            exit( 1 );
        }

        // First record should be all empty and only the first
        // record should be so. So counting all leading zeros gives us
        // the size of the record.
        for ( unsigned i = 0; i < cbRead && abTemp[i] == 0; i++ )
            continue;

        if ( i == cbRead )
        {
            printf( "First %uK segment all zero!.  File corrupt!\n", sizeof(abTemp)/1024 );
            exit( 1 );
        }

        switch ( *(USHORT *)&abTemp[i] )
        {
            case 0x5555:
            case 0xAAAA:
            case 0xBBBB:
            case 0xCCCC:
            case 0xDDDD:
                cbRec = i;
    
                if ( cbRec % 4 != 0 )
                {
                    printf( "Record size (%u bytes) not DWORD aligned!\n\n", cbRec );
                    exit( 1 );
                }
    
                cRecPerBuf = sizeof(abTemp) / cbRec;
                break;
    
            default:
                printf( "First non-zero byte is not a proper signature (%u)!\n", *(SHORT *)&abTemp[i] );
                exit( 1 );
        }
    }
    else
    {
        printf( "can't read from file %ws, error %d\n", pwcFile, GetLastError() );
        exit( 1 );
    }

#ifdef LOG
    printf( "cRecPerBuf %d, cbRec %d\n", cRecPerBuf, cbRec );
#endif

    CloseHandle( h );
} //GetRecordInformation

void PatchFileIDs(
    WCHAR const * pwcDir,
    WCHAR const * pwcPri,
    WCHAR const * pwcSec )
{
    //
    // First, read the property specifications for secondary wid, fileindex,
    // lastseen, and path.  The first 3 are in the primary and the last in
    // the secondary.
    //

    WCHAR awcPriProp[ MAX_PATH ];
    wcscpy( awcPriProp, pwcDir );
    wcscat( awcPriProp, L"CIP10000.001" );

    ULONG cPriTotal, cPriFixed, culPriFixed;
    CPropDesc SecWidPtrFieldRec;

    FindFieldRec( awcPriProp,
                  pidSecondaryStorage,
                  SecWidPtrFieldRec,
                  cPriTotal,
                  cPriFixed,
                  culPriFixed );

    CPropDesc FileIdFieldRec;
    FindFieldRec( awcPriProp,
                  pidFileIndex,
                  FileIdFieldRec,
                  cPriTotal,
                  cPriFixed,
                  culPriFixed );

    CPropDesc LastSeenFieldRec;
    FindFieldRec( awcPriProp,
                  pidLastSeenTime,
                  LastSeenFieldRec,
                  cPriTotal,
                  cPriFixed,
                  culPriFixed );

    WCHAR awcSecProp[ MAX_PATH ];
    wcscpy( awcSecProp, pwcDir );
    wcscat( awcSecProp, L"CIP20000.001" );

    ULONG cSecTotal, cSecFixed, culSecFixed;
    CPropDesc PathFieldRec;

    FindFieldRec( awcSecProp,
                  pidPath,
                  PathFieldRec,
                  cSecTotal,
                  cSecFixed,
                  culSecFixed );

    //
    // Get information about the number and size of records.
    //

    ULONG cPriRecPerBuf, cbPriRec;
    GetRecordInformation( pwcPri, cPriRecPerBuf, cbPriRec );

    ULONG cSecRecPerBuf, cbSecRec;
    GetRecordInformation( pwcSec, cSecRecPerBuf, cbSecRec );

    //
    // Walk the property store, get the secondary wid, read the path from
    // the secondary store, lookup the fileid, and write the fileid back
    // info the primary store.
    //

    CMMFile pri( pwcPri, TRUE );
    if ( !pri.Ok() )
    {
        printf( "can't map primary\n" );
        exit( 1 );
    }

    BYTE * pb = (BYTE *) pri.GetMapping();
    BYTE * pbBase = pb;

    CMMFile sec( pwcSec, TRUE );
    if ( !sec.Ok() )
    {
        printf( "can't map secondary\n" );
        exit( 1 );
    }

    BYTE * pbSecBase = (BYTE *) sec.GetMapping();

    FILETIME ftNow;
    GetSystemTimeAsFileTime( &ftNow );

#ifdef LOG
    printf( "pb %#x, size %d\n", pb, pri.FileSize() );
#endif

    ULONG iRec = 0, iRecTotal = 0;

    do
    {
#ifdef LOG
        printf( "record %d\n", iRecTotal );
#endif
        // If we're at the end of a 64k page, go on to the next one.

        if ( iRec == cPriRecPerBuf )
        {
            iRec = 0;
            pb += 65536;
        }

        COnDiskPropertyRecord * pRec = new( iRec, pb, cbPriRec/4 ) COnDiskPropertyRecord;

        if ( (BYTE *) pRec >= ( pbBase + pri.FileSize() ) )
            break;

        if ( pRec->IsTopLevel() )
        {
            PROPVARIANT var;
            static BYTE abExtra[MAX_PATH * 5];
            unsigned cbExtra = sizeof(abExtra);

            pRec->ReadFixed( SecWidPtrFieldRec.Ordinal(),
                             SecWidPtrFieldRec.Mask(),
                             SecWidPtrFieldRec.Offset(),
                             cPriTotal,
                             SecWidPtrFieldRec.Type(),
                             var,
                             abExtra,
                             &cbExtra,
                             *((PStorage *)0) );

            if ( VT_UI4 != var.vt )
            {
                printf( "failure: secondary wid wasn't a UI4\n" );
                exit( 1 );
            }

#ifdef LOG
            printf( "secondary wid %d\n", var.ulVal );
#endif

            ULONG iTargetSection = var.ulVal/cSecRecPerBuf;

            BYTE * pbSec = pbSecBase + ( iTargetSection * SixtyFourK );

            // Get the secondary store record

            COnDiskPropertyRecord * pRec2 = new( var.ulVal % cSecRecPerBuf, pbSec, cbSecRec/4 ) COnDiskPropertyRecord;

            // Read the path
            cbExtra = sizeof abExtra;

#ifdef LOG
            printf( "pRec2: %#x\n", pRec2 );
#endif

            var.vt = VT_EMPTY;

            if ( !pRec2->ReadVariable( PathFieldRec.Ordinal(),
                                       PathFieldRec.Mask(),
                                       culSecFixed,
                                       cSecTotal,
                                       cSecFixed,
                                       var,
                                       abExtra,
                                       &cbExtra ) )
            {
                // It's in an overflow record

                BOOL fOk;

                do
                {
                    //
                    // Check for existing overflow block.
                    //
    
                    WORKID widOverflow = pRec2->OverflowBlock();
    
                    if ( 0 == widOverflow )
                        break;

                    iTargetSection = widOverflow / cSecRecPerBuf;
                    pbSec = pbSecBase + ( iTargetSection * SixtyFourK );
                    pRec2 = new( widOverflow % cSecRecPerBuf, pbSec, cbSecRec/4 ) COnDiskPropertyRecord;

#ifdef LOG
                    printf( "overflow pRec2: %#x\n", pRec2 );
#endif
                    ULONG Ordinal = PathFieldRec.Ordinal() - cSecFixed;
                    DWORD Mask = (1 << ((Ordinal % 16) * 2) );
    
                    fOk = pRec2->ReadVariable( Ordinal,  // Ordinal (assuming 0 fixed)
                                               Mask,     // Mask (assuming 0 fixed)
                                               0,        // Fixed properties
                                               cSecTotal - cSecFixed,
                                               0,        // Count of fixed properties
                                               var,
                                               abExtra,
                                               &cbExtra );
                } while ( !fOk );
            }

            if ( VT_LPWSTR == var.vt )
            {
                // Get and set the fileindex for this volume

                FILEID fid = GetFileId( var.pwszVal );

                PROPVARIANT varId;
                varId.vt = VT_UI8;
                varId.hVal.QuadPart = fid;

                pRec->WriteFixed( FileIdFieldRec.Ordinal(),
                                  FileIdFieldRec.Mask(),
                                  FileIdFieldRec.Offset(),
                                  FileIdFieldRec.Type(),
                                  cPriTotal,
                                  varId );

                // Set the last seen time so we don't reindex the file

                PROPVARIANT varLS;
                varLS.vt = VT_FILETIME;
                varLS.filetime = ftNow;

                pRec->WriteFixed( LastSeenFieldRec.Ordinal(),
                                  LastSeenFieldRec.Mask(),
                                  LastSeenFieldRec.Offset(),
                                  LastSeenFieldRec.Type(),
                                  cPriTotal,
                                  varLS );

#ifdef LOG
                printf( "fileid %#I64x, %ws\n", fid, var.pwszVal );
#endif
            }
        }

        if ( pRec->IsValidType() )
        {
            iRec += pRec->CountRecords();
            iRecTotal += pRec->CountRecords();
        }
        else
        {
            iRec++;
            iRecTotal++;
        }
    } while ( TRUE );

    pri.Flush();
} //PatchFileIDs

void GetNtVolumeInformation(
    ULONG       ulVolumeId,
    ULONGLONG & ullVolumeCreationTime,
    ULONG &     ulVolumeSerialNumber,
    ULONGLONG & ullJournalId )
{
    ullVolumeCreationTime = 0;
    ulVolumeSerialNumber = 0;
    ullJournalId = 0;

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = (WCHAR) ulVolumeId;

    FILE_FS_VOLUME_INFORMATION VolumeInfo;
    VolumeInfo.VolumeCreationTime.QuadPart = 0;
    VolumeInfo.VolumeSerialNumber = 0;

    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 0,
                                 OPEN_EXISTING,
                                 0,
                                 0 );

    if ( INVALID_HANDLE_VALUE == hVolume )
    {
        printf( "failure: can't open volume %ws\n", wszVolumePath );
        exit( 1 );
    }

    IO_STATUS_BLOCK iosb;
    RtlZeroMemory( &VolumeInfo, sizeof VolumeInfo );
    NtQueryVolumeInformationFile( hVolume,
                                  &iosb,
                                  &VolumeInfo,
                                  sizeof(VolumeInfo),
                                  FileFsVolumeInformation );

    //
    // This call will only succeed on NTFS NT5 w/ USN Journal enabled.
    //

    USN_JOURNAL_DATA UsnJournalInfo;
    RtlZeroMemory( &UsnJournalInfo, sizeof UsnJournalInfo );
    NTSTATUS Status = NtFsControlFile( hVolume,
                                       0,
                                       0,
                                       0,
                                       &iosb,
                                       FSCTL_QUERY_USN_JOURNAL,
                                       0,
                                       0,
                                       &UsnJournalInfo,
                                       sizeof UsnJournalInfo );

    if ( NT_SUCCESS(Status) && NT_SUCCESS( iosb.Status ) )
    {
        // cool, it's a usn volume
    } 
    else if ( ( STATUS_JOURNAL_NOT_ACTIVE == Status ||
                STATUS_INVALID_DEVICE_STATE == Status ) )
    {
        //
        // Usn journal not created, create it
        //

        CREATE_USN_JOURNAL_DATA usnCreateData;
        usnCreateData.MaximumSize = 0x800000; // 8 meg
        usnCreateData.AllocationDelta = 0x100000; // 1 meg

        Status = NtFsControlFile( hVolume,
                                  0,
                                  0,
                                  0,
                                  &iosb,
                                  FSCTL_CREATE_USN_JOURNAL,
                                  &usnCreateData,
                                  sizeof usnCreateData,
                                  0,
                                  0 );
        if ( NT_SUCCESS( Status ) && NT_SUCCESS( iosb.Status ) )
        {
            Status = NtFsControlFile( hVolume,
                                      0,
                                      0,
                                      0,
                                      &iosb,
                                      FSCTL_QUERY_USN_JOURNAL,
                                      0,
                                      0,
                                      &UsnJournalInfo,
                                      sizeof UsnJournalInfo );

            if (! ( NT_SUCCESS(Status) && NT_SUCCESS( iosb.Status ) ) )
            {
                printf( "can't query usn vol info after creating it %#x\n", Status );
                exit( 1 );
            }
        }
        else
        {
            printf( "can't create usn journal %#x\n", Status );
            exit( 1 );
        }
    }
    else
    {
        printf( "can't get USN information, probably FAT: %#x\n", Status );
    }

    ullVolumeCreationTime = VolumeInfo.VolumeCreationTime.QuadPart;
    ulVolumeSerialNumber = VolumeInfo.VolumeSerialNumber;
    ullJournalId = UsnJournalInfo.UsnJournalID;

    printf( "      new volumecreationtime: %#I64x\n", ullVolumeCreationTime );
    printf( "      new volumeserialnumber: %#x\n", ulVolumeSerialNumber );
    printf( "      new journalid: %#I64x\n", ullJournalId );

    CloseHandle( hVolume );
} //GetNtVolumeInformation

void PatchScopeTable( WCHAR const * pwcDir )
{
    // Find out how many scopes are in the scope table

    ULONG cScopes = 0;

    {
        WCHAR awcControl[ MAX_PATH ];
        wcscpy( awcControl, pwcDir );
        wcscat( awcControl, L"cisp0000.000" );

        CMMFile Control( awcControl, FALSE );

        if ( 0 == Control.GetMapping() )
        {
            printf( "can't open file %ws\n", awcControl );
            exit( 1 );
        }
 
        cScopes = ((ULONG *) Control.GetMapping())[4];
    }

    WCHAR awcOne[ MAX_PATH ];
    wcscpy( awcOne, pwcDir );
    wcscat( awcOne, L"cisp0000.001" );
    
    // Loop through the scopes and patch 

    {
        printf( "  scope table: %ws has %d scopes\n", awcOne, cScopes );

        CMMFile One( awcOne, TRUE );
        if ( !One.Ok() )
        {
            printf( "can't map scope table\n" );
            exit( 1 );
        }
    
        BYTE * pb = (BYTE *) One.GetMapping();
    
        for ( ULONG i = 0; i < cScopes; i++ )
        {
            const LONGLONG eSigCiScopeTable = 0x5158515851585158i64;
            LONGLONG signature;
            memcpy( &signature, pb, sizeof signature );
            pb += sizeof signature;

            if ( 0 == signature )
                break;

            printf( "  scope record: \n" );

            if ( eSigCiScopeTable != signature )
            {
                printf( "invalid scope signature: %#I64x\n", signature );
                exit( 1 );
            }

            VOLUMEID volumeId;
            memcpy( &volumeId, pb, sizeof volumeId );
            printf( "    volumeId: %x\n", volumeId );
            pb += sizeof volumeId;

            ULONGLONG  ullNewVolumeCreationTime;
            ULONG      ulNewVolumeSerialNumber;
            ULONGLONG  ullNewJournalId;

            GetNtVolumeInformation( volumeId,
                                    ullNewVolumeCreationTime,
                                    ulNewVolumeSerialNumber,
                                    ullNewJournalId );

            ULONGLONG ullVolumeCreationTime;
            memcpy( &ullVolumeCreationTime, pb, sizeof ullVolumeCreationTime );
            printf( "    creation time: %#I64x\n", ullVolumeCreationTime );
            memcpy( pb,
                    &ullNewVolumeCreationTime,
                    sizeof ullNewVolumeCreationTime );
            pb += sizeof ullVolumeCreationTime;

            ULONG ulVolumeSerialNumber;
            memcpy( &ulVolumeSerialNumber, pb, sizeof ulVolumeSerialNumber );
            printf( "    serial number: %x\n", ulVolumeSerialNumber );
            memcpy( pb,
                    &ulNewVolumeSerialNumber,
                    sizeof ulNewVolumeSerialNumber );
            pb += sizeof ulVolumeSerialNumber;
    
            if ( CI_VOLID_USN_NOT_ENABLED == volumeId )
            {
                FILETIME ft;
                memcpy( &ft, pb, sizeof ft );
                printf( "    filetime: %#I64x\n", ft );
                pb += sizeof ft;
            }
            else
            {
                USN usn;
                memcpy( &usn, pb, sizeof usn );
                printf( "    usn: %#I64x\n", usn );
                USN usnNewMax = 0;
                memcpy( pb,
                        &usnNewMax,
                        sizeof usnNewMax );
                pb += sizeof usn;
    
                ULONGLONG JournalId;
                memcpy( &JournalId, pb, sizeof JournalId );
                printf( "    JournalId: %#I64x\n", JournalId );
                memcpy( pb,
                        &ullNewJournalId,
                        sizeof ullNewJournalId );
                pb += sizeof JournalId;
            }
    
            ULONG cwcPath;
            memcpy( &cwcPath, pb, sizeof cwcPath );
            pb += sizeof cwcPath;
    
            WCHAR awcPath[ MAX_PATH ];
            memcpy( awcPath, pb, cwcPath * sizeof WCHAR );
            printf( "    path: %ws\n", awcPath );
            pb += ( cwcPath * sizeof WCHAR );
        }

        One.Flush();
    }

    WCHAR awcTwo[ MAX_PATH ];
    wcscpy( awcTwo, pwcDir );
    wcscat( awcTwo, L"cisp0000.002" );

    BOOL f = CopyFile( awcOne, awcTwo, FALSE );

    if ( !f )
    {
        printf( "can't copy scope list, error %d\n", GetLastError() );
        exit( 1 );
    }
} //PatchScopeDir

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    if ( 2 != argc )
        Usage();

    //
    // The lone argument is the catalog directory, with or without catalog.wci
    //

    WCHAR awcDir[ MAX_PATH ];
    wcscpy( awcDir, argv[1] );

    AppendBackslash( awcDir );

    if ( 0 == wcsistr( awcDir, L"catalog.wci" ) )
        wcscat( awcDir, L"catalog.wci\\" );

    // Find and validate the primary and secondary stores exist

    WCHAR awcPri[MAX_PATH];
    wcscpy( awcPri, awcDir );
    wcscat( awcPri, L"*.ps1" );

    WIN32_FIND_DATA findData;
    HANDLE h = FindFirstFile( awcPri, &findData );
    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "can't find primary *.ps1 store\n" );
        exit( 1 );
    }
    FindClose( h );
    wcscpy( awcPri, awcDir );
    wcscat( awcPri, findData.cFileName );

    WCHAR awcSec[MAX_PATH];
    wcscpy( awcSec, awcDir );
    wcscat( awcSec, L"*.ps2" );

    h = FindFirstFile( awcSec, &findData );
    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "can't find secondary *.ps2 store\n" );
        exit( 1 );
    }
    FindClose( h );
    wcscpy( awcSec, awcDir );
    wcscat( awcSec, findData.cFileName );

    //
    // Do the core work here -- patch the file IDs in the primary store.
    // Also whack the last seen times so the files aren't refiltered in
    // case they were copied to the target machine after the catalog was
    // snapped.
    //

    printf( "patching file IDs\n" );
    PatchFileIDs( awcDir, awcPri, awcSec );

    //
    // Patch the scope table so cisvc doesn't think it's a different volume.
    //

    printf( "patching the scope table\n" );
    PatchScopeTable( awcDir );

    //
    // Delete the old fileid hash table since the fileids are wrong.
    // It'll get recreated automatically when the catalog is opened.
    //

    printf( "deleting the fileid hash map\n" );
    WCHAR awcHashMap[ MAX_PATH ];
    wcscpy( awcHashMap, awcDir );
    wcscat( awcHashMap, L"cicat.fid" );

    DeleteFile( awcHashMap );

    printf( "catalog successfully converted\n" );

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propdump\proprec_stub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include "proprec.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propdump\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       propdump.cxx
//
//  Contents:   Property file dump utility
//
//  History:    29 Oct 1996     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proprec.hxx>
#include <propdesc.hxx>


DECLARE_INFOLEVEL(ci)

unsigned const SixtyFourK = 1024 * 64;
unsigned const cMaxFields = 10;

unsigned fVerbose = 0;

enum eRecType
{
    Virgin,
    Top,
    Overflow,
    Free
};

struct SmallInfo
{
    ULONG Type;
    ULONG Length;
    ULONG ulPrev;
    ULONG ulNext;
    ULONG ulChainLength;
};

void Usage()
{
    printf("Usage: PropDump [-?] [-v] [-m] [-f primary_field] [-s secondary_field] <primary file> [<secondary file>]\n");
    printf("       -? to dump this usage information.\n");
    printf("       -v to be verbose.\n");
    printf("       -m[o] to dump the metadata (o --> only. No integrity check).\n");
    printf("       -f field is used to dump a specific field in the primary store records.\n");
    printf("       -s field is used to dump a specific field in the secondary store records.\n");
    printf("       -c secWidPtrField is used to check for consistency between pri and sec stores. Param is usually 3.\n");
    printf("       -w[ps] <workid> dump only <workid> in primary/secondary store\n");
    printf("       <primary file> is the name of the primary file.\n");
    printf("       <secondary file> is the name of secondary file.\n");
    printf("       Specify primary and secondary for the two-level prop store.\n");
    printf("       If secondary is not specified, the primary will be construed as the name of the single store.\n");
}

char *   pszPrimFile = 0;
char *   pszSecFile = 0;
BOOL     fReadMetadata = 0;
BOOL     fMetadataOnly = 0;

unsigned cField1 = 0;
unsigned cField2 = 0;
int      aiField1[cMaxFields];
int      aiField2[cMaxFields];
BOOL     fTwoLevel = FALSE;
ULONG    cPriRecPerBuf, cbPriRec, cPriTotal, cPriFixed;
ULONG    cSecRecPerBuf, cbSecRec, cSecTotal, cSecFixed;
ULONG    cMaxWidsInSecStore;
int      cWidPtrField = 0;
ULONG    widPrimary = 0xFFFFFFFF;
ULONG    widSecondary = 0xFFFFFFFF;

const DWORD PrimaryStore = 0;
const DWORD SecondaryStore = 1;

void DumpStore(char *pszFile, unsigned cField, int *aiField, DWORD dwLevel, ULONG wid);
void CheckConsistencyBetweenStores(char * pszPrimFile, char *pszSecFile);

CPropDesc aFieldRec[cMaxFields];
CPropDesc SecWidPtrFieldRec;

int __cdecl main( int argc, char * argv[] )
{
    if (argc < 2)
    {
        Usage();
        return 0;
    }

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {

            case '?':
                Usage();
                return 0;

            case 'v':
            case 'V':
                fVerbose = 1;
                break;

            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                if ( argv[i][2] == 'o' || argv[i][2] == 'O' )
                    fMetadataOnly = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField1 < cMaxFields )
                    aiField1[cField1++] = strtol( argv[i], 0, 10 );
                break;


            case 's':
            case 'S':
                i++;

                if ( cField2 < cMaxFields )
                    aiField2[cField2++] = strtol( argv[i], 0, 10 );
                break;

            case 'c':
            case 'C':
                i++;
                cWidPtrField = strtol(argv[i], 0, 10);
                // this works only if fReadMetadata is turned on
                fReadMetadata = TRUE;
                break;

            case 'w':
            case 'W':
                switch ( argv[i][2] )
                {
                case 'p':
                case 'P':
                case '\0':
                    i++;
                    widPrimary = strtol(argv[i], 0, 10);
                    break;

                case 's':
                case 'S':
                    i++;
                    widSecondary = strtol(argv[i], 0, 10);
                    break;
                }
            }
        }
        else
        {
            if (!pszPrimFile)
                pszPrimFile = argv[i];
            else
            {
                pszSecFile = argv[i];
                fTwoLevel = TRUE;
            }
        }
    }

    // If we don't have a primary file or a secondary file, look for them in the current directory.
    if (!pszPrimFile)
    {
        fTwoLevel = TRUE;
        pszPrimFile = "00000002.ps1";
        pszSecFile = "00000002.ps2";
    }

    // Verify that the propstore files are indeed available!
    if (0xFFFFFFFF == GetFileAttributesA(pszPrimFile))
    {
        printf("Can't find primary file %s for reason %d\n", pszPrimFile, GetLastError());
        return 0;
    }

    if (0xFFFFFFFF == GetFileAttributesA(pszSecFile))
    {
        printf("Can't find secondary file. Assuming single level property store\n");
        fTwoLevel = FALSE;
    }
    else
        fTwoLevel = TRUE;

    cPriRecPerBuf = cbPriRec = cSecRecPerBuf = cbSecRec = 0;

    //
    // CheckConsistencyBetweenStores relies on some of the information gathered
    // by calls to DumpStore, so they should be called before consistency check.
    //

    DumpStore(pszPrimFile, cField1, aiField1, PrimaryStore, widPrimary );
    if (fTwoLevel)
    {
        DumpStore(pszSecFile, cField2, aiField2, SecondaryStore, widSecondary);
        if (cWidPtrField > 0)
        {
            CheckConsistencyBetweenStores(pszPrimFile, pszSecFile);
        }
    }

    return 0;
}

void DumpStore(char *pszFile, unsigned cField, int *aiField, DWORD dwLevel, ULONG wid )
{
    BYTE abTemp[SixtyFourK];

    //
    // First, read out the metadata
    //

    unsigned cFixed = 0;
    unsigned cTotal = 0;
    unsigned culFixed = 0;

    if ( fReadMetadata || cField != 0 )
    {
        //
        // Build path.
        //

        char szPath[MAX_PATH];
        strcpy( szPath, pszFile );
        char * pLastSlash = strrchr( szPath, '\\' );
        if (pLastSlash)
            pLastSlash++;
        else
            pLastSlash = szPath;
        if (fTwoLevel)
        {
            if (PrimaryStore == dwLevel)
                strcpy( pLastSlash, "CIP10000.001" );
            else
                strcpy( pLastSlash, "CIP20000.001" );
        }
        else
            strcpy( pLastSlash, "CIPS0000.001" );

        HANDLE h = CreateFileA( szPath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                0,
                                OPEN_EXISTING,
                                0,
                                0 );

        if ( INVALID_HANDLE_VALUE == h )
        {
            printf( "Can't open file %s. Error %u\n", szPath, GetLastError() );
            return;
        }

        ULONG cbRead;

        if ( ReadFile( h,
                       abTemp,
                       sizeof(abTemp),
                       &cbRead,
                       0 ) )
        {
            //
            // Loop through records
            //

            CPropDesc * pPropDesc = (CPropDesc *)abTemp;

            if ( fReadMetadata )
                printf( "Record\t%-25s  Type\t\tOffset\tSize\tOrdinal\tMask\n",
                        "   Pid" );

            for ( unsigned i = 0;
                  i < cbRead/(sizeof(CPropDesc) + sizeof(ULONG));
                  i++, pPropDesc = (CPropDesc *)(((BYTE *)pPropDesc) + sizeof(CPropDesc) + sizeof(ULONG)) )
            {
                if ( pPropDesc->Pid() != 0 )
                {
                    if ( fReadMetadata )
                    {
                        char * pszPidName = 0;
                        char * pszMarker = "";
                        switch (pPropDesc->Pid())
                        {
                        case pidSecurity:
                            pszPidName = "pidSecurity"; break;
                        case pidDirectory:
                            pszPidName = "pidDirectory";        break;
                        case pidClassId:
                            pszPidName = "pidClassId";  break;
                        case pidStorageType:
                            pszPidName = "pidStorageType";      break;
                        case pidFileIndex:
                            pszPidName = "pidFileIndex";        break;
                        case pidVolumeId:
                            pszPidName = "pidVolumeId"; break;
                        case pidParentWorkId:
                            pszPidName = "pidParentWorkId";     break;
                        case pidLastChangeUsn:
                            pszPidName = "pidLastChangeUsn";    break;
                        case pidName:
                            pszPidName = "pidName";     break;
                        case pidSize:
                            pszPidName = "pidSize";     break;
                        case pidAttrib:
                            pszPidName = "pidAttrib";   break;
                        case pidWriteTime:
                            pszPidName = "pidWriteTime";        break;
                        case pidCreateTime:
                            pszPidName = "pidCreateTime";       break;
                        case pidAccessTime:
                            pszPidName = "pidAccessTime";       break;
                        case pidShortName:
                            pszPidName = "pidShortName";        break;
                        case pidWorkId:
                            pszPidName = "pidWorkId";   break;
                        case pidUnfiltered:
                            pszPidName = "pidUnfiltered";       break;
                        case pidRevName:
                            pszPidName = "pidRevName";  break;
                        case pidVirtualPath:
                            pszPidName = "pidVirtualPath";      break;
                        case pidLastSeenTime:
                            pszPidName = "pidLastSeenTime";     break;
                        case pidPath:
                            pszPidName = "pidPath";
                            pszMarker = "**";
                            break;
                        case pidSecondaryStorage:
                            pszPidName = "pidSecondaryStorage";
                            pszMarker = "*";
                            break;
                        }

                        static char achBuf[20];

                        if ( 0 == pszPidName )
                        {
                            sprintf( achBuf, "   %d(0x%x)",
                                     pPropDesc->Pid(), pPropDesc->Pid() );
                        }
                        else
                        {
                            sprintf( achBuf, "%-3s%d(%s)",
                                     pszMarker, pPropDesc->Pid(), pszPidName );
                        }
                        printf( "%u:\t%-25s  %u (0x%x)\t%d\t%u\t%u\t0x%x\n",
                                pPropDesc->Record(),
                                achBuf,
                                pPropDesc->Type(), pPropDesc->Type(),
                                pPropDesc->Offset(),
                                pPropDesc->Size(),
                                pPropDesc->Ordinal(),
                                pPropDesc->Mask() );
                    }

                    cTotal++;

                    if ( pPropDesc->Offset() != -1 )
                    {
                        cFixed++;
                        culFixed += (pPropDesc->Size() / sizeof(DWORD));
                    }

                    // copy the description of the sec top-level wid ptr for later use
                    if ( PrimaryStore == dwLevel && cWidPtrField && cWidPtrField == (int)pPropDesc->Record() )
                    {
                        memcpy( &SecWidPtrFieldRec, pPropDesc, sizeof(aFieldRec[0]) );
                    }

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        if ( aiField[j] == (int)pPropDesc->Record() )
                            memcpy( &aFieldRec[j], pPropDesc, sizeof(aFieldRec[0]) );

                        if (cWidPtrField && cWidPtrField == (int)j )
                        {
                            // verify that we are capturing the right property
                            // description for the sec top-level wid ptr
                            for (int k = 0; k < sizeof(aFieldRec[0]); k++)
                            {
                                Win4Assert(RtlEqualMemory(&aFieldRec[j], &SecWidPtrFieldRec, sizeof(SecWidPtrFieldRec)));
                            }
                        }
                    }
                }
            }

            printf( "\n%u Properties, %u Fixed totaling %u bytes  (* = Secondary link, ** = Path)\n\n",
                    cTotal, cFixed, culFixed * sizeof(DWORD) );
        }
        else
        {
            printf( "Can't read file %s.  Error %u\n", szPath, GetLastError() );
            return;
        }

        CloseHandle(h);

        if ( fMetadataOnly )
            return;
    }


    HANDLE h = CreateFileA( pszFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h &&
         ERROR_SHARING_VIOLATION == GetLastError() )
    {
        h = CreateFileA( pszFile,
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0,
                         OPEN_EXISTING,
                         0,
                         0 );
    }

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszFile, GetLastError() );
        return;
    }

    BY_HANDLE_FILE_INFORMATION fi;

    if ( !GetFileInformationByHandle( h, &fi ) )
    {
        printf( "Error %u getting size from handle\n", GetLastError() );
        return;
    }

    ULONG oFile = 0;
    ULONG cbRec = 0;
    ULONG cRecPerBuf;
    ULONG cRecTotal;
    ULONG cTotalSections = 0;

    HANDLE hSmallInfo;
    SmallInfo * aSmallInfo = 0;

    ULONG iSection = 0;

    BOOL fFirst = TRUE;

    ULONG iCurrentPct = 0;

    ULONG cTopLevel = 0;
    ULONG cOverflow = 0;
    ULONG cFree = 0;
    ULONG cVirgin = 0;

    for (;;)
    {
        ULONG cbRead;

        if ( ReadFile( h,
                       abTemp,
                       sizeof(abTemp),
                       &cbRead,
                       0 ) )
        {
            if (fVerbose)
                printf( "READ: 0x%x bytes, offset 0x%x\n", cbRead, oFile );

            if ( 0 == cbRead )
                break;

            if ( fFirst )
            {
                //
                // Determine record size
                //

                if ( abTemp[0] != 0 || abTemp[1] != 0 )
                {
                    printf( "Record 0 not blank.  File corrupt!\n" );
                    break;
                }

                // First record should be all empty and only the first
                // record should be so. So counting all leading zeros gives us
                // the size of the record.
                for ( unsigned i = 0; i < cbRead && abTemp[i] == 0; i++ )
                    continue;

                if ( i == cbRead )
                {
                    printf( "First %uK segment all zero!.  File corrupt!\n", sizeof(abTemp)/1024 );
                    break;
                }

                switch ( *(USHORT *)&abTemp[i] )
                {
                case 0x5555:
                case 0xAAAA:
                case 0xBBBB:
                case 0xCCCC:
                case 0xDDDD:
                    cbRec = i;

                    if ( cbRec % 4 != 0 )
                    {
                        printf( "Record size (%u bytes) not DWORD aligned!\n\n", cbRec );
                        return;
                    }

                    cRecPerBuf = sizeof(abTemp) / cbRec;
                    printf( "Record size: %u bytes (%u / %uK)\n", i, cRecPerBuf, sizeof(abTemp)/1024 );
                    cTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;

                    hSmallInfo = LocalAlloc( LMEM_MOVEABLE,
                                             ((fi.nFileSizeLow / sizeof(abTemp)) + 1) * cRecPerBuf * sizeof(SmallInfo) );
                    aSmallInfo = (SmallInfo *)LocalLock( hSmallInfo );

                    break;

                default:
                    printf( "First non-zero byte is not a proper signature (%u)!\n", *(SHORT *)&abTemp[i] );
                    return;
                }

                if (PrimaryStore == dwLevel)
                {
                    cPriRecPerBuf = cRecPerBuf;
                    cbPriRec = cbRec;
                    cPriTotal = cTotal;
                    cPriFixed = cFixed;
                }
                else
                {
                    cSecRecPerBuf = cRecPerBuf;
                    cbSecRec = cbRec;
                    cSecTotal = cTotal;
                    cSecFixed = cFixed;
                }

                fFirst = FALSE;
            }

            ULONG iRec = 0;

            while ( iRec < cRecPerBuf )
            {
                COnDiskPropertyRecord * pRec = new( iRec, abTemp, cbRec/4 ) COnDiskPropertyRecord;

                if ( !pRec->IsValidType() )
                {
                    printf( "Record 0x%x (%u:%u) (file offset 0x%x) is corrupt!\n",
                            iSection * cRecPerBuf + iRec,
                            iSection, iRec,
                            iSection * sizeof(abTemp) + iRec * cbRec );
                }

                if (fVerbose )
                    printf( "%u:%u, %s, length = %u record(s)",
                        iSection, iRec,
                        pRec->IsNormalTopLevel() ? "Top Level Normal" :
                            pRec->IsOverflow() ? "Overflow" :
                                pRec->IsFreeRecord() ? "Free Normal" :
                                    pRec->IsTopLevel() ? "Top Level Lean":
                                        pRec->IsLeanFreeRecord() ? "Free Lean":
                                    "Virgin",
                        pRec->CountRecords() );

                aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = 0;

                BOOL fPrint = (0xFFFFFFFF == wid || iSection*cRecPerBuf + iRec == wid);

                if ( pRec->IsOverflow() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Overflow;
                    cOverflow++;

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j && fPrint )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        if ( aFieldRec[j].IsFixedSize() )
                            continue;

                        ULONG Ordinal = aFieldRec[j].Ordinal() - cFixed;
                        DWORD Mask = (1 << ((Ordinal % 16) * 2) );

                        BOOL fOk = pRec->ReadVariable( Ordinal,
                                                       Mask,
                                                       0,
                                                       cTotal - cFixed,
                                                       0,
                                                       var,
                                                       abExtra,
                                                       &cbExtra );

                        if ( fOk && fPrint )
                        {
                            switch ( var.vt )
                            {
                            case VT_LPSTR:
                                printf( "%s ", var.pszVal );
                                break;

                            case VT_LPWSTR:
                                printf( "%ws ", var.pwszVal );
                                break;
                            }
                        }
                    }

                    if ( 0 != cField && fPrint )
                        printf( "\n" );
                }
                else if ( pRec->IsNormalTopLevel() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Top;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = pRec->GetOverflowChainLength();
                    cTopLevel++;

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j && fPrint )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        if ( aFieldRec[j].IsFixedSize() )
                        {
                            pRec->ReadFixed( aFieldRec[j].Ordinal(),
                                             aFieldRec[j].Mask(),
                                             aFieldRec[j].Offset(),
                                             cTotal,
                                             aFieldRec[j].Type(),
                                             var,
                                             abExtra,
                                             &cbExtra,
                                             *((PStorage *)0) );

                            if ( fPrint )
                            {
                                switch ( var.vt )
                                {
                                case VT_EMPTY:
                                    printf( "n/a " );
                                    break;

                                case VT_I4:
                                    printf( "%8d ", var.lVal );
                                    break;

                                case VT_UI4:
                                    printf( "%8u ", var.ulVal );
                                    break;

                                case VT_FILETIME:
                                    {
                                        SYSTEMTIME stTime;

                                        FileTimeToSystemTime( &var.filetime, &stTime );

                                        WCHAR awcBuffer[100] = L"???";

                                        GetDateFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"MM/dd/yy  ",         // format
                                                       awcBuffer,             // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) );

                                        GetTimeFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"hh:mmt",             // format
                                                       awcBuffer + 10,        // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) - 10 );

                                        awcBuffer[15] += 0x20;  // lowercase

                                        printf( "%ws ", awcBuffer );
                                    }
                                    break;

                                case VT_I8:
                                    printf( "%12hu ", var.hVal );
                                    break;

                                case VT_UI8:
                                    printf( "0x%08lx%08lx ", (ULONG) (var.uhVal.QuadPart>>32), (ULONG) var.uhVal.QuadPart );
                                    break;
                                }
                            }
                        }
                        else
                        {
                            BOOL fOk = pRec->ReadVariable( aFieldRec[j].Ordinal(),
                                                           aFieldRec[j].Mask(),
                                                           culFixed,
                                                           cTotal,
                                                           cFixed,
                                                           var,
                                                           abExtra,
                                                           &cbExtra );

                            if ( fOk && fPrint )
                            {
                                switch ( var.vt )
                                {
                                case VT_LPSTR:
                                    printf( "%s ", var.pszVal );
                                    break;

                                case VT_LPWSTR:
                                    printf( "%ws ", var.pwszVal );
                                    break;
                                }
                            }
                        }
                    }

                    if ( 0 != cField && fPrint )
                        printf( "\n" );
                }
                else if ( pRec->IsTopLevel() )
                {
                    // This is a lean top level record
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Top;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulChainLength = 0;
                    cTopLevel++;

                    for ( unsigned j = 0; j < cField; j++ )
                    {
                        PROPVARIANT var;
                        BYTE abExtra[MAX_PATH * 5];
                        unsigned cbExtra = sizeof(abExtra);

                        if ( 0 == j && fPrint )
                            printf( "%6u: ", iSection*cRecPerBuf + iRec );

                        Win4Assert(aFieldRec[j].IsFixedSize());

                        {
                            pRec->ReadFixed( aFieldRec[j].Ordinal(),
                                             aFieldRec[j].Mask(),
                                             aFieldRec[j].Offset(),
                                             cTotal,
                                             aFieldRec[j].Type(),
                                             var,
                                             abExtra,
                                             &cbExtra,
                                             *((PStorage *)0) );

                            if ( fPrint )
                            {
                                switch ( var.vt )
                                {
                                case VT_EMPTY:
                                    printf( "n/a " );
                                    break;

                                case VT_I4:
                                    printf( "%8d ", var.lVal );
                                    break;

                                case VT_UI4:
                                    printf( "%8u ", var.ulVal );
                                    break;

                                case VT_FILETIME:
                                    {
                                        SYSTEMTIME stTime;

                                        FileTimeToSystemTime( &var.filetime, &stTime );

                                        WCHAR awcBuffer[100] = L"???";

                                        GetDateFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"MM/dd/yy  ",         // format
                                                       awcBuffer,             // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) );

                                        GetTimeFormat( LOCALE_USER_DEFAULT,   // locale
                                                       0,                     // flags
                                                       &stTime,               // time
                                                       L"hh:mmt",             // format
                                                       awcBuffer + 10,        // output
                                                       sizeof(awcBuffer)/sizeof(awcBuffer[0]) - 10 );

                                        awcBuffer[15] += 0x20;  // lowercase

                                        printf( "%ws ", awcBuffer );

                                    }
                                    break;

                                case VT_I8:
                                    printf( "%12hu ", var.hVal );
                                    break;

                                case VT_UI8:
                                    printf( "0x%08lx%08lx ", (ULONG) (var.uhVal.QuadPart>>32), (ULONG) var.uhVal.QuadPart );
                                    break;
                                }
                            }
                        }
                    }

                    if ( 0 != cField && fPrint )
                        printf( "\n" );
                }
                else if ( pRec->IsFreeRecord() )
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Free;
                    cFree++;
                }
                else
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].Type = Virgin;
                    cVirgin++;
                }

                if (pRec->IsNormalTopLevel() || pRec->IsOverflow())
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = pRec->ToplevelBlock();
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = pRec->OverflowBlock();

                    if ( pRec->OverflowBlock() != 0 )
                    {
                        /* printf( ", Overflow = %u:%u (file offset 0x%x)",
                                pRec->OverflowBlock() / cRecPerBuf,
                                pRec->OverflowBlock() % cRecPerBuf,
                                (pRec->OverflowBlock() / cRecPerBuf) * sizeof(abTemp) +
                                    (pRec->OverflowBlock() % cRecPerBuf) * cbRec ); */
                    }
                }
                else if (pRec->IsTopLevel())
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = 0;
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = 0;
                }
                else if (pRec->IsFreeRecord())
                {
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulPrev = pRec->GetPreviousFreeRecord();
                    aSmallInfo[iSection*cRecPerBuf + iRec].ulNext = pRec->GetNextFreeRecord();
                }
                aSmallInfo[iSection*cRecPerBuf + iRec].Length = pRec->CountRecords();

                if ( pRec->CountRecords() == 0 )
                {
                    printf( "Record %u (file offset 0x%x) is zero length!\n",
                            iSection * cRecPerBuf + iRec,
                            iSection * sizeof(abTemp) + iRec * cbRec );
                }

                if (fVerbose)
                    printf( "\n" );

                if ( pRec->IsValidType() )
                    iRec += pRec->CountRecords();
                else
                    iRec++;

                ULONG iPct = (iSection * (100/5) / cTotalSections) * 5;
                if (iPct != iCurrentPct)
                {
                    iCurrentPct = iPct;
                    if (0 == wid)
                        printf( "Read %u%%\n", iCurrentPct );
                }

            }

            iSection++;
            oFile += cbRead;
        }
        else
        {
            ULONG Status = GetLastError();

            if ( Status == ERROR_HANDLE_EOF )
                break;
            else
            {
                printf( "Error %u reading file.\n", Status );
            }
        }
    }

    if (SecondaryStore == dwLevel)
        cMaxWidsInSecStore = iSection * cRecPerBuf;

    if (wid == 0 || wid == 0xFFFFFFFF)
    {
        printf( "Read 100%%\n" );
        printf( "%6u Top-Level records\n"
                "%6u Overflow records\n"
                "%6u Free records\n"
                "%6u Virgin records\n", cTopLevel, cOverflow, cFree, cVirgin );
    }

    CloseHandle( h );

    //
    // Now check inter-record state
    //

    unsigned iRec = 0;
    unsigned iCurrentSection = 0;
    iCurrentPct = 0;

    while ( iRec < iSection * cRecPerBuf )
    {
        if ( aSmallInfo[iRec].Type == Top )
        {
            unsigned iOverflowRec = aSmallInfo[iRec].ulNext;
            unsigned cOverflowRec = 0;

            while ( 0 != iOverflowRec )
            {
                if ( aSmallInfo[iOverflowRec].Type != Overflow )
                {
                    printf( "Record 0x%x (%u:%u) (file offset 0x%x) should be overflow and is not!\n   Top level = 0x%x (%u:%u) (file offset 0x%x)\n",
                            iOverflowRec,
                            iOverflowRec / cRecPerBuf,
                            iOverflowRec % cRecPerBuf,
                            (iOverflowRec / cRecPerBuf) * sizeof(abTemp) +
                                (iOverflowRec % cRecPerBuf) * cbRec,
                            iRec,
                            iRec / cRecPerBuf,
                            iRec % cRecPerBuf,
                            (iRec / cRecPerBuf) * sizeof(abTemp) +
                                (iRec % cRecPerBuf) * cbRec );

                    break;
                }

                iOverflowRec = aSmallInfo[iOverflowRec].ulNext;
                cOverflowRec++;
                if ( cOverflowRec > aSmallInfo[iRec].ulChainLength )
                    break;
            }

            if ( aSmallInfo[iRec].ulChainLength != cOverflowRec )
            {
                printf( "Record 0x%x (%u:%u) (file offset 0x%x) chain length mismatch %d,%d!\n",
                        iRec,
                        iRec / cRecPerBuf,
                        iRec % cRecPerBuf,
                        (iRec / cRecPerBuf) * sizeof(abTemp) +
                                (iRec % cRecPerBuf) * cbRec,
                        aSmallInfo[iRec].ulChainLength, cOverflowRec );
            }
        }

        if (aSmallInfo[iRec].Length == 0)
        {
            printf( "%u:%u (file offset 0x%x) zero length record!\n",
                    iRec / cRecPerBuf,
                    iRec % cRecPerBuf,
                    (iRec / cRecPerBuf) * sizeof(abTemp) +
                        (iRec % cRecPerBuf) * cbRec );

            iRec++;
        } else {
            iRec += aSmallInfo[iRec].Length;
        }

        if ( (iRec / cRecPerBuf) != iCurrentSection )
        {
            if (fVerbose)
                printf( "Checked section %u\n", iCurrentSection );

            ULONG iPct = (iCurrentSection * (100/5) / iSection) * 5;
            if (iPct != iCurrentPct)
            {
                iCurrentPct = iPct;
                if (wid == 0 || wid == 0xFFFFFFFF)
                    printf( "Checked %u%%\n", iCurrentPct );
            }

            iCurrentSection = (iRec / cRecPerBuf);
        }
    }

    if (wid == 0 || wid == 0xFFFFFFFF)
        printf( "Checked 100%%\n" );

    LocalUnlock( hSmallInfo );
    LocalFree( hSmallInfo );
}

void CheckConsistencyBetweenStores(char * pszPriFile, char *pszSecFile)
{
    BYTE abTemp[SixtyFourK];
    BYTE abTemp2[SixtyFourK];
    ULONG iSection2 = 0, iTargetSection = 0, oFile = 0, iSection = 0;
    ULONG cInconsistencies = 0;
    ULONG cPriTotalSections = 0;
    ULONG cSecTotalSections = 0;
    ULONG iCurrentPct = 0;

    HANDLE hPri = CreateFileA( pszPriFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == hPri )
    {
        printf( "Can't open file %s. Error %u\n", pszPriFile, GetLastError() );
        return;
    }

    HANDLE hSec = CreateFileA( pszSecFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == hSec )
    {
        printf( "Can't open file %s. Error %u\n", pszSecFile, GetLastError() );
        return;
    }

    BY_HANDLE_FILE_INFORMATION fi;

    if ( GetFileInformationByHandle( hPri, &fi ) )
    {
        cPriTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;
    }
    else
    {
        printf( "Error %u getting size from primary's handle\n", GetLastError() );
        return;
    }

    if ( GetFileInformationByHandle( hSec, &fi ) )
    {
        cSecTotalSections = (fi.nFileSizeLow + sizeof(abTemp) - 1)/ sizeof abTemp;
    }
    else
    {
        printf( "Error %u getting size from secondary's handle\n", GetLastError() );
        return;
    }

    ULONG ulSecWidPtr = widInvalid;

    // read the first large page of the secondary store into memory.
    DWORD cbRead2;
    ReadFile( hSec, abTemp2, sizeof(abTemp2), &cbRead2, 0 );

    for (;;)
    {
        ULONG cbRead;

        if ( ReadFile( hPri, abTemp, sizeof(abTemp), &cbRead, 0 ) )
        {
            if ( 0 == cbRead )
                break;

            ULONG iRec = 0;

            while ( iRec < cPriRecPerBuf )
            {
                COnDiskPropertyRecord * pRec = new( iRec, abTemp, cbPriRec/4 ) COnDiskPropertyRecord;

                if ( pRec->IsTopLevel() )
                {
                    Win4Assert(!pRec->IsNormalTopLevel());

                    PROPVARIANT var;
                    BYTE abExtra[MAX_PATH * 5];
                    unsigned cbExtra = sizeof(abExtra);

                    Win4Assert(SecWidPtrFieldRec.IsFixedSize());

                    {
                        pRec->ReadFixed( SecWidPtrFieldRec.Ordinal(),
                                         SecWidPtrFieldRec.Mask(),
                                         SecWidPtrFieldRec.Offset(),
                                         cPriTotal,
                                         SecWidPtrFieldRec.Type(),
                                         var,
                                         abExtra,
                                         &cbExtra,
                                         *((PStorage *)0) );

                        switch ( var.vt )
                        {
                        case VT_EMPTY:
                            Win4Assert(!"Reading VT_EMPTY. Expect to read VT_UI4");
                            break;

                        case VT_I4:
                            Win4Assert(!"Reading VT_I4. Expect to read VT_UI4");
                            break;

                        case VT_UI4:
                        {
                            // Do we need to read a new large page?
                            iTargetSection = var.ulVal/cSecRecPerBuf;
                            if (var.ulVal > cMaxWidsInSecStore)  // ensure that it is a valid wid in secondary store.
                            {
                                printf("Wid %u (0x%x) is pointing to a non-existent wid %u (0x%x) in Secondary store.\n",
                                       iSection*cPriRecPerBuf + iRec, iSection*cPriRecPerBuf + iRec,
                                       var.ulVal, var.ulVal);
                                continue;
                            }

                            if (iSection2 != iTargetSection)
                            {
                                // seek to the target section and read the large page into buffer.
                                //SetFilePointer(hSec, (iTargetSection - iSection2)*SixtyFourK, 0, FILE_CURRENT);
                                SetFilePointer(hSec, iTargetSection*SixtyFourK, 0, FILE_BEGIN);
                                ReadFile( hSec, abTemp2, sizeof(abTemp2), &cbRead2, 0 );
                                iSection2 = iTargetSection;
                            }

                            // Get the record in question.
                            COnDiskPropertyRecord * pRec2 = new( var.ulVal % cSecRecPerBuf, abTemp2, cbSecRec/4 ) COnDiskPropertyRecord;

                            // Now grill it!
                            if (!pRec2->IsNormalTopLevel())
                            {
                                cInconsistencies++;
                                // Invalid record type
                                printf("Error: Wid %u (0x%x), (%u:%u) is pointing to a non-toplevel  wid %u (0x%x), ",
                                       iSection*cPriRecPerBuf + iRec,
                                       iSection*cPriRecPerBuf + iRec,
                                       iSection, iRec,
                                       var.ulVal, var.ulVal);

                                 printf("(%u:%u), %s, length = %u record(s)\n",
                                    iSection2, var.ulVal % cSecRecPerBuf,
                                    pRec2->IsNormalTopLevel() ? "Top Level Normal" :
                                        pRec2->IsOverflow() ? "Overflow" :
                                            pRec2->IsFreeRecord() ? "Free Normal" :
                                                pRec2->IsTopLevel() ? "Top Level Lean":
                                                    pRec2->IsLeanFreeRecord() ? "Free Lean":
                                                "Virgin",
                                    pRec2->CountRecords() );
                            }
                            break;
                        }

                        case VT_FILETIME:
                            Win4Assert(!"Reading VT_FILETIME. Expect to read VT_UI4");
                            break;

                        case VT_I8:
                            Win4Assert(!"Reading VT_I8. Expect to read VT_UI4");
                            break;

                        case VT_UI8:
                            Win4Assert(!"Reading VT_UI8. Expect to read VT_UI4");
                            break;
                        }
                    }
                }
                else if ( pRec->IsFreeRecord() )
                {

                }
                else
                {

                }

                if ( pRec->CountRecords() == 0 )
                {
                    printf( "Record %u (file offset 0x%x) is zero length!\n",
                            iSection * cPriRecPerBuf + iRec,
                            iSection * sizeof(abTemp) + iRec * cbPriRec );
                }

                if ( pRec->IsValidType() )
                    iRec += pRec->CountRecords();
                else
                    iRec++;

                ULONG iPct = (iSection * (100/5) / cPriTotalSections) * 5;
                if (iPct != iCurrentPct)
                {
                    iCurrentPct = iPct;
                    printf( "Read %u%%\n", iCurrentPct );
                }
            }

            iSection++;
            oFile += cbRead;
        }
        else
        {
            ULONG Status = GetLastError();

            if ( Status == ERROR_HANDLE_EOF )
                break;
            else
            {
                printf( "Error %u reading file.\n", Status );
            }
        }
    }

    CloseHandle( hPri );
    CloseHandle( hSec );

    if (cInconsistencies)
    {
        printf("%d inconsistencies were detected between the two stores.\n", cInconsistencies);
    }
    else
        printf("No inconsistencies were detected between the two stores.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\propdump\vmapdump.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       vmapdump.cxx
//
//  Contents:   VMAP dump utility
//
//  History:    22 Jan 1998     AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vmap.hxx>


DECLARE_INFOLEVEL(ci)

unsigned fVerbose = 0;

int VMapDump( char * pszPath );

int __cdecl main( int argc, char * argv[] )
{
    char *   pszFile = argv[1];
    unsigned cFail = 0;

    for ( int i = 1; i < argc; i++ )
    {
        if ( argv[i][0] == '-' )
        {
            switch ( argv[i][1] )
            {
            case 'v':
            case 'V':
                fVerbose = 1;
                break;

#if 0
            case 'm':
            case 'M':
                fReadMetadata = TRUE;
                break;

            case 'f':
            case 'F':
                i++;

                if ( cField < cMaxFields )
                    aiField[cField++] = strtol( argv[i], 0, 10 );
                break;
#endif // 0

            default:
                fprintf(stderr, "Usage: file ...\n");
                exit(2);
            }
            continue;
        }
        else
        {
            pszFile = argv[i];

            cFail += VMapDump(pszFile);
        }
    }

    return cFail != 0;
}


int VMapDump( char * pszPath )
{
    HANDLE h = CreateFileA( pszPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            0,
                            0 );

    if ( INVALID_HANDLE_VALUE == h )
    {
        printf( "Can't open file %s. Error %u\n", pszPath, GetLastError() );
        return 1;
    }

    printf( "fileaddr  rec\tparent\ttype\n"
                       "\t\tvirtual scope\n"
                       "\t\tphysical scope\n" );

    ULONG cbRead;
    CVMapDesc VMapDesc;


    for ( unsigned i = 0; ; i++ )
    {
        if ( ! ReadFile( h, &VMapDesc, sizeof VMapDesc, &cbRead, 0 ) )
        {
            fprintf(stderr, "Error %d reading %s\n", GetLastError(), pszPath );
            CloseHandle( h );
            return 1;
        }

        if (cbRead == 0)
            break;

        if (VMapDesc.IsFree())
            continue;

        printf("%08x  %d.\t%d\t%03x",
               i*sizeof VMapDesc, i, 
               VMapDesc.Parent(), VMapDesc.RootType() );

        if (VMapDesc.IsManual())
            printf(" ManualRoot");
        if (VMapDesc.IsAutomatic())
            printf(" AutomaticRoot");
        if (VMapDesc.IsInUse())
            printf(" UsedRoot");
        if (VMapDesc.IsNNTP())
            printf(" NNTPRoot");
        if (VMapDesc.IsNonIndexedVDir())
            printf(" NonIndexedVDir");
        if (VMapDesc.IsIMAP())
            printf(" IMAPRoot");

        printf("\n");

        unsigned cchVirtual = VMapDesc.VirtualLength();
        unsigned cchPhysical = VMapDesc.PhysicalLength();

        if (cchVirtual > MAX_PATH)
        {
            fprintf(stderr, "Error - Virtual path len too long, %d\n", cchVirtual );
            cchVirtual = MAX_PATH;
        }
        if (cchPhysical > MAX_PATH)
        {
            fprintf(stderr, "Error - Physical path len too long, %d\n", cchPhysical );
            cchPhysical = MAX_PATH;
        }

        printf("\t\t%*.64ws\n\t\t%*.64ws\n",
               cchVirtual, VMapDesc.VirtualPath(),
               cchPhysical, VMapDesc.PhysicalPath() );
    }
    CloseHandle( h );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\qryperf\procinfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       procinfo.cxx
//
//  Contents:   performance test program
//
//  History:    16 March 1996   dlee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}

#include <windows.h>

#include <stdio.h>

void GetProcessInfo(
    WCHAR * pwcImage,
    LARGE_INTEGER & liUserTime,
    LARGE_INTEGER & liKernelTime,
    ULONG & cHandles,
    ULONGLONG & cbWorkingSet,
    ULONGLONG & cbPeakWorkingSet,
    ULONGLONG & cbPeakVirtualSize,
    ULONGLONG & cbNonPagedPoolUsage,
    ULONGLONG & cbPeakNonPagedPoolUsage )
{
    BYTE ab[81920];

    NTSTATUS status = NtQuerySystemInformation( SystemProcessInformation,
                                                ab,
                                                sizeof ab,
                                                NULL );

    if ( NT_SUCCESS( status ) )
    {
        DWORD dwProcId = GetCurrentProcessId();

        DWORD cbOffset = 0;
        PSYSTEM_PROCESS_INFORMATION pCurrent = 0;
        do
        {
            pCurrent = (PSYSTEM_PROCESS_INFORMATION)&(ab[cbOffset]);

            //printf(" image: '%ws'\n", pCurrent->ImageName.Buffer );

            if ( ( 0 == pwcImage && pCurrent->UniqueProcessId == LongToHandle( dwProcId ) ) ||
                 ( 0 != pwcImage && 0 != pCurrent->ImageName.Buffer && !_wcsicmp( pwcImage, pCurrent->ImageName.Buffer ) ) )
            {
                liUserTime = pCurrent->UserTime;
                liKernelTime = pCurrent->KernelTime;
                cHandles = pCurrent->HandleCount;
                cbWorkingSet = pCurrent->WorkingSetSize;
                cbPeakWorkingSet = pCurrent->PeakWorkingSetSize;
                cbPeakVirtualSize = pCurrent->PeakVirtualSize;
                cbNonPagedPoolUsage = pCurrent->QuotaNonPagedPoolUsage;
                cbPeakNonPagedPoolUsage = pCurrent->QuotaPeakNonPagedPoolUsage;

                return;
            }
  
            cbOffset += pCurrent->NextEntryOffset;
        } while (pCurrent->NextEntryOffset);
    }
}

#if 0
void PrintProcessInfo()
{
    ULONG cHandles;
    ULONG cbWorkingSet;
    ULONG cbPeakWorkingSet;
    ULONG cbPeakVirtualSize;
    ULONG cbNonPagedPoolUsage;
    ULONG cbPeakNonPagedPoolUsage;

    GetProcessInfo( cHandles,
                    cbWorkingSet,
                    cbPeakWorkingSet,
                    cbPeakVirtualSize,
                    cbNonPagedPoolUsage,
                    cbPeakNonPagedPoolUsage );

    printf( "info:\n  cbWorkingSet %d\n"
            "  cbPeakWorkingSet %d\n"
            "  cbPeakVirtualSize %d\n"
            "  cbNonPagedPoolUsage %d\n"
            "  cbPeakNonPagedPoolUsage %d\n"
            "  cHandles: %d\n",
        cbWorkingSet,
        cbPeakWorkingSet,
        cbPeakVirtualSize,
        cbNonPagedPoolUsage,
        cbPeakNonPagedPoolUsage,
        cHandles );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\qryperf\qryperf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       qryperf.CXX
//
//  Contents:   performance test program
//
//  History:    16 March 1996   dlee    Created (from fsdbdrt)
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#define STRESS

#ifdef STRESS
    #define GET_DATA_TOO
    unsigned cThreads = 8;
    const unsigned cLoopTimes = 0xffffffff;
    WCHAR *pwcCatalog = L"system";
    WCHAR *pwcMachine = L".";
    BOOL g_fStopNow = FALSE;
    const unsigned cmsSleep = 3000; // 0
    unsigned g_cmsSleep;
    BOOL g_fFetchRowsAtWill = TRUE;
#else
    const unsigned cThreads = 8;
    const unsigned cLoopTimes = 1000;
    WCHAR *pwcCatalog = L"encarta";
    WCHAR *pwcMachine = L".";
#endif

BOOL g_fSQL = FALSE;

#define DBINITCONSTANTS

#include <crt\io.h>
#include <time.h>
#include <process.h>
#include <propvar.h>
#include <olectl.h>

#include <doquery.hxx>

WCHAR g_awcCatalog[ MAX_PATH ];
WCHAR g_awcMachine[ MAX_PATH ];
BOOL g_fSequential = FALSE;

template<class T> T Rand2( T t ) { return (T) abs( (int) ( rand() % t ) ); }
template<class T> T Rand( T t ) { return (T) abs( GetTickCount() % t ); }

CCoTaskAllocator CoTaskAllocator;
void * CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return CoTaskMemAlloc( cbSize );
}

void CCoTaskAllocator::Free( void *pv )
{
    CoTaskMemFree( pv );
}

BOOL isEven(unsigned n)
{
    return ( 0 == ( n & 1 ) );
}

static const GUID guidSystem = PSGUID_STORAGE;
static const GUID guidQuery = PSGUID_QUERY;
static const GUID guidRowsetProps = DBPROPSET_ROWSET;

static CDbColId psName( guidSystem, PID_STG_NAME );
static CDbColId psPath( guidSystem, PID_STG_PATH );
static CDbColId psSize( guidSystem, PID_STG_SIZE );
static CDbColId psWriteTime( guidSystem, PID_STG_WRITETIME );
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );
static CDbColId psRank( guidQuery, DISPID_QUERY_RANK );

static CDbColId * aColIds[] =
{
    &psName, &psPath, &psSize, &psWriteTime, &psRank
};

static ULONG cColIds = sizeof aColIds / sizeof aColIds[0];

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort );

IRowsetScroll * InstantiateRowset(
    ICommand *pCommandIn,
    DWORD dwDepth,
    LPWSTR pwszScope,
    XPtr<CDbCmdTreeNode> & xTree,
    WCHAR const * pwcQuery,
    REFIID riid,
    BOOL fAsynchronous );

HACCESSOR MapColumns(
        IUnknown * pUnknown,
        ULONG cCols,
        DBBINDING * pBindings,
        const DBID * pColIds );

void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc );

DWORD __stdcall RunPerfTest(void *pv);

void LogError( char const * pszFormat, ... );

void GetProcessInfo(
    WCHAR * pwcImage,
    LARGE_INTEGER & liUserTime,
    LARGE_INTEGER & liKernelTime,
    ULONG & cHandles,
    ULONGLONG & cbWorkingSet,
    ULONGLONG & cbPeakWorkingSet,
    ULONGLONG & cbPeakVirtualSize,
    ULONGLONG & cbNonPagedPoolUsage,
    ULONGLONG & cbPeakNonPagedPoolUsage );

inline _int64 mkTime( FILETIME ft )
{
    return (_int64) ft.dwLowDateTime +
           ( ( (_int64 ) ft.dwHighDateTime ) << 32 );
} //mkTime

inline _int64 mkTime( FILETIME ftK, FILETIME ftU )
{
    return mkTime( ftK ) + mkTime( ftU );
} //mkTime

inline _int64 mkTime( LARGE_INTEGER li )
{
    return (_int64) li.LowPart +
           ( ( (_int64) li.HighPart ) << 32 );
} //mkTime

inline _int64 mkTime( LARGE_INTEGER liK, LARGE_INTEGER liU )
{
    return mkTime( liK ) + mkTime( liU );
} //mkTime

void GetCiSvcTimes(
    LARGE_INTEGER & liCiSvcKernelTime,
    LARGE_INTEGER & liCiSvcUserTime )
{
    ULONG cHandles;
    ULONGLONG cbWorkingSet;
    ULONGLONG cbPeakWorkingSet;
    ULONGLONG cbPeakVirtualSize;
    ULONGLONG cbNonPagedPoolUsage;
    ULONGLONG cbPeakNonPagedPoolUsage;
    GetProcessInfo( L"cisvc.exe",
                    liCiSvcUserTime,
                    liCiSvcKernelTime,
                    cHandles,
                    cbWorkingSet,
                    cbPeakWorkingSet,
                    cbPeakVirtualSize,
                    cbNonPagedPoolUsage,
                    cbPeakNonPagedPoolUsage );
} //GetCiSvcTimes

void RunQuerySuite()
{
    HANDLE ah[ 200 ];
    DWORD dwID;

    for ( unsigned x = 0; x < cThreads; x++ )
    {
        #ifdef STRESS

            Sleep( GetCurrentThreadId() );

        #endif // STRESS

        ah[x] = CreateThread( 0,
                              65536,
                              RunPerfTest,
                              0,
                              0,
                              &dwID );
    }

    WaitForMultipleObjects( cThreads, ah, TRUE, INFINITE );

    for ( x = 0; x < cThreads; x++ )
        CloseHandle( ah[x] );
} //RunQuerySuite

void Usage()
{
    printf( "usage: qryperf [-c:catalog] [-m:machine] [-d:delay(ms)] [-q(onarch)] [-s:(0|1)] [-t:threads] -f(etch at will)\n" );

    exit(1);
} //Usage

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    HRESULT hr = CoInitialize( 0 );

    if ( FAILED( hr ) )
        exit( 1 );

    wcscpy( g_awcCatalog, pwcCatalog );
    wcscpy( g_awcMachine, pwcMachine );

    #ifdef STRESS
        g_cmsSleep = cmsSleep;
    #endif

    for ( int i = 1; i < argc; i++ )
    {
        if ( '/' == argv[i][0] || '-' == argv[i][0] )
        {
            WCHAR c = (WCHAR) tolower( argv[i][1] );

            if ( L':' != argv[i][2] && c != L'q' && c != 'f' )
                Usage();

            if ( L'c' == c )
                wcscpy( g_awcCatalog, argv[i] + 3 );
            else if ( L'm' == c )
                wcscpy( g_awcMachine, argv[i] + 3 );
    #ifdef STRESS
            else if ( L'd' == c )
                g_cmsSleep = _wtoi( argv[i] + 3 );
            else if ( 't' == c )
                cThreads = _wtoi( argv[i] + 3 );
            else if ( 'f' == c )
                g_fFetchRowsAtWill = FALSE;
    #endif
            else if ( 'q' == c )
                g_fSQL = TRUE;
            else if ( L's' == c )
                g_fSequential = _wtoi( argv[i] + 3 );
            else
                Usage();
        }
        else
            Usage();
    }

    HANDLE hproc = GetCurrentProcess();
    FILETIME ftCreate,ftExit,ftKernel,ftUser;
    GetProcessTimes( hproc, &ftCreate, &ftExit, &ftKernel, &ftUser );
    _int64 openTime = mkTime( ftKernel, ftUser );

    {
        CI_STATE state;
        state.cbStruct = sizeof state;
        CIState( g_awcCatalog, g_awcMachine, &state );
    }

    LARGE_INTEGER liCiSvcUserTime;
    LARGE_INTEGER liCiSvcKernelTime;
    GetCiSvcTimes( liCiSvcKernelTime, liCiSvcUserTime );
    _int64 ciStartTime = mkTime( liCiSvcKernelTime, liCiSvcUserTime );

    GetProcessTimes( hproc, &ftCreate, &ftExit, &ftKernel, &ftUser );
    _int64 startTime = mkTime( ftKernel, ftUser );

    RunQuerySuite();

    CIShutdown();

    GetProcessTimes( hproc, &ftCreate, &ftExit, &ftKernel, &ftUser );
    _int64 endTime = mkTime( ftKernel, ftUser );

    GetCiSvcTimes( liCiSvcKernelTime, liCiSvcUserTime );
    _int64 ciEndTime = mkTime( liCiSvcKernelTime, liCiSvcUserTime );

#ifdef STRESS
    printf( "stress test client time: %d ms cisvc time: %d ms\n",
            (DWORD) ((endTime - startTime) / 10000 ),
            (DWORD) ((ciEndTime - ciStartTime) / 10000 ) );
#else
    printf( "%s test client time: %d ms cisvc time: %d ms\n",
            g_fSequential ? "sequential" : "non-sequential",
            (DWORD) ((endTime - startTime) / 10000 ),
            (DWORD) ((ciEndTime - ciStartTime) / 10000 ) );
#endif

    CoUninitialize();

    return 0;
} //main

#ifdef GET_DATA_TOO

class CBookMark
{
public:
    CBookMark() : cbBmk (0) {}
    CBookMark( DBBOOKMARK bmkSpecial ) : cbBmk (1)
    {
        abBmk[0] = (BYTE) bmkSpecial;
    }
    BOOL IsValid() const { return 0 != cbBmk; }
    void Invalidate () { cbBmk = 0; }
    BOOL IsEqual ( CBookMark& bmk)
    {
        if (cbBmk != bmk.cbBmk)
            return FALSE;

        return memcmp ( abBmk, bmk.abBmk, cbBmk ) == 0;
    }
    void MakeFirst()
    {
        cbBmk = sizeof (BYTE);
        abBmk[0] = (BYTE) DBBMK_FIRST;
    }
    BOOL IsFirst()
    {
        return cbBmk == sizeof(BYTE) && abBmk[0] == (BYTE) DBBMK_FIRST;
    }

    DBLENGTH cbBmk;
    BYTE     abBmk[ 50 ];
};

void FetchAtWill(
    IRowset *   pRowset,
    IUnknown *  pAccessor,
    HACCESSOR   hAccessor,
    DBCOUNTITEM cHits )
{
    if ( 0 == cHits )
        return;

    XInterface<IRowsetScroll> xRS;
    SCODE sc = pRowset->QueryInterface( IID_IRowsetScroll, xRS.GetQIPointer() );

    if ( FAILED( sc ) )
    {
        LogError( "Can't QI for IID_IRowsetScroll\n" );
        return;
    }

    const DBROWCOUNT cMaxToGet = 8;
    HROW aHRows[ cMaxToGet ];
    HROW * paHRows = aHRows;

    // Fetch relative to first

    const BYTE bmkFirst = (BYTE) DBBMK_FIRST;

    for ( unsigned i = 0; i < 5 && !g_fStopNow; i++ )
    {
        DBCOUNTITEM cRows;
        DBROWCOUNT cToGet = 1 + Rand2( cMaxToGet - 1 );
        DBROWOFFSET iStart = Rand2( cHits );
        sc = xRS->GetRowsAt( 0, 0, 1, &bmkFirst, iStart, cToGet, &cRows, &paHRows );

        if ( SUCCEEDED( sc ) )
            xRS->ReleaseRows( cRows, aHRows, 0, 0, 0 );
        else
            LogError( "can't get %d rows at %d out of %d\n", cToGet, iStart, cHits );
    }

    // Fetch relative to last

    const BYTE bmkLast = (BYTE) DBBMK_LAST;

    for ( i = 0; i < 5 && !g_fStopNow; i++ )
    {
        DBCOUNTITEM cRows;
        DBROWCOUNT cToGet = 1 + Rand2( cMaxToGet - 1 );
        DBROWOFFSET iStart = Rand2( cHits );
        sc = xRS->GetRowsAt( 0, 0, 1, &bmkLast, -iStart, cToGet, &cRows, &paHRows );

        if ( SUCCEEDED( sc ) )
            xRS->ReleaseRows( cRows, aHRows, 0, 0, 0 );
        else
            LogError( "can't get %d rows at %d from last out of %d\n", cToGet, -iStart, cHits );
    }

    // Fetch relative to a random location

    static GUID guidBmk = DBBMKGUID;
    static CDbColId dbcolBookMark( guidBmk, PROPID_DBBMK_BOOKMARK );

    DBBINDING aBmkColumn[] = { 0, sizeof DBLENGTH, 0, 0, 0, 0, 0,
                               DBPART_VALUE | DBPART_LENGTH,
                               DBMEMOWNER_CLIENTOWNED,
                               DBPARAMIO_NOTPARAM,
                               50,
                               0,
                               DBTYPE_BYTES,
                               0, 0 };

    XInterface<IAccessor> xAccessor;
    sc = xRS->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "can't create bookmark accessor IAccessor: %#x\n", sc );
        return;
    }

    HACCESSOR hBmkAccessor;
    sc = xAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                    1,
                                    aBmkColumn,
                                    0,
                                    &hBmkAccessor,
                                    0 );
    if ( FAILED(sc) )
    {
        LogError( "can't create accessor\n" );
        return;
    }

    HROW aBmkHRows[ 1 ];
    HROW * paBmkHRows = aBmkHRows;
    DBROWOFFSET iBmkStart = Rand2( cHits );
    DBCOUNTITEM cBmkRows;
    sc = xRS->GetRowsAt( 0, 0, 1, &bmkFirst, iBmkStart, 1, &cBmkRows, &paBmkHRows );

    if ( SUCCEEDED( sc ) )
    {
        CBookMark bmk;
        sc = xRS->GetData( aBmkHRows[0], hBmkAccessor, &bmk );

        if ( SUCCEEDED( sc ) && ( DB_S_ERRORSOCCURRED != sc ) )
        {
            for ( unsigned i = 0; i < 5 && !g_fStopNow; i++ )
            {
                DBCOUNTITEM cRows;
                DBROWCOUNT cToGet = 1 + Rand2( cMaxToGet - 1 );
                DBROWOFFSET iStart = Rand2( cHits ) - iBmkStart;

                sc = xRS->GetRowsAt( 0, 0, bmk.cbBmk, bmk.abBmk, iStart,
                                     cToGet, &cRows, &paHRows );

                if ( SUCCEEDED( sc ) )
                    xRS->ReleaseRows( cRows, aHRows, 0, 0, 0 );
                else
                    LogError( "can't getrowsat %d rows %d relative to bmk at %d, rowset has %d: %#x\n",
                              cToGet, iStart, iBmkStart, cHits, sc );
            }
        }
        else
            LogError( "can't GetData the bmk row: %#x\n", sc );

        xRS->ReleaseRows( 1, aBmkHRows, 0, 0, 0 );
    }
    else
        LogError( "can't GetRowsAt the bmk row: %#x\n", sc );

    ReleaseAccessor( pAccessor, hBmkAccessor );
} //FetchAtWill

#endif

static DBBINDING aPropTestCols[] =
{
  { 0,(sizeof ULONG_PTR)*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*1,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*2,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*3,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
  { 0,(sizeof ULONG_PTR)*4,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
};

void RunPerfQuery(
    CDbRestriction & CiRst,
    WCHAR const *    pwcQuery,
    unsigned         cExpectedHits,
    ICommand *       pCommand,
    BOOL             fSeq,
    BOOL             fAsynchronous )
{
    CDbColumns cols( 5 );
    BOOL fOk = cols.Add( psName, 0 );
    if ( fOk )
        cols.Add( psSize, 1 );
    if ( fOk )
        cols.Add( psWriteTime, 2 );
    if ( fOk )
        cols.Add( psPath, 3 );
    if ( fOk )
        cols.Add( psRank, 4 );

    if ( !fOk )
    {
        LogError(" can't create column specification\n" );
        return;
    }

    unsigned cRetries = 0;
    DBCOUNTITEM cRowsReturned = 0;
    IRowset * pRowset = 0;

    {
        CDbSortSet ss( 1 );

#ifdef STRESS
        int x = Rand( cColIds );
        int y = rand();
        fOk = ss.Add( *aColIds[x],
                      isEven( rand() ) ? QUERY_SORTDESCEND : QUERY_SORTASCEND,
                      0 );
#else
        fOk = ss.Add( psRank, QUERY_SORTDESCEND, 0);
#endif

        if ( !fOk )
        {
            LogError(" can't create sort specification\n" );
            return;
        }

        XPtr<CDbCmdTreeNode> xCmdTree( FormQueryTree( &CiRst,
                                                      cols,
                                                      fSeq ? 0 : &ss ) );

        if ( xCmdTree.IsNull() )
            return;

        pRowset = InstantiateRowset( pCommand,
                                     QUERY_DEEP,   // Depth
                                     L"\\",        // Scope
                                     xCmdTree,     // DBCOMMANDTREE
                                     pwcQuery,
                                     fSeq ? IID_IRowset :
                                            IID_IRowsetScroll,
                                     fAsynchronous );

        if ( 0 == pRowset )
        {
            LogError(" can't get rowset\n" );
            return;
        }

        XInterface<IRowset> xRowset( pRowset );

#ifdef GET_DATA_TOO

        // Get data

        DBID aDbCols[5];
        aDbCols[0] = psName;
        aDbCols[1] = psSize;
        aDbCols[2] = psWriteTime;
        aDbCols[3] = psPath;
        aDbCols[4] = psRank;

        IUnknown * pAccessor = pRowset;
        HACCESSOR hAccessor = MapColumns( pAccessor,
                                          5,
                                          aPropTestCols,
                                          aDbCols );
        if ( 0 == hAccessor )
            return;

#endif // GET_DATA_TOO

        DBCOUNTITEM cTotal = 0;

#ifdef STRESS
        const unsigned cFetchPasses = g_fFetchRowsAtWill ? 1000 : 5;
#else
        const unsigned cFetchPasses = 3;
#endif

        for ( unsigned i = 0; i < cFetchPasses; i++ )
        {
#ifdef STRESS
            if ( g_fStopNow )
                break;
#endif
            HROW aHRow[10];
            HROW * pgrhRows = aHRow;

            SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

            if ( FAILED( sc ) )
            {
                LogError( "'%ws' IRowset->GetNextRows returned 0x%x, cTotal: %d, cRowsReturned: %d\n",
                          pwcQuery, sc, cTotal, cRowsReturned );
                break;
            }

            cTotal += cRowsReturned;

#ifdef GET_DATA_TOO
            PROPVARIANT* data[5];

            for ( ULONG r = 0; r < cRowsReturned; r++ )
            {
                SCODE sc = pRowset->GetData( pgrhRows[r],
                                             hAccessor,
                                             &data );
            }
#endif // GET_DATA_TOO

            if ( 0 != cRowsReturned )
                pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0 );

            if ( DB_S_ENDOFROWSET == sc )
                break;
        }

#ifdef GET_DATA_TOO

        if ( !fSeq && g_fFetchRowsAtWill )
            FetchAtWill( pRowset, pAccessor, hAccessor, cTotal );

        ReleaseAccessor( pAccessor, hAccessor );

        //printf( "query %ws returned %d hits\n", pwcQuery, cTotal );
#endif // GET_DATA_TOO

        if ( 0 == cTotal )
            printf( "query %ws returned no hits\n", pwcQuery );

#if 0
        if ( cTotal < __min( 30, cExpectedHits ) )
            printf( "query %ws returned %d hits, expecting %d\n",
                    pwcQuery, cTotal, cExpectedHits );
#endif
    }

} //RunPerfQuery

struct SQuery
{
    WCHAR const * pwcQuery;
    unsigned cEncartaHits;
};

static SQuery aQueries[] =
{

#ifdef STRESS

    { L"stereo", 4 },
    { L"flex", 2 },
    { L"agassi", 1 },
    { L"detroit", 108 },
    { L"miami", 60 },
    { L"edison", 25 },
    { L"bulb", 33 },
    { L"elephant", 87 },
    { L"radius", 43 },
    { L"amplifier", 17 },
    { L"drunk", 10 },
    { L"grunt", 3 },
    { L"war", 4241 },
    { L"peace", 812 },
    { L"river", 3402 },
    { L"not", 4002 },
    { L"city", 5567 },
    { L"century", 4470 },

#else

    { L"stereo", 4 },
    { L"flex", 2 },
    { L"agassi", 1 },
    { L"detroit", 108 },
    { L"miami", 60 },
    { L"edison", 25 },
    { L"web", 57 },
    { L"bulb", 33 },
    { L"microsoft", 15 },
    { L"elephant", 87 },
    { L"radius", 43 },
    { L"amplifier", 17 },
    { L"drunk", 10 },
    { L"grunt", 3 },

#endif // STRESS

};

DWORD __stdcall RunPerfTest(void *pv)
{
    static long cQueriesSoFar = 0;

//    #ifdef STRESS
//    srand( GetTickCount() + GetCurrentThreadId() );
//    #endif

    XInterface<ICommand> xCommand;

    do
    {
        ICommand * pCommand = 0;
        SCODE sc = CICreateCommand( (IUnknown **) &pCommand,
                                    0,
                                    IID_ICommand,
                                    g_awcCatalog,
                                    g_awcMachine );
        if ( FAILED( sc ) )
            LogError( "CICreateCommand failed: 0x%x\n", sc );
        else
            xCommand.Set( pCommand );
    } while ( xCommand.IsNull() );

    for ( int x = 0; x < cLoopTimes; x++ )
    {
        try
        {
            const int cQueries = sizeof aQueries / sizeof aQueries[0];

            #ifdef STRESS
                int j = Rand( cQueries );
            #else
                int j = ( x % cQueries );
            #endif // STRESS

            CDbContentRestriction CiRst( aQueries[j].pwcQuery, psContents );

            if ( !CiRst.IsValid() )
                continue;

            #ifdef STRESS
                if ( 0 != g_cmsSleep )
                    Sleep( Rand( g_cmsSleep ) );

                ICommand *pCmd = isEven( x ) ? xCommand.GetPointer() : 0;
                BOOL fSeq = ( Rand( 100 ) < 70 );
                BOOL fAsynchronous = FALSE;
                if ( !fSeq )
                    fAsynchronous = ( Rand( 100 ) < 30 );

                RunPerfQuery( CiRst,
                              aQueries[j].pwcQuery,
                              aQueries[j].cEncartaHits,
                              pCmd,
                              fSeq,
                              fAsynchronous );

                InterlockedIncrement( &cQueriesSoFar );
                if ( 0 == ( cQueriesSoFar % 10 ) )
                    printf( "%d queries on catalog '%ws', machine '%ws'\n",
                            cQueriesSoFar, g_awcCatalog, g_awcMachine );

                if ( g_fStopNow )
                    return 0;
            #else
                RunPerfQuery( CiRst,
                              aQueries[j].pwcQuery,
                              aQueries[j].cEncartaHits,
                              xCommand.GetPointer(),
                              g_fSequential,
                              FALSE );
            #endif //STRESS
        }
        catch( CException & e )
        {
            // ignore
        }
    }

    return 0;
} //RunPerfTest

//+---------------------------------------------------------------------------
//
//  Function:   FormQueryTree
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [pRst]   - pointer to Restriction tree describing the query
//              [Cols]   - Columns in the resulting table
//              [pSort]  - pointer to sort set; may be null
//
//  Returns:    A pointer to the query tree. It is the responsibility of
//              the caller to later free it.
//
//  History:    06 July 1995   AlanW   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort )
{
    CDbCmdTreeNode *  pTree = 0;        // return value

    if ( 0 != pRst )
    {
        //
        // First create a selection node and append the restriction tree to it
        //
        CDbSelectNode * pSelect = new CDbSelectNode();
        if ( 0 == pSelect )
        {
            LogError("FormQueryTree: can't make CDbSelectNode\n" );
            return 0;
        }

        pTree = pSelect;
        if ( !pSelect->IsValid() )
        {
            delete pTree;
            LogError("FormQueryTree: select node isn't valid\n" );
            return 0;
        }

        //
        // Clone the restriction and use it.
        //
        CDbCmdTreeNode * pExpr = pRst->Clone();
        if ( 0 == pExpr )
        {
            delete pTree;
            LogError("FormQueryTree: can't clone the restriction\n" );
            return 0;
        }
#ifdef STRESS
        else
        {
            CDbContentRestriction * p = (CDbContentRestriction *) pExpr;
            if ( !p->IsValid() )
            {
                LogError( "clone failed illegally!\n" );
                DebugBreak();
            }
        }
#endif

        //
        // Now make the restriction a child of the selection node.
        //
        pSelect->AddRestriction( pExpr );
    }
    else
    {
        //
        // No restriction.  Just use table ID node as start of tree.
        //
        pTree = new CDbTableId();
        if ( 0 == pTree )
        {
            LogError("FormQueryTree: can't make CDbTableId\n" );
            return 0;
        }
    }

    //
    // Next create the projection nodes
    //
    CDbProjectNode * pProject = new CDbProjectNode();
    if ( 0 == pProject )
    {
        delete pTree;
        LogError("FormQueryTree: can't make CDbProjectNode\n" );
        return 0;
    }

    //
    // Make the selection a child of the projection node.
    //
    pProject->AddTable( pTree );
    pTree = pProject;

    //
    // Next add all the columns in the state.
    //
    unsigned int cCol = Cols.Count();
    for ( unsigned int i = 0; i < cCol; i++ )
    {
        if ( !pProject->AddProjectColumn( Cols.Get(i) ))
        {
            delete pTree;
            LogError("FormQueryTree: can't add project column\n" );
            return 0;
        }
    }

    //
    // Next add a sort node and make the project node a child of the
    // sort node
    //

    if (pSort && pSort->Count())
    {
        unsigned int cSortProp = pSort->Count();
        CDbSortNode * pSortNode = new CDbSortNode();

        if ( 0 == pSortNode )
        {
            delete pTree;
            LogError("FormQueryTree: create sort node\n" );
            return 0;
        }

        //
        // Make the project node a child of the sort node.
        //
        if ( ! pSortNode->AddTable( pTree ) )
        {
            delete pTree;
            delete pSortNode;
            LogError( "FormQueryTree: can't add table to sortnode\n" );
            return 0;
        }

        pTree = pSortNode;

        for( i = 0; i < cSortProp; i++ )
        {
            //
            // Add the sort column.
            //

            CDbSortKey const &key = pSort->Get( i );

#ifdef STRESS

            if ( 0 == &key )
            {
                LogError( "0 sort key!\n" );
                DebugBreak();
            }
#endif

            if ( !pSortNode->AddSortColumn( key ) )
            {
                delete pTree;
                LogError("FormQueryTree: can't add sort column\n");
                return 0;
            }

#ifdef STRESS
            DBCOMMANDTREE *p = (DBCOMMANDTREE *) (void *) pSortNode;
            p = p->pctFirstChild;
            p = p->pctNextSibling;
            p = p->pctFirstChild;

            if ( DBOP_sort_list_element != p->op ||
                 DBVALUEKIND_SORTINFO != p->wKind ||
                 0 == p->value.pdbsrtinfValue )
            {
                LogError( "p: %#p, bad sort element!\n", p );
                DebugBreak();
            }
#endif
        }
    }

    return pTree;
} //FormQueryTree

//+---------------------------------------------------------------------------
//
//  Class:      CAsynchNotify
//
//  Synopsis:   Class for the IDBAsynchNotify callbacks
//
//  History:    07 May 1999   dlee   Created
//
//----------------------------------------------------------------------------

class CAsynchNotify : public IDBAsynchNotify
{
public:
    CAsynchNotify() :
        _cRef( 1 ),
        _cLowResource( 0 ),
        _hEvent( 0 )
    {
        _hEvent = CreateEventW( 0, TRUE, FALSE, 0 );

        if ( 0 == _hEvent )
            LogError( "can't create notify event, %d\n", GetLastError() );
    }

    ~CAsynchNotify()
    {
        if ( 0 != _cRef )
            LogError( "CAsynchNotify refcounting is broken: %d\n", _cRef );

        if ( 0 != _hEvent )
            CloseHandle( _hEvent );
    }

    BOOL IsValid() const { return 0 != _hEvent; }

    //
    // IUnknown methods.
    //

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID *ppiuk )
    {
        *ppiuk = (void **) this; // hold our breath and jump
        AddRef();
        return S_OK;
    }

    STDMETHOD_( ULONG, AddRef ) () { return InterlockedIncrement( &_cRef ); }

    STDMETHOD_( ULONG, Release) () { return InterlockedDecrement( &_cRef ); }

    //
    // IDBAsynchNotify methods
    //

    STDMETHOD( OnLowResource ) ( DB_DWRESERVE dwReserved )
    {
        _cLowResource++;

        // If we've failed a few times due to low resource, give up
        // on the query since there may not be sufficient resources
        // to ever get an OnStop call.

        if ( _cLowResource >= 5 )
            SetEvent( _hEvent );

        return S_OK;
    }

    STDMETHOD( OnProgress ) ( HCHAPTER hChap, DBASYNCHOP ulOp,
                              DBCOUNTITEM ulProg, DBCOUNTITEM ulProgMax,
                              DBASYNCHPHASE ulStat, LPOLESTR pwszStatus )
    {
        return S_OK;
    }

    STDMETHOD( OnStop ) ( HCHAPTER hChap, ULONG ulOp,
                          HRESULT hrStat, LPOLESTR pwszStatus )
    {
        // If the query is complete (successfully or not), set the event

        if ( DBASYNCHOP_OPEN == ulOp )
            SetEvent( _hEvent );

        return S_OK;
    }

    void Wait()
    {
        WaitForSingleObject( _hEvent, INFINITE );
    }

private:
    LONG   _cRef;
    LONG   _cLowResource;
    HANDLE _hEvent;
};

//+---------------------------------------------------------------------------
//
//  Function:   WaitForQueryToComplete
//
//  Synopsis:   Waits for the query to complete.
//
//  Arguments:  [pRowset] -- the asynchronous rowset
//
//  History:    07 May 1999   dlee   Created
//
//----------------------------------------------------------------------------

SCODE WaitForQueryCompletion( IRowset * pRowset )
{
    SCODE sc = S_OK;

    if ( Rand( 100 ) < 50 )
    {
        // Register for notifications

        XInterface<IConnectionPointContainer> xCPC;
        sc = pRowset->QueryInterface( IID_IConnectionPointContainer,
                                      xCPC.GetQIPointer() );
        if (FAILED(sc))
        {
            LogError( "Can't QI for IConnectionPointContainer: %#x\n",sc );
            return sc;
        }

        XInterface<IConnectionPoint> xCP;
        sc = xCPC->FindConnectionPoint( IID_IDBAsynchNotify,
                                        xCP.GetPPointer() );
        if (FAILED(sc) && CONNECT_E_NOCONNECTION != sc )
        {
            LogError( "FindConnectionPoint failed: %#x\n",sc );
            return sc;
        }

        CAsynchNotify Notify;

        if ( !Notify.IsValid() )
            return HRESULT_FROM_WIN32( GetLastError() );

        DWORD dwAdviseID;
        sc = xCP->Advise( (IUnknown *) &Notify, &dwAdviseID );
        if (FAILED(sc))
        {
            LogError( "IConnectionPoint->Advise failed: %#x\n",sc );
            return sc;
        }

        //
        // In a real app, we'd be off doing other work rather than waiting
        // for the query to complete, but this will do.
        // MsgWaitForSingleObject is a good choice for a GUI app.  You could
        // also post a user-defined windows message when a notification is
        // received.
        //

        Notify.Wait();

        sc = xCP->Unadvise( dwAdviseID );

        if ( S_OK != sc )
        {
            LogError( "IConnectionPoint->Unadvise returned %#x\n", sc );
            return sc;
        }

        Notify.Release();
    }
    else
    {
        // Poll.  In a real app, real work would happen between checks.

        XInterface<IDBAsynchStatus> xIDBAsynch;
        sc = pRowset->QueryInterface( IID_IDBAsynchStatus,
                                      xIDBAsynch.GetQIPointer() );
        if ( FAILED( sc ) )
            return sc;
    
        do
        {
            DBCOUNTITEM Numerator, Denominator;
            DBASYNCHPHASE Phase;
            sc = xIDBAsynch->GetStatus( DB_NULL_HCHAPTER,
                                        DBASYNCHOP_OPEN,
                                        &Numerator,
                                        &Denominator,
                                        &Phase,
                                        0 );
            if ( FAILED( sc ) || ( DBASYNCHPHASE_COMPLETE == Phase ) )
                break;
    
            Sleep( 20 );  // Give the query a chance to run
        } while ( TRUE );
    }
    
    return sc;
} //WaitForQueryCompletion

//+---------------------------------------------------------------------------
//
//  Function:   InstantiateRowset
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [dwDepth]   - Query depth, one of QUERY_DEEP or QUERY_SHALLOW
//              [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [riid]      - Interface ID of the desired rowset interface
//
//  Returns:    IRowsetScroll* - a pointer to an instantiated rowset
//
//  History:    22 July 1995   AlanW   Created
//
//  Notes:      Although the returned pointer is to IRowsetScroll, the
//              returned pointer may only support IRowset, depending
//              upon the riid parameter.
//
//              Ownership of the query tree is given to the ICommandTree
//              object.  The caller does not need to delete it.
//
//              Use InstantiateMultipleRowsets for categorized queries.
//
//----------------------------------------------------------------------------

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

IRowsetScroll * InstantiateRowset(
    ICommand *             pCommandIn,
    DWORD                  dwDepth,
    LPWSTR                 pwszScope,
    XPtr<CDbCmdTreeNode> & xTree,
    WCHAR const *          pwcQuery,
    REFIID                 riid,
    BOOL                   fAsynchronous )
{
    ICommand * pCommand;
    XInterface<ICommand> xCommand;
    if ( 0 == pCommandIn )
    {
        SCODE sc = CICreateCommand( (IUnknown **) &pCommand,
                                    0,
                                    IID_ICommand,
                                    g_awcCatalog,
                                    g_awcMachine );
        if ( FAILED( sc ) )
        {
            LogError( "InstantiateRowset - error 0x%x, Unable to create icommand'\n", sc );
            return 0;
        }

        xCommand.Set( pCommand );
    }
    else
    {
        pCommand = pCommandIn;
    }

    if ( 0 == pCommand )
        return 0;

    if ( g_fSQL )
    {
        XInterface<ICommandText> xCommandText;
        SCODE sc = pCommand->QueryInterface( IID_ICommandText,
                                             xCommandText.GetQIPointer() );
        if ( FAILED( sc ) )
        {
            LogError( "InstantiateRowset error %#x, can't qi ICommandText\n", sc );
            return 0;
        }

        WCHAR awc[ 300 ];
        swprintf( awc,
                  L"SELECT %ws FROM %ws..SCOPE('\"%ws\"') WHERE CONTAINS('%ws')",
                  L"Filename, Size, Write, Path, Rank",
                  //g_awcMachine,
                  g_awcCatalog,
                  pwszScope,
                  pwcQuery );

        sc = xCommandText->SetCommandText( DBGUID_SQL, awc );
        if ( FAILED( sc ) )
        {
            LogError( "InstantiateRowset error %#x, can't set text\n", sc );
            return 0;
        }

#if 1
        XInterface<ICommandProperties> xCommandProperties;
        sc = xCommandText->QueryInterface( IID_ICommandProperties,
                                           xCommandProperties.GetQIPointer() );
        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x, can't qi commandprops\n", sc );
            return 0;
        }

        // set the machine name

        DBPROPSET PropSet;
        DBPROP    Prop;

        const GUID guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

        PropSet.rgProperties    = &Prop;
        PropSet.cProperties     = 1;
        PropSet.guidPropertySet = guidQueryCorePropset;
        
        Prop.dwPropertyID       = DBPROP_MACHINE;
        Prop.colid              = DB_NULLID;
        Prop.vValue.vt          = VT_BSTR;
        Prop.vValue.bstrVal     = SysAllocString( g_awcMachine );

        if ( 0 == Prop.vValue.bstrVal )
        {
            LogError( "InstantiateRowset error %#x, can't allocate sql machine\n", sc );
            return 0;
        }

        sc = xCommandProperties->SetProperties ( 1, &PropSet );
        
        VariantClear( &Prop.vValue );

        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x can't set sql machine\n", sc );
            return 0;
        }
#endif

        XInterface<ICommandPrepare> xCommandPrepare;
        sc = xCommandText->QueryInterface( IID_ICommandPrepare,
                                           xCommandPrepare.GetQIPointer() );
        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x, can't qi prepare\n", sc );
            return 0;
        }

        sc = xCommandPrepare->Prepare( 1 );
        if ( FAILED (sc) )
        {
            LogError( "InstantiateRowset error %#x, can't prepare\n", sc );
            return 0;
        }
    }
    else
    {
        XInterface<ICommandTree> xCmdTree;
        HRESULT sc = pCommand->QueryInterface( IID_ICommandTree,
                                               xCmdTree.GetQIPointer() );
        if (FAILED (sc) )
        {
            LogError( "QI for ICommandTree failed %#x\n", sc );
            return 0;
        }
    
        DBCOMMANDTREE * pRoot = xTree->CastToStruct();
    
        sc = xCmdTree->SetCommandTree( &pRoot, DBCOMMANDREUSE_NONE, FALSE);
        if (FAILED (sc) )
        {
            LogError("SetCommandTree failed, %08x\n", sc);
            return 0;
        }
    
        xTree.Acquire();
    }

    #ifdef GET_DATA_TOO
    {
        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // We can handle PROPVARIANTs

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;

        cProps++;

        XInterface<ICommandProperties> xCmdProp;
        SCODE sc = pCommand->QueryInterface( IID_ICommandProperties,
                                             xCmdProp.GetQIPointer() );
        if (FAILED (sc) )
        {
            LogError( "can't qi to commandprops\n", sc );
            return 0;
        }

        sc = xCmdProp->SetProperties( cProps, aPropSet );

        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
        {
            LogError( "can't set commandprops: 0x%lx\n", sc );
            return 0;
        }
    }
    #endif // GET_DATA_TOO

#ifdef STRESS
    {
        const unsigned MAX_PROPS = 1;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // Mark the icommand as synch or asynch.  Note that we always have
        // to set it since we may have an old ICommand that previously had
        // a different state set.

        aProp[cProps].dwPropertyID = DBPROP_IDBAsynchStatus;
        aProp[cProps].dwOptions = DBPROPOPTIONS_REQUIRED;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = fAsynchronous ? VARIANT_TRUE : VARIANT_FALSE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        XInterface<ICommandProperties> xCmdProp;
        SCODE sc = pCommand->QueryInterface( IID_ICommandProperties,
                                             xCmdProp.GetQIPointer() );
        if (FAILED (sc) )
        {
            LogError( "can't qi to commandprops\n", sc );
            return 0;
        }

        sc = xCmdProp->SetProperties( cProps, aPropSet );

        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
        {
            LogError( "can't set commandprops: 0x%lx\n", sc );
            return 0;
        }
    }
#endif

    XInterface<IRowsetScroll> xRowset;
    SCODE sc = pCommand->Execute( 0,                    // no aggr. IUnknown
                                  riid,                 // IID for i/f to return
                                  0,                    // disp. params
                                  0,                    // chapter
                                  (IUnknown **) xRowset.GetPPointer() );

    if ( FAILED (sc) )
    {
        LogError("ICommand::Execute failed, %08x\n", sc);
        if ( !xRowset.IsNull() )
            LogError( "pRowset is 0x%x when it should be 0\n", xRowset.GetPointer() );
    }

    if ( SUCCEEDED( sc ) && fAsynchronous )
    {
        sc = WaitForQueryCompletion( xRowset.GetPointer() );

        if ( FAILED( sc ) )
            xRowset.Free();
    }

    return xRowset.Acquire();
} //InstantiateRowset

//+-------------------------------------------------------------------------
//
//  Function:   MapColumns, public
//
//  Synopsis:   Map column IDs in column bindings.  Create an accessor
//              for the binding array.
//
//  Arguments:  [pUnknown]  -- Interface capable of returning IColumnsInfo and
//                             IAccessor
//              [cCols]     -- number of columns in arrays
//              [pBindings] -- column data binding array
//              [pDbCols]   -- column IDs array
//
//  Returns:    HACCESSOR - a read accessor for the column bindings.
//
//  History:    18 May 1995     AlanW     Created
//
//--------------------------------------------------------------------------

static DBORDINAL aMappedColumnIDs[20];

HACCESSOR MapColumns(
    IUnknown *   pUnknown,
    ULONG        cCols,
    DBBINDING *  pBindings,
    const DBID * pDbCols )
{
    XInterface<IColumnsInfo> xColumnsInfo;
    SCODE sc = pUnknown->QueryInterface( IID_IColumnsInfo,
                                         xColumnsInfo.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "IUnknown::QueryInterface for IColumnsInfo returned 0x%lx\n", sc );
        return 0;
    }

    sc = xColumnsInfo->MapColumnIDs(cCols, pDbCols, aMappedColumnIDs);

    if (S_OK != sc)
    {
        LogError( "IColumnsInfo->MapColumnIDs returned 0x%lx\n",sc);
        return 0;
    }

    for (ULONG i = 0; i < cCols; i++)
        pBindings[i].iOrdinal = aMappedColumnIDs[i];

    XInterface<IAccessor> xAccessor;
    sc = pUnknown->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "IRowset::QueryInterface for IAccessor returned 0x%lx\n", sc );
        return 0;
    }

    HACCESSOR hAcc = 0;
    sc = xAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                    cCols, pBindings, 0, &hAcc, 0 );

    if (S_OK != sc)
        LogError( "IAccessor->CreateAccessor returned 0x%lx\n",sc);

    return hAcc;
} //MapColumns

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseAccessor, public
//
//  Synopsis:   Release an accessor obtained from MapColumns
//
//  Arguments:  [pUnknown]  -- Something that we can QI the IAccessor on
//              [hAcc]      -- Accessor handle to be released.
//
//  Returns:    nothing
//
//  History:    14 June 1995     AlanW     Created
//
//--------------------------------------------------------------------------

void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc )
{
    XInterface<IAccessor> xAccessor;
    SCODE sc = pUnknown->QueryInterface( IID_IAccessor, xAccessor.GetQIPointer() );
    if ( FAILED( sc ) )
    {
        LogError( "IUnknown::QueryInterface for IAccessor returned 0x%lx\n", sc );
        return;
    }

    sc = xAccessor->ReleaseAccessor( hAcc, 0 );

    if (S_OK != sc)
        LogError( "IAccessor->ReleaseAccessor returned 0x%lx\n",sc);
} //ReleaseAccessor

//+-------------------------------------------------------------------------
//
//  Function:   LogError, public
//
//  Synopsis:   Prints a verbose-mode message.
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    13-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

void LogError( char const * pszfmt, ... )
{
    va_list pargs;
    va_start(pargs, pszfmt);
    vprintf( pszfmt, pargs );
    va_end(pargs);
    _flushall();
} //LogError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\slickdll\h\rc.h ===
#define FILE_NOT_FOUND_RC  -2
#define PATH_NOT_FOUND_RC  -3
#define TOO_MANY_OPEN_FILES_RC  -4
#define ACCESS_DENIED_RC  -5
#define MEMORY_CONTROL_BLOCKS_RC  -7
#define INSUFFICIENT_MEMORY_RC  -8
#define INVALID_DRIVE_RC  -15
#define NO_MORE_FILES_RC  -18
#define DISK_IS_WRITE_PROTECTED_RC  -19
#define UNKNOWN_UNIT_RC  -20
#define DRIVE_NOT_READY_RC  -21
#define BAD_DEVICE_COMMAND_RC  -22
#define DATA_ERROR_RC  -23
#define BAD_REQUEST_STRUCTURE_LENGTH_RC  -24
#define SEEK_ERROR_RC  -25
#define UNKNOWN_MEDIA_TYPE_RC  -26
#define SECTOR_NOT_FOUND_RC  -27
#define PRINTER_OUT_OF_PAPER_RC  -28
#define WRITE_FAULT_RC  -29
#define READ_FAULT_RC  -30
#define GENERAL_FAILURE_RC  -31
#define ERROR_OPENING_FILE_RC  -32
#define ERROR_READING_FILE_RC  -33
#define ERROR_WRITING_FILE_RC  -34
#define ERROR_CLOSING_FILE_RC  -35
#define INSUFFICIENT_DISK_SPACE_RC  -36
#define PROGRAM_CAN_NOT_BE_RUN_IN_OS2_RC  -37
#define ERROR_CREATING_DIRECTORY_RC  -38
#define SESSION_PARENT_EXISTS_RC  -39
#define UNABLE_TO_OPEN_KDF_RC  -500

#define UNABLE_TO_READ_KDF_RC  -502

#define INCORECT_KDF_VERSION_RC  -504

#define ERROR_OPENING_KEYBOARD_RC  -506

#define UNABLE_TO_OPEN_TTY_DEV_RC  -508
#define SLICK_EDITOR_VERSION_RC  -2000
#define SPILL_FILE_TOO_LARGE_RC  -2001
#define ON_RC  -2002
#define OFF_RC  -2003
#define EXPECTING_IGNORE_OR_EXACT_RC  -2004
#define ERROR_IN_MARGIN_SETTINGS_RC  -2005
#define ERROR_IN_TAB_SETTINGS_RC  -2006
#define UNKNOWN_COMMAND_RC  -2007
#define MISSING_FILENAME_RC  -2008
#define TOO_MANY_FILES_RC  -2009
#define TOO_MANY_SELECTIONS_RC  -2010
#define LINES_TRUNCATED_RC  -2011
#define TEXT_ALREADY_SELECTED_RC  -2012
#define TEXT_NOT_SELECTED_RC  -2013
#define INVALID_SELECTION_TYPE_RC  -2014
#define SOURCE_DEST_CONFLICT_RC  -2015
#define NEW_FILE_RC  -2016
#define LINE_SELECTION_REQUIRED_RC  -2017
#define BLOCK_SELECTION_REQUIRED_RC  -2018
#define TOO_MANY_GROUPS_RC  -2019
#define MACRO_FILE_NOT_FOUND_RC  -2020

#define HIT_ANY_KEY_RC  -2023
#define BOTTOM_OF_FILE_RC  -2024
#define TOP_OF_FILE_RC  -2025
#define INVALID_POINT_RC  -2026
#define TYPE_ANY_KEY_RC  -2027
#define TOO_MANY_WINDOWS_RC  -2028
#define NOT_ENOUGH_MEMORY_RC  -2029
#define PRESS_ANY_KEY_TO_CONTINUE_RC  -2030
#define SPILL_FILE_IO_ERROR_RC  -2031
#define TYPE_NEW_DRIVE_LETTER_RC  -2032
#define NOTHING_TO_UNDO_RC  -2033
#define NOTHING_TO_REDO_RC  -2034
#define LINE_OR_BLOCK_SELECTION_REQUIRED_RC  -2035
#define INVALID_SELECTION_HANDLE_RC  -2036
#define SEARCHING_AND_REPLACING_RC  -2037
#define COMMAND_CANCELLED_RC  -2038
#define ERROR_CREATING_SEMAPHORE_RC  -2039
#define ERROR_CREATING_THREAD_RC  -2040
#define ERROR_CREATING_QUEUE_RC  -2041
#define PROCESS_ALREADY_RUNNING_RC  -2042
#define CANT_FIND_INIT_PROGRAM_RC  -2043
#define CMDLINE_TOO_LONG_RC  -2044
#define SERIAL_NUMBER_RC  -2045
#define FAILED_TO_BACKUP_FILE_RC  -2101
#define FAILED_TO_BACKUP_FILE_ACCESS_DENIED_RC  -2105
#define FAILED_TO_BACKUP_FILE_INSUFFICIENT_DISK_SPACE_RC -2111
#define INVALID_REGULAR_EXPRESSION_RC  -2500
#define INCORRECT_VERSION_RC  -3000
#define NO_MAIN_ENTRY_POINT_RC  -3001
#define INTERPRETER_OUT_OF_MEMORY_RC  -3002
#define PROCEDURE_NOT_FOUND_RC  -3003

#define MODULE_ALREADY_LOADED_RC  -3006
#define CANT_REMOVE_MODULE_RC  -3007
#define NUMERIC_OVERFLOW_RC  -3008
#define INVALID_NUMBER_ARGUMENT_RC  -3009
#define RECURSION_TOO_DEEP_RC  -3010
#define INVALID_NUMBER_OF_PARAMETERS_RC  -3011
#define OUT_OF_STRING_SPACE_RC  -3012
#define EXPRESSION_STACK_OVERFLOW_RC  -3013
#define ILLEGAL_OPCODE_RC  -3014
#define INVALID_ARGUMENT_RC  -3015
#define LOOP_STACK_OVERFLOW_RC  -3016
#define DIVIDE_BY_ZERO_RC  -3017
#define INVALID_CALL_BY_REFERENCE_RC  -3018
#define PROCEDURE_NEEDS_MORE_ARGS_RC  -3019
#define BREAK_KEY_PRESSED_RC  -3020
#define CANT_WRITE_STATE_DURING_REL_RC  -3021
#define STRING_NOT_FOUND_RC  -3022
/* KBD_MACRO_TOO_LONG_RC = -3023  Can't get this any more. */
#define COMMAND_NOT_FOUND_RC  -3024

#define FUNCTION_NOT_SUPPORTED_IN_DOS_RC  -3027
#define FUNCTION_NOT_SUPPORTED_IN_OS2_RC  -3028
#define INVALID_NAME_INDEX_RC  -3029
#define INVALID_OPTION_RC  -3030


#define SPELL_FILE_NOT_FOUND_RC       -3501
#define SPELL_ERROR_OPENING_MAIN_DICT_FILE_RC         -3504
#define SPELL_ERROR_OPENING_USER_DICT_FILE_RC         -3507
#define SPELL_NOT_ENOUGH_MEMORY_RC    -3510
#define SPELL_ERROR_READING_MAIN_INDEX_RC     -3511
#define SPELL_ERROR_OPENING_COMMON_DICT_RC    -3514
#define SPELL_COMMON_DICT_TOO_LARGE_RC        -3517
#define SPELL_ERROR_READING_COMMON_DICT_RC    -3518
#define SPELL_USER_DICT_TOO_LARGE_RC  -3521
#define SPELL_ERROR_READING_USER_DICT_RC      -3524
#define SPELL_ERROR_UPDATING_USER_DICT_FILE_RC        -3527
#define SPELL_ACCESS_DENIED_RC        -3530
#define SPELL_OUT_OF_DISK_SPACE_RC    -3533
#define SPELL_ERROR_READING_MAIN_DICT_RC      -3536
#define SPELL_WORD_NOT_FOUND_RC      -3537
#define SPELL_CAPITALIZATION_RC      -3538
#define SPELL_WORD_TOO_SMALL_RC      -3539
#define SPELL_WORD_TOO_LARGE_RC      -3540
#define SPELL_WORD_INVALID_RC        -3541
#define SPELL_REPLACE_WORD_RC        -3542
#define SPELL_HISTORY_TOO_LARGE_RC   -3543
#define SPELL_USER_DICT_NOT_LOADED_RC        -3544
#define SPELL_NO_MORE_WORDS_RC       -3545
#define SPELL_REPEATED_WORD_RC       -3546

#define CLEX_NOT_ENOUGH_MEMORY_RC     -3547
#define CLEX_TOO_MANY_MLCOMMENTS_DEFINED_RC   -3548
#define CLEX_IDENTIFIER_MLCOMMENTS_NOT_SUPPORTED_RC -3549
#define CLEX_TOO_MANY_CFLINECOMMENTS_DEFINED_RC -3550
#define CLEX_IDCHARS_MUST_BE_DEFINED_FIRST_RC -3551
#define CLEX_INVALID_STYLE_RC       -3552
#define CLEX_INVALID_MLCOMMENT_RC   -3553
#define CLEX_INVALID_LINECOMMENT_RC -3554
#define CLEX_INVALID_NAME_RC        -3555
#define CLEX_FILE_NOT_FOUND_RC      -3556
#define CLEX_ACCESS_DENIED_RC       -3557
#define CLEX_UNABLE_TO_OPEN_FILE_RC -3558


#define BT_KEY_ALREADY_EXISTS_RC	-3900
#define BT_RECORD_NOT_FOUND_RC	-3901
#define BT_UNABLE_TO_RW_FILE_RC	-3902
#define BT_DATABASE_CORRUPT_RC	-3903
#define BT_RECORD_LENGTH_TOO_LARGE_RC	-3904
#define BT_INCORRECT_VERSION_RC	-3905
#define BT_INCORRECT_MAGIC_RC	-3906
#define BT_TOO_MANY_KEYS_RC	-3907
#define BT_FEATURE_NOT_FINISHED_RC	-3908
#define BT_FIELD_IS_FIXED_LENGTH_RC	-3909
#define BT_FIELD_IS_VARIABLE_LENGTH_RC	-3910
#define BT_BLOCK_FULL_RC	-3911
#define BT_UNABLE_TO_DELETE_RC	-3912
#define BT_INVALID_BLOCK_SIZE_RC	-3913
#define BT_MISSING_REQUIRED_FIELD_RC	-3914
#define BT_ERROR_UPDATING_INDEX_RC	-3915
#define BT_ERROR_CREATING_TABLE_RC	-3916
#define BT_ERROR_CREATING_INDEX_RC	-3917
#define BT_ERROR_OPENING_TABLE_RC	-3918
#define BT_ERROR_OPENING_INDEX_RC	-3919
#define BT_FEATURE_NOT_ALLOWED_RC	-3920
#define BT_TABLE_NOT_FOUND_RC	-3921
#define BT_KEY_NOT_FOUND_RC	-3922
#define BT_FIELD_NOT_FOUND_RC	-3923
#define BT_INDEX_NOT_FOUND_RC	-3924
#define BT_INTERNAL_ERROR_RC	-3925
#define BT_FIELD_NOT_SEARCHABLE_RC	-3926
#define BT_FIELD_ALREADY_EXISTS_RC	-3927
#define BT_INDEX_ALREADY_EXISTS_RC	-3928
#define BT_TABLE_ALREADY_EXISTS_RC	-3929
#define BT_FIELD_NAME_REQUIRED_RC	-3930
#define BT_INDEX_NAME_REQUIRED_RC	-3931
#define BT_TABLE_NAME_REQUIRED_RC	-3932
#define BT_DATABASE_NAME_REQUIRED_RC	-3933
#define BT_FIELD_INVALID_RC	-3934
#define BT_INVALID_DB_HANDLE_RC	-3935
#define BT_INVALID_TAG_TYPE_RC	-3936
#define BT_INVALID_TABLE_HANDLE_RC	-3937
#define BT_INVALID_INDEX_HANDLE_RC	-3938
#define BT_INVALID_SEEKPOS_RC	-3939
#define BT_DATABASE_IS_FOR_UNIX_RC	-3940
#define BT_DATABASE_IS_FOR_DOS_RC	-3941
#define BT_DATABASE_IS_READ_ONLY_RC	-3942
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\slickdll\slickdll.cpp ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1997, Microsoft Corporation.
//
// File:        SlickDLL.cpp
//
// Contents:    Visual Slick 3.0 extension to call Index Server
//
// History:     15-Oct-97       KyleP       Created
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

// VSAPI includes windows.h.  The define keeps windowsx.h out.
#define _INC_WINDOWSX 1
#include <vsapi.h>

// #define OLEDBVER 0x0250 // enable ICommandTree interface
#define DBINITCONSTANTS

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <oledbdep.h>
#include <ntquery.h>
#include <cierror.h>

// This is the *only* thing needed from nt.h by the command tree helpers.
typedef LONG NTSTATUS;

#include <dbcmdtre.hxx>

#define Win4Assert(x)
#include <tgrow.hxx>

//
// Local prototypes and structures
//

HRESULT SetCommandProperties( ICommand * pICommand );
HRESULT SetScope( ICommand * pICommand, WCHAR const * pwcQueryScope );
void ErrorMessagePopup( SCODE sc );

struct SResultItem
{
    LONGLONG llSize;
    FILETIME ftWrite;
    ULONG    ulAttrib;
    WCHAR *  pwcsPath;
};

//
// Local constants
//

CIPROPERTYDEF aProperties[] = { { L"FUNC",
                                  DBTYPE_WSTR | DBTYPE_BYREF,
                                  { { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
                                    DBKIND_GUID_NAME,
                                    L"func"
                                  }
                                },
                                { L"CLASS",
                                  DBTYPE_WSTR | DBTYPE_BYREF,
                                  { { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
                                    DBKIND_GUID_NAME,
                                    L"class"
                                  }
                                }
                              };

//
// Static command tree (sans select node) to fetch required columns and sort by Rank.
//
// NOTE: There are some funny casts below, because of the requirement to
//       statically initialize a union.
//

const DBID dbcolSize   = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                           DBKIND_GUID_PROPID,
                           (LPWSTR)12 };

const DBID dbcolWrite  = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                          DBKIND_GUID_PROPID,
                          (LPWSTR)14 };

const DBID dbcolAttrib = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                           DBKIND_GUID_PROPID,
                           (LPWSTR)13 };

const DBID dbcolPath   = { { 0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac },
                           DBKIND_GUID_PROPID,
                           (LPWSTR)11 };

const DBID dbcolRank   = { { 0x49691c90, 0x7e17, 0x101a, 0xa9, 0x1c, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
                           DBKIND_GUID_PROPID,
                           (LPWSTR)3 };

//
// Columns
//

DBCOMMANDTREE dbcmdColumnSize   = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolSize, S_OK };
DBCOMMANDTREE dbcmdColumnWrite  = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolWrite, S_OK };
DBCOMMANDTREE dbcmdColumnAttrib = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolAttrib, S_OK };
DBCOMMANDTREE dbcmdColumnPath   = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolPath, S_OK };
DBCOMMANDTREE dbcmdColumnRank   = { DBOP_column_name, DBVALUEKIND_ID, 0, 0, (ULONG_PTR)&dbcolRank, S_OK };

//
// Forward declare a few nodes to make linking easy
//

extern DBCOMMANDTREE dbcmdSortListAnchor;
extern DBCOMMANDTREE dbcmdProjectListAnchor;

//
// The Select node.  The actual Select expression will be plugged in to the dbcmdTable node.
//

WCHAR wszTable[] = L"Table";

DBCOMMANDTREE dbcmdTable = { DBOP_table_name,
                             DBVALUEKIND_WSTR,
                             0,
                             0, // CITextToSelectTree goes here...
                             (ULONG_PTR)&wszTable[0],
                             S_OK };

DBCOMMANDTREE dbcmdSelect = { DBOP_select,
                              DBVALUEKIND_EMPTY,
                              &dbcmdTable,
                              &dbcmdProjectListAnchor,
                              0,
                              S_OK };

//
// Project (Path, GUID, ...)
//
// NOTE: The order here defines the ordinals of columns.
//

DBCOMMANDTREE dbcmdProjectPath = { DBOP_project_list_element,
                                   DBVALUEKIND_EMPTY,
                                   &dbcmdColumnPath,
                                   0,
                                   0,
                                   S_OK };

DBCOMMANDTREE dbcmdProjectAttrib = { DBOP_project_list_element,
                                     DBVALUEKIND_EMPTY,
                                     &dbcmdColumnAttrib,
                                     &dbcmdProjectPath,
                                     0,
                                     S_OK };

DBCOMMANDTREE dbcmdProjectWrite = { DBOP_project_list_element,
                                    DBVALUEKIND_EMPTY,
                                    &dbcmdColumnWrite,
                                    &dbcmdProjectAttrib,
                                    0,
                                    S_OK };

DBCOMMANDTREE dbcmdProjectSize = { DBOP_project_list_element,
                                   DBVALUEKIND_EMPTY,
                                   &dbcmdColumnSize,
                                   &dbcmdProjectWrite,
                                   0,
                                   S_OK };

DBCOMMANDTREE dbcmdProjectListAnchor = { DBOP_project_list_anchor,
                                         DBVALUEKIND_EMPTY,
                                         &dbcmdProjectSize,
                                         0,
                                         0,
                                         S_OK };

DBCOMMANDTREE dbcmdProject = { DBOP_project,
                               DBVALUEKIND_EMPTY,
                               &dbcmdSelect,
                               &dbcmdSortListAnchor,
                               0,
                               S_OK };

//
// Sort (Descending by Rank)
//

DBSORTINFO dbsortDescending = { TRUE, LOCALE_NEUTRAL };

DBCOMMANDTREE dbcmdSortByRank = { DBOP_sort_list_element,
                                  DBVALUEKIND_SORTINFO,
                                  &dbcmdColumnRank,
                                  0,
                                  (ULONG_PTR)&dbsortDescending,
                                  S_OK };

DBCOMMANDTREE dbcmdSortListAnchor = { DBOP_sort_list_anchor,
                                      DBVALUEKIND_EMPTY,
                                      &dbcmdSortByRank,
                                      0,
                                      0,
                                      S_OK };

DBCOMMANDTREE dbcmdSort =    { DBOP_sort,
                               DBVALUEKIND_EMPTY,
                               &dbcmdProject,
                               0,
                               0,
                               S_OK };

//
// Bindings
//

DBBINDING aColumns[] = { { 1,                             // Column 1 -- Size
                           offsetof(SResultItem,llSize),  // obValue
                           0,                             // obLength
                           0,                             // obStatus
                           0,                             // pTypeInfo
                           0,                             // pObject
                           0,                             // pBindExt
                           DBPART_VALUE,                  // retrieve only value
                           0,                             // dwMemOwner
                           0,                             // eParamIO
                           0,                             // cbMaxLen doesn't apply to fixed types
                           0,                             // dwFlags
                           DBTYPE_I8,                     // dwType
                           0,                             // dwPrecision
                           0                              // dwScale
                         },
                         { 2,                             // Column 2 -- Write time
                           offsetof(SResultItem,ftWrite), // obValue
                           0,                             // obLength
                           0,                             // obStatus
                           0,                             // pTypeInfo
                           0,                             // pObject
                           0,                             // pBindExt
                           DBPART_VALUE,                  // retrieve only value
                           0,                             // dwMemOwner
                           0,                             // eParamIO
                           0,                             // cbMaxLen doesn't apply to fixed types
                           0,                             // dwFlags
                           VT_FILETIME,                   // dwType
                           0,                             // dwPrecision
                           0                              // dwScale
                         },
                         { 3,                             // Column 3 -- Attributes
                           offsetof(SResultItem,ulAttrib),// obValue
                           0,                             // obLength
                           0,                             // obStatus
                           0,                             // pTypeInfo
                           0,                             // pObject
                           0,                             // pBindExt
                           DBPART_VALUE,                  // retrieve only value
                           0,                             // dwMemOwner
                           0,                             // eParamIO
                           0,                             // cbMaxLen doesn't apply to fixed types
                           0,                             // dwFlags
                           VT_UI4,                        // dwType
                           0,                             // dwPrecision
                           0                              // dwScale
                         },
                         { 4,                             // Column 4 -- Path
                           offsetof(SResultItem,pwcsPath), // obValue
                           0,                             // obLength
                           0,                             // obStatus
                           0,                             // pTypeInfo
                           0,                             // pObject
                           0,                             // pBindExt
                           DBPART_VALUE,                  // retrieve only value
                           DBMEMOWNER_PROVIDEROWNED,      // Index Server owned
                           0,                             // eParamIO
                           0,                             // cbMaxLen doesn't apply to fixed types
                           0,                             // dwFlags
                           DBTYPE_WSTR|DBTYPE_BYREF,      // dwType
                           0,                             // dwPrecision
                           0                              // dwScale
                         }
                       };

//
// C++ Helpers
//

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

extern "C" {

//+---------------------------------------------------------------------------
//
//  Function:   vsDllInit, public
//
//  Synopsis:   Always called by VSlick
//
//  History:    15-Oct-97   KyleP       Stole from VSlick sample (simple.c)
//
//  Notes:      Called from VSlick's dllmain.obj
//
//----------------------------------------------------------------------------

void VSAPI vsDllInit()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   vsDllRegisterExports, public
//
//  Synopsis:   Called by VSlick to register new commands
//
//  History:    15-Oct-97   KyleP       Stole from VSlick sample (simple.c)
//
//----------------------------------------------------------------------------

void VSAPI vsDllRegisterExports()
{
    //
    // This call says CISearch takes two parameters. The first is a filename
    // and the second is just a string.  The *_ARG2 mean the command can
    // be called from many different places in VSlick.
    //

    vsDllExport( "_command void CISearch(VSPSZ,VSPSZ)",
                 VSFILE_ARG,
                 VSNCW_ARG2|VSICON_ARG2|VSCMDLINE_ARG2|VSREAD_ONLY_ARG2 );
}

//+---------------------------------------------------------------------------
//
//  Function:   vsDllExit, public
//
//  Synopsis:   Always called by VSlick
//
//  History:    15-Oct-97   KyleP       Stole from VSlick sample (simple.c)
//
//  Notes:      Called from VSlick's dllmain.obj
//
//----------------------------------------------------------------------------

void VSAPI vsDllExit()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   CISearch, public
//
//  Synopsis:   Execute an Index Server search
//
//  Arguments:  [pszScope] -- Scope to search.  Also used to locate catalog.
//              [pszQuery] -- Query, in Tripolish
//
//  History:    15-Oct-97   KyleP       Created
//
//----------------------------------------------------------------------------

void VSAPI CISearch(VSPSZ pszScope, VSPSZ pszQuery)
{
    long status;

    // Current object/window is mdi child
    status=vsExecute(0,"edit .SearchResults","");
    if ( status && status!=NEW_FILE_RC )
    {
        MessageBox(HWND_DESKTOP,
                   L"VSNTQ: Error loading file",
                   L"DLL Error",
                   0);
        return;
    }

    if ( status==NEW_FILE_RC )
        // Delete the blank line in the new file created
        vsDeleteLine(0);
    else
        vsExecute( 0, "bottom_of_buffer", "" );

    vsExecute( 0, "fileman-mode", "" );

    //
    // Convert arguments to WCHAR
    //

    unsigned ccQuery = strlen( pszQuery );
    XGrowable<WCHAR> xwcsQuery( ccQuery + ccQuery/2 + 1 );
    mbstowcs( xwcsQuery.Get(), pszQuery, xwcsQuery.Count() );

    unsigned ccScope = strlen( pszScope );
    XGrowable<WCHAR> xwcsScope( ccScope + ccScope/2 + 1 );
    mbstowcs( xwcsScope.Get(), pszScope, xwcsScope.Count() );

    //
    // Find catalog
    //

    XGrowable<WCHAR> xwcsMachine;
    ULONG ccMachine = xwcsMachine.Count();
    XGrowable<WCHAR> xwcsCat;
    ULONG ccCat = xwcsCat.Count();

    SCODE sc = LocateCatalogs( xwcsScope.Get(),   // Scope
                               0,                 // Bookmark
                               xwcsMachine.Get(), // Machine
                               &ccMachine,        //  Size
                               xwcsCat.Get(),     // Catalog
                               &ccCat );          //  Size

    if ( S_OK == sc )
    {
        //
        // Execute query
        //

        SCODE hr = S_OK;

        do
        {
            //
            // Create an ICommand object.  The default scope for the query is the
            // entire catalog.  CICreateCommand is a shortcut for making an
            // ICommand.  The ADVQUERY sample shows the OLE DB equivalent.
            //

            XInterface<ICommand> xICommand;
            hr = CICreateCommand( xICommand.GetIUPointer(), // result
                                  0,                        // controlling unknown
                                  IID_ICommand,             // IID requested
                                  xwcsCat.Get(),            // catalog name
                                  xwcsMachine.Get() );      // machine name

            if ( FAILED( hr ) )
                break;

            // Set required properties on the ICommand

            hr = SetCommandProperties( xICommand.GetPointer() );

            if ( FAILED( hr ) )
                break;

            hr = SetScope( xICommand.GetPointer(), xwcsScope.Get() );

            if ( FAILED( hr ) )
                break;

            //
            // Create an OLE DB query tree from a text restriction, column
            // set, and sort order.
            //

            DBCOMMANDTREE * pTree;
            hr = CITextToSelectTree( xwcsQuery.Get(),           // the query itself
                                     &pTree,                    // resulting tree
                                     sizeof(aProperties)/sizeof(aProperties[0]), // custom properties
                                     aProperties,               // custom properties
                                     0 );                       // neutral locale

            if ( QPLIST_E_DUPLICATE == hr )
                hr = CITextToSelectTree( xwcsQuery.Get(),       // the query itself
                                         &pTree,                // resulting tree
                                         0,                     // custom properties
                                         0,                     // custom properties
                                         0 );                   // neutral locale

            if ( FAILED( hr ) )
                break;  // Worth a special message?

            //
            // Set the Select node.
            //
            // Since this code uses a global command tree it is not
            // thread-safe.  I don't think this is a problem for VSlick.
            //

            dbcmdTable.pctNextSibling = pTree;
            pTree = &dbcmdSort;

            // Set the tree in the ICommandTree

            XInterface<ICommandTree> xICommandTree;
            hr = xICommand->QueryInterface( IID_ICommandTree,
                                            xICommandTree.GetQIPointer() );
            if ( FAILED( hr ) )
                break;

            hr = xICommandTree->SetCommandTree( &pTree,
                                                DBCOMMANDREUSE_NONE,
                                                TRUE );
            if ( FAILED( hr ) )
                break;

            // Execute the query.  The query is complete when Execute() returns

            XInterface<IRowset> xIRowset;
            hr = xICommand->Execute( 0,            // no aggregating IUnknown
                                     IID_IRowset,  // IID for interface to return
                                     0,            // no DBPARAMs
                                     0,            // no rows affected
                                     xIRowset.GetIUPointer() ); // result
            if ( FAILED( hr ) )
                break;  // Worth a special message?

            // Create an accessor, so data can be retrieved from the rowset

            XInterface<IAccessor> xIAccessor;
            hr = xIRowset->QueryInterface( IID_IAccessor,
                                           xIAccessor.GetQIPointer() );
            if ( FAILED( hr ) )
                break;

            //
            // Column iOrdinals are parallel with those passed to CiTextToFullTree,
            // so MapColumnIDs isn't necessary.  These binding values for dwPart,
            // dwMemOwner, and wType are the most optimal bindings for Index Server.
            //

            HACCESSOR hAccessor;
            hr = xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor
                                             sizeof(aColumns)/sizeof(aColumns[0]), // # of columns
                                             aColumns,           // columns
                                             0,                  // ignored
                                             &hAccessor,         // result
                                             0 );                // no status
            if ( FAILED( hr ) )
                break;

            //
            // Display the results of the query.  Print in 'fileman mode' format.
            //

            static char const szQueryCaption[] = "Query: ";

            XGrowable<char> xszLine1( ccQuery + sizeof(szQueryCaption) );

            strcpy( xszLine1.Get(), szQueryCaption );
            strcat( xszLine1.Get(), pszQuery );

            vsInsertLine(0,"",-1);
            vsInsertLine(0,xszLine1.Get(),-1);
            vsInsertLine(0,"",-1);

            DBCOUNTITEM cRowsSoFar = 0;

            do
            {
                DBCOUNTITEM cRowsReturned = 0;
                const ULONG cRowsAtATime = 10;
                HROW aHRow[cRowsAtATime];
                HROW * pgrHRows = aHRow;
                hr = xIRowset->GetNextRows( 0,              // no chapter
                                            0,              // no rows to skip
                                            cRowsAtATime,   // # rows to get
                                            &cRowsReturned, // # rows returned
                                            &pgrHRows);     // resulting hrows

                if ( FAILED( hr ) )
                    break;

                for ( ULONG iRow = 0; iRow < cRowsReturned; iRow++ )
                {
                    SResultItem result;
                    hr = xIRowset->GetData( aHRow[iRow],  // hrow being accessed
                                            hAccessor,    // accessor to use
                                            &result );    // resulting data
                    if ( FAILED( hr ) )
                        break;

                    //
                    // Note: there is no Data type error checking.  But our
                    // schema here is fixed so it's safe.
                    //

                    unsigned ccPath = wcslen( result.pwcsPath );

                    XGrowable<char> xszResult( ccPath + ccPath/2 + 40 );

                    //
                    // Size (or <DIR>)
                    //

                    if ( result.ulAttrib & FILE_ATTRIBUTE_DIRECTORY )
                        strcpy( xszResult.Get(), "   <DIR>     " );
                    else
                        sprintf( xszResult.Get(), "%11I64u  ", result.llSize );

                    //
                    // Date and time
                    //

                    FILETIME ftLocal;
                    FileTimeToLocalFileTime( &result.ftWrite, &ftLocal );

                    SYSTEMTIME systime;
                    FileTimeToSystemTime( &ftLocal, &systime );

                    sprintf( xszResult.Get() + 13, "%2u-%02u-%4u  %2u:%02u%c ",
                             systime.wMonth, systime.wDay, systime.wYear,
                             systime.wHour % 12, systime.wMinute, (systime.wHour >= 12) ? 'p' : 'a' );

                    //
                    // Attributes
                    //

                    char szAttrib[] = "RSHDA  ";

                    szAttrib[0] = ( result.ulAttrib & FILE_ATTRIBUTE_READONLY ) ? 'R' : '-';
                    szAttrib[1] = ( result.ulAttrib & FILE_ATTRIBUTE_SYSTEM ) ? 'S' : '-';
                    szAttrib[2] = ( result.ulAttrib & FILE_ATTRIBUTE_HIDDEN ) ? 'H' : '-';
                    szAttrib[3] = ( result.ulAttrib & FILE_ATTRIBUTE_DIRECTORY ) ? 'D' : '-';
                    szAttrib[4] = ( result.ulAttrib & FILE_ATTRIBUTE_ARCHIVE ) ? 'A' : '-';

                    strcat( xszResult.Get(), szAttrib );

                    //
                    // Path
                    //

                    wcstombs( xszResult.Get() + 39, result.pwcsPath, ccPath + ccPath/2 );

                    //
                    // Write out to the VSlick buffer
                    //

                    vsInsertLine(0, xszResult.Get(), -1);
                }

                if ( 0 != cRowsReturned )
                    xIRowset->ReleaseRows( cRowsReturned, // # of rows to release
                                           aHRow,         // rows to release
                                           0,             // no options
                                           0,             // no refcounts
                                           0 );           // no status

                if ( DB_S_ENDOFROWSET == hr )
                {
                    hr = S_OK; // succeeded, return S_OK from DoQuery
                    break;
                }

                if ( FAILED( hr ) )
                    break;

                cRowsSoFar += cRowsReturned;
            } while ( TRUE );

            if ( FAILED(hr) )
                break;

            xIAccessor->ReleaseAccessor( hAccessor, 0 );

        } while ( FALSE );

        //
        // Clean up Select node.
        //

        if ( 0 != dbcmdTable.pctNextSibling )
        {
            CDbCmdTreeNode * pSelect = (CDbCmdTreeNode *)(ULONG_PTR)dbcmdTable.pctNextSibling;
            delete pSelect;
            dbcmdTable.pctNextSibling = 0;
        }

        if ( FAILED(hr) )
            ErrorMessagePopup( hr );
    }
    else
    {
        MessageBox( HWND_DESKTOP,
                    L"Unable to find catalog covering specified scope.",
                    L"Error",
                    MB_OK | MB_ICONERROR );
    }
}

}  // "C"

//
// Non-VSlick stuff
//

//+-------------------------------------------------------------------------
//
//  Function:   SetCommandProperties
//
//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so
//              data is returned in PROPVARIANTs, as opposed to the
//              default, which is OLE automation VARIANTs.  PROPVARIANTS
//              allow a superset of VARIANT data types.  Use of these
//              types avoids costly coercions.
//
//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so
//              the index will always be used to resolve the query (as
//              opposed to enumerating all the files on the disk), even
//              if the index is out of date.
//
//              Both of these properties are unique to Index Server's OLE DB
//              implementation.
//
//  Arguments:  [pICommand] - The ICommand used to set the property
//
//  Returns:    HRESULT result of setting the properties
//
//--------------------------------------------------------------------------

HRESULT SetCommandProperties( ICommand * pICommand )
{
    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                    DBKIND_GUID_PROPID, 0 };
    static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

    DBPROP aProp[2];

    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
    aProp[0].dwStatus = 0;
    aProp[0].colid = dbcolNull;
    aProp[0].vValue.vt = VT_BOOL;
    aProp[0].vValue.boolVal = VARIANT_TRUE;

    aProp[1] = aProp[0];
    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX;

    DBPROPSET aPropSet[1];

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = 2;
    aPropSet[0].guidPropertySet = guidQueryExt;

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    return xICommandProperties->SetProperties( 1,          // 1 property set
                                               aPropSet ); // the properties
} //SetCommandProperties


//+-------------------------------------------------------------------------
//
//  Function:   SetScope
//
//  Synopsis:   Sets the catalog and machine properties in the ICommand.
//              Also sets a default scope.
//
//  Arguments:  [pICommand]       - ICommand to set props on
//              [pwcQueryScope]   - Scope for the query
//
//  Returns:    HRESULT result of the operation
//
//--------------------------------------------------------------------------

HRESULT SetScope( ICommand * pICommand, WCHAR const * pwcQueryScope )
{
    // Get an ICommandProperties so we can set the properties

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // note: SysAllocString, SafeArrayCreate, and SafeArrayPutElement can
    // fail, but this isn't checked here for brevity.

    SAFEARRAYBOUND rgBound[1];
    rgBound[0].lLbound = 0;
    rgBound[0].cElements = 1;
    long i = 0;

    SAFEARRAY * pScopes = SafeArrayCreate( VT_BSTR, 1, rgBound );
    hr = SafeArrayPutElement( pScopes, &i, SysAllocString( pwcQueryScope ) );
    if ( FAILED( hr ) )
        return hr;

    LONG lFlags = QUERY_DEEP;
    SAFEARRAY * pFlags = SafeArrayCreate( VT_I4, 1, rgBound );
    hr = SafeArrayPutElement( pFlags, &i, &lFlags );
    if ( FAILED( hr ) )
        return hr;

    DBPROP aScopeProperties[2];
    memset( aScopeProperties, 0, sizeof aScopeProperties );
    aScopeProperties[0].dwPropertyID = DBPROP_CI_INCLUDE_SCOPES;
    aScopeProperties[0].vValue.vt = VT_BSTR | VT_ARRAY;
    aScopeProperties[0].vValue.parray = pScopes;

    aScopeProperties[1].dwPropertyID = DBPROP_CI_SCOPE_FLAGS;
    aScopeProperties[1].vValue.vt = VT_I4 | VT_ARRAY;
    aScopeProperties[1].vValue.parray = pFlags;

    const GUID guidFSCI = DBPROPSET_FSCIFRMWRK_EXT;
    DBPROPSET aAllPropsets[1];
    aAllPropsets[0].rgProperties = aScopeProperties;
    aAllPropsets[0].cProperties = 2;
    aAllPropsets[0].guidPropertySet = guidFSCI;

    const ULONG cPropertySets = sizeof aAllPropsets / sizeof aAllPropsets[0];

    hr = xICommandProperties->SetProperties( cPropertySets,  // # of propsets
                                             aAllPropsets ); // the propsets

    SafeArrayDestroy( pScopes );
    SafeArrayDestroy( pFlags );

    return hr;
} //SetScopeCatalogAndMachine


//+-------------------------------------------------------------------------
//
//  Function:   ErrorMessagePopup
//
//  Synopsis:   Popup error dialog.
//
//  Arguments:  [sc] -- Error code
//
//--------------------------------------------------------------------------

void ErrorMessagePopup( SCODE sc )
{
    WCHAR * pBuf = 0;

    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                         GetModuleHandle(L"query.dll"),
                         sc,
                         GetSystemDefaultLCID(),
                         (WCHAR *)&pBuf,
                         0,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                         GetModuleHandle(L"kernel32.dll"),
                         sc,
                         GetSystemDefaultLCID(),
                         (WCHAR *)&pBuf,
                         0,
                         0 ) )
    {
        XGrowable<WCHAR> xawcText(100);

        wsprintf( xawcText.Get(), L"Query error: 0x%x", sc );

        MessageBox( HWND_DESKTOP,
                    xawcText.Get(),
                    L"Error",
                    MB_OK | MB_ICONERROR );
    }
    else
    {
        MessageBox( HWND_DESKTOP,
                    pBuf,
                    L"Error",
                    MB_OK | MB_ICONERROR );

        LocalFree( pBuf );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\slickdll\h\vsapi.h ===
/*

   Example
      vsDllExport("_command void proc1(int i,VSPSZ i,VSHVAR x)",0,0);

   Syntax:

   [_command] [return-type] func-name([type [var-name] [,type [var-name]...])

   type
      VSPVOID        Pointer to something  Slick-C can't call this.
      VSPSZ          NULL terminated string
      VSPLSTR        See typedef below.
      int
      long
      VSHVAR           Handle to interpreter variable
      VSHREFVAR        Call by reference handle to interpreter variable.
                       This type can be used as input to functions which
                       accept VSHVAR parameters.

   return-type may be one of the following
      VSPSZ
      VSPLSTR
      int
      long
      void

   Performance considerations:

      For best performance, use the VSHVAR or VSREFVAR param-type when
      operating on long strings instead of VSPSZ or VSPLSTR.  Then
      use the "vsHvarGetLstr" function to return a pointer to the
      interpreter variable. WARNING:  Pointers to interpreter variables
      returned by the vsHvarGetLstr function are NOT VALID after any
      interpreter variable is set.  Be sure to reset any pointer after
      setting other interpreter variables or calling other macros.
      You may modify the contents of the VSPLSTR pointer returned by
      vsHvarGetLstr so long as you do not make the string any longer.

      We suspect that using the int and long parameter types are no
      slower than using the VSHVAR type and converting the parameter yourself.
*/
#ifndef VSAPI_H
#define VSAPI_H

#if  defined(OS2386APP)
   #define INCL_DEV
   #define INCL_WIN
   #define INCL_GPI
   #define INCL_GPILCIDS
   #define INCL_WINPOINTERS
   #define INCL_GPILOGCOLORTABLE
   #define INCL_WINSYS
   #define INCL_DOSPROCESS
   #define INCL_ERRORS
   #include <os2.h>

   #define VSAPI _System
   #define VSUNIX  0
   #define VSOS2   1
   #define VSNT    0
#elif defined(WIN32)
   #ifndef _WINDOWS_
      #include <windows.h>
      #include <windowsx.h>
   #endif
   #define VSAPI  __stdcall
   #define VSUNIX  0
   #define VSOS2   0
   #define VSNT    1
#else
   #define VSAPI
   #define VSUNIX  1
   #define VSOS2   0
   #define VSNT    0
#endif

#include <rc.h>

#define VSMAXLSTR  1024
  typedef struct {
     int len;
     unsigned char str[VSMAXLSTR];
  } VSLSTR, *VSPLSTR;

#if !defined(VSXLATDLLNAMES)
   #define VSNOXLATDLLNAMES
#else
   #undef VSNOXLATDLLNAMES
#endif

#define HVAR   int
#define VSHVAR  int
#define VSHREFVAR VSHVAR
//typedef void *VSPVOID;
//typedef char *VSPSZ;

#define VSPVOID void *
#define VSPSZ char *

extern "C" {

#define VSOI_MDI_FORM          1
#define VSOI_FORM              2
#define VSOI_TEXT_BOX          3
#define VSOI_CHECK_BOX         4
#define VSOI_COMMAND_BUTTON    5
#define VSOI_RADIO_BUTTON      6
#define VSOI_FRAME             7
#define VSOI_LABEL             8
#define VSOI_LIST_BOX          9
#define VSOI_HSCROLL_BAR       10
#define VSOI_VSCROLL_BAR       11
#define VSOI_COMBO_BOX         12
#define VSOI_HTHELP            13
#define VSOI_PICTURE_BOX       14
#define VSOI_IMAGE             15
#define VSOI_GAUGE             16
#define VSOI_SPIN              17
#define VSOI_MENU              18
#define VSOI_MENU_ITEM         19
#define VSOI_TREE_VIEW         20
#define VSOI_SSTAB             21
#define VSOI_DESKTOP           22
#define VSOI_SSTAB_CONTAINER   23
#define VSOI_EDITOR            24

#define VSSC_SIZE         0xF000
#define VSSC_MOVE         0xF010
#define VSSC_MINIMIZE     0xF020
#define VSSC_MAXIMIZE     0xF030
#define VSSC_NEXTWINDOW   0xF040
#define VSSC_PREVWINDOW   0xF050
#define VSSC_CLOSE        0xF060
#define VSSC_RESTORE      0xF120

// RefreshFlags
#define VSREFRESH_BUFNAME    0x0002
#define VSREFRESH_MODENAME   0x0004
#define VSREFRESH_READONLY   0x0008
#define VSREFRESH_LINE       0x0010
#define VSREFRESH_COL        0x0020
#define VSREFRESH_INSERTMODE 0x10000
#define VSREFRESH_RECORDING  0x20000


#define VSSTATUSFLAG_READONLY    0x0001
#define VSSTATUSFLAG_INSERTMODE  0x0002
#define VSSTATUSFLAG_RECORDING   0x0004

#define VSNULLSEEK      0x7fffffffl

#define VSRC_HVAR  1


#define VSP_CANCEL              0   /* boolean*/
#define VSP_DEFAULT             1   /* boolean*/
#define VSP_ENABLED             2   /* boolean*/
#define VSP_FONTBOLD            3   /* boolean*/
#define VSP_FONTITALIC          4   /* boolean*/
#define VSP_FONTSIZE            5   /* boolean*/
#define VSP_FONTSTRIKETHRU      6   /* boolean*/
/* #define                       7 */
#define VSP_FONTUNDERLINE       8   /* boolean*/
#define VSP_MAXBUTTON           9   /* boolean*/
#define VSP_MINBUTTON           10  /* boolean*/
#define VSP_VISIBLE             11  /* boolean*/
#define VSP_TABSTOP             12  /* boolean*/
#define VSP_CONTROLBOX          13  /* boolean*/
/* #define                       14 */ /* boolean*/
#define VSP_STYLE               15   /* int */
#define VSP_BORDERSTYLE         16   /* int */
#define VSP_DRAWSTYLE           17   /* int */
#define VSP_SCROLLBARS          18   /* int */
#define VSP_MULTISELECT         19   /* int */
#define VSP_INITSTYLE           20   /* int */
/* #define                       21 */
#define VSP_ALIGNMENT           22   /* int */
#define VSP_WINDOWSTATE         23   /* string. */
#define VSP_MOUSEPOINTER        24   /* int */
#define VSP_INITINFO            25   /* int */
#define VSP_VALIDATEINFO        26   /* int */
#define VSP_EVENTTAB            27   /* int */
#define VSP_NAME                28   /* string */
#define VSP_CAPTION             29   /* string */
#define VSP_FONTNAME            30   /* string. */
#define VSP_BACKCOLOR           31   /* int */
/* #define                         32 *//* int */
#define VSP_DRAWMODE            33   /* int */
#define VSP_DRAWWIDTH           34   /* int */
#define VSP_FORECOLOR           35   /* int */
#define VSP_HEIGHT              36   /* int */
#define VSP_INTERVAL            37   /* int */
#define VSP_TABINDEX            38   /* int */
#define VSP_WIDTH               39   /* int */
#define VSP_X                   40   /* int */
#define VSP_Y                   41   /* int */
#define VSP_VALUE               42   /* int */
#define VSP_INFROMLEFT          43   /* int */
#define VSP_DOWNFROMTOP         44   /* int */
#define VSP_INFROMRIGHT         45   /* int */
#define VSP_UPFROMBOTTOM        46   /* int */
#define VSP_SCALEMODE           47   /* int */
#define VSP_X1                  48   /* int */
#define VSP_Y1                  49   /* int */
#define VSP_X2                  50   /* int */
#define VSP_Y2                  51   /* int */
#define VSP_TEXT                52   /* string */
#define VSP_PICPOINTSCALE       53   /* int */
#define VSP_AFTERPICINDENTX     54   /* int */
#define VSP_PICSPACEY           55   /* int */
#define VSP_PICINDENTX          56   /* int */
#define VSP_PICTURE             57   /* int */
#define VSP_CBACTIVE            58   /* int */
#define VSP_STRETCH             59   /* boolean */
#define VSP_FONTPRINTER         60   /* boolean */
#define VSP_AUTOSIZE            61   /* boolean */
#define VSP_CBPICTURE           62   /* int */
#define VSP_CBLISTBOX           63   /* int */
#define VSP_CBTEXTBOX           64   /* int */
#define VSP_CB                  65   /* int */
#define VSP_OBJECT              66   /* string*/
#define VSP_CHILD               67   /* int */
#define VSP_NEXT                68   /* int */
#define VSP_CLIPCONTROLS        69   /* boolean */
#define VSP_WORDWRAP            70   /* boolean */
#define VSP_ADEFAULT            71   /* boolean */
#define VSP_EDIT                72   /* boolean */
#define VSP_SELECTED            73   /* boolean */
#define VSP_OBJECTMODIFY        74   /* boolean */
#define VSP_FILLSTYLE           75   /* int */
#define VSP_EVENTTAB2           76   /* int */
#define VSP_MIN                 77   /* int */
#define VSP_MAX                 78   /* int */
#define VSP_LARGECHANGE         79   /* int */
#define VSP_SMALLCHANGE         80   /* int */
#define VSP_DELAY               81   /* int */
#define VSP_CBEXTENDEDUI        82   /* boolean */
#define VSP_NOFSTATES           83   /* int */
#define VSP_ACTIVEFORM          84   /* int */
#define VSP_TEMPLATE            85   /* int */
#define VSP_COMPLETION          86   /* string */
#define VSP_MAXCLICK            87   /* int */
#define VSP_NOFSELECTED         88   /* int */
#define VSP_AUTOSELECT          89   /* boolean */
#define VSP_INCREMENT           90   /* int */
#define VSP_PREV                91   /* int */
#define VSP_COMMAND             92   /* string */
#define VSP_MESSAGE             93   /* string */
#define VSP_CATEGORIES          94   /* string */
#define VSP_CHECKED             95   /* boolean */


#define VSP_TILEID               100  /* int */
#define VSP_WINDOWFLAGS          101  /* int */
#define VSP_VSBBYTEDIVS          102  /* int */
#define VSP_WINDOWID             103  /* int */
#define VSP_LEFTEDGE             104  /* int */
#define VSP_CURSORX              105  /* int */
#define VSP_CURSORY              106  /* int */
#define VSP_LINE                 107  /* int */
#define VSP_NOFLINES             108  /* int */
#define VSP_COL                  109  /* int */
#define VSP_BUFNAME              110  /* string */
#define VSP_MODIFY               111  /* int */
#define VSP_BUFID                112  /* int */
#define VSP_MARGINS              113  /* string */
#define VSP_TABS                 114  /* string */
#define VSP_MODENAME             115  /* string */
#define VSP_BUFWIDTH             116  /* int */
#define VSP_WORDWRAPSTYLE        117  /* int */
#define VSP_SHOWTABS             118  /* int */
#define VSP_INDENTWITHTABS       119  /* boolean */
#define VSP_BUFFLAGS             120  /* int */
#define VSP_NEWLINE              121  /* string */
#define VSP_UNDOSTEPS            122  /* int */
#define VSP_INDEX                123  /* int */
#define VSP_BUFSIZE              124  /* int */
#define VSP_CHARHEIGHT           125  /* int */
#define VSP_CHARWIDTH            126  /* int */
#define VSP_VSBMAX               127  /* int */
#define VSP_HSBMAX               128  /* int */
#define VSP_FONTHEIGHT           129  /* int */
#define VSP_FONTWIDTH            130  /* int */
#define VSP_CLIENTHEIGHT         131  /* int */
#define VSP_CLIENTWIDTH          132  /* int */
#define VSP_OLDX                 133  /* int */
#define VSP_OLDY                 134  /* int */
#define VSP_OLDWIDTH             135  /* int */
#define VSP_OLDHEIGHT            136  /* int */
#define VSP_ONEVENT              137  /* int */
#define VSP_SELLENGTH            138  /* int */
#define VSP_SELSTART             139  /* int */
#define VSP_CURRENTX             140  /* int */
#define VSP_CURRENTY             141  /* int */
#define VSP_PARENT               142  /* int */
#define VSP_MDICHILD             143  /* int */
#define VSP_WINDENTX             144  /* int */
#define VSP_FIXEDFONT            145  /* int */
#define VSP_RELLINE              146  /* int */
#define VSP_SCROLLLEFTEDGE       147  /* int */
#define VSP_DISPLAYXLAT          148  /* string */
#define VSP_UNDOVISIBLE          149  /* int */
#define VSP_MODAL                150  /* int */
#define VSP_NOFWINDOWS           151  /* int */
#define VSP_USER                 152  /* string */
#define VSP_USER2                153  /* string */
#define VSP_NOSELECTCOLOR        154  /* boolean */
#define VSP_VIEWID               155  /* int */
#define VSP_INDENTSTYLE          156  /* int */
#define VSP_MODEEVENTTAB         157  /* int */
#define VSP_XYSCALEMODE          158  /* int */
#define VSP_XYPARENT             159  /* int */
#define VSP_BUTTONBAR            160  /* int */
#define VSP_ISBUTTONBAR          161  /* int */
#define VSP_MENUHANDLE           163  /* int */
#define VSP_FILEDATE             164  /* string */
#define VSP_REDRAW               165  /* boolean */
#define VSP_WORDCHARS            166  /* string */
#define VSP_LEXERNAME            167  /* string */
#define VSP_BUSER                168  /* string */
#define VSP_COLORFLAGS           169  /* int */
#define VSP_HWND                 170  /* long */
#define VSP_HWNDFRAME            171  /* long */



#define VSP_BINARY              172   /* boolean */
#define VSP_SHOWEOF             173   /* boolean */
//#define I_SHOWNLCHARS         174
#define VSP_READONLYMODE       175    /* boolean */
#define VSP_HEXNIBBLE          176    /* boolean */
#define VSP_HEXMODE            177    /* boolean */
#define VSP_HEXFIELD           178    /* int */
#define VSP_HEXNOFCOLS         179    // int
#define VSP_HEXTOPPAGE         180    // int
#define VSP_NOFHIDDEN          181    // int
#define VSP_LINENUMBERSLEN     182    // int
#define VSP_READONLYSETBYUSER  183    // boolean

#define VSP_WINDENT_Y          184    // int
#define VSP_NOFSELDISPBITMAPS  185    // int
#define VSP_LINESTYLE          186    // int
#define VSP_LEVELINDENT        187    // int
#define VSP_SPACEY             188    // int
#define VSP_EXPANDPICTURE      189    // int
#define VSP_COLLAPSEPICTURE    190    // int
#define VSP_SHOWROOT           191    // int
//#define VSP_CHECKLISTBOX       192    not supported


//#define VSP_PASSWORD            198   not supported
#define VSP_READONLY            199   // boolean
#define VSP_SHOWSPECIALCHARS    200   // int
#define VSP_MOUSEACTIVATE       201   // int
#define VSP_MODIFYFLAGS         202   // int
#define VSP_OLDLINENUMBER       203   // int
#define VSP_NOFNOSAVE           204   // int
#define VSP_CAPTIONCLICK        205   // boolean
#define VSP_RLINE               206   // int
#define VSP_RNOFLINES           207   // int


// SSTab properties
#define VSP_ACTIVETAB           208   // int
#define VSP_ORIENTATION         209   // int
#define VSP_TABSPERROW          210   // int
#define VSP_MULTIROW            211   // boolean
#define VSP_NOFTABS             212   // int
#define VSP_ACTIVEORDER         213   // int
#define VSP_ACTIVECAPTION       214   // int
#define VSP_ACTIVEPICTURE       215   // int
#define VSP_ACTIVEHELP          216   // string
#define VSP_RBUFSIZE            217   // int
#define VSP_ACTIVEENABLED       218   // boolean
#define VSP_PICTUREONLY         219   // boolean
#define VSP_SOURCERECORDING     220   // boolean

/* Completion arguments */
    /* "!" indicates last argument. */
#define VSMORE_ARG     "*"      /* Indicate more arguments. */
#define VSWORD_ARG     "w"      /* Match what was typed. */
#define VSFILE_ARG     "f:18"   /* Match one file. 18=FILE_CASE_MATCH|AUTO_DIR_MATCH*/
#define VSMULTI_FILE_ARG  FILE_ARG'*'
#define VSBUFFER_ARG     "b:2"    /* Match buffer. */
#define VSCOMMAND_ARG    "c"
#define VSPICTURE_ARG    "_pic"
#define VSFORM_ARG       "_form"
#define VSOBJECT_ARG     "_object"
#define VSMODULE_ARG     "m"
#define VSPC_ARG         "pc"     /* look for procedure or command . */
                      /* look Slick-C tag cmd,proc,form */
#define VSMACROTAG_ARG   "mt:8"   /* Any find-proc item. 8=REMOVE_DUPS_MATCH */
#define VSMACRO_ARG      "k"      /* Recorded macro command. */
#define VSPCB_TYPE_ARG   "pcbt"   /* list proc,command, and built-in types. */
#define VSVAR_ARG        "v"      /* look for variable. Global vars not included.*/
#define VSENV_ARG        "e"      /* look for environment variables. */
#define VSMENU_ARG       "_menu"
#define VSHELP_ARG       "h:37" /* (TERMINATE_MATCH|ONE_ARG_MATCH|NO_SORT_MATCH) */
   /* Match tag used by push-tag command. */
#define VSTAG_ARG        "tag:37" /* (REMOVE_DUPS_MATCH|NO_SORT_MATCH|TERMINATE_MATCH) */



#define VSNCW_ARG2      0x1    // Command allowed when there are no MDI child windows.
#define VSICON_ARG2     0x2    // Command allowed when active window is icon.
#define VSCMDLINE_ARG2  0x4    // Command allowed/operates on command line.
#define VSMARK_ARG2     0x8    // ON_SELECT psuedo event should pass control on
                               // to this command and not deselect text first.
#define VSREAD_ONLY_ARG2 0x10  // Command is allowed in read-only mode
#define VSQUOTE_ARG2     0x40  // Indicates that this command must be quoted when
                               // called during macro recording.  Needed only if
                               // command name is an invalid identifier or
                               // keyword.
#define VSLASTKEY_ARG2  0x80   // Command requires last_event value to be set
                               // when called during macro recording.
#define VSMACRO_ARG2     0x100      // This is a recorded macro command. Used for completion.
#define VSHELP_ARG2      0x200      // Not used. Here for backward compatibility.
#define VSHELPSALL_ARG2  0x400      // Not used. Here for backward compatibility.
#define VSTEXT_BOX_ARG2  0x800      // function operates on text box control.
#define VSNOEXIT_SCROLL_ARG2 0x1000 // Do not exit scroll caused by using scroll bars.
#define VSEDITORCTL_ARG2   0x2000   // Command allowed in editor control.

/* name_type flags. */
#define VSPROC_TYPE      0x1
#define VSVAR_TYPE       0x4
#define VSEVENTTAB_TYPE  0x8
#define VSCOMMAND_TYPE   0x10
#define VSGVAR_TYPE      0x20
#define VSGPROC_TYPE     0x40
#define VSMODULE_TYPE    0x80
#define VSPICTURE_TYPE   0x100
#define VSBUFFER_TYPE    0x200
#define VSOBJECT_TYPE    0x400
#define VSOBJECT_MASK    0xf800
#define VSOBJECT_SHIFT   11
#define VSINFO_TYPE      0x10000
#define VSMISC_TYPE      0x20000000
#define DLLCALL_TYPE     0x40000   /* Entries with this flag MUST also have the
                                  COMMAND_TYPE or PROC_TYPE flag. */
#define DLLMODULE_TYPE   0x80000
#define VSBUILT_IN_TYPE  0x40000000


#define VSHIDDEN_VIEWID -9
// p_buf_flags
#define VSHIDE_BUFFER        0x1  /* NEXT_BUFFER won't switch to this buffer */
#define VSTHROW_AWAY_CHANGES 0x2  /* Allow quit without prompting on modified buffer */
#define VSKEEP_ON_QUIT 0x4  /* Don't delete buffer on QUIT.  */
#define VSREVERT_ON_THROW_AWAY 0x10
#define VSPROMPT_REPLACE_BFLAG 0x20
#define VSDELETE_BUFFER_ON_CLOSE 0x40   /* Indicates whether a list box/ */

// Predefined object handles

#define VSWID_DESKTOP       1
#define VSWID_APP           2
#define VSWID_MDI           3
#define VSWID_CMDLINE       4
#define VSWID_HIDDEN        5

// VSP_WINDOWFLAGS
#define VSWINDOWFLAG_HIDDEN  0x1


#define VSSELECT_INCLUSIVE     0x1
#define VSSELECT_NONINCLUSIVE  0x2
#define VSSELECT_CURSOREXTENDS 0x4
#define VSSELECT_BEGINEND      0x8
#define VSSELECT_PERSISTENT    0x10


#define VSSELECT_LINE   1
#define VSSELECT_CHAR   2
#define VSSELECT_BLOCK  4
// Only supported by vsSetSelectType
#define VSSELECT_NONINCLUSIVEBLOCK 8


#define VSOPTION_WARNING_ARRAY_SIZE    1
#define VSOPTION_WARNING_STRING_LENGTH 2
#define VSOPTION_VERTICAL_LINE_COL     3
#define VSOPTION_WEAK_ERRORS           4
#define VSOPTION_MAXIMIZE_FIRST_MDICHILD  5
#define VSOPTION_MAXTABCOL             6
#define VSOPTION_CURSOR_BLINK          7
#define VSOPTION_DISPLAY_TEMP_CURSOR   8
#define VSOPTION_LEFT_MARGIN           9
#define VSOPTION_DISPLAY_TOP_OF_FILE   10
#define VSOPTION_HORIZONTAL_SCROLL_BAR 11
#define VSOPTION_VERTICAL_SCROLL_BAR   12
#define VSOPTION_HIDE_MOUSE            13
#define VSOPTION_ALT_ACTIVATES_MENU    14
#define VSOPTION_DRAW_BOX_AROUND_CURRENT_LINE 15
#define VSOPTION_MAX_MENU_FILENAME_LEN 16
#define VSOPTION_PROTECT_READONLY_MODE 17
#define VSOPTION_PROCESS_BUFFER_CR_ERASE_LINE 18
#define VSOPTION_ENABLE_FONT_FLAGS     19
#define VSOPTION_APIFLAGS              20
#define VSOPTION_HAVECMDLINE           21
#define VSOPTION_QUIET                 22
#define VSOPTION_SHOWTOOLTIPS          23
#define VSOPTION_TOOLTIPDELAY          24

#define VSOPTIONZ_PAST_EOF               1000
#define VSOPTIONZ_SPECIAL_CHAR_XLAT_TAB  1001

   #define VSSPECIALCHAR_EOLCH1  0
   #define VSSPECIALCHAR_EOLCH2  1
   #define VSSPECIALCHAR_TAB     2
   #define VSSPECIALCHAR_SPACE   3
   #define VSSPECIALCHAR_VIRTUALSPACE 4
   #define VSSPECIALCHAR_EOF     5

   #define VSSPECIALCHAR_MAX     20

int VSAPI vsLoadFiles(int wid,VSPSZ pszCmdline);
int VSAPI vsGetText(int wid,int Nofbytes,long seekpos,VSPSZ pszBuf);
int VSAPI vsGetLine(int wid,VSPSZ pszBuf,int BufLen);
int VSAPI vsDeleteLine(int wid);
void VSAPI vsInsertLine(int wid,char *pBuf,int BufLen);
void VSAPI vsReplaceLine(int wid,char *pBuf,int BufLen);
void VSAPI vsMessage(VSPSZ psz);
void VSAPI vsTop(int wid);
void VSAPI vsBottom(int wid);
int VSAPI vsDown(int wid,int Noflines);
int VSAPI vsUp(int wid,int Noflines);
int VSAPI vsActivateView(int view_id);
int VSAPI vsQLineLength(int wid,int IncludeNLChars);
int VSAPI vsAllocSelection(int AllocBookmark);
int VSAPI vsFreeSelection(int markid);

int VSAPI vsDeselect(int markid=(-1));
int VSAPI vsSelectLine(int wid,int markid=-1,int SelectFlags=0);
int VSAPI vsSelectChar(int wid,int markid=-1,int SelectFlags=0);
int VSAPI vsSelectBlock(int wid,int markid=-1,int SelectFlags=0);
void VSAPI vsCopyToCursor(int wid,int markid=-1,int MustBeMinusOne=(-1));

// pszOptions--> Start an undo step/Record Macro Source/Do refresh/Async shell
// This default options are great for Menu Items and Tool bar
// buttons.  Don't use SMD options in the middle of a macro.
long VSAPI vsExecute(int wid,VSPSZ pszCommand,VSPSZ pszOptions="SMDA");

int VSAPI vsQTextWidth(int wid,char *pText,int TextLen);
int VSAPI vsColWidthGet(int wid,int i,int *pwidth);
int VSAPI vsColWidthSet(int wid,int i,int width);
int VSAPI vsColWidthClear(int wid);

#define VSTREE_ADD_BEFORE     0x1 /* Add a node before sibling in order */
#define VSTREE_ADD_AS_CHILD   0x2
//These sort flags cannot be used in combination with each other
#define VSTREE_ADD_SORTED_CS       0x4
#define VSTREE_ADD_SORTED_CI       0x8
#define VSTREE_ADD_SORTED_FILENAME 0x10

int VSAPI vsTreeSetUserInfo(int wid,int iHandle,VSHVAR hvar);
int VSAPI vsTreeAddItem(int wid,int  iRelativeIndex,VSPSZ pszCaption,int  iFlags,
                        int  iCollapsedBMIndex,int  iExpandedBMIndex,
                        int  iState);
#define VSCOLORINDEX unsigned char

VSCOLORINDEX VSAPI vsAllocColor(int wid);
void VSAPI vsFreeColor(int wid,VSCOLORINDEX ColorIndex);
void VSAPI vsSetTextColor(int wid,VSCOLORINDEX *pColor,int ColorLen);
void VSAPI vsGetTextColor(int wid,VSCOLORINDEX *pColor,int ColorLen);


#define VSCFG_SELECTION          1
#define VSCFG_WINDOW_TEXT        2
#define VSCFG_CLINE              3
#define VSCFG_SELECTED_CLINE     4
#define VSCFG_MESSAGE            5
#define VSCFG_STATUS             6
#define VSCFG_CMDLINE            7
#define VSCFG_CURSOR             8
//VSCFG_CMDLINE_SELECT   = 9
//VSCFG_LIST_BOX_SELECT  = 10
//VSCFG_LIST_BOX         = 11
//VSCFG_ERROR
#define VSCFG_MODIFIED_LINE       13
#define VSCFG_INSERTED_LINE       14
//G_INSERTED_LINE      =15
//G_INSERTED_LINE      =16
#define VSCFG_KEYWORD             17
#define VSCFG_LINENUM             18
#define VSCFG_NUMBER              19
#define VSCFG_STRING              20
#define VSCFG_COMMENT             21
#define VSCFG_PPKEYWORD           22
#define VSCFG_SYMBOL1             23
#define VSCFG_SYMBOL2             24
#define VSCFG_SYMBOL3             25
#define VSCFG_SYMBOL4             26
#define VSCFG_IMAGINARY_LINE      27
#define VSCFG_NOSAVE_LINE         27
#define VSCFG_FUNCTION            28
#define VSCFG_FILENAME            30
#define VSCFG_HILIGHT             31

#define  VSFONTFLAG_BOLD    0x1
#define  VSFONTFLAG_ITALIC  0x2
#define  VSFONTFLAG_STRIKE_THRU 0x4
#define  VSFONTFLAG_UNDERLINE   0x8
#define  VSFONTFLAG_PRINTER     0x200
void VSAPI vsDeleteSelection(int wid,int markid,int Reserved=-1);
int VSAPI vsDuplicateSelection(int wid,int markid);
void VSAPI vsShowSelection(int markid);
void VSAPI vsExpandTabsC(int wid,
                   VSPSZ pszDest,
                   int *pDestLen,
                   int StartCol,
                   int ColWidth,
                   char Option);
int VSAPI vsTextColC(int wid,int col,char option='L');
int VSAPI vsSetSelectType(int markid,int type,char option='L' /* T L */);
int VSAPI vsQSelectType(int markid= -1,char option='T' /* T S P I U W*/);
long VSAPI vsQROffset(int wid);
int VSAPI vsGoToROffset(int wid,long offset);
int VSAPI vsGetText2(int wid,int Nofbytes,long point,VSPSZ pszBuf,int *pNofbytesRead=0);
void VSAPI vsGoToOldLineNumber(int wid,int OldLineNum,int Reserved=1);
void VSAPI vsSetAllOldLineNumbers(int wid,int Reserved=1);
int VSAPI vsDeleteText(int wid,int DelLen,char option=0);
int VSAPI vsInsertText(int wid,char *pBuf,int BufLen=-1,int Binary=0,unsigned char NLCh1='\r',unsigned char NLCh2='\n');

int VSAPI vsGoToPoint(int wid,long Point,long DownCount=0,int LineNum=(-1));
void VSAPI vsQPoint(int wid,long *pPoint,long *pDownCount,char Option='P');
long VSAPI vsQOffset(int wid);

int VSAPI vsSearch(int wid,VSPSZ pszSearchString,VSPSZ pszOptions=0,VSPSZ pszReplaceString=0,int *pNofchanges=0);
int VSAPI vsRepeatSearch(int wid,VSPSZ pszOptions=0,int StartCol=0);

#ifndef COMMENTINFOMASK_LF
   #define COMMENTINFOMASK_LF 0x1f
   #define NOSAVE_LF         0x00000040   //Display this line in no save color
   #define VIMARK_LF         0x00000080   //Used by VImacro to mark lines
   //#define UNDOMASK_LF     (COMMENTINFOMASK_LF|ALLDEBUGBITMAPS_LF)
   // Line flags below likely to be saved in file.
   #define MODIFY_LF         0x00000100   //Line has been modified
   #define INSERTED_LINE_LF  0x00000200   //Line was inserted
   #define HIDDEN_LF         0x00000400
   #define MINUSBITMAP_LF    0x00000800
   #define PLUSBITMAP_LF     0x00001000
   #define BREAKPOINTBITMAP_LF  0x00002000
   #define EXECPOINTBITMAP_LF   0x00004000
   #define STACKEXECBITMAP_LF         0x00008000
   #define BREAKPOINTNOTACTIVEBITMAP_LF  0x00010000
   #define ALLDEBUGBITMAPS_LF     (BREAKPOINTBITMAP_LF|EXECPOINTBITMAP_LF|STACKEXECBITMAP_LF|BREAKPOINTNOTACTIVEBITMAP_LF)
   #define vsDebugBitmapIndex(bl_flags)  (((bl_flags) & ALLDEBUGBITMAPS_LF)>>13)
   #define LEVEL_LF             0x007E0000
   #define NEXTLEVEL_LF         0x00020000
   #define LINEFLAGSMASK_LF     0x007fffff

   #define vsLevelIndex(bl_flags)  (((bl_flags) & LEVEL_LF)>>17)
   #define vsIndex2Level(level)   ((level)<<17)
#endif
int VSAPI vsQLineFlags(int wid);
void VSAPI vsSetLineFlags(int wid,int Flags,int Mask=0);
void VSAPI vsRefresh(int wid=0,char Option='A');
void VSAPI vsQuitView(int wid);
void VSAPI vsDeleteBuffer(int wid);
int VSAPI vsQMaxTabCol();
void VSAPI vsExpandTabs(int wid,
                   VSPSZ pszDest,
                   int *pDestLen,
                   char *pSource,
                   int SrcLen,
                   int StartCol,
                   int ColWidth,
                   char Option);
int VSAPI vsSaveFile(int wid,VSPSZ pszCmdLine);

#define VSRC_HVAR    1
#define VSDOT_HVAR   2


   typedef struct {
      int kind;
 #define VSARG_INT      0
 #define VSARG_LONG     1
 #define VSARG_HREFVAR  2
 #define VSARG_PSZ      3
 #define VSARG_PLSTR    4
 #define VSARG_HVAR     5
      union {
         int i;
         long l;
         VSHVAR hVar;
         char *psz;
         VSLSTR *plstr;
      }u;
   } VSARGTYPE;

VSHVAR VSAPI vsHvarArrayEl(VSHVAR hVarArrayEl,int i);
VSHVAR VSAPI vsHvarHashtabEl(VSHVAR hVarHashtab,char *pBuf,int BufLen=-1);
VSPLSTR VSAPI vsHvarGetLstr(VSHVAR hVar);
int VSAPI vsHvarGetI(VSHVAR hVar);
int VSAPI vsHvarSetI(VSHVAR hVar,int value);
int VSAPI vsHvarSetB(VSHVAR hVar,void *pBuf,int BufLen);
int VSAPI vsHvarSetZ(VSHVAR hVar,VSPSZ pszValue);
void VSAPI vsDllInit(void);
void VSAPI vsDllExit(void);
int VSAPI vsLIBExport(char *func_proto_p,char *name_info_p,int arg2,void *pfn);
int VSAPI vsDllExport(VSPSZ pszFuncProto,VSPSZ pszNameInfo,int arg2);
int VSAPI vsPropGetI(int wid,int prop_id);
int VSAPI vsPropGetZ(int wid,int prop_id,VSPSZ pszValue,int ValueLen);
int VSAPI vsPropGetB(int wid,int prop_id,void *pBuf,int BufLen);

void VSAPI vsPropSetI(int wid,int prop_id,int value);
void VSAPI vsPropSetZ(int wid,int prop_id,VSPSZ pszValue);
void VSAPI vsPropSetB(int wid,int prop_id,void *pBuf,int BufLen);

int VSAPI vsFileOpen(VSPSZ pszFilename,int option);
int VSAPI vsFileClose(int fh);
int VSAPI vsFileRead(int fh,void *pBuf,int BufLen);
int VSAPI vsFileWrite(int fh,void *pBuf,int BufLen);
long VSAPI vsFileSeek(int fh,long seekpos,int option);
int VSAPI vsFileFlush(int fh);

int VSAPI vsFindIndex(VSPSZ pszName,int flags);
void VSAPI vsCallIndex(int wid,int index,int Nofargs,VSARGTYPE *pArgList);

void VSAPI vsFree(void *pBuf);
void *VSAPI vsAlloc(int len);
void *VSAPI vsRealloc(void *pBuf,int len);

VSHVAR VSAPI vsGetVar(int index);

VSHVAR VSAPI vsArg(int ParamNum);

VSPSZ VSAPI vsZLstrcpy(VSPSZ pszDest,VSPLSTR plstrSource,int DestLen);


int VSAPI vsHvarFree(VSHVAR hVar);
VSHVAR VSAPI vsHvarAlloc(VSHVAR InitTohVar=0);
int VSAPI vsHvarGetLstr2(VSHVAR hVar,VSLSTR **pplstr,VSLSTR *ptemps);

int VSAPI vsHvarGetBool(VSHVAR hVar,int *pbool);
int VSAPI vsHvarGetI2(VSHVAR hVar,int *pi);
int VSAPI vsHvarIsInt(VSHVAR hVar);
int VSAPI vsHvarSetL(VSHVAR hVar,long i);
int VSAPI vsHvarSetLstr(VSHVAR hVar,VSLSTR *plstr);


int VSAPI vsHvarFormat(VSHVAR hVar);

int vsShell(char *pszCommand,char *pszOptions,char *pszAltShell);

void VSAPI vsPropSetL(int wid,int prop_id,long value);
long VSAPI vsPropGetL(int wid,int prop_id);
int VSAPI vsTopLstr(VSPLSTR *pplstr);


int VSAPI vsPosInit(int LineOffset);
void VSAPI vsPosGetLinePointers(unsigned char **pp,unsigned char **ppBeginLine,
                            unsigned char **ppEndLine,int *pRelLine);
int VSAPI vsPosIsEOL(int offset,int ReturnWhenBetweenNLChars=0);
void VSAPI vsPosSetPointer(unsigned char *p);
int VSAPI vsPosRelPGoTo(unsigned char *p);
int VSAPI vsPosNextBOL(int Noflines);
int VSAPI vsPosSave(void *pSavePos);
int VSAPI vsPosRestore(void *pSavePos);
int VSAPI vsPosIsEOR(int offset);
void VSAPI vsPosGetPointers(unsigned char **pp,unsigned char **ppEndLine,
                            unsigned char **ppEndBuf=0);
int VSAPI vsPosSetCurLine();
int VSAPI vsPosQCol();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\brctrl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       brctrl.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheView (*_pView)
#define TheModel (*_pModel)

// Member functions responding to messages

LRESULT WINAPI BrowseWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lr = 0;
    CBrowseWindow *pbw = (CBrowseWindow *) GetWindowLongPtr( hwnd, 0 );

    switch (msg)
    {
        case WM_CREATE:
        {
            App.BrowseLastError() = S_OK;
            CREATESTRUCT *pcs = (CREATESTRUCT *) lParam;
            MDICREATESTRUCT *pmcs = (MDICREATESTRUCT *) pcs->lpCreateParams;
            CQueryResult *pResults = (CQueryResult *) pmcs->lParam;
            pbw = new CBrowseWindow();
            SetWindowLongPtr( hwnd, 0, (LONG_PTR) pbw);
            lr = pbw->TheBrowseController.Create( pResults,
                                                  hwnd,
                                                  &pbw->TheBrowseModel,
                                                  &pbw->TheBrowseView,
                                                  App.BrowseFont() );
            break;
        }
        case WM_MDIACTIVATE :
            pbw->TheBrowseController.Activate( hwnd, lParam );
            break;
        case WM_SIZE:
            lr = DefMDIChildProc( hwnd, msg, wParam, lParam );
            pbw->TheBrowseController.Size( hwnd, lParam );
            break;
        case WM_VSCROLL:
            pbw->TheBrowseController.VScroll(hwnd, wParam, lParam);
            break;
        case WM_HSCROLL:
            pbw->TheBrowseController.HScroll(hwnd, wParam, lParam);
            break;
        case WM_KEYDOWN:
            pbw->TheBrowseController.KeyDown (hwnd, wParam );
            lr = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
        case WM_CHAR:
            pbw->TheBrowseController.Char (hwnd, wParam);
            lr = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
        case WM_PAINT:
            pbw->TheBrowseController.Paint(hwnd);
            break;
        case wmMenuCommand:
            pbw->TheBrowseController.Command(hwnd, wParam);
            break;
        case wmInitMenu:
            pbw->TheBrowseController.EnableMenus();
            break;
        case WM_DESTROY:
            SetWindowLongPtr(hwnd,0,0);
            delete pbw;
            SetProcessWorkingSetSize( GetCurrentProcess(), -1, -1 );
            break;
        case wmNewFont:
            pbw->TheBrowseController.NewFont(hwnd, wParam);
            break;
        case WM_LBUTTONUP:
            pbw->TheBrowseView.ButtonUp( wParam, lParam );
            break;
        case WM_LBUTTONDOWN:
            pbw->TheBrowseView.ButtonDown( wParam, lParam );
            break;
        case WM_LBUTTONDBLCLK:
            pbw->TheBrowseView.DblClk( wParam, lParam );
            break;
        case WM_MOUSEMOVE :
            pbw->TheBrowseView.MouseMove( wParam, lParam );
            break;
        case WM_MOUSEWHEEL :
            lr = pbw->TheBrowseController.MouseWheel( hwnd, wParam, lParam );
            break;
        case WM_CONTEXTMENU :
            pbw->TheBrowseController.ContextMenu( hwnd, wParam, lParam );
            break;
        case EM_GETSEL:
        {
            if ( pbw->TheBrowseView.GetSelection().SelectionExists() )
                lr = MAKELRESULT( 1, 2 );
            else
                lr = 0;
            break;
        }
        default:
            lr = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
    }

    return lr;
} //BrowseWndProc

void Control::ContextMenu(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    POINT pt;
    pt.x = LOWORD( lParam );
    pt.y = HIWORD( lParam );

    GetCursorPos( &pt );

    HMENU hMenu = LoadMenu( App.Instance(), L"BrowseContextMenu" );

    if ( 0 != hMenu )
    {
        HMENU hTrackMenu = GetSubMenu( hMenu, 0 );
        if ( 0 != hTrackMenu )
        {
            if ( !TheView.GetSelection().SelectionExists() )
                EnableMenuItem( hTrackMenu,
                                IDM_EDITCOPY,
                                MF_BYCOMMAND | MF_GRAYED );

            // yes, the function returns a BOOL that you switch on

            BOOL b = TrackPopupMenuEx( hTrackMenu,
                                       TPM_LEFTALIGN | TPM_RIGHTBUTTON |
                                           TPM_RETURNCMD,
                                       pt.x,
                                       pt.y,
                                       hwnd,
                                       0 );
            switch ( b )
            {
                case IDM_BROWSE_OPEN :
                {
                    ViewFile( TheModel.Filename(),
                              fileOpen );
                    break;
                }
                case IDM_BROWSE_EDIT :
                {
                    POINT winpt;
                    winpt.x = 0;
                    winpt.y = 0;
                    ClientToScreen( hwnd, &winpt );
                    ViewFile( TheModel.Filename(),
                              fileEdit,
                              TheView.ParaFromY( pt.y - winpt.y ) );
                    break;
                }
                case IDM_EDITCOPY :
                {
                    Command( hwnd, b );
                    break;
                }
            }
        }

        DestroyMenu( hMenu );
    }
} //ContextMenu

LRESULT Control::Create(
    CQueryResult * pResults,
    HWND           hwnd,
    Model *        pModel,
    View *         pView,
    HFONT          hFont )
{
    LRESULT lr = 0;

    _iWheelRemainder = 0;
    _pModel = pModel;
    _pView = pView;
    SCODE sc = TheModel.CollectFiles( pResults );

    if ( SUCCEEDED( sc ) )
    {
        TheView.Init( hwnd, _pModel, hFont );

        // Go to first query hit (if any)

        Position pos;

        if ( TheModel.GetPositionCount() != 0 )
            pos = TheModel.GetPosition(0);

        TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());

        RECT rc;
        GetClientRect(hwnd,&rc);

        TheView.Size( rc.right, rc.bottom );

        TheView.SetScroll (pos);

        EnableMenus();
   }
   else
   {
       // no better way to get the error back

       App.BrowseLastError() = sc;
       lr = -1; // don't continue creating the window
   }

   return lr;
} //Create

void Control::Activate( HWND hwnd, LPARAM lParam )
{
    if ( hwnd == (HWND) lParam )
    {
        int apos[3] = { 0, 0, 0 };
        int cPos = 2;

        HDC hdc = GetDC( hwnd );

        if ( 0 == hdc )
            return;

        SIZE size;

        WCHAR awcLines[100];
        CResString strLines( IDS_BRSTAT_CLINES );
        wsprintf( awcLines, strLines.Get(), TheModel.ParaCount() );
        GetTextExtentPoint( hdc, awcLines, wcslen( awcLines ), &size );
        apos[0] = 2 * size.cx;

        WCHAR awcHits[100];
        CResString strHits( IDS_BRSTAT_CHITS );
        wsprintf( awcHits, strHits.Get(), TheModel.HitCount(), TheModel.HitCount() );
        GetTextExtentPoint( hdc, awcHits, wcslen( awcHits ), &size );
        apos[1] = 2 * size.cx + apos[0];

        ReleaseDC( hwnd, hdc );

        SendMessage( App.StatusBarWindow(), SB_SETPARTS, cPos, (LPARAM) apos );

        SendMessage( App.StatusBarWindow(), SB_SETTEXT, 0, (LPARAM) awcLines );

        static UINT aDisable[] = { IDM_SEARCH,
                                   IDM_SEARCHCLASSDEF,
                                   IDM_SEARCHFUNCDEF,
                                   IDM_BROWSE,
                                   IDM_DISPLAY_PROPS };
        UpdateButtons( aDisable, 5, FALSE );

        EnableMenus();
    }
} //Activate

void Control::NewFont ( HWND hwnd, WPARAM wParam)
{
    TheView.FontChange ( hwnd, (HFONT) wParam );
    InvalidateRect(hwnd, NULL, TRUE);
} //NewFont

void Control::SetScrollBars ( HWND hwnd )
{
    SetScrollPos ( hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
    SetScrollPos ( hwnd, SB_HORZ, TheView.HScrollPos(), TRUE );
} //SetScrollBars

// Go to next query hit when 'n' pressed

void Control::Char ( HWND hwnd, WPARAM wparam )
{
    Position pos;
    HCURSOR hCursor;
    BOOL success;

    switch ( wparam )
    {
        case 'n':
        {
            if ( !TheModel.NextHit() )
                break;

            pos = TheModel.GetPosition(0);
            TheView.SetScroll( pos );
            SetScrollBars (hwnd);

            EnableMenus();
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        }
        case 'p':
        {
            if ( !TheModel.PrevHit() )
                break;

            pos = TheModel.GetPosition(0);
            TheView.SetScroll( pos );
            SetScrollBars(hwnd);

            EnableMenus();
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        }
        case 'N':
        {
            hCursor = SetCursor (LoadCursor(0, IDC_WAIT));
            ShowCursor (TRUE);
            success = S_OK == TheModel.NextDoc();
            ShowCursor(FALSE);
            SetCursor (hCursor);

            if ( success )
            {
                if ( TheModel.GetPositionCount() != 0 )
                {
                    pos = TheModel.GetPosition(0);
                }
                TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());
                TheView.SetScrollMax();
                TheView.SetScroll (pos);
                UpdateScroll(hwnd);

                InvalidateRect(hwnd, NULL, TRUE);
                EnableMenus();
                SetWindowText( hwnd, TheModel.Filename() );
            }
            break;
        }
        case 'P':
        {
            hCursor = SetCursor (LoadCursor(0, IDC_WAIT));
            ShowCursor (TRUE);
            success = TheModel.PrevDoc();
            ShowCursor(FALSE);
            SetCursor (hCursor);
            if ( success )
            {
                if ( TheModel.GetPositionCount() != 0 )
                    pos = TheModel.GetPosition(0);

                TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());
                TheView.SetScrollMax();
                TheView.SetScroll (pos);
                UpdateScroll(hwnd);
                InvalidateRect(hwnd, NULL, TRUE);
                EnableMenus();
                SetWindowText( hwnd, TheModel.Filename() );
            }
            break;
        }
    }
} //Char

void Control::EnableMenus()
{
    UINT ui = IDM_NEXT_HIT;
    UpdateButtons( &ui, 1, ! TheModel.isLastHit() );
    ui = IDM_PREVIOUS_HIT;
    UpdateButtons( &ui, 1, ! TheModel.isFirstHit() );

    HMENU hmenu = GetMenu( App.AppWindow() );

    EnableMenuItem(hmenu,IDM_NEXT_HIT,MF_BYCOMMAND |
                   (TheModel.isLastHit() ? MF_GRAYED | MF_DISABLED  :
                                           MF_ENABLED) );

    EnableMenuItem(hmenu,IDM_PREVIOUS_HIT,MF_BYCOMMAND |
                   (TheModel.isFirstHit() ? MF_GRAYED | MF_DISABLED  :
                                            MF_ENABLED) );

    EnableMenuItem( hmenu, IDM_NEWSEARCH, MF_ENABLED );

    int cHits = TheModel.HitCount();

    WCHAR awcHits[100];
    if ( 0 == cHits )
    {
        awcHits[0] = 0;
    }
    else
    {
        CResString strHits( IDS_BRSTAT_CHITS );
        wsprintf( awcHits,
                  strHits.Get(),
                  TheModel.CurrentHit() + 1,
                  cHits );
    }
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, 1, (LPARAM) awcHits );
} //EnableMenus

void Control::Size ( HWND hwnd, LPARAM lParam )
{
    TheView.Size ( LOWORD(lParam), HIWORD(lParam) );
    TheView.SetScrollMax();
    UpdateScroll( hwnd );
    // in case we have to scroll to close up the gap
    // at the bottom of the window
    int delta = TheView.IncVScrollPos( 0 );
    if (delta != 0)
    {
        MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0 );
        SetScrollPos (hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
        UpdateWindow(hwnd);
    }
} //Size

void Control::UpdateScroll( HWND hwnd)
{
    TheView.SetRange ( TheModel.MaxParaLen(), TheModel.Paras());

    SetScrollRange(hwnd, SB_VERT, 0, TheView.VScrollMax(), FALSE );
    SetScrollRange(hwnd, SB_HORZ, 0, TheView.HScrollMax(), FALSE );

    SetScrollBars (hwnd);

    // proportional scroll box
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE;
    si.nPage = TheView.VisibleLines();
    SetScrollInfo( hwnd, SB_VERT, &si, TRUE );
} //UpdateScroll

LRESULT Control::MouseWheel( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    // forward what we don't process

    if ( wParam & ( MK_SHIFT | MK_CONTROL ) )
        return DefMDIChildProc( hwnd, WM_MOUSEWHEEL, wParam, lParam );

    // add the current scroll to the remainder from last time

    int iDelta = (int) (short) HIWORD( wParam );
    iDelta += _iWheelRemainder;

    // if there isn't enough to process this time, just return

    if ( abs( iDelta ) < WHEEL_DELTA )
    {
        _iWheelRemainder = iDelta;
        return 0;
    }

    // compute the remainder and amount to scroll

    _iWheelRemainder = ( iDelta % WHEEL_DELTA );
    iDelta /= WHEEL_DELTA;

    BOOL fDown;
    if ( iDelta < 0 )
    {
        fDown = TRUE;
        iDelta = -iDelta;
    }
    else
        fDown = FALSE;

    // get the # of lines to scroll per WHEEL_DELTA

    int cLines;
    SystemParametersInfo( SPI_GETWHEELSCROLLLINES, 0, &cLines, 0 );
    if ( 0 == cLines )
        return 0;

    int cVisibleLines = TheView.VisibleLines();

    // if scrolling a page, do so.  don't scroll more than one page

    if ( WHEEL_PAGESCROLL == cLines )
        iDelta = __max( 1, (cVisibleLines - 1) );
    else
    {
        iDelta *= cLines;
        if ( iDelta >= cVisibleLines )
            iDelta = __max( 1, (cVisibleLines - 1) );
    }

    // phew.  do the scroll

    if ( 0 != iDelta )
    {
        int delta = TheView.IncVScrollPos( fDown ? iDelta : -iDelta );
        MyScrollWindow( hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
        SetScrollPos( hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
        UpdateWindow( hwnd );
    }

    return iDelta;
} //MouseWheel

void Control::VScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    int nVScrollInc;
    int delta = 0;

    switch (LOWORD(wParam))
    {
        case SB_TOP:
            TheView.Home();
            InvalidateRect (hwnd, 0, TRUE);
            delta = 1;
            break;
        case SB_BOTTOM:
            TheView.End();
            InvalidateRect (hwnd, 0, TRUE);
            delta = 1;
            break;

        case SB_LINEUP:
            delta = TheView.IncVScrollPos( -1 );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;
        case SB_LINEDOWN:
            nVScrollInc = 1;
            delta = TheView.IncVScrollPos( 1 );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;

        case SB_PAGEUP:
            nVScrollInc = - max ( 1, TheView.VisibleLines() - 1);
            delta = TheView.IncVScrollPos( nVScrollInc );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;
        case SB_PAGEDOWN:
            nVScrollInc = max ( 1, TheView.VisibleLines() - 1);
            delta = TheView.IncVScrollPos( nVScrollInc );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;

        case SB_THUMBTRACK:
            delta = TheView.JumpToPara ( HIWORD(wParam) );
            MyScrollWindow (hwnd, 0, -delta * TheView.LineHeight(), 0, 0, FALSE );
            break;
        default:
            break;
    }

    if ( delta != 0 )
    {
        SetScrollPos (hwnd, SB_VERT, TheView.VScrollPara(), TRUE );
        UpdateWindow(hwnd);
    }
} //VScroll

void Control::HScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
}

void Control::KeyDown ( HWND hwnd, WPARAM wparam )
{
    switch(wparam)
    {
        case VK_HOME:
            SendMessage( hwnd, WM_VSCROLL, SB_TOP, 0L );
            break;
        case VK_END:
            SendMessage( hwnd, WM_VSCROLL, SB_BOTTOM, 0L );
            break;
        case VK_PRIOR:
            SendMessage( hwnd, WM_VSCROLL, SB_PAGEUP, 0L );
            break;
        case VK_NEXT:
            SendMessage( hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L );
            break;
        case VK_UP:
            SendMessage( hwnd, WM_VSCROLL, SB_LINEUP, 0L );
            break;
        case VK_DOWN:
            SendMessage( hwnd, WM_VSCROLL, SB_LINEDOWN, 0L );
            break;
        case VK_LEFT:
            SendMessage( hwnd, WM_HSCROLL, SB_PAGEUP, 0L );
            break;
        case VK_RIGHT:
            SendMessage( hwnd, WM_HSCROLL, SB_PAGEDOWN, 0L );
            break;
    }
} //KeyDown

// Menu commands processing

void Control::Command ( HWND hwnd, WPARAM wParam )
{
    switch ( wParam )
    {
        case IDM_NEXT_HIT:
            SendMessage ( hwnd, WM_CHAR, 'n', 0L );
            break;
        case IDM_PREVIOUS_HIT:
            SendMessage ( hwnd, WM_CHAR, 'p', 0L );
            break;
        case IDM_NEWSEARCH:
            // close the browser window
            PostMessage( hwnd, WM_CLOSE, 0, 0 );
            break;
        case IDM_EDITCOPY :
            TheView.EditCopy( hwnd, wParam );
    }
} //Command
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\brdoc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       document.cxx
//
//  Contents:   The Document part of the browser
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheSearch pSearch

const int UNICODE_PARAGRAPH_SEPARATOR=0x2029;

const GUID guidStorage = PSGUID_STORAGE;

//+-------------------------------------------------------------------------
//
//  Member:     Position::Compare, public
//
//  Synopsis:   Compare two positions
//
//--------------------------------------------------------------------------

int Position::Compare( const Position& pos ) const
{
   int diff = _para - pos.Para();
   if ( diff == 0 )
      diff = _begOff - pos.BegOff();
   return diff;
}

//+-------------------------------------------------------------------------
//
//  Member:     Hit::Hit, public
//
//  Synopsis:   Create hit from an array of positions
//
//--------------------------------------------------------------------------

Hit::Hit( const Position * aPos, unsigned cPos )
: _cPos(cPos)
{
    _aPos = new Position[cPos];

    memcpy( _aPos, aPos, sizeof(Position) * cPos );
}

Hit::~Hit()
{
    delete _aPos;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPositionCount, public
//
//  Synopsis:   return number of positions or zero
//
//--------------------------------------------------------------------------

int HitIter::GetPositionCount() const
{
    if (_iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit])
        return _pDoc->_aHit[_iHit]->Count();

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPosition, public
//
//  Synopsis:   return position by value
//
//--------------------------------------------------------------------------

Position HitIter::GetPosition ( int i ) const
{
     if ( _iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit] )
          return _pDoc->_aHit[_iHit]->GetPos(i);
     else
     {
          Position pos;
          return( pos );
     }
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::Document, public
//
//  Synopsis:   Initialize document with filename
//
//--------------------------------------------------------------------------

Document::Document(WCHAR const* filename, LONG rank, BOOL fDelete)
: _filename(0),
  _rank (rank),
  _buffer(0),
  _bufLen(0),
  _bufEnd(0),
  _pFilter(0),
  _aParaOffset(0),
  _isInit(FALSE),
  _cHit(0),
  _aParaLine(0),
  _maxParaLen(0),
  _cPara(0),
  _chunkCount(0),
  _fDelete( fDelete )
{
    _filename = new WCHAR[ wcslen( filename ) + 1 ];
    wcscpy( _filename, filename );
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::Document, public
//
//  Synopsis:   Initialize document
//
//--------------------------------------------------------------------------

Document::Document()
: _filename(0),
  _buffer(0),
  _bufLen(0),
  _bufEnd(0),
  _pFilter(0),
  _aParaOffset(0),
  _isInit(FALSE),
  _cHit(0),
  _aParaLine(0),
  _maxParaLen(0),
  _cPara(0),
  _chunkCount(0),
  _fDelete( FALSE )
{}

//+-------------------------------------------------------------------------
//
//  Member:     Document::~Document, public
//
//  Synopsis:   Free document
//
//--------------------------------------------------------------------------

Document::~Document()
{
    Free();
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::Free, public
//
//  Synopsis:   Free document storage
//
//--------------------------------------------------------------------------

void Document::Free()
{
    if ( 0 != _filename )
    {
        if ( _fDelete )
            DeleteFile( _filename );

        delete [] _filename;
    }

    if (!_isInit)
        return;

    for ( unsigned i = 0; i < _cHit; i++ )
    {
        delete _aHit[i];
        _aHit[i] = 0;
    }

    // _aHit is embedded

    delete []_aParaOffset;
    _aParaOffset = 0;

    if (_aParaLine)
    {
        for (int i = 0; i < _cPara; i++)
        {
            while (_aParaLine[i].next != 0)
            {
                ParaLine* p = _aParaLine[i].next;
                _aParaLine[i].next = _aParaLine[i].next->next;
                delete p;
            }
        }
        delete _aParaLine;
    }

    delete _buffer;

    _buffer = 0;

    _bufEnd = 0;
    _cHit = 0;

    _isInit = FALSE;
} //Free

//+-------------------------------------------------------------------------
//
//  Member:     Document::Init, public
//
//  Synopsis:   Read-in file, fill array of hits
//
//--------------------------------------------------------------------------

SCODE Document::Init(ISearchQueryHits *pSearch)
{
    BOOL noHits = FALSE;

    SCODE sc = S_OK;

    TRY
    {
        AllocBuffer( _filename );
        BindToFilter( _filename );

        ULONG ulFlags;
        sc = _pFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                             IFILTER_INIT_CANON_HYPHENS |
                             IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                             0, 0, &ulFlags );

        if (FAILED (sc))
            THROW (CException(sc));

        ReadFile();

        BreakParas();

        if (Paras() != 0)
        {
            BreakLines();

#if 0
            // some filters don't behave correctly if you just re-init them,
            // so release the filter and re-open it.

            _pFilter->Release();
            _pFilter = 0;
            BindToFilter();
#endif

            sc = _pFilter->Init ( IFILTER_INIT_CANON_PARAGRAPHS |
                                  IFILTER_INIT_CANON_HYPHENS |
                                  IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                                  0, 0, &ulFlags );
            sc = TheSearch->Init( _pFilter, ulFlags );

            if (FAILED (sc))
            {
                if ( QUERY_E_ALLNOISE != sc )
                    THROW (CException(sc));
                // we can still show the file

                sc = S_OK;
                noHits = TRUE;
            }

            // SUCCESS
            _isInit = TRUE;
        }
    }
    CATCH ( CException, e )
    {
        _isInit = FALSE;
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if (!noHits)
    {
        //
        // pull up all the hits
        //

        ULONG count;
        FILTERREGION* aRegion;
        SCODE sc = TheSearch->NextHitOffset ( &count, &aRegion );

        while (sc == S_OK)
        {
            XCoMem<FILTERREGION> xRegion( aRegion );

            CDynArrayInPlace<Position> aPos( count );

            for (unsigned i = 0; i < count; i++)
                aPos [i] = RegionToPos ( aRegion [i] );

            xRegion.Free();

            XPtr<Hit> xHit( new Hit( aPos.GetPointer(), count ) );

            _aHit[_cHit] = xHit.Get();
            _cHit++;
            xHit.Acquire();

            sc = TheSearch->NextHitOffset ( &count, &aRegion );
        }
    }
    else
    {
        _cHit = 0;
        _isInit = (_bufEnd - _buffer) != 0;
    }

    if ( _pFilter )
    {
        _pFilter->Release();
        _pFilter = 0;
    }

    return _isInit ? S_OK : sc;
}

Position Document::RegionToPos ( FILTERREGION& region )
{
    static int paraHint = 0;
    static int iChunkHint = 0;
    static Position posNull;

    ULONG offset = ULONG (-1);

    // translate region to offset into buffer
    if (iChunkHint >= _chunkCount || _chunk[iChunkHint].ChunkId() != region.idChunk )
    {
        iChunkHint = 0;

        while ( iChunkHint < _chunkCount && _chunk[iChunkHint].ChunkId() < region.idChunk )
        {
            iChunkHint++;
        }

        if (iChunkHint >= _chunkCount || _chunk[iChunkHint].ChunkId() != region.idChunk)
            return posNull;
    }

    Win4Assert ( iChunkHint < _chunkCount );
    Win4Assert ( _chunk[iChunkHint].ChunkId() == region.idChunk );

    offset = _chunk[iChunkHint].Offset() + region.cwcStart;

    if (paraHint >= _cPara || _aParaOffset[paraHint] > offset )
        paraHint = 0;

    Win4Assert ( _aParaOffset[paraHint] <= offset );

    for ( ; paraHint <= _cPara; paraHint++)
    {
        // _aParaOffset[_cPara] is valid!

        if (_aParaOffset[paraHint] > offset)
        {
            Win4Assert (paraHint > 0);
            paraHint--;
            return Position ( paraHint,
                              offset - _aParaOffset[paraHint],
                              region.cwcExtent );
        }
    }

    return posNull;
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::AllocBuffer, public
//
//  Synopsis:   Allocate buffer for file text
//
//--------------------------------------------------------------------------

void Document::AllocBuffer ( WCHAR const * pwcPath )
{
    //
    //  We should keep allocating buffers on demand,
    //  but for this simple demo we'll just get the
    //  file size up front and do a single buffer
    //  allocation of 2.25 the size (to accommodate
    //  Unicode expansion). THIS IS JUST A DEMO!
    //

    HANDLE hFile = CreateFile ( pwcPath,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               0, // security
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               0 ); // template

    if ( INVALID_HANDLE_VALUE == hFile )
        THROW( CException() );

    _bufLen = GetFileSize(hFile, 0 );
    CloseHandle ( hFile );

    // Unicode from ASCII, twice and then some

    _bufLen = 2 * _bufLen + _bufLen / 4 + 1;

    _buffer = new WCHAR [_bufLen + 1];
    _buffer[ _bufLen ] = 0;
}

typedef HRESULT (__stdcall * PFnLoadTextFilter)( WCHAR const * pwcPath,
                                                 IFilter ** ppIFilter );

PFnLoadTextFilter g_pLoadTextFilter = 0;

SCODE MyLoadTextFilter( WCHAR const *pwc, IFilter **ppFilter )
{
    if ( 0 == g_pLoadTextFilter )
    {
        g_pLoadTextFilter = (PFnLoadTextFilter) GetProcAddress( GetModuleHandle( L"query.dll" ), "LoadTextFilter" );

        if ( 0 == g_pLoadTextFilter )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return g_pLoadTextFilter( pwc, ppFilter );
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::BindToFilter, public
//
//  Synopsis:   Bind to appropriate filter for the document
//
//--------------------------------------------------------------------------

void Document::BindToFilter( WCHAR const * pwcPath )
{
    //
    // Bind to the filter interface
    //

    SCODE sc = LoadIFilter( pwcPath, 0, (void **)&_pFilter );

    if ( FAILED(sc) )
    {
        sc = MyLoadTextFilter( pwcPath, &_pFilter );
        if ( FAILED(sc) )
            THROW( CException(sc) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::ReadFile, public
//
//  Synopsis:   Read file into buffer using the filter
//
//--------------------------------------------------------------------------

void Document::ReadFile ()
{
    SCODE sc;
    ULONG lenSoFar = 0;
    int   cChunk = 0;
    BOOL  fSeenProp = FALSE;

    STAT_CHUNK statChunk;
    sc = _pFilter->GetChunk ( &statChunk );

    // what about all these glueing flags?
    // Take them into account at some point
    // to test more complicated chunking

    while (SUCCEEDED(sc)
          || FILTER_E_LINK_UNAVAILABLE == sc
          || FILTER_E_EMBEDDING_UNAVAILABLE == sc )
    {

        if ( SUCCEEDED( sc ) && (statChunk.flags & CHUNK_TEXT) )
        {
            // read the contents only

            if ( statChunk.attribute.guidPropSet == guidStorage &&
                 statChunk.attribute.psProperty.ulKind == PRSPEC_PROPID &&
                 statChunk.attribute.psProperty.propid == PID_STG_CONTENTS )
            {
                if ( statChunk.breakType != CHUNK_NO_BREAK )
                {
                    switch( statChunk.breakType )
                    {
                        case CHUNK_EOW:
                        case CHUNK_EOS:
                            _buffer[lenSoFar++] = L' ';
                            break;
                        case CHUNK_EOP:
                        case CHUNK_EOC:
                            _buffer[lenSoFar++] = UNICODE_PARAGRAPH_SEPARATOR;
                            break;
                    }
                }

                _chunk [cChunk].SetChunkId (statChunk.idChunk);
                Win4Assert ( cChunk == 0 || statChunk.idChunk > _chunk [cChunk - 1].ChunkId () );
                _chunk [cChunk].SetOffset (lenSoFar);
                cChunk++;

                do
                {
                    ULONG lenThis = _bufLen - lenSoFar;
                    if (lenThis == 0)
                        break;

                    sc = _pFilter->GetText( &lenThis, _buffer+lenSoFar );

                    // The buffer may be filled with zeroes.  Nice filter.

                    if ( SUCCEEDED(sc) && 0 != lenThis )
                    {
                        lenThis = __min( lenThis,
                                         wcslen( _buffer + lenSoFar ) );
                        lenSoFar += lenThis;
                    }
                }
                while (SUCCEEDED(sc));
            }
        } // if SUCCEEDED( sc )

        // next chunk, please
        sc = _pFilter->GetChunk ( &statChunk );
    }

    _bufEnd = _buffer + lenSoFar;

    Win4Assert( lenSoFar <= _bufLen );

    _chunkCount = cChunk;
}


//+-------------------------------------------------------------------------
//
//  Member:     Document::BreakParas, public
//
//  Synopsis:   Break document into paragraphs separated by line feeds
//
//--------------------------------------------------------------------------

#define PARAS 25

void Document::BreakParas()
{
    int maxParas = PARAS;
    _aParaOffset = new unsigned [ maxParas ];
    WCHAR * pCur = _buffer;
    _cPara = 0;
    _maxParaLen = 0;

    do
    {
        if ( _cPara == maxParas )
        {
            // grow array
            unsigned * tmp = new unsigned [maxParas * 2];
            for ( int n = 0; n < maxParas; n++ )
                tmp[n] = _aParaOffset[n];
            delete []_aParaOffset;
            _aParaOffset = tmp;
            maxParas *= 2;
        }
        _aParaOffset [_cPara] = (UINT)(pCur - _buffer);

        pCur = EatPara(pCur);

        _cPara++;

    } while ( pCur < _bufEnd );

    // store end of buffer offset as _aParaOffset[_cPara]

    if ( _cPara == maxParas )
    {
        // grow array
        unsigned * tmp = new unsigned [maxParas + 1];
        for ( int n = 0; n < maxParas; n++ )
            tmp[n] = _aParaOffset[n];
        delete []_aParaOffset;
        _aParaOffset = tmp;
        maxParas += 1;
    }

    _aParaOffset [_cPara] = (UINT)(pCur - _buffer - 1);
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::EatPara, private
//
//  Synopsis:   Skip till the line feed
//
//--------------------------------------------------------------------------

WCHAR * Document::EatPara( WCHAR * pCur )
{
    // search for newline or null
    int pos = 0;
    int c;

    while ( pCur < _bufEnd
            && (c = *pCur) != L'\n'
            && c != L'\r'
            && c != L'\0'
            && c != UNICODE_PARAGRAPH_SEPARATOR )
    {
        pos++;
        pCur++;
    }
    // eat newline and/or carriage return
    pCur++;
    if ( pCur < _bufEnd
         && *(pCur-1) == L'\r'
         && *pCur == L'\n' )
         pCur++;

    if ( pos > _maxParaLen )
        _maxParaLen = pos;
    return pCur;
}

int BreakLine ( WCHAR* buf, int cwcBuf, int cwcMax )
{
    if (cwcBuf <= cwcMax)
        return cwcBuf;
    Win4Assert (cwcMax > 0);
    // look backwards for whitespace
    int len = cwcMax;
    int c = buf[len-1];
    while (c != L' ' && c != L'\t')
    {
        len--;
        if (len < 1)
            break;
        c = buf[len-1];
    }
    if (len == 0)
    {
        // a single word larger than screen width
        // try scanning forward
        len = cwcMax;
        c = buf[len];
        while (c != L' ' && c != L'\t')
        {
            len++;
            if (len == cwcBuf)
                break;
            c = buf[len];
        }
    }
    return len;
}

const int MAX_LINE_LEN = 110;

void Document::BreakLines()
{
    _aParaLine = new ParaLine [_cPara];
    for (int i = 0; i < _cPara; i++)
    {
        int cwcLeft = _aParaOffset[i+1] - _aParaOffset[i];

        if (cwcLeft < MAX_LINE_LEN)
            _aParaLine[i].offEnd = cwcLeft;
        else
        {
            ParaLine* pParaLine = &_aParaLine[i];
            WCHAR* buf = _buffer + _aParaOffset[i];
            int cwcOffset = 0;

            for (;;)
            {
                int cwcLine = BreakLine ( buf + cwcOffset, cwcLeft, MAX_LINE_LEN );
                cwcOffset += cwcLine;
                pParaLine->offEnd = cwcOffset;
                cwcLeft -= cwcLine;
                if (cwcLeft == 0)
                    break;
                pParaLine->next = new ParaLine;
                pParaLine = pParaLine->next;
            };
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::GetLine, public
//
//  Arguments:  [nPara] -- paragraph number
//              [off] -- offset within paragraph
//              [cwc] -- in/out chars to copy / copied
//              [buf] -- target buffer
//
//  Synopsis:   Copy text from paragraph to buffer
//
//--------------------------------------------------------------------------


BOOL Document::GetLine(int nPara, int off, int& cwc, WCHAR* buf)
{
    Win4Assert (_buffer != 0);
    if (nPara >= _cPara)
        return FALSE;

    const WCHAR * pText = _buffer + _aParaOffset[nPara] + off;

    // _aParaOffset [_cPara] is the offset of the end of buffer
    int cwcPara = _aParaOffset[nPara+1] - (_aParaOffset[nPara] + off);

    cwc = __min ( cwc, cwcPara );
    memcpy ( buf, pText, cwc * sizeof(WCHAR));
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     Document::GetWord, public
//
//  Synopsis:
//  Copy the string into buffer
//
//--------------------------------------------------------------------------

void Document::GetWord(int nPara, int offSrc, int cwcSrc, WCHAR* buf)
{
    Win4Assert (_buffer != 0);
    Win4Assert ( nPara < _cPara );

    WCHAR * p = _buffer + _aParaOffset[nPara];

    Win4Assert ( p + offSrc + cwcSrc <= _bufEnd );

    memcpy ( buf, p + offSrc, cwcSrc * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\lview.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       lview.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//
// Window procedure for ListView
//

LRESULT WINAPI ListViewWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    CListView *pControl = (CListView *) GetWindowLongPtr(hwnd, 0);
    LRESULT lRet = 0;

    switch (msg)
    {
        case WM_CREATE :
            pControl = new CListView;
            pControl->Create (GetParent(hwnd), hwnd);
            SetWindowLongPtr (hwnd, 0, (LONG_PTR) pControl);
            break;
        case WM_DESTROY :
            delete pControl;
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
            break;
        case WM_SETFONT:
            pControl->SetFont ((HFONT)wParam);
            break;
        case WM_SETFOCUS:
            pControl->SetFocus();
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
            break;
        case wmInsertItem:
            pControl->InsertItem ((int)lParam);
            break;
        case wmDeleteItem:
            pControl->DeleteItem ((int)lParam);
            break;
        case wmUpdateItem:
            pControl->InvalidateItem ((int)lParam);
            break;

        case wmSetCountBefore:
            pControl->SetCountBefore ((int)lParam);
            break;
        case wmSetCount:
            pControl->SetTotalCount ((int)lParam);
            break;
        case wmResetContents:
            pControl->ResetContents();
            break;

        case WM_SIZE:
            pControl->Size (wParam, LOWORD(lParam), HIWORD(lParam));
            break;
        case WM_PAINT:
            {
                PAINTSTRUCT paint;
                BeginPaint ( hwnd, &paint );
                pControl->Paint (paint);
                EndPaint(hwnd, &paint );
            }
            break;
        case WM_LBUTTONUP:
            pControl->ButtonUp(HIWORD(lParam));
            break;
        case WM_LBUTTONDOWN:
            pControl->ButtonDown(HIWORD(lParam));
            break;
        case WM_LBUTTONDBLCLK:
            SendMessage (pControl->Parent(),
                        WM_COMMAND,
                        MAKEWPARAM(idListChild, LBN_DBLCLK),
                        (LPARAM) hwnd);
            break;
        case WM_KEYDOWN:
            pControl->KeyDown ((int)wParam);
            break;
        case WM_VSCROLL:
            pControl->Vscroll ((int)LOWORD(wParam), (int)HIWORD(wParam));
            break;
        case WM_MOUSEWHEEL :
            lRet = pControl->MouseWheel( hwnd, wParam, lParam );
            break;
        case wmContextMenuHitTest:
            lRet = pControl->ContextMenuHitTest( wParam, lParam );
            break;
        default :
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
            break;
    }

    return lRet;
} //ListViewWndProc

CListView::CListView ()
: _hwndParent(0),
  _hwnd(0),
  _cBefore(0),
  _cTotal (0),
  _cx(0),
  _cy(0),
  _cyLine(1),
  _cLines(0),
  _hfont(0),
  _iWheelRemainder(0)
{}

LRESULT CListView::MouseWheel(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    // forward what we don't process

    if ( wParam & ( MK_SHIFT | MK_CONTROL ) )
        return DefWindowProc( hwnd, WM_MOUSEWHEEL, wParam, lParam );

    // add the current scroll to the remainder from last time

    int iDelta = (int) (short) HIWORD( wParam );
    iDelta += _iWheelRemainder;

    // if there isn't enough to process this time, just return

    if ( abs( iDelta ) < WHEEL_DELTA )
    {
        _iWheelRemainder = iDelta;
        return 0;
    }

    // compute the remainder and amount to scroll

    _iWheelRemainder = ( iDelta % WHEEL_DELTA );
    iDelta /= WHEEL_DELTA;

    BOOL fDown;
    if ( iDelta < 0 )
    {
        fDown = TRUE;
        iDelta = -iDelta;
    }
    else
        fDown = FALSE;

    // get the # of lines to scroll per WHEEL_DELTA

    int cLines;
    SystemParametersInfo( SPI_GETWHEELSCROLLLINES, 0, &cLines, 0 );
    if ( 0 == cLines )
        return 0;

    int cVisibleLines = _cLines;

    // if scrolling a page, do so.  don't scroll more than one page

    if ( WHEEL_PAGESCROLL == cLines )
        iDelta = __max( 1, (cVisibleLines - 1) );
    else
    {
        iDelta *= cLines;
        if ( iDelta >= cVisibleLines )
            iDelta = __max( 1, (cVisibleLines - 1) );
    }

    // phew.  do the scroll

    if ( 0 != iDelta )
    {
        if ( fDown )
            _GoDown( iDelta );
        else
            _GoUp( iDelta );
    }

    return iDelta;
} //MouseWheel

LRESULT CListView::ContextMenuHitTest(
    WPARAM wParam,
    LPARAM lParam )
{
    POINT pt;

    // cast required to sign extend [multimon bug]
    pt.x = (LONG)(short)LOWORD( lParam );
    pt.y = (LONG)(short)HIWORD( lParam );

    RECT rc;
    GetWindowRect( _hwnd, &rc );

    // did they click in the window?

    if ( !PtInRect( &rc, pt ) )
        return -1;

    // convert y to window view coordinates

    int vy = pt.y - rc.top;

    // did they click on a line in the window?

    int line = vy / _cyLine;
    int newLine = line;
    if ( line >= _cLines || line >= _cTotal )
        return -1;

    // make this line the current selection

    ButtonDown( vy );

    return line;
} //ContextMenuHitTest

//
// Create
//

void CListView::Create (HWND hwndParent, HWND hwnd)
{
    _hwndParent = hwndParent;
    _hwnd = hwnd;
    MEASUREITEMSTRUCT measure;
    measure.CtlType = odtListView;
    //
    // Owner: Measure item!
    //
    SendMessage (_hwndParent, wmMeasureItem, 0, (LPARAM) &measure);
    _cyLine = measure.itemHeight;
} //Create

//
// Key Down
//

void CListView::KeyDown (int nKey)
{
    switch (nKey)
    {
        case ' ' :
            ButtonDown( 0 );
            break;
        case 11:
        case 13:
            // treat ENTER as a double-click
            //
            // Owner: Double click!
            //
            SendMessage (_hwndParent, WM_COMMAND, MAKEWPARAM(idListChild, LBN_DBLCLK), (LPARAM) _hwnd);
            break;
        //
        // Translate keystrokes into scrolling actions
        //
        case VK_HOME:
            SendMessage (_hwnd, WM_VSCROLL, SB_TOP, 0L);
            break;
        case VK_END:
            SendMessage (_hwnd, WM_VSCROLL, SB_BOTTOM, 0L);
            break;
        case VK_PRIOR:
            SendMessage (_hwnd, WM_VSCROLL, SB_PAGEUP, 0L);
            break;
        case VK_NEXT:
            SendMessage (_hwnd, WM_VSCROLL, SB_PAGEDOWN, 0L);
            break;
        case VK_UP:
            SelectUp ();
            break;
        case VK_DOWN:
            SelectDown ();
            break;
    }
} //KeyDown

void CListView::UpdateHighlight(
    int oldLine,
    int newLine )
{
    // unhighlight
    if ( -1 != oldLine )
        RefreshRow( oldLine );

     // highlight
    if ( oldLine != newLine )
        RefreshRow( newLine );

    UpdateWindow (_hwnd);
} //UpdateHighlight

void CListView::SelectUp ()
{
    int newLine;

    if ( SendMessage( _hwndParent, wmListNotify, listSelectUp, (LPARAM)&newLine ))
        UpdateHighlight( newLine + 1, newLine );
} //SelectUp

void CListView::SelectDown ()
{
    int newLine;

    if ( SendMessage( _hwndParent, wmListNotify, listSelectDown, (LPARAM)&newLine ))
        UpdateHighlight( newLine - 1, newLine );
} //SelectDown

//
// Button up (select)
//

void CListView::ButtonUp (int y)
{
}

void CListView::ButtonDown (int y)
{
    int line = y / _cyLine;
    int newLine = line;
    if (line >= _cLines)
        return;
    //
    // Owner: Selection made!
    //
    if (SendMessage (_hwndParent, wmListNotify, listSelect, (LPARAM)&line ))
        UpdateHighlight( line, newLine );

    ::SetFocus (_hwnd);
} //ButtonDown

void CListView::SetFocus()
{
    //
    // Owner: Focus!
    //
    SendMessage (_hwndParent, WM_COMMAND, MAKEWPARAM(idListChild, LBN_SETFOCUS), (LPARAM) _hwnd);
} //SetFocus

//
// Size
//

void CListView::Size (WPARAM flags, int cx, int cy)
{
    int cxOld = _cx;
    int cyOld = _cy;
    _cx = cx;
    _cy = cy;

    BOOL fInvalidate = FALSE;

    if (cy != cyOld)
    {
        _cLines = cy / _cyLine;
        //
        // Owner: Size!
        //
        long cRows = _cLines;
        fInvalidate = (BOOL)SendMessage(_hwndParent, wmListNotify, listSize, (LPARAM) &cRows);
    }

    // Don't repaint the common area

    RECT rect;
    rect.top = 0;
    rect.left = 0;
    rect.bottom = min (cy, cyOld);
    rect.right = min (cx, cxOld);

    // no need -- user does this for free, and it causes repaint bugs
    // ValidateRect (_hwnd, &rect );

    if (cy != cyOld)
    {
        if ( fInvalidate )
            InvalidateAndUpdateScroll();
        else
            UpdateScroll();
    }
} //Size

//
// Paint
//

void CListView::Paint (PAINTSTRUCT& paint)
{
    RECT& rect = paint.rcPaint;
    int lineStart = rect.top / _cyLine;
    int lineEnd = (rect.bottom + _cyLine - 1) / _cyLine;
    DRAWITEMSTRUCT draw;
    draw.hwndItem = _hwnd;
    draw.itemAction = ODA_DRAWENTIRE;
    HDC hdc = paint.hdc;
    draw.hDC = hdc;
    HFONT hfontOld = (HFONT) SelectObject (hdc, _hfont);

    for (int i = lineStart; i < lineEnd; i++)
    {
        draw.itemState = 0;

        if ( GetFocus() == _hwnd )
            draw.itemState |= ODS_FOCUS;

        draw.itemID = i;
        draw.rcItem.top = 0;
        draw.rcItem.left = 0;
        draw.rcItem.bottom = _cyLine;
        draw.rcItem.right = _cx;

        SetViewportOrgEx( hdc, 0, i * _cyLine, 0 );
        //
        // Owner: Draw item!
        //
        SendMessage (_hwndParent, wmDrawItem, 0, (LPARAM)&draw);
    }
    SelectObject (hdc, hfontOld);
} //Paint

//
// Set Font
//

void CListView::SetFont (HFONT hfontNew)
{
    _hfont = hfontNew;
    MEASUREITEMSTRUCT measure;
    measure.CtlType = odtListView;
    //
    // Owner: Measure item
    //
    SendMessage (_hwndParent, wmMeasureItem, 0, (LPARAM) &measure);
    _cyLine = measure.itemHeight;
    long cRows = (_cy + _cyLine - 1) / _cyLine;
    _cLines = cRows;
    //
    // Owner: Size
    //
    SendMessage(_hwndParent, wmListNotify, listSize, (LPARAM) &cRows);
    InvalidateAndUpdateScroll();
} //SetFont


//
// Scrolling
//

void CListView::Vscroll ( int action, int nPos)
{
    switch (action)
    {
        case SB_LINEUP:
            LineUp ();
            break;
        case SB_LINEDOWN:
            LineDown ();
            break;
        case SB_THUMBTRACK:
            // don't refresh when thumb dragging
            // over many hits (too expensive)
            break;

        case SB_THUMBPOSITION:
            ScrollPos (nPos);
            break;
        case SB_PAGEDOWN:
            PageDown ();
            break;
        case SB_PAGEUP:
            PageUp ();
            break;
        case SB_TOP:
            Top ();
            break;
        case SB_BOTTOM:
            Bottom ();
            break;

    }
} //VScroll

void CListView::LineUp ()
{
    long cLine = 1;
    //
    // Owner: Line up!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollLineUp, (LPARAM) &cLine);
    if (cLine == 1)
    {
        if (_cBefore != 0)
            _cBefore--;

        // Force scroll and redraw
        RECT rect;
        GetClientRect (_hwnd, &rect);
        MyScrollWindow (_hwnd, 0, _cyLine, &rect, &rect);
        UpdateScroll();
    }
} //LineUp

void CListView::LineDown ()
{
    long cLine = 1;
    //
    // Owner: Line down!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollLineDn, (LPARAM) &cLine);
    if (cLine == 1)
    {
        RECT rect;
        GetClientRect (_hwnd, &rect);
        MyScrollWindow (_hwnd, 0, -_cyLine, &rect, &rect);
        _cBefore++;
        UpdateScroll();
    }
} //LineDown

void CListView::_GoUp(
    long cToGo )
{
    CWaitCursor wait;

    long count = cToGo;

    count = __min( count, _cBefore );

    //
    // Owner: Page up!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollPageUp, (LPARAM) &count);

    // _cBefore is approximate; don't give up if it is too big

    if ( 0 == count )
    {
        if ( _cBefore > 0 )
            count = _cBefore - 1;
        else
            count = 1; // worst case; scroll up one line

        SendMessage( _hwndParent,
                     wmListNotify,
                     listScrollPageUp,
                     (LPARAM) &count );
    }

    // gee, we're having a bad hair day

    if ( 0 == count )
    {
        count = 1; // worst case; scroll up one line

        SendMessage( _hwndParent,
                     wmListNotify,
                     listScrollPageUp,
                     (LPARAM) &count );
    }

    if ( 0 != count )
    {
        // count == number of lines open at the top
        _cBefore -= count;
        if (_cBefore < 0)
            _cBefore = 0;
        InvalidateAndUpdateScroll();
    }
} //_GoUp

void CListView::PageUp ()
{
    _GoUp( _cLines - 1 );
} //PageUp

void CListView::_GoDown(
    long cToGo )
{
    CWaitCursor wait;

    long count = cToGo;
    //
    // Owner: Page Down!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollPageDn, (LPARAM) &count);
    // count == number of lines open at the bottom

    if ( 0 != count )
    {
        _cBefore += count;
        if (_cBefore >= ( _cTotal - _cLines ) )
            _cBefore = ( _cTotal - _cLines );
        InvalidateAndUpdateScroll();
    }
} //_GoDown

void CListView::PageDown ()
{
    _GoDown( _cLines - 1 );
} //PageDown

void CListView::Top ()
{
    long count = _cLines;
    //
    // Owner: Top!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollTop, (LPARAM) &count );
    _cBefore = 0;
    InvalidateAndUpdateScroll();
} //Top

void CListView::Bottom ()
{
    long count = _cLines;
    //
    // Owner: Bottom!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollBottom,  (LPARAM) &count);
    // count == number of lines visible
    _cBefore = _cTotal - count;
    if (_cBefore < 0)
        _cBefore = 0;
    InvalidateAndUpdateScroll();
} //Bottom

void CListView::ScrollPos (int pos)
{
    long iRow = pos;
    //
    // Owner: Scroll Position!
    //
    SendMessage(_hwndParent, wmListNotify, listScrollPos, (LPARAM) &iRow);
    if (iRow != -1)
    {
        _cBefore = iRow;
        InvalidateAndUpdateScroll();
    }
} //ScrollPos


//
// Message: Reset Contents
//

void CListView::ResetContents()
{
    _cBefore = 0;
    _cTotal = 0;
    UpdateScroll();

    RECT rect;
    GetClientRect (_hwnd, &rect);
    InvalidateRect (_hwnd, &rect, TRUE );
    UpdateWindow (_hwnd);
} //ResetContents

void CListView::InvalidateAndUpdateScroll()
{
    RECT rect;
    GetClientRect (_hwnd, &rect);
    InvalidateRect (_hwnd, &rect, TRUE );

    UpdateScroll();
} //InvalidateAndUpdateScroll

//
// Message: Insert item after iRow
//

void CListView::InsertItem (int iRow)
{
    Win4Assert (iRow < _cLines );
    RECT rect;
    GetClientRect (_hwnd, &rect);
    rect.top = (iRow + 1) * _cyLine;
    MyScrollWindow( _hwnd, 0, _cyLine, &rect, &rect, FALSE );
    _cTotal++;
    UpdateWindow (_hwnd);
    UpdateScroll();
} //InsertItem

//
// Message: Delete item
//

void CListView::DeleteItem (int iRow)
{
    Win4Assert (iRow < _cLines );
    RECT rect;

    GetClientRect (_hwnd, &rect);
    rect.top = (iRow + 1) * _cyLine;
    MyScrollWindow( _hwnd, 0, -_cyLine, &rect, &rect, FALSE );

    _cTotal--;
    if (_cTotal < 0)
        _cTotal = 0;

    // Invalidate the area which was
    // scrolled up (the last row before scrolling), if visible
    if ( _cTotal && _cTotal < _cLines )
    {
        RefreshRow( _cTotal );
    }

    UpdateScroll();
} //DeleteItem

//
// Message: Invalidate item
//

void CListView::InvalidateItem (int iRow)
{
    Win4Assert (iRow <= _cLines );
    RefreshRow (iRow);
    UpdateWindow (_hwnd);
} //InvalidateItem

//
// Message: Set count before
//

void CListView::SetCountBefore (int cBefore)
{
    _cBefore = cBefore;
    SetScrollPos (_hwnd, SB_VERT, _cBefore, TRUE);
} //SetCountBefore

//
// Message: Set total count
//

void CListView::SetTotalCount (int cTotal)
{
    _cTotal = cTotal;
    UpdateScroll ();
} //SetTotalCount



//
// Internal methods
//

void CListView::RefreshRow (int iRow)
{
    Win4Assert ( iRow < _cLines );
    RECT rect;
    rect.top = iRow * _cyLine;
    rect.left = 0;
    rect.bottom = rect.top + _cyLine;
    rect.right = _cx;
    InvalidateRect (_hwnd, &rect, TRUE );
} //RefreshRow

void CListView::UpdateScroll()
{
    if (_cTotal - _cLines >= 0)
    {
        ShowScrollBar( _hwnd, SB_VERT, TRUE );
        SetScrollRange (_hwnd, SB_VERT, 0, _cTotal - 1, FALSE);
        SetScrollPos (_hwnd, SB_VERT, _cBefore, TRUE);

        // proportional scroll box
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_PAGE;
        si.nPage = _cLines;
        SetScrollInfo( _hwnd, SB_VERT, &si, TRUE );

        EnableScrollBar (_hwnd, SB_VERT, ESB_ENABLE_BOTH );
    }
    else
    {
        _cBefore = 0;

        ShowScrollBar( _hwnd, SB_VERT, FALSE );
        EnableScrollBar (_hwnd, SB_VERT, ESB_DISABLE_BOTH );
    }
} //UpdateScroll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ddeml.h>
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>
#include <wininet.h>

#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <direct.h>
#include <crt\io.h>
#include <eh.h>

#define _CAIROSTG_
#define _DCOM_

#include <oleext.h>
#include <oledberr.h>
#include <filterr.h>
#include <cierror.h>
#include <oledb.h>
#include <ciodm.h>
#include <oledbdep.h>
#include <cmdtree.h>
#include <query.h>
#include <ciintf.h>
#include <ntquery.h>

// srch-specific includes

#include "minici.hxx"
#include "srch.hxx"
#include "browser.hxx"
#include "srchmenu.hxx"
#include "srchdlg.hxx"
#include "watch.hxx"
#include "srchq.hxx"
#include "view.hxx"
#include "lview.hxx"
#include "srchwnd.hxx"

#define SQLTEXT ISQLANG_V2 + 1

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\brview.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       brview.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheModel _layout.GetModel()

#define UNICODE_PARAGRAPH_SEPARATOR 0x2029

const int BUFLEN = 256;
WCHAR LineBuffer[BUFLEN];

const int cpLeftMargin = 3;

int TrimEOL (WCHAR * pwcLine, int cwcLine)
{
    // If the line ends in \r\n or \n, don't include that in the length.
    // TabbedTextOut() prints garbage when it sees \r or \n

    if ((cwcLine >= 2) && (pwcLine[cwcLine - 2] == L'\r'))
        cwcLine -= 2;
    else if ((cwcLine >= 1) &&
             ((pwcLine[cwcLine - 1] == L'\r') ||
              (pwcLine[cwcLine - 1] == UNICODE_PARAGRAPH_SEPARATOR) ||
              (pwcLine[cwcLine - 1] == L'\n')))
        cwcLine--;

    return cwcLine;
} //TrimEOL

void TextMetrics::GetSizes ( CharDim& dim )
{
    dim.cxChar = _tm.tmAveCharWidth;
    dim.cyChar = _tm.tmHeight + _tm.tmExternalLeading;
} //GetSizes

void View::_NoSelection()
{
    _Selection.None();
} //NoSelection

void View::_UpdateSelection(
    LPARAM lParam )
{
    int x = (int) (short) LOWORD( lParam );
    int y = (int) (short) HIWORD( lParam );
    if ( y < 0 )
        y = 0;
    else if ( y > _cyClient )
        y = _cyClient;
    int para, o;
    GetParaAndOffset( x, y, para, o );

    if ( _fStartIsAnchor )
    {
        if ( ( para < _Selection.ParaStart() ) ||
             ( ( para == _Selection.ParaStart() ) &&
               ( o < _Selection.OffStart() ) ) )
        {
            _Selection.SetEnd( _Selection.ParaStart(), _Selection.OffStart() );
            _Selection.SetStart( para, o );
            _fStartIsAnchor = FALSE;
        }
        else
        {
            _Selection.SetEnd( para, o );
        }
    }
    else
    {
        if ( ( para > _Selection.ParaEnd() ) ||
             ( ( para == _Selection.ParaEnd() ) &&
               ( o > _Selection.OffEnd() ) ) )
        {
            _Selection.SetStart( _Selection.ParaEnd(), _Selection.OffEnd() );
            _Selection.SetEnd( para, o );
            _fStartIsAnchor = TRUE;
        }
        else
        {
            _Selection.SetStart( para, o );
        }
    }

    if ( _fFullSelRepaint )
    {
        InvalidateRect( _hwnd, NULL, FALSE );
        _fFullSelRepaint = FALSE;
    }
    else
    {
        int yMin = __min( y, _cpLastSelY );
        int yMax = __max( y, _cpLastSelY );
    
        RECT rc;
        rc.left = 0;
        rc.right = _cxClient;
        rc.top = yMin - LineHeight();
        rc.bottom = yMax + LineHeight();
    
        InvalidateRect( _hwnd, &rc, FALSE );
    }

    _cpLastSelY = y;
} //_UpdateSelection

void View::ButtonUp( WPARAM wParam, LPARAM lParam )
{
    _fSelecting = FALSE;
    if ( GetCapture() == _hwnd )
        ReleaseCapture();

    if ( _fDblClk )
        return;

    if ( _Selection.IsNull() )
    {
        _Selection.None();
        return;
    }
    else
    {
        _UpdateSelection( lParam );
    }
} //ButtonUp

void View::MouseMove( WPARAM wParam, LPARAM lParam )
{
    if ( _fSelecting &&
         ( wParam & MK_LBUTTON ) )
        _UpdateSelection( lParam );
} //MouseMove

void View::ButtonDown( WPARAM wParam, LPARAM lParam )
{
    BOOL fOldSel = _Selection.SelectionExists();

    _fDblClk = FALSE;
    SetCapture( _hwnd );
    _fStartIsAnchor = TRUE;
    _fSelecting = TRUE;
    _NoSelection();
    int x = LOWORD( lParam );
    int y = HIWORD( lParam );
    _cpLastSelY = y;
    int para, o;
    GetParaAndOffset( x, y, para, o );
    _Selection.SetStart( para, o );
    _fFullSelRepaint = FALSE;

    if ( fOldSel )
        InvalidateRect( _hwnd, NULL, FALSE );
} //ButtonDown

int GetCharOffset(
    HDC     hdc,
    int     iClickX,
    WCHAR * pwcLine,
    int     cwcLine,
    int     cpLeft )
{
    // a click in the left margin counts

    if ( 0 != cwcLine && iClickX < cpLeft )
        return 0;

    int l = cpLeft;

    for ( int c = 0; c < cwcLine; c++ )
    {
        int dx = LOWORD( GetTabbedTextExtent( hdc, pwcLine, 1 + c, 0, 0 ) );

        if ( iClickX >= l && iClickX <= dx + cpLeft )
            break;

        l = dx + cpLeft;
    }

    return c;
} //GetCharOffset

void View::GetParaAndOffset(
    int x,
    int y,
    int & para,
    int & offset )
{
    offset = 0;
    HDC hdc = GetDC( _hwnd );

    if ( 0 == hdc )
        return;

    HFONT hOldFont = (HFONT) SelectObject( hdc, _layout.Font() );

    para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph

    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph
    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) )
    {
        do
        {
            int top = _layout.Y ( line );
            int bottom = top + _layout.CyChar();

            if ( y >= top && y <= bottom )
            {
                // got the line, now find the word selected

                int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );

                if ( TheModel.GetLine(para, paOffBeg, cwcLine, LineBuffer ) )
                {
                    cwcLine = TrimEOL( LineBuffer, cwcLine );
                    offset = paOffBeg + GetCharOffset( hdc,
                                                       x,
                                                       LineBuffer,
                                                       cwcLine,
                                                       cpLeftMargin );
                }
                goto cleanup;
            }

            line++;
            if (line >= _layout.MaxLines())
                goto cleanup;
            paLine++;
        } while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) );

        // next paragraph
        para++;
        paLine = 0;
    }

cleanup:
    SelectObject( hdc, hOldFont );
    ReleaseDC( _hwnd, hdc );
} //GetParaAndOffset

void View::EditCopy( HWND hwnd, WPARAM wParam )
{
    if ( _Selection.SelectionExists() )
    {
        // is everything in one paragraph? -- easy case

        if ( _Selection.IsInOnePara() )
        {
            int cwcLine = __min ( BUFLEN,
                                  _Selection.OffEnd() - _Selection.OffStart() );
            TheModel.GetLine( _Selection.ParaStart(),
                              _Selection.OffStart(),
                               cwcLine, LineBuffer );
            cwcLine = TrimEOL( LineBuffer, cwcLine );
            LineBuffer[cwcLine] = 0;
    
            PutInClipboard( LineBuffer );
        }
        else
        {
            // compute how much text to copy

            int cwcTotal = 0;
    
            for ( int p = _Selection.ParaStart();
                  p <= _Selection.ParaEnd();
                  p++ )
            {
                int cwcLine = BUFLEN;
                if ( p == _Selection.ParaStart() )
                {
                    TheModel.GetLine( p, _Selection.OffStart(),
                                      cwcLine, LineBuffer );
                }
                else if ( p == _Selection.ParaEnd() )
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                    cwcLine = _Selection.OffEnd();
                }
                else
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                }
                cwcTotal += cwcLine;
            }

            // allocate a buffer and copy the text

            XArray<WCHAR> aClip( cwcTotal + 1 );
            WCHAR *pwc = (WCHAR *) aClip.GetPointer();

            cwcTotal = 0;

            for ( p = _Selection.ParaStart();
                  p <= _Selection.ParaEnd();
                  p++ )
            {
                int cwcLine = BUFLEN;
                if ( p == _Selection.ParaStart() )
                {
                    TheModel.GetLine( p, _Selection.OffStart(),
                                      cwcLine, LineBuffer );
                }
                else if ( p == _Selection.ParaEnd() )
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                    cwcLine = _Selection.OffEnd();
                }
                else
                {
                    TheModel.GetLine( p, 0, cwcLine, LineBuffer );
                }
                LineBuffer[cwcLine] = 0;
                wcscpy( pwc + cwcTotal, LineBuffer );
                cwcTotal += cwcLine;
            }
    
            PutInClipboard( pwc );
        }
    }
} //EditCopy

BOOL isWhite( WCHAR c )
{
    // well, actually white space and C++ break characters

    return ( L' ' == c ||
             L'\r' == c ||
             L'\n' == c ||
             L'\t' == c ||
             L'\\' == c ||
             L'\'' == c ||
             L'\"' == c ||
             L':' == c ||
             L';' == c ||
             L',' == c ||
             L'[' == c ||
             L']' == c ||
             L'{' == c ||
             L'}' == c ||
             L'(' == c ||
             L')' == c ||
             L'/' == c ||
             L'+' == c ||
             L'-' == c ||
             L'=' == c ||
             L'*' == c ||
             L'^' == c ||
             L'~' == c ||
             L'&' == c ||
             L'!' == c ||
             L'?' == c ||
             L'<' == c ||
             L'>' == c ||
             L'.' == c ||
             L'|' == c ||
             UNICODE_PARAGRAPH_SEPARATOR == c );
} //isWhite

BOOL GetSelectedWord(
    HDC hdc,
    int iClickX,
    WCHAR *pwcLine,
    int cwcLine,
    int cpLeft,
    int &rStart,
    int &rEnd )
{
    // what character had the click?

    int c = GetCharOffset( hdc, iClickX, pwcLine, cwcLine, cpLeft );

    // move left and right till white space is found

    if ( c != cwcLine )
    {
        rEnd = c;

        while ( rEnd < (cwcLine - 1) && !isWhite( pwcLine[ rEnd ] ) )
            rEnd++;

        // selection doesn't include end

        if ( ( rEnd == ( cwcLine - 1 ) ) &&
             ( !isWhite( pwcLine[ rEnd ] ) ) )
            rEnd++;

        rStart = c;
        while ( rStart > 0 && !isWhite( pwcLine[ rStart ] ) )
            rStart--;

        // don't include white space if not at start of line

        if ( rStart < c && isWhite( pwcLine[ rStart ] ) )
            rStart++;

        // did we grab anything?

        return ( rEnd > rStart );
    }
    else
    {
        return FALSE;
    }
} //GetSelectedWord

int View::ParaFromY(
    int y )
{
    int para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph

    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph
    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) )
    {
        do
        {
            int top = _layout.Y( line );
            int bottom = top + _layout.CyChar();

            if ( y >= top && y <= bottom )
            {
                return 1 + para;
            }

            line++;
            if (line >= _layout.MaxLines())
                return _layout.FirstPara();
            paLine++;
        } while ( _layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ) );

        // next paragraph
        para++;
        paLine = 0;
    }

    return _layout.FirstPara();
} //ParaFromY

void View::DblClk( WPARAM wParam, LPARAM lParam )
{
    _fDblClk = TRUE;

    BOOL fCtrl = ( 0 != ( 0x8000 & GetAsyncKeyState( VK_CONTROL ) ) );

    int x = LOWORD( lParam );
    int y = HIWORD( lParam );

    Selection oldSel( _Selection );
    _Selection.None();

    HDC hdc = GetDC( _hwnd );

    if ( 0 == hdc )
        return;

    HFONT hOldFont = (HFONT) SelectObject( hdc, _layout.Font() );

    int para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph

    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph
    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while (_layout.GetLineOffsets ( para, paLine, paOffBeg, paOffEnd ))
    {
        do
        {
            int top = _layout.Y ( line );
            int bottom = top + _layout.CyChar();

            if ( y >= top && y <= bottom )
            {
                // if ctrl key is down, attempt to fire up an editor

                if ( fCtrl )
                {
                    ViewFile( _pModel->Filename(), fileEdit, 1+para );
                    goto cleanup;
                }

                // got the line, now find the word selected

                int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );

                if ( TheModel.GetLine(para, paOffBeg, cwcLine, LineBuffer ) )
                {
                    cwcLine = TrimEOL( LineBuffer, cwcLine );

                    int iStart, iEnd;

                    if ( GetSelectedWord( hdc,
                                          x,
                                          LineBuffer,
                                          cwcLine,
                                          cpLeftMargin,
                                          iStart,
                                          iEnd ) )
                        _Selection.Set( para,
                                        paOffBeg + iStart,
                                        para,
                                        paOffBeg + iEnd );

                    RECT rc;
                    rc.left = 0; rc.right = _cxClient;
                    rc.top = top; rc.bottom = bottom;
                    InvalidateRect( _hwnd, &rc, FALSE );
                }
            }
            else if ( oldSel.IsInSelection( para ) )
            {
                RECT rc;
                rc.left = 0; rc.right = _cxClient;
                rc.top = top; rc.bottom = bottom;
                InvalidateRect( _hwnd, &rc, FALSE );
            }

            line++;
            if (line >= _layout.MaxLines())
                goto cleanup;
            paLine++;
        } while (_layout.GetLineOffsets (para, paLine, paOffBeg, paOffEnd ));

        // next paragraph
        para++;
        paLine = 0;
    }

cleanup:

    SelectObject( hdc, hOldFont );
    ReleaseDC( _hwnd, hdc );

    UpdateWindow( _hwnd );
} //DblClk

void View::Size ( int cx, int cy )
{
    _cyClient = cy;
    _cxClient = cx;
}

void View::SetScrollMax ()
{
    int linesFromEnd = _cyClient / _layout.CyChar() - 2;
    int cline;
    for (int para = TheModel.Paras() - 1; para >= 0; para--)
    {
        cline = _layout.LinesInPara(para);
        if (linesFromEnd < cline)
            break;
        linesFromEnd -= cline;
    }

    _paraVScrollMax = TheModel.Paras() - 1;

    if ( _paraVScrollMax < 0 )
    {
        _paraVScrollMax = 0;
        _paLineVScrollMax = 0;
    }
    else
    {
        _paLineVScrollMax = cline - 1 - linesFromEnd;
    }
}

void View::SetRange ( int maxParaLen, int cParas )
{
    _layout.SetParaRange(cParas);
#if 0
    _nHScrollMax = 2 + maxParaLen - _cxClient / _layout.CxChar();
    if ( _nHScrollMax < 0 )
#endif
        _nHScrollMax = 0;
}

void View::SetScroll( Position & pos )
{
    _fFullSelRepaint = TRUE;

    int paLine, paOffBeg, paOffEnd;
    _layout.Locate (pos.Para(), pos.BegOff(), paLine, paOffBeg, paOffEnd);
    if (paLine >= 3)
    {
        _paraVScroll = pos.Para();
        _paLineVScroll = paLine - 3;
    }
    else
    {
        // show last line of prev para
        int iOffset = ( 0 == _cyClient ) ? 6 : ( VisibleLines() / 3 );
        _paraVScroll = pos.Para() - iOffset;

        if (_paraVScroll >= 0 )
        {
            _paLineVScroll = _layout.LinesInPara(_paraVScroll) - 1;
        }
        else
        {
            _paraVScroll = 0;
            _paLineVScroll = 0;
        }
    }

#if 0
    if ( pos.EndOff() - _nHScrollPos + 1 > _cxClient / _layout.CxChar() )
        _nHScrollPos =  pos.EndOff() - _cxClient / _layout.CxChar() + 1;
    else
        _nHScrollPos = 0;
    _nHScrollPos = min ( _nHScrollPos, _nHScrollMax );
#else
    _nHScrollPos = 0;
#endif
}


int View::JumpToPara ( int para )
{
    _fFullSelRepaint = TRUE;

    int delta = 0;
    int paraStart;
    int paraEnd;
    if (para == _paraVScroll)
    {
        return 0;
    }
    else if (para < _paraVScroll)
    {
        // jumping backwards, delta negative
        delta = -_paLineVScroll;
        for ( int p = _paraVScroll - 1; p >= para; p--)
            delta -= _layout.LinesInPara(p);

    }
    else
    {
        // jumping forward, delta positive
        delta = _layout.LinesInPara(_paraVScroll) - _paLineVScroll;
        for (int p = _paraVScroll + 1; p < para; p++)
            delta += _layout.LinesInPara(p);
    }
    _paraVScroll = para;
    _paLineVScroll = 0;
    // return delta from previous position
    return delta;
}

int View::IncVScrollPos ( int cLine )
{
    _fFullSelRepaint = TRUE;

    int para;

    if (cLine >= 0)
    {
        // first back up to the beginning
        // of the current para
        int cLineLeft = cLine + _paLineVScroll;
        // move forward
        for (para = _paraVScroll; para <= _paraVScrollMax; para++)
        {
            int ln = _layout.LinesInPara(para);
            if (cLineLeft < ln)
                break;
            cLineLeft -= ln;
        }

        if (para > _paraVScrollMax)
        {
            // overshot the end
            // move back
            _paraVScroll = _paraVScrollMax;
            int cline = _layout.LinesInPara(_paraVScroll);
            _paLineVScroll = _paLineVScrollMax;
            cLineLeft += cline - _paLineVScrollMax;
            cLine -= cLineLeft;
        }
        else if (para == _paraVScrollMax && cLineLeft > _paLineVScrollMax)
        {
            _paraVScroll = _paraVScrollMax;
            _paLineVScroll = _paLineVScrollMax;
            cLineLeft -= _paLineVScrollMax;
            cLine -= cLineLeft;
        }
        else
        {
            // cLineLeft < Lines In Para
            _paraVScroll = para;
            _paLineVScroll = cLineLeft;
        }
    }
    else if (cLine < 0)
    {
        // first skip to the end
        // of the current para
        int cLineLeft = - cLine + (_layout.LastLineInPara(_paraVScroll) - _paLineVScroll);
        // move backward
        for (para = _paraVScroll; para >= 0; para--)
        {
            int ln = _layout.LinesInPara(para);
            if (ln > cLineLeft)
                break;
            cLineLeft -= ln;
        }

        if (para < 0)
        {
            // overshot the beginning.
            // move up one line
            _paraVScroll = 0;
            _paLineVScroll = 0;
            cLineLeft++;
            cLine += cLineLeft;
        }
        else
        {
            // cLineLeft < Lines In Para
            _paraVScroll = para;
            _paLineVScroll = _layout.LinesInPara(para) - cLineLeft - 1;
        }
    }

    return cLine;
}

int View::IncHScrollPos ( int delta )
{
    Win4Assert ( FALSE );
    // Clip the increment

    if ( delta < -_nHScrollPos )
        delta = -_nHScrollPos;
    else if ( delta > _nHScrollMax - _nHScrollPos )
        delta = _nHScrollMax - _nHScrollPos;
    _nHScrollPos += delta;
    return delta;
}

void View::Paint( HWND hwnd )
{
    _layout.Adjust ( _cxClient, _cyClient, _paraVScroll, _paLineVScroll, _nHScrollPos);
    PaintText paint (hwnd, _paraVScroll, _paLineVScroll, _layout, _Selection);
    paint.PrintLines ();
    paint.HiliteHits ();
}

PaintText::PaintText(HWND hwnd, int paraFirst, int paLineFirst, Layout& layout,
                     Selection & Selection )
    : Paint(hwnd), _paraFirst(paraFirst), _paLineFirst(paLineFirst),
      _layout(layout), _Selection( Selection )
{
    _hOldFont = (HFONT) SelectObject ( hdc, _layout.Font() );

    SetBkColor ( hdc, GetSysColor(COLOR_WINDOW) );
    SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT) );
}

PaintText::~PaintText()
{
    SelectObject ( hdc, _hOldFont );
}

void Layout::SetParaRange (int cParas)
{
    _cParas = cParas;
    _aParaLine = _pModel->GetParaLine();
}

void Layout::Adjust (int cx, int cy, int& paraVScroll, int& paLineVScroll, int nHScrollPos)
{
    _cLine = (cy + _dim.cyChar - 1) / _dim.cyChar;
    _cCharWidth = cx / _dim.cxChar;
    _xBegin = nHScrollPos * _dim.cxChar;

    if ( paraVScroll < 0 )
    {
        paraVScroll = 0;
        paLineVScroll = 0;
    }
    _paLineFirst = paLineVScroll;
    _paraFirst = paraVScroll;
}

int Layout::Y (int line ) const
{
    return line * _dim.cyChar;
}

void Layout::Locate (int para, int paOff, int& paLine, int& paOffBeg, int& paOffEnd ) const
{
    Win4Assert(para < _cParas);
    paLine = 0;
    paOffBeg = 0;
    for (ParaLine const* p = &_aParaLine[para]; p != 0 && p->offEnd <= paOff; p = p->next)
    {
        paOffBeg = p->offEnd;
        paLine++;
    }
    if (p == 0)
        paOffEnd = 0;
    else
        paOffEnd = p->offEnd;
}

BOOL Layout::GetLineOffsets (int para, int paLine, int& paOffBeg, int& paOffEnd) const
{
    if (para < _paraFirst || para > LastPara() || para >= _cParas)
        return FALSE;

    ParaLine const * p = &_aParaLine[para];
    paOffBeg = 0;
    for (int line = 0; line < paLine; line++)
    {
        paOffBeg = p->offEnd;
        p = p->next;
        if (p == 0)
            return FALSE;
    }
    paOffEnd = p->offEnd;
    Win4Assert ( paOffEnd >= paOffBeg);
    return TRUE;
}

int Layout::LastPara() const
{
    // at most this number
    return _paraFirst + _cLine;
}

int Layout::LineNumber (int para, int paLine) const
{
    if (para == _paraFirst)
    {
        return paLine - _paLineFirst;
    }
    int curPara = _paraFirst + 1;
    int curLine = LinesInPara(_paraFirst) - _paLineFirst;

    while (curPara < para)
    {
        curLine += LinesInPara(curPara);
        curPara++;
    }
    return curLine + paLine;
}

int Layout::LinesInPara (int para) const
{
    Win4Assert(para < _cParas);
    int line = 1;
    for (ParaLine const * p = _aParaLine[para].next; p != 0; p = p->next)
        line++;
    return line;
}

void EnableHilite( HDC hdc )
{
    SetBkColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );
    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHTTEXT) );
}

void EnableHitHilite( HDC hdc )
{
//    SetBkColor( hdc, GetSysColor(COLOR_ACTIVECAPTION) );
//    SetTextColor( hdc, GetSysColor(COLOR_CAPTIONTEXT) );

//    SetBkColor( hdc, GetSysColor(COLOR_INACTIVECAPTION) );
//    SetTextColor( hdc, GetSysColor(COLOR_INACTIVECAPTIONTEXT) );

//    SetBkColor( hdc, GetSysColor(COLOR_HIGHLIGHTTEXT) );
//    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );

    SetBkColor( hdc, GetSysColor(COLOR_WINDOWTEXT) );
    SetTextColor( hdc, GetSysColor(COLOR_WINDOW) );

//    SetBkColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );
//    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHTTEXT) );
}

void EnableNonCurrentHitHilite( HDC hdc )
{
    SetBkColor ( hdc, GetSysColor(COLOR_WINDOW) );
    SetTextColor( hdc, GetSysColor(COLOR_HIGHLIGHT) );
}

void DisableHilite( HDC hdc )
{
    SetBkColor ( hdc, GetSysColor(COLOR_WINDOW) );
    SetTextColor ( hdc, GetSysColor(COLOR_WINDOWTEXT) );
}

void PaintText::PrintLines ()
{
    int para   = _layout.FirstPara();
    int paLine = _layout.FirstLineInPara();     // line within paragraph
    int paOffBeg;   // line beginning offset within paragraph
    int paOffEnd;   // line end offset within paragraph

    int line = 0;           // line # counting from top of window
    int left = cpLeftMargin - _layout.XBegin();

    while (_layout.GetLineOffsets ( para, paLine, paOffBeg, paOffEnd ))
    {
        // print paragraph
        do
        {
            // clip to the update rect
            int top = _layout.Y ( line );
            int bottom = top + _layout.CyChar();

            if ( top <= rcPaint.bottom && bottom >= rcPaint.top)
            {
                int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );
                if (!TheModel.GetLine( para, paOffBeg, cwcLine, LineBuffer ))
                    return;
    
                cwcLine = TrimEOL( LineBuffer, cwcLine );

                if ( 0 == cwcLine )
                {
                    // to make selections look better...
                    wcscpy(LineBuffer,L" ");
                    cwcLine = 1;
                }

                Win4Assert( cwcLine >= 0 );

                if ( _Selection.IsInSelection( para ) )
                {
                    if ( ( para > _Selection.ParaStart() ) &&
                         ( para < _Selection.ParaEnd() ) )
                    {
                        EnableHilite( hdc );
                        TabbedTextOut( hdc, left, top, LineBuffer, cwcLine,
                                       0, 0, left );
                        DisableHilite( hdc );
                    }
                    else
                    {
                        int l = left;
                        for ( int c = 0; c < cwcLine; c++ )
                        {
                            if ( _Selection.IsInSelection( para, c + paOffBeg ) )
                                EnableHilite( hdc );
                            LONG dim = TabbedTextOut( hdc, l, top,
                                                      LineBuffer + c, 1,
                                                      0, 0, left );
                            DisableHilite( hdc );
                            l += LOWORD(dim);
                        }
                    }
                }
                else
                {
                    TabbedTextOut( hdc, left, top, LineBuffer, cwcLine,
                                   0, 0, left );
                }
            }

            line++;
            if (line >= _layout.MaxLines())
                return;
            paLine++;
        } while (_layout.GetLineOffsets( para, paLine, paOffBeg, paOffEnd ));

        // next paragraph
        para++;
        paLine = 0;
    }
} //PrintLines

void PaintText::HiliteHits ()
{
    TheModel.HiliteAll( TRUE );

    if ( TheModel.FirstHit() )
    {
        do
        {
            if ( !TheModel.isSavedCurrent() )
                PrintCurrentHit( FALSE );
        }
        while( TheModel.NextHit() );

        TheModel.RestoreHilite();
    }

    TheModel.HiliteAll( FALSE );

    PrintCurrentHit( TRUE );
} //HiliteHits

const int WORDBUFLEN = 80;
static WCHAR WordBuffer [WORDBUFLEN];

void PaintText::PrintCurrentHit( BOOL fCurrent )
{
    if ( fCurrent )
        EnableHitHilite( hdc );
    else
        EnableNonCurrentHitHilite( hdc );

    int cPos = TheModel.GetPositionCount();
    int iPos = 0;
    Position pos = TheModel.GetPosition(iPos);

    int left = cpLeftMargin - _layout.XBegin();

    while ( iPos < cPos )
    {
        int curPara = pos.Para();

        if ( curPara > _layout.LastPara() )
            break;

        if (curPara >= _layout.FirstPara())
        {
            int paLine;     // line within paragraph
            int paOffBeg;   // line beginning offset within paragraph
            int paOffEnd;   // line end offset within paragraph

            _layout.Locate ( curPara, pos.BegOff(), paLine, paOffBeg, paOffEnd );

            int line = _layout.LineNumber ( curPara, paLine );

            // Output the line with highlights

            int cwcLine = __min ( BUFLEN, paOffEnd - paOffBeg );
            if (!TheModel.GetLine (curPara, paOffBeg, cwcLine, LineBuffer ))
                break;

            cwcLine = TrimEOL( LineBuffer, cwcLine );

            int top = _layout.Y (line);

            do
            {
                int cwc = __min( pos.Len(), WORDBUFLEN);
                TheModel.GetWord( curPara, pos.BegOff(), cwc, WordBuffer );
                Win4Assert ( cwc >= 0 );

                // Find out how much space it takes before the highlight

                DWORD dwExt = GetTabbedTextExtent ( hdc,
                                                    LineBuffer,
                                                    pos.BegOff() - paOffBeg,
                                                    0, 0 );

                // Print hilighted text

                TabbedTextOut ( hdc,
                                left + LOWORD(dwExt),
                                top,
                                WordBuffer,
                                cwc,
                                0, 0,
                                left );

                iPos++;
                if (iPos >= cPos)
                    break;
                pos = TheModel.GetPosition(iPos);

            } while ( pos.Para() == curPara );
        }
        else
        {
            iPos++;
        }
    }

    DisableHilite( hdc );
} //PrintCurrentHit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\brmodel.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       model.cxx
//
//  Contents:   The Model part of the browser
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TheSearch _pSearch

//+-------------------------------------------------------------------------
//
//  Member:     Model::Model, public
//
//  Synopsis:
//
//--------------------------------------------------------------------------

Model::Model ()
: _pResult(0),
  _aDoc(0),
  _cForce(0),
  _fHiliteAll( FALSE ),
  _iDoc(0),
  _pSearch(0)
{}

//+-------------------------------------------------------------------------
//
//  Member:     Model::~Model, public
//
//  Synopsis:
//
//--------------------------------------------------------------------------
Model::~Model()
{
    for ( unsigned i = 0; i < _cDoc; i++ )
        delete _aDoc[i];

    delete []_aDoc;

    delete _pResult;

    if (TheSearch)
        TheSearch->Release();
}

//+-------------------------------------------------------------------------
//
//  Member:     Model::Force, public
//
//  Synopsis:   Display a subset of files
//
//--------------------------------------------------------------------------
void Model::Force ( char* pStr )
{
    while (_cForce < MAX_FORCE && isdigit(*pStr) )
    {
        _aForce[_cForce] = (unsigned)atoi ( pStr );
        _cForce++;
        while (*pStr && isdigit(*pStr) )
            pStr++;
        while (*pStr && isspace(*pStr))
            pStr++;
    }
}

typedef HRESULT (__stdcall * PFnMakeISearch)( ISearchQueryHits ** ppSearch,
                                              DBCOMMANDTREE const * pRst,
                                              WCHAR const * pwcPath );
PFnMakeISearch g_pMakeISearch = 0;
SCODE MyMakeISearch( ISearchQueryHits **ppSearch,
                     DBCOMMANDTREE const * pRst,
                     WCHAR const * pwcPath )
{
    if ( 0 == g_pMakeISearch )
    {
        #ifdef _WIN64
            char const * pcMakeISearch = "?MakeISearch@@YAJPEAPEAUISearchQueryHits@@PEAVCDbRestriction@@PEBG@Z";
        #else
            char const * pcMakeISearch = "?MakeISearch@@YGJPAPAUISearchQueryHits@@PAVCDbRestriction@@PBG@Z";
        #endif

        g_pMakeISearch = (PFnMakeISearch) GetProcAddress( GetModuleHandle( L"query.dll" ), pcMakeISearch );

        if ( 0 == g_pMakeISearch )
            return HRESULT_FROM_WIN32( GetLastError() );
    }

    return g_pMakeISearch( ppSearch,
                           pRst,
                           pwcPath );
} //MyMakeISearch

//+-------------------------------------------------------------------------
//
//  Member:     Model::CollectFiles, public
//
//  Synopsis:   Parse command line, get restriction and list of docs,
//              create array of docs, initialize the first one.
//              In response to window creation
//
//--------------------------------------------------------------------------

SCODE Model::CollectFiles ( CQueryResult *pResult )
{
    _pResult = pResult;

    _cDoc = 1;
    _aDoc = new Document * [ _cDoc ];

    unsigned countSoFar = 0;
    for ( unsigned iDoc = 0; iDoc< _cDoc; iDoc++)
    {
        if (_cForce == 0 || isForced(iDoc))
        {
            Document * newDoc = new Document( pResult->_pwcPath,
                                              1000,
                                              pResult->_fDeleteWhenDone );
            //
            //  Insert into sorted list of documents
            //
            unsigned i=0;
            while ( i < countSoFar && newDoc->Rank() <= _aDoc[i]->Rank() )
                i++;
            // _aDoc[i]->Rank() > newDoc->Rank() || i == countSoFar
            for ( unsigned j = countSoFar; j > i; j-- )
                _aDoc[j] = _aDoc[j-1];
            _aDoc[i] = newDoc;
            countSoFar++;
        }
    }
    _iDoc = 0;
    _cDoc = countSoFar;

    SCODE sc = MyMakeISearch( &TheSearch, _pResult->_pTree, pResult->_pwcPath );

    if ( !FAILED( sc ) && 0 != TheSearch )
        return InitDocument();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     Model::isForced, public
//
//  Synopsis:   Check if idx is on a forced list
//
//--------------------------------------------------------------------------

BOOL Model::isForced(unsigned idx)
{
    for (unsigned i = 0; i < _cForce; i++)
        if (_aForce[i] == idx)
            return(TRUE);
    return(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Member:     Model::InitDocument, public
//
//  Synopsis:   Initialize current document
//
//--------------------------------------------------------------------------

SCODE Model::InitDocument()
{
    if ( 0 == _cDoc )
        return E_FAIL;

    SCODE sc = S_OK;

    if ( !_aDoc[_iDoc]->IsInit() )
        sc = _aDoc[_iDoc]->Init( TheSearch );

    if ( SUCCEEDED( sc ) )
        _hitIter.Init ( _aDoc[_iDoc] );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\srchq.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       srchq.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#define guidCPP { 0x8DEE0300, 0x16C2, 0x101B, { 0xB1, 0x21, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 } }

static GUID guidCPlusPlus = guidCPP;

static GUID guidBmk =       DBBMKGUID;
static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
static const GUID guidRowsetProps = DBPROPSET_ROWSET;

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};

#define guidZero { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

const DBID dbcolCPlusPlusClass = { guidCPP, DBKIND_GUID_NAME, L"class" };
const DBID dbcolCPlusPlusFunc = { guidCPP, DBKIND_GUID_NAME, L"func" };

const DBID dbcolBookMark = { DBBMKGUID, DBKIND_GUID_PROPID, (LPWSTR) (ULONG_PTR) PROPID_DBBMK_BOOKMARK };

const DBID dbcolPath =  { PSGUID_STORAGE, DBKIND_GUID_PROPID,
                             (LPWSTR) ULongToPtr( PID_STG_PATH ) };

const DBBINDING dbbindingPath = {  0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   DBPART_VALUE,
                                   DBMEMOWNER_PROVIDEROWNED,
                                   DBPARAMIO_NOTPARAM,
                                   sizeof (WCHAR *),
                                   0,
                                   DBTYPE_WSTR|DBTYPE_BYREF,
                                   0,
                                   0,
                                 };


DBBINDING aBmkColumn[] =  {  0,
                             sizeof DBLENGTH,
                             0,
                             0,
                             0,
                             0,
                             0,
                             DBPART_VALUE | DBPART_LENGTH,
                             DBMEMOWNER_CLIENTOWNED,
                             DBPARAMIO_NOTPARAM,
                             MAX_BOOKMARK_LENGTH,
                             0,
                             DBTYPE_BYTES,
                             0,
                             0,
                         };

CIPROPERTYDEF aCPPProperties[] =
{
    {
        L"FUNC",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"func"
        }
    },
    {
        L"CLASS",
        DBTYPE_WSTR | DBTYPE_BYREF,
        {
            { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
            DBKIND_GUID_NAME,
            L"class"
        }
    }
};

unsigned cCPPProperties = sizeof aCPPProperties /
                          sizeof aCPPProperties[0];

SCODE ParseQuery(
    WCHAR *          pwcQuery,
    ULONG            ulDialect,
    LCID             lcid,
    DBCOMMANDTREE ** ppQuery )
{
    *ppQuery = 0;

    return CITextToSelectTreeEx( pwcQuery,
                                 ulDialect,
                                 ppQuery,
                                 cCPPProperties,
                                 aCPPProperties,
                                 lcid );
} //ParseQuery

//-----------------------------------------------------------------------------
//
//  Function:   GetOleDBErrorInfo
//
//  Synopsis:   Retrieves the secondary error from the OLE DB error object.
//
//  Arguments:  [pErrSrc]      - Pointer to object that posted the error.
//              [riid]         - Interface that posted the error.
//              [lcid]         - Locale in which the text is desired.
//              [pErrorInfo]   - Pointer to memory where ERRORINFO should be.
//              [ppIErrorInfo] - Holds the returning IErrorInfo. Caller
//                               should release this.
//
//  Returns:    HRESULT for whether the error info was retrieved
//
//-----------------------------------------------------------------------------

HRESULT GetOleDBErrorInfo(
    IUnknown *    pErrSrc,
    REFIID        riid,
    LCID          lcid,
    ERRORINFO *   pErrorInfo,
    IErrorInfo ** ppIErrorInfo )
{
    *ppIErrorInfo = 0;

    // See if an error is available that is of interest to us.

    XInterface<ISupportErrorInfo> xSupportErrorInfo;
    HRESULT hr = pErrSrc->QueryInterface( IID_ISupportErrorInfo,
                                          xSupportErrorInfo.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xSupportErrorInfo->InterfaceSupportsErrorInfo( riid );
    if ( FAILED( hr ) )
        return hr;

    // Get the current error object. Return if none exists.

    XInterface<IErrorInfo> xErrorInfo;
    hr = GetErrorInfo( 0, xErrorInfo.GetPPointer() );
    if ( xErrorInfo.IsNull() )
        return hr;

    // Get the IErrorRecord interface and get the count of errors.

    XInterface<IErrorRecords> xErrorRecords;
    hr = xErrorInfo->QueryInterface( IID_IErrorRecords,
                                     xErrorRecords.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    ULONG cErrRecords;
    hr = xErrorRecords->GetRecordCount( &cErrRecords );
    if ( 0 == cErrRecords )
        return hr;

#if 0 // A good way to get the complete error message...

    XInterface<IErrorInfo> xErrorInfoRec;
    ERRORINFO ErrorInfo;
    for ( unsigned i=0; i<cErrRecords; i++ )
    {
        // Get basic error information.

        xErrorRecords->GetBasicErrorInfo( i, &ErrorInfo );

        // Get error description and source through the IErrorInfo interface
        // pointer on a particular record.

        xErrorRecords->GetErrorInfo( i, lcid, xErrorInfoRec.GetPPointer() );

        XBStr bstrDescriptionOfError;
        XBStr bstrSourceOfError;

        BSTR bstrDesc = bstrDescriptionOfError.GetPointer();
        BSTR bstrSrc = bstrSourceOfError.GetPointer();

        xErrorInfoRec->GetDescription( &bstrDesc ); 
        xErrorInfoRec->GetSource( &bstrSrc );

        // At this point, you could call GetCustomErrorObject and query for
        // additional interfaces to determine what else happened.

        wprintf( L"%s (%#x)\n%s\n", bstrDesc, ErrorInfo.hrError, bstrSrc );    
    }
#endif

    // Get basic error information for the most recent error

    ULONG iRecord = cErrRecords - 1;
    hr = xErrorRecords->GetBasicErrorInfo( iRecord, pErrorInfo );
    if ( FAILED( hr ) )
        return hr;

    return xErrorRecords->GetErrorInfo( iRecord, lcid, ppIErrorInfo );
} //GetOleDBErrorInfo

//
// CSearchQuery
//

CSearchQuery::CSearchQuery(
    const XGrowable<WCHAR> & xCatList,
    WCHAR *pwcQuery,
    HWND hNotify,
    int  cRowsDisp,
    LCID  lcid,
    ESearchType srchType,
    IColumnMapper & columnMapper,
    CColumnList &columns,
    CSortList &sort,
    ULONG ulDialect,
    ULONG ulLimit,
    ULONG ulFirstRows )
    : _hwndNotify(hNotify),
      _hwndList (0),
      _cRowsTotal(0),
      _cHRows(0),
      _cRowsDisp(cRowsDisp),
      _lcid(lcid),
      _fDone(FALSE),
      _srchType(srchType),
      _columns(columns),
      _columnMapper(columnMapper),
      _hAccessor(0),
      _hBmkAccessor(0),
      _hBrowseAccessor(0),
      _iRowCurrent(0),
      _hRegion(0),
      _pctDone(0),
      _dwQueryStatus(0),
      _scLastError(0),
      _dwStartTime(0),
      _dwEndTime(0),
      _prstQuery(0),
      _xCatList( xCatList )
{
    srchDebugOut((DEB_TRACE,"top of CSearchQuery()\n"));

    _dwStartTime = GetTickCount();

    _bmkTop.MakeFirst();

    for (int i = 0; i < cMaxRowCache; i++)
        _aHRows [i] = 0;

    ICommand *pICommand = 0;
    SCODE sc = InstantiateICommand( &pICommand );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    XInterface< ICommand> xCommand( pICommand );

    _xwcQuery.SetSize(wcslen(pwcQuery) + 1);

    wcscpy(_xwcQuery.Get(),pwcQuery);

    switch ( ulDialect )
    {
    case    ISQLANG_V1:
    case    ISQLANG_V2:
        {
            if (srchNormal == _srchType)
            {
                sc = ParseQuery( _xwcQuery.Get(), ulDialect, lcid, &_prstQuery );

                if ( FAILED(sc) )
                    THROW( CException(sc) );
            }
            else
            {
                XArray<WCHAR> xQuery( wcslen( _xwcQuery.Get() ) + 50 );

                wcscpy( xQuery.Get(), ( _srchType == srchClass ) ? L"@class " : L"@func " );
                wcscat( xQuery.Get(), _xwcQuery.Get() );

                sc = ParseQuery( xQuery.Get(), ulDialect, lcid, &_prstQuery );

                if ( FAILED(sc) )
                    THROW( CException(sc) );
            }

            XArray<WCHAR> xColumns;
            columns.MakeList( xColumns );

            XArray<WCHAR> xSort;
            sort.MakeList( xSort );

            DBCOMMANDTREE *pTree;
            sc = CIRestrictionToFullTree( _prstQuery,
                                          xColumns.Get(),
                                          xSort.Get(),
                                          0,
                                          &pTree,
                                          0,
                                          0,
                                          lcid );
            if ( FAILED( sc ) )
                THROW( CException(sc) );

            XInterface<ICommandTree> xCommandTree;
            sc = pICommand->QueryInterface( IID_ICommandTree, xCommandTree.GetQIPointer() );
            if ( FAILED( sc ) )
                THROW( CException(sc) );

            sc = xCommandTree->SetCommandTree( &pTree, DBCOMMANDREUSE_NONE, FALSE);
            if (FAILED (sc) )
                THROW( CException( sc ) );
            break;
        }
    case    SQLTEXT:
        {
            WCHAR       awcCommand[cwcMaxQuery];
            WCHAR       awcPropList[cwcMaxQuery] = L"Path";
            CResString  wstrQueryFormat(IDS_SQLQUERY_FORMAT);

            XInterface<ICommandText> xCommandText;
            sc = pICommand->QueryInterface( IID_ICommandText, xCommandText.GetQIPointer() );

            if ( FAILED( sc ) )
                THROW( CException( sc ) );

            // set the list of columns
            // !! Allways select the PATH column !!
            for ( ULONG iCol = 0; iCol < _columns.NumberOfColumns(); iCol++ )
            {
                if ( _wcsicmp ( _columns.GetColumn(iCol), L"Path" ) )
                {
                    wcscat( awcPropList, L", " );
                    wcscat( awcPropList, _columns.GetColumn( iCol ) );
                }
            }

            WCHAR awcMachine[MAX_PATH];
            WCHAR awcCatalog[MAX_PATH];
            WCHAR awcPath[MAX_PATH];
            BOOL fDeep;

            // What about ditributed queries?  Not supported, but that's OK
            // since this is a test tool.

            GetCatListItem( _xCatList, 0, awcMachine, awcCatalog, awcPath, fDeep );

            swprintf( awcCommand, wstrQueryFormat.Get(), awcPropList, awcCatalog, awcPath, pwcQuery );

            srchDebugOut((DEB_TRACE, "SQL query: %ws\n", awcCommand));

            sc = xCommandText->SetCommandText( DBGUID_SQL, awcCommand);

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            XInterface<ICommandPrepare> xCommandPrepare;

            sc = pICommand->QueryInterface( IID_ICommandPrepare, xCommandPrepare.GetQIPointer() );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            sc = xCommandPrepare->Prepare( 1 );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            XInterface<ICommandProperties> xCommandProperties;

            sc = pICommand->QueryInterface( IID_ICommandProperties, xCommandProperties.GetQIPointer() );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            // set the machine name

            DBPROPSET   PropSet;
            DBPROP      Prop;

            const GUID  guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

            PropSet.rgProperties    = &Prop;
            PropSet.cProperties     = 1;
            PropSet.guidPropertySet = guidQueryCorePropset;

            Prop.dwPropertyID       = DBPROP_MACHINE;
            Prop.colid              = DB_NULLID;
            Prop.vValue.vt          = VT_BSTR;
            Prop.vValue.bstrVal     = SysAllocString( awcMachine );

            if ( NULL == Prop.vValue.bstrVal )
                THROW( CException( E_OUTOFMEMORY ) );

            sc = xCommandProperties->SetProperties ( 1, &PropSet );

            VariantClear( &Prop.vValue );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            // try to get the restriction

            DBPROPIDSET     PropIDSet;
            DBPROPID        PropID = MSIDXSPROP_QUERY_RESTRICTION;

            PropIDSet.rgPropertyIDs     = &PropID;
            PropIDSet.cPropertyIDs      = 1;

            const GUID guidMSIDXS_ROWSETEXT = DBPROPSET_MSIDXS_ROWSETEXT;
            PropIDSet.guidPropertySet   = guidMSIDXS_ROWSETEXT;

            ULONG cPropSets;
            DBPROPSET *pPropSet;
            sc = xCommandProperties->GetProperties ( 1, &PropIDSet, &cPropSets, &pPropSet );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            Win4Assert( 1 == cPropSets );
            XCoMem<DBPROPSET> xPropSet( pPropSet );
            XCoMem<DBPROP> xProp( pPropSet->rgProperties );


            srchDebugOut((DEB_TRACE, "SQL query as tripolish: %ws\n",
                          pPropSet->rgProperties->vValue.bstrVal ));

            // MSIDXSPROP_QUERY_RESTRICTION returns the restriction in in Triplish1 syntax.
            // It is sometimes bogus.  Just set a zero and ignore the error for now.

            DBCOMMANDTREE *pQuery = 0;

            ParseQuery( pPropSet->rgProperties->vValue.bstrVal,
                        ISQLANG_V1,
                        lcid,
                        &pQuery );

            _prstQuery = pQuery;

            sc = VariantClear( &pPropSet->rgProperties->vValue );

            if ( FAILED (sc) )
                THROW( CException( sc ) );

            break;
        }
    }

    // Set the property that says we want to use asynch. queries
    {

        ICommandProperties * pCmdProp = 0;
        sc = pICommand->QueryInterface( IID_ICommandProperties,
                                     (void **)&pCmdProp );
        if (FAILED (sc) )
            THROW( CException( sc ) );

        XInterface< ICommandProperties > xComdProp( pCmdProp );

        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP    aProp[MAX_PROPS];

        ULONG cProps = 0;

        // asynchronous, watchable query

        aProp[cProps].dwPropertyID = DBPROP_IDBAsynchStatus;
        aProp[cProps].dwOptions = DBPROPOPTIONS_REQUIRED;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        aProp[cProps].dwPropertyID = DBPROP_IRowsetWatchRegion;
        aProp[cProps].dwOptions = DBPROPOPTIONS_REQUIRED;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        // don't timeout queries

        aProp[cProps].dwPropertyID = DBPROP_COMMANDTIMEOUT;
        aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_I4;
        aProp[cProps].vValue.lVal = 0;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidRowsetProps;

        cProps++;

        // We can handle PROPVARIANTs

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;

        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;

        cProps++;

        if ( App.ForceUseCI() )
        {
            // Set the property that says we don't want to enumerate

            aProp[cProps].dwPropertyID = DBPROP_USECONTENTINDEX;
            aProp[cProps].dwOptions = DBPROPOPTIONS_OPTIONAL;
            aProp[cProps].dwStatus = 0;
            aProp[cProps].colid = dbcolNull;
            aProp[cProps].vValue.vt = VT_BOOL;
            aProp[cProps].vValue.boolVal = VARIANT_TRUE;

            aPropSet[cProps].rgProperties = &aProp[cProps];
            aPropSet[cProps].cProperties = 1;
            aPropSet[cProps].guidPropertySet = guidQueryExt;

            cProps++;
        }

        Win4Assert( MAX_PROPS >= cProps );

        sc = pCmdProp->SetProperties( cProps, aPropSet );

        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
            THROW( CException( sc ) );
    }

    if ( 0 != ulLimit || 0 != ulFirstRows )
    {
        static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                        DBKIND_GUID_PROPID, 0 };
    
        DBPROP aRowsetProp[1];
        aRowsetProp[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
        aRowsetProp[0].dwStatus = 0;
        aRowsetProp[0].colid = dbcolNull;
        aRowsetProp[0].dwPropertyID = (0 != ulLimit) ? DBPROP_MAXROWS : DBPROP_FIRSTROWS;
        aRowsetProp[0].vValue.vt = VT_I4;
        aRowsetProp[0].vValue.lVal = (LONG) (0 != ulLimit) ? ulLimit : ulFirstRows;
    
        DBPROPSET aPropSet[1];
        aPropSet[0].rgProperties = &aRowsetProp[0];
        aPropSet[0].cProperties = 1;
        aPropSet[0].guidPropertySet = DBPROPSET_ROWSET;
    
        XInterface<ICommandProperties> xICommandProperties;
        sc = pICommand->QueryInterface( IID_ICommandProperties,
                                        xICommandProperties.GetQIPointer() );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );
    
        sc = xICommandProperties->SetProperties( 1,
                                                 aPropSet ); // the properties
        if (FAILED (sc) || DB_S_ERRORSOCCURRED == sc )
            THROW( CException( sc ) );
    }

    IRowsetScroll * pRowset;

    sc = pICommand->Execute( 0,                    // no aggr. IUnknown
                             IID_IRowsetScroll,    // IID for i/f to return
                             0,                    // dbparams
                             0,                    // chapter
                             (IUnknown **) & pRowset );  // Returned interface

    if ( FAILED(sc) )
    {
        // get the real error here

        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        SCODE sc2 = GetOleDBErrorInfo( pICommand,
                                       IID_ICommand,
                                       lcid,
                                       &ErrorInfo,
                                       xErrorInfo.GetPPointer() );

        // Post IErrorInfo only if we have a valid ptr to it.

        if (SUCCEEDED(sc2) && 0 != xErrorInfo.GetPointer())
            sc = ErrorInfo.hrError;

        THROW( CException(sc) );
    }

    _xRowset.Set( pRowset );

    IRowsetQueryStatus *pRowsetStatus;
    sc = _xRowset->QueryInterface( IID_IRowsetQueryStatus,
                                   (void**) &pRowsetStatus );
    if (SUCCEEDED( sc ) )
        _xRowsetStatus.Set( pRowsetStatus );

    IColumnsInfo *pColInfo = 0;
    sc = _xRowset->QueryInterface( IID_IColumnsInfo, (void **)&pColInfo );
    if (FAILED(sc))
        THROW( CException( sc ) );

    XInterface< IColumnsInfo > xColInfo( pColInfo );

    IAccessor *pIAccessor;
    sc = _xRowset->QueryInterface( IID_IAccessor, (void **)&pIAccessor );
    if (FAILED(sc))
        THROW (CException (sc));

    _xIAccessor.Set( pIAccessor );

    //
    // set up an accessor for bookmarks.
    //

    DBID acols[1];
    acols[0] = dbcolBookMark;
    DBORDINAL lcol;
    sc = pColInfo->MapColumnIDs(1, acols, &lcol);
    if (FAILED(sc))
        THROW (CException (sc));

    Win4Assert( 0 == lcol );
    aBmkColumn[0].iOrdinal = lcol;

    sc = _xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                      1,
                                      aBmkColumn,
                                      0,
                                      &_hBmkAccessor,
                                      0 );

    if ( FAILED(sc) )
        THROW (CException (sc));

    SetupColumnMappingsAndAccessors();

    // Get a pointer to the IDBAsynchStatus for checking completion state

    IDBAsynchStatus *pDBAsynchStatus;
    sc = _xRowset->QueryInterface( IID_IDBAsynchStatus,
                                   (void**) &pDBAsynchStatus );

    if ( FAILED(sc) )
        THROW (CException (sc));

    _xDBAsynchStatus.Set( pDBAsynchStatus );
} //CSearchQuery

void CSearchQuery::InitNotifications(
    HWND hwndList)
{
    _hwndList = hwndList;

    _xWatch.Set( new CWatchQuery( this, _xRowset.GetPointer() ) );
    if (!_xWatch->Ok())
        _xWatch.Free();
    else
        _hRegion = _xWatch->Handle();
} //InitNotifications

CSearchQuery::~CSearchQuery()
{
    srchDebugOut((DEB_TRACE,"top of ~CSearchQuery()\n"));

    _xRowsetStatus.Free();

    //
    // make sure notification thread isn't stuck sleeping in our code
    // when we shut down notifications.  this is ok, but will cause
    // an unnecessary delay in shutting down the query.
    //

    if ( !_xWatch.IsNull() )
        _xWatch->IgnoreNotifications( TRUE );

    _xDBAsynchStatus.Free();

    _xWatch.Free();

    if ( !_xIAccessor.IsNull() )
    {
        if (_hAccessor)
            _xIAccessor->ReleaseAccessor( _hAccessor, 0 );

        if ( _hBmkAccessor )
            _xIAccessor->ReleaseAccessor( _hBmkAccessor, 0 );

        if ( _hBrowseAccessor )
            _xIAccessor->ReleaseAccessor( _hBrowseAccessor, 0 );

        _xIAccessor.Free();
    }

    if ( !_xRowset.IsNull() )
    {
        srchDebugOut((DEB_TRACE,"~ Releasing %d rows, first %d\n",_cHRows,_aHRows[0]));

        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        _xRowset.Free();
    }

    srchDebugOut(( DEB_TRACE, "bottom of ~CSearchQuery()\n" ));
} //~CSearchQuery

BOOL CSearchQuery::ListNotify(
    HWND   hwnd,
    WPARAM action,
    long * pDist)
{
    BOOL fRet = TRUE;

    CWaitCursor wait;

    switch (action)
    {
        case listScrollLineUp:
            ScrollLineUp (pDist);
            break;
        case listScrollLineDn:
            ScrollLineDn (pDist);
            break;
        case listScrollPageUp:
            ScrollPageUp (pDist);
            break;
        case listScrollPageDn:
            ScrollPageDn (pDist);
            break;
        case listScrollTop:
            ScrollTop (pDist);
            break;
        case listScrollBottom:
            ScrollBottom (pDist);
            break;
        case listScrollPos:
            ScrollPos (pDist);
            break;
        case listSize:
            fRet = WindowResized (*(ULONG*)pDist);
            break;
        case listSelect:
            return Select (pDist);
            break;
        case listSelectUp:
            fRet = SelectUp( pDist );
            break;
        case listSelectDown:
            fRet = SelectDown( pDist );
            break;
        default:
            Win4Assert (!"Unknown action in CSearchQuery::Scroll");
    }
    return fRet;
} //ListNotify

long CSearchQuery::FindSelection()
{
    long iSel;

    if (IsSelected())
    {
        // Find out what is selected
        for (ULONG i = 0; i < _cHRows; i++)
            if (IsSelected(i))
                break;
        if (i == _cHRows)
            iSel = -1;
        else
            iSel = i;
    }
    else
    {
        iSel = -1;
    }

    return iSel;
} //FindSelection

BOOL CSearchQuery::SelectUp(
    long * piNew )
{
    *piNew = FindSelection();

    if ( -1 == *piNew || 0 == *piNew )
        return FALSE;

    (*piNew)--;

    GetBookMark( _aHRows[ *piNew ], _bmkSelect );

    return TRUE;
} //SelectUp

BOOL CSearchQuery::SelectDown(
    long * piNew )
{
    *piNew = FindSelection();

    if ( ( -1 == *piNew ) || ( *piNew == (long) ( _cHRows - 1) ) )
        return FALSE;

    (*piNew)++;

    GetBookMark( _aHRows[ *piNew ], _bmkSelect );

    return TRUE;
} //SelectDown

BOOL CSearchQuery::Select(
    long* piRow )
{
    ULONG newRow = *piRow;

    if (newRow >= _cHRows)
    {
        return FALSE;
    }

    *piRow = FindSelection();

    if (*piRow != (long)newRow)
        GetBookMark (_aHRows[newRow], _bmkSelect);
#if 0
    else
        _bmkSelect.Invalidate();
#endif

    return TRUE;
} //Select

BOOL CSearchQuery::IsSelected(
    UINT iRow )
{
    if (iRow >= _cHRows)
        return FALSE;
    CBookMark bmk;
    GetBookMark (_aHRows[iRow], bmk);
    return bmk.IsEqual (_bmkSelect);
} //IsSelected

BOOL CSearchQuery::WindowResized(
    ULONG & cRows)
{
    BOOL fInvalidate = FALSE;

    if (cRows < _cHRows)
    {
        if ( !_xWatch.IsNull() )
            _xWatch->Shrink (_hRegion, _bmkTop, cRows);
        _xRowset->ReleaseRows(_cHRows - cRows, _aHRows + cRows, 0, 0, 0);
        for (ULONG i = cRows; i < _cHRows; i++)
            _aHRows[i] = 0;

        _cHRows = cRows;
    }
    else if (cRows > _cHRows)
    {
        if (cRows > cMaxRowCache)
            cRows = cMaxRowCache;

        CBookMark bmk;
        long cSkip;
        if (_cHRows == 0)
        {
            cSkip = 0;
            bmk.MakeFirst();
        }
        else
        {
            cSkip = 1;
            GetBookMark (_aHRows[_cHRows-1], bmk);
        }
        DBCOUNTITEM cRowsFetched = 0;
        if ( !_xWatch.IsNull() )
            _xWatch->Extend (_hRegion);

        ULONG cRowsNeeded = cRows - _cHRows;
        FetchResult res = Fetch ( bmk, cSkip, cRowsNeeded, cRowsFetched, _aHRows + _cHRows, _hRegion);

        if ( cRowsFetched )
        {
            _cHRows += (ULONG) cRowsFetched;
            cRowsNeeded -= (ULONG) cRowsFetched;
        }

        if ( cRowsNeeded && _cHRows < _cRowsTotal )
        {
            // looks like we are at the ned
            // try to get rows from the top to fill up new space

            fInvalidate = TRUE;

            Win4Assert( fetchBoundary == res );

            if ( cRowsNeeded > _cRowsTotal - _cHRows )
            {
                cRowsNeeded = (ULONG) ( _cRowsTotal - _cHRows );
            }

            _cRowsDisp = cRows; // need to set this here before PageUp

            ScrollPageUp( (long*) &cRowsNeeded );
        }
    }
    _cRowsDisp = cRows;
    cRows = _cHRows;

    // return TRUE if an invalidate is needed or FALSE if just updating
    // the scroll bars is sufficient.

    return fInvalidate;
} //WindowResized

void CSearchQuery::ScrollLineUp(
    long * pDist)
{
    if (_cHRows == 0)
    {
        *pDist = 0;
        return;
    }
    // Try to fetch new first row
    HROW hrow;
    CBookMark bmk;
    GetBookMark (_aHRows[0], bmk);
    DBCOUNTITEM cRowsFetched = 0;
    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);
    FetchResult res = Fetch ( bmk, -1, 1, cRowsFetched, &hrow, _hRegion);

    if ( isFetchOK( res ) && cRowsFetched == 1)
    {
        if (_cHRows == _cRowsDisp)
        {
            // Release last row
            _xRowset->ReleaseRows (1, _aHRows + _cHRows - 1, 0, 0, 0);
        }
        else
        {
            _cHRows++;
        }
        // shift all rows down
        for (ULONG i = _cHRows - 1; i > 0; i--)
            _aHRows [i] = _aHRows [i-1];
        _aHRows [0] = hrow;
        GetBookMark (hrow, _bmkTop);
    }
    else
    {
        *pDist = 0;
        _bmkTop.MakeFirst();
    }
} //ScrollLineUp

void CSearchQuery::ScrollLineDn(
    long* pDist)
{
    if (_cHRows < _cRowsDisp || _cHRows == 0)
    {
        // can't scroll
        *pDist = 0;
    }
    else
    {
        // Try to fetch new last row
        HROW hrow;
        CBookMark bmk;
        GetBookMark (_aHRows[_cHRows-1], bmk);
        DBCOUNTITEM cRowsFetched = 0;
        if ( !_xWatch.IsNull() )
            _xWatch->Move( _hRegion );
        FetchResult res = Fetch ( bmk, 1, 1, cRowsFetched, &hrow, _hRegion);
        if ( ( isFetchOK( res )  ) && ( 1 == cRowsFetched ) )
        {
            // release zeroth row
            _xRowset->ReleaseRows (1, _aHRows, 0, 0, 0);
            // shift all rows up
            for (ULONG i = 0; i < _cHRows - 1; i++)
                _aHRows [i] = _aHRows [i+1];
            // if we fetched the row
            if (cRowsFetched == 1)
                _aHRows [_cHRows - 1] = hrow;
            GetBookMark (_aHRows[0], _bmkTop);
        }
        else *pDist = 0;
    }
} //ScrollLineDn

void CSearchQuery::ScrollPageUp(
    long* pDist)
{
    if (_cHRows == 0)
    {
        *pDist = 0;
        return;
    }

    // Try to fetch new first rows
    CBookMark bmk;
    GetBookMark (_aHRows[0], bmk);
    DBCOUNTITEM cRowsFetched = 0;
    long count = *pDist;
    FetchResult res;

    if ( !_xWatch.IsNull() )
        _xWatch->Move( _hRegion );
    res = Fetch ( bmk, -count, count, cRowsFetched, _aHRowsTmp, _hRegion);

    *pDist = (long) cRowsFetched;

    if ( isFetchOK( res ) && cRowsFetched != 0)
    {
        // release rows at the end
        int cRowsToRelease = (int) ( _cHRows + cRowsFetched - _cRowsDisp );
        int cRowsToShift   = (int) ( _cRowsDisp - cRowsFetched );

        _cHRows += (ULONG) cRowsFetched;

        if (cRowsToRelease > 0)
        {
            Win4Assert ( cRowsToShift >= 0);
            _xRowset->ReleaseRows (cRowsToRelease,
                                   _aHRows + cRowsToShift, 0, 0, 0);
            _cHRows -= cRowsToRelease;
        }

        if (cRowsToShift > 0)
        {
            for (int i = 0; i < cRowsToShift; i++)
                _aHRowsTmp[cRowsFetched + i] = _aHRows[i];
        }

        for (ULONG i = 0; i < _cRowsDisp; i++)
            _aHRows[i] = _aHRowsTmp[i];

        if (res == fetchBoundary)
            _bmkTop.MakeFirst();
        else
            GetBookMark (_aHRows[0], _bmkTop);
    }
} //ScrollPageUp

void CSearchQuery::ScrollPageDn(
    long* pDist)
{
    if (_cHRows < _cRowsDisp || _cHRows == 0)
    {
        // can't scroll
        *pDist = 0;
    }
    else
    {
        // Try to fetch new bottom rows
        CBookMark bmk;
        GetBookMark (_aHRows[_cHRows-1], bmk);
        DBCOUNTITEM cRowsFetched = 0;

        if ( !_xWatch.IsNull() )
            _xWatch->Move( _hRegion );

        FetchResult res = Fetch ( bmk, 1, *pDist, cRowsFetched, _aHRowsTmp, _hRegion);
        *pDist = (long) cRowsFetched;

        if ( isFetchOK( res )  && ( cRowsFetched > 0 ) )
        {
            int cRowsToRelease = (int) ( cRowsFetched + _cHRows - _cRowsDisp );
            int cRowsToShift   = (int) ( _cRowsDisp - cRowsFetched );

            // release top rows
            _xRowset->ReleaseRows (cRowsToRelease, _aHRows, 0, 0, 0);

            // shift all rows up
            for (int i = 0; i < cRowsToShift; i++)
                _aHRows [i] = _aHRows [i+cRowsToRelease];

            for (ULONG j = 0; j < cRowsFetched; j++)
                _aHRows [cRowsToShift + j] = _aHRowsTmp[j];

            _cHRows = (ULONG) ( cRowsToShift + cRowsFetched );

            GetBookMark (_aHRows[0], _bmkTop);
        }
    }
} //ScrollPageDn

void CSearchQuery::ScrollBottom(
    long* pDist)
{
    CBookMark bmk(DBBMK_LAST);
    DBCOUNTITEM cRowsFetched = 0;

    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);

    FetchResult res = Fetch ( bmk, 1 - *pDist, *pDist, cRowsFetched, _aHRowsTmp, _hRegion);

    if ( isFetchOK( res ) )
    {
        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        for (ULONG i = 0; i < cRowsFetched; i++)
            _aHRows[i] = _aHRowsTmp[i];
        for (; i < _cHRows; i++)
            _aHRows[i] = 0;
        _cHRows = (ULONG) cRowsFetched;
        *pDist = (long) cRowsFetched;
        GetBookMark (_aHRows[0], _bmkTop);
    }
} //ScrollBottom

void CSearchQuery::ScrollTop(
    long* pDist)
{
    CBookMark bmk(DBBMK_FIRST);

    DBCOUNTITEM cRowsFetched = 0;
    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);
    FetchResult res = Fetch ( bmk, 0, *pDist, cRowsFetched, _aHRowsTmp, _hRegion);

    if ( isFetchOK( res ) )
    {
        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        for (ULONG i = 0; i < cRowsFetched; i++)
            _aHRows[i] = _aHRowsTmp[i];
        for (; i < _cHRows; i++)
            _aHRows[i] = 0;
        _cHRows = (ULONG) cRowsFetched;
        *pDist = (long) cRowsFetched;
    }
    _bmkTop.MakeFirst();
} //ScrollTop

void CSearchQuery::ScrollPos(
    long* pDist)
{
    DBCOUNTITEM cRowsFetched = 0;

    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);

    if (FetchApprox (*pDist, _cRowsDisp, cRowsFetched, _aHRowsTmp, _hRegion))
    {
        _xRowset->ReleaseRows(_cHRows, _aHRows, 0, 0, 0);
        for (ULONG i = (ULONG) cRowsFetched; i < _cHRows; i++)
            _aHRows[i] = 0;

        for (i = 0; i < cRowsFetched; i++)
            _aHRows [i] = _aHRowsTmp [i];
        _cHRows = (ULONG) cRowsFetched;

        CBookMark bmk;
        GetBookMark (_aHRowsTmp[0], bmk);
        _xRowset->GetApproximatePosition(0, bmk.cbBmk, bmk.abBmk, &_iRowCurrent, &_cRowsTotal);

        if (_iRowCurrent > 0)
            _iRowCurrent--;

        *pDist = (long) _iRowCurrent;
        GetBookMark (_aHRows[0], _bmkTop);
    }
    else
        *pDist = -1;
} //ScrollPos


void CSearchQuery::InvalidateCache()
{
    ULONG cRows = _cRowsDisp;
    ULONG zero = 0;
    WindowResized (zero);
    WindowResized (cRows);
} //InvalidateCache

void CSearchQuery::UpdateProgress(
    BOOL& fMore)
{
    if ( _xRowset.IsNull() )
    {
        _pctDone = 0;
        return;
    }

#if 0
    if ( !_xRowsetStatus.IsNull() )
    {
        ULONG ulNumerator,ulDenominator;
        DWORD cFilteredDocs,cDocsToFilter;
        SCODE sc;
        if ( 0 != _cHRows )
        {
            sc = _xRowsetStatus->GetStatusEx( &_dwQueryStatus,
                                              &cFilteredDocs,
                                              &cDocsToFilter,
                                              &ulDenominator,
                                              &ulNumerator,
                                              _bmkTop.cbBmk,
                                              _bmkTop.abBmk,
                                              &_iRowCurrent,
                                              &_cRowsTotal );
            _iRowCurrent--;      // zero base
        }
        else
        {
            DWORD current;
            sc = _xRowsetStatus->GetStatusEx( &_dwQueryStatus,
                                              &cFilteredDocs,
                                              &cDocsToFilter,
                                              &ulDenominator,
                                              &ulNumerator,
                                              0,
                                              0,
                                              &current,
                                              &_cRowsTotal );
        }

        if ( FAILED( sc ) )
        {
            // query failed when we weren't looking

            _pctDone = 100;
            _iRowCurrent = 0;
            _cRowsTotal = 0;
            _fDone = TRUE;
            _dwQueryStatus = STAT_ERROR;
            _scLastError = sc;
        }
        else
        {
            Win4Assert( ulNumerator <= ulDenominator );

            _pctDone = 100 * ulNumerator;
            if ( 0 == ulDenominator )       // Prevent division by 0
                ulDenominator = 1;
            _pctDone /= ulDenominator;
        }
    }
    else
#endif // 0
    {
        DBCOUNTITEM ulNumerator, ulDenominator;
        DBASYNCHPHASE ulAsynchPhase;
        SCODE sc = _xDBAsynchStatus->GetStatus( DB_NULL_HCHAPTER,
                                                DBASYNCHOP_OPEN,
                                                &ulNumerator,
                                                &ulDenominator,
                                                &ulAsynchPhase,
                                                0 );

        if ( FAILED( sc ) )
        {
            // query failed when we weren't looking

            _pctDone = 100;
            _iRowCurrent = 0;
            _cRowsTotal = 0;
            _fDone = TRUE;
        }
        else
        {
            if ( !_xRowsetStatus.IsNull() )
                _xRowsetStatus->GetStatus( &_dwQueryStatus );

            Win4Assert( (ulAsynchPhase == DBASYNCHPHASE_COMPLETE) ?
                             (ulNumerator == ulDenominator) :
                             (ulNumerator <  ulDenominator) );

            _pctDone = 100 * (ULONG) ulNumerator;
            if ( 0 == ulDenominator )       // Prevent division by 0
                ulDenominator = 1;
            _pctDone /= (ULONG) ulDenominator;

            if (_cHRows != 0)
            {
                _xRowset->GetApproximatePosition( 0,
                                                  _bmkTop.cbBmk,
                                                  _bmkTop.abBmk,
                                                  &_iRowCurrent,
                                                  &_cRowsTotal );
                _iRowCurrent--;      // zero base
            }
            else
            {
                _xRowset->GetApproximatePosition(0, 0, 0, 0, &_cRowsTotal);
            }
        }
    }
} //UpdateProgress

void CSearchQuery::ProcessNotification(
    HWND          hwndList,
    DBWATCHNOTIFY changeType,
    IRowset *     pRowset)
{
    if ( _xRowset.GetPointer() == pRowset && !_xWatch.IsNull() )
        _xWatch->Notify( hwndList, changeType );
    _dwEndTime = GetTickCount();
} //ProcessNotification

void CSearchQuery::ProcessNotificationComplete()
{
    if ( !_xWatch.IsNull() )
        _xWatch->NotifyComplete();
} //ProcessNotificationComplete

void CSearchQuery::CreateScript(
    DBCOUNTITEM *       pcChanges,
    DBROWWATCHCHANGE ** paScript)
{
    if (_cRowsDisp == 0)
    {
        *pcChanges = 0;
        return;
    }

    Win4Assert (_cHRows == 0 || _aHRows[_cHRows-1] != 0);

    *paScript = (DBROWWATCHCHANGE*) CoTaskMemAlloc (2 * _cRowsDisp * sizeof DBROWWATCHCHANGE);

    DBCOUNTITEM cRowsFetched = 0;
    if ( !_xWatch.IsNull() )
        _xWatch->Move (_hRegion);
    //srchDebugOut((DEB_TRACE,"CreateScript fetch\n"));
    Fetch ( _bmkTop, 0, _cRowsDisp, cRowsFetched, _aHRowsTmp, _hRegion);

    if (cRowsFetched > 0)
    {
        //srchDebugOut((DEB_TRACE,"  CreateScript fetched %d rows\n",cRowsFetched));
        ULONG iSrc = 0;
        ULONG iDst = 0;

        do
        {
            if ( iDst == _cHRows || _aHRows[iDst] != _aHRowsTmp [iSrc])
            {
                // maybe the current iDst row was deleted?
                // Find out it the iSrc row appears
                // somewhere after the current row
                for (ULONG i = iDst + 1; i < _cHRows; i++)
                {
                    if (_aHRows[i] == _aHRowsTmp[iSrc])
                        break;
                }

                if (i < _cHRows && iSrc < _cRowsDisp )
                {
                    // everything from iDst up to i - 1
                    // has been deleted
                    while ( iDst < i )
                    {
                        DBROWWATCHCHANGE& change = (*paScript)[*pcChanges];
                        change.hRegion = _hRegion;
                        change.eChangeKind = DBROWCHANGEKIND_DELETE;
                        change.iRow = iSrc;
                        change.hRow =  0;
                        (*pcChanges)++;
                        iDst++;
                    }
                }
                else
                {
                    // insertion
                    DBROWWATCHCHANGE& change = (*paScript)[*pcChanges];
                    change.hRegion = _hRegion;
                    change.eChangeKind = DBROWCHANGEKIND_INSERT;
                    change.iRow = iSrc - 1;
                    change.hRow =  _aHRowsTmp[iSrc];
                    (*pcChanges)++;
                    iSrc++;
                }
            }
            else
            {
                //srchDebugOut((DEB_TRACE,"  CreateScript ignoring row %d\n",_aHRowsTmp[iSrc]));
                _xRowset->ReleaseRows ( 1, _aHRowsTmp + iSrc, 0, 0, 0);
                iDst++;
                iSrc++;
            }


        } while (iDst < _cRowsDisp && iSrc < cRowsFetched);

        if ( iSrc < cRowsFetched )
        {
            //srchDebugOut((DEB_TRACE,"  CreateScript freeing rows left behind\n"));
            _xRowset->ReleaseRows ( cRowsFetched - iSrc,
                                    _aHRowsTmp + iSrc,
                                    0, 0, 0);
        }
        else if (iSrc == cRowsFetched && iSrc < _cRowsDisp)
        {
            // the rest of the rows were deleted
            while (iDst < _cHRows)
            {
                DBROWWATCHCHANGE& change = (*paScript)[*pcChanges];
                change.hRegion = _hRegion;
                change.eChangeKind = DBROWCHANGEKIND_DELETE;
                change.iRow = iSrc;
                change.hRow =  0;
                (*pcChanges)++;
                iDst++;
            }
        }
    }

    if (*pcChanges == 0)
    {
        CoTaskMemFree (*paScript);
        *paScript = 0;
    }
} //CreateScript

void CSearchQuery::InsertRowAfter(
    int iRow,
    HROW hrow)
{
    Win4Assert (iRow >= -1 && iRow < (int) _cHRows && iRow < (int)_cRowsDisp - 1);

    int iLastRow = _cHRows - 1;
    // release last row
    if (_cHRows == _cRowsDisp)
    {
        //srchDebugOut((DEB_TRACE,"InsertRowAfter releasing 1 row %d\n",_aHRows[iLastRow]));
        _xRowset->ReleaseRows(1, _aHRows + iLastRow, 0, 0, 0);
        // shift rows down
        for (int i = iLastRow; i > iRow + 1; i--)
        {
            _aHRows [i] = _aHRows [i-1];
        }
    }
    else
    {
        // shift rows down
        for (int i = iLastRow + 1; i > iRow + 1; i--)
        {
            _aHRows [i] = _aHRows [i-1];
        }
        _cHRows++;
    }
    _aHRows [iRow + 1] = hrow;
    if (iRow == -1 && !_bmkTop.IsFirst())
    {
        GetBookMark (_aHRows[0], _bmkTop);
    }
} //InsertRowAfter

void CSearchQuery::DeleteRow(
    int iRow)
{
// with limited rows, rows to be deleted may exceed the number of
//          rows in the result
    //Win4Assert (iRow >= 0 && iRow < (int)_cHRows);

    if ( _aHRows[iRow] > 0 )
    {
        _xRowset->ReleaseRows (1, _aHRows + iRow, 0, 0, 0);
        _aHRows[iRow] = 0;
    }

    // shift  rows up
    for (ULONG i = iRow; i < _cHRows - 1; i++)
        _aHRows [i] = _aHRows [i+1];
#if 0
    if (_cHRows < _cRowsDisp)
    {
        _aHRows[_cHRows-1] = 0;
        _cHRows--;
    }
    else
    {
        // Try to fetch new last row
        HROW hrow;
        CBookMark bmk;
        GetBookMark (_aHRows[_cHRows-1], bmk);
        DBCOUNTITEM cRowsFetched = 0;
        // no need when running script
        if ( !_xWatch.IsNull() )
            _xWatch->Move (_hRegion);
        FetchResult res = Fetch ( bmk, 1, 1, cRowsFetched, &hrow, _hRegion);

        if ( isFetchOK( res ) && ( cRowsFetched > 0 ) )
            _xRowset->ReleaseRows(1, &hrow, 0, 0, 0);
    }
#else
    if ( (ULONG)iRow < _cHRows )
    {
        _aHRows[_cHRows-1] = 0;
        _cHRows--;
    }
#endif
    if (iRow == 0 && !_bmkTop.IsFirst() && _aHRows[0] != 0)
        GetBookMark (_aHRows[0], _bmkTop);
} //DeleteRow

void CSearchQuery::UpdateRow(
    int iRow,
    HROW hrow)
{
    Win4Assert (iRow >= 0 && iRow < (int)_cHRows);
    //srchDebugOut((DEB_TRACE,"UpdateRowAfter releasing 1 row %d\n",_aHRows[iRow]));
    _xRowset->ReleaseRows (1, _aHRows + iRow, 0, 0, 0);
    _aHRows[iRow] = hrow;
} //UpdateRow

BOOL CSearchQuery::GetSelectedRowData(
    WCHAR *&rpPath,
    HROW &hrow )
{
    if (!_bmkSelect.IsValid())
        return FALSE;

    DBCOUNTITEM cRowsFetched = 0;
    FetchResult res = Fetch ( _bmkSelect, 0, 1, cRowsFetched, &hrow, 0);

    if ( ( !isFetchOK( res ) ) || ( cRowsFetched != 1 ) )
        return FALSE;

    return SUCCEEDED( _xRowset->GetData( hrow, _hBrowseAccessor, &rpPath ) );

} //GetSelectedRowData

void CSearchQuery::FreeSelectedRowData(
    HROW hrow )
{
   _xRowset->ReleaseRows( 1, &hrow, 0, 0, 0 );
} //FreeSelectedRowData

BOOL CSearchQuery::Browse( enumViewFile eViewType )
{
    BOOL fOK = TRUE;

    if (!_bmkSelect.IsValid())
        return TRUE;

    HROW hrow;
    DBCOUNTITEM cRowsFetched = 0;
    FetchResult res = Fetch( _bmkSelect, 0, 1, cRowsFetched, &hrow, 0 );

    if ( ( !isFetchOK( res ) ) || ( cRowsFetched != 1 ) )
        return fOK;

    WCHAR *pwcPathFound;
    SCODE sc = _xRowset->GetData( hrow, _hBrowseAccessor, &pwcPathFound );

    if (SUCCEEDED(sc) && ( 0 != _prstQuery ) )
    {
        fOK = ViewFile( pwcPathFound, eViewType, 1, _prstQuery );
        _xRowset->ReleaseRows(1, &hrow, 0, 0, 0);
    }
    else
        fOK = FALSE;

    return fOK;
} //Browse

//
// Helper method(s)
//

void CSearchQuery::ParseCatList( WCHAR * * aScopes, WCHAR * * aCatalogs,
                                 WCHAR * * aMachines, DWORD * aDepths,
                                 ULONG & cScopes )
{
    BOOL fDeep;
    WCHAR aScope[MAX_PATH];
    WCHAR aCatalog[MAX_PATH];
    WCHAR aMachine[MAX_PATH];

    for(cScopes = 0; ; cScopes++)
    {
        if ( !GetCatListItem( _xCatList,
                             cScopes,
                             aMachine,
                             aCatalog,
                             aScope,
                             fDeep ) )
        {
            break;
        }
        aMachines[cScopes] = new WCHAR[ wcslen( aMachine ) + 1 ];
        aCatalogs[cScopes] = new WCHAR[ wcslen( aCatalog ) + 1 ];
        aScopes[cScopes] = new WCHAR[ wcslen( aScope ) + 1 ];

        wcscpy( aMachines[cScopes], aMachine );
        wcscpy( aCatalogs[cScopes], aCatalog );
        wcscpy( aScopes[cScopes], aScope );

        aDepths[cScopes] = ( fDeep ? QUERY_DEEP : QUERY_SHALLOW );

        // If the scope is virtual, set the flag and flip the slashes

        if ( L'/' == aScope[0] )
        {
            aDepths[ cScopes ] |= QUERY_VIRTUAL_PATH;
            for ( WCHAR *p = aScopes[cScopes]; *p; p++ )
                if ( L'/' == *p )
                    *p = L'\\';
        }
    }
}

SCODE CSearchQuery::InstantiateICommand(
    ICommand ** ppICommand )
{
    DWORD aDepths[ 20 ]; // hope 20 is big enough
    WCHAR * aScopes[ 20 ];
    WCHAR * aCatalogs[ 20 ];
    WCHAR * aMachines[ 20 ];
    ULONG cScopes = 0;

    SCODE sc = S_FALSE;

    ParseCatList( aScopes, aCatalogs, aMachines, aDepths, cScopes );

    *ppICommand = 0;

    sc = CIMakeICommand( ppICommand,
                         cScopes,
                         aDepths,
                         (WCHAR const * const *)aScopes,
                         (WCHAR const * const *)aCatalogs,
                         (WCHAR const * const *)aMachines );

    unsigned ii;
    for( ii = 0; ii < cScopes; ii ++)
    {
        delete [] aMachines[ii]; // This mem may not get deleted if we throw
        delete [] aCatalogs[ii]; // in this func ?
        delete [] aScopes[ii];
    }

    return sc;
} //InstantiateICommand


BOOL CSearchQuery::FetchApprox(
    LONG iFirstRow,
    LONG cToFetch,
    DBCOUNTITEM &rcFetched,
    HROW *pHRows,
    HWATCHREGION hRegion)
{
    SCODE sc;

    if ( 0 != _cRowsTotal )
    {
        sc = _xRowset->GetRowsAtRatio( hRegion,
                                       0,      // no chapters
                                       iFirstRow,
                                       _cRowsTotal,
                                       cToFetch,
                                       &rcFetched,
                                       &pHRows );
        if ( FAILED( sc ) )
            _scLastError = sc;
    }
    else
    {
        rcFetched = 0;

        sc = S_OK;
    }

    return (SUCCEEDED(sc) && rcFetched);
} //FetchApprox

FetchResult CSearchQuery::Fetch(
    CBookMark &   bmkStart,
    LONG          iFirstRow,
    LONG          cToFetch,
    DBCOUNTITEM & rcFetched,
    HROW *        pHRows,
    HWATCHREGION  hRegion)
{
    //srchDebugOut((DEB_TRACE,"  Fetch fetch\n"));

    Win4Assert (bmkStart.IsValid());

    SCODE scTmp;

    SCODE sc = _xRowset->GetRowsAt( hRegion,
                                    0,   // no chapters
                                    bmkStart.cbBmk,
                                    bmkStart.abBmk,
                                    iFirstRow,
                                    cToFetch,
                                    &rcFetched,
                                    &pHRows );
    WCHAR* szError = 0;
    WCHAR  buf[100];

    if ( FAILED( sc ) )
        _scLastError = sc;

    switch (sc)
    {
        case S_OK:
            //srchDebugOut((DEB_TRACE,"  ::fetch ok got %d rows, first: %d\n",rcFetched,pHRows[0]));
            if (cToFetch == (long)rcFetched)
                return fetchOk;
            else
                szError = L"Incomplete Fetch returned S_OK";
            break;

        case DB_S_ENDOFROWSET:
            //srchDebugOut((DEB_TRACE,"  ::fetch EOR got %d rows, first: %d\n",rcFetched,pHRows[0]));

            // Debugging
            // Turn it back on when we have frozen state!
            //
            if ( FALSE && rcFetched != 0)
            {
                HROW* pHRowsTmp = new HROW [cToFetch];
                DBCOUNTITEM cFetchedTmp = 0;
                CBookMark bmk;
                GetBookMark (pHRows[0], bmk);
                scTmp = _xRowset->GetRowsAt( hRegion,
                                             0,         // no chapters
                                             bmk.cbBmk,
                                             bmk.abBmk,
                                             0,
                                             cToFetch,
                                             &cFetchedTmp,
                                             &pHRowsTmp );
                if (FAILED(scTmp))
                {
                    szError = buf;
                    swprintf (buf, L"Repeated call returned error 0x%04x", scTmp);
                }
                else if (cFetchedTmp < rcFetched)
                {
                    szError = L"Repeated call returned fewer rows";
                }
                else
                {

                    for (ULONG i = 0; i < rcFetched; i++)
                    {
                        if (pHRows[i] != pHRowsTmp[i])
                        {
                            szError = L"Repeated call returned different HROWs";
                            break;
                        }
                    }

                }
                _xRowset->ReleaseRows(cFetchedTmp, pHRowsTmp, 0, 0, 0);
                delete pHRowsTmp;
                if (szError != 0)
                    break;
            }
            return fetchBoundary;

        case DB_E_BADSTARTPOSITION:
            //srchDebugOut((DEB_TRACE,"  ::fetch %d returned DB_E_BADSTARTPOSITION \n",cToFetch));
            //Win4Assert(sc != DB_E_BADSTARTPOSITION);
            szError = L"DB_E_BADSTARTPOSITION";
            break;
        case DB_S_BOOKMARKSKIPPED:
            szError = L"DB_S_BOOKMARKSKIPPED";
            break;
        case DB_S_ROWLIMITEXCEEDED:
            szError = L"DB_S_ROWLIMITEXCEEDED";
            break;
        case DB_E_BADBOOKMARK:
            szError = L"DB_E_BADBOOKMARK";
            break;
        case DB_E_BADCHAPTER:
            szError = L"DB_E_BADCHAPTER";
            break;
        case DB_E_NOTREENTRANT:
            szError = L"DB_E_NOTREENTRANT";
            break;
        case E_FAIL:
            szError = L"E_FAIL";
            break;
        case E_INVALIDARG:
            szError = L"E_INVALIDARG";
            break;
        case E_OUTOFMEMORY:
            szError = L"E_OUTOFMEMORY";
            break;
        case E_UNEXPECTED:
            szError = L"E_UNEXPECTED";
            break;
        default:
            szError = buf;
            swprintf (buf, L"Unexpected error 0x%04x", sc);
    }
    //MessageBox ( 0, szError, L"GetRowsAt", MB_OK );
    return fetchError;
} //Fetch

const unsigned cAtATime = 20;

void CSearchQuery::WriteResults()
{
    CBookMark bmk(DBBMK_FIRST);
    XArray<HROW> xRows( cAtATime );
    ULONG cRowsToGo = (ULONG) _cRowsTotal;
    CDynArrayInPlace<WCHAR> awcBuf( 4096 );
    int cwc = 0;

    while ( 0 != cRowsToGo )
    {
        DBCOUNTITEM cFetched = 0;
        FetchResult res = Fetch( bmk,
                                 (LONG) ( _cRowsTotal - cRowsToGo ),
                                 __min( cAtATime, cRowsToGo ),
                                 cFetched,
                                 xRows.GetPointer(),
                                 0 );

        if ( ( fetchError == res ) ||
             ( 0 == cFetched ) )
            return;

        cRowsToGo -= (ULONG) cFetched;

        for ( ULONG row = 0; row < cFetched; row++ )
        {
            WCHAR *pwcPath;
            _xRowset->GetData( xRows[ row ], _hBrowseAccessor, &pwcPath );

            while ( *pwcPath )
                awcBuf[ cwc++ ] = *pwcPath++;

            awcBuf[ cwc++ ] = L'\r';
            awcBuf[ cwc++ ] = L'\n';
        }

        _xRowset->ReleaseRows( cFetched, xRows.GetPointer(), 0, 0, 0 );
    }

    awcBuf[ cwc++ ] = 0;
    PutInClipboard( awcBuf.Get() );
} //WriteResults

const unsigned COUNT_HIDDEN_COLUMNS = 1;

void CSearchQuery::SetupColumnMappingsAndAccessors()
{
    // allocate the necessary resources

    unsigned cColumns = _columns.NumberOfColumns();
    DBID aDbCols[maxBoundCols];

    for ( unsigned iCol = 0; iCol < cColumns; iCol++ )
    {
        // Get the next desired property

        DBTYPE propType;
        unsigned int uiWidth;
        DBID *pdbid;
        SCODE sc = _columnMapper.GetPropInfoFromName( _columns.GetColumn( iCol ),
                                                      &pdbid,
                                                      &propType,
                                                      &uiWidth );
        memcpy( &aDbCols[ iCol ], pdbid, sizeof DBID );

        if (FAILED(sc))
            THROW( CException( sc ) );
    }

    IColumnsInfo *pColInfo = 0;

    SCODE sc = _xRowset->QueryInterface ( IID_IColumnsInfo,
                                          ( void ** )&pColInfo );
    if (FAILED(sc))
        THROW( CException( sc ) );

    XInterface< IColumnsInfo > xColInfo( pColInfo );

    DBORDINAL aColumnIds[ maxBoundCols ];

    // Map the columns
    sc = pColInfo->MapColumnIDs( cColumns, aDbCols, aColumnIds );

    if (FAILED(sc))
        THROW (CException (sc));

    // Map hidden columns

    DBID apsHidden[COUNT_HIDDEN_COLUMNS];

    apsHidden[0] = dbcolPath;

    DBORDINAL aColumnIdHidden[COUNT_HIDDEN_COLUMNS];

    sc = pColInfo->MapColumnIDs( 1,
                                 apsHidden,
                                 aColumnIdHidden );
    if (FAILED(sc))
        THROW (CException (sc));

    // allocate the necessary resources and cache in the
    // object

    DBBINDING aGenBindings[maxBoundCols];
    ULONG oCurrentOffset = 0;

    // Add each requested property to the binding

    for ( unsigned iBind = 0; iBind < cColumns; iBind++ )
    {
        // Set up the binding array

        aGenBindings[ iBind ].iOrdinal = aColumnIds[ iBind ];        // Ordinal of column
        aGenBindings[ iBind ].obValue = oCurrentOffset;              // Offset of data
        aGenBindings[ iBind ].obLength = 0,                          // Offset where length data is stored
        aGenBindings[ iBind ].obStatus = 0,                          // Status info for column written
        aGenBindings[ iBind ].pTypeInfo = 0,                         // Reserved
        aGenBindings[ iBind ].pObject = 0,                           // DBOBJECT structure
        aGenBindings[ iBind ].pBindExt = 0,                          // Ignored
        aGenBindings[ iBind ].dwPart = DBPART_VALUE;                 // Return data
        aGenBindings[ iBind ].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Memory owne
        aGenBindings[ iBind ].eParamIO = 0;                          // eParamIo
        aGenBindings[ iBind ].cbMaxLen = sizeof(PROPVARIANT *);      // Size of data to return
        aGenBindings[ iBind ].dwFlags = 0;                           // Reserved
        aGenBindings[ iBind ].wType = DBTYPE_VARIANT | DBTYPE_BYREF; // Type of return data
        aGenBindings[ iBind ].bPrecision = 0;                        // Precision to use
        aGenBindings[ iBind ].bScale = 0;                            // Scale to us

        oCurrentOffset += sizeof( PROPVARIANT *);
    }

    sc = _xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                      cColumns,
                                      aGenBindings,
                                      0,                // cbRowSize
                                      &_hAccessor,
                                      0 );

    if (FAILED(sc))
        THROW ( CException( sc ) );

    DBBINDING aBrowBindings[1];

    aBrowBindings[0] = dbbindingPath;
    aBrowBindings[0].iOrdinal = aColumnIdHidden[0];

    sc = _xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                      1,
                                      aBrowBindings,
                                      0,                // cbRowSize
                                      &_hBrowseAccessor,
                                      0 );

    if (FAILED(sc))
        THROW ( CException( sc ) );
} //SetupColumnMappingsAndAccessors
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\srch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       srch.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <htmlhelp.h>

typedef void (__stdcall * PFnCIShutdown)(void);
PFnCIShutdown g_pCIShutdown = 0;

void MyCIShutdown()
{
    if ( 0 == g_pCIShutdown )
    {
        #ifdef _WIN64
            char const * pcCIShutdown = "?CIShutdown@@YAXXZ";
        #else
            char const * pcCIShutdown = "?CIShutdown@@YGXXZ";
        #endif

        g_pCIShutdown = (PFnCIShutdown) GetProcAddress( GetModuleHandle( L"query.dll" ), pcCIShutdown );

        if ( 0 == g_pCIShutdown )
            return;
    }

    g_pCIShutdown();
} //MyCIShutdown

CSearchApp App;

int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     pcCmdLine,
    int       nCmdShow)
{
    int iRet = 0;

    CTranslateSystemExceptions xlate;

    TRY
    {
        App.Init(hInstance,nCmdShow,pcCmdLine);
    }
    CATCH(CException, e)
    {
        // hardcode these strings -- may be out of memory!

        MessageBox( 0, L"Unable to start the application.", L"srch.exe",
                    MB_OK | MB_ICONEXCLAMATION);
        iRet = -1;
    }
    END_CATCH;

    if (0 == iRet)
        iRet = App.MessageLoop();

    srchDebugOut ((DEB_TRACE,"falling out of WinMain()\n"));

    TRY
    {
        MyCIShutdown();

        App.Shutdown( hInstance );
    }
    CATCH(CException, e)
    {
    }
    END_CATCH;

    return iRet;
} //WinMain

int CSearchApp::MessageLoop()
{
    // toss out all the init code that we'll never need again

    SetProcessWorkingSetSize( GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1 );

    MSG msg;

    while (GetMessage(&msg,0,0,0))
    {
        if ( ( 0 == _hdlgCurrent ) ||
             ( !IsDialogMessage( _hdlgCurrent, &msg ) ) )
        {
            if (!TranslateMDISysAccel(_hMDIClientWnd,&msg) &&
                !TranslateAccelerator(_hAppWnd,_hAccTable,&msg))
            {
                if ((msg.message == WM_KEYDOWN) && (msg.wParam == VK_F1))
                    _ShowHelp( HH_DISPLAY_TOPIC, 0 );

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return (int)msg.wParam;
} //MessageLoop

LRESULT WINAPI MainWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    return App.WndProc(hwnd,msg,wParam,lParam);
} //MainWndProc

CSearchApp::CSearchApp():
     _hInst(0),
     _hMDIClientWnd(0),
     _hAppWnd(0),
     _hStatusBarWnd(0),
     _hToolBarWnd(0),
     _hdlgCurrent(0),
     _hAccTable(0),
     _hbrushBtnFace(0),
     _hbrushBtnHilite(0),
     _hbrushHilite(0),
     _hbrushWindow(0),
     _hfontApp(0),
     _hfontBrowse(0),
     _fHelp(FALSE),
     _iAppCmdShow(0),
     _iStartupState(0),
     _iMDIStartupState(0),
     _scBrowseLastError(0),
     _sortDir(0),
     _lcid(0),
     _fToolBarOn(FALSE),
     _fStatusBarOn(FALSE),
     _fForceUseCI(FALSE),
     _ulDialect(0),
     _ulLimit(0),
     _ulFirstRows(0),
     _sortDirINI(0),
     _lcidINI(0),
     _fToolBarOnINI(FALSE),
     _fStatusBarOnINI(FALSE),
     _fForceUseCIINI(FALSE),
     _ulDialectINI(0),
     _ulLimitINI(0),
     _ulFirstRowsINI(0)
{
    RtlZeroMemory( &_NumberFmt, sizeof( NUMBERFMT ) );
    RtlZeroMemory( &_NumberFmtFloat, sizeof( NUMBERFMT ) );
    RtlZeroMemory( &_lfApp, sizeof( LOGFONT ) );
    RtlZeroMemory( &_lfBrowse, sizeof( LOGFONT ) );

    *_awcAppFont     = 0;
    *_awcBrowseFont  = 0;
    *_awcAppPath     = 0;
    *_awcHelpFile    = 0;
    *_awcSort        = 0;
    *_awcSortINI     = 0;
} //CSearchApp

void CSearchApp::Init(
    HINSTANCE hInstance,
    int nCmdShow,
    LPSTR pcCmdLine)
{
    HRESULT hr = CoInitialize (0);

    if ( FAILED( hr ) )
        THROW( CException( hr ) );

    InitCommonControls();

    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_USEREX_CLASSES;
    InitCommonControlsEx(&icex);


    _iAppCmdShow = nCmdShow;
    _hInst = hInstance;

    _InitApplication();
    _InitInstance(pcCmdLine);
} //Init

void CSearchApp::Shutdown( HINSTANCE hInst )
{
    UnregisterClass( APP_CLASS, hInst );
    UnregisterClass( SEARCH_CLASS, hInst );
    UnregisterClass( BROWSE_CLASS, hInst );
    UnregisterClass( LIST_VIEW_CLASS, hInst );

    if ( 0 != _hfontApp )
        DeleteObject( _hfontApp );

    if ( 0 != _hfontBrowse )
        DeleteObject( _hfontBrowse );

    FreeNumberFormatInfo( _NumberFmt );
    FreeNumberFormatInfo( _NumberFmtFloat );

    _xCmdCreator.Free();

    CoUninitialize();
} //Shutdown

CSearchApp::~CSearchApp()
{
} //~CSearchApp

BOOL WINAPI AboutDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fRet = FALSE;

    switch (msg)
    {
        case WM_INITDIALOG :
            CenterDialog(hdlg);
            fRet = TRUE;
            break;
        case WM_COMMAND :
            EndDialog(hdlg,TRUE);
            break;
    }

    return fRet;
} //AboutDlgProc

#if 0

BOOL WINAPI BrowseToolDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fRet = FALSE;
    UINT uiID;
    WCHAR awcCmd[MAX_PATH];
    DWORD dwSize;
    int fStrip;

    switch (msg)
    {
        case WM_INITDIALOG :
            dwSize = sizeof awcCmd;
            if (!GetReg(CISEARCH_REG_BROWSE,awcCmd,&dwSize))
                wcscpy(awcCmd,BROWSER);

            fStrip = GetRegInt(CISEARCH_REG_BROWSESTRIP,FALSE);

            SetDlgItemText(hdlg,ID_BR_EDIT,L"");
            EnableWindow(GetDlgItem(hdlg,ID_BR_EDIT),FALSE);
            EnableWindow(GetDlgItem(hdlg,ID_BR_STRIP),FALSE);

            if (!_wcsicmp(awcCmd,BROWSER))
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_BROWSER);
            else if (!_wcsicmp(awcCmd,BROWSER_SLICK))
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_SLICK);
            else if (!_wcsicmp(awcCmd,BROWSER_SLICK_SEARCH))
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_SLICK_SEARCH);
            else
            {
                CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,ID_BR_CUSTOM);
                SetDlgItemText(hdlg,ID_BR_EDIT,awcCmd);
                EnableWindow(GetDlgItem(hdlg,ID_BR_EDIT),TRUE);
                EnableWindow(GetDlgItem(hdlg,ID_BR_STRIP),TRUE);
                CheckDlgButton(hdlg,ID_BR_STRIP,fStrip);
            }

            CenterDialog(hdlg);

            fRet = TRUE;
            break;
        case WM_COMMAND :
            uiID = MyWmCommandID(wParam,lParam);
            switch (uiID)
            {
                case ID_BR_BROWSER:
                case ID_BR_SLICK:
                case ID_BR_SLICK_SEARCH:
                case ID_BR_CUSTOM:
                    SetDlgItemText(hdlg,ID_BR_EDIT,L"");
                    EnableWindow(GetDlgItem(hdlg,ID_BR_EDIT),ID_BR_CUSTOM == uiID);
                    EnableWindow(GetDlgItem(hdlg,ID_BR_STRIP),ID_BR_CUSTOM == uiID);
                    CheckRadioButton(hdlg,ID_BR_BROWSER,ID_BR_CUSTOM,uiID);

                    if (ID_BR_CUSTOM == uiID)
                    {
                        SetFocus(GetDlgItem(hdlg,ID_BR_EDIT));
                        MySendEMSetSel(GetDlgItem(hdlg,ID_BR_EDIT),0,(UINT) -1);
                    }

                    break;
                case IDOK:
                    fStrip = FALSE;

                    if (IsDlgButtonChecked(hdlg,ID_BR_BROWSER))
                        wcscpy(awcCmd,BROWSER);
                    else if (IsDlgButtonChecked(hdlg,ID_BR_SLICK))
                        wcscpy(awcCmd,BROWSER_SLICK);
                    else if (IsDlgButtonChecked(hdlg,ID_BR_SLICK_SEARCH))
                        wcscpy(awcCmd,BROWSER_SLICK_SEARCH);
                    else
                    {
                        GetDlgItemText(hdlg,ID_BR_EDIT,awcCmd,sizeof awcCmd);
                        fStrip = IsDlgButtonChecked(hdlg,ID_BR_STRIP);
                    }
                    if (0 == awcCmd[0])
                        wcscpy(awcCmd,BROWSER);
                    SetReg(CISEARCH_REG_BROWSE,awcCmd);
                    SetRegInt(CISEARCH_REG_BROWSESTRIP,fStrip);
                    // fall through!
                case IDCANCEL:
                    EndDialog(hdlg,IDOK == uiID);
                    break;
            }
            break;
    }

    return fRet;
} //BrowseToolDlgProc

#endif

void CSearchApp::_SizeMDIAndBars(
    BOOL fMove,
    int  iDX,
    int  iDY )
{
    if (_hMDIClientWnd)
    {
        int iMdiDY = iDY;
        int iMdiY = 0;

        if (_fToolBarOn)
        {
            RECT rc;
            GetWindowRect( _hToolBarWnd, &rc );
            iMdiY = rc.bottom - rc.top;
            iMdiDY -= iMdiY;
        }

        if (_fStatusBarOn)
        {
            RECT rc;
            GetWindowRect( _hStatusBarWnd, &rc );
            iMdiDY -= ( rc.bottom - rc.top );
        }

        MoveWindow( _hMDIClientWnd, 0, iMdiY, iDX, iMdiDY, TRUE );
    }

    if ( _fStatusBarOn && !fMove )
        InvalidateRect( _hStatusBarWnd, 0, TRUE );
} //_SizeMDIAndBars

void CSearchApp::_SaveProfileData()
{
    _SaveWindowState(FALSE);
    _SaveWindowState(TRUE);

    if ( _ulLimit != _ulLimitINI )
        SetRegInt( CISEARCH_REG_LIMIT, _ulLimit );

    if ( _ulFirstRows != _ulFirstRowsINI )
        SetRegInt( CISEARCH_REG_FIRSTROWS, _ulFirstRows );

    if ( _ulDialect != _ulDialectINI )
        SetRegInt( CISEARCH_REG_DIALECT, _ulDialect );

    if (_fToolBarOn != _fToolBarOnINI)
        SetRegInt(CISEARCH_REG_TOOLBAR,_fToolBarOn);

    if (_fStatusBarOn != _fStatusBarOnINI)
        SetRegInt(CISEARCH_REG_STATUSBAR,_fStatusBarOn);

    if (_fForceUseCI != _fForceUseCIINI)
        SetRegInt(CISEARCH_REG_FORCEUSECI,_fForceUseCI);

    if (_sortDir != _sortDirINI)
        SetRegInt(CISEARCH_REG_SORTDIR,_sortDir);

    if ( _wcsicmp( _awcSortINI, _awcSort ) )
        SetReg( CISEARCH_REG_SORTPROP, _awcSort );

    if ( _lcid != _lcidINI )
        SetRegLCID( CISEARCH_REG_LOCALE, _lcid );

    _MarshallFont(_lfApp,_awcAppFont,CISEARCH_REG_FONT);
    _MarshallFont(_lfBrowse,_awcBrowseFont,CISEARCH_REG_BROWSEFONT);
} //_SaveProfileData

void CSearchApp::_UnMarshallFont(
    LOGFONT &lf,
    WCHAR *pwcFont,
    WCHAR *pwcRegEntry)
{
    DWORD dwSize = MAX_PATH * sizeof WCHAR;
    if (GetReg(pwcRegEntry,pwcFont,&dwSize))
    {
        int iItalic,iUnderline,iStrikeOut,iCharSet,iQuality,iPitchAndFamily;

        swscanf(pwcFont,L"%d,%d,%d,%d,%d,%d,%d,%d,%d",&lf.lfHeight,
                &lf.lfWidth,&lf.lfWeight,&iItalic,&iUnderline,
                &iStrikeOut,&iCharSet,&iQuality,&iPitchAndFamily);

        WCHAR *pwc = pwcFont;
        for (int i = 0; *pwc && i < 9; pwc++)
            if (*pwc == ',')
                i++;

        wcscpy(lf.lfFaceName,pwc);
        lf.lfItalic = (BYTE) iItalic;
        lf.lfUnderline = (BYTE) iUnderline;
        lf.lfStrikeOut = (BYTE) iStrikeOut;
        lf.lfCharSet = (BYTE) iCharSet;
        lf.lfQuality = (BYTE) iQuality;
        lf.lfPitchAndFamily = (BYTE) iPitchAndFamily;
    }
} //_UnMarshallFont

void CSearchApp::_MarshallFont(
    LOGFONT &lf,
    WCHAR *pwcOriginal,
    WCHAR *pwcRegEntry)
{
    WCHAR awcTmp[MAX_PATH];

    swprintf(awcTmp,L"%d,%d,%d,%d,%d,%d,%d,%d,%d,%ws",lf.lfHeight,
             lf.lfWidth,lf.lfWeight,(int) lf.lfItalic,
             (int) lf.lfUnderline,(int) lf.lfStrikeOut,
             (int) lf.lfCharSet,(int) lf.lfQuality,
             (int) lf.lfPitchAndFamily,lf.lfFaceName);

    if (wcscmp(pwcOriginal,awcTmp))
        SetReg(pwcRegEntry,awcTmp);
} //_MarshallFont

void CSearchApp::_ReadDefaultFonts()
{
    _UnMarshallFont(_lfApp,_awcAppFont,CISEARCH_REG_FONT);
    _UnMarshallFont(_lfBrowse,_awcBrowseFont,CISEARCH_REG_BROWSEFONT);
} //_ReadDefaultFont

LRESULT CSearchApp::WndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lRet = 0;
    UINT uiStatus,uiFmt;
    RECT rc;
    CLIENTCREATESTRUCT ccs;
    CHOOSEFONT chf;
    HDC hdc;
    HWND hwndActive;
    WCHAR * pwcBuf;
    LONG l;
    BOOL bOn;
    HMENU hSysMenu;
    WCHAR awcWindowClass[60],*pwcAboutBonus;
    UINT uiID,uiFlags,uiCmd;

    switch (msg)
    {
        case WM_ENTERIDLE :
            if ((wParam == MSGF_MENU) && (GetKeyState(VK_F1) & 0x8000))
            {
                _fHelp = TRUE;
                PostMessage(hwnd,WM_KEYDOWN,VK_RETURN,0);
            }
            break;
        case WM_NOTIFY :
            lRet = ToolBarNotify( hwnd, msg, wParam, lParam, App.Instance() );
            break;
        case WM_MENUSELECT :
        {
            UINT uiFlags = MyMenuSelectFlags( wParam, lParam );
            UINT uiCmd = MyMenuSelectCmd( wParam, lParam );
            HMENU hmenu = MyMenuSelectHMenu( wParam, lParam );

            if (_fStatusBarOn)
            {
                UINT uiID = 0;

                if ( 0xffff == uiFlags && 0 == hmenu )
                    uiID = (UINT) -1;
                else if ( MFT_SEPARATOR == uiFlags )
                    uiID = 0;
                else if ( MF_POPUP == uiFlags )
                    uiID = 0;
                else
                {
                    uiID = uiCmd;
                    if ( uiID >= IDM_WINDOWCHILD )
                        if (uiID < (IDM_WINDOWCHILD + 20))
                            uiID = IDS_IDM_WINDOWCHILD;
                        else
                            uiID = 0;
                }

                if ( -1 == uiID )
                {
                    SendMessage( _hStatusBarWnd, SB_SIMPLE, FALSE, 0 );
                }
                else
                {
                    SendMessage( _hStatusBarWnd, SB_SIMPLE, TRUE, 0 );

                    if ( 0 != uiID )
                    {
                        WCHAR awc[ 200 ];

                        LoadString( _hInst, uiID, awc, sizeof awc / sizeof WCHAR );
                        SendMessage( _hStatusBarWnd, SB_SETTEXT, 255,
                                     (LPARAM) awc );
                    }
                }
            }
            break;
        }
        case WM_COMMAND :
        {
            uiID = MyWmCommandID(wParam,lParam);
            switch (uiID)
            {
                case IDM_STATUS_BAR :
                case IDM_ICON_BAR :
                  uiStatus = GetMenuState(GetMenu(hwnd),uiID,MF_BYCOMMAND);
                  bOn = ! (uiStatus & MF_CHECKED);
                  if (uiID == IDM_STATUS_BAR)
                  {
                      _fStatusBarOn = bOn;
                      ShowWindow(_hStatusBarWnd,bOn ? SW_SHOW : SW_HIDE);
                  }
                  else
                  {
                      _fToolBarOn = bOn;
                      ShowWindow(_hToolBarWnd,bOn ? SW_SHOW : SW_HIDE);
                  }
                  CheckMenuItem(GetMenu(hwnd),uiID,bOn ? MF_CHECKED : MF_UNCHECKED);
                  GetClientRect(hwnd,&rc);
                  _SizeMDIAndBars( FALSE, rc.right, rc.bottom );
                  break;
                case IDM_FONT :
                  {
                  BOOL fApp = IsSpecificClass(GetActiveMDI(),SEARCH_CLASS);
                  LOGFONT *pLogFont = fApp ? &_lfApp : &_lfBrowse;
                  HFONT &rhFont = fApp ? _hfontApp : _hfontBrowse;

                  hdc = GetDC(hwnd);
                  memset(&chf,0,sizeof CHOOSEFONT);
                  chf.lStructSize = sizeof CHOOSEFONT;
                  chf.hwndOwner = hwnd;
                  chf.hDC = hdc;
                  chf.lpLogFont = pLogFont;
                  chf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT;
                  chf.nFontType = SCREEN_FONTTYPE;
                  if (ChooseFont(&chf))
                  {
                      HFONT hOldFont = rhFont;
                      HFONT hNewFont = CreateFontIndirect(pLogFont);
                      if (hNewFont)
                      {
                          rhFont = hNewFont;
                          _SendToSpecificChildren(fApp ? SEARCH_CLASS :
                                                         BROWSE_CLASS,
                                                  wmNewFont,
                                                  (WPARAM) hNewFont,0);

                          if (hOldFont)
                              DeleteObject(hOldFont);
                      }
                  }
                  ReleaseDC(hwnd,hdc);
                  }
                  break;
                case IDM_OPEN :
                  SendMessage(hwnd,wmOpenCatalog,TRUE,0);
                  break;
                case IDM_ABOUT :
                {
                  CResString strApp( IDS_APPNAME );
                  CResString strBonus( IDS_ABOUT_BONUS );
                  ShellAbout(hwnd,
                             strApp.Get(),
                             strBonus.Get(),
                             LoadIcon(_hInst,L"SrchIcon"));
                  break;
                }
                //case IDM_BROWSE_TOOL :
                //  DoModalDialog(BrowseToolDlgProc,hwnd,L"BrowseToolBox",0);
                //  break;
                case IDM_EXIT :
                  SendMessage(hwnd,WM_CLOSE,0,0);
                  break;
                case IDM_TILE :
                  SendMessage(_hMDIClientWnd,WM_MDITILE,MDITILE_HORIZONTAL,0);
                  break;
                case IDM_CASCADE :
                  SendMessage(_hMDIClientWnd,WM_MDICASCADE,0,0);
                  break;
                case IDM_ARRANGE :
                  SendMessage(_hMDIClientWnd,WM_MDIICONARRANGE,0,0);
                  break;
                case IDM_EDITUNDO:
                  PassOnToEdit(EM_UNDO,0,0);
                  break;
                case IDM_EDITCOPY:
                  PassOnToEdit(WM_COPY,0,0);
                  _SendToActiveMDI(wmMenuCommand,uiID,1L);
                  break;
                case IDM_EDITPASTE:
                  PassOnToEdit(WM_PASTE,0,0);
                  break;
                case IDM_EDITCUT:
                  PassOnToEdit(WM_CUT,0,0);
                  break;
                case IDM_EDITCLEAR:
                  PassOnToEdit(EM_REPLACESEL,0,(LPARAM) L"");
                  break;
                case ACC_CTRLSPACE :
                  if ((hwndActive = GetActiveMDI()) &&
                      (hSysMenu = GetSystemMenu(hwndActive,FALSE)))
                      PostMessage(hwndActive,WM_SYSCOMMAND,SC_KEYMENU,(DWORD) '-');
                  else
                      MessageBeep(0);
                  break;
                case ACC_ALTR :
                case ACC_ALTQ :
                case ACC_TAB :
                case ACC_SHIFTTAB :
                  _SendToActiveMDI(wmAccelerator,uiID,0);
                  break;
                case IDM_CLOSE :
                  _SendToActiveMDI(WM_CLOSE,0,0);
                  break;
                case IDM_HELP_CONTENTS :
                  _ShowHelp( HH_DISPLAY_TOPIC, 0 );
                  break;

                case IDM_SEARCH :
                case IDM_SEARCHCLASSDEF :
                case IDM_SEARCHFUNCDEF :
                case IDM_NEWSEARCH :
                case IDM_BROWSE :
                case IDM_NEXT_HIT :
                case IDM_PREVIOUS_HIT :
                case IDM_WRITE_RESULTS :
                case IDM_SCOPE_AND_DEPTH :
                case IDM_FILTER_SCOPE :

                case IDM_LOCALE_NEUTRAL:
                case IDM_LOCALE_CHINESE_TRADITIONAL:
                case IDM_LOCALE_CHINESE_SIMPLIFIED:
                case IDM_LOCALE_CHINESE_HONGKONG:
                case IDM_LOCALE_CHINESE_SINGAPORE:
                case IDM_LOCALE_CHINESE_MACAU:
                case IDM_LOCALE_DUTCH_DUTCH:
                case IDM_LOCALE_ENGLISH_CAN:
                case IDM_LOCALE_ENGLISH_US:
                case IDM_LOCALE_ENGLISH_UK:
                case IDM_LOCALE_FINNISH_DEFAULT:
                case IDM_LOCALE_FARSI_DEFAULT:
                case IDM_LOCALE_FRENCH_FRENCH:
                case IDM_LOCALE_FRENCH_CANADIAN:
                case IDM_LOCALE_GERMAN_GERMAN:
                case IDM_LOCALE_GREEK_DEFAULT:
                case IDM_LOCALE_HEBREW_DEFAULT:
                case IDM_LOCALE_HINDI_DEFAULT:
                case IDM_LOCALE_ITALIAN_ITALIAN:
                case IDM_LOCALE_JAPANESE_DEFAULT:
                case IDM_LOCALE_KOREAN_KOREAN:
//                case IDM_LOCALE_KOREAN_JOHAB:
                case IDM_LOCALE_POLISH_DEFAULT:
                case IDM_LOCALE_ROMANIAN_DEFAULT:
                case IDM_LOCALE_RUSSIAN_DEFAULT:
                case IDM_LOCALE_SPANISH_CASTILIAN:
                case IDM_LOCALE_SPANISH_MEXICAN:
                case IDM_LOCALE_SPANISH_MODERN:
                case IDM_LOCALE_SWAHILI_DEFAULT:
                case IDM_LOCALE_SWEDISH_DEFAULT:
                case IDM_LOCALE_THAI_DEFAULT:
                case IDM_LOCALE_TURKISH_DEFAULT:
                case IDM_LOCALE_UKRAINIAN_DEFAULT:
                case IDM_LOCALE_VIETNAMESE_DEFAULT:

                case IDM_DISPLAY_PROPS:
                case IDM_CATALOG_STATUS:
                case IDM_MASTER_MERGE:
                case IDM_FORCE_USE_CI:
                case IDM_EDITCOPYALL :
                case IDM_DIALECT_1 :
                case IDM_DIALECT_2 :
                case IDM_DIALECT_3 :
                case IDM_LIMIT_10 :
                case IDM_LIMIT_300 :
                case IDM_LIMIT_NONE :
                case IDM_FIRSTROWS_5 :
                case IDM_FIRSTROWS_15 :
                case IDM_FIRSTROWS_NONE :

                    _SendToActiveMDI(wmMenuCommand,uiID,1L);
                    break;
                default :
                  lRet = DefFrameProc(hwnd,_hMDIClientWnd,msg,wParam,lParam);
                  break;
              }
            break;
        }
        case wmOpenCatalog:
        {
            BOOL fDialog = (BOOL) wParam;

            if ( !fDialog ||
                 DoModalDialog( ScopeDlgProc,
                                hwnd,
                                L"ScopeBox",
                                (LPARAM) &_xCatList ) )
            {
                _MakeMDI( _xCatList.Get(),
                          SEARCH_CLASS,
                          0,0,
                          (LPARAM) _xCatList.Get());
            }
            break;
        }
        case WM_DRAWITEM :
            _SendToActiveMDI(msg, wParam, lParam );
            break;
        case WM_SIZE :
            SendMessage( _hToolBarWnd, msg, wParam, lParam );
            SendMessage( _hStatusBarWnd, msg, wParam, lParam );
            _SizeMDIAndBars( FALSE, LOWORD( lParam ), HIWORD( lParam ) );
            break;
        case WM_MOVE :
            GetClientRect( hwnd, &rc );
            _SizeMDIAndBars( TRUE, rc.right, rc.bottom );
            break;
        case WM_SYSCOLORCHANGE :
        case WM_SETTINGCHANGE :
            _hbrushBtnFace = CreateSolidBrush( GetSysColor( COLOR_BTNFACE ) );
            _hbrushBtnHilite = CreateSolidBrush( GetSysColor( COLOR_BTNHIGHLIGHT ) );
            _hbrushHilite = CreateSolidBrush( GetSysColor( COLOR_HIGHLIGHT ) );
            _hbrushWindow = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
            SendMessage( App.StatusBarWindow(), msg, wParam, lParam );
            SendMessage( App.ToolBarWindow(), msg, wParam, lParam );
            _SendToMDIChildren( msg, wParam, lParam );
            lRet = DefFrameProc( hwnd, _hMDIClientWnd, msg, wParam, lParam );
            break;
        case WM_SYSCOMMAND :
            if (wParam == SC_CLOSE)
                SendMessage( hwnd, WM_CLOSE, 0, 0 );
            else
                lRet = DefFrameProc( hwnd, _hMDIClientWnd, msg, wParam, lParam );
            break;
        case WM_CLOSE :
            _SaveProfileData();
            _SendToMDIChildren( wmAppClosing, 0, 0 );
            DestroyWindow(hwnd);
            break;
        case WM_ENDSESSION :
            _SaveProfileData();
            lRet = DefFrameProc(hwnd,_hMDIClientWnd,msg,wParam,lParam);
            break;
        case WM_CREATE :
        {
            ccs.hWindowMenu = GetSubMenu(GetMenu(hwnd),WINDOWMENU);
            ccs.idFirstChild = IDM_WINDOWCHILD;
            _hMDIClientWnd = CreateWindowEx( WS_EX_CLIENTEDGE,
                                             L"mdiclient",0,
                                             WS_CHILD|WS_CLIPCHILDREN,
                                             0,0,0,0,
                                             hwnd,(HMENU) 0xcac,_hInst,
                                             (LPSTR) &ccs);
            ShowWindow(_hMDIClientWnd,SW_SHOW);
            PostMessage(hwnd,wmSetState,_iStartupState,0);
            break;
        }
        case wmSetState :
            if (_iAppCmdShow != SW_SHOWNORMAL)
                ShowWindow(hwnd,_iAppCmdShow);
            else if (wParam == 1)
                ShowWindow(hwnd,SW_SHOWMAXIMIZED);
            else
                ShowWindow(hwnd,SW_SHOW);
            break;
        case WM_DESTROY :
            SaveWindowRect( hwnd, CISEARCH_REG_POSITION );

//            HtmlHelp( hwnd, _awcHelpFile, HH_CLOSE_ALL, 0 );
            PostQuitMessage(0);
            break;
        case WM_INITMENU :
        {
            HMENU hmenu = (HMENU) wParam;

            // Disable all those that may conditionally be enabled later
            EnableMenuItem(hmenu,IDM_EDITUNDO,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCUT,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCOPY,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCLEAR,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITPASTE,MF_GRAYED);

            EnableMenuItem(hmenu,IDM_BROWSE,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_NEXT_HIT,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_PREVIOUS_HIT,MF_GRAYED);

            EnableMenuItem( hmenu, IDM_DIALECT_1, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_DIALECT_2, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_DIALECT_3, MF_GRAYED );

            EnableMenuItem( hmenu, IDM_LIMIT_10, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_LIMIT_300, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_LIMIT_NONE, MF_GRAYED );
            
            EnableMenuItem( hmenu, IDM_FIRSTROWS_5, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_FIRSTROWS_15, MF_GRAYED );
            EnableMenuItem( hmenu, IDM_FIRSTROWS_NONE, MF_GRAYED );

            for ( ULONG i = 0; i < cLocaleEntries; i++ )
            {
                int option = aLocaleEntries[ i ].iMenuOption;
                EnableMenuItem( hmenu, option, MF_GRAYED );
            }

            EnableMenuItem(hmenu,IDM_SEARCH,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_SEARCHCLASSDEF,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_SEARCHFUNCDEF,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_NEWSEARCH,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_WRITE_RESULTS,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_SCOPE_AND_DEPTH,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_FILTER_SCOPE,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_DISPLAY_PROPS,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_CATALOG_STATUS,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_MASTER_MERGE,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_FORCE_USE_CI,MF_GRAYED);
            EnableMenuItem(hmenu,IDM_EDITCOPYALL,MF_GRAYED);


            if (_CountMDIChildren())
                uiStatus = MF_ENABLED;
            else
                uiStatus = MF_GRAYED;

            EnableMenuItem(hmenu,IDM_TILE,uiStatus);
            EnableMenuItem(hmenu,IDM_CASCADE,uiStatus);
            EnableMenuItem(hmenu,IDM_ARRANGE,uiStatus);
            EnableMenuItem(hmenu,IDM_CLOSE,uiStatus);

            // Enable/Disable Edit Menu options
            if (hwndActive = GetFocus())
            {
                GetClassName(hwndActive,
                             awcWindowClass,
                             (sizeof awcWindowClass / sizeof WCHAR) - 1);

                if ( (!_wcsicmp(awcWindowClass,L"Edit")) ||
                     (!_wcsicmp(awcWindowClass,BROWSE_CLASS)) )
                {
                    if (SendMessage (hwndActive,EM_CANUNDO,0,0))
                        uiStatus = MF_ENABLED;
                    else
                        uiStatus = MF_GRAYED;

                    EnableMenuItem(hmenu,IDM_EDITUNDO,uiStatus);

                    l = (LONG)SendMessage(hwndActive,EM_GETSEL,0,0);
                    uiStatus = (HIWORD(l) == LOWORD(l)) ? MF_GRAYED : MF_ENABLED;
                    EnableMenuItem(hmenu,IDM_EDITCOPY,uiStatus);

                    if ( _wcsicmp(awcWindowClass,BROWSE_CLASS) )
                    {
                        EnableMenuItem(hmenu,IDM_EDITCUT,uiStatus);
                        EnableMenuItem(hmenu,IDM_EDITCLEAR,uiStatus);
                    }

                    uiStatus = MF_GRAYED;
                    if (OpenClipboard(hwnd))
                    {
                        uiFmt = 0;
                        while ((uiFmt = EnumClipboardFormats(uiFmt)) &&
                               (uiStatus == MF_GRAYED))
                            if (uiFmt == CF_UNICODETEXT)
                                uiStatus = MF_ENABLED;
                        CloseClipboard();
                    }

                    if ( _wcsicmp(awcWindowClass,BROWSE_CLASS) )
                        EnableMenuItem(hmenu,IDM_EDITPASTE,uiStatus);
                }
                _SendToActiveMDI(wmInitMenu,wParam,0);
            }
            break;
        }
        default:
            lRet = DefFrameProc(hwnd,_hMDIClientWnd,msg,wParam,lParam);
            break;
    }
    return lRet;
} //WndProc

void CSearchApp::_InitApplication()
{
    WNDCLASS wc;
    BOOL bRet = FALSE;

    _strTrue.Load( IDS_BOOL_TRUE );
    _strFalse.Load( IDS_BOOL_FALSE );
    _strAttrib.Load( IDS_ATTRIB_INIT );
    _strBlob.Load( IDS_BLOB_FORMAT );
    _strYes.Load( IDS_YES );
    _strNo.Load( IDS_NO );

    _hbrushBtnFace = CreateSolidBrush( GetSysColor( COLOR_BTNFACE ) );
    _hbrushBtnHilite = CreateSolidBrush( GetSysColor( COLOR_BTNHIGHLIGHT ) );
    _hbrushHilite = CreateSolidBrush( GetSysColor( COLOR_HIGHLIGHT ) );
    _hbrushWindow = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );

    // Main Window
    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = _hInst;
    wc.hIcon = LoadIcon(_hInst,L"SearchIcon");
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName = L"SrchMenu";
    wc.lpszClassName = APP_CLASS;
    if (RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));

    // Search window
    wc.hbrBackground = _hbrushBtnFace;
    wc.hIcon = LoadIcon(_hInst,L"SearchWindowIcon");
    wc.cbWndExtra = sizeof ULONG_PTR;
    wc.lpszMenuName = 0;
    wc.lpfnWndProc = SearchWndProc;
    wc.lpszClassName = SEARCH_CLASS;
    if (RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));

    // Browse window
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
    wc.hIcon = LoadIcon(_hInst,L"BrowseWindowIcon");
    wc.lpfnWndProc = BrowseWndProc;
    wc.lpszClassName = BROWSE_CLASS;
    wc.style = CS_DBLCLKS;
    if ( RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));

    // List window
    // to be replaced by ListView

    wc.style = CS_DBLCLKS;
    wc.hIcon = 0;
    wc.cbWndExtra = sizeof ULONG_PTR;
    wc.lpfnWndProc = ListViewWndProc;
    wc.lpszClassName = LIST_VIEW_CLASS;
    if (RegisterClass(&wc) == 0)
        THROW(CException(E_FAIL));
} //_InitApplication

void CSearchApp::_CreateFonts()
{
    memset(&_lfApp,0,sizeof(LOGFONT));

    _lfApp.lfWeight = FW_NORMAL;
    _lfApp.lfHeight = -11;
    _lfApp.lfCharSet = ANSI_CHARSET;
    _lfApp.lfOutPrecision = OUT_DEFAULT_PRECIS;
    _lfApp.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    _lfApp.lfQuality = PROOF_QUALITY;
    _lfApp.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    wcscpy( _lfApp.lfFaceName, L"MS SHELL DLG" ); //L"HELV");

    _lfBrowse = _lfApp;
    _lfBrowse.lfPitchAndFamily = FF_MODERN | FIXED_PITCH;
    wcscpy(_lfBrowse.lfFaceName,L"COURIER");

    _ReadDefaultFonts();

    _hfontApp = CreateFontIndirect((LPLOGFONT) &_lfApp);
    _hfontBrowse = CreateFontIndirect((LPLOGFONT) &_lfBrowse);

    if (!( _hfontApp && _hfontBrowse ))
        THROW(CException(E_FAIL));
} //_CreateFonts

void CSearchApp::_GetPaths()
{
    WCHAR awc[MAX_PATH+1],*pc;

    GetModuleFileName(_hInst,awc,MAX_PATH);
    UINT ui = (UINT) wcslen(awc);

    wcscpy(_awcAppPath,awc);
    for (pc = _awcAppPath + ui; pc > _awcAppPath; pc--)
    {
        if (*pc == '/' || *pc == '\\' || *pc == ':')
        {
            *(++pc) = '\0';
            break;
        }
    }

    wcscpy(_awcHelpFile,_awcAppPath);
    wcscat(_awcHelpFile,CISEARCH_HELPFILE);
} //_GetPaths

void CSearchApp::_InitInstance(LPSTR pcCmdLine)
{
    LoadNumberFormatInfo( _NumberFmt );
    _NumberFmt.NumDigits = 0; // override: none after the decimal point!

    LoadNumberFormatInfo( _NumberFmtFloat );

    BOOL fScopeSpecified = FALSE;

    CLSID clsidCISimpleCommandCreator = CLSID_CISimpleCommandCreator;

    HRESULT hr = CoCreateInstance( clsidCISimpleCommandCreator,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ISimpleCommandCreator,
                                   _xCmdCreator.GetQIPointer() );

    if ( FAILED( hr ) )
        THROW( CException( hr ) );

    SScopeCatalogMachine defaults;

    defaults.fDeep = TRUE;
    wcscpy( defaults.awcMachine, L"." );
    wcscpy( defaults.awcScope, L"\\" );
    defaults.awcCatalog[0] = 0;

    ULONG cwcMachine = sizeof defaults.awcMachine / sizeof WCHAR;
    ULONG cwcCatalog = sizeof defaults.awcCatalog / sizeof WCHAR;
    SCODE sc = LocateCatalogs( L"\\",
                               0,
                               defaults.awcMachine,
                               &cwcMachine,
                               defaults.awcCatalog,
                               &cwcCatalog );

    if ( pcCmdLine && pcCmdLine[0] )
    {
        // make sure drive / unc is '\' terminated

        WCHAR awcTmp[MAX_PATH];

        mbstowcs(awcTmp, pcCmdLine, sizeof awcTmp / sizeof WCHAR);
        _wcslwr(awcTmp);

        // look for machine;catalog;scope or
        //                  catalog;scope or
        //                          scope

        WCHAR *pwcM = 0;  // machine
        WCHAR *pwcC = 0;  // catalog
        WCHAR *pwcS = 0;  // scope

        WCHAR *pwc = wcschr( awcTmp, L';' );

        if ( pwc )
        {
            *pwc++ = 0;
            WCHAR *pwc2 = wcschr( pwc, L';' );

            if ( pwc2 )
            {
                *pwc2++ = 0;
                pwcM = awcTmp;
                pwcC = pwc;
                pwcS = pwc2;
            }
            else
            {
                pwcC = awcTmp;
                pwcS = pwc;
            }
        }
        else
        {
            pwcS = awcTmp;
        }

        if ( *pwcS )
        {
            if ( ( _wcsicmp( pwcS, L"catalog" ) ) &&
                 ( _wcsicmp( pwcS, L"\\" ) ) )
            {
                int len = wcslen( pwcS );

                if (pwcS[len - 1] != L'\\')
                {
                    pwcS[len] = L'\\';
                    pwcS[len + 1] = 0;
                }

                if ( pwcS[0] != '\\' || pwcS[1] != '\\')
                {
                    WCHAR *pwcFinal;
                    GetFullPathName(pwcS,
                                    sizeof defaults.awcScope / sizeof WCHAR,
                                    defaults.awcScope,
                                    &pwcFinal);
                }
                else wcscpy(defaults.awcScope,pwcS);
            }
            else wcscpy(defaults.awcScope,pwcS);
        }
        else wcscpy(defaults.awcScope,L"\\");  // entire catalog

        if ( pwcM )
            wcscpy( defaults.awcMachine, pwcM );

        if ( pwcC )
            wcscpy( defaults.awcCatalog, pwcC );

        if ( 0 != defaults.awcCatalog[0] )
            fScopeSpecified = TRUE;
    }
    else
    {
        // use the current drive as a default

        //wcscpy(defaults.awcScope,L"X:\\");
        //defaults.awcScope[0] = _getdrive() + L'A' - 1;
    }

    // Populate _xCatList - Note: This doesn't handle distributed queries.
    //                            But that's OK -- it's just a test tool.

    _xCatList.SetSize( wcslen( defaults.awcMachine ) +
                       wcslen( defaults.awcCatalog ) +
                       wcslen( defaults.awcScope ) +
                       1 +  // depth
                       4 +  // delimiters
                       1    // null terminator
                       );

    wcscpy( _xCatList.Get(), defaults.awcMachine );
    wcscat( _xCatList.Get(), L"," );

    wcscat( _xCatList.Get(), defaults.awcCatalog );
    wcscat( _xCatList.Get(), L"," );

    wcscat( _xCatList.Get(), defaults.awcScope );
    wcscat( _xCatList.Get(), L"," );

    wcscat( _xCatList.Get(), defaults.fDeep ? L"d" : L"s" );
    wcscat( _xCatList.Get(), L";" );


    _GetPaths();
    _CreateFonts();

    _iStartupState = GetWindowState(TRUE);
    _iMDIStartupState = GetWindowState(FALSE);
    _fToolBarOn = _fToolBarOnINI = (BOOL) GetRegInt(CISEARCH_REG_TOOLBAR,1);
    _fStatusBarOn = _fStatusBarOnINI = (BOOL) GetRegInt(CISEARCH_REG_STATUSBAR,1);
    _fForceUseCI = _fForceUseCIINI = (BOOL) GetRegInt(CISEARCH_REG_FORCEUSECI,1);
    _sortDir = _sortDirINI = (BOOL) GetRegInt(CISEARCH_REG_SORTDIR,SORT_UP);
    _ulDialect = _ulDialectINI = (ULONG) GetRegInt( CISEARCH_REG_DIALECT, ISQLANG_V1 );
    _ulLimit = _ulLimitINI = (ULONG) GetRegInt( CISEARCH_REG_LIMIT, 0 );
    _ulFirstRows = _ulFirstRowsINI = (ULONG) GetRegInt( CISEARCH_REG_FIRSTROWS, 0 );

    DWORD dw = sizeof _awcSortINI;
    if (! GetReg( CISEARCH_REG_SORTPROP, _awcSortINI, &dw ) )
        wcscpy( _awcSortINI, DEFAULT_SORT_PROPERTIES );
    wcscpy( _awcSort, _awcSortINI );

    _lcid = _lcidINI = GetRegLCID( CISEARCH_REG_LOCALE, MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                                                              SORT_DEFAULT ) );
    _hAccTable = LoadAccelerators(_hInst,L"SrchAcc");

    int left,top,right,bottom;
    LoadWindowRect( &left, &top, &right, &bottom, CISEARCH_REG_POSITION );

    CResString strApp( IDS_APPNAME );

    if ((_hAppWnd = CreateWindow(APP_CLASS, strApp.Get(),
                                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                                 left,top,right,bottom,
                                 0,0,_hInst,0)) &&
        (_hStatusBarWnd = CreateStatusWindow( SBARS_SIZEGRIP |
                                              (_fStatusBarOn ? WS_VISIBLE : 0) |
                                              WS_CHILD,
                                              L"",
                                              _hAppWnd,
                                              0 ) ) &&
        (_hToolBarWnd = CreateTBar( _hAppWnd, _hInst ) ) )
    {
        UpdateWindow(_hAppWnd);

        if (_fStatusBarOn)
            CheckMenuItem(GetMenu(_hAppWnd),IDM_STATUS_BAR,MF_CHECKED);
        if (_fToolBarOn)
            CheckMenuItem(GetMenu(_hAppWnd),IDM_ICON_BAR,MF_CHECKED);
        if (_fForceUseCI)
            CheckMenuItem(GetMenu(_hAppWnd),IDM_FORCE_USE_CI,MF_CHECKED);

        PostMessage(_hAppWnd,wmOpenCatalog,!fScopeSpecified,0);
    }
    else
    {
        THROW(CException(E_FAIL));
    }
} //_InitInstance

HWND CSearchApp::_MakeMDI(
    WCHAR const *pwcTitle,
    WCHAR *pwcClass,
    UINT uiState,
    DWORD dwStyle,
    LPARAM lParam)
{
    HWND hwndActive;

    if ((hwndActive = GetActiveMDI()) && IsZoomed(hwndActive))
        uiState = 1;
    else if (!_CountMDIChildren())
        uiState = (UINT) _iMDIStartupState;

    MDICREATESTRUCT mcs;

    mcs.szTitle = pwcTitle;
    mcs.szClass = pwcClass;
    mcs.hOwner = _hInst;
    mcs.x = mcs.cx = mcs.y = mcs.cy = CW_USEDEFAULT;

    if (1 == uiState)
        mcs.style = WS_MAXIMIZE;
    else if (2 == uiState)
        mcs.style = WS_MINIMIZE;
    else
        mcs.style = 0;

    mcs.style |= dwStyle;
    mcs.lParam = lParam;

    return (HWND) SendMessage(_hMDIClientWnd,WM_MDICREATE,0,(LPARAM) &mcs);
} //_MakeMDI

int CSearchApp::_SaveWindowState(
    BOOL fApp)
{
    int iState=0,i;
    HWND h;
    WCHAR *pwc,awcBuf[30];

    if (fApp)
    {
        pwc = L"main";
        h = _hAppWnd;
        i = _iStartupState;
    }
    else
    {
        pwc = L"mdi";
        h = GetActiveMDI();
        i = _iMDIStartupState;
    }
    if (h)
    {
        if (IsZoomed(h))
            iState = 1;
        else
            iState = 0;

        int z = fApp ? _iStartupState : _iMDIStartupState;

        if (iState != z)
        {
            if (fApp)
                _iStartupState = iState;
            else
                _iMDIStartupState = iState;

            wcscpy(awcBuf,pwc);
            wcscat(awcBuf,L"-state");
            SetRegInt(awcBuf,iState);
        }
    }
    return iState;
} //_SaveWindowState

int CSearchApp::_CountMDIChildren(void)
{
    HWND hwndActive;
    int cItems = 0;

    if ((_hMDIClientWnd) &&
        (hwndActive = GetActiveMDI()))
        do
            cItems++;
        while (hwndActive = GetNextWindow(hwndActive,GW_HWNDNEXT));

    return cItems;
} //_CountMDIChildren

int CSearchApp::_CountMDISearch(void)
{
    HWND h;
    int cItems = 0;

    if ((_hMDIClientWnd) &&
        (h = GetActiveMDI()))
    {
        do
        {
            if (IsSpecificClass(h,SEARCH_CLASS))
                cItems++;
        }
        while (h = GetNextWindow(h,GW_HWNDNEXT));
    }

    return cItems;
} //_CountMDISearch

LRESULT CSearchApp::_SendToMDIChildren(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND h;
    LRESULT l = 0;

    if ((_hMDIClientWnd) &&
        (h = GetActiveMDI()))
    {
        do
            l = SendMessage(h,msg,wParam,lParam);
        while (h = GetNextWindow(h,GW_HWNDNEXT));
    }

    return l;
} //_SendToMDIChildren

LRESULT CSearchApp::_SendToSpecificChildren(
    WCHAR *pwcClass,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND h;
    LRESULT l = 0;

    if ((_hMDIClientWnd) &&
        (h = GetActiveMDI()))
        do
            if (IsSpecificClass(h,pwcClass))
                l = SendMessage(h,msg,wParam,lParam);
        while (h = GetNextWindow(h,GW_HWNDNEXT));

    return l;
} //_SendToSpecificChildren

LRESULT CSearchApp::_SendToActiveMDI(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndActive;
    LRESULT l = 0;

    if ((_hMDIClientWnd) &&
        (hwndActive = GetActiveMDI()))
        l = SendMessage(hwndActive,msg,wParam,lParam);

    return l;
} //_SendToActiveMDI

void CSearchApp::_ShowHelp(UINT uiCmnd,DWORD dw)
{
  if (!HtmlHelp(_hAppWnd,_awcHelpFile,uiCmnd,dw))
      SearchError(_hAppWnd,IDS_ERR_CANT_OPEN_HELP,_awcHelpFile);
} //_ShowHelp

const SLocaleEntry aLocaleEntries[] =
{
    { IDM_LOCALE_NEUTRAL,
      MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_TRADITIONAL,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_SIMPLIFIED,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_HONGKONG,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_HONGKONG), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_SINGAPORE,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE), SORT_DEFAULT ) },
    { IDM_LOCALE_CHINESE_MACAU,
      MAKELCID( MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_MACAU), SORT_DEFAULT ) },
    { IDM_LOCALE_DUTCH_DUTCH,
      MAKELCID( MAKELANGID( LANG_DUTCH, SUBLANG_DUTCH), SORT_DEFAULT ) },
    { IDM_LOCALE_ENGLISH_CAN,
      MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_CAN), SORT_DEFAULT ) },
    { IDM_LOCALE_ENGLISH_US,
      MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT ) },
    { IDM_LOCALE_ENGLISH_UK,
      MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_UK), SORT_DEFAULT ) },
    { IDM_LOCALE_FINNISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_FINNISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_FARSI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_FARSI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_FRENCH_FRENCH,
      MAKELCID( MAKELANGID( LANG_FRENCH, SUBLANG_FRENCH), SORT_DEFAULT ) },
    { IDM_LOCALE_FRENCH_CANADIAN,
      MAKELCID( MAKELANGID( LANG_FRENCH, SUBLANG_FRENCH_CANADIAN), SORT_DEFAULT ) },
    { IDM_LOCALE_GERMAN_GERMAN,
      MAKELCID( MAKELANGID( LANG_GERMAN, SUBLANG_GERMAN), SORT_DEFAULT ) },
    { IDM_LOCALE_GREEK_DEFAULT,
      MAKELCID( MAKELANGID( LANG_GREEK, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_HEBREW_DEFAULT,
      MAKELCID( MAKELANGID( LANG_HEBREW, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_HINDI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_HINDI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_ITALIAN_ITALIAN,
      MAKELCID( MAKELANGID( LANG_ITALIAN, SUBLANG_ITALIAN), SORT_DEFAULT ) },
    { IDM_LOCALE_JAPANESE_DEFAULT,
      MAKELCID( MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_KOREAN_KOREAN,
      MAKELCID( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN), SORT_DEFAULT ) },
//    { IDM_LOCALE_KOREAN_JOHAB,
//      MAKELCID( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN_JOHAB), SORT_DEFAULT ) },
    { IDM_LOCALE_POLISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_POLISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_ROMANIAN_DEFAULT,
      MAKELCID( MAKELANGID( LANG_ROMANIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_RUSSIAN_DEFAULT,
      MAKELCID( MAKELANGID( LANG_RUSSIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_SPANISH_CASTILIAN,
      MAKELCID( MAKELANGID( LANG_SPANISH, SUBLANG_SPANISH), SORT_DEFAULT ) },
    { IDM_LOCALE_SPANISH_MEXICAN,
      MAKELCID( MAKELANGID( LANG_SPANISH, SUBLANG_SPANISH_MEXICAN), SORT_DEFAULT ) },
    { IDM_LOCALE_SPANISH_MODERN,
      MAKELCID( MAKELANGID( LANG_SPANISH, SUBLANG_SPANISH_MODERN), SORT_DEFAULT ) },
    { IDM_LOCALE_SWAHILI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_SWAHILI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_SWEDISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_SWEDISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_THAI_DEFAULT,
      MAKELCID( MAKELANGID( LANG_THAI, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_TURKISH_DEFAULT,
      MAKELCID( MAKELANGID( LANG_TURKISH, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_UKRAINIAN_DEFAULT,
      MAKELCID( MAKELANGID( LANG_UKRAINIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) },
    { IDM_LOCALE_VIETNAMESE_DEFAULT,
      MAKELCID( MAKELANGID( LANG_VIETNAMESE, SUBLANG_DEFAULT), SORT_DEFAULT ) },
};

const ULONG cLocaleEntries = sizeof aLocaleEntries / sizeof SLocaleEntry;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\srchutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       srchutil.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

void SetReg(
    WCHAR const * pwcName,
    WCHAR const * pwcValue)
{
    HKEY hKeyParent;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER,CISEARCH_PARENT_REG_KEY,0,
                     KEY_ALL_ACCESS,&hKeyParent))
    {
        DWORD dwDisp;
        HKEY hKey;

        if (ERROR_SUCCESS ==
            RegCreateKeyEx(hKeyParent,CISEARCH_REG_SUBKEY,0,L"",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,0,&hKey,&dwDisp))
        {
            RegSetValueEx(hKey,pwcName,0,REG_SZ,(LPBYTE) pwcValue,
                          sizeof(WCHAR) * (wcslen(pwcValue) + 1));
            RegCloseKey(hKey);
        }
        RegCloseKey(hKeyParent);
    }
} //SetReg

BOOL GetReg(
    WCHAR const * pwcName,
    WCHAR *       pwcValue,
    DWORD *       pdwSize)
{
    BOOL fOk = FALSE;
    HKEY hKeyParent;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER,CISEARCH_PARENT_REG_KEY,0,
                     KEY_ALL_ACCESS,&hKeyParent))
    {
        DWORD dwDisp;
        HKEY hKey;

        if (ERROR_SUCCESS ==
            RegCreateKeyEx(hKeyParent,CISEARCH_REG_SUBKEY,0,L"",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,0,&hKey,&dwDisp))
        {
            DWORD dwType;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,pwcName,0,&dwType,
                                                 (LPBYTE) pwcValue,pdwSize))
                fOk = TRUE;

            RegCloseKey(hKey);
        }
        RegCloseKey(hKeyParent);
    }

    return fOk;
} //GetReg


LCID GetRegLCID(
    WCHAR const * pwcName,
    LCID          defLCID )
{
    WCHAR awc[100];
    DWORD dw = sizeof awc;

    if (GetReg(pwcName,awc,&dw))
        return _wtoi(awc);
    else
        return defLCID;
} //GetRegLCID


void SetRegLCID(
    WCHAR const * pwcName,
    LCID          lcid )
{
    WCHAR awc[20];

    // itow is not in all C runtimes _itow(iValue,awc,10);
    swprintf( awc, L"%d", lcid );
    SetReg( pwcName, awc );
} //SetRegLCID


int GetRegInt(
    WCHAR const * pwcName,
    int           iDef)
{
    WCHAR awc[100];
    DWORD dw = sizeof awc;

    if (GetReg(pwcName,awc,&dw))
        return _wtoi(awc);
    else
        return iDef;
} //GetRegInt

void SetRegInt(
    WCHAR const * pwcName,
    int           iValue)
{
    WCHAR awc[20];

    // itow is not in all C runtimes _itow(iValue,awc,10);
    swprintf( awc, L"%d", iValue );
    SetReg( pwcName, awc );
} //SetRegInt


BOOL IsSpecificClass(
    HWND          hwnd,
    WCHAR const * pwcClass)
{
    WCHAR awcClass[60];

    GetClassName(hwnd,awcClass,(sizeof awcClass / sizeof WCHAR) - 1);

    return !wcscmp( awcClass, pwcClass );
} //IsSpecificClass

int GetLineHeight(
    HWND  hwnd,
    HFONT hFont)
{
    if (hFont == 0)
        hFont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    HDC hdc;
    int iHeight=0;

    if (hdc = GetDC(hwnd))
    {
        HFONT hOldFont;
        if (hOldFont = (HFONT) SelectObject(hdc,hFont))
        {
            TEXTMETRIC tm;
            GetTextMetrics(hdc,&tm);
            iHeight = (tm.tmHeight + 2 * tm.tmExternalLeading);
            SelectObject(hdc,hOldFont);
        }
        ReleaseDC(hwnd,hdc);
    }

    return iHeight;
} //GetLineHeight

int GetAvgWidth(
    HWND  hwnd,
    HFONT hFont)
{
    if (hFont == 0)
        hFont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    HDC hdc;
    LONG cpWidth = 0;

    if (hdc = GetDC(hwnd))
    {
        HFONT hOldFont;
        if (hOldFont = (HFONT) SelectObject(hdc,hFont))
        {
            TEXTMETRIC tm;
            GetTextMetrics(hdc,&tm);
            cpWidth = tm.tmAveCharWidth;
            SelectObject(hdc,hOldFont);
        }
        ReleaseDC(hwnd,hdc);
    }

    return cpWidth;
} //GetAvgWidth

INT_PTR DoModalDialog(
    DLGPROC fp,
    HWND hParent,
    WCHAR * pwcName,
    LPARAM lParam)
{
    return DialogBoxParam(MyGetWindowInstance(hParent),
                          pwcName,
                          hParent,
                          fp,
                          lParam);
} //DoModalDialog

void SaveWindowRect(
    HWND          hwnd,
    WCHAR const * pwc )
{
    if (! (IsZoomed(hwnd) || IsIconic(hwnd)))
    {
        RECT rc;
        GetWindowRect(hwnd,&rc);

        WCHAR awc[100];
        swprintf(awc,L"%d %d %d %d",rc.left,rc.top,rc.right,rc.bottom);

        SetReg( pwc, awc );
    }
} //SaveWindowRect

BOOL LoadWindowRect(
    int *         left,
    int *         top,
    int *         right,
    int *         bottom,
    WCHAR const * pwc )
{
    WCHAR awc[100];
    DWORD dw = sizeof awc;

    if ( GetReg( pwc, awc, &dw ) )
    {
        swscanf(awc,L"%d %d %d %d",left,top,right,bottom);
        *right = *right - *left;
        *bottom = *bottom - *top;
        return TRUE;
    }
    else
    {
        *left = *top = *right = *bottom = CW_USEDEFAULT;
        return FALSE;
    }
} //LoadWindowRect

int GetWindowState(
    BOOL bApp)
{
    WCHAR awcValue[100],awcBuf[100];

    if (bApp)
        wcscpy(awcBuf,L"main");
    else
        wcscpy(awcBuf,L"mdi");

    wcscat(awcBuf,L"-state");

    DWORD dw = sizeof awcValue;
    int iState;

    if (GetReg(awcBuf,awcValue,&dw))
        iState = awcValue[0] - L'0';
    else
        iState = 1;

    return iState;
} //GetWindowState

void PassOnToEdit(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndActive = GetFocus();

    if ( 0 != hwndActive )
    {
        WCHAR awcBuf[60];
        int r = GetClassName(hwndActive,awcBuf,(sizeof awcBuf / sizeof WCHAR) - 1);

        if ( 0 == r )
            return;

        if ( ( !_wcsicmp( awcBuf, L"Edit" ) ) ||
             ( !_wcsicmp( awcBuf, L"RichEdit" ) ) )
            SendMessage( hwndActive, msg, wParam, lParam);
    }
} //PassOnToEdit

void WINAPI CenterDialog(
    HWND hdlg)
{
    RECT rcParent;
    RECT rc;

    GetWindowRect(hdlg,(LPRECT) &rc);
    GetWindowRect(GetParent(hdlg),(LPRECT) &rcParent);

    LONG xbias = rcParent.left + (rcParent.right - rcParent.left)/2;
    LONG ybias = rcParent.top + (rcParent.bottom - rcParent.top)/2;
    LONG lWidth = rc.right - rc.left;
    LONG lHeight = rc.bottom - rc.top;

    MoveWindow(hdlg, xbias - lWidth/2,
                     ybias - lHeight/2,
                     lWidth,lHeight,FALSE);
} //CenterDialog

//+---------------------------------------------------------------------------
//
//  Function:   ConvertGroupingStringToInt
//
//  Synopsis:   Converts a grouping string from the registry to an integer,
//              as required by the Win32 number formatting API
//
//  History:    5-Feb-99   dlee      Stole from the Win32 implementation
//
//----------------------------------------------------------------------------

int ConvertGroupingStringToInt( WCHAR const * pwcGrouping )
{
    XGrowable<WCHAR> xDest( 1 + wcslen( pwcGrouping ) );
    WCHAR * pDest = xDest.Get();

    //
    //  Filter out all non-numeric values and all zero values.
    //  Store the result in the destination buffer.
    //

    WCHAR const * pSrc  = pwcGrouping;

    while (0 != *pSrc)
    {
        if ( ( *pSrc < L'1' ) || ( *pSrc > L'9' ) )
        {
            pSrc++;
        }
        else
        {
            if (pSrc != pDest)
                *pDest = *pSrc;

            pSrc++;
            pDest++;
        }
    }

    //
    // Make sure there is something in the destination buffer.
    // Also, see if we need to add a zero in the case of 3;2 becomes 320.
    //

    if ( ( pDest == xDest.Get() ) || ( *(pSrc - 1) != L'0' ) )
    {
        *pDest = L'0';
        pDest++;
    }

    // Null terminate the buffer.

    *pDest = 0;

    // Convert the string to an integer.

    return _wtoi( xDest.Get() );
} //ConvertGroupingStringToInt

void LoadNumberFormatInfo(
    NUMBERFMT & rFormat)
{
    LCID lcid = GetUserDefaultLCID();

    WCHAR awcBuf[cwcBufSize];

    //  Get the number of decimal digits.
    GetLocaleInfo(lcid,LOCALE_IDIGITS,awcBuf,cwcBufSize);
    rFormat.NumDigits = _wtoi(awcBuf);

    //  Get the leading zero in decimal fields option.
    GetLocaleInfo(lcid,LOCALE_ILZERO,awcBuf,cwcBufSize);
    rFormat.LeadingZero = _wtoi(awcBuf);

    //  Get the negative ordering.
    GetLocaleInfo(lcid,LOCALE_INEGNUMBER,awcBuf,cwcBufSize);
    rFormat.NegativeOrder = _wtoi(awcBuf);

    //  Get the grouping left of the decimal.
    GetLocaleInfo(lcid,LOCALE_SGROUPING,awcBuf,cwcBufSize);
    rFormat.Grouping = ConvertGroupingStringToInt( awcBuf );

    //  Get the decimal separator.
    GetLocaleInfo(lcid,LOCALE_SDECIMAL,awcBuf,cwcBufSize);
    rFormat.lpDecimalSep = new WCHAR[wcslen(awcBuf) + 1];
    wcscpy(rFormat.lpDecimalSep,awcBuf);

    //  Get the thousand separator.
    GetLocaleInfo(lcid,LOCALE_STHOUSAND,awcBuf,cwcBufSize);
    rFormat.lpThousandSep = new WCHAR[wcslen(awcBuf) + 1];
    wcscpy(rFormat.lpThousandSep,awcBuf);
} //LoadNumberFormatInfo

void FreeNumberFormatInfo(
    NUMBERFMT & rFormat)
{
    delete rFormat.lpDecimalSep;
    delete rFormat.lpThousandSep;
} //FreeNumberFormatInfo

void SearchError(
    HWND          hParent,
    ULONG         dwErrorID,
    WCHAR const * pwcTitle)
{
    CResString str( dwErrorID );
    MessageBox( hParent, str.Get(), pwcTitle, MB_OK | MB_ICONEXCLAMATION );
} //SearchError

void PutInClipboard(
    WCHAR const * pwcBuffer )
{
    if ( OpenClipboard( App.AppWindow() ) )
    {
        EmptyClipboard();

        HGLOBAL hglbCopy = GlobalAlloc( GMEM_DDESHARE,
                           ( wcslen( pwcBuffer ) + 1 ) *
                           sizeof WCHAR );

        if ( 0 != hglbCopy )
        {
            WCHAR *pwc = (WCHAR *) GlobalLock( hglbCopy );
            wcscpy( pwc, pwcBuffer );
            GlobalUnlock( hglbCopy );
            SetClipboardData( CF_UNICODETEXT, hglbCopy );
        }

        CloseClipboard();
    }
} //PutInClipboard

BOOL GetRegEditor(
    WCHAR const * pwcName,
    WCHAR *       pwcValue,
    DWORD *       pdwSize)
{
    BOOL fOk = FALSE;
    HKEY hKeyParent;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER,L"software\\microsoft",0,
                     KEY_ALL_ACCESS,&hKeyParent))
    {
        DWORD dwDisp;
        HKEY hKey;

        if (ERROR_SUCCESS ==
            RegCreateKeyEx(hKeyParent,L"Windiff",0,L"",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,0,&hKey,&dwDisp))
        {
            DWORD dwType;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,pwcName,0,&dwType,
                                                 (LPBYTE) pwcValue,pdwSize))
                fOk = TRUE;

            RegCloseKey(hKey);
        }
        RegCloseKey(hKeyParent);
    }

    return fOk;
} //GetRegEditor

void FormatSrchError( SCODE sc, WCHAR * pwc, LCID lcid )
{
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale( lcid );

    ULONG Win32status = sc;
    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );

    if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                          GetModuleHandle(L"query.dll"),
                          sc,
                          0,
                          pwc,
                          MAX_PATH,
                          0 ) )
    {
        //
        //  Try looking up the error in the Win32 list of error codes
        //
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle(L"kernel32.dll"),
                              Win32status,
                              0,
                              pwc,
                              MAX_PATH,
                              0 ) )
        {
            swprintf( pwc, L"0x%x", sc );
        }
    }

    SetThreadLocale(SaveLCID);
} //FormatSrchError

BOOL CopyURL( WCHAR const * pwcURL, WCHAR * awcTempName )
{
   WCHAR const * pwcSlash = wcsrchr( pwcURL, L'/' );

   if ( 0 == pwcSlash )
       return FALSE;

   pwcSlash++;

   DWORD cwc = GetTempPath( MAX_PATH, awcTempName );

   if ( 0 == cwc || cwc > MAX_PATH )
       return FALSE;

   wcscat( awcTempName, pwcSlash );

    XIHandle xhI( InternetOpenW( L"srch",
                                 INTERNET_OPEN_TYPE_PRECONFIG,
                                 0,
                                 0,
                                 0 ) );
    if ( xhI.IsNull() )
        return FALSE;

    XIHandle xhUrl( InternetOpenUrlW( xhI.Get(), pwcURL, 0, 0,
                                      INTERNET_FLAG_RELOAD |
                                      INTERNET_FLAG_DONT_CACHE |
                                      INTERNET_FLAG_PRAGMA_NOCACHE |
                                      INTERNET_FLAG_NO_CACHE_WRITE |
                                      INTERNET_FLAG_NO_COOKIES |
                                      INTERNET_FLAG_NO_UI,
                                      0 ) );

    if ( xhUrl.IsNull() )
        return FALSE;

    FILE * fp = _wfopen( awcTempName, L"wb" );

    if ( 0 == fp )
        return FALSE;

    char ac[ 1024 * 16 ];

    do
    {
        DWORD cbRead = 0;
        BOOL fOK = InternetReadFile( xhUrl.Get(),
                                     ac,
                                     sizeof ac,
                                     &cbRead );
        if ( !fOK )
        {
            fclose( fp );
            return FALSE;
        }

        if ( 0 == cbRead )
            break;

        fwrite( ac, 1, cbRead, fp );
    } while( TRUE );

    fclose( fp );

    return TRUE;
} //CopyURL

BOOL InvokeBrowser(
    WCHAR const *   pwcFilePath,
    DBCOMMANDTREE * prstQuery )
{
    WCHAR awcTempFile[MAX_PATH];
    BOOL fDeleteWhenDone = FALSE;

    if ( !_wcsnicmp( pwcFilePath, L"file:", 5 ) )
        pwcFilePath += 5;
    else if ( !_wcsnicmp( pwcFilePath, L"http:", 5 ) )
    {
        if ( !CopyURL( pwcFilePath, awcTempFile ) )
            return FALSE;

        pwcFilePath = awcTempFile;
        fDeleteWhenDone = TRUE;
    }

    BOOL fOK = TRUE;

    CQueryResult *pResult = new CQueryResult( pwcFilePath, prstQuery, fDeleteWhenDone );

    // call internal mdi browser

    if (pwcFilePath)
    {
        HWND h = App.CreateBrowser( pwcFilePath, (LPARAM) pResult );
        if ( 0 == h )
        {
            WCHAR awcError[ MAX_PATH ];
            FormatSrchError( App.BrowseLastError(), awcError, App.GetLocale() );
            WCHAR awcMsg[ MAX_PATH ];
            CResString strErr( IDS_ERR_CANT_BROWSE_FILE );
            swprintf( awcMsg, strErr.Get(), awcError );
            MessageBox( App.AppWindow(),
                        awcMsg,
                        pwcFilePath,
                        MB_OK|MB_ICONEXCLAMATION );
            fOK = FALSE;
        }
    }

    return fOK;
} //InvokeBrowser

void ExecApp(
    WCHAR const * pwcCmd)
{
    STARTUPINFO si;
    memset( &si, 0, sizeof si );
    si.cb = sizeof si;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWDEFAULT;

    PROCESS_INFORMATION pi;

    CreateProcess( 0, (WCHAR *) pwcCmd, 0, 0, FALSE, 0, 0, 0, &si, &pi );
} //ExecApp

BOOL ViewFile(
    WCHAR const *    pwcPath,
    enumViewFile     eViewType,
    int              iLineNumber,
    DBCOMMANDTREE *  prstQuery )
{
    BOOL fOK = TRUE;
    WCHAR awcCmd[MAX_PATH + cwcBufSize];
    DWORD cbCmd = sizeof awcCmd;

    if ( fileOpen == eViewType )
    {
        HINSTANCE hinst = ShellExecute( HWND_DESKTOP,
                                        0,
                                        pwcPath,
                                        0,
                                        0,
                                        SW_SHOWNORMAL );
        if ( 32 > (DWORD_PTR) hinst )
        {
            // if no app is registered for this extension, use notepad

            wcscpy( awcCmd, L"notepad " );
            wcscat( awcCmd, pwcPath );
            ExecApp( awcCmd );
        }
    }
    else if ( fileBrowse == eViewType )
    {
        fOK = InvokeBrowser( (WCHAR *) pwcPath, prstQuery );
    }
    else if ( fileEdit == eViewType )
    {
        WCHAR awcEditor[ MAX_PATH ];

        if ( GetReg( CISEARCH_REG_EDITOR, awcEditor, &cbCmd ) )
        {
            // cool -- use it.
        }
        else
        {
            // try to use windiff's configuration

            cbCmd = sizeof awcCmd;
            if ( GetRegEditor( L"Editor", awcEditor, &cbCmd ) )
            {

                WCHAR *p = wcsstr( awcEditor, L"%p" );
                if ( p )
                    *(p+1) = L's';
                p = wcsstr( awcEditor, L"%l" );
                if ( p )
                    *(p+1) = L'd';
            }
            else
            {
  
                //wcscpy( awcEditor, L"s %ws -#%d" );

                // no editor configured -- open the file

                return ViewFile( pwcPath, fileOpen, iLineNumber, prstQuery );
            }
        }

        TRY
        {
            swprintf( awcCmd, awcEditor, pwcPath, iLineNumber );
            ExecApp( awcCmd );
        }
        CATCH( CException, e )
        {
            fOK = FALSE;
        }
        END_CATCH;
    }

    return fOK;
} //ViewFile

BOOL GetCatListItem( const XGrowable<WCHAR> & const_xCatList,
                     unsigned iItem,
                     WCHAR * pwszMachine,
                     WCHAR * pwszCatalog,
                     WCHAR * pwszScope,
                     BOOL  & fDeep )
{
    XGrowable<WCHAR> xCatList = const_xCatList;

    Win4Assert( pwszMachine && pwszCatalog && pwszScope );
    *pwszMachine = *pwszCatalog = *pwszScope = 0;
    fDeep = FALSE;

    unsigned ii;
    WCHAR * pStart = xCatList.Get();
    for( ii = 0; ii < iItem; ii++ )
    {
        pStart = wcschr( pStart, L';' );
        if ( pStart )
        {
            pStart++;
        }
        else
            break;

        if ( 0 == *pStart )
        {
            break;
        }
    }

    if ( 0 == pStart || 0 == *pStart )
    {
        return FALSE;
    }

    WCHAR * pEnd;

    // machine
    pEnd = wcschr( pStart, L',' );
    if ( !pEnd )
    {
        return FALSE;
    }
    *pEnd = 0;
    wcscpy( pwszMachine, pStart );
    pStart = pEnd + 1;

    // catalog
    pEnd = wcschr( pStart, L',' );
    if ( !pEnd )
    {
        return FALSE;
    }
    *pEnd = 0;
    wcscpy( pwszCatalog, pStart );
    pStart = pEnd + 1;

    // scope
    pEnd = wcschr( pStart, L',' );
    if ( !pEnd )
    {
        return FALSE;
    }
    *pEnd = 0;
    wcscpy( pwszScope, pStart );
    pStart = pEnd + 1;

    // depth
    fDeep = ( L'd' == *pStart || L'D' == *pStart );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\toolbar.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       toolbar.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

// cImages        = Number of images in toolbar.bmp.  Note that this is not
//                  the same as the number of elements on the toolbar.
// cpImageWidth   = Width of a single button image in toolbar.bmp
// cpImageHeight  = Height of a single button image in toolbar.bmp
// cpButtonWidth  = Width of a button on the toolbar (zero = default)
// cpButtonHeight = Height of a button on the toolbar (zero = default)

const int cImages        = 12;

const int cpImageWidth   = 19;
const int cpImageHeight  = 16;
const int cpButtonWidth  = 19;
const int cpButtonHeight = 16;

TBBUTTON aButtons[] =        // Array defining the toolbar buttons
{
//    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {7,  IDM_SEARCH,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {8,  IDM_SEARCHCLASSDEF, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {9,  IDM_SEARCHFUNCDEF,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {2,  IDM_BROWSE,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {11, IDM_DISPLAY_PROPS,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {0,  IDM_NEWSEARCH,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {6,  IDM_PREVIOUS_HIT,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {5,  IDM_NEXT_HIT,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {4,  IDM_FONT,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},

    {0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0, 0},

    {1,  IDM_OPEN,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {10, IDM_TILE,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
    {3,  IDM_CASCADE,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0},
};

static WNDPROC _lpOrgTBProc = 0;

LRESULT WINAPI TBSubclassProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;

    // ordinarily, flat toolbars ride on a background window with a cool
    // bitmap.  this one doesn't -- so draw an appropriate background.

    if ( WM_ERASEBKGND == msg )
    {
        RECT rect;
        GetClientRect( hwnd, &rect );
        FillRect( (HDC) wParam, & rect, App.BtnFaceBrush() );
    }
    else
    {
        lRet = CallWindowProc( _lpOrgTBProc,
                               hwnd,
                               msg,
                               wParam,
                               lParam );
    }

    return lRet;
} //TBSubclassProc

HWND CreateTBar(
    HWND hwnd,
    HINSTANCE hInst)
{
    HWND bar = CreateToolbarEx( hwnd,
                                WS_CHILD | WS_VISIBLE |
                                    TBSTYLE_TOOLTIPS | TBSTYLE_FLAT,
                                IDM_TOOLBAR_WINDOW,
                                cImages,
                                hInst,
                                ToolbarBmpNormal,
                                aButtons,
                                sizeof aButtons / sizeof TBBUTTON,
                                cpButtonWidth,
                                cpButtonHeight,
                                cpImageWidth,
                                cpImageHeight,
                                sizeof TBBUTTON );

    if ( 0 == bar )
        return 0;

    _lpOrgTBProc = (WNDPROC) GetWindowLongPtr( bar, GWLP_WNDPROC );
    SetWindowLongPtr( bar, GWLP_WNDPROC, (LONG_PTR) TBSubclassProc );

    SendMessage( bar, TB_BUTTONSTRUCTSIZE, sizeof TBBUTTON, 0 );

    // pixels with color 192,192,192 are changed to buttonface color

    HIMAGELIST h = ImageList_LoadBitmap( hInst,
                                         MAKEINTRESOURCE( ToolbarBmpHilite ),
                                         cpImageWidth,
                                         6,
                                         RGB(192,192,192) );
    SendMessage( bar, TB_SETBITMAPSIZE, 0, MAKELONG( cpImageWidth,
                                                     cpImageHeight ) );
    SendMessage( bar, TB_SETHOTIMAGELIST, 0, (LPARAM) h );

    return bar;
} //CreateTBar

LRESULT ToolBarNotify(
    HWND hwnd,
    UINT uMessage,
    WPARAM wparam,
    LPARAM lparam,
    HINSTANCE hInst )
{
    WCHAR awcBuffer[64];

    TOOLTIPTEXT * pToolTipText = (LPTOOLTIPTEXT)lparam;

    if ( TTN_NEEDTEXT == pToolTipText->hdr.code )
    {
        int id = (int)pToolTipText->hdr.idFrom;

        if ( ( IDM_NEWSEARCH == id ) &&
             ( IsSpecificClass( GetFocus(), BROWSE_CLASS ) ) )
            id = IDS_CLOSEBROWSE;

        LoadString( hInst,
                    id,
                    awcBuffer,
                    sizeof awcBuffer / sizeof WCHAR );

        pToolTipText->lpszText = awcBuffer;
    }

    return 0;
} //ToolBarNotify

void UpdateButton(UINT iID, UINT iFlags)
{
    int iCurrentFlags = (int) SendMessage( App.ToolBarWindow(),
                                           TB_GETSTATE,
                                           iID, 0L );

    if (iCurrentFlags & TBSTATE_PRESSED)
        iFlags |= TBSTATE_PRESSED;

    SendMessage( App.ToolBarWindow(),
                 TB_SETSTATE,
                 iID,
                 MAKELPARAM( iFlags, 0 ) );
} //UpdateButton

void UpdateButtons( UINT *aId, UINT cId, BOOL fEnabled )
{
    for ( UINT i = 0; i < cId; i++ )
        UpdateButton( aId[ i ],
                      fEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE );

} //UpdateButtons
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\view.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       view.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

const int cpMargin = 2;
const int cpInflate = 4;
const int cpPaneMargin = 3;
const int cpPaneSpacing = 5;
const int cpPaneBottomSpacing = 0;

const DBID colAttrib = { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) (ULONG_PTR) PID_STG_ATTRIBUTES };
const DBID colFileIndex = { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) (ULONG_PTR) PID_STG_FILEINDEX };

CSearchView::CSearchView(
    HWND                hwndSearch,
    CSearchControl &    control,
    CColumnList &       columns )
    :
    _hwndSearch( hwndSearch ),
    _hwndQuery( 0 ),
    _hwndQueryTitle( 0 ),
    _hwndList( 0 ),
    _hwndHeader( 0 ),
    _hbrushWindow( 0 ),
    _hbrushHighlight( 0 ),
    _fHavePlacedTitles( FALSE ),
    _hfontShell( 0 ),
    _cLines( 0 ),
    _control( control ),
    _columns( columns ),
    _fMucked( FALSE ),
    _iColAttrib( 0xffffffff ),
    _iColFileIndex( 0xffffffff )
{
    MakeFont();
    _cpFontHeight = ::GetLineHeight( hwndSearch, _hfontShell );
    _iLineHeightList = ::GetLineHeight( hwndSearch, App.AppFont() );
    SysColorChange ();
} //CSearchView

CSearchView::~CSearchView()
{
    if (0 != _hfontShell)
        DeleteObject(_hfontShell);

    if (0 != _hbrushWindow)
    {
        DeleteObject(_hbrushWindow);
        DeleteObject(_hbrushHighlight);
    }
} //~CSearchView

unsigned CSearchView::ColumnWidth(
    unsigned x )
{
    if ( 0 == x )
        return _aWidths[ 0 ] + cpInflate + _cpAvgWidth/2 + cpMargin;
    else
        return _aWidths[ x ] + _cpAvgWidth;
} //ColumnWidth

void CSearchView::SetColumnWidth(
    unsigned x,
    unsigned cpWidth )
{
    unsigned w;

    if ( 0 == x )
        w = cpWidth - cpInflate - _cpAvgWidth/2 - cpMargin;
    else
        w = cpWidth - _cpAvgWidth;

    if ( _aWidths[ x ] > w )
        _fMucked = TRUE;

    _aWidths[ x ] = w;
} //SetColumnWidth

unsigned CSearchView::SetDefColumnWidth(
    unsigned iCol )
{
    DBID *pdbid;
    unsigned cc;
    DBTYPE pt;

    IColumnMapper & colMap = _control.GetColumnMapper();

    SCODE sc = colMap.GetPropInfoFromName( _columns.GetColumn( iCol ),
                                           &pdbid,
                                           &pt,
                                           &cc );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    _aPropTypes[ iCol ] = pt;

    if ( ( VT_FILETIME == pt ) || ( DBTYPE_DATE == pt ) )
        _aWidths[ iCol ] = _cpDateWidth + _cpTimeWidth;
    else if ( VT_CLSID == pt )
        _aWidths[ iCol ] = _cpGuidWidth;
    else if ( VT_BOOL == pt )
        _aWidths[ iCol ] = _cpBoolWidth;
    else if ( !memcmp( pdbid, &colAttrib, sizeof DBID ) )
    {
        _aWidths[ iCol ] = _cpAttribWidth;
        _iColAttrib = iCol;
    }
    else if ( !memcmp( pdbid, &colFileIndex, sizeof DBID ) )
    {
        _aWidths[ iCol ] = _cpFileIndexWidth;
        _iColFileIndex = iCol;
    }
    else
        _aWidths[ iCol ] = cc * _cpAvgWidth;

    // did the attrib column get redefined?

    if ( _iColAttrib == iCol && memcmp( pdbid, &colAttrib, sizeof DBID ) )
        _iColAttrib = 0xffffffff;

    // did the fileindex column get redefined?

    if ( _iColFileIndex == iCol && memcmp( pdbid, &colFileIndex, sizeof DBID ) )
        _iColFileIndex = 0xffffffff;

    return ColumnWidth( iCol );
} //SetDefColumnWidth

void CSearchView::ColumnsChanged()
{
    _ComputeFieldWidths();

    for ( unsigned iCol = 0; iCol < _columns.NumberOfColumns(); iCol++ )
        SetDefColumnWidth( iCol );
} //ColumnsChanged

void CSearchView::MakeFont()
{
    LOGFONT lf;
    memset( &lf, 0, sizeof LOGFONT );

    lf.lfHeight = -11;
    lf.lfWeight = FW_NORMAL;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    wcscpy( lf.lfFaceName, L"MS SHELL DLG" );
    _hfontShell = CreateFontIndirect( &lf );
} //MakeFont

void CSearchView::SysColorChange()
{
    if (0 != _hbrushWindow)
    {
        DeleteObject(_hbrushWindow);
        DeleteObject(_hbrushHighlight);
    }

    _colorHighlight     = GetSysColor(COLOR_HIGHLIGHT);
    _colorHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    _colorWindow        = GetSysColor(COLOR_WINDOW);
    _colorWindowText    = GetSysColor(COLOR_WINDOWTEXT);

    _hbrushHighlight    = CreateSolidBrush( _colorHighlight );
    _hbrushWindow       = CreateSolidBrush( _colorWindow );
} //SysColorChange

void CSearchView::InitPanes (
    HWND hwndQueryTitle,
    HWND hwndQuery,
    HWND hwndList,
    HWND hwndHeader )
{
    _hwndQueryTitle = hwndQueryTitle;
    _hwndQuery      = hwndQuery;
    _hwndList       = hwndList;
    _hwndHeader     = hwndHeader;

    SendMessage( _hwndQueryTitle, WM_SETFONT, (WPARAM) _hfontShell, 1 );
    SendMessage( _hwndHeader, WM_SETFONT, (WPARAM) _hfontShell, 1 );
    SendMessage( _hwndQuery, WM_SETFONT, (WPARAM) App.AppFont(), 1 );
    SendMessage( _hwndList, WM_SETFONT, (WPARAM) App.AppFont(), 1 );
} //InitPanes

void CSearchView::PrimeItem(
    LPDRAWITEMSTRUCT & lpdis,
    RECT &             rc )
{
    CopyRect( &rc, &lpdis->rcItem );
    InflateRect( (LPRECT) &rc, 1, 0 );

    HBRUSH hbr;

    if ( lpdis->itemState & ODS_SELECTED )
    {
        SetBkColor( lpdis->hDC, _colorHighlight );
        SetTextColor( lpdis->hDC, _colorHighlightText );
        hbr = _hbrushHighlight;
    }
    else
    {
        SetBkColor( lpdis->hDC, _colorWindow );
        SetTextColor( lpdis->hDC, _colorWindowText );
        hbr = _hbrushWindow;
    }

    FillRect( lpdis->hDC, &rc, hbr );

    InflateRect( &rc, -cpInflate, 0 );
} //PrimeItem

inline void _drawText(
    HDC      hdc,
    RECT &   rc,
    unsigned cpWidth,
    WCHAR *  pwc,
    int      cwc,
    BOOL     fClip )
{
    RECT rctext = rc;
    rctext.right = rc.left + cpWidth;

    DrawText( hdc,
              pwc,
              cwc,
              &rctext,
              DT_VCENTER | DT_NOPREFIX | DT_RIGHT | DT_SINGLELINE |
              ( fClip ? 0 : DT_NOCLIP ) );
} //_drawText

template<class T> void _drawVectorItems(
    T *      pVal,
    ULONG    cVals,
    WCHAR *  pwcFmt,
    HDC      hdc,
    RECT &   rc,
    unsigned width )
{
    WCHAR awcBuf[ cwcBufSize ];
    unsigned ccUnused = cwcBufSize - 10;
    WCHAR *pwcEnd = awcBuf;

    *pwcEnd++ = L'{';

    for( unsigned iVal = 0;
         iVal < cVals && ccUnused > 0;
         iVal++ )
    {
        int ccPrinted = _snwprintf( pwcEnd,
                                    ccUnused,
                                    pwcFmt,
                                    iVal == 0 ? L' ': L',',
                                    *pVal++ );

        if ( ccPrinted == -1 )
            break;

        ccUnused -= ccPrinted;
        pwcEnd += ccPrinted;
    }

    if ( iVal != cVals )
    {
        *pwcEnd++ = L'.';
        *pwcEnd++ = L'.';
        *pwcEnd++ = L'.';
    }

    *pwcEnd++ = L' ';
    *pwcEnd++ = L'}';
    *pwcEnd = L'\0';

    _drawText( hdc, rc, width, awcBuf, -1, TRUE );
} //_drawVectorItems

void Append( CDynArrayInPlace<WCHAR> & xBuf, WCHAR const * pwc, unsigned cwc )
{
    for ( unsigned i = 0; i < cwc; i++ )
        xBuf[ xBuf.Count() ] = pwc[ i ];
} //Append

void Append( CDynArrayInPlace<WCHAR> & xBuf, WCHAR const * pwc )
{
    while ( 0 != *pwc )
        xBuf[ xBuf.Count() ] = *pwc++;
} //Append

void RenderSafeArray(
    WCHAR *     pwc,
    unsigned    cwcMax,
    VARTYPE     vt,
    LPSAFEARRAY pa );

void Render(
    CDynArrayInPlace<WCHAR> & xOut,
    VARTYPE                   vt,
    void *                    pv )
{
    srchDebugOut(( DEB_ITRACE, "vt %#x, pv %#x\n", vt, pv ));
    __int64 i = 0;

    XArray<WCHAR> xBuf( cwcBufSize );
    WCHAR *awcBuf = xBuf.GetPointer();
    XArray<WCHAR> xTmp( cwcBufSize );
    WCHAR *awcTmp = xTmp.GetPointer();
    static WCHAR wszfmtU[] = L"%I64u";
    WCHAR *pwszfmt = L"%I64d";
    LCID lcid = App.GetLocale();

    if ( VT_ARRAY & vt )
    {
        SAFEARRAY *psa = *(SAFEARRAY **) pv;
        *awcBuf = 0;
        RenderSafeArray( awcBuf, cwcBufSize, vt - VT_ARRAY, psa );
        Append( xOut, awcBuf );
        return;
    }

    switch ( vt )
    {
        case VT_UI1:
            i = (unsigned __int64) *(BYTE *)pv;
            goto do_ui64;

        case VT_I1:
            i = *(CHAR *)pv;
            goto do_i64;

        case VT_UI2:
            i = (unsigned __int64) *(USHORT *)pv;
            goto do_ui64;

        case VT_I2:
            i = (unsigned __int64) *(SHORT *)pv;
            goto do_i64;

        case VT_UI4:
        case VT_UINT:
            i = (unsigned __int64) *(ULONG *)pv;
            goto do_ui64;

        case VT_I4:
        case VT_ERROR:
        case VT_INT:
            i = (unsigned __int64) *(LONG *)pv;
            goto do_i64;

        case VT_UI8:
            RtlCopyMemory( &i, pv, sizeof i );
do_ui64:
            pwszfmt = wszfmtU;
            goto do_i64;

        case VT_I8:
            RtlCopyMemory( &i, pv, sizeof i );

do_i64:
        {
            swprintf( awcTmp, pwszfmt, i );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormat(), awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1);
            break;
        }
        case VT_R4:
        {
            float f;
            RtlCopyMemory( &f, pv, sizeof f );
            swprintf( awcTmp, L"%f", f );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_R8:
        {
            double d;
            RtlCopyMemory( &d, pv, sizeof d );
            swprintf( awcTmp, L"%lf", d );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_DECIMAL:
        {
            double dbl;
            VarR8FromDec( (DECIMAL *) pv, &dbl );
            swprintf( awcTmp, L"%lf", dbl );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_CY:
        {
            double dbl;
            VarR8FromCy( * (CY *) pv, &dbl );
            swprintf( awcTmp, L"%lf", dbl );
            int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                       & App.NumberFormatFloat(),
                                       awcBuf,
                                       cwcBufSize );
            Append( xOut, awcBuf, cwc - 1 );
            break;
        }
        case VT_BOOL:
        {
            Append( xOut,
                    *(VARIANT_BOOL *)pv ? App.GetTrue() : App.GetFalse() );
            break;
        }
        case VT_BSTR:
        {
            BSTR bstr = *(BSTR *) pv;
            Append( xOut, bstr );
            break;
        }
        case VT_VARIANT:
        {
            PROPVARIANT * pVar = (PROPVARIANT *) pv;
            Render( xOut, pVar->vt, & pVar->lVal );
            break;
        }
        case VT_DATE:
        {
            DATE date;
            RtlCopyMemory( &date, pv, sizeof date );
            awcBuf[0] = 0;

            // no timezone is expressed or implied in variant dates.

            SYSTEMTIME SysTime;
            RtlZeroMemory( &SysTime, sizeof SysTime );
            VariantTimeToSystemTime( date, &SysTime );

            // date
            int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &SysTime,
                                     0, awcBuf, cwcBufSize );
            if ( 0 != cwc )
                Append( xOut, awcBuf, cwc - 1 );

            Append( xOut, L" " );

            // time
            cwc = GetTimeFormat( lcid, 0, &SysTime, 0, awcBuf,
                                 cwcBufSize );
            if ( 0 != cwc )
                Append( xOut, awcBuf, cwc - 1 );
            break;
        }

        case VT_EMPTY:
        case VT_NULL:
        {
            break;
        }
        default :
        {
            swprintf( awcTmp, L"(vt 0x%x)", (int) vt );
            Append( xOut, awcTmp );
            break;
        }
    }
} //Render

void RenderSafeArray(
    WCHAR *     pwc,
    unsigned    cwcMax,
    VARTYPE     vt,
    LPSAFEARRAY pa )
{
    *pwc = 0;
    cwcMax -= 10; // leave room for formatting

    // Get the dimensions of the array

    CDynArrayInPlace<WCHAR> xOut;
    UINT cDim = SafeArrayGetDim( pa );
    if ( 0 == cDim )
        return;

    XArray<LONG> xDim( cDim );
    XArray<LONG> xLo( cDim );
    XArray<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        HRESULT hr = SafeArrayGetLBound( pa, iDim + 1, &xLo[iDim] );
        if ( FAILED( hr ) )
            return;

        xDim[ iDim ] = xLo[ iDim ];

        hr = SafeArrayGetUBound( pa, iDim + 1, &xUp[iDim] );
        if ( FAILED( hr ) )
            return;

        srchDebugOut(( DEB_ITRACE, "dim %d, lo %d, up %d\n",
                       iDim, xLo[iDim], xUp[iDim] ));

        xOut[ xOut.Count() ] = L'{';
    }

    // slog through the array

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone && ( xOut.Count() < cwcMax ) )
    {
        // inter-element formatting

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            xOut[ xOut.Count() ] = L',';

        // Get the element and render it

        void *pv;
        HRESULT hr = SafeArrayPtrOfIndex( pa, xDim.GetPointer(), &pv );
        Win4Assert( SUCCEEDED( hr ) );
        Render( xOut, vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            xOut[ xOut.Count() ] = L'}';

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            xOut[ xOut.Count() ] = L'{';
    }

    unsigned cwc = __min( cwcMax, xOut.Count() );
    RtlCopyMemory( pwc, xOut.GetPointer(), cwc * sizeof WCHAR );

    // If it wouldn't all fit, show ...

    if ( !fDone )
    {
        pwc[ cwc++ ] = '.';
        pwc[ cwc++ ] = '.';
        pwc[ cwc++ ] = '.';
    }

    pwc[ cwc ] = 0;
} //RenderSafeArray

void CSearchView::PaintItem (
    CSearchQuery * pSearch,
    HDC            hdc,
    RECT &         rc,
    DWORD          iRow )
{
    static WCHAR wszfmtU[] = L"%u";    // unsigned scalar
    static WCHAR wszfmtVU[] = L"%lc%u"; // vector of unsigned scalars

    PROPVARIANT * aProps[ maxBoundCols ];
    unsigned cColumns;

    if ( ! pSearch->GetRow( iRow, cColumns, aProps ) )
        return;

    //
    // These must be static for IceCap profiling to work.  Declaring them on
    // stack causes __alloca_probe (alias: _chkstk) to be called.  This
    // routine plays funny games with the stack that IceCap V3 doesn't understand.
    //

    static WCHAR awcBuf[cwcBufSize];
    static WCHAR awcTmp[cwcBufSize];

    LCID lcid = App.GetLocale();
    rc.left += cpMargin; // leave a margin

    for ( unsigned i = 0; i < cColumns; i++ )
    {
        PROPVARIANT & v = * aProps[ i ];
        unsigned width = _aWidths[ i ];
        WCHAR *pwszfmt = L"%d";            // signed scalar
        WCHAR *pwszfmtV = L"%lc%d";        // vector of signed scalars
        BOOL fHighPartValid;

        switch ( v.vt )
        {
            case VT_UI1:
                v.ulVal = v.bVal;
                goto doulong;

            case VT_I1:
                v.lVal = v.cVal;
                goto dolong;

            case VT_UI2:
                v.ulVal = v.uiVal;
                goto doulong;

            case VT_I2:
                v.lVal = v.iVal;
                goto dolong;

            case VT_UI4:
            case VT_UINT:
doulong:
                pwszfmt = wszfmtU;
            case VT_I4:
            case VT_INT:
            case VT_ERROR:
dolong:
            {
                int cwc;

                if ( i == _iColAttrib )
                {
                    cwc = 0;
                    WCHAR *pwc = App.GetAttrib();
                    LONG l = v.lVal;
                    if ( l & FILE_ATTRIBUTE_READONLY )
                        awcBuf[ cwc++ ] = pwc[ 0 ];
                    if ( l & FILE_ATTRIBUTE_HIDDEN )
                        awcBuf[ cwc++ ] = pwc[ 1 ];
                    if ( l & FILE_ATTRIBUTE_SYSTEM )
                        awcBuf[ cwc++ ] = pwc[ 2 ];
                    if ( l & FILE_ATTRIBUTE_DIRECTORY )
                        awcBuf[ cwc++ ] = pwc[ 3 ];
                    if ( l & FILE_ATTRIBUTE_ARCHIVE )
                        awcBuf[ cwc++ ] = pwc[ 4 ];
                    if ( l & FILE_ATTRIBUTE_ENCRYPTED )
                        awcBuf[ cwc++ ] = pwc[ 5 ];
                    if ( l & FILE_ATTRIBUTE_NORMAL )
                        awcBuf[ cwc++ ] = pwc[ 6 ];
                    if ( l & FILE_ATTRIBUTE_TEMPORARY )
                        awcBuf[ cwc++ ] = pwc[ 7 ];
                    if ( l & FILE_ATTRIBUTE_SPARSE_FILE )
                        awcBuf[ cwc++ ] = pwc[ 8 ];
                    if ( l & FILE_ATTRIBUTE_REPARSE_POINT )
                        awcBuf[ cwc++ ] = pwc[ 9 ];
                    if ( l & FILE_ATTRIBUTE_COMPRESSED )
                        awcBuf[ cwc++ ] = pwc[ 10 ];
                    if ( l & FILE_ATTRIBUTE_OFFLINE )
                        awcBuf[ cwc++ ] = pwc[ 11 ];
                    if ( l & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )
                        awcBuf[ cwc++ ] = pwc[ 12 ];
                    awcBuf[ cwc ] = 0;
                }
                else
                {
                    if ( pwszfmt == wszfmtU )
                        _ultow( v.lVal, awcTmp, 10 );
                    else
                        _ltow( v.lVal, awcTmp, 10 );

                    cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormat(), awcBuf,
                                           cwcBufSize );
                    cwc--;
                }

                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_I8:
            {
                _i64tow( * (__int64 *) &v.hVal, awcTmp, 10 );
                int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormat(), awcBuf,
                                           cwcBufSize );
                cwc--;
                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_UI8:
            {
                if ( i == _iColFileIndex )
                {
                    wcscpy( awcBuf, L"0x" );

                    if ( 0 != v.hVal.HighPart )
                    {
                        wsprintf( awcTmp, L"%08x,", v.hVal.HighPart );
                        wcscat( awcBuf, awcTmp );
                    }

                    wsprintf( awcTmp, L"%08x", v.hVal.LowPart );
                    wcscat( awcBuf, awcTmp );
                    _drawText( hdc, rc, width, awcBuf, -1, _fMucked );
                }
                else
                {
                    _ui64tow( *(unsigned __int64 *) &v.hVal, awcTmp, 10 );
                    int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                               & App.NumberFormat(), awcBuf,
                                               cwcBufSize );
                    cwc--;
                    _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                }
                break;
            }

            case VT_FILETIME :
            {
                awcBuf[0] = 0;

                if ( 0 == v.filetime.dwLowDateTime &&
                     0 == v.filetime.dwHighDateTime )
                {
                    _drawText( hdc, rc, width, L"0", -1, TRUE );
                }
                else
                {
                    // convert the file time to local time, then to system time
                    FILETIME LocalFTime;
                    memset( &LocalFTime, 0, sizeof LocalFTime );
                    FileTimeToLocalFileTime( &(v.filetime), &LocalFTime );
                    SYSTEMTIME SysTime;
                    memset( &SysTime, 0, sizeof SysTime );
                    FileTimeToSystemTime( &LocalFTime, &SysTime );

                    // date
                    int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &SysTime,
                                             0, awcBuf, cwcBufSize );
                    int dmin = __min( _cpDateWidth, (int) width );
                    if ( 0 != cwc )
                        _drawText( hdc, rc, dmin, awcBuf, cwc - 1, _fMucked );

                    // time
                    if ( (int) width > _cpDateWidth )
                    {
                        cwc = GetTimeFormat( lcid, 0, &SysTime, 0, awcBuf,
                                             cwcBufSize );
                        int left = rc.left;
                        rc.left += _cpDateWidth;
                        int tmin = __min( _cpTimeWidth, (int) width - _cpDateWidth );
                        if ( 0 != cwc )
                            _drawText( hdc, rc, tmin, awcBuf, cwc - 1, _fMucked );
                        rc.left = left;
                    }
                }

                break;
            }

            case VT_LPWSTR :
            case DBTYPE_WSTR | DBTYPE_BYREF :
            case VT_LPSTR :
            case DBTYPE_STR | DBTYPE_BYREF :
            case VT_BSTR :
            {
                if ( 0 != v.pwszVal )
                {
                    // don't clip if it's the last column

                    UINT f = ( i == ( cColumns - 1 ) ) ? DT_NOCLIP : 0;
                    RECT rctext;
                    CopyRect( &rctext, &rc );
                    rctext.right = rc.left + width;

                    if ( ( VT_LPSTR == v.vt ) ||
                         ( ( DBTYPE_STR | DBTYPE_BYREF ) == v.vt ) )
                        DrawTextA( hdc,
                                   v.pszVal,
                                   -1,
                                   &rctext,
                                   DT_VCENTER | DT_LEFT | DT_NOPREFIX |
                                   DT_SINGLELINE | f );
                    else
                        DrawText( hdc,
                                  v.pwszVal,
                                  -1,
                                  &rctext,
                                  DT_VCENTER | DT_LEFT | DT_NOPREFIX |
                                  DT_SINGLELINE | f );
                }
                break;
            }

            case VT_R4:
            {
                swprintf( awcTmp, L"%f", v.fltVal );
                int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormatFloat(),
                                           awcBuf,
                                           cwcBufSize );
                cwc--;
                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_DATE:
            {
                awcBuf[0] = 0;

                SYSTEMTIME SysTime;
                RtlZeroMemory( &SysTime, sizeof SysTime );
                VariantTimeToSystemTime( v.date, &SysTime );

                // date

                int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &SysTime,
                                         0, awcBuf, cwcBufSize );
                int dmin = __min( _cpDateWidth, (int) width );
                if ( 0 != cwc )
                    _drawText( hdc, rc, dmin, awcBuf, cwc - 1, _fMucked );

                // time

                if ( (int) width > _cpDateWidth )
                {
                    cwc = GetTimeFormat( lcid, 0, &SysTime, 0, awcBuf,
                                         cwcBufSize );
                    int left = rc.left;
                    rc.left += _cpDateWidth;
                    int tmin = __min( _cpTimeWidth, (int) width - _cpDateWidth );
                    if ( 0 != cwc )
                        _drawText( hdc, rc, tmin, awcBuf, cwc - 1, _fMucked );
                    rc.left = left;
                }

                break;
            }

            case VT_R8:
            {
                swprintf( awcTmp, L"%lf", v.dblVal );
                int cwc = GetNumberFormat( lcid, 0, awcTmp,
                                           & App.NumberFormatFloat(),
                                           awcBuf,
                                           cwcBufSize );
                cwc--;
                _drawText( hdc, rc, width, awcBuf, cwc, _fMucked );
                break;
            }

            case VT_DECIMAL:
            {
                double dbl;
                VarR8FromDec( &v.decVal, &dbl );
                swprintf( awcBuf, L"%lf", dbl );
                _drawText( hdc, rc, width, awcBuf, -1, TRUE );
                break;
            }

            case VT_CY:
            {
                double dbl;
                VarR8FromCy( v.cyVal, &dbl );
                swprintf( awcTmp, L"$%lf", dbl );
                _drawText( hdc, rc, width, awcTmp, -1, _fMucked );
                break;
            }

            case VT_BOOL:
            {
                _drawText( hdc, rc, width,
                           v.boolVal ? App.GetTrue() : App.GetFalse(), -1, _fMucked );
                break;
            }

            case VT_CLSID:
            {
                GUID * puuid = v.puuid;
                if ( 0 != puuid )
                    swprintf( awcTmp,
                              L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                              puuid->Data1,
                              puuid->Data2,
                              puuid->Data3,
                              puuid->Data4[0], puuid->Data4[1],
                              puuid->Data4[2], puuid->Data4[3],
                              puuid->Data4[4], puuid->Data4[5],
                              puuid->Data4[6], puuid->Data4[7] );
                else
                    awcTmp[0] = 0;

                _drawText( hdc, rc, width, awcTmp, -1, _fMucked );
                break;
            }

            case VT_BLOB:
            {
                swprintf( awcTmp,
                          App.GetBlob(),
                          v.blob.cbSize,
                          v.blob.pBlobData );

                _drawText( hdc, rc, width, awcTmp, -1, TRUE );
                break;
            }

            case VT_CF:
            {
                if ( 0 != v.pclipdata )
                    swprintf( awcTmp, L"vt_cf cb 0x%x, fmt 0x%x",
                              v.pclipdata->cbSize,
                              v.pclipdata->ulClipFmt );
                else
                    swprintf( awcTmp, L"vt_cf (null)" );

                _drawText( hdc, rc, width, awcTmp, -1, TRUE );
                break;
            }

            case VT_VECTOR | VT_UI1:
                pwszfmtV = wszfmtVU;
            case VT_VECTOR | VT_I1:
            {
                _drawVectorItems( v.caub.pElems,
                                  v.caub.cElems,
                                  pwszfmtV,
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_BOOL:
            case VT_VECTOR | VT_UI2:
                pwszfmtV = wszfmtVU;
            case VT_VECTOR | VT_I2:
            {
                _drawVectorItems( v.cai.pElems,
                                  v.cai.cElems,
                                  pwszfmtV,
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_UI4:
                pwszfmtV = wszfmtVU;
            case VT_VECTOR | VT_I4:
            {
                _drawVectorItems( v.cal.pElems,
                                  v.cal.cElems,
                                  pwszfmtV,
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_LPSTR:
            case VT_VECTOR | VT_LPWSTR:
            case VT_VECTOR | VT_BSTR:
            {
                _drawVectorItems( v.calpwstr.pElems,
                                  v.calpwstr.cElems,
                                  ( ( VT_VECTOR | VT_LPSTR ) == v.vt ) ?
                                      L"%wc%S" : L"%wc%s",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_R4:
            {
                _drawVectorItems( v.caflt.pElems,
                                  v.caflt.cElems,
                                  L"%wc%f",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_R8:
            {
                _drawVectorItems( v.cadbl.pElems,
                                  v.cadbl.cElems,
                                  L"%wc%lf",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            case VT_VECTOR | VT_I8:
            case VT_VECTOR | VT_UI8:
            {
                _drawVectorItems( v.cah.pElems,
                                  v.cah.cElems,
                                  ( v.vt == ( VT_VECTOR | VT_I8 ) ) ?
                                      L"%wc%I64d" : L"%wc%I64u",
                                  hdc,
                                  rc,
                                  width );
                break;
            }

            //case VT_VECTOR | VT_DATE:
            //case VT_VECTOR | VT_FILETIME:
            //case VT_VECTOR | VT_CF:
            //case VT_VECTOR | VT_CY:
            //case VT_VECTOR | VT_VARIANT:

            case VT_NULL :
            case VT_EMPTY :
            {
                //_drawText( hdc, rc, width, L"-", -1, TRUE );
                break;
            }

            default :
            {
                if ( VT_ARRAY & v.vt )
                {
                    RenderSafeArray( awcBuf,
                                     sizeof awcBuf / sizeof WCHAR,
                                     v.vt - VT_ARRAY,
                                     v.parray );
                    _drawText( hdc, rc, width, awcBuf, -1, TRUE );
                    break;
                }

                swprintf( awcTmp, L"(vt 0x%x)", (int) v.vt );
                _drawText( hdc, rc, width, awcTmp, -1, TRUE );
                break;
            }
        }

        rc.left += ( width + _cpAvgWidth );
    }
} //PaintItem

void CSearchView::Size(
    int cx,
    int cy )
{
    HDWP hDefer = BeginDeferWindowPos( 4 );

    if ( 0 == hDefer )
        return;

    int iFontDY = _cpFontHeight;
    int dyQuery = _iLineHeightList + _cpFontHeight / 2;
    int iListHeight = cy - ( 2 * cpPaneSpacing ) - dyQuery;

    int iX = cpPaneMargin;
    int iDX = cx - cpPaneMargin * 2;
    int iY = cpPaneSpacing;
    int iDY = iFontDY;
    int iTitleDX = iFontDY * 3;

    if (!_fHavePlacedTitles)
        hDefer = DeferWindowPos( hDefer,
                                 _hwndQueryTitle,
                                 0,
                                 iX, iY + iFontDY / 4,
                                 iTitleDX, iDY,
                                 SWP_NOZORDER );

    hDefer = DeferWindowPos( hDefer,
                             _hwndQuery,
                             0,
                             iX + iTitleDX, iY,
                             iDX - iTitleDX, dyQuery,
                             SWP_NOZORDER ); 

    if (iListHeight > 0)
    {
        HD_LAYOUT hdl;
        RECT rc = { 0, 0, cx, cy };
        hdl.prc = &rc;
        WINDOWPOS wp;
        hdl.pwpos = &wp;
        Header_Layout( _hwndHeader, &hdl );

        iY += ( dyQuery + cpPaneSpacing );

        hDefer = DeferWindowPos( hDefer,
                                 _hwndHeader,
                                 0,
                                 iX, iY,
                                 iDX, wp.cy,
                                 SWP_NOZORDER );

        int iListY = iY + wp.cy;

        iListY--; // too many black lines...

        iListHeight = cy - iListY - cpPaneBottomSpacing;

        // fit integral number of lines in listview

        int cyBorder2x = 2 * GetSystemMetrics( SM_CYBORDER );
        _cLines = ( iListHeight - cyBorder2x ) / GetLineHeight();

        hDefer = DeferWindowPos( hDefer,
                                 _hwndList,
                                 0,
                                 iX, iListY,
                                 iDX, _cLines * GetLineHeight() + cyBorder2x,
                                 SWP_NOZORDER );
    }

    EndDeferWindowPos( hDefer );

    _fHavePlacedTitles = TRUE;
} //Size

void CSearchView::FontChanged(
    HFONT hfontNew )
{
    HDC hdc = GetDC (_hwndList);

    if (hdc)
    {
        HFONT hfOld = (HFONT) SelectObject( hdc, hfontNew );
        TEXTMETRIC tm;
        GetTextMetrics (hdc, &tm);
        _iLineHeightList = (tm.tmHeight + 2 * tm.tmExternalLeading);
        SelectObject( hdc, hfOld );

        RECT rc;
        GetWindowRect(_hwndList,(LPRECT) &rc);
        _cLines = (rc.bottom - rc.top) / GetLineHeight();

        ReleaseDC( _hwndList, hdc );
    }
} //FontChanged

void CSearchView::ResizeQueryCB()
{
    RECT rect;

    ShowWindow( _hwndQuery, SW_HIDE );

    if ( GetClientRect( _hwndQuery, &rect ) )
    {
        SetWindowPos( _hwndQuery,
                      0,
                      0,
                      0,
                      rect.right,
                      5 * ( _cpFontHeight * 3 ) / 2,
                      SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW | SWP_DEFERERASE | 
                      SWP_NOACTIVATE );
    }
    ShowWindow( _hwndQuery, SW_SHOWNOACTIVATE );
}

inline int CSearchView::_MeasureString(
    HDC     hdc,
    WCHAR * pwcMeasure,
    RECT &  rc,
    int     cwc)
{
    RECT rcMeasure;
    CopyRect( &rcMeasure, &rc );

    DrawText( hdc, pwcMeasure, cwc, &rcMeasure,
              DT_CALCRECT | DT_SINGLELINE | DT_BOTTOM | DT_LEFT );
    return rcMeasure.right - rcMeasure.left;
} //_MeasureString

void CSearchView::_ComputeFieldWidths()
{
    HDC hdc = GetDC( _hwndList );

    if ( 0 == hdc )
        return;

    HFONT hfOld = (HFONT) SelectObject( hdc, (HGDIOBJ) App.AppFont() );

    TEXTMETRIC tm;
    GetTextMetrics( hdc, &tm );
    _cpAvgWidth = tm.tmAveCharWidth;

    RECT rc = { 0, 0, 2000, 2000 };

    SYSTEMTIME st;
    RtlZeroMemory( &st, sizeof st );
    st.wMonth = 12;
    st.wDay = 28;
    st.wDayOfWeek = 3;
    st.wYear = 1994;

    LCID lcid = App.GetLocale();
    WCHAR awc[ cwcBufSize ];
    int cwc = GetDateFormat( lcid, DATE_SHORTDATE, &st, 0, awc, cwcBufSize );
    _cpDateWidth = _MeasureString( hdc, awc, rc, cwc - 1 );

    st.wHour = 22;
    st.wMinute = 59;
    st.wSecond = 59;
    st.wMilliseconds = 10;

    cwc = GetTimeFormat( lcid, 0, &st, 0, awc, cwcBufSize );
    _cpTimeWidth = _MeasureString( hdc, awc, rc, cwc - 1 );
    _cpTimeWidth += _cpAvgWidth; // room between time and date...

    _cpGuidWidth = _MeasureString( hdc, L"{8dee0300-16c2-101b-b121-08002b2ecda9}", rc);

    _cpBoolWidth = _MeasureString( hdc, App.GetFalse(), rc);

    // guess that only half of the attributes will be on at once

    _cpAttribWidth = 4 + _MeasureString( hdc, App.GetAttrib(), rc ) / 2;

    _cpFileIndexWidth = _MeasureString( hdc, L"0x88888888,88888888", rc );

    SelectObject( hdc, hfOld );
    ReleaseDC( _hwndList, hdc );
} //_ComputeFieldWidths
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\watch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       watch.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//#define USE_WATCH_REGIONS  // last tried 10/7/96

//
// CWatchQuery
//

CWatchQuery::CWatchQuery (CSearchQuery* pClient, IRowsetScroll* pRowset)
: _pClient (pClient),
  _pContainer (0),
  _pNotifyWatch (0),
  _pPoint (0),
  _pRowsetWatch (0),
  _hRegion (0),
  _fEverGotARowsChanged(FALSE),
  _wnLast( 0 )
{
    if (!pRowset)
        THROW (CException(E_FAIL));

    _pNotifyWatch = new CRowsetNotifyWatch( pClient->_hwndNotify );

    SCODE sc = pRowset->QueryInterface( IID_IConnectionPointContainer,
                                        (void **) &_pContainer );
    if (SUCCEEDED(sc))
    {
        sc = _pContainer->FindConnectionPoint( IID_IRowsetWatchNotify,
                                               &_pPoint );
        if (SUCCEEDED(sc))
        {
            sc = _pPoint->Advise( (IUnknown *) _pNotifyWatch,
                                  &_dwAdviseID );
            if (SUCCEEDED(sc))
            {
                sc = pRowset->QueryInterface( IID_IRowsetWatchRegion,
                                              (void**) &_pRowsetWatch );
            }
        }
    }
#ifdef USE_WATCH_REGIONS
    if (_pRowsetWatch)
    {
        sc = _pRowsetWatch->CreateWatchRegion (DBWATCHMODE_MOVE, &_hRegion);
    }
#endif
    _mode = DBWATCHMODE_MOVE;
} //CWatchNotify

CWatchQuery::~CWatchQuery ()
{
    srchDebugOut(( DEB_ITRACE,
                   "~CWatchQuery, ever got a rc: %d, _wnLast: %d\n",
                   _fEverGotARowsChanged, _wnLast ));
    if (_pPoint)
    {
        _pPoint->Unadvise(_dwAdviseID);
        _pPoint->Release();
    }

    if (_pContainer)
        _pContainer->Release();
    if (_pRowsetWatch)
        _pRowsetWatch->Release();

    if (_pNotifyWatch)
        _pNotifyWatch->Release();
} //~CWatchQuery

void CWatchQuery::Notify (HWND hwndList, DBWATCHNOTIFY changeType)
{
    // don't post more notifications while we're busy

    _pNotifyWatch->HoldNotifications( TRUE );

    _wnLast = changeType;

    switch (changeType)
    {
        case DBWATCHNOTIFY_QUERYDONE:
            _pClient->Quiesce(TRUE);
             srchDebugOut(( DEB_ITRACE, "CWatchQuery::Notify - Query DONE\n"));
            break;
        case DBWATCHNOTIFY_QUERYREEXECUTED:
            _pClient->Quiesce(FALSE);
            break;
        case DBWATCHNOTIFY_ROWSCHANGED:
            RowsChanged (hwndList);
            break;
        default :
            Win4Assert( !"unexpected notification!" );
            break;
    }
} //Notify

void CWatchQuery::NotifyComplete()
{
    _pNotifyWatch->HoldNotifications( FALSE );
} //NotifyComplete

void CWatchQuery::RowsChanged (HWND hwnd)
{
    DBCOUNTITEM cChanges = 0;
    DBROWWATCHCHANGE* aChange = 0;

    _fEverGotARowsChanged = TRUE;
    SCODE sc = _pRowsetWatch->Refresh( &cChanges, &aChange );

    Win4Assert ((sc == STATUS_UNEXPECTED_NETWORK_ERROR ||
                 sc == DB_S_TOOMANYCHANGES || sc == E_FAIL) 
                && cChanges == 0);

    if ( sc == STATUS_UNEXPECTED_NETWORK_ERROR )
        sc = DB_S_TOOMANYCHANGES;

    if (sc == DB_S_TOOMANYCHANGES)
    {
        _pClient->CreateScript (&cChanges, &aChange);
    }

    srchDebugOut(( DEB_ITRACE, "CWatchQuery::RowsChanged Changes = %d\n", cChanges));

    if (cChanges != 0)
    {
        ExecuteScript (hwnd, (ULONG) cChanges, aChange);
        CoTaskMemFree (aChange);
    }
} //RowsChanged

void CWatchQuery::ExecuteScript (HWND hwndList, ULONG cChanges, DBROWWATCHCHANGE* aScript)
{
    for (ULONG i = 0; i < cChanges; i++)
    {
        switch (aScript[i].eChangeKind)
        {
            case DBROWCHANGEKIND_INSERT:
                _pClient->InsertRowAfter((int) aScript[i].iRow, aScript[i].hRow);
                SendMessage (hwndList, wmInsertItem, 0, aScript[i].iRow );
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row INS: %d\n", aScript[i].iRow));
                break;
            case DBROWCHANGEKIND_DELETE:
                _pClient->DeleteRow ((int) aScript[i].iRow);
                SendMessage (hwndList, wmDeleteItem, 0, aScript[i].iRow );
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row DEL: %d\n", aScript[i].iRow));
                break;
            case DBROWCHANGEKIND_UPDATE:
                _pClient->UpdateRow ((int) aScript[i].iRow, aScript[i].hRow);
                SendMessage (hwndList, wmUpdateItem, 0, aScript[i].iRow );
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row UPD\n"));
                break;
            case DBROWCHANGEKIND_COUNT:
                _pClient->UpdateCount ((int) aScript[i].iRow);
                srchDebugOut(( DEB_ITRACE, "CWatchQuery::ExecuteScript - Row CNT\n"));
            default:
                Win4Assert (!"unknown change kind");
        }
    }
} //ExecuteScript

void CWatchQuery::Extend (HWATCHREGION hRegion)
{
#ifdef USE_WATCH_REGIONS
    if ((_mode & DBWATCHMODE_EXTEND) == 0)
    {
        _mode |= DBWATCHMODE_EXTEND;
        _mode &= ~DBWATCHMODE_MOVE;
        _pRowsetWatch->ChangeWatchMode ( hRegion, _mode);
    }
#endif
}

void CWatchQuery::Move (HWATCHREGION hRegion)
{
#ifdef USE_WATCH_REGIONS
    if ((_mode & DBWATCHMODE_MOVE) == 0)
    {
        _mode |= DBWATCHMODE_MOVE;
        _mode &= ~DBWATCHMODE_EXTEND;
        _pRowsetWatch->ChangeWatchMode ( hRegion, _mode);
    }
#endif
}

void CWatchQuery::Shrink (HWATCHREGION hRegion, CBookMark& bmk, ULONG cRows)
{
#ifdef USE_WATCH_REGIONS
    _pRowsetWatch->ShrinkWatchRegion (hRegion,
                                      0, // no chapter
                                      bmk.cbBmk, bmk.abBmk,
                                      cRows //_mode
                                      );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srch\srchwnd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       srchwnd.cxx
//
//  Contents:   
//
//  History:    15 Aug 1996     DLee    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <ntquery.h>

//
// Main Search Window procedure
//

LRESULT WINAPI SearchWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;
    // Find search control corresponding to this window
    CSearchControl *pControl = (CSearchControl *) GetWindowLongPtr( hwnd, 0 );

    switch (msg)
    {
        //
        // Message sent to us by ListView
        //
        case wmListNotify:
            lRet = pControl->wmListNotify (hwnd, wParam, lParam);
            break;
        case wmDrawItem :
            lRet = pControl->wmDrawItem(wParam,lParam);
            break;
        case wmMeasureItem:
            pControl->wmMeasureItem(wParam,lParam);
            break;

        // OLE DB notification
        case wmNotification:
            pControl->wmNotification(wParam,lParam);
            break;

        //------------------------------------
        case wmAccelerator :
            pControl->wmAccelerator(wParam,lParam);
            break;
        case WM_MDIACTIVATE :
            lRet = pControl->wmActivate( hwnd, wParam, lParam );
            break;
        case WM_DRAWITEM :
            lRet = pControl->wmRealDrawItem( hwnd, wParam, lParam );
            break;
        case WM_SIZE :
            lRet = pControl->wmSize(wParam,lParam);
            break;
        case wmDisplaySubwindows :
            pControl->wmDisplaySubwindows(wParam,lParam);
            break;
        case WM_CREATE :
        {
            CREATESTRUCT *pcs = (CREATESTRUCT *) lParam;
            MDICREATESTRUCT *pmcs = (MDICREATESTRUCT *) pcs->lpCreateParams;
            pControl = new CSearchControl(hwnd, (WCHAR *) pmcs->lParam);
            PostMessage( hwnd, wmDisplaySubwindows, 0, 0 );
            break;
        }
        case WM_CTLCOLORSTATIC :
            SetTextColor((HDC) wParam, GetSysColor( COLOR_BTNTEXT ) );
            // fall through
        case WM_CTLCOLORBTN :
            SetBkColor((HDC) wParam, GetSysColor( COLOR_BTNFACE ) );
            lRet = (LRESULT) (LPVOID) App.BtnFaceBrush();
            break;
        case wmNewFont :
            pControl->wmNewFont(wParam,lParam);
            break;
        case wmAppClosing :
            pControl->wmAppClosing(wParam,lParam);
            break;
        case WM_CLOSE :
            pControl->wmClose(wParam,lParam);
            lRet = DefMDIChildProc(hwnd,msg,wParam,lParam);
            break;
        case WM_DESTROY :
            delete pControl;
            break;
        case wmMenuCommand :
            pControl->wmMenuCommand(wParam,lParam);
            break;
        case WM_SETFOCUS :
        case wmGiveFocus :
            pControl->wmSetFocus(wParam,lParam);
            break;
        case WM_COMMAND :
            pControl->wmCommand(wParam,lParam);
            break;
        case wmInitMenu :
            pControl->wmInitMenu(wParam,lParam);
            break;
        case WM_SYSCOLORCHANGE :
            pControl->wmSysColorChange( wParam, lParam );
            lRet = DefMDIChildProc( hwnd, msg, wParam, lParam );
            break;
        case WM_NOTIFY :
            pControl->wmColumnNotify( wParam, lParam );
            break;
        case WM_CONTEXTMENU :
            pControl->wmContextMenu( hwnd, wParam, lParam );
            break;
        default:
            lRet = DefMDIChildProc( hwnd, msg, wParam, lParam );
            break;
    }

    return lRet;
} //SearchWndProc

//
// Scope choice dialog box proc and helper functions
//

unsigned GetCatalogListCount( HWND hdlg )
{
    unsigned cChecked = 0;

    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    unsigned iItem = ListView_GetItemCount( hCatList ) ;
    LVITEM lvi;

    for ( ; iItem > 0; iItem-- )
    {
        lvi.iItem = iItem - 1;

        if ( ListView_GetCheckState( hCatList, lvi.iItem ) )
            cChecked++;
    }

    return cChecked;
} //GetCatalogListCount

void DeleteCatalogSelectedListItems( HWND hdlg )
{
    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    unsigned iItem = ListView_GetItemCount( hCatList ) ;

    for ( ; iItem > 0; iItem-- )
    {
        if ( LVIS_SELECTED == ListView_GetItemState( hCatList, iItem - 1, LVIS_SELECTED ) )
            ListView_DeleteItem( hCatList, iItem - 1 );
    }
} //DeleteCatalogSelectedListItems

BOOL IsInList(
    HWND                         hCatList,
    SScopeCatalogMachine const & scm,
    int &                        item )
{
    unsigned iItem = ListView_GetItemCount( hCatList ) ;

    LVITEM lvi;
    WCHAR wTemp[MAX_PATH];
    lvi.pszText = (WCHAR*)wTemp;
    lvi.cchTextMax = MAX_PATH;

    for ( ; iItem > 0; iItem-- )
    {
        unsigned iCol = 0;

        lvi.iItem = iItem - 1;
        lvi.mask  = LVIF_TEXT;
    
        // machine

        lvi.iSubItem  = iCol++;
        ListView_GetItem( hCatList, &lvi );

        if ( !_wcsicmp( scm.awcMachine, lvi.pszText ) )
        {
            // catalog

            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            if ( !_wcsicmp( scm.awcCatalog, lvi.pszText ) )
            {
                // scope

                lvi.iSubItem  = iCol++;
                ListView_GetItem( hCatList, &lvi );

                if ( !_wcsicmp( scm.awcScope, lvi.pszText ) )
                {
                    item = lvi.iItem;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
} //IsInList

void AddCatalogToList(
    HWND                         hdlg,
    SScopeCatalogMachine const & scm,
    BOOL                         fChecked )
{
    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    // Don't add duplicates, but check the checkbox if needed

    int item;
    if ( IsInList( hCatList, scm, item ) )
    {
        if ( fChecked )
            ListView_SetCheckState( hCatList, item, fChecked );

        return;
    }

    unsigned cItems = ListView_GetItemCount( hCatList ) ;

    LVITEM lvItem;
    unsigned iCol = 0;

    // Machine
    lvItem.mask     = LVIF_TEXT;
    lvItem.iItem    = cItems;
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = (WCHAR*)scm.awcMachine;
    ListView_InsertItem( hCatList, &lvItem );

    // Catalog
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = (WCHAR*)scm.awcCatalog;
    ListView_SetItem( hCatList, &lvItem );

    // Scope
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = (WCHAR*)scm.awcScope;
    ListView_SetItem( hCatList, &lvItem );

    // Depth
    lvItem.iSubItem = iCol++;
    lvItem.pszText  = ( TRUE == scm.fDeep ) ? App.GetYes() : App.GetNo();
    ListView_SetItem( hCatList, &lvItem );

    ListView_SetCheckState( hCatList, cItems, fChecked );
} //AddCatalogToList

void CheckItIfInList(
    HWND                         hdlg,
    SScopeCatalogMachine const & scm )
{
    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    // Don't add duplicates, but check the checkbox if needed

    int item;
    if ( IsInList( hCatList, scm, item ) )
        ListView_SetCheckState( hCatList, item, TRUE );
} //CheckItIfInList

BOOL VerifyCatalogInfo( HWND hdlg, SScopeCatalogMachine & scm )
{
    CWaitCursor wait;

    if (IsDlgButtonChecked(hdlg,ID_SCOPE_DEEP))
        scm.fDeep = TRUE;
    else
        scm.fDeep = FALSE;

    GetDlgItemText( hdlg,
                    ID_SCOPE_EDIT,
                    scm.awcScope,
                    MAX_PATH );

    GetDlgItemText( hdlg,
                    ID_SCOPE_CATALOG_EDIT,
                    scm.awcCatalog,
                    MAX_PATH );

    GetDlgItemText( hdlg,
                    ID_SCOPE_MACHINE_EDIT,
                    scm.awcMachine,
                    SRCH_COMPUTERNAME_LENGTH );

    if ( 0 == scm.awcCatalog[0] )
    {

        //
        // If the user didn't specify a Catalog, then look for one using scope.
        //

        ULONG ccCat = sizeof(scm.awcCatalog)/sizeof(WCHAR);
        ULONG ccMachine = sizeof(scm.awcMachine)/sizeof(WCHAR);

        SCODE sc = LocateCatalogs( scm.awcScope,
                                   0,
                                   scm.awcMachine,
                                   &ccMachine,
                                   scm.awcCatalog,
                                   &ccCat );
    }

    // don't allow empty catalog names

    if ( 0 == scm.awcCatalog[0] )
    {
        SearchError( hdlg,
                     IDS_ERR_NO_CATALOG_SPECIFIED,
                     L"" );
        return FALSE;
    }

    // if scope is empty make it a global physical scope.

    if ( 0 == scm.awcScope[0] )
        wcscpy( scm.awcScope, L"\\" ); // entire catalog

    // map empty machine name to local machine

    if ( 0 == scm.awcMachine[0] )
        wcscpy( scm.awcMachine, L"." ); // local machine

    // remove leading two backslashes from machine name

    if ( L'\\' == scm.awcMachine[0] &&
         L'\\' == scm.awcMachine[1] )
    {
        WCHAR awc[SRCH_COMPUTERNAME_LENGTH + 1];
        wcscpy( awc, scm.awcMachine+2 );
        wcscpy( scm.awcMachine, awc );
    }

    CI_STATE cistate;
    cistate.cbStruct = sizeof cistate;

    if (STATUS_NOT_FOUND == CIState( scm.awcCatalog,
                                     scm.awcMachine,
                                     & cistate ) )
    {
        SearchError( hdlg,
                     IDS_ERR_BAD_CATALOG_SPECIFIED,
                     L"" );
        return FALSE;
    }

    return TRUE;
} //VerifyCatalogInfo

void CatListToString( HWND hdlg, XGrowable<WCHAR> & xCatStr )
{
    xCatStr.SetSize( 1 );
    xCatStr[0] = 0;

    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    unsigned iItem = ListView_GetItemCount( hCatList ) ;
    LVITEM lvi;
    WCHAR wTemp[MAX_PATH];
    lvi.pszText = (WCHAR*)wTemp;
    lvi.cchTextMax = MAX_PATH;

    for ( ; iItem > 0; iItem-- )
    {
        unsigned iCol = 0;
        unsigned cCatStr;
        unsigned cText;

        lvi.iItem = iItem - 1;

        if ( ListView_GetCheckState( hCatList, lvi.iItem ) )
        {
            lvi.mask  = LVIF_TEXT;
    
            // machine
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = wcslen( lvi.pszText );
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(), lvi.pszText );
            wcscat( xCatStr.Get(), L"," );
    
            // catalog
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = wcslen( lvi.pszText );
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(), lvi.pszText );
            wcscat( xCatStr.Get(), L"," );
    
            // scope
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = wcslen( lvi.pszText );
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(), lvi.pszText );
            wcscat( xCatStr.Get(), L"," );
    
            // depth
            lvi.iSubItem  = iCol++;
            ListView_GetItem( hCatList, &lvi );
    
            cCatStr = wcslen( xCatStr.Get() );
            cText   = 1;
    
            xCatStr.SetSize( cCatStr + cText + 2 );
    
            wcscat( xCatStr.Get(),
                    !wcscmp( App.GetYes(), lvi.pszText ) ? L"d" : L"s" );
            wcscat( xCatStr.Get(), L";" );
        }
    }
} //CatListToString

BOOL ScopeDlgInit(
    HWND   hdlg,
    LPARAM lParam,
    LPWSTR awcScopeOrig)
{
    SScopeCatalogMachine scm;

    // search control was passed as lParam
    SetWindowLongPtr(hdlg, DWLP_USER, lParam);
    XGrowable<WCHAR> *xCatList = (XGrowable<WCHAR> *) lParam;

    CheckDlgButton( hdlg, ID_SCOPE_DEEP, TRUE );

    SendDlgItemMessage( hdlg,
                        ID_SCOPE_MACHINE_EDIT,
                        EM_SETLIMITTEXT,
                        SRCH_COMPUTERNAME_LENGTH,
                        0 );

    SendDlgItemMessage( hdlg,
                        ID_SCOPE_EDIT,
                        EM_SETLIMITTEXT,
                        MAX_PATH,
                        0 );

    SendDlgItemMessage( hdlg,
                        ID_SCOPE_CATALOG_EDIT,
                        EM_SETLIMITTEXT,
                        MAX_PATH,
                        0 );

    // Setup columns in the multi catalog list box

    HWND hCatList = GetDlgItem( hdlg, ID_CATALOG_LIST );
    Win4Assert( hCatList );

    ListView_SetExtendedListViewStyleEx( hCatList,
                                         LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT,
                                         LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT );

    CResString str;
    LVCOLUMN lvc;
    unsigned iCol = 0;

    lvc.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt      = LVCFMT_LEFT;

    lvc.cx       = 100;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_MACHINE );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    lvc.cx       = 90;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_CATALOG );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    lvc.cx       = 90;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_SCOPE );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    lvc.cx       = 50;
    lvc.iSubItem = iCol++;
    str.Load( IDS_CATLIST_COL_SUBDIRS );
    lvc.pszText = str.Get();
    ListView_InsertColumn( hCatList, iCol, &lvc) ;

    BOOL fMultiCat = GetCatListItem( *xCatList,
                                     1,
                                     scm.awcMachine,
                                     scm.awcCatalog,
                                     scm.awcScope,
                                     scm.fDeep );

    scm.fDeep = TRUE;

    //
    // Add the catalogs from the user's environment if present.
    // The SRCHDEFAULTS variable is of the form
    //
    //  server\catalog:scope;server\catalog:scope;+server\catalog:scope
    //
    // + indicates that the server should be checked by default.  If no
    // scope is provided, then \ is used.
    //
    WCHAR wszDefaults[MAX_PATH];
    DWORD dwResult = GetEnvironmentVariableW( L"SRCHDEFAULTS", wszDefaults, MAX_PATH );
    if (dwResult && dwResult < MAX_PATH)
    {
        LPWSTR psz = wszDefaults;
        while ( *psz )
        {
            BOOL fChecked = FALSE;

            if ( *psz == L'+' )
            {
                fChecked = TRUE;
                psz++;
            }

            // Everything up to the \ is the server name
            LPWSTR pszT = wcschr( psz, L'\\' );
            if ( 0 == pszT )
            {
                break;
            }
            *pszT++ = L'\0';
            lstrcpynW( scm.awcMachine, psz, SRCH_COMPUTERNAME_LENGTH + 1 );

            // Everything up to the ; or end of string is the catalog:scope
            psz = pszT;
            pszT = wcschr( psz, L';' );
            if ( 0 != pszT )
            {
                *pszT++ = L'\0';
            }
            else
            {
                pszT = psz + wcslen( psz );
            }

            //
            //  If there is a : then that's the scope.
            //
            LPWSTR pszColon = wcschr( psz, L':' );
            if ( 0 != pszColon )
            {
                *pszColon++ = L'\0';
                lstrcpynW( scm.awcScope, pszColon, MAX_PATH );
            }
            else
            {
                // Default scope is "\"
                wcscpy( scm.awcScope, L"\\" );
            }

            lstrcpynW( scm.awcCatalog, psz, MAX_PATH );

            AddCatalogToList( hdlg, scm, fChecked );
            psz = pszT;
        }
    }
    else
    {
        // Add the well-known catalogs

        wcscpy( scm.awcScope, L"\\" );
        HRSRC hrc = FindResource( 0, (LPCWSTR) IDR_CATALOGS, RT_RCDATA );

        if ( 0 != hrc )
        {
            HGLOBAL hg = LoadResource( 0, hrc );

            if ( 0 != hg )
            {
                WCHAR * p = (WCHAR *) LockResource( hg );

                while ( 0 != p && 0 != *p )
                {
                    wcscpy( scm.awcMachine, p );
                    p += ( wcslen( p ) + 1 );
                    wcscpy( scm.awcCatalog, p );
                    p += ( wcslen( p ) + 1 );
                    AddCatalogToList( hdlg, scm, FALSE );
                }
            }
        }
    }

    if ( ! fMultiCat )
    {
        if ( GetCatListItem( *xCatList,
                             0,
                             scm.awcMachine,
                             scm.awcCatalog,
                             scm.awcScope,
                             scm.fDeep ) )
        {
            SetDlgItemText( hdlg, ID_SCOPE_EDIT, scm.awcScope );
            SetDlgItemText( hdlg, ID_SCOPE_CATALOG_EDIT, scm.awcCatalog );
            SetDlgItemText( hdlg, ID_SCOPE_MACHINE_EDIT, scm.awcMachine );
            CheckDlgButton( hdlg, ID_SCOPE_DEEP, scm.fDeep );

            CheckItIfInList( hdlg, scm );
        }
    }
    else
    {
        for ( unsigned ii = 0; ; ii ++ )
        {
            if ( GetCatListItem( *xCatList,
                                 ii,
                                 scm.awcMachine,
                                 scm.awcCatalog,
                                 scm.awcScope,
                                 scm.fDeep ) )
                AddCatalogToList( hdlg, scm, TRUE );
            else
                break;
        }
    }

    wcscpy( awcScopeOrig, scm.awcScope );

    UINT ctlID = ID_SCOPE_MACHINE_EDIT;

    SetFocus( GetDlgItem( hdlg, ctlID ) );
    MySendEMSetSel( GetDlgItem( hdlg, ctlID ), 0, (UINT) -1 );

    CenterDialog( hdlg );

    return FALSE;

} //ScopeDlgInit

INT_PTR WINAPI ScopeDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    BOOL fRet = FALSE;

    // pointer to search control that will receive the new scope
    // safe: can have one dlg up at a time!

    SScopeCatalogMachine scm;
    static WCHAR awcScopeOrig[MAX_PATH];

    switch (msg)
    {
        case WM_INITDIALOG :
        {
            fRet = ScopeDlgInit( hdlg, lParam, awcScopeOrig );
            break;
        }

        case WM_NOTIFY:
        {
            if ( ID_CATALOG_LIST == (int) wParam )
            {
                LPNMHDR pnmh = (LPNMHDR) lParam;

                if ( LVN_KEYDOWN == pnmh->code )
                {
                    NMLVKEYDOWN * pnkd = (NMLVKEYDOWN *) lParam;

                    if ( VK_DELETE == pnkd->wVKey )
                        DeleteCatalogSelectedListItems( hdlg );
                }
            }
            break;
        }

        case WM_COMMAND :
        {
            UINT uiID = MyWmCommandID( wParam, lParam );
            switch (uiID)
            {
                case ID_SCOPE_EDIT:
                {
                    if ( EN_KILLFOCUS == HIWORD(wParam) )
                    {
                        // Try to locate a matching catalog

                        GetDlgItemText( hdlg,
                                        ID_SCOPE_EDIT,
                                        scm.awcScope,
                                        MAX_PATH );

                        // only look for a cat if the scope changed

                        if ( 0 != wcscmp( scm.awcScope, awcScopeOrig ) )
                        {
                            CWaitCursor wait;

                            ULONG ccCat = sizeof(scm.awcCatalog)/sizeof(WCHAR);
                            ULONG ccMachine = sizeof(scm.awcMachine)/sizeof(WCHAR);
    
                            SCODE sc = LocateCatalogs( scm.awcScope,
                                                       0,
                                                       scm.awcMachine,
                                                       &ccMachine,
                                                       scm.awcCatalog,
                                                       &ccCat );
    
                            if ( S_OK == sc )
                            {
                                SetDlgItemText( hdlg, ID_SCOPE_CATALOG_EDIT, scm.awcCatalog );
                                SetDlgItemText( hdlg, ID_SCOPE_MACHINE_EDIT, scm.awcMachine );
                            }
                        }
                    }
                    break;
                }

                case ID_CATALOG_ADD:
                {
                    if ( VerifyCatalogInfo( hdlg, scm ) )
                    {
                        AddCatalogToList( hdlg, scm, TRUE );

                        SetDlgItemText( hdlg, ID_SCOPE_EDIT, L"" );
                        SetDlgItemText( hdlg, ID_SCOPE_CATALOG_EDIT, L"" );
                        SetDlgItemText( hdlg, ID_SCOPE_MACHINE_EDIT, L"" );

                        SetFocus( GetDlgItem( hdlg, ID_SCOPE_MACHINE_EDIT ) );
                    }
                    break;
                }

                case IDOK:
                {
                    XGrowable<WCHAR> *xCatList = reinterpret_cast<XGrowable<WCHAR> *>
                                                        (GetWindowLongPtr(hdlg, DWLP_USER));

                    GetDlgItemText( hdlg,
                                    ID_SCOPE_EDIT,
                                    scm.awcScope,
                                    MAX_PATH );

                    GetDlgItemText( hdlg,
                                    ID_SCOPE_CATALOG_EDIT,
                                    scm.awcCatalog,
                                    MAX_PATH );

                    GetDlgItemText( hdlg,
                                    ID_SCOPE_MACHINE_EDIT,
                                    scm.awcMachine,
                                    SRCH_COMPUTERNAME_LENGTH );

                    // We look at the edit fields only if user has entered some
                    // value and nothing has been added to the catalog list.
                    // If anything has been added to catalog list, then we
                    // only look at the list and ignore these fields

                    if ( ( scm.awcScope[0] || scm.awcCatalog[0] || scm.awcMachine[0] )
                         && 0 == GetCatalogListCount( hdlg ) )
                    {
                        if ( VerifyCatalogInfo( hdlg, scm ) )
                            AddCatalogToList( hdlg, scm, TRUE );
                        else
                            break;
                    }

                    CatListToString( hdlg, *xCatList );

                    if ( 0 == (*xCatList)[0] )
                    {
                        SearchError( hdlg,
                                     IDS_ERR_NO_CATALOG_SPECIFIED,
                                     L"" );
                        break;
                    }
                }
                    // fall through!
                case IDCANCEL:
                    EndDialog( hdlg, IDOK == uiID );
                    break;
            }
            break;
        }
    }

    return fRet;
} //ScopeDlgProc

static WNDPROC g_DlgWndProc = 0;
INT_PTR WINAPI DisplayPropsDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam );

void EnableOrDisableButtons(
    HWND hdlg,
    HWND hAvail,
    HWND hDisp )
{
    int iSelAvail = (int) SendMessage( hAvail, LB_GETCURSEL, 0, 0 );
    int iSelDisp = (int) SendMessage( hDisp, LB_GETCURSEL, 0, 0 );

    HWND hAdd = GetDlgItem( hdlg, ID_PROP_ADD );
    HWND hRemove = GetDlgItem( hdlg, ID_PROP_REMOVE );

    if ( iSelAvail == -1 && GetFocus() == hAdd )
        SetFocus( hAvail );

    if ( iSelDisp == -1 && GetFocus() == hRemove )
        SetFocus( hDisp );

    EnableWindow( hAdd, iSelAvail != -1 );
    EnableWindow( hRemove, iSelDisp != -1 );
} //EnableOrDisableButtons

LRESULT WINAPI DlgSubclassProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    static UINT msgDrag = RegisterWindowMessage( DRAGLISTMSGSTRING );
    static iDraggedItem;

    LRESULT lRet = 0;

    if ( msgDrag == msg )
    {
        HWND hAvail = GetDlgItem( hwnd, ID_PROP_AVAIL );
        HWND hDisp = GetDlgItem( hwnd, ID_PROP_DISP );
        DRAGLISTINFO *pInfo = (DRAGLISTINFO *) lParam;

        switch( pInfo->uNotification )
        {
            case DL_BEGINDRAG :
            {
                iDraggedItem = LBItemFromPt( pInfo->hWnd,
                                             pInfo->ptCursor, TRUE );
                lRet = TRUE;
                break;
            }
            case DL_DRAGGING :
            {
                int i = -1;
                HWND hDst = hDisp;

                if ( pInfo->hWnd == hAvail )
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                }
                else
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                    if ( -1 == i )
                    {
                        i = LBItemFromPt( hAvail, pInfo->ptCursor, TRUE );
                        hDst = hAvail;
                    }
                }

                DrawInsert( hwnd, hDst, i );
                if ( -1 == i )
                    lRet = DL_STOPCURSOR;
                else
                    lRet = DL_MOVECURSOR;
                break;
            }
            case DL_CANCELDRAG :
            {
                DrawInsert( hwnd, pInfo->hWnd, -1 );
                lRet = DL_CURSORSET;
                break;
            }
            case DL_DROPPED :
            {
                int i = -1;
                HWND hDst = hDisp;
                if ( pInfo->hWnd == hAvail )
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                }
                else
                {
                    i = LBItemFromPt( hDisp, pInfo->ptCursor, TRUE );
                    if ( -1 == i )
                    {
                        i = LBItemFromPt( hAvail, pInfo->ptCursor, TRUE );
                        hDst = hAvail;
                    }
                }

                if ( ( -1 != i && -1 != iDraggedItem ) &&
                     ( ! ( pInfo->hWnd == hDisp &&
                           hDst == hDisp &&
                           i == iDraggedItem ) ) )
                {
                    if ( hDst == hAvail )
                    {
                        // move displayed to avail
                        DisplayPropsDlgProc( hwnd,
                                             WM_COMMAND,
                                             (WPARAM) MAKELONG(ID_PROP_REMOVE,0),
                                             0 );
                    }
                    else if ( pInfo->hWnd == hAvail )
                    {
                        // move avail to displayed
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hAvail, LB_GETTEXT, iDraggedItem, (LPARAM) awcBuf );
                        SendMessage( hDisp, LB_INSERTSTRING, i, (LPARAM ) awcBuf );
                        SendMessage( hAvail, LB_DELETESTRING, iDraggedItem, 0 );
                    }
                    else
                    {
                        // reorder displayed items
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hDisp, LB_GETTEXT, iDraggedItem, (LPARAM) awcBuf );
                        SendMessage( hDisp, LB_INSERTSTRING, i, (LPARAM ) awcBuf );
                        if ( iDraggedItem > i )
                            iDraggedItem++;
                        SendMessage( hDisp, LB_DELETESTRING, iDraggedItem, 0 );
                    }
                }

                DrawInsert( hwnd, pInfo->hWnd, -1 );
                lRet = DL_CURSORSET;

                EnableOrDisableButtons( hwnd, hAvail, hDisp );
                break;
            }
        }

        return lRet;
    }

    if ( 0 != g_DlgWndProc )
        lRet = g_DlgWndProc( hwnd, msg, wParam, lParam );

    return lRet;
} //DlgSubclassProc

INT_PTR WINAPI DisplayPropsDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    // pointer to search control that will receive the new props
    // safe: can have one dlg up at a time!
    static CSearchControl *s_pControl = 0;

    BOOL fRet = FALSE;

    switch (msg)
    {
        case WM_INITDIALOG :
        {
            // subclass the dlgproc -- we need a window proc, not a dlgproc

            g_DlgWndProc = (WNDPROC) GetWindowLongPtr( hdlg, GWLP_WNDPROC );
            SetWindowLongPtr( hdlg, GWLP_WNDPROC, (LONG_PTR) DlgSubclassProc );

            // search control was passed as lParam

            s_pControl = (CSearchControl *) lParam;

            CColumnList & columns = s_pControl->GetColumnList();
            IColumnMapper & map = s_pControl->GetColumnMapper();

            // fill the displayed and available listboxes

            HWND hAvail = GetDlgItem( hdlg, ID_PROP_AVAIL );
            HWND hDisp = GetDlgItem( hdlg, ID_PROP_DISP );
            unsigned cDisp = columns.NumberOfColumns();

            MakeDragList( hAvail );
            MakeDragList( hDisp );

            ULONG iEntry = 0;
            WCHAR const *pwcName;
            DBID *pdbid;
            DBTYPE dbtype;
            unsigned int uiWidth;

            while ( SUCCEEDED( map.EnumPropInfo( iEntry,
                                                 &pwcName,
                                                 &pdbid,
                                                 &dbtype,
                                                 &uiWidth ) ) )
            {
                if ( 0 != uiWidth )
                {
                    XArray<WCHAR> xLower( 1 + wcslen( pwcName ) );
                    wcscpy( xLower.Get(), pwcName );
                    _wcslwr( xLower.Get() + 1 );

                    BOOL fIsDisp = FALSE;

                    for ( unsigned i = 0; i < cDisp; i++ )
                    {
                        if ( !_wcsicmp( xLower.Get(), columns.GetColumn( i ) ) )
                        {
                            fIsDisp = TRUE;
                            break;
                        }
                    }

                    if (!fIsDisp)
                        SendMessage( hAvail,
                                     LB_ADDSTRING,
                                     0,
                                     (LPARAM) xLower.Get() );
                }

                iEntry++;
            }

            for ( unsigned i = 0; i < cDisp; i++ )
                SendMessage( hDisp, LB_ADDSTRING, 0,
                             (LPARAM) columns.GetColumn( i ) );

            CenterDialog( hdlg );

            EnableOrDisableButtons( hdlg, hAvail, hDisp );
            fRet = FALSE;
            break;
        }

        case WM_COMMAND :
        {
            HWND hAvail = GetDlgItem( hdlg, ID_PROP_AVAIL );
            HWND hDisp = GetDlgItem( hdlg, ID_PROP_DISP );
            WORD cmd = MyWmCommandCmd( wParam, lParam );

            switch ( MyWmCommandID( wParam, lParam ) )
            {
                case ID_PROP_ADD :
                {
                    int iSelDisp = (int) SendMessage( hDisp, LB_GETCURSEL, 0, 0 );
                    int iSelAvail = (int) SendMessage( hAvail, LB_GETCURSEL, 0, 0 );

                    if ( LB_ERR != iSelAvail )
                    {
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hAvail, LB_GETTEXT, iSelAvail, (LPARAM) awcBuf );
                        SendMessage( hDisp,
                                     LB_INSERTSTRING,
                                     iSelDisp != LB_ERR ? iSelDisp : -1,
                                     (LPARAM ) awcBuf );
                        SendMessage( hAvail, LB_DELETESTRING, iSelAvail, 0 );
                    }

                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }

                case ID_PROP_REMOVE :
                {
                    int iSelDisp = (int) SendMessage( hDisp, LB_GETCURSEL, 0, 0 );

                    if ( LB_ERR != iSelDisp )
                    {
                        WCHAR awcBuf[ cwcBufSize ];
                        SendMessage( hDisp, LB_GETTEXT, iSelDisp, (LPARAM) awcBuf );
                        SendMessage( hAvail, LB_ADDSTRING, 0, (LPARAM ) awcBuf );
                        SendMessage( hDisp, LB_DELETESTRING, iSelDisp, 0 );
                    }

                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }
                case ID_PROP_AVAIL :
                {
                    if ( LBN_DBLCLK == cmd )
                        DisplayPropsDlgProc( hdlg,
                                             WM_COMMAND,
                                             (WPARAM) MAKELONG(ID_PROP_ADD,0),
                                             0 );
                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }
                case ID_PROP_DISP :
                {
                    if ( LBN_DBLCLK == cmd )
                        DisplayPropsDlgProc( hdlg,
                                             WM_COMMAND,
                                             (WPARAM) MAKELONG(ID_PROP_REMOVE,0),
                                             0 );

                    EnableOrDisableButtons( hdlg, hAvail, hDisp );
                    break;
                }
                case IDOK :
                {
                    HWND hDisp = GetDlgItem( hdlg, ID_PROP_DISP );
                    ULONG cDisp = (ULONG)SendMessage( hDisp, LB_GETCOUNT, 0, 0 );
                    WCHAR awcDisp[ cwcBufSize ];
                    awcDisp[0] = 0;

                    cDisp = __min( cDisp, maxBoundCols );

                    for ( unsigned i = 0; i < cDisp; i++ )
                    {
                        WCHAR awcBuf[ cwcBufSize ];

                        SendMessage( hDisp, LB_GETTEXT, i, (LPARAM) awcBuf );
                        if ( 0 != awcDisp[0] )
                            wcscat( awcDisp, L"," );
                        wcscat( awcDisp, awcBuf );
                    }

                    SetReg( CISEARCH_REG_DISPLAYPROPS, awcDisp );
                    s_pControl->SetupDisplayProps( awcDisp );
                    EndDialog( hdlg, TRUE );
                    break;
                }

                case ID_PROP_DEFAULT :
                {
                    WCHAR awcDisp[ cwcBufSize ];
                    wcscpy( awcDisp, DEFAULT_DISPLAYED_PROPERTIES );
                    SetReg( CISEARCH_REG_DISPLAYPROPS, awcDisp );
                    s_pControl->SetupDisplayProps( awcDisp );
                    EndDialog( hdlg, TRUE );
                    break;
                }

                case IDCANCEL :
                {
                    EndDialog( hdlg, FALSE );
                    break;
                }
            }
            break;
        }
    }

    return fRet;
} //DisplayPropsDlgProc

//
// Subclass window procedure for edit control
//

LRESULT WINAPI EditSubclassProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;
    HWND hParent = GetParent(GetParent(hwnd));

    if (0 != hParent)
    {
        CSearchControl *pControl = (CSearchControl *) GetWindowLongPtr (hParent, 0);

        if (0 != pControl)
            lRet = pControl->EditSubclassEvent(hwnd,msg,wParam,lParam);
    }

    return lRet;
} //EditSubclassProc

//
// Search Control
//

CSearchControl::CSearchControl(
    HWND    hwnd,
    WCHAR * pwcScope)
   :
#pragma warning(disable : 4355)
    _view( hwnd, *this, _columns ),
#pragma warning(default : 4355)
    _hInst( 0 ),
    _hwndSearch( hwnd ),
    _hwndQuery( 0 ),
    _hwndQueryTitle( 0 ),
    _hwndHeader( 0 ),
    _hwndList( 0 ),
    _lpOrgEditProc( 0 ),
    _pSearch( 0 ),
    _fDeep( TRUE )
{
    ISimpleCommandCreator & cmdCreator = *App.GetCommandCreator();
    XInterface<IColumnMapperCreator> xMapper;

    SCODE sc = cmdCreator.QueryInterface( IID_IColumnMapperCreator, xMapper.GetQIPointer() );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    sc = xMapper->GetColumnMapper( L".", L"SYSTEM", _xColumnMapper.GetPPointer() );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    SetWindowLongPtr( hwnd, 0, (LONG_PTR) this );

    _sort.SetSort( App.GetSortProp(), App.GetSortDir() );

    _lcid = App.GetLocale();
    _hInst = MyGetWindowInstance( _hwndSearch );

    _xCatList = App.CatalogList();

    // Get the first cat item
    GetCatListItem( App.CatalogList(), 0, _awcMachine, _awcCatalog, _awcScope, _fDeep );

    ResetTitle();

    InitPanes();
} //CSearchControl

LRESULT CSearchControl::wmActivate(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    if ( hwnd == (HWND) lParam )
    {
        SIZE size;
        {
            HDC hdc = GetDC( _hwndQueryTitle );

            if ( 0 != hdc )
            {
                CResString str( IDS_COUNTTITLE );
                GetTextExtentPoint32( hdc, str.Get(), wcslen( str.Get() ), &size );
                ReleaseDC( _hwndQueryTitle, hdc );
            }
        }

        int apos[] = { size.cx + 2, size.cx + 102, -1 };
        SendMessage( App.StatusBarWindow(),
                     SB_SETPARTS,
                     sizeof apos / sizeof apos[ 0 ],
                     (LPARAM) apos );
        _UpdateStatusWindow( L"", L"" );

        UINT cDisable = 2;
        static UINT aDisable[] = { IDM_PREVIOUS_HIT,
                                   IDM_NEXT_HIT,
                                   IDM_BROWSE, };
        UINT cEnable = 4;
        static UINT aEnable[] = { IDM_SEARCH,
                                  IDM_SEARCHCLASSDEF,
                                  IDM_SEARCHFUNCDEF,
                                  IDM_DISPLAY_PROPS,
                                  IDM_BROWSE };

        if ( ( 0 != _pSearch ) &&
             ( _pSearch->IsSelected() ) )
            cEnable++;
        else
            cDisable++;

        UpdateButtons( aDisable, cDisable, FALSE );
        UpdateButtons( aEnable, cEnable, TRUE );

        _UpdateCount();
    }

    return 0;
} //wmActivate

void CSearchControl::_UpdateStatusWindow(
    WCHAR const * pwcMsg,
    WCHAR const * pwcReliability )
{
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, SBT_OWNERDRAW | idStatusRatio, 0 );
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusMsg, (LPARAM) pwcMsg );
    SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusReliability, (LPARAM) pwcReliability );
} //_UpdateStatusWindow

LRESULT CSearchControl::wmRealDrawItem(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;

    if ( lpdis->hwndItem == App.StatusBarWindow() )
    {
        ULONG iPct = 0;
        if ( 0 != _pSearch )
            iPct = _pSearch->PctDone();

        RECT rc;
        CopyRect( &rc, &lpdis->rcItem );
        rc.right += iPct;
        FillRect( lpdis->hDC, &rc, App.BtnHiliteBrush() );
        CopyRect( &rc, &lpdis->rcItem );
        rc.left += iPct;
        FillRect( lpdis->hDC, &rc, App.BtnFaceBrush() );

        if ( 0 != _pSearch )
        {
            int iOldMode = SetBkMode( lpdis->hDC, TRANSPARENT );
            COLORREF crOld = SetTextColor( lpdis->hDC,
                                           GetSysColor( COLOR_BTNTEXT ) );

            WCHAR awc[40];

            if ( QUERY_FILL_STATUS( _pSearch->QueryStatus() ) == STAT_ERROR )
            {
                CResString strError( IDS_QUERYERROR );
                wcscpy( awc, strError.Get() );
            }
            else if ( _pSearch->MostlyDone() )
            {
                CResString strDone( IDS_QUERYDONE );
                wcscpy( awc, strDone.Get() );
            }
            else
                wsprintf( awc, L"%d%%", iPct );

            DrawText( lpdis->hDC, awc, wcslen( awc ), & lpdis->rcItem,
                      DT_SINGLELINE | DT_VCENTER | DT_CENTER );

            SetTextColor( lpdis->hDC, crOld );
            SetBkMode( lpdis->hDC, iOldMode );
        }
    }

    return 1;
} //wmRealDrawItem

LRESULT CSearchControl::wmColumnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
  HD_NOTIFY * pn = (HD_NOTIFY *) lParam;

  switch ( pn->hdr.code )
  {
      case HDN_ENDTRACK :
      {
          if ( (int) _view.ColumnWidth( pn->iItem ) != pn->pitem->cxy )
          {
              _view.SetColumnWidth( pn->iItem, pn->pitem->cxy );

              InvalidateRect( _hwndList, 0, TRUE );
          }
          break;
      }
      case HDN_DIVIDERDBLCLICK :
      {
          HD_ITEM hdi;
          hdi.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
          hdi.cxy = _view.SetDefColumnWidth( pn->iItem );
          hdi.pszText = (WCHAR *) _columns.GetColumn( pn->iItem );
          hdi.hbm = 0;
          hdi.cchTextMax = wcslen( hdi.pszText );
          hdi.fmt =  HDF_STRING | HDF_LEFT;
          hdi.lParam = 0;
          Header_SetItem( _hwndHeader, pn->iItem, &hdi );

          InvalidateRect( _hwndList, 0, TRUE );
          break;
      }
      case HDN_ITEMCLICK :
      {
          //BOOL fUp = ( 0 == ( 0x8000 & GetAsyncKeyState( VK_CONTROL ) ) );

          // invert the old sort order

          int dir = ( _sort.GetSortDir() == SORT_UP ) ? SORT_DOWN : SORT_UP;

          _sort.SetSort( _columns.GetColumn( pn->iItem ), dir );

          wcscpy( App.GetSortProp(), _columns.GetColumn( pn->iItem ) );
          App.GetSortDir() = dir;

          PostMessage ( _hwndSearch,
                        ::wmMenuCommand,
                        IDM_SEARCH,
                        MAKELPARAM( 1, 0 ) );
          break;
      }
  }

  return DefMDIChildProc( _hwndSearch, WM_NOTIFY, wParam, lParam );
} //wmColumnNotify

void CSearchControl::SetupDisplayProps(
    WCHAR *pwcProps )
{
    _columns.SetNumberOfColumns( 0 );

    WCHAR *pwc = pwcProps;
    unsigned iPos = 0;

    do
    {
        WCHAR *pwcStart = pwc;

        while ( *pwc && ',' != *pwc )
            pwc++;

        if ( ',' == *pwc )
        {
            *pwc = 0;
            pwc++;
        }

        if ( *pwcStart )
            _columns.SetColumn( pwcStart, iPos++ );
        else
            break;
    } while ( TRUE );

    // if the list is bad -- no props added, add the default props

    if ( 0 == iPos )
    {
        WCHAR awcProp[ cwcBufSize ];
        wcscpy( awcProp, DEFAULT_DISPLAYED_PROPERTIES );
        SetupDisplayProps( awcProp );
    }

    _view.ColumnsChanged();

    _AddColumnHeadings();

} //SetupDisplayProps

void CSearchControl::_AddColumnHeadings()
{
    // delete any existing column headers

    int cItems = Header_GetItemCount( _hwndHeader );
    for ( int i = 0; i < cItems; i++ )
        Header_DeleteItem( _hwndHeader, 0 );

    // add the current column headers

    HD_ITEM hdi;
    hdi.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
    hdi.hbm = 0;
    hdi.fmt =  HDF_STRING | HDF_LEFT;
    hdi.lParam = 0;

    for ( unsigned x = 0; x < _columns.NumberOfColumns(); x++ )
    {
        hdi.cxy = _view.ColumnWidth( x );
        hdi.pszText = (WCHAR *) _columns.GetColumn( x );
        hdi.cchTextMax = wcslen( hdi.pszText );
        Header_InsertItem( _hwndHeader, x, &hdi );
    }
} //_AddColumnHeadings

void CSearchControl::InitPanes ()
{
    // Query pane
    _hwndQuery = CreateWindow( L"COMBOBOX",
                               0,
                               WS_VSCROLL | CBS_AUTOHSCROLL | CBS_DROPDOWN | WS_CHILD | WS_BORDER | WS_TABSTOP | WS_GROUP,
                               0, 0, 0, 0,
                               _hwndSearch,
                               (HMENU) idQueryChild,
                               _hInst,
                               0 );

    // Get the edit field from the combobox
    // This is a hack, but I can't find any way of getting the
    // edit field from the combo box
    HWND hEdit = FindWindowEx( _hwndQuery, 0, L"EDIT", 0 );

    if ( 0 == hEdit )
        return;

    _lpOrgEditProc = (WNDPROC) GetWindowLongPtr( hEdit, GWLP_WNDPROC );
    SetWindowLongPtr( hEdit, GWLP_WNDPROC, (LONG_PTR) EditSubclassProc );

    _hLastToHaveFocus = _hwndQuery;

    // List View pane
    // to be replaced by ListView

    _hwndList = CreateWindow( LIST_VIEW_CLASS,
                              L"",
                              WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_GROUP |
                              WS_VSCROLL | WS_BORDER,
                              0, 0, 0, 0,
                              _hwndSearch,
                              (HMENU) idListChild,
                              _hInst,
                              0 );
    DWORD err;
    if (_hwndList == 0)
        err = GetLastError();


    const long styleStatic = SS_LEFT | WS_CHILD;
    CResString strQuery (IDS_QUERYTITLE);

    _hwndQueryTitle = CreateWindow( L"static",
                                    strQuery.Get(),
                                    styleStatic,
                                    0,0,0,0,
                                    _hwndSearch,
                                    (HMENU) idQueryTitle,
                                    _hInst,
                                    0 );

    _hwndHeader = CreateWindowEx( 0,
                                  WC_HEADER,
                                  0,
                                  WS_CHILD | WS_BORDER |
                                  HDS_HORZ | HDS_BUTTONS,
                                  0,0,0,0,
                                  _hwndSearch,
                                  (HMENU) idHeader,
                                  _hInst,
                                  0 );

    _view.InitPanes ( _hwndQueryTitle,
                      _hwndQuery,
                      _hwndList,
                      _hwndHeader );

    WCHAR awcDisplayProps[cwcBufSize];
    ULONG cb = sizeof awcDisplayProps;
    if ( !GetReg( CISEARCH_REG_DISPLAYPROPS, awcDisplayProps, &cb ) )
        wcscpy( awcDisplayProps, DEFAULT_DISPLAYED_PROPERTIES );

    SetupDisplayProps( awcDisplayProps );

    PostMessage( _hwndSearch, wmGiveFocus, 0, 0 );
} //InitPanes

CSearchControl::~CSearchControl()
{
    SetWindowLongPtr( _hwndSearch, 0, 0 );
    delete _pSearch;
} //~CSearchControl

LRESULT CSearchControl::wmListNotify(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    if (!_pSearch)
    {
        *(long *)lParam = -1;
        return LRESULT(FALSE);
    }

    BOOL f = (BOOL)_pSearch->ListNotify (hwnd, wParam, (long *)lParam);

    static UINT aItem[] = { IDM_BROWSE };
    UpdateButtons( aItem, 1, _pSearch->IsSelected() );

    return (LRESULT) f;
} //wmListNotify

//
// Edit control procedure
//

LRESULT CSearchControl::EditSubclassEvent(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    LRESULT lRet = 0;

    switch (msg)
    {
#if 0
        case WM_KEYDOWN :
        {
            if ( VK_UP == wParam )
                pwc = _history.Previous();
            else if ( VK_DOWN == wParam )
                pwc = _history.Next();

            else
                lRet = CallWindowProc( _lpOrgEditProc,
                                        hwnd, msg, wParam, lParam );

            if ( 0 != pwc )
            {
                SetWindowText( hwnd, pwc );
                MySendEMSetSel( hwnd, 0, (UINT) -1 );
            }
            break;
        }
#endif
        case WM_KEYUP :
        {
            if ( VK_ESCAPE == wParam )
            {
                if ( SendMessage( _hwndQuery, CB_GETDROPPEDSTATE, 0, 0 ) )
                {
                    SendMessage( _hwndQuery, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0 );
                }
            }
            lRet = CallWindowProc( _lpOrgEditProc, hwnd, msg, wParam, lParam );
            break;
        }

        case WM_CHAR :
        {
            if ( VK_RETURN == wParam || 11 == wParam )
            {
                // Handle 'enter' only if combobox list is closed. If it is open,
                // then we handle the selection message in wmCommand
                if ( FALSE == SendMessage( _hwndQuery, CB_GETDROPPEDSTATE, 0, 0 ) )
                {
                    SendMessage ( _hwndSearch,
                                  ::wmMenuCommand,
                                  IDM_SEARCH,
                                  MAKELPARAM( 1, 0 ) );
                    // swallow cr/lf
                    break;
                }
            }
            else
            {
                // Match the user entered string with the strings in the combobox
                // list box...

                lRet = CallWindowProc( _lpOrgEditProc, hwnd, msg, wParam, lParam );

                UINT uiLen = GetWindowTextLength( hwnd );

                if (0 != uiLen && VK_BACK != wParam )
                {
                    XGrowable<WCHAR> xBuf;
                    xBuf.SetSize( uiLen + 1 );

                    GetWindowText( hwnd, xBuf.Get(), uiLen + 1 );

                    int index = (int)SendMessage( _hwndQuery, CB_FINDSTRING, -1, (LPARAM) xBuf.Get() );

                    if ( CB_ERR != index)
                    {
                        unsigned uiFullLen = (unsigned)SendMessage( _hwndQuery, CB_GETLBTEXTLEN, index, 0 );
                        xBuf.SetSize( uiFullLen + 1 );

                        if ( CB_ERR != SendMessage( _hwndQuery,
                                                    CB_GETLBTEXT,
                                                    index,
                                                    (LPARAM) xBuf.Get() ) )

                        {
                            SetWindowText( hwnd, xBuf.Get() );
                            MySendEMSetSel( hwnd, uiLen, (UINT) -1 );
                        }
                    }
                }
                break;
            }

            // no break, fall through!
        }
        default :
          lRet = CallWindowProc( _lpOrgEditProc, hwnd, msg, wParam, lParam );
          break;
    }

    return lRet;
} //EditSubclassEvent

LRESULT CSearchControl::wmSize(
    WPARAM wParam,
    LPARAM lParam )
{
    // no need to do this since User doesn't have the repaint bug with
    // comboboxes that it does with edit controls

    //if (_hwndQuery)
    //    InvalidateRect(_hwndQuery, 0, TRUE);

    LRESULT lr = DefMDIChildProc(_hwndSearch, WM_SIZE, wParam, lParam);

    if ( _hwndQuery )
        _view.Size( LOWORD (lParam), HIWORD (lParam));

    return lr;
} //wmSize

LRESULT CSearchControl::wmDisplaySubwindows(
    WPARAM wParam,
    LPARAM lParam )
{
    ShowWindow(_hwndQuery,SW_SHOW);
    ShowWindow(_hwndList,SW_SHOW);
    ShowWindow(_hwndQueryTitle,SW_SHOW);
    ShowWindow(_hwndHeader,SW_SHOW);
    return 0;
} //wmDisplaySubwindows

LRESULT CSearchControl::wmContextMenu(
    HWND   hwnd,
    WPARAM wParam,
    LPARAM lParam )
{
    POINT pt;
    pt.x = LOWORD( lParam );
    pt.y = HIWORD( lParam );

    GetCursorPos( &pt );

    RECT rc;
    GetWindowRect( _hwndHeader, &rc );

    WCHAR *pwcMenu = L"bogus";

    // is the click over the properties header?

    if ( PtInRect( &rc, pt ) )
    {
        pwcMenu = L"HeaderContextMenu";
    }
    else
    {
        // do hit testing on listview -- on a hit?

        int iHit = (int) SendMessage( _hwndList,
                                      wmContextMenuHitTest,
                                      0,
                                      MAKELPARAM( pt.x, pt.y ) );

        if ( -1 != iHit )
            pwcMenu = L"ResultsContextMenu";
    }

    HMENU hMenu = LoadMenu( App.Instance(), pwcMenu );

    if ( 0 != hMenu )
    {
        HMENU hTrackMenu = GetSubMenu( hMenu, 0 );
        if ( 0 != hTrackMenu )
        {
            if ( !wcscmp( pwcMenu, L"ResultsContextMenu" ) )
                SetMenuDefaultItem( hTrackMenu, IDM_BROWSE, FALSE );

            // yes, the function returns a BOOL that you switch on

            BOOL b = TrackPopupMenuEx( hTrackMenu,
                                       TPM_LEFTALIGN | TPM_RIGHTBUTTON |
                                           TPM_RETURNCMD,
                                       pt.x,
                                       pt.y,
                                       hwnd,
                                       0 );
            switch ( b )
            {
                case IDM_EDITCOPY :
                case IDM_EDITCOPYALL :
                case IDM_DISPLAY_PROPS :
                {
                    wmMenuCommand( b, 0 );
                    break;
                }
                case IDM_BROWSE :
                {
                    _DoBrowse( fileBrowse );
                    break;
                }
                case IDM_BROWSE_OPEN :
                {
                    _DoBrowse( fileOpen );
                    break;
                }
                case IDM_BROWSE_EDIT :
                {
                    _DoBrowse( fileEdit );
                    break;
                }
            }
        }

        DestroyMenu( hMenu );
    }

    return 0;
} //wmContextMenu

void CSearchControl::_DoBrowse(
    enumViewFile eViewType )
{
    if (_pSearch)
    {
        CWaitCursor curWait;
        TRY
        {
            BOOL fIsZoomed = IsZoomed( _hwndSearch );
            BOOL fOK = _pSearch->Browse( eViewType );

            if ( !fOK && fIsZoomed )
            {
                App.ZoomMDI( _hwndSearch );
                InvalidateRect( _hwndSearch, NULL, TRUE );
            }
        }
        CATCH (CException, e)
        {
        }
        END_CATCH;
    }
} //_DoBrowse

LRESULT CSearchControl::wmCommand(
    WPARAM wParam,
    LPARAM lParam )
{
    UINT uiID = MyWmCommandID( wParam, lParam );
    HWND hCtl = MyWmCommandHWnd( wParam, lParam );
    UINT uiCmd = MyWmCommandCmd( wParam, lParam );

    switch (uiID)
    {
        case idQueryChild :
            switch (uiCmd)
            {
                case CBN_SETFOCUS:
                  _hLastToHaveFocus = _hwndQuery;
                  break;

                case CBN_SELENDOK :
                    PostMessage ( _hwndSearch,
                                  ::wmMenuCommand,
                                  IDM_SEARCH,
                                  MAKELPARAM( 1, 0 ) );
                    break;

                case CBN_DROPDOWN:
                    // This list is getting dropped
                    // Set its size
                    _view.ResizeQueryCB();
                    break;
            }
            break;
        case idListChild :
            switch (uiCmd)
            {
                case LBN_SETFOCUS :
                    _hLastToHaveFocus = _hwndList;
                    break;
                case LBN_DBLCLK :
                {
                    BOOL fCtrl = ( 0 != ( 0x8000 & GetAsyncKeyState( VK_CONTROL ) ) );
                    _DoBrowse( fCtrl ? fileOpen : fileBrowse );
                    break;
                }
            }
            break;
    }

    return 0;
} //wmCommand

LRESULT CSearchControl::wmAccelerator(
    WPARAM wParam,
    LPARAM lParam)
{
    switch (wParam)
    {
        case ACC_ALTQ :
          SetFocus(_hwndQuery);
          break;
        case ACC_ALTR :
          SetFocus(_hwndList);
          break;
        case ACC_TAB :
        case ACC_SHIFTTAB :
          if (_hLastToHaveFocus == _hwndQuery)
              SetFocus(_hwndList);
          else
              SetFocus(_hwndQuery);
          break;
    }

    return 0;
} //wmAccelerator

LRESULT CSearchControl::wmNewFont(
    WPARAM wParam,
    LPARAM lParam)
{
    HFONT hfontNew = (HFONT) wParam;

    _view.FontChanged (hfontNew);

    WCHAR awcDisplayProps[cwcBufSize];
    ULONG cb = sizeof awcDisplayProps;
    if ( !GetReg( CISEARCH_REG_DISPLAYPROPS, awcDisplayProps, &cb ) )
        wcscpy( awcDisplayProps, DEFAULT_DISPLAYED_PROPERTIES );
    SetupDisplayProps( awcDisplayProps );

    SendMessage( _hwndList, WM_SETFONT, (WPARAM) hfontNew, 1L );

    SendMessage( _hwndQuery, WM_SETFONT, (WPARAM) hfontNew, 1L );

    RECT rc;
    GetClientRect( _hwndSearch, &rc );

    _view.Size( rc.right - rc.left, rc.bottom - rc.top );

    return 0;
} //wmNewFont

LRESULT CSearchControl::wmDrawItem(
    WPARAM wParam,
    LPARAM lParam)
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;

    if (lpdis->hwndItem == _hwndList)
    {
        if (lpdis->itemID == (UINT) -1)
            lpdis->itemAction = ODA_FOCUS;

        if ( lpdis->itemAction & ODA_DRAWENTIRE )
        {
            if ( _pSearch && _pSearch->IsSelected( lpdis->itemID ) )
                lpdis->itemState |= ODS_SELECTED;

            RECT rc;
            _view.PrimeItem( lpdis, rc );

            //if ( lpdis->itemState & ( ODS_SELECTED | ODS_FOCUS ) )
            //    DrawFocusRect( lpdis->hDC, &rc );

            if ( 0 != _pSearch )
                _view.PaintItem(  _pSearch,
                                  lpdis->hDC,
                                  rc,
                                  lpdis->itemID );
        }
    }

    return 1;
} //wmDrawItem

LRESULT CSearchControl::wmAppClosing(
    WPARAM wParam,
    LPARAM lParam )
{
    SendMessage( _hwndSearch, ::wmMenuCommand, IDM_NEWSEARCH, 0 );

    return 0;
} //wmAppClosing

void CSearchControl::ResetTitle()
{
    SScopeCatalogMachine scm;


    XGrowable<WCHAR> xTitle;
    xTitle.SetSize( wcslen(_xCatList.Get()) + 50 );
    xTitle[0] = 0;

    unsigned ii;
    for ( ii = 0; ; ii++ )
    {
        if ( ! GetCatListItem( _xCatList,
                               ii,
                               scm.awcMachine,
                               scm.awcCatalog,
                               scm.awcScope,
                               scm.fDeep ) )
        {
            break;
        }

        if ( ii > 0 )
        {
            wcscat( xTitle.Get(), L", " );
        }

        if ( scm.awcMachine[0] != L'.' )
        {
            wcscat( xTitle.Get(), scm.awcMachine );
            wcscat( xTitle.Get(), L" " );
        }

        wcscat( xTitle.Get(), scm.awcCatalog );
        wcscat( xTitle.Get(), L" " );
        wcscat( xTitle.Get(), scm.awcScope );
    }

    SetWindowText( _hwndSearch, xTitle.Get() );
} //ResetTitle

//+-------------------------------------------------------------------------
//
//  Function:   MyForceMasterMerge
//
//  Synopsis:   Forces a master merge on the catalog
//
//  Arguments:  [pwcCatalog] - Catalog name
//              [pwcMachine] - Machine on which catalog resides
//
//--------------------------------------------------------------------------

HRESULT MyForceMasterMerge(
    WCHAR const * pwcCatalog,
    WCHAR const * pwcMachine )
{
    // Create the main Indexing Service administration object.

    CLSID clsid;
    HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
    if ( FAILED( hr ) )
        return hr;

    XInterface<IAdminIndexServer> xAdmin;
    hr = CoCreateInstance( clsid,
                           0,
                           CLSCTX_INPROC_SERVER,
                           __uuidof(IAdminIndexServer),
                           xAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Set the machine name.

    BSTR bstrMachine = SysAllocString( pwcMachine );
    if ( 0 == bstrMachine )
        return E_OUTOFMEMORY;

    XBStr xbstr( bstrMachine );
    hr = xAdmin->put_MachineName( bstrMachine );
    if ( FAILED( hr ) )
        return hr;

    // Get a catalog administration object.

    BSTR bstrCatalog = SysAllocString( pwcCatalog );
    if ( 0 == bstrCatalog )
        return E_OUTOFMEMORY;

    xbstr.Free();
    xbstr.Set( bstrCatalog );
    XInterface<ICatAdm> xCatAdmin;
    hr = xAdmin->GetCatalogByName( bstrCatalog,
                                   (IDispatch **) xCatAdmin.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Force the merge.

    return xCatAdmin->ForceMasterMerge();
} //MyForceMasterMerge

LRESULT CSearchControl::wmMenuCommand(
    WPARAM wParam,
    LPARAM lParam )
{
    switch (wParam)
    {
        case IDM_EDITCOPY :
            if ( ( 0 != _hwndList ) &&
                 ( _hwndList == GetFocus() ) &&
                 ( 0 != _pSearch ) &&
                 ( _pSearch->IsSelected() ) )
            {
                WCHAR *pwcPath;
                HROW hrow;

                if ( _pSearch->GetSelectedRowData( pwcPath, hrow ) )
                {
                    PutInClipboard( pwcPath );
                    _pSearch->FreeSelectedRowData( hrow );
                }
            }

            break;

        case IDM_SCOPE_AND_DEPTH:
        {
            if ( DoModalDialog( ScopeDlgProc,
                                _hwndSearch,
                                L"ScopeBox",
                                (LPARAM) &_xCatList ) )
            {
                // Get the first cat list item
                GetCatListItem( _xCatList, 0, _awcMachine, _awcCatalog, _awcScope, _fDeep );

                SendMessage(_hwndSearch,
                            ::wmMenuCommand,
                            IDM_SEARCH,
                            MAKELPARAM (1,0));
            }
            break;
        }
        case IDM_DISPLAY_PROPS:
            if ( DoModalDialog( DisplayPropsDlgProc,
                                _hwndSearch,
                                L"DisplayPropsBox",
                                (LPARAM) this ) )
            {
                SendMessage(_hwndSearch,
                            ::wmMenuCommand,
                            IDM_SEARCH,
                            MAKELPARAM (1,0));
            }
            break;

        case IDM_EDITCOPYALL :
            if (0 != _pSearch)
            {
                CWaitCursor curWait;
                _pSearch->WriteResults();
            }
            break;
        case IDM_BROWSE:
            MyPostWmCommand(_hwndSearch, idListChild, _hwndSearch, LBN_DBLCLK);
            break;

        case IDM_LIMIT_10:
            App.Limit() = 10;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_LIMIT_300:
            App.Limit() = 300;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_LIMIT_NONE:
            App.Limit() = 0;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_FIRSTROWS_5:
            App.FirstRows() = 5;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_FIRSTROWS_15:
            App.FirstRows() = 15;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;
        case IDM_FIRSTROWS_NONE:
            App.FirstRows() = 0;
            SendMessage( _hwndSearch,
                         ::wmMenuCommand,
                         IDM_SEARCH,
                         MAKELPARAM( 1, 0 ) );
            break;

        case IDM_DIALECT_1:
        case IDM_DIALECT_2:
            if ( wParam == IDM_DIALECT_1 )
                App.Dialect() = ISQLANG_V1;
            else
                App.Dialect() = ISQLANG_V2;
            break;

        case IDM_DIALECT_3:
            App.Dialect() = SQLTEXT;
            break;

        case IDM_LOCALE_NEUTRAL:
        case IDM_LOCALE_CHINESE_TRADITIONAL:
        case IDM_LOCALE_CHINESE_SIMPLIFIED:
        case IDM_LOCALE_CHINESE_HONGKONG:
        case IDM_LOCALE_CHINESE_SINGAPORE:
        case IDM_LOCALE_CHINESE_MACAU:
        case IDM_LOCALE_DUTCH_DUTCH:
        case IDM_LOCALE_ENGLISH_CAN:
        case IDM_LOCALE_ENGLISH_US:
        case IDM_LOCALE_ENGLISH_UK:
        case IDM_LOCALE_FINNISH_DEFAULT:
        case IDM_LOCALE_FARSI_DEFAULT:
        case IDM_LOCALE_FRENCH_FRENCH:
        case IDM_LOCALE_FRENCH_CANADIAN:
        case IDM_LOCALE_GERMAN_GERMAN:
        case IDM_LOCALE_GREEK_DEFAULT:
        case IDM_LOCALE_HEBREW_DEFAULT:
        case IDM_LOCALE_HINDI_DEFAULT:
        case IDM_LOCALE_ITALIAN_ITALIAN:
        case IDM_LOCALE_JAPANESE_DEFAULT:
        case IDM_LOCALE_KOREAN_KOREAN:
//        case IDM_LOCALE_KOREAN_JOHAB:
        case IDM_LOCALE_POLISH_DEFAULT:
        case IDM_LOCALE_ROMANIAN_DEFAULT:
        case IDM_LOCALE_RUSSIAN_DEFAULT:
        case IDM_LOCALE_SPANISH_CASTILIAN:
        case IDM_LOCALE_SPANISH_MEXICAN:
        case IDM_LOCALE_SPANISH_MODERN:
        case IDM_LOCALE_SWAHILI_DEFAULT:
        case IDM_LOCALE_SWEDISH_DEFAULT:
        case IDM_LOCALE_THAI_DEFAULT:
        case IDM_LOCALE_TURKISH_DEFAULT:
        case IDM_LOCALE_UKRAINIAN_DEFAULT:
        case IDM_LOCALE_VIETNAMESE_DEFAULT:
        {
            for ( ULONG i = 0; i < cLocaleEntries; i++ )
            {
                if ( wParam == aLocaleEntries[ i ].iMenuOption )
                {
                    _lcid = aLocaleEntries[ i ].lcid;
                    App.SetLocale( _lcid );
                    break;
                }
            }
            break;
        }

        case IDM_FORCE_USE_CI :
        {
            BOOL fTmp = App.ForceUseCI();
            App.ForceUseCI() = !fTmp;
            break;
        }
        case IDM_CATALOG_STATUS:
            // what about distributed queries?  They aren't supported

            CreateDialogParam( _hInst,
                               L"CatalogStatusBox",
                               App.AppWindow(),
                               StatusDlgProc,
                               (LPARAM) this );
            break;
        case IDM_MASTER_MERGE:
        {
            // what about distributed queries?
            SCODE sc = MyForceMasterMerge( CatalogOrNull(),
                                           Machine() );
            if ( FAILED( sc ) )
            {
                WCHAR awcError[MAX_PATH];
                FormatSrchError( sc, awcError, _lcid );
                MessageBox( _hwndSearch,
                            awcError,
                            _awcScope,
                            MB_OK|MB_ICONEXCLAMATION );
            }
            break;
        }
        case IDM_SEARCH :
        case IDM_SEARCHCLASSDEF :
        case IDM_SEARCHFUNCDEF :
        {
            CWaitCursor curWait;

            // Scope change invokes a new query, so make sure title bar is ok
            ResetTitle();

            CSearchQuery *ptmp = _pSearch;
            _pSearch = 0;

            // Let the user know we're doing something
            {
                CResString strHitCount(IDS_COUNTEND);
                _UpdateStatusWindow( strHitCount.Get(), L"" );
                UpdateWindow( App.StatusBarWindow() );
            }

            SendMessage( _hwndList, wmResetContents, 0, 0 );
            delete ptmp;

            static UINT aItem[] = { IDM_BROWSE };
            UpdateButtons( aItem, 1, FALSE );

            // Let the user know we're doing something
            {
                CResString strHitCount(IDS_COUNTSTART);
                _UpdateStatusWindow( strHitCount.Get(), L"" );
                UpdateWindow( App.StatusBarWindow() );
            }

            HWND hEdit = FindWindowEx( _hwndQuery, 0, L"EDIT", 0 );

            UINT uiLen = GetWindowTextLength(hEdit);

            if (0 == uiLen)
            {
                CResString strCount (IDS_COUNTTITLE);
                SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusMsg, (LPARAM) strCount.Get() );
            }
            else
            {
                WCHAR * pwcBuf = new WCHAR [uiLen + 1];

                TRY
                {
                    GetWindowText (hEdit, pwcBuf, uiLen + 1);

                    ESearchType st = srchNormal;

                    if (IDM_SEARCHCLASSDEF == wParam)
                        st = srchClass;
                    else if (IDM_SEARCHFUNCDEF == wParam)
                        st = srchFunction;

                    //----------
                    // NEW QUERY
                    //----------

                    _pSearch = new CSearchQuery( _xCatList,
                                                 pwcBuf,
                                                 _hwndSearch,
                                                 _view.Lines(),
                                                 _lcid,
                                                 st,
                                                 _xColumnMapper.GetReference(),
                                                 _columns,
                                                 _sort,
                                                 App.Dialect(),
                                                 App.Limit(),
                                                 App.FirstRows() );
                    _pSearch->InitNotifications(_hwndList);

                    // Scope may have changed if server was down
                    ResetTitle();

                    // Let the user know we're doing something
                    {
                        WCHAR awcCount[100];
                        CResString strHitCount(IDS_HITCOUNT);
                        swprintf( awcCount, strHitCount.Get(), 0, 0.0f );
                        SendMessage( App.StatusBarWindow(), SB_SETTEXT, SBT_OWNERDRAW | idStatusRatio, 0 );
                        SendMessage( App.StatusBarWindow(), SB_SETTEXT, idStatusMsg, (LPARAM) awcCount );
                        UpdateWindow( App.StatusBarWindow() );
                    }

                    MySendEMSetSel( hEdit, 0, (UINT) -1 );

                    if ( CB_ERR == SendMessage( _hwndQuery, CB_FINDSTRINGEXACT, -1, (LPARAM) pwcBuf ) )
                    {
                        SendMessage( _hwndQuery, CB_INSERTSTRING, 0, (LPARAM) pwcBuf );
                    }

                    //_history.Add( pwcBuf );

                    delete [] pwcBuf;
                    pwcBuf = 0;
                }
                CATCH (CException, e )
                {
                    SCODE sc = e.GetErrorCode();
                    if ( 0 == _pSearch )
                    {
                        // check for version mismatch, otherwise just report
                        // the error

                        if ( STATUS_INVALID_PARAMETER_MIX == sc )
                        {
                            SearchError( _hwndSearch,
                                         IDS_ERR_BAD_VERSION,
                                         _awcScope );
                        }
                        else  // if ( QUERY_E_ALLNOISE != sc )
                        {
                            WCHAR awcError[MAX_PATH];
                            FormatSrchError( sc, awcError, _lcid );
                            CResString strErr( IDS_ERR_QUERY_ERROR );
                            WCHAR awcMsg[MAX_PATH];
                            swprintf( awcMsg, strErr.Get(), awcError );
                            MessageBox( _hwndSearch,
                                        awcMsg,
                                        _awcScope,
                                        MB_OK|MB_ICONEXCLAMATION );
                        }
                    }
                    else
                    {
                        delete _pSearch;
                        _pSearch = 0;
                    }

                    delete [] pwcBuf;

                    CResString strCount (IDS_COUNTTITLE);
                    SendMessage( App.StatusBarWindow(), SB_SETTEXT,
                                 idStatusMsg, (LPARAM) strCount.Get() );
                }
                END_CATCH;
            }
        }
        break;
        case IDM_NEWSEARCH :
        {
            CWaitCursor curWait;

            CSearchQuery *ptmp = _pSearch;
            _pSearch = 0;

            // Let the user know we're doing something
            {
                CResString strHitCount(IDS_COUNTEND);
                _UpdateStatusWindow( strHitCount.Get(), L"" );
                UpdateWindow( App.StatusBarWindow() );
            }

            delete ptmp;

            static UINT aItem[] = { IDM_BROWSE };
            UpdateButtons( aItem, 1, FALSE );

            ResetTitle();

            CResString strCount (IDS_COUNTTITLE);
            _UpdateStatusWindow( strCount.Get(), L"" );

            SetWindowText( _hwndQuery, L"") ;
            SendMessage( _hwndList, wmResetContents, 0, 0 );
            SetFocus( _hwndQuery );
        }
        break;
    }

    return 0;
} //wmMenuCommand

LRESULT CSearchControl::wmSetFocus(
    WPARAM wParam,
    LPARAM lParam )
{
    if (0 != _hLastToHaveFocus)
        SetFocus(_hLastToHaveFocus);

    return 0;
} //wmSetFocus

LRESULT CSearchControl::wmClose(
    WPARAM wParam,
    LPARAM lParam )
{
    SendMessage( _hwndSearch, ::wmMenuCommand, IDM_NEWSEARCH, 0 );

    return 0;
} //wmClose

void _CheckReliability(
    DWORD   dwStatus,
    DWORD   bit,
    UINT    msg,
    WCHAR * pwcMsg )
{
    if ( QUERY_RELIABILITY_STATUS( dwStatus ) & bit )
    {
        CResString str( msg );
        if ( 0 != pwcMsg[ 0 ] )
            wcscat( pwcMsg, L" / " );
        wcscat( pwcMsg, str.Get() );
    }
} //_CheckReliability

void CSearchControl::_UpdateCount()
{
    if ( _hwndSearch == App.GetActiveMDI() )
    {
        WCHAR awcCount[200];
        CResString strHitCount;
        WCHAR awcReliability[MAX_PATH];
        awcReliability[ 0 ] = 0;

        DWORD dwStatus = 0;

        if ( _pSearch )
        {
            strHitCount.Load( IDS_HITCOUNT );

            swprintf( awcCount,
                      strHitCount.Get(),
                      _pSearch->RowCount(),
                      (float) _pSearch->QueryTime() );

            dwStatus = _pSearch->QueryStatus();

            if ( 0 != _pSearch->LastError() )
            {
                FormatSrchError( _pSearch->LastError(), awcReliability, _lcid );
            }
            else
            {
                _CheckReliability( dwStatus,
                                   STAT_CONTENT_OUT_OF_DATE,
                                   IDS_RELIABILITY_OUTOFDATE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_NOISE_WORDS,
                                   IDS_RELIABILITY_NOISE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_PARTIAL_SCOPE,
                                   IDS_RELIABILITY_PARTIAL,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_REFRESH_INCOMPLETE,
                                   IDS_RELIABILITY_REFRESH_INCOMPLETE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_CONTENT_QUERY_INCOMPLETE,
                                   IDS_RELIABILITY_CONTENT_QUERY_INCOMPLETE,
                                   awcReliability );

                _CheckReliability( dwStatus,
                                   STAT_TIME_LIMIT_EXCEEDED,
                                   IDS_RELIABILITY_TIME_LIMIT_EXCEEDED,
                                   awcReliability );
            }
        }
        else
        {
            CResString strCount( IDS_COUNTTITLE );
            wcscpy( awcCount, strCount.Get() );
        }

        _UpdateStatusWindow( awcCount, awcReliability );
        UpdateWindow( App.StatusBarWindow() );
    }
} //_UpdateCount

LRESULT CSearchControl::wmNotification(
    WPARAM wParam,
    LPARAM lParam)
{
    if (0 != _pSearch)
    {
        _pSearch->ProcessNotification( _hwndList,
                                       DBWATCHNOTIFY(wParam),
                                       (IRowset*)lParam);

        BOOL fMore;
        _pSearch->UpdateProgress( fMore );
        PostMessage( _hwndList, wmSetCountBefore, 0,
                     (LPARAM)_pSearch->RowCurrent() );
        PostMessage( _hwndList, wmSetCount, 0,
                     (LPARAM)_pSearch->RowCount() );
        _UpdateCount();

        _pSearch->ProcessNotificationComplete();
    }

    return 0;
} //wmNotification

LRESULT CSearchControl::wmInitMenu(
    WPARAM wParam,
    LPARAM lParam)
{
    HMENU hmenu = (HMENU) wParam;

    for ( ULONG i = 0; i < cLocaleEntries; i++ )
    {
        DWORD option = aLocaleEntries[ i ].iMenuOption;
        EnableMenuItem( hmenu, option, MF_ENABLED );

        LCID lcid = aLocaleEntries[ i ].lcid;
        CheckMenuItem( hmenu,
                       option,
                       _lcid == lcid ? MF_CHECKED : MF_UNCHECKED );
    }
    EnableMenuItem(hmenu,IDM_SEARCH,MF_ENABLED);

    if ( SQLTEXT == App.Dialect() )
    {
        EnableMenuItem( hmenu, IDM_SEARCHCLASSDEF, MF_GRAYED );
        EnableMenuItem( hmenu, IDM_SEARCHFUNCDEF, MF_GRAYED );
    }
    else
    {
        EnableMenuItem( hmenu, IDM_SEARCHCLASSDEF, MF_ENABLED );
        EnableMenuItem( hmenu, IDM_SEARCHFUNCDEF, MF_ENABLED);
    }

    EnableMenuItem(hmenu,IDM_NEWSEARCH,MF_ENABLED);
    EnableMenuItem(hmenu,IDM_SCOPE_AND_DEPTH,MF_ENABLED);
    EnableMenuItem(hmenu,IDM_FILTER_SCOPE,MF_ENABLED);

    EnableMenuItem(hmenu,IDM_DISPLAY_PROPS,MF_ENABLED);

    EnableMenuItem(hmenu, IDM_FORCE_USE_CI, MF_ENABLED);
    CheckMenuItem(hmenu, IDM_FORCE_USE_CI, App.ForceUseCI() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem( hmenu, IDM_DIALECT_1, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_DIALECT_2, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_DIALECT_3, MF_ENABLED );
    CheckMenuItem( hmenu, IDM_DIALECT_1, ISQLANG_V1 == App.Dialect() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_DIALECT_2, ISQLANG_V2 == App.Dialect() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_DIALECT_3, SQLTEXT == App.Dialect() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem( hmenu, IDM_LIMIT_10, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_LIMIT_300, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_LIMIT_NONE, MF_ENABLED );
    CheckMenuItem( hmenu, IDM_LIMIT_10, 10 == App.Limit() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_LIMIT_300, 300 == App.Limit() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_LIMIT_NONE, 0 == App.Limit() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem( hmenu, IDM_FIRSTROWS_5, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_FIRSTROWS_15, MF_ENABLED );
    EnableMenuItem( hmenu, IDM_FIRSTROWS_NONE, MF_ENABLED );
    CheckMenuItem( hmenu, IDM_FIRSTROWS_5, 5 == App.FirstRows() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_FIRSTROWS_15, 15 == App.FirstRows() ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hmenu, IDM_FIRSTROWS_NONE, 0 == App.FirstRows() ? MF_CHECKED : MF_UNCHECKED );

    EnableMenuItem(hmenu,IDM_CATALOG_STATUS,MF_ENABLED);
    EnableMenuItem(hmenu,IDM_MASTER_MERGE,MF_ENABLED);

    if ( 0 != _hwndList && _hwndList == GetFocus() )
    {
        if (0 != _pSearch && _pSearch->IsSelected())
        {
            EnableMenuItem( hmenu, IDM_BROWSE, MF_ENABLED );
            EnableMenuItem( hmenu, IDM_EDITCOPY, MF_ENABLED );
        }
    }

    if ( 0 != _pSearch && 0 != _pSearch->RowCount() )
        EnableMenuItem( hmenu, IDM_EDITCOPYALL, MF_ENABLED );

    return 0;
} //wmInitMenu

LRESULT CSearchControl::wmMeasureItem(
    WPARAM wParam,
    LPARAM lParam)
{
    MEASUREITEMSTRUCT* lpmis = (MEASUREITEMSTRUCT*) lParam;

    if (lpmis->CtlType == odtListView)
        lpmis->itemHeight = _view.GetLineHeight();

    return 0;
} //wmMeasureItem

void SStatusDlg::SetCaption()
{
    CResString str( IDS_STATUS_CAPTION );
    WCHAR awc[ MAX_PATH + 100 ];
    WCHAR *pwcCat = _CatalogOrNull();
    WCHAR *pwcScope = _Scope();
    WCHAR *pwcMachine = _Machine();
    WCHAR awcM[ SRCH_COMPUTERNAME_LENGTH + 2 ];
    if ( L'.' == *pwcMachine )
        awcM[0] = 0;
    else
    {
        awcM[0] = ' ';
        wcscpy( awcM+1, pwcMachine );
    }
    wsprintf( awc, str.Get(), awcM, pwcCat ? pwcCat : pwcScope );
    SetWindowText( _hdlg, awc );
} //SetCaption

const DWORD ALL_CI_MERGE = ( CI_STATE_SHADOW_MERGE |
                             CI_STATE_ANNEALING_MERGE |
                             CI_STATE_MASTER_MERGE |
                             CI_STATE_MASTER_MERGE_PAUSED );

void SStatusDlg::Update()
{
    CI_STATE state;
    RtlZeroMemory( &state, sizeof state );
    state.cbStruct = sizeof state;

    SCODE sc = CIState( _CatalogOrNull(),
                        _Machine(),
                        & state );

    if ( SUCCEEDED( sc ) )
    {
        SetDlgItemInt( _hdlg, ID_STAT_FTF,   state.cDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_SECQ,  state.cSecQDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_FF,    state.cFilteredDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_FTE,   state.cFreshTest, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_WL,    state.cWordList, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_PI,    state.cPersistentIndex, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_KEYS,  state.cUniqueKeys, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_FILES, state.cTotalDocuments, FALSE );
        SetDlgItemInt( _hdlg, ID_STAT_Q,     state.cQueries, FALSE );

        if ( 0 != ( state.eState & CI_STATE_SCANNING ) )
        {
            WCHAR awcTmp[50];
            swprintf( awcTmp, L"%ws: %d", App.GetYes(), state.cPendingScans );
            SetDlgItemText( _hdlg, ID_STAT_SCANNING, awcTmp );
        }
        else
        {
            SetDlgItemText( _hdlg, ID_STAT_SCANNING, App.GetNo() );
        }

        unsigned idStatus = IDS_CI_STATE_OK;

        if ( 0 != ( state.eState & CI_STATE_RECOVERING ) )
            idStatus = IDS_CI_STATE_RECOVER;
        else if ( 0 != ( state.eState & CI_STATE_HIGH_IO ) )
            idStatus = IDS_CI_STATE_HIIO;
        else if ( 0 != ( state.eState & CI_STATE_LOW_MEMORY ) )
            idStatus = IDS_CI_STATE_LOMEM;
        else if ( 0 != ( state.eState & CI_STATE_BATTERY_POWER ) )
            idStatus = IDS_CI_STATE_BATTERY;
        else if ( 0 != ( state.eState & CI_STATE_READ_ONLY ) )
            idStatus = IDS_CI_STATE_READ_ONLY;
        else if ( 0 != ( state.eState & CI_STATE_USER_ACTIVE ) )
            idStatus = IDS_CI_STATE_USER_ACTIVE;
        else if ( 0 != ( state.eState & CI_STATE_STARTING ) )
            idStatus = IDS_CI_STATE_STARTING;
        else if ( 0 != ( state.eState & CI_STATE_READING_USNS ) )
            idStatus = IDS_CI_STATE_READING_USNS;

        {
            CResString str( idStatus );
            SetDlgItemText( _hdlg, ID_STAT_STATUS, str.Get() );
        }

        if ( 0 != ( state.eState & ALL_CI_MERGE ) )
        {
            unsigned idStr;
            if ( state.eState & CI_STATE_SHADOW_MERGE )
                idStr = IDS_MERGE_SHADOW;
            else if ( state.eState & CI_STATE_ANNEALING_MERGE )
                idStr = IDS_MERGE_ANNEALING;
            else if ( state.eState & CI_STATE_MASTER_MERGE )
                idStr = IDS_MERGE_MASTER;
            else
                idStr = IDS_MERGE_MASTER_PAUSED;

            CResString str( idStr );
            WCHAR awc[ cwcBufSize ];
            swprintf( awc,
                      L"%ws %d%%",
                      str.Get(),
                      state.dwMergeProgress );
            SetDlgItemText( _hdlg, ID_STAT_MT, awc );
        }
        else
        {
            SetDlgItemText( _hdlg, ID_STAT_MT, App.GetNo() );
        }
    }
    else
    {
        WCHAR awcTmp[80];
        swprintf( awcTmp, L"0x%x", sc );
        //FormatSrchError( sc, awcTmp, App.GetLocale() );
        SetDlgItemText( _hdlg, ID_STAT_STATUS, awcTmp );

        SetDlgItemText( _hdlg, ID_STAT_FTF, L"" );
        SetDlgItemText( _hdlg, ID_STAT_SECQ, L"" );
        SetDlgItemText( _hdlg, ID_STAT_FF, L"" );
        SetDlgItemText( _hdlg, ID_STAT_FTE, L"" );
        SetDlgItemText( _hdlg, ID_STAT_WL, L"" );
        SetDlgItemText( _hdlg, ID_STAT_PI, L"" );
        SetDlgItemText( _hdlg, ID_STAT_KEYS, L"" );
        SetDlgItemText( _hdlg, ID_STAT_FILES, L"" );
        SetDlgItemText( _hdlg, ID_STAT_Q, L"" );

        SetDlgItemText( _hdlg, ID_STAT_SCANNING, L"" );
        SetDlgItemText( _hdlg, ID_STAT_MT, L"" );
    }
} //Update

INT_PTR WINAPI StatusDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam )
{
    BOOL fRet = FALSE;
    SStatusDlg * pstat = (SStatusDlg *) GetWindowLongPtr( hdlg, DWLP_USER );

    switch( msg )
    {
        case WM_INITDIALOG :
        {
            CSearchControl &ctrl = * (CSearchControl *) lParam;
            pstat = new SStatusDlg( ctrl, hdlg );
            SetWindowLongPtr( hdlg, DWLP_USER, (LONG_PTR) pstat );
            fRet = TRUE;
            SetTimer( hdlg, 2, 1000, 0);

            int left,top,right,bottom;
            if ( LoadWindowRect( &left,
                                 &top,
                                 &right,
                                 &bottom,
                                 CISEARCH_REG_STATUSPOSITION ) )
            {
                RECT rc;
                GetWindowRect( hdlg,(LPRECT) &rc );
                MoveWindow( hdlg,
                            left,
                            top,
                            rc.right - rc.left,
                            rc.bottom - rc.top,
                            FALSE );
            }

            pstat->SetCaption();
            pstat->Update();
            break;
        }
        case WM_ACTIVATE :
        {
            if ( 0 == wParam )
                App.GetCurrentDialog() = 0;
            else
                App.GetCurrentDialog() = hdlg;
            break;
        }
        case WM_TIMER :
        {
            if ( ! IsIconic( App.AppWindow() ) )
                pstat->Update();
            break;
        }
        case WM_DESTROY :
        {
            KillTimer( hdlg, 2 );
            App.GetCurrentDialog() = 0;
            SaveWindowRect( hdlg, CISEARCH_REG_STATUSPOSITION );
            SetWindowLongPtr( hdlg, DWLP_USER, 0 );
            delete pstat;
            break;
        }
        case WM_COMMAND :
        {
            UINT uiID = MyWmCommandID( wParam, lParam );

            switch( uiID )
            {
                case IDCANCEL :
                {
                    DestroyWindow( hdlg );
                    fRet = TRUE;
                    break;
                }
            }
            break;
        }
    }

    return fRet;
} //StatusDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\srchslm\srchslm.cxx ===
//+-------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:  qsample.cxx
//
// PURPOSE:  Illustrates a minimal query using Indexing Service.
//           Uses CICreateCommand and CITextToFullTree helper functions.
//
// PLATFORM: Windows NT
//
//--------------------------------------------------------------------------

//#define UNICODE

#define OLEDBVER 0x0250 // need the command tree definitions
#define DBINITCONSTANTS

#include <stdio.h>
#include <windows.h>


#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>

#include <ntquery.h>
#include <cierror.h>

//
// Local prototypes
//

BOOL FindSlmRoot( WCHAR const * pwszPath, char * pszName, char * pszProject, char * pszRoot, char * pszSubDir );

struct SlmModifications
{
    char szLogname[100];
    char szLastChange[50];
    unsigned cMods;
};

unsigned WhoModified( char const * pszName,
                      char const * pszProject,
                      char const * pszRoot,
                      char const * pszSubDir,
                      SlmModifications & aMods,
                      unsigned cLogname );

//
// Local constants
//

CIPROPERTYDEF aProperties[] = { { L"Func",
                                  DBTYPE_WSTR | DBTYPE_BYREF,
                                  { { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
                                    DBKIND_GUID_NAME,
                                    L"func"
                                  }
                                },
                                { L"CLASS",
                                  DBTYPE_WSTR | DBTYPE_BYREF,
                                  { { 0x8dee0300, 0x16c2, 0x101b, 0xb1, 0x21, 0x08, 0x00, 0x2b, 0x2e, 0xcd, 0xa9 },
                                    DBKIND_GUID_NAME,
                                    L"class"
                                  }
                                }
                              };

// This is found in disptree.cxx

//extern void DisplayCommandTree( DBCOMMANDTREE * pNode, ULONG iLevel = 0 );

//+-------------------------------------------------------------------------
//
//  Template:   XInterface
//
//  Synopsis:   Template for managing ownership of interfaces
//
//--------------------------------------------------------------------------

template<class T> class XInterface
{
public:
    XInterface( T * p = 0 ) : _p( p ) {}
    ~XInterface() { if ( 0 != _p ) _p->Release(); }
    T * operator->() { return _p; }
    T * GetPointer() const { return _p; }
    IUnknown ** GetIUPointer() { return (IUnknown **) &_p; }
    T ** GetPPointer() { return &_p; }
    void ** GetQIPointer() { return (void **) &_p; }
    T * Acquire() { T * p = _p; _p = 0; return p; }

private:
    T * _p;
};

BOOL FindSlmRoot( WCHAR const * pwszPath, char * pszName, char * pszProject, char * pszRoot, char * pszSubDir )
{
    //
    // Compute path to slm.ini
    //

    char szSlmIni[MAX_PATH];

    wcstombs( szSlmIni, pwszPath, sizeof(szSlmIni) );

    char * pcLastSlash = strrchr( szSlmIni, '\\' );

    if ( 0 == pcLastSlash )
        return FALSE;

    strcpy( pszName, pcLastSlash + 1 );
    strcpy( pcLastSlash + 1, "slm.ini" );

    //
    // Open file and read project / root
    //

    FILE * pf = fopen( szSlmIni, "r" );

    if ( 0 == pf )
        return FALSE;

    //
    // Project
    //

    if ( 0 == fgets( pszProject, MAX_PATH, pf ) ||
         0 != strncmp( pszProject, "project = ", 10 ) )
    {
        fclose( pf );
        return FALSE;
    }

    unsigned cc = strlen( pszProject ) - 10 - 1;  // Preface and newline
    memmove( pszProject, pszProject + 10, cc );
    pszProject[cc] = 0;

    //
    // Root
    //

    if ( 0 == fgets( pszRoot, MAX_PATH, pf ) ||
         0 != strncmp( pszRoot, "slm root = ", 11 ) )
    {
        fclose( pf );
        return FALSE;
    }

    cc = strlen( pszRoot ) - 11 - 1;  // Preface and newline
    memmove( pszRoot, pszRoot + 11, cc );
    pszRoot[cc] = 0;

    for ( char * p = pszRoot; *p; p++ )
    {
        if ( '/' == *p )
            *p = '\\';
    }

    //
    // Subdir
    //

    if ( 0 == fgets( pszSubDir, MAX_PATH, pf ) ||
         0 == fgets( pszSubDir, MAX_PATH, pf ) ||
         0 != strncmp( pszSubDir, "sub dir = ", 10 ) )
    {
        fclose( pf );
        return FALSE;
    }

    cc = strlen( pszSubDir ) - 10 - 1;  // Preface and newline
    unsigned ccQuote = 0;

    if ( pszSubDir[10] == '"' )
        ccQuote = 1;

    memmove( pszSubDir, pszSubDir + 10 + ccQuote, cc - 2*ccQuote);
    pszSubDir[cc - 2*ccQuote] = 0;

    for ( p = pszSubDir; *p; p++ )
    {
        if ( '/' == *p )
            *p = '\\';
    }

    fclose( pf );

    return TRUE;
}

unsigned WhoModified( char const * pszName,
                  char const * pszProject,
                  char const * pszRoot,
                  char const * pszSubDir,
                  SlmModifications * aMods,
                  unsigned cMods )
{
    //
    // Initialize
    //

    memset( aMods, 0, sizeof(SlmModifications) * cMods );
    unsigned iNext = 0;

    //
    // Put the pieces together.
    //

    char szPath[MAX_PATH];

    strcpy( szPath, pszRoot );
    strcat( szPath, "\\diff\\" );
    strcat( szPath, pszProject );
    strcat( szPath, pszSubDir );
    strcat( szPath, "\\" );
    strcat( szPath, pszName );

    FILE * pf = fopen( szPath, "r" );

    if ( 0 == pf )
        return 0;

    char szTemp[500];
    char szDate[50];

    while ( 0 != fgets( szTemp, sizeof(szTemp), pf ) )
    {
        if ( 0 == _strnicmp( szTemp, "#T ", 3 ) )
        {
            //
            // Record the date, sans <cr>.
            //

            unsigned cc = strlen(szTemp + 3) - 1;
            memcpy( szDate, szTemp + 3, cc );
            szDate[cc] = 0;

            continue;
        }

        if ( 0 == _strnicmp( szTemp, "#A ", 3 ) )
        {
            //
            // Have we seen this user before?
            //

            char * pUser = szTemp + 3;
            pUser[strlen(pUser)-1] = 0;  // Remove newline

            for ( unsigned i = 0; i < cMods; i++ )
            {
                if ( 0 == _stricmp( pUser, aMods[i].szLogname ) )
                {
                    aMods[i].cMods++;
                    strcpy( aMods[i].szLastChange, szDate );

                    //
                    // Move this user to the end of the list.
                    //

                    SlmModifications Temp;

                    memcpy( &Temp, &aMods[i], sizeof(Temp) );

                    for ( unsigned j = i+1; j < iNext; j++ )
                        memcpy( &aMods[j-1], &aMods[j], sizeof(aMods[0]) );

                    memcpy( &aMods[j], &Temp, sizeof(Temp) );

                    break;
                }
            }

            //
            // New user?
            //

            if ( i == cMods )
            {
                strcpy( aMods[iNext].szLogname, pUser );
                aMods[iNext].cMods = 1;
                strcpy( aMods[iNext].szLastChange, szDate );

                iNext++;

                if ( iNext == cMods )
                    iNext = 0;
            }
        }
    }

    fclose( pf );

    return iNext;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetCommandProperties
//
//  Synopsis:   Sets the DBPROP_USEEXTENDEDDBTYPES property to TRUE, so
//              data is returned in PROPVARIANTs, as opposed to the
//              default, which is OLE automation VARIANTs.  PROPVARIANTS
//              allow a superset of VARIANT data types.  Use of these
//              types avoids costly coercions.
//
//              Also sets the DBPROP_USECONTENTINDEX property to TRUE, so
//              the index will always be used to resolve the query (as
//              opposed to enumerating all the files on the disk), even
//              if the index is out of date.
//
//              Both of these properties are unique to Index Server's OLE DB
//              implementation.
//
//  Arguments:  [pICommand] - The ICommand used to set the property
//
//  Returns:    HRESULT result of setting the properties
//
//--------------------------------------------------------------------------

HRESULT SetCommandProperties( ICommand * pICommand )
{
    static const DBID dbcolNull = { { 0,0,0, { 0,0,0,0,0,0,0,0 } },
                                    DBKIND_GUID_PROPID, 0 };
    static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

    DBPROP aProp[2];

    aProp[0].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[0].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
    aProp[0].dwStatus = 0;
    aProp[0].colid = dbcolNull;
    aProp[0].vValue.vt = VT_BOOL;
    aProp[0].vValue.boolVal = VARIANT_TRUE;

    aProp[1] = aProp[0];
    aProp[1].dwPropertyID = DBPROP_USECONTENTINDEX;

    DBPROPSET aPropSet[1];

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = 2;
    aPropSet[0].guidPropertySet = guidQueryExt;

    XInterface<ICommandProperties> xICommandProperties;
    HRESULT hr = pICommand->QueryInterface( IID_ICommandProperties,
                                            xICommandProperties.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    return xICommandProperties->SetProperties( 1,          // 1 property set
                                               aPropSet ); // the properties
} //SetCommandProperties

//+-------------------------------------------------------------------------
//
//  Function:   DoQuery
//
//  Synopsis:   Creates and executes a query, then displays the results.
//
//  Arguments:  [pwcQueryCatalog]    - Catalog name over which query is run
//              [pwcQueryMachine]    - Machine name on which query is run
//              [pwcQueryRestrition] - The actual query string
//              [fDisplayTree]       - TRUE to display the command tree
//
//  Returns:    HRESULT result of the query
//
//--------------------------------------------------------------------------

HRESULT DoQuery(
    WCHAR const * pwcQueryCatalog,
    WCHAR const * pwcQueryMachine,
    WCHAR const * pwcQueryRestriction,
    BOOL          fDisplayTree )
{
    // Create an ICommand object.  The default scope for the query is the
    // entire catalog.  CICreateCommand is a shortcut for making an
    // ICommand.  The ADVQUERY sample shows the OLE DB equivalent.

    XInterface<ICommand> xICommand;
    HRESULT hr = CICreateCommand( xICommand.GetIUPointer(), // result
                                  0,                  // controlling unknown
                                  IID_ICommand,       // IID requested
                                  pwcQueryCatalog,    // catalog name
                                  pwcQueryMachine );  // machine name

    if ( FAILED( hr ) )
        return hr;

    // Set required properties on the ICommand

    hr = SetCommandProperties( xICommand.GetPointer() );
    if ( FAILED( hr ) )
        return hr;

    //
    // @func
    //


    // Create an OLE DB query tree from a text restriction, column
    // set, and sort order.

    DBCOMMANDTREE * pTree;
    hr = CITextToFullTree( pwcQueryRestriction,      // the query itself
                           L"Size,Path",             // columns to return
                           L"Rank[d]",               // rank descending
                           0,                        // reserved
                           &pTree,                   // resulting tree
                           sizeof(aProperties)/sizeof(aProperties[0]), // custom properties
                           aProperties,               // custom properties
                           GetSystemDefaultLCID() ); // default locale

    //
    // The user may have a DefineColumns.txt file with func/class in it.
    //

    if ( QPLIST_E_DUPLICATE == hr )
    {
        hr = CITextToFullTree( pwcQueryRestriction,      // the query itself
                               L"Size,Path",             // columns to return
                               L"Rank[d]",               // rank descending
                               0,                        // reserved
                               &pTree,                   // resulting tree
                               0,                        // Custom props from global column def file
                               0,
                               GetSystemDefaultLCID() ); // default locale
    }

    if ( FAILED( hr ) )
        return hr;

    // If directed, display the command tree

    //if ( fDisplayTree )
    //    DisplayCommandTree( pTree );

    // Set the tree in the ICommandTree

    XInterface<ICommandTree> xICommandTree;
    hr = xICommand->QueryInterface( IID_ICommandTree,
                                    xICommandTree.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    hr = xICommandTree->SetCommandTree( &pTree,
                                        DBCOMMANDREUSE_NONE,
                                        FALSE );
    if ( FAILED( hr ) )
        return hr;

    // Execute the query.  The query is complete when Execute() returns

    XInterface<IRowset> xIRowset;
    hr = xICommand->Execute( 0,            // no aggregating IUnknown
                             IID_IRowset,  // IID for interface to return
                             0,            // no DBPARAMs
                             0,            // no rows affected
                             xIRowset.GetIUPointer() ); // result
    if ( FAILED( hr ) )
        return hr;

    // Create an accessor, so data can be retrieved from the rowset

    XInterface<IAccessor> xIAccessor;
    hr = xIRowset->QueryInterface( IID_IAccessor,
                                   xIAccessor.GetQIPointer() );
    if ( FAILED( hr ) )
        return hr;

    // Column iOrdinals are parallel with those passed to CiTextToFullTree,
    // so MapColumnIDs isn't necessary.  These binding values for dwPart,
    // dwMemOwner, and wType are the most optimal bindings for Index Server.

    const ULONG cColumns = 2; // 2 for Size and Path
    DBBINDING aColumns[ cColumns ];
    memset( aColumns, 0, sizeof aColumns );

    aColumns[0].iOrdinal   = 1; // first column specified above (size)
    aColumns[0].obValue    = 0; // offset where value is written in GetData
    aColumns[0].dwPart     = DBPART_VALUE;  // retrieve value, not status
    aColumns[0].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Index Server owned
    aColumns[0].wType      = DBTYPE_VARIANT | DBTYPE_BYREF; // VARIANT *

    aColumns[1] = aColumns[0];
    aColumns[1].iOrdinal   = 2; // second column specified above (path)
    aColumns[1].obValue    = sizeof (PROPVARIANT *); // offset for value

    HACCESSOR hAccessor;
    hr = xIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, // rowdata accessor
                                     cColumns,           // # of columns
                                     aColumns,           // columns
                                     0,                  // ignored
                                     &hAccessor,         // result
                                     0 );                // no status
    if ( FAILED( hr ) )
        return hr;

    // Display the results of the query.  Print file size and file path.

    DBCOUNTITEM cRowsSoFar = 0;

    do
    {
        DBCOUNTITEM cRowsReturned = 0;
        const ULONG cRowsAtATime = 10;
        HROW aHRow[cRowsAtATime];
        HROW * pgrHRows = aHRow;
        hr = xIRowset->GetNextRows( 0,              // no chapter
                                    0,              // no rows to skip
                                    cRowsAtATime,   // # rows to get
                                    &cRowsReturned, // # rows returned
                                    &pgrHRows);     // resulting hrows

        if ( FAILED( hr ) )
            break;

        for ( DBCOUNTITEM iRow = 0; iRow < cRowsReturned; iRow++ )
        {
            PROPVARIANT * aData[cColumns];
            hr = xIRowset->GetData( aHRow[iRow],  // hrow being accessed
                                    hAccessor,    // accessor to use
                                    &aData );     // resulting data
            if ( FAILED( hr ) )
                break;

            if ( VT_I8 ==     aData[0]->vt &&
                 VT_LPWSTR == aData[1]->vt )
            {

                char szName[MAX_PATH];
                char szProject[MAX_PATH];
                char szRoot[MAX_PATH];
                char szSubDir[MAX_PATH];

                if ( FindSlmRoot( aData[1]->pwszVal,
                                  szName,
                                  szProject,
                                  szRoot,
                                  szSubDir ) )
                {
                    printf( "SERVER: %s, PROJECT: %s, FILE: %s\\%s\n",
                            szRoot, szProject, szSubDir, szName );

                    SlmModifications aMods[10];

                    unsigned iStart = WhoModified( szName,
                                                   szProject,
                                                   szRoot,
                                                   szSubDir,
                                                   aMods,
                                                   sizeof(aMods)/sizeof(aMods[0]) );

                    BOOL fHeader = TRUE;

                    for ( unsigned i = 0; i < sizeof(aMods)/sizeof(aMods[0]); i++ )
                    {
                        if ( aMods[iStart].cMods > 0 )
                        {
                            if ( fHeader )
                            {
                                printf( "  LAST MODIFIED BY: " );
                                fHeader = FALSE;
                            }
                            else
                                printf( "                    " );

                            printf( "%s on %s", aMods[iStart].szLogname, aMods[iStart].szLastChange );

                            if ( aMods[iStart].cMods > 1 )
                                printf( " (%u changes)\n", aMods[iStart].cMods );
                            else
                                printf( "\n" );
                        }

                        iStart++;

                        if ( iStart == sizeof(aMods)/sizeof(aMods[0]) )
                            iStart = 0;
                    }
                }
                else
                {
                    printf( "NON SLM FILE: %ws\n", aData[1]->pwszVal );
                }
            }
            else
                printf( "could not retrieve a file's values\n" );
        }

        if ( 0 != cRowsReturned )
            xIRowset->ReleaseRows( cRowsReturned, // # of rows to release
                                   aHRow,         // rows to release
                                   0,             // no options
                                   0,             // no refcounts
                                   0 );           // no status

        if ( DB_S_ENDOFROWSET == hr )
        {
            hr = S_OK; // succeeded, return S_OK from DoQuery
            break;
        }

        if ( FAILED( hr ) )
            break;

        cRowsSoFar += cRowsReturned;
    } while ( TRUE );

    printf( "%d files matched the query '%ws'\n",
            cRowsSoFar,
            pwcQueryRestriction );

    xIAccessor->ReleaseAccessor( hAccessor, 0 );

    return hr;
} //DoQuery

//+-------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays information about how to use the app and exits
//
//--------------------------------------------------------------------------

void Usage()
{
    printf( "usage: QSAMPLE query [/c:catalog] [/m:machine] [/d]\n\n" );
    printf( "    query        an Indexing Service query\n" );
    printf( "    /c:catalog   name of the catalog, default is SYSTEM\n" );
    printf( "    /m:machine   name of the machine, default is local machine\n" );
    printf( "    /d           display the DBCOMMANDTREE, default is off\n" );
    exit( -1 );
} //Usage

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Entry point for the app.  Parses command line arguments
//              and issues a query.
//
//  Arguments:  [argc]     - Argument count
//              [argv]     - Arguments
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR * argv[] )
{
    WCHAR const * pwcCatalog     = L"sources"; // default: system catalog
    WCHAR const * pwcMachine     = L"index2";  // default: Index2
    WCHAR const * pwcRestriction = 0;          // no default restriction
    BOOL fDisplayTree            = FALSE;      // don't display the tree

    // Parse command line parameters

    for ( int i = 1; i < argc; i++ )
    {
        if ( L'-' == argv[i][0] || L'/' == argv[i][0] )
        {
            WCHAR wc = (WCHAR) toupper( argv[i][1] );

            if ( ':' != argv[i][2] && 'D' != wc )
                Usage();

            if ( 'C' == wc )
                pwcCatalog = argv[i] + 3;
            else if ( 'M' == wc )
                pwcMachine = argv[i] + 3;
            else if ( 'D' == wc )
                fDisplayTree = TRUE;
            else
                Usage();
        }
        else if ( 0 != pwcRestriction )
            Usage();
        else
            pwcRestriction = argv[i];
    }

    // A query restriction is necessary.  Fail if none is given.

    if ( 0 == pwcRestriction )
        Usage();

    // Run the query

    HRESULT hr = DoQuery( pwcCatalog,
                          pwcMachine,
                          pwcRestriction,
                          fDisplayTree );

    if ( FAILED( hr ) )
    {
        printf( "the query '%ws' failed with error %#x\n",
                pwcRestriction, hr );
        return -1;
    }

    return 0;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\usndump\usndump.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1997-1998
//
//  File:       usndump.cxx
//
//  Contents:   Usn dump utility. Needs admin privileges to run.
//
//  History:    05-Jul-97       SitaramR          Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

void Usage()
{
    printf( "Needs admin privileges to run, usage: usndump  <drive_letter>, e.g. usndump c\n" );
}

DECLARE_INFOLEVEL(ci)

//+---------------------------------------------------------------------------
//
//  Function:   PrintUsnRecords
//
//  Purpose:    Prints usn records from buffer
//
//  History:    05-Jul-97   SitaramR    Created
//              21-May-98   KLam        Added SourceInfo as output
//
//----------------------------------------------------------------------------

void PrintUsnRecords( IO_STATUS_BLOCK *iosb, void *pBuffer )
{
    USN usnNextStart;
    USN_RECORD * pUsnRec;

    ULONG_PTR dwByteCount = iosb->Information;
    if ( dwByteCount != 0 )
    {
        usnNextStart = *(USN *)pBuffer;
        pUsnRec = (USN_RECORD *)((PCHAR)pBuffer + sizeof(USN));
        dwByteCount -= sizeof(USN);
    }

    while ( dwByteCount != 0 )
    {
        if ( pUsnRec->MajorVersion != 2 || pUsnRec->MinorVersion != 0 )
        {
            printf( "Unrecognized USN version, Major=%u, Minor=%u\n",
                    pUsnRec->MajorVersion, pUsnRec->MinorVersion );
            break;
        }

        if ( 0 != pUsnRec->SourceInfo )
            printf( "FileId=%#I64x, ParentFileId=%#I64x, Usn=%#I64x, Reason=%#x, SourceInfo=%#x, FileAttr=%#x, FileName=%.*ws\n",
                    pUsnRec->FileReferenceNumber,
                    pUsnRec->ParentFileReferenceNumber,
                    pUsnRec->Usn,
                    pUsnRec->Reason,
                    pUsnRec->SourceInfo,
                    pUsnRec->FileAttributes,
                    pUsnRec->FileNameLength / sizeof WCHAR ,
                    &pUsnRec->FileName );
        else
            printf( "FileId=%#I64x, ParentFileId=%#I64x, Usn=%#I64x, Reason=%#x, FileAttr=%#x, FileName=%.*ws\n",
                    pUsnRec->FileReferenceNumber,
                    pUsnRec->ParentFileReferenceNumber,
                    pUsnRec->Usn,
                    pUsnRec->Reason,
                    pUsnRec->FileAttributes,
                    pUsnRec->FileNameLength / sizeof WCHAR,
                    &pUsnRec->FileName );

        if ( pUsnRec->RecordLength <= dwByteCount )
        {
            dwByteCount -= pUsnRec->RecordLength;
            pUsnRec = (USN_RECORD *) ((PCHAR) pUsnRec + pUsnRec->RecordLength );
        }
        else
        {
            printf( "***--- Usn read fsctl returned bogus dwByteCount 0x%x ---***\n", dwByteCount );

            THROW( CException( STATUS_UNSUCCESSFUL ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Purpose:    Main dump routine
//
//  History:    05-Jul-97   SitaramR    Created
//
//----------------------------------------------------------------------------

int __cdecl main( int argc, char * argv[] )
{
    if ( argc != 2 )
    {
        Usage();
        return 0;
    }

    WCHAR wcDriveLetter = argv[1][0];

    TRY
    {
        //
        // Looking at a file?
        //

        if ( strlen(argv[1]) > 2 )
        {
            int ccUnicodeStr = strlen( argv[1] ) + 1;
            WCHAR * pUnicodeStr = new WCHAR[ccUnicodeStr];
            if ( !MultiByteToWideChar( CP_ACP, 0, argv[1], -1, pUnicodeStr, ccUnicodeStr ) )
            {
                printf("MultiByteToWideChar failed.\n");
                delete [] pUnicodeStr;
                return 0;
            }
            CFunnyPath funnyPath( pUnicodeStr );
            delete [] pUnicodeStr;

            HANDLE hFile = CreateFile( funnyPath.GetPath(),
                                       GENERIC_READ,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_FLAG_BACKUP_SEMANTICS,
                                       NULL );

            if ( INVALID_HANDLE_VALUE == hFile && ERROR_ACCESS_DENIED == GetLastError() )
                hFile = CreateFile( funnyPath.GetPath(),
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

            if ( hFile == INVALID_HANDLE_VALUE )
            {
                printf( "***--- Usn file open failed 0x%x, check for admin privileges ---***\n", GetLastError() );

                THROW( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
            }

            NTSTATUS status;

            SHandle xFile( hFile );

            IO_STATUS_BLOCK iosb;
            ULONGLONG readBuffer[100];

            for ( unsigned i = 0; i < sizeof(readBuffer)/sizeof(readBuffer[0]); i++ )
                readBuffer[i] = 0xFFFFFFFFFFFFFFFFi64;

            USN_RECORD *pUsnRec;
            status = NtFsControlFile( hFile,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &iosb,
                                      FSCTL_READ_FILE_USN_DATA,
                                      NULL,
                                      NULL,
                                      &readBuffer,
                                      sizeof(readBuffer) );

            if ( !NT_SUCCESS(status) || !NT_SUCCESS(iosb.Status) )
            {
                printf( "***--- Error 0x%x / 0x%x returned from READ_FILE_USN_DATA ---***\n", status, iosb.Status );
                return 0;
            }

            pUsnRec = (USN_RECORD *) &readBuffer;

            if ( pUsnRec->MajorVersion != 2 || pUsnRec->MinorVersion != 0 )
                printf( "Unrecognized USN version, Major=%u, Minor=%u\n",
                        pUsnRec->MajorVersion, pUsnRec->MinorVersion );
            else
                printf( "FileId=%#I64x, ParentFileId=%#I64x, Usn=%#I64x, FileAttr=%#x, FileName=%.*ws\n",
                        pUsnRec->FileReferenceNumber,
                        pUsnRec->ParentFileReferenceNumber,
                        (ULONG)(pUsnRec->Usn>>32),
                        (ULONG)pUsnRec->Usn,
                        pUsnRec->FileAttributes,
                        pUsnRec->FileNameLength / sizeof(WCHAR),
                        &pUsnRec->FileName );
        }
        else
        {
            //
            // Create the volume handle that will be used for usn fsctls
            //

            WCHAR wszVolumePath[] = L"\\\\.\\a:";
            wszVolumePath[4] = wcDriveLetter;
            HANDLE hVolume = CreateFile( wszVolumePath,
                                         GENERIC_READ | GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_EXISTING,
                                         0,
                                         NULL );

            if ( hVolume == INVALID_HANDLE_VALUE )
            {
                printf( "***--- Usn volume open failed 0x%x, check for admin privileges ---***\n", GetLastError() );

                THROW( CException( HRESULT_FROM_WIN32( GetLastError() ) ) );
            }

            SWin32Handle xHandleVolume( hVolume );

            IO_STATUS_BLOCK iosb;

            //
            // Get the Journal ID
            //


            USN_JOURNAL_DATA UsnJournalInfo;

            NTSTATUS status = NtFsControlFile( hVolume,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &iosb,
                                               FSCTL_QUERY_USN_JOURNAL,
                                               0,
                                               0,
                                               &UsnJournalInfo,
                                               sizeof(UsnJournalInfo) );
            if ( status == STATUS_PENDING )
            {
                printf( "***--- Status_pending returned for synchronous read fsctl ---***\n" );
                return 0;
            }

            if ( !NT_SUCCESS(status) || !NT_SUCCESS(iosb.Status) )
            {
                printf( "***--- Error 0x%x / 0x%x returned from QUERY_USN_JOURNAL ---***\n", status, iosb.Status );
                return 0;
            }

            READ_USN_JOURNAL_DATA usnData = {0, MAXULONG, 0, 0, 0, UsnJournalInfo.UsnJournalID};
            ULONGLONG readBuffer[2048];

            status = NtFsControlFile( hVolume,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &iosb,
                                      FSCTL_READ_USN_JOURNAL,
                                      &usnData,
                                      sizeof(usnData),
                                      &readBuffer,
                                      sizeof(readBuffer) );

            if ( status == STATUS_PENDING )
            {
                printf( "***--- Status_pending returned for synchronous read fsctl ---***\n" );
                return 0;
            }

            if ( NT_SUCCESS( status ) )
            {
                status = iosb.Status;

                if ( STATUS_KEY_DELETED == status ||
                     STATUS_JOURNAL_ENTRY_DELETED == status )
                {
                    printf( "***--- Status key deleted, rerun ---***\n" );
                    return 0;
                }

                PrintUsnRecords( &iosb, readBuffer );

                //
                // Read usn records until the end of usn journal
                //

                USN usnStart = 0;
                while ( NT_SUCCESS( status ) )
                {
                    ULONG_PTR dwByteCount = iosb.Information;

                    if ( dwByteCount <= sizeof(USN) )
                        return 0;
                    else
                    {
                        usnStart = *(USN *)&readBuffer;
                        usnData.StartUsn = usnStart;
                        status = NtFsControlFile( hVolume,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  &iosb,
                                                  FSCTL_READ_USN_JOURNAL,
                                                  &usnData,
                                                  sizeof(usnData),
                                                  &readBuffer,
                                                  sizeof(readBuffer) );

                        if ( NT_SUCCESS( status ) )
                            status = iosb.Status;
                        else
                        {
                            printf( "***--- Error 0x%x returned from read fsctl ---***\n", status );
                            return 0;
                        }

                        if ( STATUS_KEY_DELETED == status ||
                             STATUS_JOURNAL_ENTRY_DELETED == status )
                        {
                            printf( "***--- Status key deleted, rerun usndump ---***\n" );
                            return 0;
                        }

                        PrintUsnRecords( &iosb, readBuffer );
                    }
                }

                return 0;
            }
            else
                printf( "***--- Usn read fsctl returned 0x%x, check if usn journal has created on that volume ---***\n",
                        status );
        }

        return 0;
    }
    CATCH( CException, e )
    {
       printf( "***--- Caught exception 0x%x ---***\n", e.GetErrorCode() );
    }
    END_CATCH

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\webhits\cdoc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cdoc.cxx
//
//  Contents:   a radically stripped down version of the document class
//              that gets rid of the notion of paragragph and maintains only
//              information relative to the stream
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cidebug.hxx>
#include <dynstack.hxx>
#include <cimbmgr.hxx>
#include <propspec.hxx>
#include <vquery.hxx>
#include <pageman.hxx>
#include <dblink.hxx>
#include <imprsnat.hxx>
#include <queryexp.hxx>

#include "whmsg.h"
#include "webdbg.hxx"
#include "cdoc.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   ComparePositions
//
//  Arguments:  const void* pPos1 - pointer to first position
//              const void* pPos2 - pointer to second position
//
//  Synopsis:   Comparison function used by qsort to sort positions array
//
//--------------------------------------------------------------------------


int _cdecl ComparePositions(
    const void* pPos1,
    const void* pPos2 )
{
    Position* pp1= (Position*) pPos1;
    Position* pp2= (Position*) pPos2;

    Win4Assert(0 != pp1 && 0 !=pp2);

    if (pp1->GetBegOffset() == pp2->GetBegOffset())
        return 0;
    else if (pp1->GetBegOffset() < pp2->GetBegOffset())
        return -1;
    else
        return 1;
}

void Hit::Sort()
{
    qsort( _aPos, _cPos, sizeof(Position), &ComparePositions );
}


//+-------------------------------------------------------------------------
//
//  Member:     Hit::Hit, public
//
//  Arguments:  [aPos]      - array of positions
//              [cPos]      - number of Positions in [aPos]
//
//  Synopsis:   Create hit from an array of positions
//
//--------------------------------------------------------------------------

Hit::Hit( const Position * aPos, unsigned cPos )
: _cPos(cPos)
{
    _aPos = new Position[cPos];

    memcpy( _aPos, aPos, sizeof(Position) * cPos );
}

Hit::~Hit()
{
    delete[] _aPos;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPositionCount, public
//
//  Synopsis:   return number of positions or zero
//
//--------------------------------------------------------------------------

int HitIter::GetPositionCount() const
{
    if (_iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit])
        return _pDoc->_aHit[_iHit]->GetPositionCount();

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     HitIter::GetPosition, public
//
//  Synopsis:   return position by value
//
//--------------------------------------------------------------------------

Position HitIter::GetPosition ( int i ) const
{
     if ( _iHit < _pDoc->_cHit && _pDoc->_aHit[_iHit] )
          return _pDoc->_aHit[_iHit]->GetPos(i);
     else
     {
          Position pos;
          return( pos );
     }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::CDocument, public constructor
//
//  Arguments:  [filename]       - the name of the file to hit highlight
//              [rank]           - the rank of document in the hierarchy - NOT USED
//              [rSearch]        - ISearch object
//              [cmsReadTimeout] - timeout for the initial file read
//              [lockSingleThreadedFilter] - lock used for all single
//                                           threaded filters
//              [propertyList]   - properties to be emitted
//              [ulDisplayScript] - setting for displaying scripts
//
//  Synopsis:   Stream the file in chunk by chunk, scan it for hits,
//              and record those positions in the stream matching the restricition.
//
//--------------------------------------------------------------------------

CDocument::CDocument(
    WCHAR *           filename,
    ULONG             rank,
    ISearchQueryHits &         rSearch,
    DWORD             cmsReadTimeout,
    CReleasableLock & lockSingleThreadedFilter,
    CEmptyPropertyList &   propertyList,
    ULONG             ulDisplayScript )
: _filename( filename ),
  _rank( rank ),
  _bufEnd( 0 ),
  _iChunkHint( 0 ),
  _cHit( 0 ),
  _rSearch( rSearch ),
  _cmsReadTimeout( cmsReadTimeout ),
  _lockSingleThreadedFilter( lockSingleThreadedFilter )
{
    BOOL noHits = FALSE;

    //
    // cut away anything after the non-drive colon
    // like in c:\wzmail\foo.fld:12.wzm
    //

    WCHAR* pChar =  _filename;
    if ( _filename[1] == L':')
        pChar += 2;
    while (*pChar != 0 && *pChar != L':')
        pChar++;
    if(*pChar == L':')
        *pChar = 0;

    //
    // allocate a buffer to hold the file
    //

    AllocBuffer();

    //
    // attach to IFilter
    //

    BOOL fKnownFilter = BindToFilter();

    // Check if this file's extension has a script mapping (if necessary)

    BOOL fHasScriptMap = FALSE;

    if ( ( DISPLAY_SCRIPT_NONE == ulDisplayScript ) ||
         ( ( DISPLAY_SCRIPT_KNOWN_FILTER == ulDisplayScript ) &&
           ( !fKnownFilter ) ) )
    {
        WCHAR *pwcExt = wcsrchr( _filename, L'.' );
        webDebugOut(( DEB_ITRACE, "extension: '%ws'\n", pwcExt ));

        if ( 0 != pwcExt )
        {
            //
            // .asp files include .inc files.  .inc files don't have a script
            // map but they contain script.  I'm not aware of a good way to
            // enumerate all possible include file extensions for asp.
            //

            if ( !_wcsicmp( pwcExt, L".inc" ) )
                fHasScriptMap = TRUE;
            else
            {
                //
                // Must be system to read the metabase
                //
    
                CImpersonateSystem system;
                CMetaDataMgr mdMgr( TRUE, W3VRoot );
                fHasScriptMap = mdMgr.ExtensionHasScriptMap( pwcExt );
            }
        }
    }

    webDebugOut(( DEB_ITRACE,
                  "fHasScriptMap %d, fKnownFilter %d, ulDisplayScript %d\n",
                  fHasScriptMap, fKnownFilter, ulDisplayScript ));

    if ( fHasScriptMap )
    {
        if ( ( DISPLAY_SCRIPT_NONE == ulDisplayScript ) ||
             ( ( DISPLAY_SCRIPT_KNOWN_FILTER == ulDisplayScript ) &&
               ( !fKnownFilter ) ) )
        {
            THROW( CException( MSG_WEBHITS_PATH_INVALID ) );
        }
    }

    //
    // Initialize IFilter.  Pass the list of properties to be emitted, since
    // some other properties may have sensitive information (eg passwords in
    // vbscript code in .asp files).
    //

    // First count how many properties exist.

    ULONG cProps = propertyList.GetCount();
    
    // Copy the properties

    CDbColumns aSpecs( cProps );
    CDbColId prop;
    for ( unsigned iProp = 0; iProp < cProps; iProp++ )
        aSpecs.Add( prop, iProp );

    typedef CPropEntry * PCPropEntry;
    XArray<PCPropEntry> xapPropEntries(cProps);


    SCODE sc = propertyList.GetAllEntries(xapPropEntries.GetPointer(), cProps);
    Win4Assert(S_OK == sc);

    if (FAILED (sc))
        THROW (CException(sc));

    PCPropEntry *apPropEntries = xapPropEntries.GetPointer();
    for (ULONG i = 0; i < cProps; i++)
    {
        CDbColId * pcol = (CDbColId *) &aSpecs.Get( i );

        *pcol = apPropEntries[i]->PropSpec();
        if ( !pcol->IsValid())
            THROW (CException(E_OUTOFMEMORY));
    }

    webDebugOut(( DEB_ITRACE, "%d properties being processed\n", cProps ));

    ULONG ulFlags;
    sc = _xFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         cProps,
                         (FULLPROPSPEC *) aSpecs.GetColumnsArray(),
                         &ulFlags );

    if (FAILED (sc))
        THROW (CException(sc));

    //
    // pull the contents of the file into the buffer
    //

    ReadFile();

    // Some broken filters don't work right if you Init() them twice, so
    // throw away the IFilter, and get it again.

    _xFilter.Free();
    BindToFilter();

    sc = _xFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                         IFILTER_INIT_CANON_HYPHENS |
                         IFILTER_INIT_APPLY_INDEX_ATTRIBUTES,
                         cProps,
                         (FULLPROPSPEC *) aSpecs.GetColumnsArray(),
                         &ulFlags );
    if (FAILED (sc))
        THROW (CException(sc));

    //
    // attach to ISearchQueryHits, which will find the hits
    //

    sc = _rSearch.Init( _xFilter.GetPointer(), ulFlags );

    if (FAILED (sc))
    {
        if ( QUERY_E_INVALIDRESTRICTION != sc )
            THROW (CException(sc));

        // we can still show the file
        noHits = TRUE;
    }

    //
    // pull up all the hits
    //

    TRY
    {
        if (!noHits)
        {
            ULONG count;
            FILTERREGION* aRegion;
            SCODE sc = _rSearch.NextHitOffset( &count, &aRegion );
    
            while ( S_OK == sc )
            {
                XCoMem<FILTERREGION> xRegion( aRegion );

                webDebugOut(( DEB_ITRACE,
                              "CDOCUMENT: next hit: count %d, chunk %d offset %d, ext %d\n",
                              count,
                              aRegion[0].idChunk,
                              aRegion[0].cwcStart,
                              aRegion[0].cwcExtent ));
    
                CDynArrayInPlace<Position> aPos( count );
    
                //
                // get the positions in the hit
                //
    
                for (unsigned i = 0; i < count; i++)
                {
                    aPos[i] = RegionToPos( aRegion [i] );
                    webDebugOut(( DEB_ITRACE,
                                  "  region %d, start %d, length %d\n",
                                  i,
                                  aPos[i].GetBegOffset(),
                                  aPos[i].GetLength() ));
                }
    
                xRegion.Free();

                XPtr<Hit> xHit( new Hit( aPos.GetPointer(), count ) );

                _aHit[_cHit] = xHit.GetPointer();
                _cHit++;

                xHit.Acquire();
    
                sc = _rSearch.NextHitOffset( &count, &aRegion );
            }

            if ( FAILED( sc ) )
                THROW( CException( sc ) );
        }
    }
    CATCH( CException, e )
    {
        FreeHits();
        RETHROW();
    }
    END_CATCH;

    // done with the filter

    _xFilter.Free();

    if ( _lockSingleThreadedFilter.IsHeld() )
        _lockSingleThreadedFilter.Release();
} //CDocument

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::~CDocument, public
//
//  Synopsis:   Free CDocument
//
//--------------------------------------------------------------------------

CDocument::~CDocument()
{
    FreeHits();
} //~CDocument

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::Free, public
//
//  Synopsis:   Free CDocument storage
//
//--------------------------------------------------------------------------

void CDocument::FreeHits()
{
    //
    // walk through _aHit, deleting each Positions array that the
    // cells are pointing to
    //

    for ( unsigned i = 0; i < _cHit; i++ )
    {
        delete _aHit[i];
        _aHit[i] = 0;
    }
    _cHit = 0;
} //Free

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::RegionToPos, public
//
//  Synopsis:   Convert a FILTERREGION to a position
//
//--------------------------------------------------------------------------

Position CDocument::RegionToPos(
    FILTERREGION& region )
{
    //
    // Use a linear search here.  In profile runs this has never shown
    // up as a problem.  Fix if this changes.
    //

    ULONG offset = ULONG (-1);

    //
    // check whether we're not trying to access an illegal chunk
    //

    if (_iChunkHint >= _chunkCount || _chunk[_iChunkHint].ChunkId() !=
        region.idChunk )
    {
        _iChunkHint = 0;

        while ( _iChunkHint < _chunkCount && _chunk[_iChunkHint].ChunkId() <
            region.idChunk )
        {
            _iChunkHint++;
        }

        if (_iChunkHint >= _chunkCount || _chunk[_iChunkHint].ChunkId()
            != region.idChunk)
        {
            return Position();
        }
    }

    //
    // _iChunkHint now contains the index of the appropriate chunk in the
    // chunk array
    //

    Win4Assert ( _iChunkHint < _chunkCount );
    Win4Assert ( _chunk[_iChunkHint].ChunkId() == region.idChunk );

    //
    // offset now stores the linear offset of the position from the
    // beginning of the stream/buffer
    //

    offset = _chunk[_iChunkHint].Offset() + region.cwcStart;

    return Position (offset,region.cwcExtent );
} //RegionToPos

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::AllocBuffer, public
//
//  Synopsis:   Allocate buffer for file text
//
//--------------------------------------------------------------------------

void CDocument::AllocBuffer()
{
    HANDLE hFile = CreateFile( _filename,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               0, // security
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               0 ); // template

    if ( INVALID_HANDLE_VALUE == hFile )
        THROW( CException() );

    ULONG cbBuf = GetFileSize( hFile, 0 );
    CloseHandle( hFile );

    // Allow extra room for custom properties to be emitted from the
    // filter, plus the conversion to unicode

    _xBuffer.Init( cbBuf + cbBuf / 2 );
} //AllocBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::BindToFilter, public
//
//  Synopsis:   Bind to appropriate filter for the CDocument
//
//  Returns:    TRUE if an appropriate filter was found
//              FALSE if defaulted to the text filter
//
//--------------------------------------------------------------------------

BOOL CDocument::BindToFilter()
{
    //
    // Bind to the filter interface -- try free threaded first.  If the
    // filter isn't thread-safe, grab the lock and get the filter.
    //

    SCODE sc = LoadBHIFilter( _filename, 0, _xFilter.GetQIPointer(), FALSE );

    // Is the filter not thread safe?  If so, get the lock to protect
    // the filter.  No checking is done to see that this particular
    // filter is in use -- just that some non-thread-safe filter is in use.

    if ( S_FALSE == sc )
    {
        // If the lock isn't held yet, get it (BindToFilter is called
        // twice by CDocument's constructor, so check IsHeld())

        if ( !_lockSingleThreadedFilter.IsHeld() )
            _lockSingleThreadedFilter.Request();

        // retry to load the filter as single-threaded

        sc = LoadBHIFilter( _filename, 0, _xFilter.GetQIPointer(), TRUE );
    }

    BOOL fFoundFilter = TRUE;

    if ( FAILED(sc) )
    {
        sc = LoadTextFilter( _filename, _xFilter.GetPPointer() );
        if (FAILED(sc))
            THROW (CException(sc));

        fFoundFilter = FALSE;
    }

    return fFoundFilter;
} //BindToFilter

//+-------------------------------------------------------------------------
//
//  Function:   GetThreadTime
//
//  Synopsis:   Gets the current total cpu usage for the thread
//
//--------------------------------------------------------------------------

LONGLONG GetThreadTime()
{
    FILETIME ftDummy1, ftDummy2;
    LONGLONG llUser, llKernel;
    Win4Assert( sizeof(LONGLONG) == sizeof(FILETIME) );

    GetThreadTimes( GetCurrentThread(),
                    &ftDummy1,                 // Creation time
                    &ftDummy2,                 // Exit time
                    (FILETIME *) &llUser,      // user mode time
                    (FILETIME *) &llKernel );  // kernel mode tiem

    return llKernel + llUser;
} //GetThreadTime

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::ReadFile, public
//
//  Synopsis:   Read file into buffer using the filter
//
//--------------------------------------------------------------------------

void CDocument::ReadFile()
{
    // get the maximum cpu time in 100s of nano seconds.

    LONGLONG llLimitCpuTime = _cmsReadTimeout * 1000 * 10000;
    llLimitCpuTime += GetThreadTime();

    ULONG               cwcSoFar = 0;
    int                 cChunk = 0;
    BOOL                fSeenProp = FALSE;
    STAT_CHUNK  statChunk;
    SCODE               sc = _xFilter->GetChunk ( &statChunk );

    //
    // Take them into account at some point
    // to test more complicated chunking
    //

    //
    // keep getting chunks of the file, placing them in the buffer,
    // and setting the chunk offset markers that will be used to
    // interpolate the buffer
    //

    while ( SUCCEEDED(sc)
            || FILTER_E_LINK_UNAVAILABLE == sc
            || FILTER_E_EMBEDDING_UNAVAILABLE == sc
            || FILTER_E_NO_TEXT == sc )
    {

        //
        // Eliminate all chunks with idChunkSource 0 right here - these
        // cannot be hit highlighted.
        // Also eliminate all CHUNK_VALUE chunks.
        //

        if ( SUCCEEDED( sc ) && (statChunk.flags & CHUNK_TEXT) && (0 != statChunk.idChunkSource)  )
        {
            //
            // set markers
            //

            Win4Assert ( cChunk == 0 || statChunk.idChunk >
            _chunk [cChunk - 1].ChunkId() );

            //
            // If there was an end of sentence or paragraph or chapter, we
            // should introduce an appropriate spacing character.
            //
            if ( statChunk.breakType != CHUNK_NO_BREAK &&
                 cwcSoFar < _xBuffer.Count() )
            {
                switch (statChunk.breakType)
                {
                    case CHUNK_EOW:
                    case CHUNK_EOS:
                        _xBuffer[cwcSoFar++] = L' ';   // introduce a space character
                        break;

                    case CHUNK_EOP:
                    case CHUNK_EOC:
                        _xBuffer[cwcSoFar++] = UNICODE_PARAGRAPH_SEPARATOR;
                        break;
                }
            }

            //
            // The Offset into the stream depends on whether this is an
            // 'original' chunk or not
            //

            CCiPropSpec* pProp = (CCiPropSpec*) &statChunk.attribute;

            webDebugOut(( DEB_ITRACE,
                          "Chunk %d, Source %d, Contents %d, start %d, cwc %d\n",
                          statChunk.idChunk,
                          statChunk.idChunkSource,
                          pProp->IsContents(),
                          statChunk.cwcStartSource,
                          statChunk.cwcLenSource ));

            if ( (statChunk.idChunk == statChunk.idChunkSource) &&
                 pProp->IsContents() )
            {
                _chunk[cChunk].SetChunkId( statChunk.idChunk );
                _chunk[cChunk].SetOffset( cwcSoFar );
                cChunk++;
#if 0
            }
            else if ( statChunk.idChunk != statChunk.idChunkSource )
            {
                _chunk [cChunk].SetChunkId (statChunk.idChunk);

                //
                // we have to first find the offset of the source chunk
                //

                for (int i=cChunk-1;i>=0;i--)
                {
                    if (_chunk[i].ChunkId() == statChunk.idChunkSource)
                    {
                        _chunk[cChunk].SetOffset(_chunk[i].Offset()+statChunk.cwcStartSource);
                        break;
                    }
                }
                cChunk++;

            }

            //
            // if the chunk is a contents chunk and idChunkSrc = idChunk,
            // then pull it in
            //

            if ( (statChunk.idChunk == statChunk.idChunkSource) &&
                 pProp->IsContents() )
            {
#endif

                webDebugOut(( DEB_ITRACE, "CDOC: markers: chunk %d offset %d\n",
                              _chunk[cChunk-1].ChunkId(),
                              _chunk[cChunk-1].Offset() ));


                //
                // push the text into memory
                //

                do
                {
                    ULONG cwcThis = _xBuffer.Count() - cwcSoFar;
                    if ( 0 == cwcThis )
                        break;

                    sc = _xFilter->GetText( &cwcThis,
                                            _xBuffer.GetPointer() + cwcSoFar );

                    if (SUCCEEDED(sc))
                    {
                        cwcSoFar += cwcThis;
                    }
                }
                while (SUCCEEDED(sc));
            }
        } // If SUCCEEDED( sc )

        if ( GetThreadTime() > llLimitCpuTime )
        {
            webDebugOut(( DEB_ERROR, "Webhits took too long. Timeout\n" ));
            THROW( CException( MSG_WEBHITS_TIMEOUT ) );
        }

        //
        // next chunk, please
        //

        sc = _xFilter->GetChunk ( &statChunk );
    }

    _bufEnd = _xBuffer.GetPointer() + cwcSoFar;
    _chunkCount = cChunk;
} //ReadFile

WCHAR* CDocument::GetWritablePointerToOffset(
    long offset )
{
    if (offset >= 0)
    {
        if (_xBuffer.GetPointer() + offset < _bufEnd)
            return _xBuffer.GetPointer() + offset;
        else
            return _bufEnd;
    }
    else
    {
        return _xBuffer.GetPointer();
    }
} //GetWritablePointerToOffset

//+-------------------------------------------------------------------------
//
//  Member:     CDocument::GetPointerToOffset, public
//
//  Arguments:  [offset] - the offset in the stream that we want a pointer to
//
//  Synopsis:   Return a constant pointer to a specific offset in the buffer
//
//--------------------------------------------------------------------------

const WCHAR* CDocument::GetPointerToOffset(long offset) 
{
    return (const WCHAR *) GetWritablePointerToOffset(offset);
} //GetPointerToOffset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\usnmon\usnmon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999.
//
//  File:       usnmon.cxx
//
//  Contents:   USN monitor
//
//  History:    18 Nov 1998     DLee    Created
//
//--------------------------------------------------------------------------

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif 

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}

#include <windows.h>
#include <stdio.h>
#include <process.h>

#define MAX_PATH_WCHARS (MAX_PATH * 4 )

BOOL fVerbose = FALSE;

void usage()
{
    printf( "usage: usnmon x: [-verbose]\n" );
    printf( "You must be an administrator to run this application.\n" );
    exit( 1 );
} //usage

void IdToPath(
    HANDLE       hVol,
    LONGLONG     ll,
    WCHAR        wcVol,
    WCHAR *      pwcPath )
{
    *pwcPath = 0;

    UNICODE_STRING uScope;
    uScope.Buffer = (WCHAR *) &ll;
    uScope.Length = sizeof ll;
    uScope.MaximumLength = sizeof ll;

    OBJECT_ATTRIBUTES ObjectAttr;
    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                hVol,                 // Root
                                0 );                  // Security

    IO_STATUS_BLOCK IoStatus;
    HANDLE h = INVALID_HANDLE_VALUE;
    NTSTATUS Status = NtOpenFile( &h,                
                                  FILE_READ_ATTRIBUTES,
                                  &ObjectAttr,       
                                  &IoStatus,         
                                  FILE_SHARE_READ |
                                      FILE_SHARE_WRITE |
                                      FILE_SHARE_DELETE,
                                  FILE_OPEN_BY_FILE_ID );
    if ( NT_ERROR( Status ) )
        return;        

    static BYTE abFileNameInformation[ MAX_PATH_WCHARS * sizeof WCHAR +
                                       sizeof FILE_NAME_INFORMATION ];

    ULONG cbMax = sizeof abFileNameInformation;

    PFILE_NAME_INFORMATION FileName = (PFILE_NAME_INFORMATION) abFileNameInformation;
    FileName->FileNameLength = cbMax - sizeof FILE_NAME_INFORMATION;

    Status = NtQueryInformationFile( h,
                                     &IoStatus,
                                     FileName, 
                                     cbMax,
                                     FileNameInformation );
    NtClose( h );
                                            
    if ( NT_ERROR( Status ) )
        return;

    // This is actually the full path, not the filename

    FileName->FileName[ FileName->FileNameLength / sizeof WCHAR ] = 0;

    pwcPath[0] = wcVol;
    pwcPath[1] = ':';
    wcscpy( pwcPath + 2, FileName->FileName );
} //IdToPath

USN PrintUsnRecords(
    HANDLE            hVol,
    WCHAR             wcVol,
    IO_STATUS_BLOCK * pIoSB,
    void *            pBuffer,
    USN               usnPrev )
{
    USN usnNextStart;
    USN_RECORD * pUsnRec;

    ULONG_PTR dwByteCount = pIoSB->Information;
    if ( 0 != dwByteCount )
    {
        usnNextStart = *(USN *)pBuffer;
        pUsnRec = (USN_RECORD *)((PCHAR)pBuffer + sizeof(USN));
        dwByteCount -= sizeof(USN);
    }
    else
    {
        usnNextStart = usnPrev;
    }

    while ( 0 != dwByteCount )
    {
        if ( fVerbose )
            printf( "usn %#I64x id %#I64x ",
                    pUsnRec->Usn,
                    pUsnRec->FileReferenceNumber );

        static WCHAR awcPath[ MAX_PATH_WCHARS ];

        IdToPath( hVol, pUsnRec->FileReferenceNumber, wcVol, awcPath );

        ULONG r = pUsnRec->Reason;

        if ( 0 == awcPath[0] || ( r & USN_REASON_RENAME_OLD_NAME ) )
        {
            IdToPath( hVol, pUsnRec->ParentFileReferenceNumber, wcVol, awcPath );

            // If the parent directory has already been deleted, just
            // print the filename.

            if ( 0 == awcPath[0] )
                printf( "(%.*ws) ",
                        pUsnRec->FileNameLength / sizeof WCHAR,
                        &pUsnRec->FileName );
            else
                printf( "%ws\\%.*ws ",
                        awcPath,
                        pUsnRec->FileNameLength / sizeof WCHAR,
                        &pUsnRec->FileName );
        }
        else
            printf( "%ws ", awcPath );

        if ( r & USN_REASON_DATA_OVERWRITE )
            printf( "DATA_OVERWRITE " );
        if ( r & USN_REASON_DATA_EXTEND )
            printf( "DATA_EXTEND " );
        if ( r & USN_REASON_DATA_TRUNCATION )
            printf( "DATA_TRUNCATION " );
        if ( r & USN_REASON_NAMED_DATA_OVERWRITE )
            printf( "NAMED_DATA_OVERWRITE " );
        if ( r & USN_REASON_NAMED_DATA_EXTEND )
            printf( "NAMED_DATA_EXTEND " );
        if ( r & USN_REASON_NAMED_DATA_TRUNCATION )
            printf( "NAMED_DATA_TRUNCATION " );
        if ( r & USN_REASON_FILE_CREATE )
            printf( "FILE_CREATE " );
        if ( r & USN_REASON_FILE_DELETE )
            printf( "FILE_DELETE " );
        if ( r & USN_REASON_EA_CHANGE )
            printf( "EA_CHANGE " );
        if ( r & USN_REASON_SECURITY_CHANGE )
            printf( "SECURITY_CHANGE " );
        if ( r & USN_REASON_RENAME_OLD_NAME )
            printf( "RENAME_OLD_NAME " );
        if ( r & USN_REASON_RENAME_NEW_NAME )
            printf( "RENAME_NEW_NAME " );
        if ( r & USN_REASON_INDEXABLE_CHANGE )
            printf( "INDEXABLE_CHANGE " );
        if ( r & USN_REASON_BASIC_INFO_CHANGE )
            printf( "BASIC_INFO_CHANGE " );
        if ( r & USN_REASON_HARD_LINK_CHANGE )
            printf( "HARD_LINK_CHANGE " );
        if ( r & USN_REASON_COMPRESSION_CHANGE )
            printf( "COMPRESSION_CHANGE " );
        if ( r & USN_REASON_ENCRYPTION_CHANGE )
            printf( "ENCRYPTION_CHANGE " );
        if ( r & USN_REASON_OBJECT_ID_CHANGE )
            printf( "OBJECT_ID_CHANGE " );
        if ( r & USN_REASON_REPARSE_POINT_CHANGE )
            printf( "REPARSE_POINT_CHANGE " );
        if ( r & USN_REASON_STREAM_CHANGE )
            printf( "STREAM_CHANGE " );
        if ( r & USN_REASON_CLOSE )
            printf( "CLOSE " );

        printf( "\n" );

        if ( pUsnRec->RecordLength <= dwByteCount )
        {
            dwByteCount -= pUsnRec->RecordLength;
            pUsnRec = (USN_RECORD *) ((PCHAR) pUsnRec + pUsnRec->RecordLength );
        }
        else
        {
            printf( "Usn read fsctl returned bogus dwByteCount %#x\n", dwByteCount );
            exit( -1 );
        }
    } 

    return usnNextStart;
} //PrintUsnRecords

int __cdecl main(
    int    argc,
    char * argv[] )
{
    if ( 2 != argc && 3 != argc )
        usage();

    if ( 3 == argc && argv[2][1] == 'v' )
        fVerbose = TRUE;

    WCHAR wcVol = argv[1][0];

    WCHAR wszVolumePath[] = L"\\\\.\\a:";
    wszVolumePath[4] = wcVol;
    HANDLE hVolume = CreateFile( wszVolumePath,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,
                                 NULL );

    if ( INVALID_HANDLE_VALUE == hVolume )
    {
        printf( "Usn volume open failed %d, check for admin privileges\n", GetLastError() );
        usage();
    }

    HANDLE hEvent = CreateEvent( 0, TRUE, FALSE, 0 );

    //
    // Get the Journal ID
    //

    USN_JOURNAL_DATA UsnJournalInfo;
    IO_STATUS_BLOCK IoSB;

    NTSTATUS status = NtFsControlFile( hVolume,
                                       hEvent,
                                       0,
                                       0,
                                       &IoSB,
                                       FSCTL_QUERY_USN_JOURNAL,
                                       0,
                                       0,
                                       &UsnJournalInfo,
                                       sizeof UsnJournalInfo );
    if ( STATUS_PENDING == status )
        WaitForSingleObject( hEvent, INFINITE );

    if ( !NT_SUCCESS(status) || !NT_SUCCESS(IoSB.Status) )
    {
        printf( "Error %#x / %#x returned from QUERY_USN_JOURNAL\n", status, IoSB.Status );
        return -1;
    }

    USN usnMax = UsnJournalInfo.NextUsn;

    do
    {
        READ_USN_JOURNAL_DATA usnData = { usnMax, MAXULONG, 0, 0, 1, UsnJournalInfo.UsnJournalID };

        static ULONGLONG readBuffer[2048];

        status = NtFsControlFile( hVolume,
                                  hEvent,
                                  0,
                                  0,
                                  &IoSB,
                                  FSCTL_READ_USN_JOURNAL,
                                  &usnData,
                                  sizeof usnData,
                                  &readBuffer,
                                  sizeof readBuffer );

        if ( STATUS_PENDING == status )
            WaitForSingleObject( hEvent, INFINITE );

        if ( NT_SUCCESS( status ) )
            status = IoSB.Status;

        if ( !NT_SUCCESS( status ) )
        {
            printf( "FSCTL_READ_USN_JOURNAL failed %#x\n", status );
            return -1;
        }

        usnMax = PrintUsnRecords( hVolume, wcVol, &IoSB, readBuffer, usnMax );
    } while ( TRUE );

    return 0;
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\abktize.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       abktize.cxx
//
//  Contents:   Asynchronous Bucket->Window Conversion.
//
//  Classes:
//
//  Functions:
//
//  History:    5-25-95   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop


#include <bigtable.hxx>
#include <execute.hxx>

#include "tblbuket.hxx"
#include "tabledbg.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CAsyncBucketExploder ~ctor
//
//  Arguments:  [largeTable]   -- LargeTable driving the bucket->window
//                                conversion.
//              [pBucket]      -- The bucket to expand into a window.
//              [widToPin]     -- WORKID to pin.
//              [fDoWidToPath] -- TRUE if table holds 'fake' wids, and bucket
//                                must convert fake wid to path.
//
//  History:    5-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAsyncBucketExploder::CAsyncBucketExploder( CLargeTable &        largeTable,
                                            XPtr<CTableBucket> & xBucket,
                                            WORKID               widToPin,
                                            BOOL                 fDoWidToPath )
                         : PWorkItem(eSigCAsyncBucketExploder),
                           _largeTable(largeTable),
                           _pBucket(0),
                           _widToPin(widToPin),
                           _fDoWidToPath( fDoWidToPath ),
                           _pQueryExecute(0),
                           _refCount(1),
                           _fOnWorkQueue(FALSE),
                           _fOnLTList(FALSE),
                           _status(STATUS_SUCCESS)

{
    Close();        // Initialize the links to point to self.

    _pBucket = xBucket.Acquire();
    Win4Assert( 0 != _pBucket );

    END_CONSTRUCTION( CAsyncBucketExploder );
}


//+---------------------------------------------------------------------------
//
//  Function:   CAsyncBucketExploder
//
//  Synopsis:   ~dtor
//
//  History:    5-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAsyncBucketExploder::~CAsyncBucketExploder()
{
    Win4Assert( 0 == _refCount );
    Win4Assert( IsSingle() );  // Is not linked in the list
    Win4Assert( !_fOnWorkQueue );
    Win4Assert( !_fOnLTList );

    if ( 0 != _pQueryExecute )
    {
        _pQueryExecute->Release();
    }

    delete _pBucket;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoIt
//
//  Synopsis:   The main method called by the worker thread .
//
//  Arguments:  [pThread] -- Thread executing request.
//
//  History:    5-25-95   srikants   Created
//
//  Notes:      At the end, if this object in the LargeTable's list, it will
//              be removed from the large table list. While doing that,
//              DO NOT hold the mutex because there LT can call into this
//              object with its lock held. We don't want to deadlock.
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::DoIt( CWorkThread * pThread )
{

    {
        CLock   lock(_mutex);
        Win4Assert( 0 != _pBucket );
        Win4Assert( 0 != _pQueryExecute );
        _fOnWorkQueue = FALSE;
    }

    AddRef();

    //
    // None of these calls throw
    //

    CBucketRowIter  bktIter( *_pBucket, _fDoWidToPath );

    _pQueryExecute->Update( bktIter );

    //
    // If it is on the large table queue, remove it from the lt queue.
    //
    if ( _fOnLTList )
    {
        _fOnLTList = FALSE;
        _largeTable._RemoveFromExplodeList(this);
    }

    _evt.Set();

    Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   SetQuery
//
//  Synopsis:   Sets the query object to be used for bucket->window conversion.
//
//  Arguments:  [pQExecute] - The Query object to use for bucket->window
//              conversion.
//
//  History:    5-25-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::SetQuery( CQAsyncExecute * pQExecute )
{
    CLock   lock(_mutex);
    Win4Assert( 0 == _pQueryExecute && 0 != pQExecute );
    _pQueryExecute = pQExecute;
    _pQueryExecute->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   SetOnLTList
//
//  Synopsis:   Sets the internal state that it is on the large table's
//              list also.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::SetOnLTList()
{
    CLock   lock(_mutex);
    Win4Assert( !_fOnLTList );
    _fOnLTList = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToWorkQueue
//
//  Synopsis:   Adds this item to the work queue.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::AddToWorkQueue()
{
    CLock   lock(_mutex);
    Win4Assert( !_fOnWorkQueue );

    _fOnWorkQueue = TRUE;
    TheWorkQueue.Add(this);
}

//+---------------------------------------------------------------------------
//
//  Function:   Abort
//
//  Synopsis:   Aborts the work item by removing it from the work queue
//              (if present). It also releases the query object.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::Abort()
{

    CLock   lock(_mutex);

    Win4Assert( IsSingle() );   // Must not be on any list at this stage
    _fOnLTList = FALSE;

    if ( _fOnWorkQueue )
    {
        TheWorkQueue.Remove(this);
        _fOnWorkQueue = FALSE;
    }

    if ( 0 != _pQueryExecute )
    {
        _pQueryExecute->Release();
        _pQueryExecute = 0;
    }

    _evt.Set(); // Wake up any thread waiting on us
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRef
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::AddRef()
{
    InterlockedIncrement(&_refCount);
}

//+---------------------------------------------------------------------------
//
//  Function:   Release
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAsyncBucketExploder::Release()
{
    Win4Assert( _refCount > 0 );
    if ( InterlockedDecrement(&_refCount) <= 0 )
    {
        delete this;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\webhits\webhits.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       webhits.cxx
//
//  History:    05-20-96 t-matts Created
//              03-03-97 dlee    Converted to isapi
//
//  Contents:   This is the main() for the hit-highliting feature. The
//              CGI environment variables are read, yielding the filename
//              and the textual form of the restriction. The textual form
//              is then converted to internal form. The document is then
//              scanned for hits, and the positions contained in those
//              hits are sorted. Finally, HTML tags are inserted in the order
//              in which the distinct positions appear in the document, to
//              allow the user to navigate.
//
//--------------------------------------------------------------------------

#include<pch.cxx>
#pragma hdrstop

#include <cidebug.hxx>
#include <codepage.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <cpid.hxx>
#include <dblink.hxx>
#include <imprsnat.hxx>
#include <regevent.hxx>
#include <dynstack.hxx>
#include <cimbmgr.hxx>

#include "webhits.hxx"
#include "webdbg.hxx"
#include "whmsg.h"
#include "linkhits.hxx"

#define _DECL_DLLMAIN 1

DECLARE_INFOLEVEL (web);
DECLARE_INFOLEVEL (ci);

const int ERROR_MESSAGE_SIZE=512;

BOOL g_fShutdown = TRUE;
LONG g_cThreads = 0;
CWebhitsInfo * g_pWebhitsInfo = 0;

void OutputErrorMessage( CWebServer & webServer,
                         CLanguageInfo & LanguageInfo,
                         DWORD dwMsgId,
                         WCHAR const * pwcIdqPPath,
                         WCHAR const * pwcIdqVPath,
                         WCHAR const * pwcHtwPPath,
                         WCHAR const * pwcHtwVPath,
                         WCHAR const * pwcWebhitsPPath,
                         WCHAR const * pwcWebhitsVPath,
                         WCHAR const * pwszDefaultMsg = 0,
                         WCHAR const * pwszFileName = 0,
                         ULONG ulFileLine = 0 );

//+---------------------------------------------------------------------------
//
//  Function:   GetVPathInfo
//
//  Synopsis:   Convers a vpath to a ppath
//
//  Arguments:  [webServer]    -- Used for the translation
//              [pwcVPath]     -- VPath to translate
//              [dwAccessMask] -- Access required for file, or 0 for none
//              [dwFlags]      -- Returns vpath flags (HSE_URL_FLAGS_*)
//
//  Returns:    pointer to PPath allocated on the heap.
//
//  History:    3-04-97   dlee   Created
//
//----------------------------------------------------------------------------

WCHAR * GetVPathInfo(
    CWebServer &  webServer,
    WCHAR const * pwcVPath,
    DWORD         dwAccessMask,
    DWORD &       dwFlags )
{
    WCHAR *pwc = 0;

    TRY
    {
        WCHAR awcPPath[MAX_PATH];
        dwFlags = webServer.GetPhysicalPath( pwcVPath,
                                             awcPPath,
                                             sizeof awcPPath / sizeof WCHAR,
                                             dwAccessMask );

        if ( ( 0 == wcsstr( awcPPath, L"../" ) ) &&
             ( 0 == wcsstr( awcPPath, L"..\\" ) ) )
        {
            ULONG cwc = wcslen( awcPPath ) + 1;
            pwc = new WCHAR[ cwc ];
            RtlCopyMemory( pwc, awcPPath, cwc * sizeof WCHAR );
        }
    }
    CATCH( CException, e )
    {
        // returning 0 is sufficient
    }
    END_CATCH

    return pwc;
} //GetVPathInfo

//+---------------------------------------------------------------------------
//
//  Function:   GetWebhitsVPathInfo
//
//  Synopsis:   Converts vpaths to ppaths for the query, template, and
//              webhits files.
//
//  Arguments:  [vars]      -- Source of vpaths, sink of ppaths
//              [webServer] -- Used for the translations
//
//  History:    9-06-96   srikants   Created
//
//----------------------------------------------------------------------------

void GetWebhitsVPathInfo(
    CGetEnvVars & vars,
    CWebServer &  webServer )
{
    // Translate the path of the query (idq) file if one is given.

    DWORD dwFlags;

    if ( vars.GetQueryFileVPath() )
    {
        WCHAR * pwc = GetVPathInfo( webServer,
                                    vars.GetQueryFileVPath(),
                                    0,
                                    dwFlags );

        if ( 0 == pwc )
            THROW( CWTXException( MSG_WEBHITS_IDQ_NOT_FOUND,
                                  vars.GetQueryFileVPath(),
                                  0 ) );

        vars.AcceptQueryFilePPath( pwc, dwFlags );
        webDebugOut(( DEB_ITRACE, "Query file '%ws'\n", pwc ));
    }

    // Translate the path of the template (htw) file if one is given.

    if ( vars.GetTemplateFileVPath() )
    {
        WCHAR * pwc = GetVPathInfo( webServer,
                                    vars.GetTemplateFileVPath(),
                                    0,
                                    dwFlags );

        if ( 0 == pwc )
            THROW( CWTXException( MSG_WEBHITS_NO_SUCH_TEMPLATE,
                                  vars.GetTemplateFileVPath(),
                                  0 ) );

        vars.AcceptTemplateFilePPath( pwc, dwFlags );
        webDebugOut(( DEB_ITRACE, "Template file '%ws'\n", pwc ));
    }

    // Translate the path of the WebHits file being displayed.  Read access
    // is required for this file.

    if ( vars.GetWebHitsFileVPath() )
    {
        WCHAR * pwc = GetVPathInfo( webServer,
                                    vars.GetWebHitsFileVPath(),
                                    HSE_URL_FLAGS_READ,
                                    dwFlags );

        if ( 0 == pwc )
            THROW( CException(MSG_WEBHITS_PATH_INVALID) );

        vars.AcceptWebHitsFilePPath( pwc, dwFlags );
        webDebugOut(( DEB_ITRACE, "WebHits file '%ws'\n", pwc ));
    }
    else
    {
        THROW( CException(MSG_WEBHITS_PATH_INVALID) );
    }
} //GetWebhitsVPathInfo

//+---------------------------------------------------------------------------
//
//  Function:   ProcessWebRequest
//
//  Synopsis:   Main driver method for webhits.
//
//  Arguments:  [webServer]  -- web server to use
//
//  History:    9-04-96   srikants   Created
//
//----------------------------------------------------------------------------

DWORD ProcessWebRequest( CWebServer & webServer )
{
    DWORD hse = HSE_STATUS_SUCCESS;

    //
    // Initialize the locale and codepage.
    //
    LCID lcid = GetLCID( webServer );
    ULONG urlCodePage = GetBrowserCodepage( webServer, lcid );

    CLanguageInfo langInfo;

    //
    // Set the client and output locale info to be the same as
    // the client info. If a different value is set
    // via CiLocale, it will be changed when the querystring is parsed.
    //

    langInfo.SetUrlLangInfo( urlCodePage, lcid );
    langInfo.SetRestrictionLangInfo( urlCodePage, lcid );

    CURLUnescaper unescaper( langInfo.GetUrlCodePage() );
    CCollectVar varRetriever( unescaper, webServer );

    XArray<WCHAR> xwszQueryFile;

    WCHAR awcWebhitsPPath[ MAX_PATH ];
    WCHAR awcWebhitsVPath[ MAX_PATH ];
    WCHAR awcIdqPPath[ MAX_PATH ];
    WCHAR awcIdqVPath[ MAX_PATH ];
    WCHAR awcHtwPPath[ MAX_PATH ];
    WCHAR awcHtwVPath[ MAX_PATH ];

    WCHAR const * pwcWebhitsPPath = 0;
    WCHAR const * pwcWebhitsVPath = 0;
    WCHAR const * pwcIdqPPath = 0;
    WCHAR const * pwcIdqVPath = 0;
    WCHAR const * pwcHtwPPath = 0;
    WCHAR const * pwcHtwVPath = 0;

    TRY
    {
        //
        // Refresh the registry values if necessary
        //

        g_pWebhitsInfo->Refresh();

        //
        // Are there too many threads doing webhits?
        //

        if ( g_cThreads > (LONG) g_pWebhitsInfo->GetMaxRunningWebhits() )
        {
            webDebugOut(( DEB_WARN,
                          "%d instances of webhits running\n",
                          g_cThreads ));
            THROW( CException( MSG_WEBHITS_TOO_MANY_COPIES ) );
        }

        //
        // Retrieve the necessary environment variables.
        //

        CGetEnvVars variables( webServer,
                               langInfo,
                               varRetriever,
                               unescaper );

        if (variables.GetQueryFileVPath())
        {
            xwszQueryFile.Init( wcslen(variables.GetQueryFileVPath())+1 );
            wcscpy( xwszQueryFile.GetPointer(), variables.GetQueryFileVPath() );
        }

        GetWebhitsVPathInfo( variables, webServer );

        //
        // construct Property List with static properties
        //

        XInterface<CEmptyPropertyList> xlist;

        //
        // If an idq file was specified, then parse the [NAMES] section of
        // that file to obtain custom properties
        //

        if ( variables.GetQueryFilePPath() )
        {
            Win4Assert( wcslen( variables.GetQueryFilePPath() ) < MAX_PATH );
            wcscpy( awcIdqPPath, variables.GetQueryFilePPath() );
            pwcIdqPPath = awcIdqPPath;

            Win4Assert( wcslen( variables.GetQueryFileVPath() ) < MAX_PATH );
            wcscpy( awcIdqVPath, variables.GetQueryFileVPath() );
            pwcIdqVPath = awcIdqVPath;
            xlist.Set( new CLocalGlobalPropertyList( GetGlobalStaticPropertyList(),
                                                     TRUE,
                                                     variables.GetQueryFilePPath(),
                                                     langInfo.GetUrlCodePage()) );
            ULONG iLine;
            WCHAR * pwszFile;

            SCODE sc = ((CLocalGlobalPropertyList *)xlist.GetPointer())->CheckError( iLine, &pwszFile );
            if (FAILED(sc))
                THROW(CException(sc));
        }
        else
            xlist.Set(GetGlobalStaticPropertyList());

        //
        // If a template file is specified, it should be parsed.
        //

        XPtr<CWebhitsTemplate> xTemplate;

        if ( variables.GetTemplateFileVPath() )
        {
            Win4Assert( wcslen( variables.GetTemplateFilePPath() ) < MAX_PATH );
            wcscpy( awcHtwPPath, variables.GetTemplateFilePPath() );
            pwcHtwPPath = awcHtwPPath;

            Win4Assert( wcslen( variables.GetTemplateFileVPath() ) < MAX_PATH );
            wcscpy( awcHtwVPath, variables.GetTemplateFileVPath() );
            pwcHtwVPath = awcHtwVPath;

            CWebhitsTemplate * pTemplate =
                    new CWebhitsTemplate( variables,
                                          langInfo.GetOutputCodePage() );
            xTemplate.Set( pTemplate );
        }

        //
        // convert textual query into CDbRestriction
        //

        CInternalQuery query( variables, xlist.GetReference(), langInfo.GetQueryLCID() );

        Win4Assert( wcslen( variables.GetWebHitsFilePPath() ) < MAX_PATH );
        wcscpy( awcWebhitsPPath, variables.GetWebHitsFilePPath() );
        pwcWebhitsPPath = awcWebhitsPPath;

        Win4Assert( wcslen( variables.GetWebHitsFileVPath() ) < MAX_PATH );
        wcscpy( awcWebhitsVPath, variables.GetWebHitsFileVPath() );
        pwcWebhitsVPath = awcWebhitsVPath;

        //
        // Verify a consistent SSL-setting for .htw and webhits files.
        // This fixes the problem where the webhits file requires SSL,
        // but the template file doesn't, since a port can't change its
        // SSL setting on the fly.  A work-around would be to do a redirect
        // to a bogus .htw file in the same virtual directory as the
        // webhits file to force SSL, but that seemed overkill.
        //

        if ( variables.GetTemplateFileVPath() )
        {
            //
            // This is a complete list of SSL-related flags.
            //

            const DWORD dwSSL = HSE_URL_FLAGS_SSL |
                                HSE_URL_FLAGS_NEGO_CERT |
                                HSE_URL_FLAGS_REQUIRE_CERT |
                                HSE_URL_FLAGS_MAP_CERT |
                                HSE_URL_FLAGS_SSL128;

            DWORD dwTemplate = ( variables.GetTemplateFileFlags() & dwSSL );
            DWORD dwWebHits = ( variables.GetWebHitsFileFlags() & dwSSL );

            if ( ( dwTemplate != dwWebHits ) &&
                 ( 0 != dwWebHits ) )
            {
                webDebugOut(( DEB_WARN,
                              "SSL mismatch template: 0x%x, webhits: 0x%x\n",
                              dwTemplate, dwWebHits ));
                THROW( CException( MSG_WEBHITS_INCONSISTENT_SSL ) );
            }
        }

        //
        // Impersonate if the file being webhit is remote
        //

        CImpersonateRemoteAccess imp( 0 );

        if ( CImpersonateRemoteAccess::IsNetPath( pwcWebhitsPPath ) )
        {
            CImpersonationTokenCache * pCache = g_pWebhitsInfo->GetTokenCache( webServer );
            imp.SetTokenCache( pCache );

            // Flip the slashes -- the token cache expects backslashes...

            unsigned cwc = wcslen( pwcWebhitsVPath );
            Win4Assert( cwc < MAX_PATH );
            WCHAR awcTempVPath[ MAX_PATH ];

            for ( unsigned c = 0; c < cwc; c++ )
            {
                if ( L'/' == pwcWebhitsVPath[c] )
                    awcTempVPath[c] = L'\\';
                else
                    awcTempVPath[c] = pwcWebhitsVPath[c];
            }

            awcTempVPath[ cwc ] = 0;

            //
            // If impersonation fails, try rescanning the metabase.
            // There may have been an update to vroot info.
            // Note that revocation may take a long time as a result.
            // It's really unlikely we'll have to reinit very often
            // unless the server is misconfigured.
            //

            if ( !imp.ImpersonateIfNoThrow( pwcWebhitsPPath, awcTempVPath ) )
            {
                pCache->ReInitializeIISScopes();
                imp.ImpersonateIf( pwcWebhitsPPath, awcTempVPath );
            }
        }

        //
        // construct framework for highlighting, and highlight hits
        //

        query.CreateISearch( pwcWebhitsPPath );

        //
        // two cases - either summary or full hit-highlighting
        //

        CReleasableLock lock( g_pWebhitsInfo->GetNonThreadedFilterMutex(),
                              FALSE );

        if (variables.GetHiliteType() == CGetEnvVars::SUMMARY)
        {
            XPtr<CDocument> xDoc( new CDocument(
                                  (WCHAR*) pwcWebhitsPPath,
                                  CLinkQueryHits::BOGUS_RANK,
                                  query.GetISearchRef(),
                                  g_pWebhitsInfo->GetMaxWebhitsCpuTime(),
                                  lock,
                                  xlist.GetReference(),
                                  g_pWebhitsInfo->GetDisplayScript() ) );

            PHttpOutput httpOutput( webServer, langInfo );
            httpOutput.Init( &variables, xTemplate.GetPointer() );

            HitIter iterator;
            iterator.Init( xDoc.GetPointer() );

            httpOutput.OutputHTMLHeader();

            if ( variables.IsFixedFont() )
                httpOutput.OutputPreformattedTag();

            CExtractHits hitExtractor( xDoc.GetReference(),
                                       iterator,
                                       httpOutput );

            httpOutput.OutputHTMLFooter();
        }
        else
        {
            PHttpFullOutput httpOutput( webServer, langInfo );
            httpOutput.Init(&variables, xTemplate.GetPointer());

            XPtr<CLinkQueryHits> xLQH( new CLinkQueryHits(
                                       query,
                                       variables,
                                       httpOutput,
                                       g_pWebhitsInfo->GetMaxWebhitsCpuTime(),
                                       lock,
                                       xlist.GetReference(),
                                       g_pWebhitsInfo->GetDisplayScript() ) );

            httpOutput.OutputHTMLHeader();
            xLQH->InsertLinks();
            httpOutput.OutputHTMLFooter();
        }
    }
    CATCH( CPListException, ple )
    {
        WCHAR wcTempBuffer[ERROR_MESSAGE_SIZE];

        wsprintf( wcTempBuffer,
                  L"Property list parsing query file %ls failed with error 0x%X\n",
                  xwszQueryFile.GetPointer(),
                  ple.GetPListError() );

        OutputErrorMessage( webServer,
                            langInfo,
                            ple.GetPListError(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath,
                            wcTempBuffer,
                            xwszQueryFile.GetPointer(),
                            ple.GetLine() );
    }
    AND_CATCH( CWTXException, we )
    {
        WCHAR wcTempBuffer[ERROR_MESSAGE_SIZE];

        wsprintf( wcTempBuffer,
                  L"Parsing template file %ls failed with error 0x%X\n",
                  we.GetFileName(),
                  we.GetErrorCode() );

        OutputErrorMessage( webServer,
                            langInfo,
                            we.GetErrorCode(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath,
                            wcTempBuffer,
                            we.GetFileName(),
                            we.GetLineNumber() );
    }
    AND_CATCH( CParserException, pe )
    {
        WCHAR wcTempBuffer[ERROR_MESSAGE_SIZE];
        wsprintf( wcTempBuffer,
                  L"Parsing of QUERY_STRING failed with error 0x%X\n",
                  pe.GetErrorCode() );

        OutputErrorMessage( webServer,
                            langInfo,
                            pe.GetParseError(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath,
                            wcTempBuffer );
    }
    AND_CATCH( CException,e )
    {
        OutputErrorMessage( webServer,
                            langInfo,
                            e.GetErrorCode(),
                            pwcIdqPPath,
                            pwcIdqVPath,
                            pwcHtwPPath,
                            pwcHtwVPath,
                            pwcWebhitsPPath,
                            pwcWebhitsVPath );
    }
    END_CATCH

    return hse;
} //ProcessWebRequest

//+---------------------------------------------------------------------------
//
//  Function:   OutputErrorMessage
//
//  Synopsis:   Outputs an error message based on the msg id given. It first
//              looks up for the error in webhits.dll, query.dll, then in
//              kernel32.dll.
//              If no message is found, it then uses the default message.
//
//  Arguments:  [dwMsgId]        - Message id
//              [pwszDefaultMsg] - Pointer to the default message. Will be
//                                 used if there is no pre-formatted message.
//              [pwszFileName]   - File name to be printed prior to the error
//                                 message.  Will not be printed if null.
//              [ulFileLine]     - File line number.  Not printed if zero.
//
//  History:    9-04-96   srikants   Created
//
//----------------------------------------------------------------------------

void OutputErrorMessage( CWebServer & webServer,
                         CLanguageInfo & langInfo,
                         DWORD dwMsgId,
                         WCHAR const * pwcIdqPPath,
                         WCHAR const * pwcIdqVPath,
                         WCHAR const * pwcHtwPPath,
                         WCHAR const * pwcHtwVPath,
                         WCHAR const * pwcWebhitsPPath,
                         WCHAR const * pwcWebhitsVPath,
                         WCHAR const * pwszDefaultMsg,
                         WCHAR const * pwszFileName,
                         ULONG ulFileLine )
{
    CImpersonateSystem system;

    //
    //  If the error was the result of an access denied problem, then simply
    //  return a 401 error to the browser if the path allows authentication
    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //

    if ( (STATUS_ACCESS_DENIED                              == dwMsgId) ||
         (STATUS_NETWORK_ACCESS_DENIED                      == dwMsgId) ||
         (HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED )         == dwMsgId) ||
         (HRESULT_FROM_WIN32( ERROR_INVALID_ACCESS )        == dwMsgId) ||
         (HRESULT_FROM_WIN32( ERROR_NETWORK_ACCESS_DENIED ) == dwMsgId) )
    {
        WCHAR const * pwcVPath = 0;
        WCHAR const * pwcPPath = 0;

        if ( 0 != pwcWebhitsVPath )
        {
            pwcPPath = pwcWebhitsPPath;
            pwcVPath = pwcWebhitsVPath;
        }
        else if ( 0 != pwcHtwVPath )
        {
            pwcPPath = pwcHtwPPath;
            pwcVPath = pwcHtwVPath;
        }
        else
        {
            pwcPPath = pwcIdqPPath;
            pwcVPath = pwcIdqVPath;
        }

        Win4Assert( 0 != pwcPPath );
        Win4Assert( 0 != pwcVPath );

        webDebugOut(( DEB_ITRACE, "error P and V paths: '%ws', '%ws'\n",
                      pwcPPath, pwcVPath ));

        CMetaDataMgr mdMgr( FALSE, W3VRoot, webServer.GetServerInstance() );
        ULONG Authorization = mdMgr.GetVPathAuthorization( pwcVPath );
        webDebugOut(( DEB_ITRACE, "authorization: 0x%x\n", Authorization ));

        // If the virtual directory doesn't support just anonymous,
        // this is not a remote physical path, try to authenticate.

        if ( 0 != Authorization &&
             MD_AUTH_ANONYMOUS != Authorization &&
             !CImpersonateRemoteAccess::IsNetPath( pwcPPath ) )
        {
            webDebugOut(( DEB_WARN,
                          "mapping 0x%x to 401 access denied\n",
                          dwMsgId ));
            webServer.WriteHeader( 0, "401 Access denied" );
            const char * pcAccessDenied = "Access is denied.";
            webServer.WriteClient( (BYTE *) pcAccessDenied,
                                   strlen( pcAccessDenied ) );
            return;
        }
    }

    WCHAR awcTempBuffer[ERROR_MESSAGE_SIZE];
    WCHAR * pwszErrorMessage = awcTempBuffer;
    ULONG cchAvailMessage = ERROR_MESSAGE_SIZE;

    //
    // Don't pass a specific lang id to FormatMessage since it will
    // fail if there's no message in that language. Instead set
    // the thread locale, which will get FormatMessage to use a search
    // algorithm to find a message of the appropriate language or
    // use a reasonable fallback msg if there's none.
    //
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale( langInfo.GetQueryLCID() );

    if (pwszFileName != 0)
    {
        //
        //  These are errors encountered while parsing the [names] section
        //
        DWORD_PTR args [] = {
                         (DWORD_PTR) pwszFileName,
                         (DWORD_PTR) ulFileLine,
                        };

        NTSTATUS MsgNum = MSG_WEBHITS_FILE_MESSAGE;
        if ( 0 != ulFileLine )
            MsgNum = MSG_WEBHITS_FILE_LINE_MESSAGE;

        ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      GetModuleHandle(L"webhits.dll"),
                                      MsgNum,
                                      0,
                                      pwszErrorMessage,
                                      cchAvailMessage,
                                      (va_list *) args );
        pwszErrorMessage += cchMsg;
        cchAvailMessage -= cchMsg;
    }

    if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"webhits.dll"),
                         dwMsgId,
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"Query.dll"),
                         dwMsgId,
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"kernel32.dll"),
                         dwMsgId,
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) &&
         !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         GetModuleHandle(L"kernel32.dll"),
                         HRESULT_CODE(dwMsgId),
                         0,
                         pwszErrorMessage,
                         cchAvailMessage,
                         0 ) )
    {
         DWORD dwError = GetLastError();
         webDebugOut(( DEB_ERROR, "Format Message failed with error 0x%X\n",
                                  dwError ));
         if ( !pwszDefaultMsg )
         {
             wsprintf( pwszErrorMessage,
                       L"Error 0x%X occurred while running webhits \n",
                       dwMsgId );
         }
         else
         {
             Win4Assert( wcslen( pwszDefaultMsg ) < cchAvailMessage );
             wsprintf( pwszErrorMessage, L"%ws\n", pwszDefaultMsg );
         }
     }

    SetThreadLocale(SaveLCID);

    PHttpOutput httpOutput( webServer, langInfo );

    httpOutput.OutputErrorHeader();
    httpOutput.OutputErrorMessage( awcTempBuffer, wcslen(awcTempBuffer) );
    httpOutput.OutputHTMLFooter();
} //OutputErrorMessage

//+---------------------------------------------------------------------------
//
//  Function:   GetExtensionVersion - public
//
//  Synposis:   Returns extension info to the server.  This is called before
//              HttpExtensionProc is called, and it is called in System
//              context, so any initialization that requires this context
//              must be handled here.
//
//  Arguments:  [pVer]  - where the info goes
//
//  History:    96-Apr-15   dlee        Added header
//
//----------------------------------------------------------------------------

BOOL WINAPI GetExtensionVersion(
    HSE_VERSION_INFO * pVer )
{
    BOOL fOK = TRUE;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        Win4Assert( g_fShutdown );
        Win4Assert( 0 == g_pWebhitsInfo );

        pVer->dwExtensionVersion = MAKELONG( 0, 3 );
        strcpy( pVer->lpszExtensionDesc, "Indexing Service webhits extension" );

        g_pWebhitsInfo = new CWebhitsInfo();
        g_fShutdown = FALSE;
    }
    CATCH( CException, e )
    {
        fOK = FALSE;

        webDebugOut(( DEB_WARN,
                      "GetExtensionVersion failed 0x%x\n",
                      e.GetErrorCode() ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return fOK;
} //GetExtensionVersion

//+---------------------------------------------------------------------------
//
//  Function:   TerminateExtension, public
//
//  Synposis:   Called by IIS during shutdown
//
//  History:    3-Mar-97   dlee       Created
//
//----------------------------------------------------------------------------

BOOL WINAPI TerminateExtension(
    DWORD dwFlags )
{
    TRANSLATE_EXCEPTIONS;

    BOOL fOK = FALSE;

    if ( dwFlags & HSE_TERM_MUST_UNLOAD )
    {
        TRY
        {
            Win4Assert( !g_fShutdown );
            g_fShutdown = TRUE;

            webDebugOut(( DEB_WARN,
                          "Mandatory extension unload. Shutting down webhits.\n" ));

            // wait for all the isapi request threads to finish

            while ( 0 != g_cThreads )
                Sleep( 50 );

            delete g_pWebhitsInfo;
            g_pWebhitsInfo = 0;

            CIShutdown();
        }
        CATCH( CException, e )
        {
            // ignore
        }
        END_CATCH

        fOK = TRUE;
    }

    webDebugOut(( DEB_WARN,
                  "webhits extension unload: 0x%x. Flags = 0x%x\n",
                  fOK, dwFlags ));

    UNTRANSLATE_EXCEPTIONS;

    return fOK;
} //TerminateExtension

//+---------------------------------------------------------------------------
//
//  Function:   HttpExtensionProc, public
//
//  Synposis:   Handles a request from the web server
//
//  Arguments:  [pEcb] -- block from the server
//
//  History:    3-Mar-97   dlee       Created
//
//----------------------------------------------------------------------------

DWORD WINAPI HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pEcb )
{
    if ( g_fShutdown )
    {
        pEcb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
        return HSE_STATUS_ERROR;
    }

    InterlockedIncrement( & g_cThreads );

    CWebServer webServer( pEcb );
    DWORD hseStatus = HSE_STATUS_ERROR;
    webServer.SetHttpStatus( HTTP_STATUS_OK );

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        XCom xcom;

        hseStatus = ProcessWebRequest( webServer );
    }
    CATCH( CException, e )
    {
        hseStatus = HSE_STATUS_ERROR;
        webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    Win4Assert( HSE_STATUS_PENDING != hseStatus );

    InterlockedDecrement( & g_cThreads );

    return hseStatus;
} //HttpExtensionProc

//+---------------------------------------------------------------------------
//
//  Method:     CWebhitsInfo::CWebhitsInfo, public
//
//  Synposis:   Constructs a webhits info object
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

CWebhitsInfo::CWebhitsInfo() :
    _regChangeEvent( wcsRegAdminTree )
{
    ReadRegValues();
} //CWebhitsInfo

//+---------------------------------------------------------------------------
//
//  Method:     CWebhitsInfo::Refresh, public
//
//  Synposis:   Checks to see if the registry has changed and refreshes it
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

void CWebhitsInfo::Refresh()
{
    CLock lock( _mutex );

    ULONG res = WaitForSingleObject( _regChangeEvent.GetEventHandle(), 0 );

    if ( WAIT_OBJECT_0 == res )
    {
        ReadRegValues();
        _regChangeEvent.Reset();
    }
} //Refresh

//+---------------------------------------------------------------------------
//
//  Method:     CWebhitsInfo::ReadRegValues
//
//  Synposis:   Reads webhits registry info
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

void CWebhitsInfo::ReadRegValues()
{
    CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );

    const ULONG CI_RUNNING_WEBHITS_DEFAULT = 20;
    const ULONG CI_RUNNING_WEBHITS_MIN     = 1;
    const ULONG CI_RUNNING_WEBHITS_MAX     = 200;
    ULONG ul = reg.Read( wcsMaxRunningWebhits, CI_RUNNING_WEBHITS_DEFAULT );
    _cMaxRunningWebhits = Range( ul, CI_RUNNING_WEBHITS_MIN, CI_RUNNING_WEBHITS_MAX );

    const ULONG CI_WEBHITS_DISPLAY_SCRIPT_DEFAULT = DISPLAY_SCRIPT_KNOWN_FILTER;
    const ULONG CI_WEBHITS_DISPLAY_SCRIPT_MIN     = 0;
    const ULONG CI_WEBHITS_DISPLAY_SCRIPT_MAX     = 2;
    ul = reg.Read( wcsWebhitsDisplayScript, CI_WEBHITS_DISPLAY_SCRIPT_DEFAULT );
    _ulDisplayScript = Range( ul, CI_WEBHITS_DISPLAY_SCRIPT_MIN, CI_WEBHITS_DISPLAY_SCRIPT_MAX );

    const ULONG CI_WEBHITS_TIMEOUT_DEFAULT = 30;
    const ULONG CI_WEBHITS_TIMEOUT_MIN     = 5;
    const ULONG CI_WEBHITS_TIMEOUT_MAX     = 7200;
    ul = reg.Read( wcsMaxWebhitsCpuTime, CI_WEBHITS_TIMEOUT_DEFAULT );
    _cmsMaxWebhitsCpuTime = Range( ul, CI_WEBHITS_TIMEOUT_MIN, CI_WEBHITS_TIMEOUT_MAX );
} //ReadRegValues

//+---------------------------------------------------------------------------
//
//  Method:     GetTokenCache, public
//
//  Synposis:   Retrieves the appropriate token cache for the web server
//
//  Arguments:  [webServer] -- The web server instance
//
//  History:    18-Aug-97   dlee       Created
//
//----------------------------------------------------------------------------

CImpersonationTokenCache * CWebhitsInfo::GetTokenCache(
    CWebServer & webServer )
{
    //
    // Get the server instance of this ISAPI request
    //

    ULONG ulInstance = webServer.GetServerInstance();

    //
    // Look for a token cache for this server instance
    //

    CLock lock( _mutex );

    for ( unsigned x = 0; x < _aTokenCache.Count(); x++ )
    {
        Win4Assert( 0 != _aTokenCache[ x ] );

        if ( _aTokenCache[ x ]->GetW3Instance() == ulInstance )
            return _aTokenCache[ x ];
    }

    //
    // Not found, so create a new token cache
    //

    CImpersonateSystem system;

    XPtr<CImpersonationTokenCache> xCache( new CImpersonationTokenCache( L"" ) );

    xCache->Initialize( L"webhits",    // arbitrary name of token cache
                        TRUE,          // w3svc
                        FALSE,         // not nntp
                        FALSE,         // not imap
                        ulInstance,    // virtual server instance number
                        0,             // no nntp vserver instance
                        0 );           // no imap vserver instance

    _aTokenCache[ _aTokenCache.Count() ] = xCache.GetPointer();

    return xCache.Acquire();
} //GetTokenCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\webhits\vsrvinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       vsrvinfo.cxx
//
//  Contents:   Retrieves the virtual server address in the form of
//              L"a.b.c.d" if the process calling this is in the context
//              of a virtual server.
//
//  History:    9-03-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <winsock.h>
#include <webdbg.hxx>
#include <vsrvinfo.hxx>

//+---------------------------------------------------------------------------
//
//  Class:      CVServerInfo 
//
//  Purpose:    Determines the virtual server ip address (if applicable)
//
//  History:    9-03-96   srikants   Created
//
//----------------------------------------------------------------------------


class CVServerInfo
{

public:

    CVServerInfo( char const * pszServer );

    WCHAR * GetVirtualServerIpAddress();

private:

    ULONG _GetIpAddress( char const * pszName );

    static BOOL         _fSocketsInit;

    char const *        _pszServer;
    char                _szDefaultServer[MAX_PATH];

    ULONG               _ipServer;
    ULONG               _ipDefaultServer;

};

BOOL CVServerInfo::_fSocketsInit = FALSE;

//+---------------------------------------------------------------------------
//
//  Member:     CVServerInfo::CVServerInfo
//
//  Synopsis:   Constructor - stores the given name of the server and also
//              determines the default server address.
//
//  Arguments:  [pszName] - Name of the server which launched this program.
//
//  History:    9-03-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CVServerInfo::CVServerInfo( char const * pszName )
:_pszServer(pszName)
{
    _ipServer = (ULONG) SOCKET_ERROR;
    _ipDefaultServer = (ULONG) SOCKET_ERROR;

    DWORD dwError = 0;

    //
    // Initialize sockets interface if not already initialized.
    //
    if ( !_fSocketsInit )
    {
        INT             wsaResult = SOCKET_ERROR;   // result of the WSAStartup routine
        WSADATA         wsadata;

        wsaResult = WSAStartup( 0x101, &wsadata );

        if( SOCKET_ERROR == wsaResult )
        {
            dwError = WSAGetLastError();
            webDebugOut(( DEB_ERROR, "WSAStartup() failed with error %d\n",
                           dwError ));
            THROW( CException( dwError ) );
        }

        _fSocketsInit = TRUE;
    }

    //
    // Retrieve the name of the current host.
    //
    if ( SOCKET_ERROR == gethostname( _szDefaultServer, sizeof(_szDefaultServer)) )
    {
        dwError = WSAGetLastError();
        webDebugOut(( DEB_ERROR, "gethostname failed with error %d\n",
                       dwError ));
        THROW( CException( dwError ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVServerInfo::_GetIpAddress
//
//  Synopsis:   Retrieves the ipaddress of the given server name.
//
//  Arguments:  [pszName] - Server name. Can be either of the form
//              "foo@microsoft.com" or "foo" or "1.2.3.4"
//
//  Returns:    Ipaddress as a ULONG of the given server
//
//  History:    9-03-96   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CVServerInfo::_GetIpAddress( char const * pszName )
{
    Win4Assert( 0 != pszName );
    struct hostent * pHostEntry = 0;

    ULONG  ulIpAddress = inet_addr( pszName );

    if ( INADDR_NONE == ulIpAddress )
    {
        pHostEntry = gethostbyname( pszName );

        if ( 0 == pHostEntry )
        {
            DWORD dwError = WSAGetLastError();
            webDebugOut(( DEB_ERROR, "gethostbyname failed with error %d\n",
                           dwError ));
            THROW( CException( dwError ) );
        }

        RtlCopyMemory( &ulIpAddress, pHostEntry->h_addr,
                       sizeof(ulIpAddress) );
    }

    return ulIpAddress;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVServerInfo::GetVirtualServerIpAddress
//
//  Synopsis:   Retrieves the virtual server ip address as WCHAR "a.b.c.d"
//              if the process is running in the context of a virtual server.
//              NULL if it is in the context of a default server.
//
//  History:    9-03-96   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR * CVServerInfo::GetVirtualServerIpAddress()
{

    if ( 0 == _stricmp( _pszServer, _szDefaultServer) )
    {
        webDebugOut(( DEB_ITRACE, "found default server\n" ));
        return 0;        
    }

    _ipServer = _GetIpAddress( _pszServer );
    _ipDefaultServer = _GetIpAddress( _szDefaultServer );

#if 0
    {
        char const * szIpAddress = inet_ntoa( *((struct in_addr *) &_ipServer) );
        szIpAddress = inet_ntoa( *((struct in_addr *) &_ipDefaultServer) );
    }
#endif  // 0

    if ( _ipServer == _ipDefaultServer )
        return 0;

    //
    // Convert the ULONG form of ip address to a string form and
    // return that.
    //
    Win4Assert( sizeof(_ipServer) == sizeof(struct in_addr) );

    char const * szIpAddress = inet_ntoa( *((struct in_addr *) &_ipServer) );
    size_t len = strlen( szIpAddress );

    XArray<WCHAR>   xIpAddress(len+1);

    //
    // As the ip address just consists of numbers and periods, we can
    // directly copy to the wide char array.
    //
    for ( unsigned i = 0; i < len; i++ )
        xIpAddress[i] = (WCHAR) szIpAddress[i];    

    xIpAddress[i] = 0;

    return xIpAddress.Acquire();
}


WCHAR * GetVirtualServerIpAddress( char const * pszServer )
{
    CVServerInfo   info( pszServer );
    return info.GetVirtualServerIpAddress();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\bmkmap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       bmkmap.cxx
//
//  Contents:   Book Mark Map Implementation
//
//  Classes:    CBookMarkMap
//
//  Functions:  
//
//  History:    11-22-94   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <pidmap.hxx>

#include "bmkmap.hxx"
#include "rowindex.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   AddBookMark
//
//  Synopsis:   Adds a NEW book mark to the mapping.
//
//  Arguments:  [wid]       --  WorkId to be added.
//              [oTableRow] --  Offset of the in the table window for this
//                              bookmark.
//
//  History:    11-23-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CBookMarkMap::AddBookMark( WORKID wid, TBL_OFF oTableRow )
{
    Win4Assert( widInvalid != wid );
    CWidBmkHashEntry  entry( wid, oTableRow );
    _widHash.AddEntry( entry );
}

//+---------------------------------------------------------------------------
//
//  Function:   AddReplaceBookMark
//
//  Synopsis:   Adds a NEW book mark to the mapping or replaces one if
//              already present.
//
//  Arguments:  [wid]       --  WorkId to be added.
//              [oTableRow] --  Offset of the in the table window for this
//                              bookmark.
//
//  History:    11-30-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CBookMarkMap::AddReplaceBookMark( WORKID wid, TBL_OFF oTableRow )
{
    Win4Assert( widInvalid != wid );
    CWidBmkHashEntry  entry( wid, oTableRow );
    _widHash.ReplaceOrAddEntry( entry );
}


//+---------------------------------------------------------------------------
//
//  Function:   FindBookMark
//
//  Synopsis:   Locates the requested bookmark mapping.
//
//  Arguments:  [wid]        -- WorkId to locate.
//              [obTableRow] -- (Output) Offset of the table row in the
//                              window.
//              [iRowIndex] -- (Output) Index in the sorted permutation
//                              (RowIndex) of the entry.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    11-23-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CBookMarkMap::FindBookMark(
    WORKID      wid,
    TBL_OFF & obTableRow,
    ULONG &     iRowIndex )
{
    CWidBmkHashEntry  entry( wid );

    BOOL fHash =  _widHash.LookUpWorkId( entry );
    if ( !fHash )
    {
        return FALSE;
    }

    obTableRow = entry.Value();

    //
    // It has been located in the hash table. Now find out the corresponding
    // entry in the row index.
    //
    return _rowIndex.FindRow( obTableRow, iRowIndex );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\buketize.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       buketize.cxx
//
//  Classes:    CBuketizeWindows
//
//  History:    2-16-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>

#include "buketize.hxx"

CBucketizeWindows::CBucketizeWindows( CLargeTable & largeTable,
                                      CTableWindow &srcWindow )
: _largeTable(largeTable),
  _srcWindow( srcWindow ),
  _fFirstBkt(TRUE),
  _cRowsToCopy(0),
  _pBucket(0)
{
}


//+---------------------------------------------------------------------------
//
//  Function:   _AddWorkIds
//
//  Synopsis:   Adds workids from the given window to the bucket.
//
//  Arguments:  [iter] - 
//
//  History:    2-16-95   srikants   Created
//              4-27-95   srikants   Modified to deal with converting 
//                                   single window to multiple buckets.
//
//  Notes:      
//
//----------------------------------------------------------------------------

ULONG CBucketizeWindows::_AddWorkIds( CWindowRowIter & iter )
{

#if CIDBG==1
    ULONG cTotal =  iter.TotalRows();
    Win4Assert( _cRowsToCopy+iter.GetCurrPos() <= cTotal );
#endif  // CIDBG==1

    Win4Assert( 0 != _pBucket );

    ULONG iFirstRow = ULONG_MAX;
    ULONG iLastRow  = ULONG_MAX;

    ULONG cRowsCopied = 0;

    for ( ; !iter.AtEnd() && (cRowsCopied < _cRowsToCopy) ; iter.Next() )
    {
        if ( !iter.IsDeletedRow() )
        {
            iLastRow = iter.GetCurrPos();    
            if ( 0 == cRowsCopied )
                iFirstRow = iter.GetCurrPos();    
            _pBucket->_AddWorkId( iter.Get(), iter.Rank(), iter.HitCount() );
            cRowsCopied++;
        }
    }

    //
    // Initialize the lowest and the highest rows.
    //
    if ( 0 != cRowsCopied )
    {
        _srcWindow.GetSortKey( iFirstRow,
                               _pBucket->GetLowestKey() );

        _srcWindow.GetSortKey( iLastRow,
                               _pBucket->GetHighestKey() );
    }

    return cRowsCopied;
}

//+---------------------------------------------------------------------------
//
//  Function:   LokCreateBuckets
//
//  Synopsis:   Creates buckets from the source window.
//
//  Arguments:  [pSortSet] - The sortset on the table.
//              [colSet]   - Master column set for the table. 
//              [segId]    - Segment Id for the new bucket.
//
//  History:    2-16-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CBucketizeWindows::LokCreateBuckets( const CSortSet & sortSet,
                                          CTableKeyCompare & comparator,
                                          CColumnMasterSet & colSet
                                           )
{

    CWindowRowIter  iter(_srcWindow);

    ULONG cRowsRemaining = iter.TotalRows();
    const cRowsPerBkt = CTableSink::cBucketRowLimit;
    const cRowsMax = cRowsPerBkt * 110 /100;    // allow a 10% fall over

    //
    // While there are more rows in the windows, copy a set to the next
    // bucket.
    //
    while ( !iter.AtEnd() )
    {
        if ( cRowsRemaining <= cRowsMax )
        {
            //
            // This is to prevent a very small last bucket.
            //
            _cRowsToCopy = cRowsRemaining;    
        }
        else
        {
            _cRowsToCopy = cRowsPerBkt;
        }

        ULONG bktSegId;
        if ( _fFirstBkt )
        {
            //
            // For the first bucket, use the same segment id as the original
            // window.
            //
            bktSegId = _srcWindow.GetSegId();
            _fFirstBkt = FALSE;
        }
        else
        {
            bktSegId = _largeTable._AllocSegId();
        }

        //
        // Create a new bucket and append it to the end of bucket list.
        //
        _pBucket =  new CTableBucket( sortSet,
                                      comparator,
                                      colSet,
                                      bktSegId );

        //
        // Add the workids from the _iStart to _iEnd to the bucket.
        //
        ULONG cRowsCopied = _AddWorkIds( iter );
        if ( 0 != cRowsCopied )
        {
            _bktList.Queue( _pBucket );
            _pBucket = 0;
        }
        Win4Assert( iter.GetCurrPos() <= iter.TotalRows() );

        cRowsRemaining = iter.TotalRows() - iter.GetCurrPos();
    }

    Win4Assert( cRowsRemaining == 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\webhits\whtmplat.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996 - 1998, Microsoft Corporation.
//
//  File:   htx.cxx
//
//  Contents:   Parser for a HTX file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cgiesc.hxx>
#include <htmlchar.hxx>

#include "whtmplat.hxx"
#include "webdbg.hxx"
#include "whmsg.h"

//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::CWTXScanner - public constructor
//
//  Synopsis:   Builds a scanner for a section within a HTX file
//
//  Arguments:  [variableSet] - list of replaceable parameters
//              [wcsPrefix]   - prefix delimiter for replacable parameters
//              [wcsSuffix]   - suffix delimiter for replacable parameters
//
//  Notes:      The wcsPrefix and wcsSuffix are expected to be the same
//              length and either one or two characters.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
CWTXScanner::CWTXScanner( CWHVarSet & variableSet,
                          WCHAR const * wcsPrefix,
                          WCHAR const * wcsSuffix ) :
                                    _wcsPrefix(wcsPrefix),
                                    _wcsSuffix(wcsSuffix),
                                    _variableSet(variableSet),
                                    _type(eNone),
                                    _nextType(eNone),
                                    _wcsString(0),
                                    _wcsPrefixToken(0),
                                    _wcsSuffixToken(0)
{
    Win4Assert( wcslen( _wcsPrefix ) == wcslen( _wcsSuffix ) &&
                wcslen( _wcsPrefix ) <= 2 );

    if ( _wcsPrefix[1] == L'\0' )
        _cchPrefix = _cchSuffix = 1;
    else
        _cchPrefix = _cchSuffix = 2;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::Init - public
//
//  Synopsis:   Saves a pointer to the string to be parsed.
//
//  Arguments:  [wcsString] - the string to be parsed
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//  NOTES:      THIS STRING WILL BE MODIFIED BY SUBSEQUENT CALLS TO MEMBER
//              FUNCTIONS OF THIS CLASS.
//
//----------------------------------------------------------------------------
void CWTXScanner::Init( WCHAR * wcsString )
{
    _wcsString = wcsString;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::IsToken - private
//
//  Synopsis:   Determines if a string is a special token.
//
//  Arguments:  [wcs] - start of string to be tested.
//
//  Notes:      If the string is a token, the members _type, _wcsPrefixToken
//              and _wcsSuffixToken are set appropriately.
//
//  History:    96/Apr/02   AlanW       Created
//              96/May/17   DwightKr    Treat all <%..%> as variables
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------

BOOL CWTXScanner::IsToken(WCHAR * wcs)
{
    if ( wcsncmp( _wcsPrefix, wcs, _cchPrefix ) != 0 )
    {
        webDebugOut(( DEB_USER1, "CWTXScanner::IsToken  end of string\n" ));
        return FALSE;
    }

    wcs += _cchPrefix;
    WCHAR * wcsSuffixTok = wcs2chr( wcs, _wcsSuffix );
    if ( 0 == wcsSuffixTok )
    {
        webDebugOut(( DEB_USER1, "CWTXScanner::IsToken  no suffix token\n" ));
        return FALSE;
    }

    *wcsSuffixTok = L'\0';
    _wcsPrefixToken = wcs - _cchPrefix;
    _wcsupr( wcs );

    //
    //  Strip leading spaces before token
    //
    while ( iswspace(*wcs) && (wcs < wcsSuffixTok) )
    {
        wcs++;
    }

    //
    //  Strip trailing spaces after token
    //
    WCHAR * wcsSuffix = wcsSuffixTok - 1;
    while ( iswspace(*wcsSuffix) && (wcsSuffix > wcs) )
    {
        *wcsSuffix = 0;
        wcsSuffix--;
    }

    webDebugOut(( DEB_USER1, "CWTXScanner::IsToken  wcs=%ws\n", wcs ));

    if ( wcsncmp( wcs, L"ESCAPEHTML ", 11 ) == 0 )
    {
        _type = eEscapeHTML;
    }
    else if ( wcsncmp( wcs, L"ESCAPEURL ", 10 ) == 0 )
    {
        _type = eEscapeURL;
    }
    else if ( wcsncmp( wcs, L"ESCAPERAW ", 10 ) == 0 )
    {
        _type = eEscapeRAW;
    }
    else
    {
        //
        //  Find this name in the list of replaceable parameters.  Note that
        //  if we can't find this variable in the list of replaceable
        //  parameters, we've converted some output text to uppercase.  This
        //  is probably OK since the user used <% ... %> to delimit their
        //  output; <% & %> are reserved tokens hence this would be an error.
        //
        WCHAR const *pVariable = _variableSet.Find( wcs );

        _type = eParameter;

        if ( 0 == pVariable )
        {
            webDebugOut(( DEB_IWARN,
                            "Warning: CWTXScanner::IsToken found a unknown variable: '%ws'\n",
                            wcs ));
        }
    }

    *_wcsPrefixToken = L'\0';
    _wcsSuffixToken = wcsSuffixTok;
    _wcsNextToken = wcsSuffixTok + _cchSuffix;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::FindNextToken - public
//
//  Synopsis:   Locates the next token in the string.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------

BOOL CWTXScanner::FindNextToken()
{
    if (_nextType != eNone)
    {
        //
        // Found a token on the previous call.  Just return it.
        //
        Win4Assert ( _wcsPrefixToken && _wcsSuffixToken > _wcsPrefixToken );
        _type = _nextType;
        _nextType = eNone;
        _wcsString = _wcsNextToken = _wcsSuffixToken + _cchSuffix;
        return TRUE;
    }

    if ( (0 == _wcsString) || (0 == *_wcsString) )
    {
        _type = eNone;
        _wcsNextToken = 0;

        return FALSE;
    }

    if ( *_wcsString == *_wcsPrefix &&
         IsToken( _wcsString ) )
    {
        _nextType = eNone;
        return TRUE;
    }

    //
    // The string doesn't start with one of our special keywords.
    // Treat it as an ordinary string, and look ahead to the next
    // valid token.
    //

    _wcsPrefixToken = wcs2chr( _wcsString+1, _wcsPrefix );
    while ( _wcsPrefixToken )
    {
        if ( IsToken( _wcsPrefixToken ) )
        {
            _nextType = _type;
            _wcsNextToken = _wcsPrefixToken;
            _type = eString;
            return TRUE;
        }
        _wcsPrefixToken = wcs2chr( _wcsPrefixToken+_cchPrefix, _wcsPrefix );
    }

    _nextType = eNone;
    _type = eString;
    _wcsNextToken = _wcsString + wcslen( _wcsString );
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXScanner::GetToken - public
//
//  Synopsis:   Returns a pointer to the replaceable parameter token found.
//              Prepares the scanner to return the next token.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Mar/13   DwightKr    add support for eEscapeURL &
//                                      eEscapeHTML
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------

WCHAR * CWTXScanner::GetToken()
{
    if ( eString == _type )
    {
        if ( 0 != _wcsString )
        {
            WCHAR * wcsString = _wcsString;
            _wcsString = _wcsNextToken;

            return wcsString;
        }
    }
    else if ( eEscapeHTML == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 10;                        // Skip 'EscapeHTML'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else if ( eEscapeURL == _type ||
              eEscapeRAW == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 9;                         // Skip 'EscapeURL'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else
    {
        if ( 0 != _wcsPrefixToken )
        {
            Win4Assert( 0 != _wcsSuffixToken &&
                        _wcsPrefixToken < _wcsSuffixToken &&
                        _wcsSuffixToken < _wcsNextToken );

            *_wcsPrefixToken = 0;
            *_wcsSuffixToken = 0;

            _wcsString = _wcsNextToken;

            WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
            while ( (0 != *wcsString) && iswspace(*wcsString) )
            {
                wcsString++;
            }


            return wcsString;
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::CWTXFile - public constructor
//
//  Synopsis:   Builds a CWTXFile object and initializes values.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
CWTXFile::CWTXFile( WCHAR const * wcsTemplate,
                    WCHAR const * wcsPhysicalName,
                    UINT codePage) :
                        _wcsVirtualName( wcsTemplate  ),
                        _wcsPhysicalName( wcsPhysicalName ),
                        _pVarHeader(0),
                        _pVarRowDetails(0),
                        _pVarFooter(0),
                        _wcsFileBuffer(0),
                        _codePage(codePage)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::~CWTXFile - public destructor
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
CWTXFile::~CWTXFile()
{
    delete _pVarHeader;
    delete _pVarRowDetails;
    delete _pVarFooter;
    delete _wcsFileBuffer;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::ParseFile - public
//
//  Synopsis:   Parses the HTX file and breaks it up into its sections.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::ParseFile( CWHVarSet & variableSet )
{

    //
    //  Read the entire file into a buffer
    //
    _wcsFileBuffer = ReadFile( _wcsPhysicalName );
    Win4Assert( 0 != _wcsFileBuffer );

    //
    //  Break the buffer into the sections; the header, the detail section,
    //  and the footer.  Verify that if there is a <%BeginDetail%>
    //  section, then there MUST be a <%EndDetail%> section AFTER it, not
    //  before.  Neither <%EndDetail%> nor <%BeginDetail%> can appear on
    //  their own.
    //

    //
    //  Find the <%BeginDetail%> and <%EndDetail%> sections
    //
    WCHAR * wcsHeader     = _wcsFileBuffer;             // Assume a header
    WCHAR * wcsRowDetails = wcsipattern(wcsHeader, L"<%BEGINDETAIL%>" );
    WCHAR * wcsFooter     = wcsipattern(wcsHeader, L"<%ENDDETAIL%>" );

    if ( wcsHeader == wcsRowDetails )
    {
        //
        //  No header found in this file; it begins with the detail section.
        //
        wcsHeader = 0;
    }

    const int cwcBeginDetail = 15;
    const int cwcEndDetail   = 13;

    Win4Assert( cwcBeginDetail == wcslen( L"<%BEGINDETAIL%>" ) );
    Win4Assert( cwcEndDetail == wcslen( L"<%ENDDETAIL%>" ) );

    if ( 0 != wcsRowDetails )
    {
        //
        //  A <%BeginDetail%> section was found.  We better also have an
        //  <%EndDetail%> section AFTER the <%BeginDetail%> section.
        //

        *wcsRowDetails = 0;         // Null terminate the header string
        wcsRowDetails += cwcBeginDetail;

        if ( 0 != wcsFooter )
        {
            if ( wcsFooter < wcsRowDetails )
            {
                //
                //  The <%EndDetail%> was found before the <%BeginDetail%>
                //
                WCHAR * wcsHTXFileName;
                LONG    lLineNumber;

                GetFileNameAndLineNumber( CiPtrToInt( wcsFooter - _wcsFileBuffer ),
                                          wcsHTXFileName,
                                          lLineNumber );

                THROW( CWTXException(MSG_WEBHITS_ENDDETAIL_BEFORE_BEGINDETAIL,
                                     wcsHTXFileName,
                                     lLineNumber) );
            }

            *wcsFooter = 0;         // Null terminate the BeginDetail section
            wcsFooter += cwcEndDetail;
        }
        else
        {
            //
            //  Report an error:  <%BeginDetail%> without an <%EndDetail%>
            //

            WCHAR * wcsHTXFileName;
            LONG    lLineNumber;

            GetFileNameAndLineNumber( CiPtrToInt( wcsRowDetails - _wcsFileBuffer ),
                                      wcsHTXFileName,
                                      lLineNumber );

            THROW( CWTXException(MSG_WEBHITS_NO_ENDDETAIL_SECTION,
                                 wcsHTXFileName,
                                 lLineNumber) );
        }
    }
    else if ( 0 != wcsFooter )
    {
        //
        //  A <%BeginDetail%> section could be found.  There should
        //  be no <%EndDetail%> section either.
        //

        WCHAR * wcsHTXFileName;
        LONG    lLineNumber;

        GetFileNameAndLineNumber( CiPtrToInt( wcsFooter - _wcsFileBuffer ),
                                  wcsHTXFileName,
                                  lLineNumber );

        THROW( CWTXException(MSG_WEBHITS_NO_BEGINDETAIL_SECTION,
                             wcsHTXFileName,
                             lLineNumber) );
    }


    if ( 0 != wcsHeader )
    {
        _pVarHeader = new CWHParamReplacer ( wcsHeader,
                                                              L"<%",
                                                              L"%>" );
        _pVarHeader->ParseString( variableSet );
    }

    if ( 0 != wcsRowDetails )
    {
        _pVarRowDetails = new CWHParamReplacer ( wcsRowDetails,
                                                                  L"<%",
                                                                  L"%>" );
        _pVarRowDetails->ParseString( variableSet );
    }

    if ( 0 != wcsFooter )
    {
        _pVarFooter = new CWHParamReplacer ( wcsFooter,
                                                              L"<%",
                                                              L"%>" );
        _pVarFooter->ParseString( variableSet );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::ReadFile - public
//
//  Synopsis:   Read the HTX file into a buffer
//
//  Arguments:  [wcsFileName]  - full physical path name of file
//
//  History:    96/Jan/03   DwightKr    created
//              96/Apr/06   DwightKr    add support for unicode files
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
WCHAR * CWTXFile::ReadFile( WCHAR const * wcsFileName )
{
    Win4Assert ( 0 != wcsFileName );

    //
    //  Verify the HTX file exists, and is a file, not a directory.
    //
    WIN32_FIND_DATA ffData;
    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        webDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));

        THROW( CWTXException(MSG_WEBHITS_NO_SUCH_TEMPLATE, _wcsVirtualName, 0) );
    }


    if ( (ffData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 )
    {
        THROW( CWTXException(MSG_WEBHITS_NO_SUCH_TEMPLATE, _wcsVirtualName, 0) );
    }

    //
    //  Open the file and map its contents
    //
    CFileMapView mapView( wcsFileName );
    mapView.Init();

    int cbBuffer = mapView.GetBufferSize() + 1;
    XArray<WCHAR> pwBuffer(cbBuffer);

    //
    //  If the first two BYTES of the file are 0xFF 0xFE, then this is a
    //  unicode file, and we don't need to convert it.
    //
    if ( mapView.IsUnicode() )
    {
        RtlCopyMemory( pwBuffer.Get(), mapView.GetBuffer()+2, cbBuffer-2 );
        pwBuffer[ ( cbBuffer - 2 ) / sizeof WCHAR ] = 0;

        return pwBuffer.Acquire();
    }

    //
    //  Copy & convert the ASCII buffer to a WCHAR buffer.
    //
    int cwBuffer = mapView.GetBufferSize() + 1;
    int cwConvert;

    do
    {
        cwConvert = MultiByteToWideChar( _codePage,
                                         0,
                          (const char *) mapView.GetBuffer(),    // Ptr to input buf
                                         mapView.GetBufferSize(),// Size of input buf
                                         pwBuffer.Get(), // Ptr to output buf
                                         cwBuffer - 1 ); // Size of output buf

        if ( 0 == cwConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwBuffer += (cwBuffer/2);
                delete pwBuffer.Acquire();
                pwBuffer.Init(cwBuffer);
            }
            else
            {
                THROW( CException() );
            }
        }
        else
        {
            pwBuffer[cwConvert] = 0;        // Null terminate the buffer
        }

        Win4Assert( cwConvert < cwBuffer );

    } while ( 0 == cwConvert );

    return pwBuffer.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::GetFileNameAndLineNumber
//
//  Synopsis:   Determines the filename & line number amoung a group of
//              nested includes for a particular offset into the buffer.
//
//  Arguments:  [offset] - offset of the error in the overall buffer
//              [wcsFileName] - resulting name of file containing error
//              [lineNumber]  - line # containing the error
//
//  History:    96/Jun/25   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::GetFileNameAndLineNumber( int offset,
                                         WCHAR const *& wcsFileName,
                                         LONG & lineNumber )
{

    //
    //  Save a pointer to the name of the file containing the error
    //
    WCHAR const * pCurrent = _wcsFileBuffer;
    wcsFileName = _wcsVirtualName;


    //
    //  Count the number of lines in this sub-file
    //
    Win4Assert( 0 != _wcsFileBuffer );
    WCHAR const * pEnd = _wcsFileBuffer + offset;

    lineNumber = CountLines( pCurrent, pEnd );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::CountLines - private
//
//  Synopsis:   Deterines the number of lines (CR's) between the start
//              of the buffer and the end.
//
//  Arguments:  [wcsStart] - start location of search
//              [wcsEnd]   - end of search
//
//  History:    96/Jun/25   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
LONG CWTXFile::CountLines( WCHAR const * wcsStart,
                           WCHAR const * wcsEnd ) const
{
    Win4Assert( 0 != wcsStart );
    Win4Assert( 0 != wcsEnd );

    LONG cLines = 1;

    while ( wcsStart <= wcsEnd )
    {
        if ( L'\n' == *wcsStart )
        {
            cLines++;
        }

        wcsStart++;
    }

    return cLines;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::GetHeader - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file BEFORE
//              the <%begindetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]       - the CVirtualString to append data to
//              [variableSet]  - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::GetHeader( CVirtualString & string,
                          CWHVarSet & variableSet )
{
    if ( 0 != _pVarHeader )
    {
        _pVarHeader->ReplaceParams( string, variableSet, _codePage );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWTXFile::GetFooter - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file AFTER
//              the <%enddetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]      - the CVirtualString to append data to
//              [variableSet] - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWTXFile::GetFooter( CVirtualString & string,
                          CWHVarSet & variableSet )
{
    if ( 0 != _pVarFooter )
    {
        _pVarFooter->ReplaceParams( string, variableSet, _codePage );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CWHVarSet::GetStringValueHTML
//
//  Synopsis:   Get variable value formatted as HTML
//
//  Arguments:  [wcsName] - 
//              [str]     - 
//              [ulCodepage] - code page for translation
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CWHVarSet::GetStringValueHTML( WCHAR const * wcsName,
                                    CVirtualString & str,
                                    ULONG ulCodepage )
{
    WCHAR const * pwcsValue = Find( wcsName );
    if ( pwcsValue )
    {
        HTMLEscapeW( pwcsValue, str, ulCodepage );
        return TRUE;
    }
    else return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHVarSet::GetStringValueURL
//
//  Synopsis:   Get variable value formatted as for a URL
//
//  Arguments:  [wcsName]    - 
//              [str]        - 
//              [ulCodepage] - code page for translation
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CWHVarSet::GetStringValueURL( WCHAR const * wcsName,
                                   CVirtualString & str,
                                   ULONG ulCodepage )
{
    WCHAR const * pwcsValue = Find( wcsName );
    if ( pwcsValue )
    {
        URLEscapeW( pwcsValue, str, ulCodepage );
        return TRUE;
    }
    else return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamNode::~CWHParamNode
//
//  Synopsis:   
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

CWHParamNode::~CWHParamNode()
{
    if ( 0 != _pNext )
        delete _pNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::CWHParamReplacer
//
//  Synopsis:   
//
//  Arguments:  [wcsString] - 
//              [wcsPrefix] - 
//              [wcsSuffix] - 
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

CWHParamReplacer::CWHParamReplacer( WCHAR const * wcsString,
                                    WCHAR const * wcsPrefix,
                                    WCHAR const * wcsSuffix ) :
_wcsString(0),
_wcsPrefix(wcsPrefix),
_wcsSuffix(wcsSuffix),
_ulFlags(0),
_paramNode(L"Top")
{
        
    Win4Assert( 0 != wcsString );
    Win4Assert( 0 != wcsPrefix );
    Win4Assert( 0 != wcsSuffix );

    ULONG cwcString = wcslen(wcsString) + 1;
    _wcsString = new WCHAR[ cwcString ];
    RtlCopyMemory( _wcsString, wcsString, cwcString * sizeof(WCHAR) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::ParseString
//
//  Synopsis:   
//
//  Arguments:  [variableSet] - 
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CWHParamReplacer::ParseString( CWHVarSet & variableSet )
{
    CWTXScanner scanner( variableSet, _wcsPrefix, _wcsSuffix );
    scanner.Init( _wcsString );
    BuildList( scanner, &_paramNode );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::ReplaceParams - public
//
//  Synopsis:   Generates a new string replacing all %values% in the original
//              string
//
//  Arguments:  [StrResult]   - a safe string to append the new params to
//              [variableSet] - the list of replaceable parameter values
//
//  Notes:      If expressions are handled in the parameter node iterator.
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Sep/07   SrikantS    Copied and adapted to webhits use from
//                                      htx.cxx/htx.hxx
//
//----------------------------------------------------------------------------
void CWHParamReplacer::ReplaceParams( CVirtualString & StrResult,
                                      CWHVarSet & variableSet, 
                                      ULONG ulCodepage )
{
    for ( CWHParamNodeIter iter(&_paramNode);
          !iter.AtEnd();
           iter.Next() )
    {
        CWHParamNode * pNode = iter.Get();

        ULONG type = pNode->Type() & eJustParamMask;

        switch ( type )
        {

        case eString:
            StrResult.StrCat( pNode->String(), pNode->Length() );
        break;

        case eParameter:
        case eEscapeHTML:
        {
            if (! variableSet.GetStringValueHTML( pNode->String(),
                                                  StrResult, ulCodepage ) )
            {
                webDebugOut(( DEB_IWARN,
                                "Warning: CWHParamReplacer::ReplaceParams GetStringValueHTML returned FALSE for '%ws'\n",
                                pNode->String() ));

                if ( eParameter == type )
                    StrResult.StrCat( _wcsPrefix );
                HTMLEscapeW( pNode->String(), StrResult, ulCodepage );
                if ( eParameter == type )
                    StrResult.StrCat( _wcsSuffix );
            }
        }
        break;

        case eEscapeURL:
        {
            if (! variableSet.GetStringValueURL( pNode->String(),
                                                 StrResult, ulCodepage ) )
            {
                webDebugOut(( DEB_IWARN,
                                "Warning: CWHParamReplacer::ReplaceParams GetStringValueURL returned FALSE for '%ws'\n",
                                pNode->String() ));

                URLEscapeW( pNode->String(), StrResult, ulCodepage );
            }
        }
        break;

        case eEscapeRAW:
        {
            ULONG cwcValue;
            WCHAR const * wcsValue = variableSet.GetStringValueRAW( pNode->String(),
                                                                    cwcValue );


            if ( 0 != wcsValue )
            {
                StrResult.StrCat( wcsValue, cwcValue );
            }
            else
            {
                webDebugOut(( DEB_IWARN,
                                "Warning: CWHParamReplacer::ReplaceParams GetStringValueRAW returned NULL for '%ws'\n",
                                pNode->String() ));

                StrResult.StrCat( pNode->String(), pNode->Length() );
            }
        }
        break;

#if DBG==1
        case eNone :
        break;

        default :
            DbgPrint(" unexpected param type: 0x%lx\n", type );
            Win4Assert( !"unexpected parameter type" );
            break;
#endif // DBG==1

        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWHParamReplacer::BuildList
//
//  Synopsis:   Builds a list of the parameters.
//
//  Arguments:  [scanner] - 
//              [pPrev]   - 
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CWHParamReplacer::BuildList( CWTXScanner & scanner,
                                  CWHParamNode *pPrev )
{
    CWHParamNode *pNode = 0;

    while ( scanner.FindNextToken() )
    {
        switch ( scanner.TokenType() & eParamMask )
        {
        case eString:
        {
            //
            //  A non-replaceable wcsString was found before any replaceable/
            //  conditional nodes.  Save the wcsString in a node;
            //
            pNode = new CWHParamNode( scanner.GetToken(), eString );
            pPrev->SetNextNode( pNode );
            pPrev = pNode;

            break;
        }

        case eParameter:
        {
            //
            //  We've found a replaceable node.
            //
            WCHAR * wcsParameter = scanner.GetToken();

            pNode = new CWHParamNode( wcsParameter, eParameter );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;

            break;
        }

        case eEscapeHTML:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            pNode = new CWHParamNode( wcsParameter, eEscapeHTML );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;
        }
        break;

        case eEscapeURL:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            pNode = new CWHParamNode( wcsParameter, eEscapeURL );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;
        }
        break;

        case eEscapeRAW:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            pNode = new CWHParamNode( wcsParameter, eEscapeRAW );

            pPrev->SetNextNode( pNode );
            pPrev = pNode;
        }
        break;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\apps\webhits\linkhits.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       linkhits.cxx
//
//  Contents:   classes to insert links among query hits in HTML format
//
//--------------------------------------------------------------------------

#include<pch.cxx>
#pragma hdrstop

#include <locale.h>

#include <mbutil.hxx>
#include <htmlchar.hxx>
#include <codepage.hxx>
#include <cgiesc.hxx>
#include <weblcid.hxx>

#include "webdbg.hxx"
#include "whmsg.h"
#include "linkhits.hxx"
#include "whtmplat.hxx"

extern int _cdecl ComparePositions(const void* pPos1, const void* pPos2);

const WCHAR VPathWebHitsFile[]=L"CiWebHitsFile";
const WCHAR CommandLineVarName[]=L"QUERY_STRING";
const WCHAR RestrictionVarName[]=L"CiRestriction";
const WCHAR IDQFilenameVarName[]=L"CiQueryFile";
const WCHAR WTXFilenameVarName[]=L"CiTemplateFile";
const WCHAR HiliteTypeVarName[]=L"CiHiliteType";
const WCHAR ColorVarName[]=L"CiHiliteColor";
const WCHAR BoldVarName[]=L"CiBold";
const WCHAR ItalicVarName[]=L"CiItalic";
const WCHAR MaxLineLength[]=L"CiMaxLineLength";
const WCHAR LocaleVar[]=L"CiLocale";
const WCHAR BeginHiliteVar[]=L"CiBeginHilite";
const WCHAR EndHiliteVar[]=L"CiEndHilite";
const WCHAR NullHTWFile[]=L"null.htw";
const WCHAR CodepageVar[]=L"CiCodepage";
const WCHAR DialectVar[]=L"CiDialect";

const WCHAR ParaTag[]=L"<P>\n";
const WCHAR HRule[]=L"<HR>\n";

const WCHAR Red24BitMask[]=L"#FF0000";
const WCHAR Blue24BitMask[]=L"#0000FF";
const WCHAR Green24BitMask[]=L"#00FF00";
const WCHAR Black24BitMask[]=L"#000000";
const WCHAR Yellow24BitMask[]=L"#FFFF00";


//
// List of replacable parameters in the htx file for output generation.
//
const WCHAR wcsParamCiUrl[]         = L"CIURL";
const WCHAR wcsParamRestriction[]   = L"CIRESTRICTION";
const WCHAR wcsCharSet[]            = L"CICHARSET";
const WCHAR wcsLocale[]             = L"CILOCALE";
const WCHAR wcsCodepage[]           = L"CICODEPAGE";

const WCHAR wcsUserParamPrefix[]    = L"CIUSERPARAM";
const ULONG cwcUserParamPrefix = (sizeof(wcsUserParamPrefix)/sizeof(WCHAR))-1;

const WCHAR * awcsUserParamNames[]  = {
                              L"CIUSERPARAM1",
                              L"CIUSERPARAM2",
                              L"CIUSERPARAM3",
                              L"CIUSERPARAM4",
                              L"CIUSERPARAM5",
                              L"CIUSERPARAM6",
                              L"CIUSERPARAM7",
                              L"CIUSERPARAM8",
                              L"CIUSERPARAM9",
                              L"CIUSERPARAM10",
                                      };


//+-------------------------------------------------------------------------
//
//  Member:     CInternalQuery::CinternalQuery, public constructor
//
//  Arguments:  [rGetEnvVars]   - object that contains CGI env. variables
//              [rPList]        - property list of properties to query
//              [lcid]          - LCID (locale identifier)
//
//  Synopsis:   rGetEnvVars yields the textual restriction.
//              GetStringDbRestriction then converts it into a DbRestriction.
//
//--------------------------------------------------------------------------

CInternalQuery::CInternalQuery(
    CGetEnvVars&        rGetEnvVars,
    CEmptyPropertyList& rPList,
    LCID                lcid ):
_pDbRestriction(0),
_pISearch(0)
{
    TRY
    {
        _pDbRestriction = GetStringDbRestriction( rGetEnvVars.GetRestriction(),
                                                  rGetEnvVars.GetDialect(),
                                                  &rPList,
                                                  lcid);
    }
    CATCH( CException, e)
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: failed to get DbRestriction\n" ));

        delete _pDbRestriction;
        RETHROW();
    }
    END_CATCH
}

void CInternalQuery::CreateISearch( WCHAR const * pwszPath )
{
    Win4Assert( 0 == _pISearch );
    SCODE sc = MakeISearch( &_pISearch, _pDbRestriction, pwszPath );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //CreateISearch


//+-------------------------------------------------------------------------
//
//  Member:     CURLUnescaper::CURLUnescaper public constructor
//
//--------------------------------------------------------------------------


CURLUnescaper::CURLUnescaper( UINT codePage ) :
    _codePage(codePage)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CURLUnescaper::UnescapeAndConvertToUnicode
//
//  Synopsis:   Converts the given multi-byte string into a unicode string
//              based on the code page.  Decodes URL escape sequences along
//              the way.
//
//  Arguments:  [pszMbStr]   - smart array pointer to input string
//              [cch]        - length of input string
//              [xwcsBuffer] -
//
//  Returns:    Number of characters in target buffer, excluding the
//              terminating NULL.
//
//  History:    24 Nov 1997   AlanW      Created
//
//----------------------------------------------------------------------------

ULONG CURLUnescaper::UnescapeAndConvertToUnicode( char const * pszMbStr,
                                                  ULONG cch,
                                                  XArray<WCHAR> & xwcsBuffer )
{
    if ( xwcsBuffer.Get() == 0 || cch+1 > xwcsBuffer.Count() )
    {
        delete [] xwcsBuffer.Acquire();
        xwcsBuffer.Init( cch+1 );
    }

    DecodeURLEscapes( (BYTE *)pszMbStr,
                              cch,
                              xwcsBuffer.Get(),
                              _codePage );

    return cch;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCollectVar::CCollectVar, public constructor
//
//  Arguments:  [rUnescaper]    - reference to an unescaper object - it will
//                                be used to unescape variables stored in
//                                the local buffer
//              [webServer]     - web server object from which variables
//                                are read.
//
//--------------------------------------------------------------------------

CCollectVar::CCollectVar(
    CURLUnescaper& rUnescaper,
    CWebServer &   webServer ):
_rUnescaper(rUnescaper),
_webServer( webServer ),
_xwcsBuffer(DEFAULT_BUFF_SIZE),
_cwcVarSize(0),
_xszBuffer(DEFAULT_BUFF_SIZE),
_cbVarSize(0)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CCollectVar::GetEnvVar
//
//  Arguments:  [pwcsVariableName]  - the name of the variable to be retrieved
//
//  Synopsis:   Returns TRUE if the specified variable was retrieved and
//              FALSE otherwise.
//
//--------------------------------------------------------------------------

BOOL CCollectVar::GetEnvVar( CHAR const * pszVariableName)
{

    //
    // Prime to indicate that the WIDE-CHAR form of the string is
    // not valid anymore.
    //
    _cwcVarSize = 0;
    _cbVarSize = 0;

    //
    // Retrieve the variable as an ascii string
    //
    webDebugOut(( DEB_ITRACE, "WEBHITS: Getting environment variable\n" ));

    ULONG cb = _xszBuffer.Count();

    if ( ! _webServer.GetCGIVariable( pszVariableName,
                                      _xszBuffer.GetPointer(),
                                      & cb ) )
    {
        if ( cb > _xszBuffer.Count() )
        {
            //
            // have to re-size and incur the cost of the memory allocation
            //

            delete[] _xszBuffer.Acquire();
            _xszBuffer.Init( cb );
            if ( ! _webServer.GetCGIVariable( pszVariableName,
                                              _xszBuffer.GetPointer(),
                                              & cb ) )
                return FALSE;
        }
        else
        {
            return FALSE;
        }

    }

    _cbVarSize = cb;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCollectVar::UnescapeAndConvertToUnicode
//
//  Synopsis:   Unescapes the variable currently stored in _xszBuffer.
//
//--------------------------------------------------------------------------

inline void CCollectVar::UnescapeAndConvertToUnicode()
{
    //
    // Convert the multi-byte string into a UNICODE string.
    //
    _cwcVarSize = _rUnescaper.UnescapeAndConvertToUnicode( _xszBuffer.Get(),
                                                           _cbVarSize,
                                                           _xwcsBuffer );
}


//+-------------------------------------------------------------------------
//
//  Member:     CSmartByteArray::CSmartByteArray - public constructor
//
//  Synopsis:   allocates memory for the buffer
//--------------------------------------------------------------------------

CSmartByteArray::CSmartByteArray():
_xszBuffer(DEFAULT_BUFFER_SIZE)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CSmartByteArray::CopyTo
//
//  Arguments:  [pwcText]    - pointer to text to be copied
//              [cwcToCopy]  - the number of characters to be copied
//
//  Synopsis:   copies the text pointed to by [pwcText] to the buffer,
//              enlarging it if necessary. A L'\0' is appended to the end
//              automatically, since this method is used to copy non-null
//              terminated strings.
//
//--------------------------------------------------------------------------

void CSmartByteArray::CopyTo(char * pszText, ULONG cbToCopy)
{
    //
    // if a buffer larger than the default one is being allocated, then
    // re-size it
    //

    if ( cbToCopy >= _xszBuffer.Count() )
    {
        delete[] _xszBuffer.Acquire();

        ULONG cbNew = max(2*_xszBuffer.Count(), cbToCopy+1);
        _xszBuffer.Init(cbNew);
    }

    RtlCopyMemory(_xszBuffer.GetPointer(),pszText,cbToCopy);

    // insert null terminator
    _xszBuffer[cbToCopy] = 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::CQueryStringParser, public constructor
//
//  Arguments:  [pwszQUERY_STRING]  - buffer in which the *ESCAPED*
//                                    QUERY_STRING is stored
//              [rUnescaper]        - ref. to unescaper object
//
//  Synopsis:   The QUERY_STRING must be passed in *ESCAPED* form, otherwise
//              it's difficult to say for example whether an ampersand delimits
//              consecutive variables or is part of the restriction
//
//--------------------------------------------------------------------------

CQueryStringParser::CQueryStringParser( char * pszQUERY_STRING,
                                        CURLUnescaper& rUnescaper):
_pszQS(pszQUERY_STRING),
_pszQSEnd(_pszQS+strlen(_pszQS)),
_pBeg(_pszQS),
_pEnd(_pszQSEnd),
_isNull(TRUE),
_rUnescaper(rUnescaper)
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::FindVarEnd
//
//  Arguments:  [pwc]  - pointer to character at which to begin 'searching'
//                       for the end of the current variable assignment
//
//  Synopsis:   returns a pointer to the end of the variable assignment inside
//              of which pwc points - this is the next '&' if there are more
//              variable assignments following, or the terminating L'\0'
//              of QUERY_STRING if this is the last one.
//
//--------------------------------------------------------------------------

CHAR* CQueryStringParser::FindVarEnd(CHAR* psz)
{
    if (!psz)
        return NULL;

    while( (psz < _pszQSEnd) && *psz != '&')
        psz++;

    return psz;

}

//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::EatChar
//
//  Arguments:  [pwc]  - pointer to the character that is to be eaten
//
//  Synopsis:   If [pwc] points to the character before the null terminator
//              of the string, returns NULL. Otherwise, returns [pwc]+1.
//
//--------------------------------------------------------------------------

CHAR* CQueryStringParser::EatChar(char * psz)
{
   if (!psz)
       return NULL;

   psz++;
   if (*psz)
      return psz;
   else
      return NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::EatVariableName
//
//  Arguments:  [pwc]  - pointer to the character at which to start eating
//
//  Synopsis:   Eat text until a '\0', whitespace, or '=' is encountered. If
//              a '\0' is encountered, return NULL, otherwise return a pointer
//              to the first non-blob character, where a blob character is
//              defined as anything except for whitespace, '\0', and '='.
//
//--------------------------------------------------------------------------

char * CQueryStringParser::EatVariableName(char * psz)
{
    if (!psz)
        return NULL;

    //
    // Note: this limits us to Ascii for variable names, which isn't
    // really a problem since we define all the variables.
    //

    while ( (*psz) && !isspace(*psz) && ('=' != *psz))
        psz++;

    if (*psz)
        return psz;

    return NULL;
} //EatVariableName

//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::ValidateArgument
//
//  Arguments:  [pwc]  - pointer to the character string to validate
//
//  Synopsis:   Returns the pointer if valid or 0 otherwise.
//
//--------------------------------------------------------------------------


char * CQueryStringParser::ValidateArgument(char * psz)
{
    if ( ( 0 == psz ) || ( 0 == *psz ) )
        return 0;

    return psz;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryStringParser::NextVar
//
//  Synopsis:   Extract the next command-line variable contained
//              in QUERY_STRING. Returns TRUE if the next variable was
//              successfully extracted, and FALSE otherwise
//
//--------------------------------------------------------------------------

BOOL CQueryStringParser::NextVar()
{
    //
    // set the NULL flag
    //

    _isNull = TRUE;

    // we've hit the end of the buffer

    if (!_pBeg)
        return FALSE;

    // find the end of the variable assignment within the buffer
    _pEnd = FindVarEnd(_pBeg);

    if (!_pEnd || _pEnd == _pBeg)
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    //
    // copy the chunk of the QUERY_STRING into the temporary buffer for
    // unescaping
    //
    _smartBuffer.CopyTo(_pBeg, (ULONG)(_pEnd-_pBeg));  // L'\0' appended
    //_rUnescaper.Unescape(_smartBuffer.GetXPtr(), _pEnd-_pBeg);

    // move to the variable name
    CHAR* pTemp1 = ValidateArgument( _smartBuffer.GetPointer() );

    if (!pTemp1)
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    CHAR* pTemp2 = EatVariableName(pTemp1);

    if (!pTemp2)
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    //
    // Convert the variable name into a Unicode string.
    //

    ULONG cbToConvert = (ULONG)(pTemp2-pTemp1) ;
    _rUnescaper.UnescapeAndConvertToUnicode( pTemp1, cbToConvert, _xwszVarName );

    // move to the equal sign

    pTemp1=ValidateArgument(pTemp2);

    if (!pTemp1 || (*pTemp1 != L'='))
    {
        THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
    }

    pTemp1 = EatChar(pTemp1);

    //
    // if not a null value keep on eating away
    //

    if (ValidateArgument(pTemp1))
    {
        // move to the variable value

        pTemp1 = ValidateArgument(pTemp1);
        if (!pTemp1)
        {
            THROW( CException(MSG_WEBHITS_QS_FORMAT_INVALID));
        }

        // get the variable value

        cbToConvert = strlen(pTemp1);

        _rUnescaper.UnescapeAndConvertToUnicode( pTemp1, cbToConvert, _xwszVarValue );
        //
        // if we got this far, the variable had a value
        //
        _isNull = FALSE;
    }
    else
    {
        //
        // null value - delete the string name
        //
        delete _xwszVarName.Acquire();
    }

     // advance to the next variable assignment
    if (_pEnd < _pszQSEnd)
    {
        _pBeg = ++_pEnd;
    }
    else
    {
        _pBeg = NULL;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::CGetEnvVars(), public constructor
//
//  Arguments:  [webServer]     - web server to use
//              [langInfo]      - language-specific info
//              [rCollectVar]   - ref. to a variable-retrieving object
//              [rUnescaper]    - ref. to unescaper object
//
//  Synopsis:   The constructor retrieves the Filename, VPath, QUERY_STRING,
//              and Restriction.
//--------------------------------------------------------------------------

CGetEnvVars::CGetEnvVars(
    CWebServer & webServer,
    CLanguageInfo & langInfo,
    CCollectVar& rCollectVar,
    CURLUnescaper& rUnescaper ) :
_lcid(langInfo.GetUrlCodePage()),
_hiliteType(SUMMARY),
_rCollectVar( rCollectVar ),
_rUnescaper(rUnescaper),
_isBold(FALSE),
_isItalic(FALSE),
_isFixedFont(FALSE),
_ccFixedFontLine(1),
_xwc24BitColourMask(new WCHAR[8]),
_aUserParams(eMaxUserReplParams),
_langInfo( langInfo ),
_webServer( webServer ),
_dwWebHitsFileFlags( 0 ),
_dwQueryFileFlags( 0 ),
_dwTemplateFileFlags( 0 ),
_dialect( ISQLANG_V2 )
{

    for ( ULONG i = 0; i < eMaxUserReplParams; i++ )
        _aUserParams[i] = 0;

    wcscpy(_xwc24BitColourMask.GetPointer(),L"#FF0000");

    //
    //  We support only the GET and POST methods -- verify
    //

    BYTE * pszBuffer;
    ULONG  cbBuffer;

    if ( ( strcmp( webServer.GetMethod(), "GET" ) != 0 ) &&
         ( strcmp( webServer.GetMethod(), "POST" ) != 0 ) )
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: invalid REQUEST_METHOD\n" ));

        THROW( CException(MSG_WEBHITS_REQUEST_METHOD_INVALID) );
    }

    XArray<WCHAR> xHTW;
    ULONG cwc;
    if ( webServer.GetCGI_PATH_INFO( xHTW, cwc ) )
    {
        webDebugOut(( DEB_ITRACE, "htw file: '%ws'\n", xHTW.GetPointer() ));

        // Allow null.htw files to not exist, in which case the file just
        // serves as a script map trigger with default formatting info.

        WCHAR *pwc = wcsrchr( xHTW.GetPointer(), L'/' );
        if ( ( 0 != pwc ) && ( _wcsicmp( pwc+1, NullHTWFile ) ) )
            _xwcsTemplateFileVPath.Set( xHTW.Acquire() );
    }

    //
    // retrieve and parse the command line - we store in the same
    // buffer in both places
    //

    RetrieveQueryString();

    ParseQUERY_STRING();
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::ParseQUERY_STRING()
//
//  Synopsis:   parses QUERY_STRING for the various command-line parameters.
//              This method must be called AFTER RetrieveQueryString. If a
//              "crucial" variable remains unset at the end, an exception is
//              is thrown.
//
//--------------------------------------------------------------------------

void CGetEnvVars::ParseQUERY_STRING()
{
    webDebugOut(( DEB_ITRACE, "WEBHITS: parsing QS '%s'\n",
                  _xszQueryString.GetPointer() ));

    CQueryStringParser QSParser( _xszQueryString.GetPointer(), _rUnescaper );

    while(QSParser.NextVar())
    {
        XPtrST<WCHAR> xwcTempVarName;
        XPtrST<WCHAR> xwcTempVarValue;

        //
        // acquire the variable name and value from the parser, and hand it over to SetVar
        //
        if (!QSParser.IsNull())
        {
            QSParser.GetVarName(xwcTempVarName);
            QSParser.GetVarValue(xwcTempVarValue);

            SetVar(xwcTempVarName,xwcTempVarValue);
        }
    }

    VerifyQSVariablesComplete();
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::IsUserParam
//
//  Synopsis:
//
//  Arguments:  [pwcsParam] -
//
//  Returns:
//
//  Modifies:
//
//  History:    9-10-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline ULONG CGetEnvVars::IsUserParam( const WCHAR * pwcsParam )
{

    if ( 0 == _wcsnicmp( pwcsParam, wcsUserParamPrefix, cwcUserParamPrefix) )
    {
        int i = _wtoi( pwcsParam+cwcUserParamPrefix );
        if ( i > 0 && i <= eMaxUserReplParams )
            return (ULONG) i;
        else return 0;
    }
    else
    {
        return 0;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::SetVar
//
//  Arguments:  [xwszVarName] - the name of the variable being set
//              [xwszVarValue]- the value it is being set to
//
//  Synopsis:   Sets the command-line variable [xwszVarName] to [xwszVarValue]
//              and throws if the variable name is invalid. The string
//              containing the variable name is deleted here, as is the
//              string containing the variable value if the latter is of no
//              use and should not be stored.
//
//--------------------------------------------------------------------------


void CGetEnvVars::SetVar(XPtrST<WCHAR>& xwszVarName,
                         XPtrST<WCHAR>& xwszVarValue)
{
    //
    // create local copies of the smart pointers, ensuring deletion at the end
    //

    XPtrST<WCHAR> xwszLocalVarName(xwszVarName.Acquire());
    XPtrST<WCHAR> xwszLocalVarValue(xwszVarValue.Acquire());

    webDebugOut(( DEB_ITRACE, "var '%ws', value '%ws'\n",
                  xwszLocalVarName.GetPointer(),
                  xwszLocalVarValue.GetPointer() ));

    if(_wcsicmp(xwszLocalVarName.GetPointer(),RestrictionVarName) == 0)
    {
        if ( 0 != _xwcsRestriction.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );

        _xwcsRestriction.Set(xwszLocalVarValue.Acquire());
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),HiliteTypeVarName) == 0)
    {
        if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"full") == 0)
        {
            _hiliteType = FULL;
        }
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),IDQFilenameVarName) == 0)
    {
        if ( 0 != _xwcsQueryFileVPath.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );
        _xwcsQueryFileVPath.Set(xwszLocalVarValue.Acquire());
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),ColorVarName)==0)
    {
         if ( (*(xwszLocalVarValue.GetPointer()) == L'0') &&
              (wcslen(xwszLocalVarValue.GetPointer()) == 8))
         {
             //
             // a 24-bit colour spec is being passed in
             //
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),xwszLocalVarValue.GetPointer()+1,
                           sizeof(Red24BitMask));

             *(_xwc24BitColourMask.GetPointer())=L'#';
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"red")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Red24BitMask,sizeof(Red24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"blue")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Blue24BitMask,sizeof(Blue24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"green")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Green24BitMask,sizeof(Green24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"black")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Black24BitMask,sizeof(Black24BitMask));
         }
         else if (_wcsicmp(xwszLocalVarValue.GetPointer(),L"yellow")==0)
         {
             RtlCopyMemory(_xwc24BitColourMask.GetPointer(),Yellow24BitMask,sizeof(Yellow24BitMask));
         }
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),VPathWebHitsFile) == 0)
    {
        if ( 0 != _xwcsWebHitsFileVPath.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );

        _xwcsWebHitsFileVPath.Set(xwszLocalVarValue.Acquire());
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),BoldVarName) == 0)
    {
        _isBold=TRUE;
    }
    else if (_wcsicmp(xwszLocalVarName.GetPointer(),ItalicVarName)==0)
    {
        _isItalic=TRUE;
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),MaxLineLength) == 0 )
    {
        _isFixedFont = TRUE;
        if ( xwszLocalVarValue.GetPointer() )
            _ccFixedFontLine = _wtoi( xwszLocalVarValue.GetPointer() );
        _ccFixedFontLine = max( _ccFixedFontLine, 1 );
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),LocaleVar) == 0 )
    {
        //
        // Set the output and cirestriction locale info now.
        //
        if ( xwszLocalVarValue.GetPointer() )
        {
            if ( !_locale.IsNull() )
                delete _locale.Acquire();

            LCID lcid = GetLCIDFromString( xwszLocalVarValue.GetPointer() );
            _locale.Init(1+wcslen(xwszLocalVarValue.GetPointer()));
            wcscpy(_locale.GetPointer(), xwszLocalVarValue.GetPointer());

            //
            // The output will be generated using this codepage and for
            // interpretation of the "CiRestriction".
            //
            _langInfo.SetRestrictionLocale( lcid );
        }
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(), CodepageVar) == 0)
    {
        if (xwszLocalVarValue.GetPointer() )
        {
            if ( !_codepage.IsNull() )
                delete _codepage.Acquire();

            _codepage.Init(1+wcslen(xwszLocalVarValue.GetPointer()));
            wcscpy(_codepage.GetPointer(), xwszLocalVarValue.GetPointer());
        }
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(), DialectVar) == 0)
    {
        if ( xwszLocalVarValue.GetPointer() )
        {
            ULONG d = (ULONG) _wtoi( xwszLocalVarValue.GetPointer() );

            if ( d > ISQLANG_V2 || d < ISQLANG_V1 )
                THROW( CException( MSG_WEBHITS_INVALID_DIALECT ) );

            _dialect = d;
        }
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),BeginHiliteVar) == 0 )
    {
        if ( 0 != _xwcsBeginHiliteTag.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );
#if 0 // security hole -- we can't display random html from users
        _xwcsBeginHiliteTag.Set(xwszLocalVarValue.Acquire());
#endif
    }
    else if ( _wcsicmp(xwszLocalVarName.GetPointer(),EndHiliteVar) == 0 )
    {
        if ( 0 != _xwcsEndHiliteTag.GetPointer() )
            THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );
#if 0 // security hole -- we can't display random html from users
        _xwcsEndHiliteTag.Set(xwszLocalVarValue.Acquire());
#endif
    }
    else
    {
        ULONG nUserParam = IsUserParam( xwszLocalVarName.GetPointer() );
        if ( nUserParam > 0 )
        {
            if ( 0 != _aUserParams[nUserParam-1] )
                THROW( CException( MSG_WEBHITS_DUPLICATE_PARAMETER ) );

            _aUserParams[nUserParam-1] = xwszLocalVarValue.Acquire();
        }
        else
        {
           //
           // the variable name is not recognized - throw. We don't need to
           // delete the strings as they are contained in smart pointers
           //

           webDebugOut((DEB_ERROR,"WEBHITS: bad variable name:%ws\n",
                         xwszLocalVarName.GetPointer() ));

           THROW(CException(MSG_WEBHITS_VARNAME_INVALID));
        }
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::VerifyQSVariablesComplete()
//
//  Synopsis:   Checks whether all the "crucial" variables that were to be
//              set as part of QUERY_STRING have been set, and throws an
//              exception otherwise.
//
//--------------------------------------------------------------------------


void CGetEnvVars::VerifyQSVariablesComplete()
{
    if(_xwcsRestriction.IsNull())
    {
        webDebugOut(( DEB_ERROR,
                      "WEBHITS: incomplete variable set read from QS\n" ));

        THROW(CException(MSG_WEBHITS_INVALID_QUERY));
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::RetrieveCONTENT_LENGTH
//
//  Synopsis:   retrieves and returns the  value of CONTENT_LENGTH,
//              and throws if unable to retrieve
//
//--------------------------------------------------------------------------


int CGetEnvVars::RetrieveCONTENT_LENGTH()
{
    if(!_rCollectVar.GetEnvVar("CONTENT_LENGTH"))
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: failed to get CONTENT_LENGTH\n" ));

        return 0;

        THROW( CException(MSG_WEBHITS_CONTENT_LENGTH_INVALID) );
    }
    else
    {
        //
        // get the number of bytes
        //

        return _wtoi(_rCollectVar.GetVarValue());
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CGetEnvVars::RetrieveQueryString
//
//  Synopsis:   retrieves the value of QUERY_STRING, setting _xwcsQueryString
//              to point to it, and throws otherwise
//
//--------------------------------------------------------------------------

void CGetEnvVars::RetrieveQueryString()
{
    if(!_rCollectVar.GetEnvVar("QUERY_STRING"))
    {
        webDebugOut(( DEB_ERROR, "WEBHITS: failed to get QS\n" ));

        THROW( CException(MSG_WEBHITS_INVALID_QUERY) );
    }
    else
    {
        int cbToCopy  = _rCollectVar.GetMultiByteStrLen();

        //
        // we do not unescape QUERY_STRING to preserve delimiting information
        //
        _xszQueryString.Init(cbToCopy+1);

        RtlCopyMemory( _xszQueryString.GetPointer(),
                       _rCollectVar.GetMultiByteStr(),
                       cbToCopy );

        _xszQueryString[cbToCopy] = 0;
    }
}

//+-------------------------------------------------------------------------
//
//  function    GetLCID
//
//  Synopsis:   returns the locale in HTTP_ACCEPT_LANGUAGE, or if that one is
//              is not set, the one obtained from GetSystemDefaultLCID()
//
//--------------------------------------------------------------------------

LCID GetLCID( CWebServer & webServer )
{
    webDebugOut(( DEB_ITRACE,
                  "WEBHITS: Getting HTTP_ACCEPT_LANGUAGE variable\n" ));

    XArray<WCHAR> xBuffer;
    ULONG cwcBuffer;

    BOOL fOK = webServer.GetCGIVariableW( L"HTTP_ACCEPT_LANGUAGE",
                                          xBuffer,
                                          cwcBuffer );
    if ( !fOK )
    {
        LCID locale = GetSystemDefaultLCID();
        return locale;
    }

    LCID lcid = GetLCIDFromString( xBuffer.GetPointer() );
    if ( 0xFFFFFFFF == lcid )
        lcid = GetSystemDefaultLCID();

    return lcid;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetCodePageForCRunTimes
//
//  Synopsis:   Set the appropriate code page for the c-runtimes so that
//              swprintf, putchar, etc correctly translate the unicode into
//              the appropriate multi-byte sequence.
//
//  Arguments:  [codePage] - Code page of the client.
//
//  History:    9-06-96   srikants   Created
//
//----------------------------------------------------------------------------

UINT CLanguageInfo::SetCodePageForCRunTimes( UINT codePage )
{
    char szCodePage[20];

    sprintf( szCodePage,".%d", codePage );
    char * p = setlocale( LC_ALL, szCodePage );

    if ( 0 == p )
    {
        webDebugOut(( DEB_WARN,
                      "Could not set code page for %d\n. Going to system default",
                      codePage ));
        LCID lcid = GetSystemDefaultLCID();
        codePage = LocaleToCodepage( lcid );

        sprintf( szCodePage,".%d", codePage );
        char * p = setlocale( LC_ALL, szCodePage );
    }

    return codePage;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSortQueryHits::Init()
//
//  Synopsis:   Initialization function for CSortQueryHits (need to do this
//              as a HitIter& is needed to fully construct this class).
//              creates array of positions sorted in order of occurrence
//              within the document (note that a position may occur several
//              times).
//
//--------------------------------------------------------------------------


void CSortQueryHits::Init()

{
    Win4Assert(0 == _aPosition);
    _positionCount = CountPositions();

    if (0 != _positionCount)
    {
        _aPosition = new Position[_positionCount];

        int iPosition=0;

        for (BOOL fOk=_rHitIter.FirstHit();fOk;fOk=_rHitIter.NextHit())
        {
            int posInHit=_rHitIter.GetPositionCount();
            for (int i=0;i<posInHit;i++)
                _aPosition[iPosition++] = _rHitIter.GetPosition(i);
        }

        Win4Assert(iPosition == _positionCount);
        qsort(_aPosition,_positionCount,sizeof(Position),&ComparePositions);
    }

}


//+-------------------------------------------------------------------------
//
//  Member:     CSortQueryHits::CountPositions()
//
//  Synopsis:   Count the total number of positions across all hits returned
//              by ISearch.
//
//--------------------------------------------------------------------------


int CSortQueryHits::CountPositions()

{
    int count=0;

    for (BOOL fOk = _rHitIter.FirstHit();fOk;fOk=_rHitIter.NextHit() )
    {
        count +=_rHitIter.GetPositionCount();
        webDebugOut(( DEB_ITRACE, "Count = %d\n", count ));
    }

    return count;
}


//+-------------------------------------------------------------------------
//
//  Member:     CLinkQueryHits::CLinkQueryHits, public constructor
//
//  Arguments:  [rInternalQuery]    - DbRestriction
//              [rGetEnvVars]       - object containing CGI env. variables
//              [rHttpOutput]       - HTTP output object
//              [cmsReadTimeout]    - Read timeout for IFilter on the doc
//              [lockSingleThreadedFilter] - lock for single-threaded filters
//              [propertyList]      - Properties to webhit
//              [ulDisplayScript]   - Flags for displaying scripts
//
//--------------------------------------------------------------------------


CLinkQueryHits::CLinkQueryHits(
    CInternalQuery &  rInternalQuery,
    CGetEnvVars &     rGetEnvVars,
    PHttpFullOutput&  rHttpOutput,
    DWORD             cmsReadTimeout,
    CReleasableLock & lockSingleThreadedFilter,
    CEmptyPropertyList &   propertyList,
    ULONG             ulDisplayScript ) :

_document( (WCHAR*) rGetEnvVars.GetWebHitsFilePPath(),
           BOGUS_RANK,
           rInternalQuery.GetISearchRef(),
           cmsReadTimeout,
           lockSingleThreadedFilter,
           propertyList,
           ulDisplayScript ),
_rGetEnvVars(rGetEnvVars),
_rInternalQuery(rInternalQuery),
_rHttpOutput(rHttpOutput),
_HitIter(),
_sortedHits(_HitIter),
_currentOffset(0),
_posIndex(0),
_tagCount(0),
_ccOutputBuffer(0)
{
    //
    // initialize the iterator
    //

    _HitIter.Init(&_document);
    _sortedHits.Init();

    //
    // set the total count of positions
    //

    _posCount = _sortedHits.GetPositionCount();

    //
    // if there are any positions, initialize the "next position" data members
    // to the first one
    //

    if (_posCount > 0)
    {
        Position    nextPos = _sortedHits.GetPosition(0);

        _nextBegOffset = nextPos.GetBegOffset();
        _nextEndOffset = nextPos.GetEndOffset();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CLinkQueryHits::IsSeparatedBySpaces
//
//  Arguments:  [startOffset]    - beginning offset
//              [endOffset]      - ending offset
//
//  Synopsis:   returns TRUE if the positions in the current paragraph
//              determined by [startOffset] and [endOffset] are separated
//              by whitespace characters.
//
//  Note:       There is a maximum 'allowed' separation, beyond which
//              whitespace is considered significant.
//
//--------------------------------------------------------------------------

unsigned const ccSignificantWhitespace = 20;

BOOL CLinkQueryHits::IsSeparatedBySpaces(int startOffset, int endOffset)
{
    Win4Assert( startOffset <= endOffset );

    if (startOffset > endOffset)
        return FALSE;

    //
    // Small buffer for calls to GetStringTypeW
    //

    WORD awCharType[ccSignificantWhitespace];
    int len = endOffset - startOffset;

    if ( 0 == len )
        return TRUE;

    if ( len > ccSignificantWhitespace )
        return FALSE;

    const WCHAR* pStart = _document.GetPointerToOffset(startOffset);

    //
    // Check for whitespace
    //

    if ( !GetStringTypeW( CT_CTYPE1, pStart, len, awCharType ) )
    {
        webDebugOut(( DEB_ERROR, "GetStringType returned %d\n", GetLastError() ));
        return FALSE;
    }

    //
    // Only blanks are legal 'spaces'
    //

    for ( int i = 0; i < len; i++ )
    {
        if ( 0 == (awCharType[i] & C1_BLANK) )
            return FALSE;
    }

    return TRUE;

}

//+-------------------------------------------------------------------------
//
//  Member:     CLinkQueryHits::InsertLinks
//
//  Synopsis:   Hit highlight the document by inserting linked HTML tags
//
//--------------------------------------------------------------------------

void CLinkQueryHits::InsertLinks()
{

    if ( !_rHttpOutput.IsTemplateFilePresent() )
        _rHttpOutput.TagPosition(-1);

    _rHttpOutput.OutputFullHeader();

    //
    // Determine if this is a mainly text document.
    //
    if ( _rGetEnvVars.IsFixedFont() )
        _rHttpOutput.OutputPreformattedTag();

    ULONG eofOffset = _document.GetEOFOffset();

    if (_sortedHits.GetPositionCount() == 0)
    {
        //
        // There are no hits. Just render the whole text.
        //
         WCHAR*  pText = _document.GetWritablePointerToOffset(0);
        _rHttpOutput.OutputHttpText(pText,eofOffset);
    }
    else
    {
        BOOL openTag = FALSE;

        while(_currentOffset < (int) eofOffset)
        {
            WCHAR*  pText = _document.GetWritablePointerToOffset(_currentOffset);
            const ULONG cSectionSize = _nextBegOffset - _currentOffset;

            if ( cSectionSize > 0 )
            {
                _rHttpOutput.OutputHttpText(pText,cSectionSize);
                _currentOffset +=cSectionSize;

                if ( (int) eofOffset == _currentOffset )
                    break;

                pText+=cSectionSize;
            }

            const ULONG cHiliteSize = _nextEndOffset - _nextBegOffset;

            if ( cHiliteSize > 0 )
            {
                //
                // display the "<<" tag - if a tag is not already open
                //

                if (!openTag)
                {
                    _rHttpOutput.OutputLeftTag(_tagCount-1);
                    _rHttpOutput.TagPosition(_tagCount);
                    openTag = TRUE;
                }

                //
                // display the highlited position text
                //

                _rHttpOutput.OutputHilite(pText, cHiliteSize);
                _currentOffset += cHiliteSize;
                Win4Assert(_currentOffset == _nextEndOffset);
            }

            //
            // get the next distinct position
            //

            BOOL existsNextPosition = MoveToNextDifferentPosition();

            //
            // display the ">>" tag unless separated only by spaces or
            // last tag in doc in which case we have to make it point to the
            // top
            if ( !existsNextPosition )
            {
                if ( openTag )
                {
                    _rHttpOutput.OutputRightTag(-1);
                    openTag = FALSE;
                }

                _nextBegOffset = _nextEndOffset = eofOffset;
            }
            else if ( openTag && !IsSeparatedBySpaces(_currentOffset,_nextBegOffset) )
            {
                _rHttpOutput.OutputRightTag(_tagCount+1);
                _tagCount++;
                openTag = FALSE;
            }
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::CExtractedHit, public constructor
//
//  Arguments:  [rDocument]    - ref. to document being hilited
//                              [rHit]         - ref. to hit being hilited
//              [rOutput]      - ref. to Http Output object
//              [cwcMargin]    - number of chars. to be printed before and
//                               after the hit
//              [cwcSeparation]- maximum number of characters that may
//                               separate consecutive positions before
//                               truncation occurs
//              [cwcDelim]     - the number of characters to print before and
//                               after a position in the case of truncation
//--------------------------------------------------------------------------


CExtractedHit::CExtractedHit(   CDocument& rDocument,
                                Hit& rHit,
                                PHttpOutput& rOutput,
                                int cwcMargin,
                                int cwcSeparation,
                                int cwcDelim ):

_rDocument(rDocument),
_rHit(rHit),
_cwcMargin(cwcMargin),
_rOutput(rOutput),
_cwcSeparation(cwcSeparation),
_cwcDelim(cwcDelim),
_cwcOutputBuffer(0)
{
   SortHit();
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::SortHit()
//
//  Synopsis:   Sort the positions in the hit in the order in which they occur
//              in the document
//
//--------------------------------------------------------------------------


void CExtractedHit::SortHit()
{
   qsort( _rHit._aPos,
          _rHit.GetPositionCount(),
          sizeof(Position),
          &ComparePositions );
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::DisplayPosition
//
//  Arguments:  [rPos]  - ref. to position being displayed
//
//  Synopsis:   Display the highlighted position (i.e. JUST the position)
//
//--------------------------------------------------------------------------

void CExtractedHit::DisplayPosition(const Position& rPos)
{
    const WCHAR* pText = _rDocument.GetPointerToOffset(rPos.GetBegOffset());
    _rOutput.OutputHilite(pText,rPos.GetLength());
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::ExtractHit()
//
//  Synopsis:   Extract the hit - i.e. display all of the positions and
//              the associated preamble/postamble text
//
//--------------------------------------------------------------------------

void CExtractedHit::ExtractHit()
{
    //
    // make sure that we are not dealing with a null hit - i.e. a hit composed
    // entirely of null positions

    if (_rHit.IsNullHit())
        return;

    // stores the number of positions in the hit

    int cPositions = _rHit.GetPositionCount();

    //
    // introduce new paragraph
    //

    _rOutput.OutputParaTag();
    _rOutput.OutputEllipsis();

    //
    // go through displaying each position
    //

    //
    // find the first non-null position in the hit
    //

    int firstRealPos = EatNullPositions();

    //
    // display the preamble
    //

    PrintPreamble(_rHit.GetPos(firstRealPos),_cwcMargin);

    //
    // display the positions and the stuff in between the positions
    //

    for (int i=firstRealPos;i < cPositions; i++)
    {
        DisplayPosition(_rHit.GetPos(i));

        // the stuff between consecutive positions

        if (i != cPositions - 1)
        {
            //
            // guard against the case where multiple identical positions are
            // returned as part of the same hit
            //


            if (_rHit.GetPos(i).GetBegOffset() <
                    _rHit.GetPos(i+1).GetBegOffset())
            {
                PrintBtwPositions(_rHit.GetPos(i),_rHit.GetPos(i+1));
            }
            else
            {
                while ( ( i != ( cPositions - 1 ) ) &&
                        ( _rHit.GetPos(i).GetBegOffset() ==
                          _rHit.GetPos(i+1).GetBegOffset() ) )
                    i++;
            }
        }
    }

    //
    // display the postamble
    //

    PrintPostamble(_rHit.GetPos(cPositions-1),_cwcMargin);

    _rOutput.OutputEllipsis();
    _rOutput.OutputHRULE();
} //ExtractHit

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::ComputeDistance
//
//  Arguments:  [rStartPos] - ref. to starting position
//              [rEndPos]   - ref. to end position
//
//  Synopsis:   Compute the distance in characters between the start and
//              end positions
//
//--------------------------------------------------------------------------


ULONG CExtractedHit::ComputeDistance (const Position& rStartPos,
    const Position& rEndPos)
{
    return rEndPos.GetBegOffset() - rStartPos.GetEndOffset();
}

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::PrintPreamble
//
//  Arguments:  [rStartPosition] - ref. to start position
//              [cwcDist]        - maximum number of characters to print
//
//
//  Synopsis:   Prints the context text preceding the hit - the number of
//              characters printed depends on cwcDist. The break is made
//              at a word boundary
//
//--------------------------------------------------------------------------

void CExtractedHit::PrintPreamble(const Position& rStartPosition,int cwcDist)
{

    WCHAR* pBeg = _rDocument.GetWritablePointerToOffset(
                                        rStartPosition.GetBegOffset()-cwcDist);
    const WCHAR* pEnd = _rDocument.GetPointerToOffset(
                                        rStartPosition.GetBegOffset());

    // Boundary case - if the beginning of the document, don't skip any thing
    if ( pBeg != _rDocument.GetPointerToOffset(0) )
    {
        while( (pBeg < pEnd) &&
               !iswspace(*pBeg) &&
               !(UNICODE_PARAGRAPH_SEPARATOR == *pBeg))
            pBeg++;
    }

    Win4Assert(pBeg <= pEnd);
    _rOutput.OutputHttpText(pBeg, CiPtrToUlong( pEnd-pBeg ));
} //PrintPreamble

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::PrintPostamble
//
//  Arguments:  [rStartPosition] - ref. to start position
//              [cwcDist]        - maximum number of characters to be printed
//
//  Synopsis:   Print the context text following the hit - the number of
//              characters printed depends on cwcDist. The break is made
//              at a word boundary
//
//--------------------------------------------------------------------------

void CExtractedHit::PrintPostamble(const Position& rStartPosition, int cwcDist)
{

    WCHAR* pBeg = _rDocument.GetWritablePointerToOffset(
                                         rStartPosition.GetEndOffset());
    const WCHAR*  pEnd = _rDocument.GetPointerToOffset(
                                         rStartPosition.GetEndOffset()+cwcDist);

    while( (pEnd > pBeg) &&
           !iswspace(*pEnd) &&
           !(UNICODE_PARAGRAPH_SEPARATOR == *pEnd) )
        pEnd--;

    Win4Assert(pEnd >= pBeg);

    _rOutput.OutputHttpText( pBeg, CiPtrToUlong( pEnd-pBeg ));
} //PrintPostamble

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHit::PrintBtwPositions
//
//  Arguments:  [rStartPosition] - ref. to start position
//              [rEndPosition]   - ref. to end position
//
//  Synopsis:   Display the text between the two positions, breaking at word
//              boundaries. If the positions are separated by a distance
//              greated than _cwcSeparation, then the text in-between is
//              truncated, and up to _cwcDelim characters after the first and
//              before the second position are printed, separated by an
//              ellipsis
//
//--------------------------------------------------------------------------

void CExtractedHit::PrintBtwPositions(  const Position& rStartPosition,
                                        const Position& rEndPosition)
{

    long dist;

    if ((dist=ComputeDistance(rStartPosition,rEndPosition)) > _cwcSeparation)
    {
        PrintPostamble(rStartPosition,_cwcDelim);
        _rOutput.OutputEllipsis();
        PrintPreamble(rEndPosition,_cwcDelim);
    }
    else
    {
        WCHAR* pText = _rDocument.GetWritablePointerToOffset(
            rStartPosition.GetEndOffset() );

        _rOutput.OutputHttpText(pText,dist);
    }
} //PrintBtwPositions

//+-------------------------------------------------------------------------
//
//  Member:     CExtractedHits::ExtractHits
//
//  Arguments:  same as CExtractHit constructor, except rHitIter - a hit
//              iterator replaces the hit reference
//
//  Synopsis:   Class functor to encapsulate the action of highliting the
//              hits in rHitIter. A temporary CExtractHit object is created
//              for each hit.
//
//--------------------------------------------------------------------------

CExtractHits::CExtractHits(CDocument& rDocument,
                           HitIter& rHitIter,
                           PHttpOutput& rOutput,
                           int cwcMargin,
                           int cwcDelim,
                           int cwcSeparation )

{
    for (BOOL fOK=rHitIter.FirstHit(); fOK; fOK = rHitIter.NextHit())
    {
        CExtractedHit extractedHit( rDocument,
                                    rHitIter.GetHit(),
                                    rOutput,
                                    cwcMargin,
                                    cwcDelim,
                                    cwcSeparation );
        extractedHit.ExtractHit();
    }
} //CExtractHits

//+-------------------------------------------------------------------------
//
//  Member:     PHttpOutput::PHttpOutput - public constructor
//
//  Arguments:  [webServer] -- The web server to write to
//              [langInfo]  -- Language information
//
//--------------------------------------------------------------------------

PHttpOutput::PHttpOutput(
    CWebServer & webServer,
    CLanguageInfo & langInfo ):
_hasPrintedHeader(FALSE),
_xwc24BitColourMask(new WCHAR[8]),
_isBold(FALSE),
_isItalic(FALSE),
_isInPreformat(FALSE),
_newLine(FALSE),
_cwcOutputBuffer(0),
_pGetEnvVars(NULL),
_pTemplate(NULL),
_fUseHiliteTags(FALSE),
_cwcBeginHiliteTag(0),
_cwcEndHiliteTag(0),
_webServer( webServer ),
_langInfo( langInfo )
{
    wcscpy(_xwc24BitColourMask.GetPointer(),L"#FF0000");

    _mbStr.Init( MAX_OUTPUT_BUF );
}

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::Init
//
//  Synopsis:   Initializes the output generation class with the environment
//              variables object and the template object.
//
//  Arguments:  [pGetEnvVars] - Pointer to the object that has the relevant
//              environment variables.
//              [pTemplate]   - [OPTIONAL] - Pointer to the template object.
//              If non-zero, this will be used to generate the output for
//              hit-highlighter.
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::Init(CGetEnvVars* pGetEnvVars, CWebhitsTemplate * pTemplate )
{
    Win4Assert( 0 != pGetEnvVars );

    delete[] _xwc24BitColourMask.Acquire();
    _pGetEnvVars = pGetEnvVars;
    _xwc24BitColourMask.Set(_pGetEnvVars->GetColour().Acquire());
    _isItalic = _pGetEnvVars->GetItalic();
    _isBold  = _pGetEnvVars->GetBold();

    _ccCurrLine = 0;
    _ccMaxLine = _pGetEnvVars->GetFixedFontLineLen();

    _pTemplate = pTemplate;

    _fUseHiliteTags = _pGetEnvVars->GetBeginHiliteTag() &&
                      _pGetEnvVars->GetEndHiliteTag();
    if ( _fUseHiliteTags )
    {
        _cwcBeginHiliteTag = wcslen( _pGetEnvVars->GetBeginHiliteTag() );
        _cwcEndHiliteTag = wcslen( _pGetEnvVars->GetEndHiliteTag() );
    }

}

#define WCHAR_COUNT(x) ( (sizeof(x)/sizeof(WCHAR))-1 )

//+-------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputHtmlHeader()
//
//  Synopsis:   Output the HTML header
//
//--------------------------------------------------------------------------


void PHttpOutput::OutputHTMLHeader()
{

    if ( 0 == _pTemplate || !_pTemplate->DoesHeaderExist() )
    {
        WCHAR* pwszTemp;

        static const WCHAR wszHdr1[] = L"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n<HTML>\n<HEAD>\n";
        static const ULONG ccHdr1 = WCHAR_COUNT(wszHdr1);
        OutputHttp( wszHdr1, ccHdr1 );

        static const WCHAR wszHdr2[] = L"<TITLE>Query Results</TITLE>\n</HEAD>\n";
        static const ULONG ccHdr2 = WCHAR_COUNT(wszHdr2);
        OutputHttp( wszHdr2, ccHdr2 );

        static const WCHAR wszHdr3[] =  L"<H2>\"";
        static const ULONG ccHdr3 = WCHAR_COUNT(wszHdr3);
        OutputHttp( wszHdr3, ccHdr3 );

        pwszTemp = (WCHAR*) _pGetEnvVars->GetRestriction();
        OutputHttpText(pwszTemp, wcslen(pwszTemp));

        static const WCHAR wszHdr4[] = L"\" in </H2>\n";
        static const ULONG ccHdr4 = WCHAR_COUNT( wszHdr4 );
        OutputHttp( wszHdr4, ccHdr4 );

        static const WCHAR wszHdr5[] = L"<H2><a href=\"";
        static const ULONG ccHdr5 = WCHAR_COUNT(wszHdr5);
        OutputHttp( wszHdr5, ccHdr5 );

        pwszTemp = (WCHAR*) _pGetEnvVars->GetWebHitsFileVPath();
        OutputHttp(pwszTemp,wcslen(pwszTemp));

        static const WCHAR wszHdr6[] = L"\">";
        static const ULONG ccHdr6 = WCHAR_COUNT(wszHdr6);
        OutputHttp( wszHdr6, ccHdr6 );

        OutputHttpText(pwszTemp,wcslen(pwszTemp));

        static const WCHAR wszHdr7[] = L"</a> </H2><P><HR>\n<BODY>";
        static const ULONG ccHdr7 = WCHAR_COUNT(wszHdr7);
        OutputHttp( wszHdr7, ccHdr7 );
    }
    else
    {
        static const WCHAR wszHdr8[] = L"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n";
        static const ULONG ccHdr8 = WCHAR_COUNT(wszHdr8);
        OutputHttp( wszHdr8, ccHdr8 );

        CVirtualString  str;
        _pTemplate->GetWTXFile().GetHeader( str, _pTemplate->GetVariableSet() );
        OutputHttp( str.Get(), str.StrLen() );
    }

    _hasPrintedHeader = TRUE;
} //OutputHTMLHeader

//+-------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputHtmlFooter
//
//  Synopsis:   Output HTML footer
//
//--------------------------------------------------------------------------


void PHttpOutput::OutputHTMLFooter()
{
    if ( _isInPreformat )
    {
        static const WCHAR wszTag1[] = L"</pre>";
        static const ULONG ccTag1 = WCHAR_COUNT( wszTag1 );
        OutputHttp( wszTag1, ccTag1 );
    }

    if ( 0 == _pTemplate || !_pTemplate->DoesFooterExist() )
    {
        static const WCHAR wszTag2[] = L"</BODY>\n </HTML>";
        static const ULONG ccTag2 = WCHAR_COUNT( wszTag2 );
        OutputHttp( wszTag2, ccTag2 );
    }
    else
    {
        CVirtualString  str;
        _pTemplate->GetWTXFile().GetFooter( str,
                                           _pTemplate->GetVariableSet() );
        OutputHttp( str.Get(), str.StrLen() );
    }
} //OutputHTMLFooter

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputHilite()
//
// Arguments: [pwszBuffer]      - pointer to the buffer to be output highlited
//            [cwcBuffLength]   - number of characters to print from the buff.
//
// Synopsis:  Output the buffer in highlited form
//
//+-----------------------------------------------------------------------
void PHttpOutput::OutputHilite(const WCHAR* pwszBuffer, ULONG cwcBuffLength)
{
    if ( !_fUseHiliteTags )
    {
        WCHAR wcsColourCodeEnd[] = L"</font>";
        WCHAR wcsColourTag[50];
        swprintf(wcsColourTag,L"<font color=\"%s\">",_xwc24BitColourMask.GetPointer());

        static const WCHAR wcsBoldBegin[]=L"<B>";
        static const cwcBoldBegin = wcslen( wcsBoldBegin );

        static const WCHAR wcsItalicBegin[]=L"<em>";
        static const cwcItalicBegin = wcslen( wcsItalicBegin );

        static const WCHAR wcsBoldEnd[]=L"</B>";
        static const cwcBoldEnd = wcslen(wcsBoldEnd);

        static const WCHAR wcsItalicEnd[]=L"</em>";
        static const cwcItalicEnd=wcslen(wcsItalicEnd);

        if (_isBold)
        {
            OutputHttp( wcsBoldBegin,cwcBoldBegin);
        }
        if (_isItalic)
        {
            OutputHttp( wcsItalicBegin, cwcItalicBegin);
        }

        OutputHttp(wcsColourTag,wcslen(wcsColourTag));
        OutputHttp(pwszBuffer,cwcBuffLength);
        OutputHttp(wcsColourCodeEnd,wcslen(wcsColourCodeEnd));

        if (_isItalic)
        {
            OutputHttp( wcsItalicEnd, cwcItalicEnd );
        }
        if (_isBold)
        {
            OutputHttp( wcsBoldEnd, cwcBoldEnd );
        }
    }
    else
    {
        OutputHttp( _pGetEnvVars->GetBeginHiliteTag(), _cwcBeginHiliteTag );
        OutputHttp( pwszBuffer,cwcBuffLength );
        OutputHttp( _pGetEnvVars->GetEndHiliteTag(), _cwcEndHiliteTag );
    }
} //OutputHilite

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputLeftTag()
//
// Arguments: [tagParam]   - integer to be used in setting destination tag
//
// Synopsis:  Output the "<<" tag, making it refer to "Tag[tagParam]"
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputLeftTag(int tagParam)
{

    _cwcOutputBuffer = swprintf(_wcOutputBuffer,L"%s\"%s%d\"%s",
                    L"<a href=",L"#CiTag",tagParam,L">&lt;&lt;</a>");
    OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputRightTag()
//
// Arguments: [tagParam]    - integer to be used in setting destination tag
//
// Synopsis:  Output the ">>" tag, making it refer to "Tag[tagParam]"
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputRightTag(int tagParam)
{
    _cwcOutputBuffer = swprintf(_wcOutputBuffer, L"%s\"%s%d\"%s",L"<a href=",
                            L"#CiTag", tagParam, L">&gt;&gt;</a>&nbsp;");
    OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputEllipsis()
//
// Synopsis:  Output the ellipsis that separates the truncated text between
//            two consecutive positions
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputEllipsis()
{
    OutputHttp(L" ... ",5);
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputFullHeader()
//
// Synopsis:  Output the additional header information specific to the
//            full hit-highliting
//
//+-----------------------------------------------------------------------

void PHttpFullOutput::OutputFullHeader()
{
    if ( 0 == _pTemplate || !_pTemplate->DoesHeaderExist() )
    {
        _cwcOutputBuffer = swprintf(_wcOutputBuffer,
                L"%s\"%s\"%s %s %s\"%s\"%s",
                L"<h3><b> <font color=",
                L"#FF0000",
                L">",
                L"&lt;&lt; </font> takes you to the previous hit. ",
                L"<font color=",L"#FF0000",
                L"> &gt;&gt; </font> takes you to the next hit.</b></h3><P>\n");

        OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);

        _cwcOutputBuffer = swprintf(_wcOutputBuffer, L"%s\"%s\"%s %s",
                L"<b>Click <a href=",L"#CiTag0",
                L"> &gt;&gt; </a> to go to the first hit</b>\n", L"<HR>\n" );


        OutputHttp(_wcOutputBuffer, _cwcOutputBuffer);
    }
} //OutputFullHeader

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::WriteToStdout
//
//  Synopsis:
//
//  Arguments:  [pwcsBuffer] - the buffer
//              [cLength]    - count of wide characters
//
//  History:    11-15-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::WriteToStdout( WCHAR const * pwcsBuffer, ULONG cLength )
{
    if ( 0 != cLength )
        _vsResult.StrCat( pwcsBuffer, cLength );
} //WriteToStdout

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::Flush
//
//  Synopsis:   Flushes the buffer to the web server
//
//  History:    10-10-97   dlee   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::Flush()
{
    if ( 0 != _vsResult.StrLen() )
    {
        DWORD cbToWrite = WideCharToXArrayMultiByte(
                            _vsResult.Get(),
                            _vsResult.StrLen(),
                            _langInfo.GetOutputCodePage(),
                            _mbStr );

        if ( 0 != cbToWrite )
            _webServer.RawWriteClient( _mbStr.Get(), cbToWrite );

        _vsResult.Empty();
    }
} //Flush

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputPreformattedTag
//
//  Synopsis:   Outputs the pre-formatted tag if not already emitted.
//
//----------------------------------------------------------------------------


void PHttpOutput::OutputPreformattedTag()
{
    if ( !_isInPreformat )
    {
        static WCHAR wszTag[] = L"<pre>";
        static const len = ( sizeof(wszTag)/sizeof(WCHAR) ) - 1;

        WriteToStdout( wszTag, len );

        _isInPreformat = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputPreFormatRawText
//
//  Synopsis:   Outputs the text for pre-formatted type.
//
//  Arguments:  [pwcsBuffer] -
//              [cLength]    -
//
//  History:    11-15-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::OutputPreFormatRawText( const WCHAR * pwcsBuffer,
                                          ULONG cLength )
{
    Win4Assert( _isInPreformat );

    WCHAR const * pwcsCurrLineBegin = pwcsBuffer;

    for ( ULONG i=0, cwcToWrite = 0;
          i< cLength;
          i++ )
    {
        if ( IsNewLine( pwcsBuffer[i] ) )
        {
            //
            // Empty out the current line - as much as has been
            // accumulated.
            //
            WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
            WriteNewline();


            if ( pwcsBuffer[i] == '\r' && pwcsBuffer[i+1] == '\n' )
                i++;

            _ccCurrLine = cwcToWrite = 0;
            pwcsCurrLineBegin = pwcsBuffer+i+1;  // Position at the next character
        }
        else
        {
            //
            // Include this character in the current line.
            //
            cwcToWrite++;

            //
            // _ccCurrLine is cumulative from multiple invocations.
            //
            _ccCurrLine++;

            if ( _ccCurrLine > _ccMaxLine && iswspace( pwcsBuffer[i] ) )
            {
                //
                // Write out the line and force a line feed.
                //

                WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
                WriteNewline();

                pwcsCurrLineBegin += cwcToWrite;
                Win4Assert( pwcsCurrLineBegin == pwcsBuffer+i+1 );
                _ccCurrLine = cwcToWrite = 0;
            }
        }
    }

    WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
} //OutputPreFormatRawText

void PHttpOutput::WriteNewline()
{
    static WCHAR wcNewLine[] = L"\r\n";
    static const len = (sizeof(wcNewLine)/sizeof(WCHAR))-1;

    WriteToStdout( wcNewLine, len );
}

void PHttpOutput::WriteBreakTag()
{
    static WCHAR wcBreakTag[] = L"<BR>";
    static const len = (sizeof(wcBreakTag)/sizeof(WCHAR)) - 1;

    WriteToStdout( wcBreakTag, len );
}

//+-----------------------------------------------------------------------
//
// Member:  PHttpOutput::OutputHttp
//
// Arguments:   [pwcsBuffer] - pointer to buffer containing text
//              [cLength]    - the number of characters to print
//              [fRawText]   - if TRUE, convert cr, lf and paragraph
//                                  mark to <BR> or newline
//
// Synopsis: Encapsulates the output operation - for now, writes to stdout
//
//+-----------------------------------------------------------------------


void PHttpOutput::OutputHttp( const WCHAR* pwcsBuffer, ULONG cLength,
                              BOOL fRawText )
{
    if ( !fRawText )
    {
        //
        // This is HTML header or footer or formatting. No need to
        // introduce <BR> tags for new-lines and paragraphs.
        //
        WriteToStdout( pwcsBuffer, cLength );
        return;
    }
    else if ( _isInPreformat )
    {
        //
        // We can emit cr-lf as cr-lf. No need to convert to <BR> tags.
        // However, we have to respect the max-line length.
        //
        OutputPreFormatRawText( pwcsBuffer, cLength );
        return;
    }

    //
    // We must output raw text that is not pre-formatted. We have to
    // convert the newlines, paragraph separators to BreakTags.
    //
    WCHAR const * pwcsCurrLineBegin = pwcsBuffer;

    for ( ULONG i=0, cwcToWrite = 0;
          i< cLength;
          i++ )
    {
        if ( IsNewLine( pwcsBuffer[i] ) )
        {
            WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
            WriteBreakTag();

            if ( pwcsBuffer[i] == '\r' && pwcsBuffer[i+1] == '\n' )
                i++;

            cwcToWrite = 0;
            pwcsCurrLineBegin = pwcsBuffer+i+1;
        }
        else
        {
            cwcToWrite++;
        }
    }

    WriteToStdout( pwcsCurrLineBegin, cwcToWrite );
} //OutputHttp

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputErrorHeader()
//
// Synopsis:  Output an "ERROR" header
//
//+-----------------------------------------------------------------------

void PHttpOutput::OutputErrorHeader()
{
    static const WCHAR wszHdr[] = L"HTTP/1.0 200 OK \r\nContent-Type: text/html\r\n\r\n<HTML>\n<BODY>\n";
    static const ULONG ccHdr = WCHAR_COUNT( wszHdr );
    OutputHttp( wszHdr, ccHdr  );
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::OutputErrorMessage
//
// Synopsis:  Send error message to stdout / web page
//
// Arguments: [pwcsBuffer] -- Error message
//            [ccBuffer]   -- Size in characters of [pwcsBuffer]
//
// History:   31-Jul-97    KyleP   Added header
//
//+-----------------------------------------------------------------------

void PHttpOutput::OutputErrorMessage( WCHAR * pwcsBuffer, ULONG ccBuffer )
{
    static const WCHAR wszTag1[] = L"<p><h3><center>";
    static const ULONG ccTag1 = WCHAR_COUNT( wszTag1 );
    OutputHttp( wszTag1, ccTag1 );

    OutputHttpText( pwcsBuffer, ccBuffer );

    static const WCHAR wszTag2[] = L"</center></h3><BR>";
    static const ULONG ccTag2 = WCHAR_COUNT( wszTag2 );
    OutputHttp( wszTag2, ccTag2 );
}

//+-----------------------------------------------------------------------
//
// Member:    PHttpOutput::TagPosition
//
// Arguments: [tagParam] - output a <NAME="Tag[tagParam]"> tag
//
// Synopsis:  Tag the current position
//
//+-----------------------------------------------------------------------


void PHttpOutput::TagPosition(int tagParam)
{
    _cwcOutputBuffer= swprintf(_wcOutputBuffer,L"%s\"%s%d\"%s",
                            L"<a NAME=",L"CiTag",tagParam,L"> </a>");

    OutputHttp(_wcOutputBuffer,_cwcOutputBuffer);
}

//+---------------------------------------------------------------------------
//
//  Member:     PHttpOutput::OutputHttpText
//
//  Synopsis:   Outputs the given data as "text" and not as html formatting.
//
//  Arguments:  [pwcsBuffer] - buffer to be output
//              [cchLength]  - length of pwcsBuffer
//
//  Notes:      Any UNICODE_PARAGRAPH_SEPARATOR characters in the buffer
//              need to be preserved for use by OutputHttp
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void PHttpOutput::OutputHttpText( WCHAR * pwcsBuffer, ULONG cchLength )
{
    if ( cchLength > 0 )
    {
        //
        // NOTE - HTMLEscapeW expects the string to be NULL terminated. It
        // does not accept a length field. HTMLEscapeW is one of the most
        // frequently executed routines in idq.dll and so changing it to
        // optionally take in a length parameter may affect performance.
        // That is why I have chosen to overwrite the current buffer with
        // a NULL at cchLength and restore it after the escaping - srikants.
        //
        const WCHAR wcTemp = pwcsBuffer[cchLength];
        pwcsBuffer[cchLength] = 0;

        WCHAR * pwcsTmpBuf = pwcsBuffer;
        WCHAR * pwcsParaMark = wcschr( pwcsTmpBuf, UNICODE_PARAGRAPH_SEPARATOR );
        while ( 0 != pwcsParaMark )
        {
            _escapedStr.Empty();
            *pwcsParaMark = 0;
            HTMLEscapeW( pwcsTmpBuf, _escapedStr, _langInfo.GetOutputCodePage() );
            _escapedStr.CharCat( UNICODE_PARAGRAPH_SEPARATOR );
            OutputHttp( _escapedStr.Get(), _escapedStr.StrLen(), TRUE );

            *pwcsParaMark = UNICODE_PARAGRAPH_SEPARATOR;
            pwcsTmpBuf = pwcsParaMark + 1;
            pwcsParaMark = wcschr( pwcsTmpBuf, UNICODE_PARAGRAPH_SEPARATOR );
        }

        if (*pwcsTmpBuf)
        {
            _escapedStr.Empty();
            HTMLEscapeW( pwcsTmpBuf, _escapedStr, _langInfo.GetOutputCodePage() );
            OutputHttp( _escapedStr.Get(), _escapedStr.StrLen(), TRUE );
        }
        pwcsBuffer[cchLength] = wcTemp;
    }
} //OutputHttpText

//+---------------------------------------------------------------------------
//
//  Member:     CWebhitsTemplate::CWebhitsTemplate
//
//  Synopsis:   Constructor of the webhits template file. It takes the
//              environment variables object and reads in the htx file,
//              processes it. Also, adds the appropriate replaceable
//              parameters.
//
//  Arguments:  [envVars]  - Environment variables to use
//              [codePage] - Codepage to use for the template
//
//  History:    9-09-96   srikants   Created
//
//----------------------------------------------------------------------------

CWebhitsTemplate::CWebhitsTemplate(
    CGetEnvVars const & envVars,
    ULONG               codePage )
: _wtxFile( envVars.GetTemplateFileVPath(),
            envVars.GetTemplateFilePPath(),
            codePage )
{
    //
    // Add the replacable parameters to the variable set.
    //
    _variableSet.AddParam( wcsParamCiUrl, envVars.GetWebHitsFileVPath() );
    _variableSet.AddParam( wcsParamRestriction, envVars.GetRestriction() );

    if (envVars.GetLocale())
        _variableSet.AddParam( wcsLocale, envVars.GetLocale() );
    if (envVars.GetCodepage())
        _variableSet.AddParam( wcsCodepage, envVars.GetCodepage() );

    //
    // Add user definable parameters.
    //
    for ( ULONG i = 0; i < CGetEnvVars::eMaxUserReplParams; i++ )
    {
        if ( envVars.GetUserParam(i+1) )
        {
            _variableSet.AddParam( awcsUserParamNames[i],
                                   envVars.GetUserParam(i+1) );
        }
    }

    //
    // Parse the htx file.
    //
    _wtxFile.ParseFile( _variableSet );
} //CWebhitsTemplate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\bigtable.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       bigtable.cxx
//
//  Contents:
//
//  Classes:    CLargeTable - top-level class for large tables
//              CTableSegIter - iterator of table segments
//
//  Functions:
//
//  History:    01 Feb 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <query.hxx>
#include <srequest.hxx>
#include <cifailte.hxx>
#include <tbrowkey.hxx>

#include "tabledbg.hxx"
#include "tblwindo.hxx"
#include "winsplit.hxx"

#include "buketize.hxx"
#include "tputget.hxx"
#include "regtrans.hxx"

static inline ULONG AbsDiff( ULONG num1, ULONG num2 )
{
    return num1 >= num2 ? num1-num2 : num2-num1;
}

unsigned CTableSink::LokCategorize(
    CCategParams & params )
{
    return _pCategorizer->LokAssignCategory( params );
} //LokCategorize

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::CLargeTable, public
//
//  Synopsis:   Constructor for a large table.  Allocates and fills
//              in the master column description.
//              Allocates initial window to collect data.
//
//  Arguments:  [col]           - A description of initial output column set
//              [sort]          - A description of the initial sort order
//              [cCategorizers] - Total count of categorizers over table
//              [mutex]         - CAsyncQuery's mutex for serialization
//              [fUniqueWorkid] - TRUE if workid (from iterator) is unique
//
//  Notes:
//
//  History:    01-Jan-96   KyleP     Optional unique wid in user-mode.
//
//--------------------------------------------------------------------------

CLargeTable::CLargeTable( XColumnSet & col,
                          XSortSet & sort,
                          unsigned cCategorizers,
                          CMutexSem & mutex,
                          BOOL fUniqueWorkid,
                          CRequestServer * pQuiesce )
        : CTableSink(),
          _sigLargeTable(eSigLargeTable),
          _cbMemoryUsage( 0 ),
          _cbMemoryTarget( DEFAULT_MEM_TARGET ),
          _MasterColumnSet( col.GetPointer() ),
          _fUniqueWorkid( fUniqueWorkid ),
          _segListMgr(cMaxClientEntriesToPin),
          _segList(_segListMgr.GetList()),
          _watchList(_segList),
          _nextSegId(1),
          _pCategorization(0),
          _fAbort(FALSE),
          _pSortSet( 0 ),
          _fProgressNeeded (FALSE),
          _bitNotifyEnabled(0),
          _bitClientNotified(0),
          _bitChangeQuiesced(0),
          _bitRefresh(0),
          _bitIsWatched(0),
          _bitQuiesced(0),
          _pDeferredRows(0),
          _fQuiescent (FALSE),
          _ulProgressNum(0),
          _ulProgressDenom(1),
          _cCategorizersTotal( cCategorizers ),
          _fRankVectorBound( FALSE ),
          _mutex( mutex ),
          _widCurrent( WORKID_TBLBEFOREFIRST ),
          _hNotifyEvent( 0 ),
          _pRequestServer( 0 ),
          _pQExecute(0),
          _pQuiesce( pQuiesce ),
          _fSortDefined( FALSE )
{
    tbDebugOut (( DEB_NOTIFY, "lt: CLargeTable\n" ));

    TRY // use exception generating new
    {
        // Don't bucketize when rank vector is bound

        _fRankVectorBound = ( 0 != _MasterColumnSet.Find( pidRankVector ) );

        //
        //  Be sure the workid column is in the master column set.  The
        //  output column set was added in the constructor above.
        //
        _MasterColumnSet.Add( CColumnMasterDesc(pidWorkId, TYPE_WORKID) );

        //
        // Add the status column, which is used internally and may
        // be bound to at some point.  Status is stored as a byte to save
        // space, and is translated to an HRESULT when passed out to a
        // client.
        //
        CColumnMasterDesc *pRowStatus =
            _MasterColumnSet.Add( CColumnMasterDesc(pidRowStatus, VT_UI1) );
        pRowStatus->SetComputed(TRUE);
        pRowStatus->SetUniform(TRUE);

        //
        // If categorization is turned on, create an I4 category column
        //
        if ( 0 != cCategorizers )
            _MasterColumnSet.Add( CColumnMasterDesc(pidChapter, VT_I4) );

        //
        // Set up file path and name as global, shared compressions with
        // the WorkId as key.  Only needed if it's inconvenient to fetch
        // name and path from workid (e.g. workid isn't unique).
        //

        if ( !_fUniqueWorkid )
        {
            _MasterColumnSet.Add( CColumnMasterDesc(pidPath, TYPE_PATH) );
            _MasterColumnSet.Add( CColumnMasterDesc(pidName, TYPE_NAME) );

            CCompressedCol * pPathCompression = new CPathStore();

            CColumnMasterDesc* pMastCol;

            pMastCol = _MasterColumnSet.Find(pidWorkId);
            Win4Assert(pMastCol != 0);
            pMastCol->SetCompression(pPathCompression);

            pMastCol = _MasterColumnSet.Find(pidPath);
            Win4Assert(pMastCol != 0);
            pMastCol->SetCompression(pPathCompression, pidWorkId);

            pMastCol = _MasterColumnSet.Find(pidName);
            Win4Assert(pMastCol != 0);
            pMastCol->SetCompression(pPathCompression, pidWorkId);
        }

        //
        //  Add the sort keys to the master column set.
        //

        if ( ! sort.IsNull() )
        {
            for ( unsigned iCol = 0; iCol < sort->Count(); iCol++ )
                _MasterColumnSet.Add( CColumnMasterDesc(sort->Get(iCol)) );
            _fSortDefined = TRUE;   // set it to true since sorting is defined
        }

        //
        // Master column set is constructed. Acquire the sortset, but first
        // make sure workid is in the sort set.
        //
        _pSortSet = _CheckAndAddWidToSortSet( sort );

        Win4Assert ( 0 != _pSortSet );

        tbDebugOut(( DEB_ITRACE, "New Big Table with %d columns\n",
                                 _MasterColumnSet.Size() ));
    }
    CATCH(CException, e)
    {
        delete _pSortSet;
        RETHROW();
    }
    END_CATCH;
}


//+---------------------------------------------------------------------------
//
//  Function:   _CheckAndAddWidToSortSet
//
//  Synopsis:   Tests if the sort specification(if any) already had the
//              "pidWorkId" as part of the sort set. If not, it adds one to
//              the end of sort set.
//
//  Arguments:  [sort] -  Input sort set.
//
//  Returns:    The sort set to be used.
//
//  History:    3-22-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSortSet * CLargeTable::_CheckAndAddWidToSortSet( XSortSet & sort )
{
    //
    // Check if the pidWorkId is already a field in the sortset.
    //

    BOOL fPresent = FALSE;

    if ( sort.IsNull() )
    {
        sort.Set( new CSortSet(1) );
    }
    else
    {
        for ( unsigned i = 0; i < sort->Count(); i++ )
        {
            SSortKey & key = sort->Get(i);

            if ( pidWorkId == key.pidColumn )
            {
                fPresent = TRUE;
                break;
            }
        }
    }

    if ( !fPresent )
    {
        SSortKey keyWid( pidWorkId, QUERY_SORTASCEND, 0 );
        sort->Add( keyWid, sort->Count() );
    }

    //
    // Initialize the variant types array for the sort columns
    //
    _vtInfoSortKey.Init( sort->Count() );
    for ( unsigned i = 0; i < sort->Count(); i++ )
    {
        SSortKey & key = sort->Get(i);
        PROPID pid = key.pidColumn;

        CColumnMasterDesc *pMasterCol = _MasterColumnSet.Find(pid);
        Win4Assert( 0 != pMasterCol );
        _vtInfoSortKey[i] = pMasterCol->DataType;
    }

    _keyCompare.Set( new CTableKeyCompare( sort.GetReference() ) );
    _currRow.Set( new CTableRowKey( sort.GetReference() ) );

    _segListMgr.GetSegmentArray().SetComparator( _keyCompare.GetPointer() );

    return sort.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::~CLargeTable, public
//
//  Synopsis:   Destructor for a large table.
//
//  Notes:      The query execution object along with
//              the worker threads has been already
//              destroyed (see CAsyncQuery) so there
//              is no race condition here.
//
//--------------------------------------------------------------------------

CLargeTable::~CLargeTable( )
{
    //
    // Cancel the notification.  Insure that no notifications will be
    // picked up as the thread leaves.  In almost all cases, this will
    // never be called, because the notification thread will already
    // be killed when the last connection point goes away.
    //

    Win4Assert( 0 == _pQExecute );

    CancelAsyncNotification();

    delete _pSortSet;

    // make sure the waiter wakes up

    if ( 0 != _pQuiesce )
    {
        // only called on failure cases -- success cases quiesce ok

        _pQuiesce->QueryQuiesced( _fQuiescent, _scStatus );
        _pQuiesce = 0;
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokFindTableSegment, private
//
//  Synopsis:   Find the appropriate table segment for a request which
//              operates on only a single table segment.
//
//  Arguments:  [wid] - WORKID which identifies the table segment of interest
//              [fMustExist] - TRUE if wid must exist in some segment
//              [pSegHint] - optional, possible segment in which wid will be
//                      found.
//
//  Returns:    CTableSegment* - the selected table segment, 0 if not found.
//
//  Notes:      The method cannot be used for any of the special workIDs used
//              as sentinels (WORKID_TBLBEFOREFIRST, etc).
//              Use _LokLocateTableSegment instead.
//
//--------------------------------------------------------------------------

CTableSegment *
CLargeTable::_LokFindTableSegment(
    WORKID      wid
)
{
    //
    // Iterate over all the segments and locate the segment in
    // which the given workid is present.
    //
    for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter) ;
          _segList.Advance(iter) )
    {
        CTableSegment & segment = *iter.GetSegment();
        if ( segment.IsRowInSegment( wid ) )
            break;
    }

    CTableSegment * pSeg = 0;
    if ( !_segList.AtEnd(iter) )
    {
        pSeg = iter.GetSegment();
    }

    return pSeg;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LokSplitWindow
//
//  Synopsis:   Splits the given window into two and replaces the source
//              window with two windows.
//
//  Arguments:  [ppWindow]    -   Source window that needs to be split.
//                                If successful, will be set to NULL on
//                                return.
//              [iSplitQuery] -   Offset in the rowIndex that is used by
//                                query as the split point.
//
//  Returns:    Pointer to the "left" window after split.
//
//  History:    2-06-95   srikants   Created
//
//  Notes:      Destroys the source window after split.
//
//----------------------------------------------------------------------------

CTableSegment * CLargeTable::_LokSplitWindow( CTableWindow ** ppWindow,
                                           ULONG iSplitQuery )
{
    Win4Assert( 0 != ppWindow );
    CTableWindow * pWindow = *ppWindow;
    Win4Assert( 0 != pWindow );

    CTableWindow * pLeft = 0;
    CTableWindow * pRight = 0;

    {
        CTableWindowSplit   split( *pWindow,
                                   iSplitQuery,
                                   pWindow->GetSegId(), _AllocSegId(),
                                   _segList.IsLast( *pWindow ) );

        //
        // Create empty target windows.
        //
        split.CreateTargetWindows();

        tbDebugOut(( DEB_WINSPLIT, "CLargeTable::Splitting Window\n" ));
        //
        // Do the actual split.
        //
        split.DoSplit();

        //
        // Take ownership of the newly created windows.
        //
        split.TransferTargetWindows( &pLeft, &pRight );
        Win4Assert( 0 != pLeft && 0 != pRight );

    }

    //
    // Replace the pWindow in the list with the two new ones.
    //
    CTableSegList   windowList;
    windowList.Push( pRight );
    windowList.Push( pLeft );

    _segListMgr.Replace( pWindow, windowList );
    Win4Assert( windowList.IsEmpty() );

    //
    // Update the watch regions from the source window to destination
    // window.
    //
    for ( CWatchIter  iter(_watchList) ;
          !_watchList.AtEnd(iter);
          _watchList.Advance(iter) )
    {
        HWATCHREGION hWatch = iter->Handle();
        CWatchRegion * pRegion = iter.Get();

        if ( pRegion->Segment() == pWindow )
        {
            CTableWindow * pNewStartWindow;

            if ( pLeft->HasWatch(hWatch) )
            {
                pNewStartWindow = pLeft;
            }
            else
            {
                Win4Assert( pRight->HasWatch(hWatch) );
                pNewStartWindow = pRight;
            }

            ULONG iWatch = (ULONG) pNewStartWindow->GetWatchStart(hWatch);
            CI_TBL_BMK bmkNew = pNewStartWindow->GetBookMarkAt( iWatch );
            iter->UpdateSegment( pWindow, pNewStartWindow, bmkNew  );
        }

#if CIDBG==1
        _watchList.CheckRegionConsistency( pRegion );
#endif  // CIDBG==1

    }

    //
    // Destroy the source window.
    //
    delete pWindow;
    *ppWindow = 0;

    //
    // Update the mru cache to reflect the split.
    //
    _segListMgr.UpdateSegsInUse( pLeft );
    _segListMgr.UpdateSegsInUse( pRight );

    return pRight;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::PathToWorkID, public
//
//  Synopsis:   Convert a file path name to a work ID.  For down-level
//              stores, the file systems do not return a value which
//              can be reliably used as a WorkID, so we use the file
//              path name as the unique identifier of a file.  This
//              method will use the path column compressor to provide
//              a unique ID over the table given the input path name.
//
//  Arguments:  [obj]      -- a reference to an object retriever which can
//                            return object data
//              [eRowType] -- the type of row being added.
//
//  Returns:    WORKID - a unique value over the table for this row.
//
//  Notes:
//
//--------------------------------------------------------------------------

WORKID CLargeTable::PathToWorkID( CRetriever& obj,
                                  CTableSink::ERowType eRowType )
{
    Win4Assert( !_fUniqueWorkid );

    if ( _fUniqueWorkid )
    {
        PROPVARIANT var;
        ULONG   cb = sizeof(var);

        if ( obj.GetPropertyValue( pidWorkId, &var, &cb ) != GVRSuccess )
            return widInvalid;
        else
        {
            Win4Assert( var.vt == VT_I4 );
            return var.lVal;
        }
    }
    else
    {
        WORKID ulRet = 0;
        GetValueResult eGvr;

        CColumnMasterDesc* pMastCol;

        CLock   lock(_mutex);

        pMastCol = _MasterColumnSet.Find( pidPath );
        Win4Assert(pMastCol != NULL && pMastCol->IsCompressedCol());

        struct
        {
            PROPVARIANT v;
            WCHAR awch[512];         // don't force new every time
        } varnt;
        PROPVARIANT* pVarnt = &(varnt.v);
        ULONG cbBuf = sizeof varnt;

        XArray<BYTE>  xByte;

        eGvr = obj.GetPropertyValue(pMastCol->PropId, pVarnt, &cbBuf);

        if (eGvr == GVRNotEnoughSpace)
        {
            Win4Assert(cbBuf <= TBL_MAX_DATA + sizeof (PROPVARIANT));

            pVarnt = (CTableVariant *) new BYTE[cbBuf];
            xByte.Set( cbBuf, (BYTE *)pVarnt );
            Win4Assert (pVarnt != NULL);
            eGvr = obj.GetPropertyValue(pMastCol->PropId,
                                                  pVarnt, &cbBuf);
        }

        if ( GVRSuccess != eGvr )
        {
            THROW( CException(CRetriever::NtStatusFromGVR(eGvr)) );
        }

        BOOL fFound = FALSE;
        if ( CTableSink::eNewRow != eRowType )
        {
            // try to find an existing path before adding it

            fFound = pMastCol->GetCompressor()->FindData( pVarnt, ulRet );
        }

        if ( ! fFound )
            pMastCol->GetCompressor()->AddData(pVarnt, &ulRet, eGvr);

        Win4Assert(eGvr == GVRSuccess && ulRet != 0);

        return ulRet;
    }
} //PathToWorkID

//+---------------------------------------------------------------------------
//
//  Function:   WorkIdToPath
//
//  Synopsis:   Converts a workid to a path.
//
//  Arguments:  [wid]      -   WID whose path is needed
//              [outVarnt] -   on output will have the path as a variant
//              [cbVarnt]  -   in/out max len on input; actual len on
//                             output. If the return value is FALSE, this will
//                             indicate the lenght of variant needed.  If on
//                             output this is 0 and the return value is FALSE,
//                             wid->path operation failed.
//
//  Returns:    TRUE if we succeeded in getting the path.
//              FALSE if we failed.
//
//  History:    3-24-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CLargeTable::WorkIdToPath( WORKID wid, CInlineVariant & outVarnt,
                                ULONG & cbVarnt )
{
    Win4Assert( !_fUniqueWorkid );

    if ( _fUniqueWorkid )
        return FALSE;

    CLock   lock( _mutex );

    CColumnMasterDesc* pMastCol = _MasterColumnSet.Find( pidPath );
    Win4Assert( pMastCol );
    CCompressedCol & pathCompressor = *(pMastCol->GetCompressor());

    CTableVariant pathVarnt;
    XCompressFreeVariant xpvarnt;

    BOOL fStatus = FALSE;

    if ( GVRSuccess ==
         pathCompressor.GetData( &pathVarnt, VT_LPWSTR, wid, pidPath ) )
    {
        xpvarnt.Set( &pathCompressor, &pathVarnt );

        //
        // Copy the data from the variant to the buffer.
        //
        const ULONG cbHeader  = sizeof(CInlineVariant);
        ULONG cbVarData = pathVarnt.VarDataSize();
        ULONG cbTotal   = cbVarData + cbHeader;

        if ( cbVarnt >= cbTotal )
        {
            CVarBufferAllocator bufAlloc( outVarnt.GetVarBuffer(), cbVarData );
            bufAlloc.SetBase(0);
            pathVarnt.Copy( &outVarnt, bufAlloc, (USHORT) cbVarData, 0 );
            fStatus = TRUE;
        }

        cbVarnt = cbTotal;
    }
    else
    {
        cbVarnt = 0;
    }

    return fStatus;
} //WorkIdToPath

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokRemoveCategorizedRow, private
//
//  Synopsis:   Removes a row from the categorization.
//
//  Arguments:  [chapt]    -- chapter from which removal is done
//              [wid]      -- wid to remove
//              [widNext]  -- the next wid in the table, can be widInvalid
//              [pSegment] -- segment from which widNext can be computed if
//                            not specified.
//
//  History:    ?             dlee  Created
//
//--------------------------------------------------------------------------

void CLargeTable::_LokRemoveCategorizedRow(
    CI_TBL_CHAPT    chapt,
    WORKID          wid,
    WORKID          widNext,
    CTableSegment * pSegment )
{
    if ( IsCategorized() )
    {
        if ( widInvalid == widNext )
        {
            // sigh.  We need to find the workid of the row after the
            // row just deleted in the case that the deleted row was the
            // first row in a category and not the only row in the category,
            // since the categorizers need to keep track of the first wid
            // in a category.  widNext is widInvalid if the deleted row
            // was the last row in the window.

            for ( CFwdTableSegIter iter( _segList );
                  !_segList.AtEnd( iter );
                  _segList.Advance( iter ) )
            {
                CTableSegment * pNextSeg = iter.GetSegment();
                if ( pNextSeg == pSegment )
                {
                    _segList.Advance( iter );

                    if ( !_segList.AtEnd( iter ) )
                    {
                        CTableWindow * pWindow = iter.GetWindow();

                        widNext = pWindow->GetFirstBookMark();
                    }

                    break;
                }

                _segList.Advance(iter);
            }
        }

        pSegment->GetCategorizer()->RemoveRow( chapt, wid, widNext );
    }
} //_LokRemoveCategorizedRow


//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::PutRow, public
//
//  Synopsis:   Add a row to a large table
//
//  Arguments:  [obj]      -- a reference to an object retriever which can
//                            return object data
//              [eRowType] -- the type of row being added.
//
//  Returns:    TRUE if progress report needed
//
//--------------------------------------------------------------------------

BOOL CLargeTable::PutRow( CRetriever& obj, CTableSink::ERowType eRowType )
{
    CReleasableLock relLock( _mutex, FALSE );

    if ( FALSE == relLock.Try() )
    {
        // Unable to get bigtable lock. Maybe GetRows is holding bigtable
        // lock and is waiting on propstore lock which this thread might
        // be holding. So rlease that and try again.
        obj.Quiesce();
        relLock.Request();  // If we deadlock now, then we need to fix that !
    }

    //
    // The query may be in the process of being deleted if it has been
    // cancelled during query execution.  In this case, the _pQExecute will
    // have been set to 0 by the call to ReleaseQueryExecute() in
    // ~CAsyncQuery.
    //

    if ( 0 == _pQExecute )
        return FALSE;

    TRY
    {
        WORKID widRow = obj.WorkId();

        //
        // Check if it already exists in one of the segments based
        // on its workid.
        //
        CTableSegment *pSegment = 0;

        if ( CTableSink::eNotificationRow == eRowType )
        {
            //
            // If the table is not watched, do not process notifications.
            //
            if ( !_LokIsWatched() )
            {
                return _fProgressNeeded;
            }
            else if ( _LokIsPutRowDeferred( widRow, obj ) )
            {
                _bitRefresh = 1;
                LokCompleteAsyncNotification();
                return _fProgressNeeded;
            }
        }
        else if ( CTableSink::eNewRow != eRowType )
        {
            //
            // NOSUPPORT: This will not work with LINKS. We have to look at
            // table irrespective of whether this is a notification or not.
            // Of course, we don't support links.
            //
            //
            pSegment = _LokFindTableSegment( obj.WorkId() );
        }

        if ( 0 != pSegment )
        {
            //
            // Modifications are to be treated as deletions followed by
            // additions.
            //

            //
            // First delete the current row and then add the new row.
            // If the "key" of this row is different from the one already
            // in the table, the new row may end up in a different bucket
            // than the original.
            //
            PROPVARIANT varWid;
            varWid.lVal = (LONG) obj.WorkId();
            varWid.vt = VT_I4;
            tbDebugOut(( DEB_BOOKMARK, "CLargeTable - Delete And ReAdd WorkId 0x%X\n",
                         varWid.lVal ));
            WORKID widNext;
            CI_TBL_CHAPT chapt;

            //
            // Delete the row and then add a new one.
            //
            pSegment->RemoveRow( varWid, widNext, chapt );
            _LokRemoveCategorizedRow( chapt,
                                      obj.WorkId(),
                                      widNext,
                                      pSegment );

        }
        else
        {
            pSegment = _segListMgr.GetCachedPutRowSeg();
        }

        CTableRowPutter rowPutter( *this, obj );

        pSegment = rowPutter.LokFindSegToInsert( pSegment );
        Win4Assert( 0 != pSegment );

        //
        // If the current segment is getting full, we should either split it
        // or create a new one.
        //
        if ( pSegment->IsGettingFull() )
            pSegment = rowPutter.LokSplitOrAddSegment( pSegment );

        Win4Assert( 0 != pSegment );
        Win4Assert( pSegment->GetLowestKey().IsInitialized() );
        Win4Assert( pSegment->GetHighestKey().IsInitialized() );

        BOOL fRowThrownAway = FALSE;

        // Check for Row limit...

        ULONG cRowLimit = FirstRows();
        tbDebugOut(( DEB_ITRACE, "CLargeTable::PutRow: FirstRows is %d, MaxRows is %d\n", FirstRows(), MaxRows() ));

        BOOL fFirstRows = cRowLimit > 0;

        if (  !fFirstRows )
            cRowLimit = MaxRows();
        
        tbDebugOut(( DEB_ITRACE, "CLargeTable::PutRow: RowCount() is %d\n", RowCount() ));
        tbDebugOut(( DEB_ITRACE, "CLargeTable::PutRow: cRowLimit is %d\n", cRowLimit ));

        if ( 0 == cRowLimit || RowCount() < cRowLimit ) 
        {
            pSegment->PutRow( obj, _currRow.GetReference() );
        }
        else
        {
            // We are here. Therefore it means that:
            // There is a maxrow limit set AND rowcount >= maxrows AND
            // we have at least one segment which has at least one row...

            // Note: The special case of sort by rank descending is handled
            // by CQAsyncExecute::Resolve in which case we only get rows less
            // than equal to MaxRows (in case MaxRows is defined)

            if ( !fFirstRows )
            { 
                if ( !_fSortDefined )
                {
                    // Since not sort order is defined, we can stop processing of 
                    // rows here, since we have all the data that we need
                    _fNoMoreData = fRowThrownAway = TRUE;
                }
                else
                {
                    _currRow->MakeReady();

                    // There is a sort defined. So we need to process all the
                    // rows and put the best results in the maxrow rows

                    CTableSegment* pLastSegment = _segListMgr.GetList().GetLast();
                    Win4Assert( pLastSegment );

                    // Now we need to make sure that the last segment is a window
                    // and it has at least one row in it. This is done because
                    // a bucket does not support the kind of operations that
                    // we are planning to do here on...

                    while ( !pLastSegment->IsWindow() || 0 == pLastSegment->RowCount() )
                    {
                        if ( 0 == pLastSegment->RowCount() )
                        {
                            // delete this segment
                            _segListMgr.RemoveFromList( pLastSegment );
                            delete pLastSegment;
                            pLastSegment = _segListMgr.GetList().GetLast();
                            Win4Assert( pLastSegment );
                            continue;
                        }

                        if ( !pLastSegment->IsWindow() )
                        {
                            // Convert it to a window

                            Win4Assert( pLastSegment->IsBucket() );

                            obj.Quiesce();

                            XPtr<CTableBucket> xBktToExpand( (CTableBucket*)pLastSegment );

                            CDoubleTableSegIter iter( pLastSegment );
                            _LokReplaceWithEmptyWindow( iter );

                            _NoLokBucketToWindows( xBktToExpand, 0, FALSE, FALSE );

                            pLastSegment = _segListMgr.GetList().GetLast();
                            Win4Assert( pLastSegment );

                            // pSegment may no longer exist -- look it up again

                            CTableRowPutter rp( *this, obj );
                            pSegment = rp.LokFindSegToInsert( 0 );
                            Win4Assert( 0 != pSegment );
                        }
                    }

                    if ( ( pLastSegment == pSegment ) &&
                         ( _keyCompare->Compare( _currRow.GetReference(),
                                                 pSegment->GetHighestKey() ) > 0 ) )
                    {
                        // Since the current row is worse than the our worst row,
                        // we can throw it away
                         fRowThrownAway = TRUE;

                        // NEWFEATURE: update counter of thrown rows
                    }   
                    else
                    {
                        // CurrRow is better than (at least) our worst row
                        // Delete the last row in the last segment and insert
                        // the new row. This would keep RowCount == MaxRows

                        PROPVARIANT varWid;
                        varWid.lVal = (LONG) ((CTableWindow*)pLastSegment)->
                            _GetLastWorkId();
                        Win4Assert( widInvalid != varWid.lVal );
                        varWid.vt = VT_I4;

                        WORKID widNext;
                        CI_TBL_CHAPT chapt;

                        pLastSegment->RemoveRow( varWid, widNext, chapt );
                        _LokRemoveCategorizedRow( chapt,
                                                  varWid.lVal,
                                                  widNext,
                                                  pLastSegment );

                        // Insert the new row
                        pSegment->PutRow( obj, _currRow.GetReference() );

                        if ( 0 == pLastSegment->RowCount() )
                        {
                            // remove this segment
                            _segListMgr.RemoveFromList( pLastSegment );
                            delete pLastSegment;
                        }
                    }
                }
            }           
        }     
        
        if ( !fRowThrownAway )
        {
            _segListMgr.SetCachedPutRowSeg( pSegment );
                
            if ( rowPutter.LokIsNewWindowCreated() &&
                 ( ! _fRankVectorBound ) &&
                 ( ! IsCategorized() ) &&
                 ( _fUniqueWorkid ) ) // don't bucketize ::_noindex_:: catalogs
            {
                _LokConvertWindowsToBucket();
            }    

            _bitRefresh = 1;
            LokCompleteAsyncNotification();
        }
    }
    CATCH( CException, e )
    {
        if ( e.GetErrorCode() != STATUS_FILE_DELETED )
        {
            RETHROW();
        }
    }
    END_CATCH

    return _fProgressNeeded;
} //PutRow

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokDeferPutRow
//
//  Synopsis:
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
void CLargeTable::_LokDeferPutRow(
    WORKID       wid,
    CRetriever & obj )
{
    Win4Assert( 0 != _pSortSet );

    if ( 0 == _pDeferredRows )
    {
        _pDeferredRows = new CTableBucket( *_pSortSet,
                                           _keyCompare.GetReference(),
                                           _MasterColumnSet,
                                           _AllocSegId() );

    }

    PROPVARIANT vRank;
    ULONG cbRank = sizeof vRank;
    obj.GetPropertyValue( pidRank, &vRank, &cbRank );

    Win4Assert( VT_I4 == vRank.vt );

    PROPVARIANT vHitCount;
    ULONG cbHitCount = sizeof vHitCount;
    obj.GetPropertyValue( pidHitCount, &vHitCount, &cbHitCount );

    Win4Assert( VT_I4 == vHitCount.vt );

    _pDeferredRows->_AddWorkId( wid,
                                vRank.lVal,
                                vHitCount.lVal );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokIsPutRowDeferred
//
//  Synopsis:   If the workid given is being watched and the client knows
//              about its existence, then we must defer the addition of
//              this row until later.
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLargeTable::_LokIsPutRowDeferred( WORKID widRow, CRetriever &obj )
{
    Win4Assert( _LokIsWatched() );

    PROPVARIANT varWid;
    varWid.lVal = (LONG) widRow;
    varWid.vt = VT_I4;

    WORKID widNext;

    BOOL fDeferred = FALSE;

    for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter);
          _segList.Advance(iter) )
    {
        CTableSegment * pSegment = iter.GetSegment();

        WORKID widNext;
        CI_TBL_CHAPT chapt;

        //
        // NEWFEATURE: (windowed notifications)
        // This is not correct. We should remove it only if soft
        // deletions are being done on a window. If it is a hard delete,
        // we  must wait until a refresh is called. May need a different
        // data structure for the case of watch all - a bucket will not
        // suffice.
        //
        if ( pSegment->RemoveRow(varWid, widNext, chapt) )
        {
            _LokRemoveCategorizedRow( chapt,
                                      widRow,
                                      widNext,
                                      pSegment );

            if ( pSegment->IsWindow() )
            {
                CTableWindow * pWindow = iter.GetWindow();
                if ( pWindow->IsPendingDelete( widRow ) )
                {
                    _LokDeferPutRow( widRow, obj );
                    fDeferred = TRUE;
                }
            }

            break;
        }
    }

    return fDeferred;

}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokRemoveIfDeferred
//
//  Synopsis:
//
//  Arguments:  [wid] -
//
//  Returns:
//
//  History:    8-01-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CLargeTable::_LokRemoveIfDeferred( WORKID wid )
{
    BOOL fRemoved = FALSE;

    if ( 0 != _pDeferredRows )
    {

        PROPVARIANT varWid;
        varWid.lVal = (LONG) wid;
        varWid.vt = VT_I4;

        WORKID widNext;
        CI_TBL_CHAPT chapt;

        fRemoved = _pDeferredRows->RemoveRow( varWid, widNext, chapt );
    }

    return fRemoved;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokCheckQueryStatus, private
//
//  Synopsis:   Fail a request if the query has encountered an error.
//
//  Arguments:  - NONE -
//
//  Returns:    Nothing, throws E_FAIL on error.
//
//--------------------------------------------------------------------------

void       CLargeTable::_LokCheckQueryStatus( )
{
    if (QUERY_FILL_STATUS( Status() ) == STAT_ERROR)
    {
        NTSTATUS sc = GetStatusError();
        Win4Assert( sc != STATUS_SUCCESS );
        tbDebugOut(( DEB_WARN,
                     "Bigtable 0x%x Query failed, sc = %x\n",
                     this, sc));
        if (sc == STATUS_SUCCESS)
            sc = E_FAIL;

        THROW( CException( sc ));
    }
    else if ( _fAbort )
    {
        THROW( CException( STATUS_TOO_LATE ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetRows, public
//
//  Synopsis:   Retrieve row data from a large table.
//
//  Arguments:  [widStart] - WORKID identifying first row to be
//                      transferred.  If WORKID_TBLFIRST is
//                      used, the transfer will start at the first
//                      row in the segment.
//              [chapt]    - Chapter from which to fetch rows (if chaptered)
//              [rOutColumns] - a CTableColumnSet that describes the
//                      output format of the data table.
//              [rGetParams] - an CGetRowsParams structure which
//                      describes how many rows are to be fetched and
//                      other parameters of the operation.
//              [rwidLastRowTransferred] - on return, the work ID of
//                      the last row to be transferred from this table.
//                      Can be used to initialize widStart on next call.
//
//  Returns:    SCODE - status of the operation.  DB_S_ENDOFROWSET if
//                      widStart is WORKID_TBLAFTERLAST at start of
//                      transfer, or if rwidLastRowTransferred is the
//                      last row in the segment at the end of the transfer.
//
//                      DB_S_BUFFERTOOSMALL is returned if the available
//                      space in the out-of-line data was exhausted during
//                      the transfer.
//
//  Notes:      To transfer successive rows, as in GetNextRows, the
//              rwidLastRowTransferred must be advanced by one prior
//              to the next transfer.
//
//--------------------------------------------------------------------------

SCODE       CLargeTable::GetRows(
    HWATCHREGION            hRegion,
    WORKID                  widStart,
    CI_TBL_CHAPT            chapt,
    CTableColumnSet const & rOutColumns,
    CGetRowsParams &        rGetParams,
    WORKID &                rwidLastRowTransferred
)
{
    return GetRowsAt( hRegion, widStart, chapt, 0, rOutColumns,
                      rGetParams, rwidLastRowTransferred );

}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::RestartPosition, public
//
//  Synopsis:   Set next fetch position for the chapter to the start
//
//  Arguments:  [chapt]    - Chapter from which to fetch rows (if chaptered)
//
//  Returns:    SCODE - status of the operation.
//
//--------------------------------------------------------------------------

void       CLargeTable::RestartPosition(
    CI_TBL_CHAPT           chapt)
{
    SetCurrentPosition( chapt, WORKID_TBLBEFOREFIRST );
    CTableSource::RestartPosition( chapt );
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::RowCount, public
//
//  Synopsis:   Return the total row count in the table
//
//  Returns:    ULONG - row count aggregated over all segments in the
//                      table.
//
//--------------------------------------------------------------------------

DBCOUNTITEM CLargeTable::RowCount()
{
    CLock   lock(_mutex);
    _LokCheckQueryStatus();

    return _LokRowCount();
}


//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokRowCount, public
//
//  Synopsis:   Return the total row count in the table
//
//  Returns:    ULONG - row count aggregated over all segments in the
//                      table.
//
//--------------------------------------------------------------------------

DBCOUNTITEM   CLargeTable::_LokRowCount()
{

    DBCOUNTITEM cRowsTotal = 0;

    for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter); _segList.Advance(iter) )
    {
        cRowsTotal += iter.GetSegment()->RowCount();
    }

    return cRowsTotal;
}


//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::RatioFinished
//
//  Synopsis:   Return query progress
//
//  Arguments:  [ulDeneominator] - on return, denominator of fraction
//              [ulNumerator] - on return, numerator of fraction
//              [cRows] - on return, number of rows in table
//
//  Notes:      For the fQuick case, we could try doing a quick
//              synchronization with the CAsyncExecute to compute
//              a good value for the ratio, but the implementation
//              below is fine for the Gibraltar query since no callers
//              will use the ratio anyway.
//
//              A sketch of the code needed to do the quick synchronization
//              is below:
//                  BOOL CAsyncExecute::QuickRF( ULONG &ulDen, ULONG &ulNum )
//                  {
//                      CLock lock(_mutex);
//                      if (_fRunning)
//                          return FALSE;
//                      else
//                      {
//                          _pCurResolve->RatioFinished( ulDen, ulNum );
//                          return TRUE;
//                      }
//                  }
//
//
//  History:    Mar-20-1995 BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::RatioFinished (
    DBCOUNTITEM& ulDenominator,
    DBCOUNTITEM& ulNumerator,
    DBCOUNTITEM& cRows )
{
    CLock lock(_mutex);
    _LokCheckQueryStatus();

    if (_fQuiescent)
    {
        cRows = _LokRowCount();
        ulDenominator = ulNumerator = 100;
        return;
    }
    _fProgressNeeded = TRUE;

    ulDenominator = _ulProgressDenom;
    ulNumerator =   _ulProgressNum;
    cRows = _LokRowCount();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::ProgressDone, public
//
//  Synopsis:   Sets the progress indicators and wakes up
//              the client
//
//  Arguments:  [ulDenominator]
//              [ulNumerator]
//
//  History:    Mar-21-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void  CLargeTable::ProgressDone (ULONG ulDenominator, ULONG ulNumerator)
{
    tbDebugOut(( DEB_ITRACE, "CLargeTable reporting progress %ld / %ld\n",
                ulNumerator, ulDenominator ));
    CLock lock(_mutex);
    _fProgressNeeded = FALSE;
    _ulProgressDenom = ulDenominator;
    _ulProgressNum   = ulNumerator;
}

void CLargeTable::Quiesce ()
{
    TRY
    {
        CLock lock(_mutex);
    
        tbDebugOut(( DEB_NOTIFY, "CLargeTable reached quiescent state\n" ));
    
        Win4Assert( QUERY_FILL_STATUS( Status() ) == STAT_DONE ||
                    QUERY_FILL_STATUS( Status() ) == STAT_ERROR );
        _fProgressNeeded = FALSE;
        _fQuiescent = TRUE;
        _ulProgressDenom = 100;
        _ulProgressNum   = 100;
    
        // don't tell the client we quiesced more than once
    
        tbDebugOut(( DEB_ITRACE, "CLargeTable::Quiesce: _bitQuiesced is %d\n", _bitQuiesced ));
        if ( 0 == _bitQuiesced )
        {
            _bitChangeQuiesced = 1;
            _bitQuiesced = 1;
            LokCompleteAsyncNotification();
        }
    
        // inform the client once that we're complete
    
        if ( 0 != _pQuiesce )
        {
            _pQuiesce->QueryQuiesced( TRUE, _scStatus );
            _pQuiesce = 0;
        }
    }
    CATCH( CException, e )
    {
        // ignore the exception; it may be in a unwind path
    }
    END_CATCH;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetApproximatePosition, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [chapt] -        chapter
//              [bmk] -          bookmark
//              [pulNumerator] - on return, numerator of fraction
//              [pulRowCount] -  on return, denominator of fraction (row count)
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:      The denominator of the fraction is the approximate
//              row count in the table or chapter.
//
//--------------------------------------------------------------------------

SCODE
CLargeTable::GetApproximatePosition(
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmk,
    DBCOUNTITEM *       pulNumerator,
    DBCOUNTITEM *       pulRowCount
)
{
    CLock   lock(_mutex);
    _LokCheckQueryStatus();

    if (bmk == widInvalid)
        return DB_E_BADBOOKMARK;

    Win4Assert (bmk != WORKID_TBLBEFOREFIRST && bmk != WORKID_TBLAFTERLAST);

    DBCOUNTITEM iBmkPosition = ULONG_MAX;

    DBCOUNTITEM cRows = 0;

    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
    {
        cRows = GetCategorizer()->GetRowCount( chapt );

        if ( WORKID_TBLFIRST == bmk )
        {
            iBmkPosition = 1;
            if (cRows == 0)
                iBmkPosition = 0;
        }
        else if ( WORKID_TBLLAST == bmk )
        {
            iBmkPosition = cRows;
        }
        else
        {
            WORKID widFirst = GetCategorizer()->GetFirstWorkid( chapt );

            CFwdTableSegIter iter( _segList );
            DBCOUNTITEM cChaptRows = 0;
            BOOL fFoundFirstYet = FALSE;

            while ( !_segList.AtEnd(iter) )
            {
                ULONG iRow = 0;

                CTableSegment * pSegment = iter.GetSegment();
                if ( pSegment->IsWindow() )
                {
                    CTableWindow * pWindow = iter.GetWindow();

                    ULONG iFirstRow;
                    if ( !fFoundFirstYet &&
                         pWindow->RowOffset( widFirst, iFirstRow ) )
                    {
                        if ( pWindow->RowOffset(bmk, iRow) )
                        {
                            iBmkPosition = iRow - iFirstRow + 1;
                            break;
                        }
                        else
                        {
                            cChaptRows = pSegment->RowCount() - iFirstRow;
                            fFoundFirstYet = TRUE;
                        }
                    }
                    else if ( pWindow->RowOffset(bmk, iRow) )
                    {
                        //  We can't have set the numerator previously.
                        Win4Assert(iBmkPosition == ULONG_MAX);
                        iBmkPosition = cChaptRows + iRow + 1;
                        break;
                    }
                    else if ( fFoundFirstYet )
                    {
                        cChaptRows += pSegment->RowCount();
                    }
                }
                else
                {
                    //  The chapter is in a bucket.  All rows in the
                    //  bucket are in the chapter, and the chapter
                    //  spans no other segments.

                    CTableBucket * pBucket = iter.GetBucket();
                    if ( pBucket->IsRowInSegment(bmk) )
                    {
                        Win4Assert( iBmkPosition == ULONG_MAX );

                        if ( pBucket->RowOffset(bmk, iRow) )
                        {
                            iBmkPosition = iRow + 1;
                        }
                        else
                        {
                            iBmkPosition = ((ULONG)pBucket->RowCount() + 1)/2;
                        }
                    }
                }

                _segList.Advance(iter);
            }
        }
    }
    else
    {
        if (bmk == WORKID_TBLFIRST)
        {
            iBmkPosition = 1;
            cRows = RowCount();
            if (cRows == 0)
                iBmkPosition = 0;
        }
        else if (bmk == WORKID_TBLLAST)
        {
            cRows = RowCount();
            iBmkPosition = cRows;
        }
        else
        {
            //
            // Iterate over all table segments prior to the table seg.
            // in which the bookmark occurs, adding their row counts to
            // iBmkPosition.  Accumulate the total row count at the same
            // time.
            //

            CFwdTableSegIter iter( _segList );
            while ( !_segList.AtEnd(iter) )
            {
                ULONG iRow = 0;

                CTableSegment * pSegment = iter.GetSegment();
                if ( pSegment->IsWindow() )
                {
                    CTableWindow * pWindow = iter.GetWindow();
                    if ( pWindow->RowOffset(bmk, iRow) )
                    {
                        //  We can't have set the numerator previously.
                        Win4Assert(iBmkPosition == ULONG_MAX);
                        iBmkPosition = cRows + iRow + 1;
                    }
                }
                else
                {
                    CTableBucket * pBucket = iter.GetBucket();
                    if ( pBucket->IsRowInSegment(bmk) )
                    {
                        Win4Assert( iBmkPosition == ULONG_MAX );

                        iBmkPosition = cRows;
                        if ( pBucket->RowOffset(bmk, iRow) )
                        {
                            iBmkPosition += iRow + 1;
                        }
                        else
                        {
                            iBmkPosition += ((ULONG)pBucket->RowCount() + 1)/2;
                        }
                    }
                }

                cRows += pSegment->RowCount();
                _segList.Advance(iter);
            }
        }
    }

    if (iBmkPosition == ULONG_MAX)
        return DB_E_BADBOOKMARK;

    Win4Assert(iBmkPosition <= cRows);

    *pulNumerator = iBmkPosition;
    *pulRowCount = cRows;

    return S_OK;
} //GetApproximagePosition

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::IsColumnInTable, public
//
//  Synopsis:   Check whether some column can be added to the table.
//              Used in support of CQuery::SetBindings; added columns
//              may only refeerence columns which already exist in the
//              table.
//
//  Arguments:  [PropId] - the property ID to be added to the table.
//
//  Returns:    BOOL - TRUE if it's okay to add the column.  False
//                      otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL
CLargeTable::IsColumnInTable(
    PROPID PropId
) {

    CLock   lock(_mutex);

    //
    //  See if the column already exists in the master column set
    //
    if ( _MasterColumnSet.Find( PropId ) != 0 ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#if 0
//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::_LokLocateTableSegment, private
//
//  Synopsis:   Position a table segment iterator to the table segment
//              in which some work ID is found.
//
//  Arguments:  [rIter] - An iterator over table segments
//              [chapt] - Chapter in which to search for row
//              [wid]   - value to be searched for
//
//  Returns:    BOOL - TRUE if the work ID was found, FALSE if not.
//
//  Notes:
//
//--------------------------------------------------------------------------

WORKID
CLargeTable::_LokLocateTableSegment(
    CDoubleTableSegIter& rIter,
    CI_TBL_CHAPT         chapt,
    WORKID               wid
)
{
    Win4Assert( !_segList.AtEnd(rIter) );

    if ( IsSpecialWid( wid ) )
    {
        if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        {
            if ( WORKID_TBLFIRST       == wid  ||
                 WORKID_TBLBEFOREFIRST == wid )
            {
                wid = GetCategorizer()->GetFirstWorkid( chapt );
            }
            else
            {
                // Heuristic: assume last row of [chapt] is in same window
                // as first row of [ next chapt ]

                wid = GetCategorizer()->GetFirstWorkidOfNextCategory( chapt );

                if ( widInvalid == wid )
                {
                    // chapt was the last chapter -- get the last segment

                    while ( !_segList.IsLast(rIter) )
                        _segList.Advance(rIter);
                    return TRUE;
                }
                else
                {
                    // check if this row (the first of the next chapter) is
                    // the first in the segment.  If so, back up to the prev
                    // segment.

                    Win4Assert( _segList.IsFirst(rIter) );
                    while ( !_segList.AtEnd(rIter) )
                    {
                        if ( rIter.GetSegment()->IsRowInSegment(wid) )
                        {
                            ULONG iRow;
                            CTableWindow * pWindow = rIter.GetWindow();
                            pWindow->RowOffset( wid, iRow );
                            if ( 0 == iRow )
                            {
                                // uh, oh.  Back up a segment.  The first row of
                                // the next category is the first row in the seg,
                                // so the last row of the categ must be in the
                                // prev segment.
                                Win4Assert( !_segList.IsFirst(rIter) );
                               _segList.BackUp(rIter);
                            }

                            return TRUE;
                        }
                       _segList.Advance(rIter);
                    }

                    tbDebugOut((DEB_WARN, "Got confused looking for %x\n", wid));
                    return FALSE;
                }
            }
        }
        else
        {
            //
            //  For the special cases of Beginning and End, just position to the
            //  correct end.
            //
            if (wid == WORKID_TBLBEFOREFIRST || wid == WORKID_TBLFIRST)
            {
                while ( !_segList.IsFirst(rIter) )
                    _segList.BackUp(rIter);
            }
            else
            {
                Win4Assert( wid == WORKID_TBLLAST ||
                            wid == WORKID_TBLAFTERLAST );

                while ( !_segList.IsLast(rIter) )
                    _segList.Advance(rIter);
            }

            return TRUE;
        }
    }

    //
    //  Locate the appropriate segment
    //  NOTE: we assume we start with a fresh iterator, so just go forward
    //

    Win4Assert( _segList.IsFirst(rIter) );
    while ( !_segList.AtEnd(rIter) )
    {
        if ( rIter.GetSegment()->IsRowInSegment(wid) )
        {
            return TRUE;
        }
        _segList.Advance(rIter);
    }
    tbDebugOut((DEB_WARN, "Work ID %x not found in table\n", wid));
    return FALSE;
}

#endif


//
//  Methods which call through to the constituent table segments.
//  These will in general just select one segment to call, or
//  iterate over all segments.
//

//+---------------------------------------------------------------------------
//
//  Function:   IsRowInSegment
//
//  Synopsis:   
//
//  Arguments:  [wid] - Workid of row to be found
//
//  Returns:    BOOL - TRUE if row is found, FALSE otherwise
//
//  History:    3-24-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CLargeTable::IsRowInSegment( WORKID wid )
{
    CLock   lock(_mutex);

    return (_LokFindTableSegment(wid) != 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   SortOrder
//
//  Synopsis:
//
//  Returns:
//
//  History:    3-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSortSet const & CLargeTable::SortOrder()
{
    //CLock   lock(_mutex);
    return( *_pSortSet );
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveRow
//
//  Synopsis:
//
//  Arguments:  [varUnique] -
//
//  Returns:
//
//  History:    3-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLargeTable::RemoveRow( PROPVARIANT const & varUnique )
{

    CLock   lock(_mutex);

    if ( !_LokIsWatched() )
    {
        //
        // Do not process deletions unless the table is watched.
        //
        return;
    }


    WORKID widRow = widInvalid;

    if ( _fUniqueWorkid )
        widRow = varUnique.lVal;
    else
    {
        CColumnMasterDesc* pMastCol = _MasterColumnSet.Find( pidPath );
        Win4Assert(0 != pMastCol && pMastCol->IsCompressedCol());

        //
        // Convert the filename to a wid before deletion.
        //

        BOOL fFound = pMastCol->GetCompressor()->FindData( &varUnique,
                                                           widRow );

        // See if the delete wasn't in the table to begin with

        if ( !fFound )
            return;
    }

    if ( !_LokRemoveIfDeferred( widRow ) )
    {
        //
        // This row was not a deferred update. We must iterate through
        // the segments and remove it.
        //

        PROPVARIANT varWid;
        varWid.lVal = (LONG) widRow;
        varWid.vt = VT_I4;

        for ( CFwdTableSegIter iter(_segList); !_segList.AtEnd(iter);
              _segList.Advance(iter) )
        {
            CTableSegment * pSegment = iter.GetSegment();
            WORKID widNext;
            CI_TBL_CHAPT chapt;

             // No Hard Delete.
            if ( pSegment->RemoveRow( varWid, widNext, chapt ) )
            {
                _LokRemoveCategorizedRow( chapt,
                                          widRow,
                                          widNext,
                                          pSegment );
                break;
            }
        }
    }

    _bitRefresh = 1;
    LokCompleteAsyncNotification();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::NeedToNotifyReset, private
//
//  Synopsis:   Checks if there is a need to notify the client
//              Resets the changeQuiesced bit if needed
//
//  Arguments:  [changeType] -- out, what change type
//
//  History:    Arp-4-95   BartoszM    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::NeedToNotifyReset (DBWATCHNOTIFY& changeType)
{
    CLock lock (_mutex);
    return LokNeedToNotifyReset(changeType);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::LokNeedToNotifyReset, private
//
//  Synopsis:   Checks if there is a need to notify the client
//              Resets the changeQuiesced bit if needed
//
//  Arguments:  [changeType] -- out, what change type
//
//  History:    Arp-4-95   BartoszM    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::LokNeedToNotifyReset(DBWATCHNOTIFY& changeType)
{
    if (_bitRefresh )
    {
        if (!_bitClientNotified)
        {
            changeType = DBWATCHNOTIFY_ROWSCHANGED;
            return TRUE;
        }
    }
    else // no need to run changes
    {
        if (_bitChangeQuiesced)
        {
            changeType = (_bitQuiesced)? DBWATCHNOTIFY_QUERYDONE: DBWATCHNOTIFY_QUERYREEXECUTED;
            tbDebugOut(( DEB_NOTIFY, "changetype set to %d\n", changeType ));
            //
            // Reset the bit!
            //
            _bitChangeQuiesced = 0;
            return TRUE;
        }
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::NeedToNotify, private
//
//  Synopsis:   Checks if there is a need to notify the client
//
//  History:    29-Aug-95   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::NeedToNotify()
{
    CLock lock (_mutex);
    return LokNeedToNotify();
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::LokNeedToNotify, private
//
//  Synopsis:   Checks if there is a need to notify the client
//
//  History:    29-Aug-95   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CLargeTable::LokNeedToNotify()
{
    if (_bitRefresh )
    {
        if (!_bitClientNotified)
            return TRUE;
    }
    else if (_bitChangeQuiesced)
    {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetNotifications, private
//
//  Synopsis:   Retrieves the notification info from the query object
//              row data.
//
//  Arguments:  [rSync]    -- notification synchronization info
//              [rParams]  -- notification data info
//
//  Returns:    SCODE
//
//  History:    10-24-94     dlee      created
//
//----------------------------------------------------------------------------

SCODE CLargeTable::GetNotifications(
    CNotificationSync & rSync,
    DBWATCHNOTIFY     & changeType )
{
    tbDebugOut (( DEB_NOTIFY, "lt: GetNotifications\n" ));

    {
        CLock lock(_mutex);
        _bitNotifyEnabled = 1;

        // don't fail if the query failed -- report the notification that
        // the query completed.

        // _LokCheckQueryStatus();
    }

    SCODE sc = S_OK;

    {
        CLock lock(_mutex);

        Win4Assert( 0 == _pRequestServer );
        Win4Assert( 0 == _hNotifyEvent );

        if ( LokNeedToNotifyReset( changeType ) )
        {
            _bitClientNotified = 1;
            tbDebugOut (( DEB_NOTIFY, "complete in getnotify: %d\n",
                          changeType ));
            return S_OK;
        }
        else
        {
            if ( rSync.IsSvcMode() )
            {
                Win4Assert( 0 == _pRequestServer );
                _pRequestServer = rSync.GetRequestServer();
                Win4Assert( 0 != _pRequestServer );
                tbDebugOut (( DEB_NOTIFY, "getnotify returning pending\n" ));
                return STATUS_PENDING;
            }

            // Block on an event until notifications
            // arrive (or the table is going away).  If notifications
            // exist, grab them.  Also block on the notification cancel
            // event and report if that was received.

            Win4Assert( 0 == _hNotifyEvent );

            _hNotifyEvent = CreateEvent( 0, TRUE, FALSE, 0 );

            if ( 0 == _hNotifyEvent )
            {
                tbDebugOut(( DEB_ERROR, "Create event returned 0d\n",
                             GetLastError() ));
                THROW( CException() );
            }
        }
    }

    HANDLE aEvents[2];
    aEvents[0] = _hNotifyEvent;
    aEvents[1] = rSync.GetCancelEvent();

    ULONG wait = WaitForMultipleObjects( 2,
                                         aEvents,
                                         FALSE,
                                         INFINITE );

    CloseHandle( _hNotifyEvent );
    _hNotifyEvent = 0;

    if ( STATUS_WAIT_0 == wait )
    {
        CLock lock(_mutex);
        changeType = _changeType;
    }
    else if ( STATUS_WAIT_1 == wait )
    {
        sc = STATUS_CANCELLED;
    }
    else
    {
        Win4Assert(!"Unexpected return from WaitForMultipleObjects()");
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::CreateWatchRegion
//
//  Synopsis:   Creates a new watch region
//
//  Arguments:  [mode] -- initial mode
//              [phRegion] -- (out) region handle
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::CreateWatchRegion (ULONG mode, HWATCHREGION* phRegion)
{
    CLock   lock( _mutex );
    _bitIsWatched = 1;

    *phRegion = _watchList.NewRegion (mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::ChangeWatchMode
//
//  Synopsis:   Changes watch mode of a region
//
//  Arguments:
//              [hRegion] -- region handle
//              [mode] -- new mode
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::ChangeWatchMode (  HWATCHREGION hRegion, ULONG mode)
{
    CLock   lock( _mutex );
    _watchList.ChangeMode (hRegion, mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::GetWatchRegionInfo
//
//  Synopsis:   Retrieves watch region information
//
//  Arguments:  [hRegion] -- region handle
//              [pChapter] -- (out) chapter
//              [pBookmark] -- (out) bookmark
//              [pcRows] -- (out) size in rows
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::GetWatchRegionInfo ( HWATCHREGION hRegion,
                                      CI_TBL_CHAPT* pChapter,
                                      CI_TBL_BMK* pBookmark,
                                      DBROWCOUNT * pcRows)
{
    CLock   lock( _mutex );
    _watchList.GetInfo (hRegion, pChapter, pBookmark, (DBCOUNTITEM *)pcRows);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::DeleteWatchRegion
//
//  Synopsis:   Delete watch region
//
//  Arguments:  [hRegion] -- region handle
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::DeleteWatchRegion (HWATCHREGION hRegion)
{
    CLock   lock( _mutex );
    _watchList.DeleteRegion (hRegion);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::ShrinkWatchRegion
//
//  Synopsis:   Shrinks watch region
//
//  Arguments:  [hRegion] -- region handle
//              [chapter] -- new chapter
//              [bookmark] -- new bookmark
//              [cRows] -- new size in rows
//
//  History:    Jun-16-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CLargeTable::ShrinkWatchRegion (HWATCHREGION hRegion,
                                    CI_TBL_CHAPT   chapter,
                                    CI_TBL_BMK     bookmark,
                                    LONG cRows )
{
    CLock   lock( _mutex );
    _watchList.ShrinkRegion (hRegion, chapter, bookmark, cRows);

#if CIDBG==1
    CWatchRegion * pRegion = _watchList.GetRegion(hRegion);
    _watchList.CheckRegionConsistency( pRegion );
#endif  //CIDBG==1

}



//+-------------------------------------------------------------------------
//
//  Member:     CLargeTable::Refresh
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [] --
//
//  History:    Apr-4-95    BartoszM    Created
//              Jul-27-95   BartoszM   Implemented (with no change script)
//
//--------------------------------------------------------------------------

void CLargeTable::Refresh()
{
    CDynStack<CTableBucket>  xBktToConvert(0); // buckets to expand at our leisure

    {
        CLock lock (_mutex);
        _LokCheckQueryStatus();

        _bitClientNotified = 0;
        _bitRefresh = 0;


        // Update the bookmarks before refreshing windows.
        // We need to know where they will be migrating
        // in case rows were deleted.
        // Remove watch regions from windows

        for (CWatchIter iterWatch1 (_watchList);
            !_watchList.AtEnd(iterWatch1);
            _watchList.Advance(iterWatch1))
        {
            CWatchRegion* pRegion = iterWatch1.Get();

            if (pRegion->IsInit())
            {
                CTableWindow * pWindow = (CTableWindow *) pRegion->Segment();

                CI_TBL_BMK bookmark = _FindNearestDynamicBmk (
                    pWindow,
                    pRegion->Chapter(),
                    pRegion->Bookmark());

                pRegion->Set( pRegion->Chapter(),
                              bookmark,
                              pRegion->RowCount() );

                _watchList.ShrinkRegionToZero (pRegion->Handle());
            }
        }

        // Recreate new watch regions in windows
        // Find starting segments using bookmarks

        for (CWatchIter iterWatch3 (_watchList);
            !_watchList.AtEnd(iterWatch3);
            _watchList.Advance(iterWatch3))
        {
            CWatchRegion* pRegion = iterWatch3.Get();

            if ( pRegion->RowCount() > 0 )
            {
                Win4Assert( widInvalid != pRegion->Bookmark() );

                CTableSegment* pSegment = _LokFindTableSegment(pRegion->Bookmark());
                pRegion->SetSegment( pSegment );

                if ( 0 != pSegment )
                {
                    LokStretchWatchRegion (pRegion, xBktToConvert);
                    _watchList. BuildRegion (
                            pRegion->Handle(),
                            pSegment,
                            pRegion->Chapter(),
                            pRegion->Bookmark(),
                            pRegion->RowCount() );
                }
#if CIDBG==1
                _watchList.CheckRegionConsistency( pRegion );
#endif  // CIDBG==1
            }
        }

        //
        // If there are any deferred rows that were not added during the
        // normal "PutRow", we should expand them now.
        //
        if ( 0 != _pDeferredRows )
        {
            xBktToConvert.Push(_pDeferredRows);
            _pDeferredRows = 0;
        }

        if (_bitChangeQuiesced)
            LokCompleteAsyncNotification();
    }

    if ( xBktToConvert.Count() > 0 )
    {
        // Schedule buckets for asynchronous expansion
        _NoLokBucketToWindows( xBktToConvert, widInvalid, TRUE, FALSE );
    }
} //Refresh


void CLargeTable::LokStretchWatchRegion (  CWatchRegion* pRegion,
                                        CDynStack<CTableBucket>&  xBktToConvert)
{
    CTableWindow* pFirstWindow = (CTableWindow*) pRegion->Segment();
    Win4Assert (pFirstWindow->IsWindow());
    //
    // Compute the number of rows that can be retrieved from current window.
    //
    TBL_OFF dummy;
    ULONG     iRow;
    pFirstWindow->FindBookMark(pRegion->Bookmark(), dummy, iRow );

    ULONG cRowsToRetrieve = pRegion->RowCount();
    ULONG cRowsFromCurrWindow = (ULONG)pFirstWindow->RowCount() - iRow;

    if ( cRowsToRetrieve > cRowsFromCurrWindow )
    {
        //
        // We still have more rows to be retrieved.
        //
        cRowsToRetrieve -= cRowsFromCurrWindow;
    }
    else
    {
        //
        // This window can give us all the rows to be fetched.
        //
        return;
    }

    CDoubleTableSegIter iter (pRegion->Segment());

    do
    {
        Win4Assert( !_segList.AtEnd(iter) );

        _segList.Advance( iter );

        if ( _segList.AtEnd(iter) )
        {
            break;
        }

        if ( iter.GetSegment()->IsBucket() )
        {
            CTableBucket * pBucket = _LokReplaceWithEmptyWindow(iter);
            xBktToConvert.Push(pBucket);
        }
        else
        {
            CTableWindow * pWindow = iter.GetWindow();
            cRowsFromCurrWindow = (ULONG)pWindow->RowCount();

            if ( cRowsToRetrieve > cRowsFromCurrWindow )
            {
                cRowsToRetrieve -= cRowsFromCurrWindow;
            }
            else
            {
                cRowsToRetrieve = 0;
            }
        }
    }
    while ( cRowsToRetrieve > 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::CancelAsyncNotification
//
//  Synopsis:   signals the notification event
//
//  History:    10-24-94     dlee      created
//
//  Notes:      can only be called from the destructor
//
//----------------------------------------------------------------------------

void CLargeTable::CancelAsyncNotification()
{
    if ( 0 != _pRequestServer )
    {
        //_pRequestServer->CompleteNotification( 0 );
        _pRequestServer = 0;
        return;
    }

    if ( 0 != _hNotifyEvent )
        SetEvent( _hNotifyEvent );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLargeTable::LokCompleteAsyncNotification
//
//  Synopsis:   signals the notification event
//
//  History:    10-24-94     dlee      created
//
//----------------------------------------------------------------------------

void CLargeTable::LokCompleteAsyncNotification()
{
    if (_bitClientNotified && !_bitChangeQuiesced)
        return; // no need to keep pinging the client

    Win4Assert( ! ( _pRequestServer && _hNotifyEvent ) );

    if ( 0 != _pRequestServer )
    {
        if ( LokNeedToNotifyReset( _changeType ) )
        {
            if ( DBWATCHNOTIFY_ROWSCHANGED == _changeType )
                _bitClientNotified = 1;

            tbDebugOut (( DEB_NOTIFY, "complete in lcan: %d\n",
                          _changeType ));

            _pRequestServer->CompleteNotification( _changeType );
            _pRequestServer = 0;
        }

        return;
    }

    if ( 0 != _hNotifyEvent )
    {
        if ( LokNeedToNotifyReset( _changeType ) )
        {
            if ( DBWATCHNOTIFY_ROWSCHANGED == _changeType )
                _bitClientNotified = 1;

            SetEvent( _hNotifyEvent );
            // event will be released / zeroed by notify thread.
        }
    }

} //LokCompleteAsyncNotification

//+---------------------------------------------------------------------------
//
//  Function:   _LokConvertToBucket
//
//  Synopsis:   Converts the given window into a bucket and replace the
//              window with a bucket.
//
//  Arguments:  [window] - The window to be converted into a bucket.
//
//  Returns:    The bucket that was created.
//
//  History:    3-24-95   srikants   Created
//
//----------------------------------------------------------------------------

void CLargeTable::_LokConvertToBucket( CTableWindow ** ppWindow )
{

    //
    // Convert the window into a bucket.
    //
    CTableWindow * pWindow = *ppWindow;
    Win4Assert( pWindow->IsWindow() );

    CBucketizeWindows   bucketize( *this, *pWindow );
    tbDebugOut(( DEB_WINSPLIT, "Converting 0x%X window to buckets\n",
                 pWindow->GetSegId() ));
    bucketize. LokCreateBuckets( *_pSortSet,
                                 _keyCompare.GetReference(),
                                 _MasterColumnSet );

    CTableSegList & bktList = bucketize.GetBucketsList();

    for ( CFwdTableSegIter iter2(bktList); !bktList.AtEnd(iter2);
          bktList.Advance(iter2) )
    {
        //
        // This information is needed for doing a wid->path translation
        //
        CTableBucket * pBucket = iter2.GetBucket();
        pBucket->SetLargeTable(this);
    }

    if ( 0 != bktList.GetSegmentsCount() )
    {
        _segListMgr.Replace( pWindow, bktList );
    }
    else
    {
        _segListMgr.RemoveFromList( pWindow );
    }

    *ppWindow = 0;
    delete pWindow;
} //_LokConvertToBucket

//+---------------------------------------------------------------------------
//
//  Function:   _LokConvertWindowsToBucket
//
//  Synopsis:   Uses heuristics to convert some of the windows into buckets
//              to reduce memory usage.
//
//  History:    3-24-95   srikants   Created
//
//  Notes:      This function needs a lot of work. For now, it just tries
//              to avoid converting windows that "were recently used". It
//              also tries to alternate windows and buckets if possible.
//
//              A heuristic used is NOT to convert the "last" window into a
//              bucket. This is because in case of content queries, the
//              results are probably coming sorted and we can use this fact.
//              Since new rows always go to the end, we will win by creating
//              well sorted buckets when windows are converted into buckets.
//
//              Also, don't convert a window to a bucket if it is < 40%
//              capacity.
//
//----------------------------------------------------------------------------

void CLargeTable::_LokConvertWindowsToBucket( WORKID widToPin )
{
    if ( _segList.GetWindowsCount() < cMaxWindows )
        return;

    unsigned cWindows = 0;
    BOOL     fConvert = TRUE;   // used to keep alternated segments as
                                // windows (approx)

    CBackTableSegIter   iter(_segList);

    while( !_segList.AtEnd(iter) )
    {
        CTableSegment * pSegment = iter.GetSegment();

        if ( pSegment->IsWindow() )
        {
            cWindows++;
            CTableWindow * pWindow = iter.GetWindow();
            ULONG cRows = (ULONG)pWindow->RowCount();

            if ( fConvert &&
                 cRows >= cMinRowsToBucketize &&
                 !pWindow->IsWatched() &&
                 !_segListMgr.IsRecentlyUsed(pWindow) &&
                 !_segList.IsLast(iter) &&
                 !_segList.IsFirst(iter) &&
                 ( widInvalid == widToPin || !pWindow->IsRowInSegment( widToPin ) ) )
            {
                //
                // The window may be deleted. So, we must backup the iterator
                // before destroying the window.
                //

                Win4Assert( widInvalid == widToPin ||
                            !pWindow->IsRowInSegment( widToPin ) );

                CTableWindow * pWindow = iter.GetWindow();
                _segList.BackUp(iter);

                _LokConvertToBucket( &pWindow );
                //
                // Don't convert the next segment into a bucket.
                //
                fConvert = FALSE;
            }
            else
            {
                _segList.BackUp(iter);
                //
                // We had a window which we didn't convert into a bucket.
                // If the next one is a window, we can convert it.
                //
                fConvert = TRUE;
            }
        }
        else
        {
            _segList.BackUp(iter);
        }
    }

    Win4Assert( cWindows >= cMaxWindows );
} //_LokConvertWindowsToBucket

//+---------------------------------------------------------------------------
//
//  Function:   _LokReplaceWithEmptyWindow
//
//  Synopsis:   Replaces the given bucket with an empty window in preparation
//              for bucket->window conversion.
//
//  Arguments:  [pBucket] -  The bucket to replace
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableBucket *
CLargeTable::_LokReplaceWithEmptyWindow( CDoubleTableSegIter & iter )
{

    Win4Assert( iter.GetSegment()->IsBucket() );

    CTableBucket * pBucket = iter.GetBucket();

    tbDebugOut(( DEB_WINSPLIT,
                 "Replacing Bucket 0x%X with Window\n", pBucket->GetSegId() ));

    CTableWindow * pWindow = _CreateNewWindow( pBucket->GetSegId(),
                                               pBucket->GetLowestKey(),
                                               pBucket->GetHighestKey());
    _segListMgr.Replace( iter, pWindow );


    //
    // Make the newly created window preferred place to put the new
    // rows in.
    //
    _segListMgr.SetCachedPutRowSeg( pWindow );

    return pBucket;
}

//+---------------------------------------------------------------------------
//
//  Function:   _NoLokBucketToWindows
//
//  Synopsis:
//
//  Arguments:  [xBktToExpand] -
//              [widToPin]     -
//              [isWatched]    -
//
//  Returns:
//
//  History:    7-07-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLargeTable::_NoLokBucketToWindows( XPtr<CTableBucket> & xBktToExpand,
                                    WORKID widToPin,
                                    BOOL isWatched,
                                    BOOL fOptimizeBucketization )
{

    CAsyncBucketExploder * pBktExploder =
            new CAsyncBucketExploder( *this,
                                      xBktToExpand,
                                      widToPin,
                                      !_fUniqueWorkid );
    //
    // DO NOT add any code here. pBucket now belongs to pBktExploder and we
    // should acquire it from xBktToExpand before doing anything else.
    //
    Win4Assert( 0 == xBktToExpand.GetPointer() );
    XInterface<CAsyncBucketExploder> xRef(pBktExploder);

    //
    // We don't have to do an AddRef on pBktExploder because it is refcounted
    // in the constructor.
    //
    NTSTATUS  status = STATUS_SUCCESS;

    //
    // Lock the table
    // ============================================================
    //
    {
        CLock   lock(_mutex);

        _LokCheckQueryStatus();

        if ( 0 != _pQExecute )
        {
            pBktExploder->SetQuery( _pQExecute );
        }
        else
        {
            //
            // The query is being destoryed.
            //
            THROW( CException( STATUS_TOO_LATE ) );
        }

        //
        // Convert any excess windows to buckets.
        //

        if ( fOptimizeBucketization )
            _LokConvertWindowsToBucket( widToPin );

        //
        // Add to the bigtable's list of exploding buckets.
        //
        _LokAddToExplodeList( pBktExploder );
        pBktExploder->SetOnLTList();
    }

    //
    // Release the table
    // ============================================================
    //

    if ( isWatched )
    {

        //
        // There can be a failure (like failing to create a worker thread)
        // when we add to the work queue. So, we must be able to deal with
        // it.
        //

        TRY
        {
            ciFAILTEST( STATUS_NO_MEMORY );
            pBktExploder->AddToWorkQueue();
        }
        CATCH( CException, e )
        {
            tbDebugOut(( DEB_ERROR,
                "CLargeTable::_NoLokBucketToWindow "
                "AddToWorkQueue failed with error 0X%X\n",
                e.GetErrorCode() ));

           SetStatus( STAT_ERROR );
           _RemoveFromExplodeList( pBktExploder );
           pBktExploder->Abort();

           RETHROW();
        }
        END_CATCH

        xRef.Acquire();
        pBktExploder->Release();

        //
        // Return to the caller from here and continue fetching the
        // remaining rows.
        //

    }
    else
    {
        //
        // No need of using another thread. Just use the callers
        // thread.
        //
        pBktExploder->DoIt( 0 );
        status = pBktExploder->GetStatus();
        xRef.Acquire();
        pBktExploder->Release();
    }

    if ( STATUS_SUCCESS != status )
    {
        THROW( CException(status) );
    }

    if (!isWatched)
    {
        CLock   lock(_mutex);
        //
        // Give a notification to "kick" the notification thread after the
        // bucket->window conversion.
        //
        LokCompleteAsyncNotification();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _NoLokBucketToWindows
//
//  Synopsis:   Converts the given buckets into a windows.
//
//  Arguments:  [bucketRef] -  Safe stack of buckets.
//
//  History:    3-24-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLargeTable::_NoLokBucketToWindows( CDynStack<CTableBucket> & xSegStack,
                                    WORKID widToPin,
                                    BOOL isWatched,
                                    BOOL fOptimizeBucketization )
{

    //
    // The bucket that must be scheduled for expansion.
    //
    XPtr<CTableBucket> xBktToExpand;

    do
    {

        //
        //=============================================================
        // Lock the table.
        //
        {
            CLock   lock(_mutex);
            CTableBucket * pBucket = (CTableBucket *) xSegStack.Pop();
            Win4Assert( 0 == xBktToExpand.GetPointer() );
            xBktToExpand.Set( pBucket );
        }
        //
        //=============================================================
        // release the lock on table
        //

        //
        // Convert this single bucket to a window.
        //
        _NoLokBucketToWindows( xBktToExpand, widToPin, isWatched, fOptimizeBucketization );

    } while (  0 != xSegStack.Count() );
} //_NoLokBucketToWindows

//+---------------------------------------------------------------------------
//
//  Method:     CLargeTable::GetRowsAt
//
//  Synopsis:   Fetch rows relative to a bookmark
//
//  Arguments:  [hRegion]                - watch region handle
//              [widStart]               -
//              [chapt]    - Chapter from which to fetch rows (if chaptered)
//              [iRowOffset]             -
//              [rOutColumns]            -
//              [rGetParams]             -
//              [rwidLastRowTransferred] -
//
//  Returns:
//
//  History:    3-31-95   srikants   Created
//              6-28-95     BartoszM    Added watch region support
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE
CLargeTable::GetRowsAt(
        HWATCHREGION            hRegion,
        WORKID                  widStart,
        CI_TBL_CHAPT            chapt,
        DBROWOFFSET             iRowOffset,
        CTableColumnSet const & rOutColumns,
        CGetRowsParams &        rGetParams,
        WORKID &                rwidLastRowTransferred
        )
{

    //
    // DO NOT OBTAIN LOCK HERE.
    // If the row of interest is in an un-sorted bucket, it must be
    // expanded into a window before we can determine the exact wid.
    // For bucket->window expansion, we have to release the lock because
    // the conversion (not now but later) will be done by a worker thread
    // and we will deadlock.
    //

    tbDebugOut(( DEB_REGTRANS,
            " =============== Entering GetRowsAt ========= \n\n " ));

    if ( iRowOffset > 0 )
        rwidLastRowTransferred = WORKID_TBLLAST;
    else
        rwidLastRowTransferred = WORKID_TBLFIRST;

    BOOL fAsync = FALSE;

    if ( WORKID_TBLBEFOREFIRST == widStart )
    {
        if (iRowOffset <= 0)
        {
           widStart = WORKID_TBLLAST;
        }
        else
        {
           widStart = WORKID_TBLFIRST;
           iRowOffset--;
        }
    }
    else if ( WORKID_TBLAFTERLAST == widStart )
    {
        widStart = WORKID_TBLLAST;
        iRowOffset++;
    }

    tbDebugOut(( DEB_REGTRANS, "  widstart 0x%x, offset %d\n", widStart, iRowOffset ));

    ULONG cChaptRows = 0;
    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
    {
        CLock   lock(_mutex);

        cChaptRows = GetCategorizer()->GetRowCount( chapt );
        if ( WORKID_TBLFIRST == widStart || WORKID_TBLLAST == widStart )
        {
            BOOL isLastBmk = WORKID_TBLLAST == widStart;
            widStart = GetCategorizer()->GetFirstWorkid( chapt );
            if ( isLastBmk )
            {
                iRowOffset += ( cChaptRows - 1 );
            }

            if ( ( isLastBmk ) &&
                 ( -1 == iRowOffset ) &&
                 ( 1 == cChaptRows ) )
            {
                iRowOffset = 0;
            }
        }
    }

    CTableRowLocator rowLocator( *this, widStart, (LONG) iRowOffset, chapt );
    CTableRowGetter  tableRowGetter( *this, rOutColumns, rGetParams, chapt, hRegion );
    SCODE status = S_OK;

    CWatchRegion* pWatchRegion = 0;
    BOOL fBeyondTable = FALSE;          // flag indicating if we had to go
                                        // beyond the end of the table.

    CDynStack<CTableBucket>  xBktToConvert(0); // buckets to expand at our leisure

    WORKID  widToPin = widInvalid;  // The workid we need to pin.

    for (;;)
    {
        //
        // Loop as long as there are buckets to be sychronously
        // expanded.
        //

        XPtr<CTableBucket>  xBktToExplode(0); // bucket to explode synchronously

        // ============================================================
        {
            CLock   lock(_mutex);

            _LokCheckQueryStatus();
            fAsync = _LokIsWatched() && (0 != hRegion);

            if (!_watchList.IsEmpty())
            {
                _watchList.VerifyRegion (hRegion);
                // valid region or null
                pWatchRegion = _watchList.GetRegion(hRegion);
            }
            else if (hRegion != 0)
            {
                THROW (CException(E_INVALIDARG));
            }

#if CIDBG==1
            if ( 0 != pWatchRegion && pWatchRegion->IsInit() )
            {
                Win4Assert( pWatchRegion->Segment()->IsWindow() );
                CTableWindow * pWindow = (CTableWindow *) pWatchRegion->Segment();
                Win4Assert( pWindow->HasWatch( hRegion ) );
            }
#endif  // CIDBG==1

            CRegionTransformer regionTransformer( pWatchRegion,
                                                  (LONG) iRowOffset,
                                                  rGetParams.RowsToTransfer(),
                                                  rGetParams.GetFwdFetch() );

            CFwdTableSegIter iter( _segList );

            //
            // Locate the bookmark.
            //
            status = rowLocator.LokLocate( hRegion,
                                           fAsync,
                                           iter,
                                           regionTransformer);

            if ( S_OK != status )
            {
                return status;
            }

            // also: calculate the fetch coordinates
            if ( !regionTransformer.Validate() )
                THROW (CException(DB_E_NONCONTIGUOUSRANGE));

            // The iterator is positioned at the fetch bookmark
            // Move it to the actual fetch offset

            rowLocator.LokRelocate ( fAsync,
                                     iter,
                                     regionTransformer,
                                     xBktToExplode,
                                     xBktToConvert );

            if ( xBktToExplode.IsNull() )
            {
                //
                // The first row to be fetched is in a window.
                //

                if ( 0 != rowLocator.GetBeyondTableCount() )
                {
                    tbDebugOut(( DEB_REGTRANS,
                                 "    GetBeyondTableCount: %d\n",
                                 rowLocator.GetBeyondTableCount() ));
                    //
                    // The requested offset is beyond the table. Must update
                    // the row retrieval count based on the residual row
                    // count.
                    //
                    regionTransformer.DecrementFetchCount( rowLocator,
                                                           iter,
                                                           _segList );

                    // to support watch regions, fetches beyond the
                    // end of rowset are expected

                    fBeyondTable = TRUE;

                    // don't read any rows that do fall in the table
                    // if notifications aren't enabled.

                    if ( 0 == _bitNotifyEnabled )
                        break;
                }

                Win4Assert( regionTransformer.GetFetchCount() >= 0 );
                if ( regionTransformer.GetFetchCount() > 0 )
                {
                    Win4Assert( iter.GetSegment()->IsWindow() );
                    if ( 0 != regionTransformer.Region() )
                    {
                        CDoubleTableSegIter fakeIter( iter );

                        //
                        // Simulate a fetch and collect all the buckets to be
                        // asynchronously expanded.
                        //
                        rowLocator.LokSimulateFetch( fakeIter,
                                                     regionTransformer,
                                                     xBktToConvert );
                        regionTransformer.Transform (_segList,
                                                     _watchList );
                    }

                    //
                    // We have located exactly where the starting workid is.
                    // Start fetching rows from here.
                    //
                    widStart = rowLocator.GetWorkIdFound();
                    tableRowGetter.SetRowsToTransfer( (ULONG) regionTransformer.GetFetchCount() );

                    //
                    //  Real Work done here!
                    //
                    CTableWindow * pWindow = iter.GetWindow();
                    status = tableRowGetter.LokGetRowsAtSegment ( pWindow,
                                                                  widStart,
                                                                  fAsync,
                                                                  xBktToExplode );

                    rwidLastRowTransferred = tableRowGetter.GetLastWorkId();

                    if ( !xBktToExplode.IsNull() )
                    {
                        Win4Assert( !fAsync );

                        //
                        // All the requested rows did not get filled in.
                        // We have hit a bucket which must be exploded.
                        // Snapshot the current position and offset (either
                        // +1 if forward fetch or -1 if backwards fetch) so
                        // that we can continue from the snapshotted position
                        // after the bucket has been exploded.
                        //

                        long iOffset;
                        if ( rGetParams.GetFwdFetch() )
                            iOffset = 1;
                        else
                            iOffset = -1;

                        rowLocator.SetLocateInfo( rwidLastRowTransferred, iOffset );
                        widToPin = rwidLastRowTransferred;

                        iRowOffset = iOffset;
                    }
                } // regionTransformer.GetFetchCount() > 0
            }

#if CIDBG==1
        _watchList.CheckRegionConsistency( pWatchRegion );
#endif  // CIDBG==1

        }
        // Lock released
        // ============================================================

        if ( 0 != xBktToExplode.GetPointer() )
        {
            // We need to synchronously convert bucket into windows.
            // and then restart fetching from the top

            if ( widInvalid == widToPin )
                widToPin = widStart;

            _NoLokBucketToWindows( xBktToExplode, widToPin, FALSE, FALSE );
        }
        else
        {
            break;
        }
    } // end of bucket expansion loop

    if ( xBktToConvert.Count() > 0 )
    {
        // Schedule buckets for asynchronous expansion
        _NoLokBucketToWindows ( xBktToConvert, widInvalid, TRUE, TRUE );
    }

    if (SUCCEEDED(status) && fBeyondTable)
    {
       if ( _bitNotifyEnabled )
           status = DB_S_ENDOFROWSET;
       else
           status = DB_E_BADSTARTPOSITION;
    }
    else if ( ( IsCategorized() ) &&
              ( DB_S_ENDOFROWSET == status ) &&
              ( 0 == rGetParams.RowsTransferred() ) &&
              ( 0 != cChaptRows ) )
    {
        status = DB_E_BADSTARTPOSITION;
    }

    //
    // If the query timed out and we're fetching at the end of the
    // rowset, give an appropriate status.
    //

    if ( ( DB_S_ENDOFROWSET == status ) &&
         ( 0 != ( Status() & STAT_TIME_LIMIT_EXCEEDED ) ) )
    {
        status = DB_S_STOPLIMITREACHED;
    }

    return status;
} //GetRowsAt

//+---------------------------------------------------------------------------
//
//  Function:   GetRowsAtRatio
//
//  Synopsis:   An APPROXIMATE retrieval of rows. NOTE that this is not
//              EXACT - use GetRowsAt to retrieve rows at exact position.
//
//  Arguments:  [hRegion]                - watch region handle
//              [ulNum]                  -
//              [ulDenom]                -
//              [chapt]                  - Chapter of rows returned
//              [rOutColumns]            -
//              [rGetParams]             -
//              [rwidLastRowTransferred] -
//
//  Returns:
//
//  History:    4-04-95   srikants   Created
//              6-28-95     BartoszM    Added watch region support
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE
CLargeTable::GetRowsAtRatio(
        HWATCHREGION hRegion,
        ULONG       ulNum,
        ULONG       ulDenom,
        CI_TBL_CHAPT   chapt,
        CTableColumnSet const & rOutColumns,
        CGetRowsParams & rGetParams,
        WORKID &    rwidLastRowTransferred
        )
{
    if ( 0 == ulDenom || ulNum > ulDenom )
    {
        QUIETTHROW( CException(DB_E_BADRATIO) );
    }

    BOOL  fFarFromWindow = TRUE;
    BOOL  fAsync = FALSE;

    SCODE  scRet = S_OK;
    ULONG cRowsFromFront = 0;

    WORKID  widAnchor = widInvalid; // initialize to an invalid value.
    ULONG cPercentDiff = 0;
    LONG offFetchStart = 0;

    XPtr<CTableBucket>      xBktToExplode(0);

    //
    // ==================================================================
    // Obtain the lock
    {

        CLock   lock(_mutex);
        _LokCheckQueryStatus();

        if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        {

            ULONG cRows = GetCategorizer()->GetRowCount( chapt );

            Win4Assert( 0 != cRows && "Chapter is empty" );

            LONGLONG  llcRowsFromFront = ( (LONGLONG) cRows) * ulNum ;
            llcRowsFromFront /= ulDenom;
            Win4Assert( llcRowsFromFront <= cRows && llcRowsFromFront >= 0 );
            cRowsFromFront = lltoul( llcRowsFromFront ) ;
        }
        else
        {
            //
            // Determine the approximate offset from the beginning of the table
            //
            const ULONG cTotalRows = (ULONG) RowCount();

            if ( 0 == cTotalRows )
            {
                rwidLastRowTransferred = WORKID_TBLAFTERLAST;
                return DB_S_ENDOFROWSET;
            }

            LONGLONG  llcRowsFromFront = ( (LONGLONG) cTotalRows) * ulNum ;
            llcRowsFromFront /= ulDenom;
            Win4Assert( llcRowsFromFront <= cTotalRows && llcRowsFromFront >= 0 );
            cRowsFromFront = lltoul( llcRowsFromFront ) ;

            if ( cRowsFromFront == cTotalRows )
            {
                if ( rGetParams.GetFwdFetch() )
                {
                    //
                    // The user is asking to retrieve past the end of table.
                    //
                    rwidLastRowTransferred = WORKID_TBLAFTERLAST;
                    return DB_S_ENDOFROWSET;
                }
                else
                {
                    //
                    // Fetch rows starting with last row in rowset
                    //
                    rwidLastRowTransferred = WORKID_TBLAFTERLAST;

                    SCODE scRet = GetRowsAt( hRegion,
                                             WORKID_TBLAFTERLAST,
                                             chapt,
                                             -1,
                                             rOutColumns,
                                             rGetParams,
                                             rwidLastRowTransferred );
                     return scRet;
                }
            }

            //
            // Locate the closest window at this offset.
            //
            CLinearRange    winRange;   // will be initialized by _LokGetClosestWindow
            CTableWindow * pWindow = _LokGetClosestWindow( cRowsFromFront, winRange );

            if ( 0 == pWindow )
            {
                fFarFromWindow = TRUE;
            }
            else
            {
                //
                // Offset of the first row from the beginning of the table.
                //
                offFetchStart = winRange.GetLow();

                if ( winRange.InRange( cRowsFromFront ) &&
                     rGetParams.RowsToTransfer() <= winRange.GetRange() )
                {
                    //
                    // This window has enough rows.
                    //

                    long cRowsOff;        // offset within the window
                    if ( rGetParams.GetFwdFetch() )
                    {
                        if ( cRowsFromFront + rGetParams.RowsToTransfer() <=
                             winRange.GetHigh() )
                        {
                            //
                            // We hit the exact row that the client requested.
                            //
                            cRowsOff = cRowsFromFront - winRange.GetLow();
                        }
                        else
                        {
                            //
                            // Optimization : We cannot fill the output set with the rows
                            // from this window if we position exactly. So just use a
                            // little from front.
                            //
                            cRowsOff = winRange.GetRange() - rGetParams.RowsToTransfer();
                        }
                    }
                    else
                    {
                        if ( cRowsFromFront >= rGetParams.RowsToTransfer()
                             && cRowsFromFront - rGetParams.RowsToTransfer() >= winRange.GetLow() )
                        {
                            //
                            // We hit the exact row that the client requested
                            //
                             cRowsOff = cRowsFromFront - winRange.GetLow();
                        }
                        else
                        {
                            //
                            // Optimization : We cannot fill the output set with the rows
                            // from this window if we position exactly. So just use a
                            // little from back.
                            //
                            cRowsOff = rGetParams.RowsToTransfer() - 1;
                        }
                    }

                    //
                    // There was no wrap around.
                    //
                    Win4Assert( cRowsOff >= 0 && cRowsOff < (long)pWindow->RowCount());

                    offFetchStart += cRowsOff;
                    widAnchor = pWindow->GetBookMarkAt( cRowsOff );
                }
                else
                {
                    widAnchor = WORKID_TBLFIRST;
                }

                const cMaxApproxPerCent = 10;   // Let us say 10% maximum approximation

                //
                // Determine how accurate is the approximate position.
                //
                cPercentDiff =  AbsDiff( offFetchStart, cRowsFromFront ) * 100;
                cPercentDiff /= cTotalRows;
                if ( cPercentDiff <= cMaxApproxPerCent )
                {
                    Win4Assert( widInvalid != widAnchor );
                    fFarFromWindow = FALSE;
                }
                else
                {
                    tbDebugOut(( DEB_WINSPLIT,
                        " Approximation is too off 0x%X - Requested - Arrived 0x%X\n",
                        cRowsFromFront, offFetchStart ));
                }
            }

            fAsync = _LokIsWatched() && (0 != hRegion);

            if ( 0 != hRegion )
            {
                // Nuke the region first
                _watchList.ShrinkRegionToZero (hRegion);
            }

            //
            // If we are either too far from a window or if the asynchronous
            // mode is on, we have to use GetRowsAt()
            //
            if ( !fFarFromWindow && !fAsync )
            {
                tbDebugOut(( DEB_WINSPLIT,
                    "GetRowsAtRatio - Approximate. Requested 0x%X Actual 0x%X Percent 0x%X\n",
                    cRowsFromFront, offFetchStart, cPercentDiff ));

                CTableRowGetter   rowGetter( *this, rOutColumns, rGetParams, chapt, hRegion );


                //
                // Real work done here!
                //
                Win4Assert( widInvalid != widAnchor );
                Win4Assert( 0 != pWindow->RowCount() );

#if CIDBG==1
                TBL_OFF oRowdummy;
                ULONG     iRowdummy;
                Win4Assert( pWindow->FindBookMark( widAnchor, oRowdummy, iRowdummy ) );
#endif  // CIDBG==1

                scRet = rowGetter.LokGetRowsAtSegment( pWindow,
                                                       widAnchor,
                                                       FALSE,   // synchronous
                                                       xBktToExplode );

                if ( !FAILED(scRet) )
                {
                    rwidLastRowTransferred = rowGetter.GetLastWorkId();

                    Win4Assert( rwidLastRowTransferred != widInvalid &&
                                !IsSpecialWid( rwidLastRowTransferred ) );
                }

                if ( xBktToExplode.IsNull() )
                {
                    return scRet;
                }

                //
                // The bucket to explode is not null.  We will synchronously
                // explode it and continue fetching from there on.
                //
                Win4Assert( !FAILED(scRet) );
            }
        }
    }
    // ==================================================================
    // Release table lock

    //
    // We are either :
    // 1. Far from window or
    // 2. Is being watched or
    // 3. We have a bucket to explode synchronously.
    //
    if ( xBktToExplode.IsNull() )
    {
        //
        // We are either far from a window or we have a watch region.
        //
        widAnchor = WORKID_TBLFIRST;
        offFetchStart = cRowsFromFront;
    }
    else
    {
        widAnchor = rwidLastRowTransferred;
        if ( rGetParams.GetFwdFetch() )
            offFetchStart = 1;
        else
            offFetchStart = -1;

        _NoLokBucketToWindows( xBktToExplode, widAnchor, FALSE, TRUE );   // synchronous
    }

    tbDebugOut(( DEB_WINSPLIT, "GetRowsAtRatio - going to GetRowsAt\n" ));
    Win4Assert( widInvalid != widAnchor );

    // The region is pre-shrunk to zero, so it's okay to start in a bucket.
    scRet = GetRowsAt( hRegion,
                      widAnchor,
                      chapt,
                      offFetchStart,
                      rOutColumns,
                      rGetParams,
                      rwidLastRowTransferred );
    if (DB_E_BADSTARTPOSITION == scRet)
       scRet = DB_S_ENDOFROWSET;

    return scRet;
} //GetRowsAtRatio

//+---------------------------------------------------------------------------
//
//  Class:      CClosestWindow
//
//  Purpose:    Determines the closest window for a given position in the
//              table.
//
//  History:    4-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

class CClosestWindow
{

public:

    CClosestWindow( ULONG targetOffset, CTableSegList & list )
    : _targetOffset(targetOffset),
      _list(list),
      _iter(_list),
      _currSegOffset(0),
      _pBest(0), _bestRange(ULONG_MAX,ULONG_MAX),
      _fDone(FALSE)
    {

    }

    void ProcessCurrent();

    BOOL IsDone() { return _fDone || _list.AtEnd(_iter); }

    CTableWindow * GetClosest( CLinearRange & winRange )
    {
        if ( 0 != _pBest )
        {
            winRange.Set( _bestRange.GetLow(), _bestRange.GetHigh() );
        }

        return _pBest;
    }

    void Next()
    {
        Win4Assert( !_list.AtEnd(_iter) );
        _list.Advance(_iter);
    }

private:

    ULONG               _targetOffset;  // Target offset to locate

    CTableSegList &     _list;          // The list of segments
    CFwdTableSegIter    _iter;          // Iterator over the list of segments

    ULONG               _currSegOffset; // Beginning offset of the current
                                        // segment

    CTableWindow *      _pBest;         // Best window so far
    CLinearRange        _bestRange;     // Range of the best window

    BOOL                _fDone;         // Flag set to TRUE if we have already
                                        // found the best possible window.
};

//+---------------------------------------------------------------------------
//
//  Function:   ProcessCurrent
//
//  Synopsis:   Processes the current segment in the iterator and updates
//              the "best" window if applicable.
//
//  History:    4-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CClosestWindow::ProcessCurrent( )
{

    CTableSegment * pSegment = _iter.GetSegment();
    Win4Assert( 0 != pSegment );

    Win4Assert( !_fDone );

    ULONG cRowsInSeg = (ULONG)pSegment->RowCount();
    ULONG currEndSeg = _currSegOffset;

    if ( 0 != cRowsInSeg )
    {
        currEndSeg += (cRowsInSeg-1);
    }

    if ( pSegment->IsWindow() && 0 != pSegment->RowCount() )
    {
        if ( _currSegOffset <= _targetOffset )
        {
            //
            // We are still on the left hand side. So, this one MUST be
            // closer than what we had before.
            //

            _pBest = (CTableWindow *) pSegment;
            _bestRange.Set( _currSegOffset, currEndSeg );
            _fDone = _bestRange.InRange( _targetOffset );
        }
        else
        {
            //
            // We are on the right hand side of the target.
            //
            CTableWindow * pRight = (CTableWindow *) pSegment;
            if ( 0 != _pBest )
            {
                if ( AbsDiff( _currSegOffset, _targetOffset ) <
                     AbsDiff( _bestRange.GetLow(), _targetOffset ) )
                {
                    //
                    // We found a closer window on the right hand
                    // side.
                    //
                    _pBest = pRight;
                    _bestRange.Set( _currSegOffset, currEndSeg );
                }
            }
            else
            {
                _pBest = pRight;
                _bestRange.Set( _currSegOffset, currEndSeg );
            }

            _fDone = TRUE;
        }
    }

    _currSegOffset += cRowsInSeg;

}


//+---------------------------------------------------------------------------
//
//  Function:   _LokGetClosestWindow
//
//  Synopsis:   Given a position from the beginning of the table, this
//              method determines the closest window from that position.
//
//  Arguments:  [cRowsFromFront] -  Number of rows from the beginning of
//              the table.
//              [winRange]       -  (output) Range of the window found in
//              the table.
//
//  Returns:    Pointer to the window, if one is found that is closest to
//              the position requested.
//
//  History:    4-03-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableWindow * CLargeTable::_LokGetClosestWindow(
    ULONG cRowsFromFront,
    CLinearRange & winRange  )
{
    winRange.Set(0,0);

    for ( CClosestWindow  closest( cRowsFromFront, _segList );
          !closest.IsDone();
          closest.Next() )

    {
        closest.ProcessCurrent();
    }

    return closest.GetClosest( winRange );
}


//+---------------------------------------------------------------------------
//
//  Function:   _CreateNewWindow
//
//  Synopsis:   Creates a new window with the given segment id.
//
//  Arguments:  [segId] - Segment id of the window to create.
//
//  Returns:    Pointer to the newly created window.
//
//  History:    4-19-95   srikants   Created
//
//  Notes:      This is a helper function for "CTableRowPutter" class.
//
//----------------------------------------------------------------------------

CTableWindow * CLargeTable::_CreateNewWindow(
    ULONG segId,
    CTableRowKey &lowKey,
    CTableRowKey &highKey)
{
    XPtr<CTableWindow> xWindow( new CTableWindow( _pSortSet,
                                                  _keyCompare.GetReference(),
                                                  &_MasterColumnSet,
                                                  segId,
                                                  GetCategorizer(),
                                                  _sharedBuf, 
                                                  *_pQExecute ) );

    xWindow->GetLowestKey() = lowKey;
    xWindow->GetHighestKey() = highKey;

    return xWindow.Acquire();
} //_CreateNewWindow

//+---------------------------------------------------------------------------
//
//  Function:   SetQueryExecute
//
//  Synopsis:   Initializes the query executer object to be used during
//              bucket->window conversion.  The query object will be refcounted
//              to co-ordinate destruction order.
//
//  Arguments:  [pQExecute] - Pointer to the query object.
//
//  History:    4-25-95   srikants   Created
//
//  Notes:      Must be called ONCE and only ONCE. Before ~CLargeTable is
//              called, the ReleaseQueryExecute MUST be called.
//
//----------------------------------------------------------------------------

void CLargeTable::SetQueryExecute( CQAsyncExecute * pQExecute )   // virtual
{
    CLock lock(_mutex);
    Win4Assert( 0 == _pQExecute );
    _pQExecute = pQExecute;
    _pQExecute->AddRef();

}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseQueryExecute
//
//  Synopsis:   Releases the query object. After this, we cannot do any
//              bucket->window conversions.
//
//  History:    4-25-95   srikants   Created
//
//  Notes:      MUST be called once before the destructor is called.
//
//----------------------------------------------------------------------------

void CLargeTable::ReleaseQueryExecute()
{
    CLock lock(_mutex);
    Win4Assert( 0 != _pQExecute );
    _pQExecute->Release();
    _pQExecute = 0;

    //
    // Abort all the bucket->window expansions that are in progress.
    //
    for ( CAsyncBucketExploder * pEntry = _explodeBktsList.RemoveLast();
          0 != pEntry;
          pEntry = _explodeBktsList.RemoveLast() )
    {
        pEntry->Close();
        pEntry->Abort();
        pEntry->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _LokAddToExplodeList
//
//  Synopsis:
//
//  Arguments:  [pBktExploder] -
//
//  Returns:
//
//  History:    5-30-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void CLargeTable::_LokAddToExplodeList( CAsyncBucketExploder * pBktExploder )
{
    Win4Assert( pBktExploder->IsSingle() );
    pBktExploder->AddRef();
    _explodeBktsList.Push( pBktExploder );


    //
    // Pin the workid to be in a window and prevent from being converted
    // into a bucket.
    //
    _segListMgr.SetInUseByBuckets( pBktExploder->GetWorkIdToPin() );
} //_LokAddToExplodeList

//+---------------------------------------------------------------------------
//
//  Function:   _RemoveFromExplodeList
//
//  Synopsis:
//
//  Arguments:  [pBktExploder] -
//
//  Returns:
//
//  History:    5-30-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLargeTable::_RemoveFromExplodeList( CAsyncBucketExploder * pBktExploder )
{
    {
        CLock   lock(_mutex);
        Win4Assert( 0 != pBktExploder );

        _explodeBktsList.RemoveFromList( pBktExploder );
        pBktExploder->Close();
        _segListMgr.ClearInUseByBuckets( pBktExploder->GetWorkIdToPin() );
    }

    pBktExploder->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryAbort
//
//  Synopsis:   Processes an abort and wakes up any waiters on the events
//              in the largetable.
//
//  History:    5-31-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CLargeTable::QueryAbort()
{
    CLock lock(_mutex);
    Win4Assert( 0 == _pQExecute );
    Win4Assert( _explodeBktsList.IsEmpty() );

    _fAbort = TRUE;
}  //QueryAbort

//+---------------------------------------------------------------------------
//
//  Method:     GetCurrentPosition, public
//
//  Synopsis:   Gets the current GetNextRows position for the table or
//              chapter.
//
//  Arguments:  [chapt] - gets the current position for this chapter
//
//  History:    6-30-95   dlee   Created
//
//----------------------------------------------------------------------------

WORKID CLargeTable::GetCurrentPosition(
    CI_TBL_CHAPT chapt)
{
    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        return GetCategorizer()->GetCurrentPositionThisLevel( chapt );
    else
        return _widCurrent;
} //GetCurrentPosition

//+---------------------------------------------------------------------------
//
//  Method:     SetCurrentPosition, public
//
//  Synopsis:   Sets the current GetNextRows position for the table or
//              chapter.
//
//  Arguments:  [chapt] - sets the current position for this chapter
//
//  History:    6-30-95   dlee   Created
//
//----------------------------------------------------------------------------

WORKID CLargeTable::SetCurrentPosition(
    CI_TBL_CHAPT chapt,
    WORKID wid)
{
    if ( IsCategorized() && DB_NULL_HCHAPTER != chapt )
        return GetCategorizer()->SetCurrentPositionThisLevel( chapt, wid );
    else
        return ( _widCurrent = wid );
} //SetCurrentPosition

//+---------------------------------------------------------------------------
//
//  Method:     LokGetOneColumn, public
//
//  Synopsis:   Gets data for one column for the given workid.
//
//  Arguments:  [wid]           - for which data is retrieved
//              [rOutColumn]    - column descritption for where data is written
//              [pbOut]         - where data is written
//              [rVarAllocator] - allocator to use for variable-len data
//
//  History:    8-22-95   dlee   Created
//
//----------------------------------------------------------------------------

void CLargeTable::LokGetOneColumn(
    WORKID                    wid,
    CTableColumn const &      rOutColumn,
    BYTE *                    pbOut,
    PVarAllocator &           rVarAllocator )
{
    CTableWindow *pWindow = (CTableWindow *) _LokFindTableSegment( wid );

    pWindow->LokGetOneColumn( wid, rOutColumn, pbOut, rVarAllocator );
} //LokGetOneColumn

CI_TBL_BMK CLargeTable::_FindNearestDynamicBmk( CTableWindow * pWindow,
                                                 CI_TBL_CHAPT chapter,
                                                 CI_TBL_BMK bookmark )
{
    // If the row corresponding to the bookmark exists in the
    // dynamic state, return the original bookmark.
    // If the row has been deleted from the dynamic state
    // return the bookmark of the next available dynamic row.
    // If you hit the end of the table, return the bookmark
    // of the last row in the dynamic state of the table

    CI_TBL_BMK bmkFound = bookmark;

    if ( pWindow->FindNearestDynamicBmk( chapter, bmkFound ) )
    {
        return bmkFound;
    }

    //
    // Find the closest bookmark to the right of this window.
    //
    CDoubleTableSegIter fwdIter( pWindow );

    for ( _segList.Advance(fwdIter); !_segList.AtEnd(fwdIter);
          _segList.Advance(fwdIter) )
    {
        if ( fwdIter.GetSegment()->IsWindow() )
        {
            CTableWindow * pWindow = fwdIter.GetWindow();
            if ( pWindow->FindFirstNonDeleteDynamicBmk(bmkFound) )
                return bmkFound;
        }
    }

    //
    // Couldn't find anything to the right of this window. Find to the
    // left of the window.
    //
    CDoubleTableSegIter backIter( pWindow );

    for ( _segList.BackUp(backIter); !_segList.AtEnd(backIter);
          _segList.BackUp(backIter) )
    {
        if ( backIter.GetSegment()->IsWindow() )
        {
            CTableWindow * pWindow = backIter.GetWindow();
            if ( pWindow->FindFirstNonDeleteDynamicBmk(bmkFound) )
                return bmkFound;
        }
    }

    //
    // The whole table has been deleted. Just use the WORKID_TBLFIRST
    //
    return WORKID_TBLFIRST;
} //_FindNearestDynamicBmk

//+---------------------------------------------------------------------------
//
//  Member:     CTableSink::SetStatus, public
//
//  Synopsis:   Sets the query status.
//
//  Arguments:  [s] -- The new status
//
//  History:    18-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CTableSink::SetStatus(ULONG s, NTSTATUS sc)
{
    _status = s;

    if (sc != STATUS_SUCCESS)
    {
        Win4Assert( QUERY_FILL_STATUS(s) == STAT_ERROR &&
                    ! NT_SUCCESS(sc) );
        _scStatus = sc;

        tbDebugOut(( DEB_WARN,
                     "tablesink at 0x%x entering 0x%x ERROR state\n",
                     this, sc ));
    }
    else
    {
        Win4Assert( QUERY_FILL_STATUS(s) != STAT_ERROR );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\categ.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       categ.cxx
//
//  Contents:   Unique categorization class
//
//  Classes:    CCategorize
//
//  History:    30 Mar 95   dlee   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>

#include "tabledbg.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CCategorize, public
//
//  Synopsis:   Constructor for categorization class
//
//  Arguments:  [rCatSpec]  -- categorization specification for this level
//              [iSpec]     -- 1-based categorization level, where smaller
//                             numbers are higher in the hierarchy.
//              [pParent]   -- categorization object that categorizes rows
//                             on this level (or 0 if none)
//              [mutex]     -- CAsyncQuery's mutex for serialization
//
//  History:    6-1-95   dlee   Created
//
//  Notes:      Category identifiers start at 0x40000000 plus 0x1000 times
//              [iSpec].  The 0x40000000 is so it is obvious to the
//              debugger that it is a category.  The 0x1000*[iSpec] is
//              so that it is obvious what level a category falls into.
//
//----------------------------------------------------------------------------

CCategorize::CCategorize(
    CCategorizationSpec & rCatSpec,
    unsigned              iSpec,
    CCategorize *         pParent,
    CMutexSem &           mutex)
    : _iSpec(                 iSpec ),
      _pParent(               pParent ),
      _pChild(                0 ),
      _mutex(                 mutex ),
      _iCategoryGen(          0x40000000 + ( 0x1000 * iSpec ) ),
      _widCurrent(            WORKID_TBLBEFOREFIRST ),
      _fNotificationsEnabled( FALSE ),
      _iFindHint(             0 ),
      _aDynamicCategories(    0 ),
      _aVisibleCategories(    16 )
{
    if (rCatSpec.Type() != CATEGORIZE_UNIQUE)
        THROW(CException( E_INVALIDARG ));
} //CCategorize


//+---------------------------------------------------------------------------
//
//  Method:     CCategorize::GetRows, public
//
//  Arguments:  [widStart]    - WORKID identifying first row to be
//                              transferred.  If WORKID_TBLFIRST is
//                              used, the transfer will start at the first
//                              row in the segment.
//              [chapt]       - Chapter from which to fetch rows (if chaptered)
//              [pOutColumns] - A CTableColumnSet that describes the
//                              output format of the data table.
//              [rGetParams]  - An CGetRowsParams structure which
//                              describes how many rows are to be fetched and
//                              other parameters of the operation.
//              [rwidLastRowTransferred] - On return, the work ID of
//                                         the last row to be transferred
//                                         from this table.  Can be used to
//                                         initialize widStart on next call.
//
//  Returns:    SCODE - status of the operation.  DB_S_ENDOFROWSET if
//                      widStart is WORKID_TBLAFTERLAST at start of
//                      transfer, or if rwidLastRowTransferred is the
//                      last row in the segment at the end of the transfer.
//
//                      STATUS_BUFFER_TOO_SMALL is returned if the available
//                      space in the out-of-line data was exhausted during
//                      the transfer.
//
//  Notes:      To transfer successive rows, as in GetNextRows, the
//              rwidLastRowTransferred must be advanced by one prior
//              to the next transfer.
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetRows(
    HWATCHREGION            hRegion,
    WORKID                  widStart,
    CI_TBL_CHAPT            chapt,
    CTableColumnSet const & rOutColumns,
    CGetRowsParams &        rGetParams,
    WORKID &                rwidLastRowTransferred)
{
    SCODE sc = S_OK;

    TRY
    {
        if (WORKID_TBLAFTERLAST == widStart)
        {
            rwidLastRowTransferred = WORKID_TBLAFTERLAST;
            return DB_S_ENDOFROWSET;
        }
        else if (widInvalid == widStart)
        {
            Win4Assert(! "CCategorize::GetRows widStart is widInvalid");
            return E_FAIL;
        }
        else
        {
            CLock lock( _mutex );

            if ( 0 == _aVisibleCategories.Count() )
                sc = DB_S_ENDOFROWSET;
            else
            {
                unsigned iRow;
                if ( widStart != WORKID_TBLFIRST &&
                     widStart != WORKID_TBLBEFOREFIRST )
                    iRow = _FindCategory( widStart );
                else
                    iRow = 0;

                rwidLastRowTransferred = 0;

                while ( 0 != rGetParams.RowsToTransfer() &&
                        iRow < _aVisibleCategories.Count() )
                {
                    // at the end of the chapter when this level is categorized?

                    if ( ( _isCategorized() ) &&
                         ( DB_NULL_HCHAPTER != chapt ) &&
                         ( _aVisibleCategories[ iRow ].catParent != chapt ) )
                        break; // code below will set sc = DB_S_ENDOFROWSET

                    BYTE* pbDst = (BYTE *) rGetParams.GetRowBuffer();

                    for ( unsigned col = 0; col < rOutColumns.Count(); col++ )
                    {
                        CTableColumn const & rDstColumn = *rOutColumns.Get(col);
                        PROPID pid = rDstColumn.GetPropId();

                        if ( pidChapter == pid || pidWorkId  == pid )
                        {
                            if (rDstColumn.GetStoredType() == VT_VARIANT)
                            {
                                Win4Assert( rDstColumn.GetValueSize() == sizeof VARIANT );
                                CTableVariant * pVarnt = (CTableVariant *) ( pbDst +
                                                         rDstColumn.GetValueOffset() );
                                pVarnt->vt = VT_UI4;
                                pVarnt->ulVal = _aVisibleCategories[iRow].catID;
                            }
                            else
                            {
                                Win4Assert( rDstColumn.GetValueSize() == sizeof CI_TBL_CHAPT );
                                RtlCopyMemory( pbDst + rDstColumn.GetValueOffset(),
                                               &( _aVisibleCategories[iRow].catID),
                                               sizeof CI_TBL_CHAPT );
                            }
                            rDstColumn.SetStatus( pbDst, CTableColumn::StoreStatusOK );
                            rDstColumn.SetStatus( pbDst, CTableColumn::StoreStatusOK );
                        }
                        else
                        {
                            _pChild->LokGetOneColumn( _aVisibleCategories[iRow].widFirst,
                                                      rDstColumn,
                                                      pbDst,
                                                      rGetParams.GetVarAllocator() );
                        }
                    }

                    rwidLastRowTransferred = _aVisibleCategories[iRow].catID;
                    rGetParams.IncrementRowCount();

                    if ( rGetParams.GetFwdFetch() )
                        iRow++;
                    else
                    {
                        if (iRow == 0)
                            break;
                        iRow--;
                    }
                }

                // If we didn't transfer as many rows as requested, we must
                // have run into the end of the table or chapter.

                if ( rGetParams.RowsToTransfer() > 0 )
                {
                    if ( 0 == rGetParams.RowsTransferred() )
                        sc = DB_E_BADSTARTPOSITION;
                    else
                        sc = DB_S_ENDOFROWSET;
                }
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        Win4Assert( E_OUTOFMEMORY == sc ||
                    STATUS_BUFFER_TOO_SMALL == sc ); // benign?

        if ( E_OUTOFMEMORY == sc && rGetParams.RowsTransferred() > 0)
            sc = DB_S_BLOCKLIMITEDROWS;
    }
    END_CATCH;

    return sc;
} //GetRows

//+-------------------------------------------------------------------------
//
//  Member:     CCategorize::RestartPosition, public
//
//  Synopsis:   Set next fetch position for the chapter to the start
//
//  Arguments:  [chapt]    - Chapter from which to fetch rows (if chaptered)
//
//  Returns:    SCODE - status of the operation.
//
//--------------------------------------------------------------------------

void       CCategorize::RestartPosition(
    CI_TBL_CHAPT           chapt)
{
    SetCurrentPosition( chapt, WORKID_TBLBEFOREFIRST );
    CTableSource::RestartPosition( chapt );
}


//+---------------------------------------------------------------------------
//
//  Method:     LocateRelativeRow, public
//
//  Synopsis:   Finds a row in the category table.  Since there is only one
//              category segment, we are almost assured of finding the row.
//
//  Arguments:  [widStart]       -- where to start the locate
//              [chapt]          -- parent chapter in which to do the locate
//              [cRowsToMove]    -- rows to skip after [widStart]
//              [rwidRowOut]     -- wid found after locate
//              [rcRowsResidual] -- number of rows left over -- will be 0
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::LocateRelativeRow(
    WORKID          widStart,
    CI_TBL_CHAPT    chapt,
    DBROWOFFSET     cRowsToMove,
    WORKID &        rwidRowOut,
    DBROWOFFSET &   rcRowsResidual)
{
    CLock lock( _mutex );

    if ( widStart == WORKID_TBLBEFOREFIRST && cRowsToMove > 0 )
    {
        widStart = WORKID_TBLFIRST;
        cRowsToMove--;
    }
    else if ( widStart == WORKID_TBLAFTERLAST && cRowsToMove < 0 )
    {
        widStart = WORKID_TBLLAST;
        cRowsToMove++;
    }
    else if ( WORKID_TBLAFTERLAST   == widStart ||
              WORKID_TBLBEFOREFIRST == widStart )
    {
        rwidRowOut = widStart;
        rcRowsResidual = cRowsToMove;
        return S_OK;
    }

    ULONG iRow;

    if ( WORKID_TBLFIRST == widStart )
    {
        if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
            iRow = _FindCategory( _pParent->GetFirstWorkid( chapt ) );
        else
            iRow = 0;
    }
    else if ( WORKID_TBLLAST == widStart )
    {
        if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
        {
            iRow = _FindCategory( _pParent->GetFirstWorkid( chapt ) );
            iRow += _pParent->GetRowCount( chapt );
        }
        else
        {
            iRow = _aVisibleCategories.Count();
        }

        iRow--;
    }
    else
    {
        iRow = _FindCategory( widStart );
    }

    rcRowsResidual = cRowsToMove + iRow;

    if (rcRowsResidual < 0)
    {
        rwidRowOut = WORKID_TBLBEFOREFIRST;
        tbDebugOut(( DEB_ITRACE,
                     "category table LocateRelativeRow off beginning of table\n" ));
    }
    else if ( (ULONG) rcRowsResidual >= _aVisibleCategories.Count() )
    {
        rwidRowOut = WORKID_TBLAFTERLAST;
        rcRowsResidual -= _aVisibleCategories.Count();

        tbDebugOut(( DEB_ITRACE,
                     "category table LocateRelativeRow off end of table\n" ));
    }
    else
    {
        rwidRowOut = (WORKID) _aVisibleCategories[ (unsigned) rcRowsResidual ].catID;
        rcRowsResidual = 0;
    }

    return S_OK;
} //LocateRelativeRow

//+---------------------------------------------------------------------------
//
//  Method:     CCategorize::LokAssignCategory, public
//
//  Synopsis:   Assigns a category to a row in a lower level, then calls
//              the parent categorizer to re-categorize the row's category
//              if there is a parent.
//
//  Arguments:  [prm]  -- category parameters.  See tblsink.hxx for more
//                        info about this object.
//
//  History:    6-1-95   dlee   Created
//
//  Notes:      No need to grab the CAsyncQuery lock -- bigtable grabs it
//              up front in PutRow.
//
//----------------------------------------------------------------------------

unsigned CCategorize::LokAssignCategory(
    CCategParams & prm)
{
    unsigned category = chaptInvalid;
    unsigned iEntry = 0xffffffff;

    CDynArrayInPlace<CCategory> & array = _WritableArray();

    if ( widInvalid != prm.widPrev &&
         widInvalid != prm.widNext &&
         prm.catPrev == prm.catNext )
    {
        // new row is between two rows of the same category
        // no need to call parent categorizer -- just return

        _IncrementRowCount( prm.catPrev );
        return prm.catPrev;
    }
    else if ( widInvalid == prm.widPrev &&
              widInvalid == prm.widNext )
    {
        // first row we've ever seen

        Win4Assert( 0 == array.Count() );
        CCategory cat( prm.widRow );
        array[ 0 ] = cat;
        category = _GenCategory();
        array[ 0 ].catID = category;
        iEntry = 0;
    }
    else if ( widInvalid == prm.widPrev )
    {
        // new first row in the next row's category or a new category

        if ( prm.icmpNext > _iSpec )
        {
            // new first row in this (the next row's) category

            category = prm.catNext;
            iEntry = _FindWritableCategory( category );
            array[ iEntry ].widFirst = prm.widRow;
            array[ iEntry ].cRows++;

            return category;
        }
        else
        {
            // insert new category before the next category

            iEntry = _FindWritableCategory( prm.catNext );
            category = _InsertNewCategory( prm.widRow, iEntry );
        }
    }
    else if ( widInvalid == prm.widNext )
    {
        // new category OR
        // new element in previous row's category

        if ( prm.icmpPrev <= _iSpec )
        {
            // new category after previous (may be an insert operation).
            // just because widNext is invalid doesn't mean it doesn't exist.

            iEntry = 1 + _FindWritableCategory( prm.catPrev );
            category = _InsertNewCategory( prm.widRow, iEntry );
        }
        else
        {
            // new element in previous row's category

            _IncrementRowCount( prm.catPrev );
            return prm.catPrev;
        }
    }
    else
    {
        // good rows on either side in different categories, one of either:
        //     new member of previous row's category       OR
        //     new first member of next rows's category    OR
        //     new category

        if ( prm.icmpPrev > _iSpec )
        {
            // new member of previous row's category

            _IncrementRowCount( prm.catPrev );
            return prm.catPrev;
        }
        else if ( prm.icmpNext > _iSpec )
        {
            // new first member of next rows's category

            iEntry = _FindWritableCategory( prm.catNext );

            array[ iEntry ].widFirst = prm.widRow;
            array[ iEntry ].cRows++;

            return prm.catNext;
        }
        else
        {
            // new category

            iEntry = _FindWritableCategory( prm.catNext ) ;
            category = _InsertNewCategory( prm.widRow, iEntry );
        }
    }

    // Not all cases above get to this point.  Several return early if
    // there is no way a parent would care about the operation.

    if ( _isCategorized() )
    {
        Win4Assert( category != chaptInvalid );
        Win4Assert( iEntry != 0xffffffff );

        // Get the parent category.  Use a different CCategParams so original
        // is intact.

        CCategParams prnt = prm;
        prnt.widRow = category;

        if ( 0 == iEntry )
            prnt.widPrev = widInvalid;
        else
        {
            prnt.widPrev = array[ iEntry - 1 ].catID;
            prnt.catPrev = array[ iEntry - 1 ].catParent;
        }

        if ( iEntry < ( array.Count() - 1 ) )
        {
            prnt.widNext = array[ iEntry + 1 ].catID;
            prnt.catNext = array[ iEntry + 1 ].catParent;
        }
        else
            prnt.widNext = widInvalid;

        array[ iEntry ].catParent = _pParent->LokAssignCategory( prnt );
    }

    return category;
} //LokAssignCategory

//+---------------------------------------------------------------------------
//
//  Method:     _FindCategory, private
//
//  Synopsis:   Finds a category in the category array
//
//  Arguments:  [cat]  -- category
//
//  Returns:    index into the category array
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

unsigned CCategorize::_FindCategory(
    CI_TBL_CHAPT cat )
{
    unsigned cCategories = _aVisibleCategories.Count();

    // first try the hint and the hint + 1

    if ( _iFindHint < cCategories )
    {
        if ( cat == _aVisibleCategories[ _iFindHint ].catID )
            return _iFindHint;

        unsigned iHintPlus = _iFindHint + 1;

        if ( ( iHintPlus < cCategories ) &&
             ( cat == _aVisibleCategories[ iHintPlus ].catID ) )
        {
            _iFindHint++;
            return _iFindHint;
        }
    }

    // linear search for the category

    for ( unsigned i = 0; i < cCategories; i++ )
    {
        if ( cat == _aVisibleCategories[ i ].catID )
        {
            _iFindHint = i;
            return i;
        }
    }

    THROW( CException( DB_E_BADCHAPTER ) );
    return 0;
} //_FindCategory

//+---------------------------------------------------------------------------
//
//  Method:     _FindWritableCategory, private
//
//  Synopsis:   Finds a category in the updatable category array
//
//  Arguments:  [cat]  -- category
//
//  Returns:    index into the category array
//
//  History:    6-1-95   dlee   Created
//
//  PERFPERF:   Linear search -- we may want to put a hash table over this.
//              How many categories do we expect?
//              Another alternative is to cache the last array entry
//              referenced and use it and the prev/next entries as first
//              guesses.
//
//----------------------------------------------------------------------------

unsigned CCategorize::_FindWritableCategory(
    CI_TBL_CHAPT cat )
{
    CDynArrayInPlace<CCategory> & array = _WritableArray();

    for ( unsigned i = 0; i < array.Count(); i++ )
        if ( cat == array[ i ].catID )
            return i;

    Win4Assert( !"_FindWritableCategory failed" );
    THROW( CException( DB_E_BADCHAPTER ) );
    return 0;
} //_FindWritableCategory

//+---------------------------------------------------------------------------
//
//  Method:     GetRowsAt, public
//
//  Synopsis:   Retrieves rows at a specified location
//
//  Arguments:  [widStart]    -- where to start retrieving rows
//              [chapt]       -- in which rows are retrieved
//              [cRowsToMove] -- offset from widStart
//              [rOutColumns] -- description of output columns
//              [rGetParams]  -- info about the get operation
//              [rwidLastRowTransferred] -- last row retrieved
//
//  Returns:    SCODE
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetRowsAt(
    HWATCHREGION     hRegion,
    WORKID           widStart,
    CI_TBL_CHAPT     chapt,
    DBROWOFFSET      cRowsToMove,
    CTableColumnSet  const & rOutColumns,
    CGetRowsParams & rGetParams,
    WORKID &         rwidLastRowTransferred )
{
    CLock lock( _mutex );

    DBROWOFFSET cRowsResidual;

    SCODE scRet = LocateRelativeRow( widStart,
                                     chapt,
                                     cRowsToMove,
                                     widStart,
                                     cRowsResidual);

    Win4Assert( !FAILED( scRet ) );

    if ( cRowsResidual )
    {
        Win4Assert ( WORKID_TBLAFTERLAST   == widStart ||
                     WORKID_TBLBEFOREFIRST == widStart );
        return DB_E_BADSTARTPOSITION;
    }

    scRet = GetRows( hRegion,
                     widStart,
                     chapt,
                     rOutColumns,
                     rGetParams,
                     rwidLastRowTransferred);
    return scRet;
} //GetRowsAt

//+---------------------------------------------------------------------------
//
//  Method:     GetRowsAtRatio, public
//
//  Synopsis:   Retrieves rows at a specified location.  Nothing fuzzy about
//              this -- they're all in memory so be as exact as possible.
//
//  Arguments:  [num]         -- numerator of starting point fraction
//              [denom]       -- denominator of starting point fraction
//              [chapt]       -- in which rows are retrieved
//              [rOutColumns] -- description of output columns
//              [rGetParams]  -- info about the get operation
//              [rwidLastRowTransferred] -- last row retrieved
//
//  Returns:    SCODE
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetRowsAtRatio(
    HWATCHREGION            hRegion,
    ULONG                   num,
    ULONG                   denom,
    CI_TBL_CHAPT            chapt,
    CTableColumnSet const & rOutColumns,
    CGetRowsParams &        rGetParams,
    WORKID &                rwidLastRowTransferred )
{
    CLock lock( _mutex );

    if ( 0 == denom || num > denom )
        QUIETTHROW( CException(DB_E_BADRATIO) );

    ULONG cRows;
    if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
        cRows = _pParent->GetRowCount( chapt );
    else
        cRows = _aVisibleCategories.Count();

    ULONG cRowsFromFront = (ULONG) ( ( (unsigned _int64) num *
                                       (unsigned _int64) cRows ) /
                                     ( unsigned _int64 ) denom );

    if ( cRowsFromFront == cRows )
    {
        // The user is asking to retrieve past the end of table.

        rwidLastRowTransferred = WORKID_TBLAFTERLAST;
        return DB_S_ENDOFROWSET;
    }

    return GetRowsAt( hRegion, WORKID_TBLFIRST, chapt, (LONG) cRowsFromFront,
                      rOutColumns, rGetParams, rwidLastRowTransferred );
} //GetRowsAtRatio

//+---------------------------------------------------------------------------
//
//  Method:     RemoveRow, public
//
//  Synopsis:   Removes a row from the categorization
//
//  Arguments:  [chapt]     -- of row being removed
//              [wid]       -- of removed row in categorized child table
//              [widNext]   -- of row following removed row
//
//  History:    6-1-95   dlee   Created
//
//----------------------------------------------------------------------------

void CCategorize::RemoveRow(
    CI_TBL_CHAPT   chapt,
    WORKID         wid,
    WORKID         widNext )
{
    CLock lock( _mutex );

    CDynArrayInPlace<CCategory> & array = _WritableArray();

    unsigned iEntry = _FindWritableCategory( chapt );
    array[ iEntry ].cRows--;

    if ( 0 == array[ iEntry ].cRows )
    {
        // in case we need parent category later, save it

        unsigned catParent = array[ iEntry ].catParent;

        // last member of category -- remove the category

        array.Remove( iEntry );

        if ( _isCategorized() )
        {
           // notify the parent that a row was deleted

            WORKID widNextCategory;
            if ( ( 0 == array.Count() ) ||
                 ( iEntry >= ( array.Count() - 1) ) )
                widNextCategory = widInvalid;
            else
                widNextCategory = array[ iEntry ].catID;

            _pParent->RemoveRow( catParent,
                                 chapt,
                                 widNextCategory );
        }
    }
    else if ( array[ iEntry ].widFirst == wid )
    {
        // new first member of the category

        array[ iEntry ].widFirst = widNext;

        // removed the GetNextRows() current position row -- fixup

        if ( array[ iEntry ].widGetNextRowsPos == wid )
            array[ iEntry ].widGetNextRowsPos = widNext;
    }
} //RemoveRow

//+---------------------------------------------------------------------------
//
//  Method:     GetApproximatePosition, public
//
//  Synopsis:   Returns the offset of a bookmark in the table/chapter and
//              the number of rows in that table/chapter
//
//  Arguments:  [chapt]   -- of row being queried
//              [bmk]     -- of row being queried
//              [piRow]   -- returns index of row in table/chapter
//              [pcRows]  -- returns count of rows in table/chapter
//
//  History:    6-29-95   dlee   Created
//
//----------------------------------------------------------------------------

SCODE CCategorize::GetApproximatePosition(
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmk,
    DBCOUNTITEM * piRow,
    DBCOUNTITEM * pcRows )
{
    CLock lock( _mutex );

    if (bmk == widInvalid)
        return DB_E_BADBOOKMARK;

    Win4Assert( bmk != WORKID_TBLBEFOREFIRST && bmk != WORKID_TBLAFTERLAST );

    DBCOUNTITEM iBmkPos = ULONG_MAX, cRows = 0;

    if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
        cRows = _pParent->GetRowCount( chapt );
    else
        cRows = _aVisibleCategories.Count();

    if ( WORKID_TBLFIRST == bmk )
        iBmkPos = cRows ? 1 : 0;
    else if ( WORKID_TBLLAST == bmk )
        iBmkPos = cRows;
    else
    {
        iBmkPos = _FindCategory( bmk ) + 1;

        // position is relative to first member of the category (if any)

        if ( _isCategorized() && DB_NULL_HCHAPTER != chapt )
            iBmkPos -= _FindCategory( _pParent->GetFirstWorkid( chapt ) );
    }

    Win4Assert(iBmkPos <= cRows);

    *piRow = iBmkPos;
    *pcRows = cRows;

    return S_OK;
} //GetApproximatePosition

//+---------------------------------------------------------------------------
//
//  Method:     LokGetOneColumn, public
//
//  Synopsis:   Returns column data for the first item in a category.
//
//  Arguments:  [wid]        -- workid or chapter of the row to be queried
//              [rOutColumn] -- layout of the output data
//              [pbOut]      -- where to write the column data
//              [rVarAlloc]  -- variable data allocator to use
//
//  History:    22-Aug-95   dlee   Created
//
//----------------------------------------------------------------------------

void CCategorize::LokGetOneColumn(
    WORKID                    wid,
    CTableColumn const &      rOutColumn,
    BYTE *                    pbOut,
    PVarAllocator &           rVarAlloc )
{
    unsigned iRow = _FindCategory( wid );

    _pChild->LokGetOneColumn( _aVisibleCategories[iRow].widFirst,
                              rOutColumn,
                              pbOut,
                              rVarAlloc );
} //LokGetOneColumn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\colhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       colhash.cxx
//
//  Contents:   Hash table compressions for large tables.
//
//  Classes:    CCompressedColHash
//
//  Functions:  GuidHash - Hash function for GUIDs
//
//  History:    13 Apr 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <objcur.hxx>
#include <tblvarnt.hxx>

#include "tabledbg.hxx"
#include "colcompr.hxx"


const USHORT MAX_HASH_TABLE_SIZE = 32767;     // Maximum hash table size

//+-------------------------------------------------------------------------
//
//  Function:   GuidHash, public
//
//  Synopsis:   Hash a GUID value for use in a hash table.
//
//  Arguments:  [pbData] - pointer to the value to be hashed.
//              [cbData] - should be sizeof (GUID), unused
//
//  Returns:    ULONG - Hash value for the input GUID
//
//  Notes:      The hash function just xors a few selected fields out
//              of the GUID structure.  It is intended to work well for
//              both generated GUIDs (from UuidCreate) and administratively
//              assigned GUIDs like OLE IIDs and CLSIDs.
//
//--------------------------------------------------------------------------

ULONG GuidHash(
    BYTE *pbData,
    USHORT cbData
) {
    UNALIGNED GUID *pGuid = (GUID *)pbData;
    return (pGuid->Data1 ^
            (pGuid->Data4[0]<<16) ^
            (pGuid->Data4[6]<<8) ^
            (pGuid->Data4[7]));
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::DefaultHash, public static
//
//  Synopsis:   Generic hash function
//
//  Arguments:  [pbData] - pointer to the value to be hashed.
//              [cbData] - size of pbData
//
//  Returns:    ULONG - Hash value for the input data
//
//--------------------------------------------------------------------------

//static
ULONG CCompressedColHash::DefaultHash(
    BYTE *pbData,
    USHORT cbData
) {
    ULONG ulRet = cbData;

    while (cbData--)
        ulRet = (ulRet<<1) ^ *pbData++;

    return ulRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::CCompressedColHash, public
//
//  Synopsis:   Constructor for a hash compressed column.
//
//  Arguments:  [vtData] - type of each data item
//              [cbDataWidth] - size of each data item
//              [pfnHashFunction] - pointer to hash function
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.
//
//  Notes:
//
//--------------------------------------------------------------------------


CCompressedColHash::CCompressedColHash(
    VARTYPE     vtData,
    USHORT      cbDataWidth,
    PFNHASH     pfnHashFunction) :
        CCompressedCol(
            vtData,                     // DataType
            sizeof (HASHKEY),           // _cbKeyWidth
            CCompressedCol::FixedHash   // _CompressionType
        ),

        _cbDataWidth(cbDataWidth),
        _pfnHash(pfnHashFunction),
        _pHashTable(NULL), _cHashEntries(0),
        _pDataItems(NULL), _cDataItems(0),
        _fGrowthInProgress(FALSE),
        _pData(NULL), _cbData(0),
        _ulMemCounter(0)
{

}


CCompressedColHash::~CCompressedColHash( )
{
    if (_pData) {
        TblPageDealloc(_pData, _ulMemCounter);
        _pData = NULL;
        _cbData = 0;
    }
    Win4Assert(_ulMemCounter == 0);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::AddData, public
//
//  Synopsis:   Add a data entry to the hash table if it is not
//              already there.
//
//  Arguments:  [pVarnt] - pointer to data item
//              [pKey] - pointer to lookup key value
//              [reIndicator] - returns an indicator variable for
//                      problems
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.  reIndicator is filled with an indication
//              of problems.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHash::AddData(
    PROPVARIANT const * const pVarnt,
    ULONG* pKey,
    GetValueResult& reIndicator
) {
    //
    //  Specially handle the VT_EMPTY case
    //
    if (pVarnt->vt == VT_EMPTY) {
        *pKey = 0;
        reIndicator = GVRSuccess;
        return;
    }

    CTableVariant *pVar = (CTableVariant *)pVarnt;
    Win4Assert(pVarnt->vt == DataType);

    BYTE *pbData ;
    USHORT cbData = (USHORT) pVar->VarDataSize();

    Win4Assert(cbData && cbData == _cbDataWidth);
    if (pVar->VariantPointerInFirstWord( )) {
        pbData = (BYTE *) pVar->pszVal;
    } else {
        Win4Assert(pVar->VariantPointerInSecondWord( ));
        pbData = (BYTE *) pVar->blob.pBlobData;
    }

    _AddData(pbData, cbData, pKey);
    reIndicator = GVRSuccess;
    return;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::_AddData, protected
//
//  Synopsis:   Helper for the public AddData method.  Adds
//              a data entry to the hash table (if it does not already
//              exist).
//
//  Arguments:  [pbData] - pointer to data item
//              [cbDataSize] - size of data item
//              [pKey] - pointer to lookup key value
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHash::_AddData(
    BYTE *pbData,
    USHORT cbDataSize,
    ULONG* pKey
) {
    Win4Assert(cbDataSize == _cbDataWidth);

    if (_pData == NULL) {
        _GrowHashTable();
    }

    ULONG ulHash = _pfnHash(pbData, cbDataSize);

    ulHash %= _cHashEntries;

    HASHKEY* pusHashChain = &_pHashTable[ulHash];
    HASHKEY* pusNextData;
    USHORT cChainLength = 0;

    while (*pusHashChain != 0) {
        cChainLength++;
        pusNextData = _IndexHashkey( *pusHashChain );

        if (memcmp((BYTE *) (pusNextData+1), pbData, cbDataSize) == 0) {
            //
            //  Found the data item.  Return its index.
            //
            *pKey = *pusHashChain;
            return;
        }
        pusHashChain = pusNextData;
    }
    if (cChainLength > _maxChain)
        _maxChain = cChainLength;

    pusNextData = (HASHKEY *) ((BYTE *)_pDataItems +
                    (_cDataItems) * (sizeof (HASHKEY) + _cbDataWidth));
    if (((BYTE*)pusNextData + (sizeof (HASHKEY) + _cbDataWidth) -
        (BYTE *)_pData) > (int) _cbData ||
        (_cDataItems > (ULONG) ( _cHashEntries * 3 ) &&
         _cHashEntries < MAX_HASH_TABLE_SIZE &&
         !_fGrowthInProgress)) {

        //
        //  The new data will not fit in the table, or the hash chains will
        //  be too long.  Grow the table, then recurse.  The table may be
        //  rehashed, and can be moved when grown, so the lookup we've
        //  already done may be invalid.
        //
        _GrowHashTable();
        _AddData(pbData, cbDataSize, pKey);
        return;
    }

    //
    //  Now add the new data item.  The data item consists of a USHORT
    //  for the hash chain, followed by the buffer for the fixed size
    //  data item.
    //

    *pKey = *pusHashChain = ++_cDataItems;
    Win4Assert(_cDataItems != 0);               // check for overflow
    *pusNextData++ = 0;
    RtlCopyMemory((BYTE *)pusNextData, pbData, _cbDataWidth);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::_Rehash, protected
//
//  Synopsis:   Helper function for the _GrowHashTable method.
//              reinserts an existing item into the hash table.
//
//  Arguments:  [pbData] - pointer to data item
//              [kData] - index to the data item in the table
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHash::_Rehash(
    HASHKEY kData,
    BYTE *pbData
) {
    Win4Assert(_pData != NULL && kData > 0 && kData <= _cDataItems);

    ULONG ulHash = _pfnHash(pbData, _cbDataWidth);

    ulHash %= _cHashEntries;

    HASHKEY* pusHashChain = &_pHashTable[ulHash];
    HASHKEY* pusNextData;
    USHORT cChainLength = 0;

    while (*pusHashChain != 0) {
        cChainLength++;
        pusNextData = _IndexHashkey( *pusHashChain );
        pusHashChain = pusNextData;
    }
    if (cChainLength > _maxChain)
        _maxChain = cChainLength;

    pusNextData = _IndexHashkey( kData );

    //
    //  Now add the data item to the hash chain.
    //

    *pusHashChain = kData;
    *pusNextData++ = 0;
    Win4Assert((BYTE*)pusNextData == pbData);
    return;
}



//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::GetData, public
//
//  Synopsis:   Retrieve a value from the hash table.
//
//  Arguments:  [pVarnt] - pointer to variant in which to return the data
//              [PreferredType] - Peferred data type
//              [ulKey] - the lookup key value
//              [PropId] - (unused) property id being retrieved.
//
//  Returns:    pVarnt is filled with the result of the lookup.
//
//  Notes:      The PreferredType expresses the caller's preference only.
//              This method is free to return whatever type is most
//              convenient.
//
//              The returned data does not conform to any alignment
//              restrictions on the data.
//
//--------------------------------------------------------------------------

GetValueResult  CCompressedColHash::GetData(
    PROPVARIANT * pVarnt,
    VARTYPE PreferredType,
    ULONG ulKey,
    PROPID PropId
) {
    CTableVariant *pVar = (CTableVariant *)pVarnt;
    Win4Assert(PreferredType == DataType && ulKey >= 1 && ulKey <= _cDataItems);

    if (ulKey >= 1 && ulKey <= _cDataItems) {
        pVarnt->vt = DataType;

        BYTE *pbData = ((BYTE *)_pDataItems +
                        (ulKey-1) * (sizeof (HASHKEY) + _cbDataWidth)) +
                        sizeof (HASHKEY);

        if (pVar->VariantPointerInFirstWord( )) {
            pVar->pszVal = (CHAR*)pbData;
        } else {
            Win4Assert(pVar->VariantPointerInSecondWord( ));
            pVar->blob.pBlobData = pbData;
        }
        return GVRSuccess;
    } else {
        pVarnt->vt = VT_EMPTY;
        return GVRNotAvailable;
    }
}

void    CCompressedColHash::FreeVariant(PROPVARIANT * pvarnt) { }



//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHash::_GrowHashTable, protected
//
//  Synopsis:   Grow the space allocated to the hash table and data
//              items.
//
//  Arguments:  - none -
//
//  Returns:    Nothing
//
//  Notes:      Also called to allocate the initial data area.
//
//              The number of hash buckets starts out at a low
//              number, then is increased as the amount of data
//              grows.  Data items must be rehashed when this occurs.
//              Since items are identified by their offset in the
//              data array, this must not change while rehashing.
//
//--------------------------------------------------------------------------

const unsigned MIN_HASH_TABLE_SIZE = 11;        // Minimum hash table size


inline USHORT CCompressedColHash::_NextHashSize(
    HASHKEY cItems,
    USHORT cHash
) {
    do {
        cHash = cHash*2 + 1;
    } while (cHash < _cDataItems);
    return  (cHash < MAX_HASH_TABLE_SIZE) ? cHash : MAX_HASH_TABLE_SIZE;
}


VOID CCompressedColHash::_GrowHashTable( void )
{
    ULONG cbSize;
    USHORT cNewHashEntries;
    int fRehash = FALSE;

    Win4Assert(!_fGrowthInProgress &&
             "Recursive call to CCompressedColHash::_GrowHashTable");

    _fGrowthInProgress = TRUE;
    if (_pData == NULL) {
        cNewHashEntries = MIN_HASH_TABLE_SIZE;
    } else if (_cHashEntries < MAX_HASH_TABLE_SIZE &&
               (_cDataItems > (ULONG) _cHashEntries*2 ||
                (_cDataItems > _cHashEntries && _maxChain > 3))) {
        cNewHashEntries = _NextHashSize(_cDataItems, _cHashEntries);
        fRehash = TRUE;
        tbDebugOut((DEB_ITRACE, "Growing hash table, old,new sizes = %d,%d\n",
                                        _cHashEntries, cNewHashEntries));
    }

    //
    //  Compute the required size of the hash table and data
    //
    cbSize = _cHashEntries * sizeof(HASHKEY);
    cbSize += (_cDataItems + 4) * (_cbDataWidth + sizeof (HASHKEY));
    cbSize = TblPageGrowSize(cbSize, TRUE);
    Win4Assert(cbSize > _cbData || (fRehash && cbSize == _cbData));

    BYTE *pbNewData;

    if (_pData && cbSize < TBL_PAGE_MAX_SEGMENT_SIZE) {
        pbNewData = (BYTE *)
            TblPageRealloc(_pData, _ulMemCounter, cbSize, 0);
    } else {
        pbNewData =
            (BYTE *)TblPageAlloc(cbSize, _ulMemCounter, TBL_SIG_COMPRESSED);
    }

    tbDebugOut((DEB_ITRACE, "New hash table at = %x\n", pbNewData));

    if (_pData != NULL && !fRehash) {
        if (_pData != pbNewData) {
            RtlCopyMemory(pbNewData, _pData, _cbData);
            TblPageDealloc(_pData, _ulMemCounter, _cbData);
            _pData = pbNewData;
        }
        _cbData = cbSize;
        _pHashTable = (HASHKEY *) _pData;
        _pDataItems = (BYTE *) (_pHashTable + _cHashEntries);
    } else {
        BYTE *pOldDataItems = _pDataItems;
        VOID *pOldData = _pData;
        ULONG cbOldSize = _cbData;

        _pData = pbNewData;
        _cbData = cbSize;
        _pHashTable = (HASHKEY *)_pData;
        _cHashEntries = cNewHashEntries;
        _pDataItems = (BYTE *) (_pHashTable + _cHashEntries);
        if (pOldData != NULL)
            RtlMoveMemory(_pDataItems,
                          pOldDataItems,
                          _cDataItems * (sizeof (HASHKEY) + _cbDataWidth));
        RtlZeroMemory(_pHashTable, cNewHashEntries * sizeof (HASHKEY));
        _maxChain = 0;

        //
        //  Now re-add all old data items to the hash table.
        //
        pOldDataItems = _pDataItems;
        for (HASHKEY i=1; i<=_cDataItems; i++) {
            pOldDataItems += sizeof (HASHKEY);  // skip hash chain
            _Rehash(i, pOldDataItems);
            pOldDataItems += _cbDataWidth;      // skip data item
        }
        if (pOldData != NULL && pOldData != _pData)
            TblPageDealloc(pOldData, _ulMemCounter, cbOldSize);
    }

    _fGrowthInProgress = FALSE;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   _ClearAll
//
//  Synopsis:   Method clears all the data in the "fixed width" part of the
//              memory buffer.
//
//  Arguments:  (none)
//
//  History:    12-16-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCompressedColHash::_ClearAll()
{
    RtlZeroMemory(_pHashTable, _cHashEntries * sizeof (HASHKEY));
    RtlZeroMemory(_pDataItems, _cDataItems * _cbDataWidth );
    _cDataItems = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\colmastr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       colmastr.cxx
//
//  Contents:   Classes dealing with the table master column description.
//
//  Classes:    CColumnMasterDesc - A master column description
//              CColumnMasterArray - A simple array of master columns
//              CColumnMasterSet - An managed set of master columns
//
//  Functions:
//
//  History:    28 Feb 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tablecol.hxx>
#include <coldesc.hxx>

#include "tabledbg.hxx"
#include "colcompr.hxx"
#include "propdata.hxx"

//
//  Generate the implementation of the master set base class
//
IMPL_DYNARRAY( CColumnMasterArray, CColumnMasterDesc )


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::CColumnMasterSet, public
//
//  Synopsis:   Constructor for a master column set.
//
//  Arguments:  [pcol] -- A description of the initial output column set
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterSet::CColumnMasterSet( const CColumnSet * const pcol )
        : _iNextFree( 0 ),
          _aMasterCol( pcol->Size() ),
          _fHasUserProp( FALSE )
{
    for (unsigned iCol = 0; iCol< pcol->Size(); iCol++)
    {
        PROPID pid = pcol->Get(iCol);

        if ( IsUserDefinedPid( pid ) )
            _fHasUserProp = TRUE;

        CColumnMasterDesc MasterCol( pid );

        Add( MasterCol );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::Find, private
//
//  Synopsis:   Find a master column description in a master column set.
//
//  Arguments:  [propid] -- The property ID of the column to be located
//              [riPos] -- If found, returns the position of the column
//                      description in the dynamic array.
//
//  Returns:    CColumnMasterDesc* - a pointer to the master column
//                      description if found, otherwise NULL
//
//  Notes:
//
//--------------------------------------------------------------------------

inline CColumnMasterDesc *
CColumnMasterSet::Find( const PROPID propid, unsigned& riCol )
{
    Win4Assert(_iNextFree <= Size());

    for (riCol = 0; riCol < _iNextFree; riCol++) {
        if (_aMasterCol.Get(riCol)->PropId  == propid)
            return _aMasterCol.Get(riCol);
    }
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::Find, public
//
//  Synopsis:   Find a master column description in a master column set.
//
//  Arguments:  [propid] -- The property ID of the column to be located
//
//  Returns:    CColumnMasterDesc* - a pointer to the master column
//                      description if found, otherwise NULL
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc*
CColumnMasterSet::Find( const PROPID propid )
{
    unsigned iCol;

    return Find(propid, iCol);
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterSet::Add, public
//
//  Synopsis:   Add a master column description to a master column set.
//
//  Arguments:  [xpNewCol] -- A reference to the column description to be
//                      added.
//
//  Returns:    CColumnMasterDesc* - a pointer to the master column
//                      description added
//
//  Notes:      If a property description with the same property ID
//              is already in the column set, the new column is not
//              added, but the previous column is used.
//
//--------------------------------------------------------------------------

CColumnMasterDesc*
CColumnMasterSet::Add( XPtr<CColumnMasterDesc> & xpNewCol )
{
    CColumnMasterDesc* pCol = Find(xpNewCol->PropId);

    if ( 0 != pCol )
        return pCol;

    //
    //  Column was not found in the existing set, add it.
    //
    unsigned iCol = _iNextFree++;
    if (iCol >= _aMasterCol.Size())
        _aMasterCol.Add(0, iCol);       // force the array to grow

    _aMasterCol.Add(xpNewCol.Acquire(), iCol);
    return _aMasterCol.Get(iCol);
}


CColumnMasterDesc*
CColumnMasterSet::Add( CColumnMasterDesc const & rColDesc )
{
    CColumnMasterDesc* pCol = Find(rColDesc.PropId);

    if ( 0 != pCol )
        return pCol;

    //
    // Column was not found in the existing set, add it.
    //
    // PERFFIX: to avoid the compression restriction, use the method above.

    Win4Assert(! rColDesc.IsCompressedCol() );

    CColumnMasterDesc* pNewCol = new CColumnMasterDesc;

    XPtr<CColumnMasterDesc> xCol( pNewCol );

    *pNewCol = rColDesc;

    unsigned iCol = _iNextFree++;
    _aMasterCol.Add(pNewCol, iCol);

    xCol.Acquire();

    return _aMasterCol.Get(iCol);
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::CColumnMasterDesc, public
//
//  Synopsis:   Constructor for a master column description.
//
//  Arguments:  [PropertyId] -- the PROPID for the column
//              [DataTyp] -- data type of column
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc::CColumnMasterDesc( PROPID PropertyId,
                                      VARTYPE DataTyp)
        : PropId( PropertyId ),
          DataType( DataTyp ),
          _cbData( 0 ),
          _fComputedProperty( FALSE ),
          _PredominantType( VT_EMPTY ),
          _fUniformType( TRUE ),
          _fNotVariantType (FALSE),
          _pCompression( NULL ),
          _CompressMasterID( 0 )
{
    if ( DataType == VT_EMPTY )
    {
        DataType =  PropIdToType( PropId );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::CColumnMasterDesc, public
//
//  Synopsis:   Constructor for a master column description from a
//              sort key description.
//
//  Arguments:  [rSortKey] -- A description of a sort key
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc::CColumnMasterDesc( SSortKey& rSortKey )
        : PropId( rSortKey.pidColumn ),
          DataType( PropIdToType(rSortKey.pidColumn) ),
          _cbData( 0 ),
          _fComputedProperty( FALSE ),
          _PredominantType( VT_EMPTY ),
          _fUniformType( TRUE ),
          _fNotVariantType (FALSE),
          _pCompression( NULL ),
          _CompressMasterID( 0 )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::~CColumnMasterDesc, public
//
//  Synopsis:   Destructor for a master column description.
//
//  Notes:
//
//--------------------------------------------------------------------------

CColumnMasterDesc::~CColumnMasterDesc( )
{
    if (_pCompression && _CompressMasterID == 0)
          delete _pCompression;
}


//+-------------------------------------------------------------------------
//
//  Member:     CColumnMasterDesc::SetCompression, public
//
//  Synopsis:   Install a global compression for a master column.
//
//  Arguments:  [pCompr] -- A pointer to the compressor for the
//                      column
//              [SharedID] -- If non-zero, the master column ID
//                      for a shared compression.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
CColumnMasterDesc::SetCompression(
    CCompressedCol* pCompr,
    PROPID SharedID
) {
    if (_pCompression && _CompressMasterID == 0)
          delete _pCompression;

    _pCompression = pCompr;
    _CompressMasterID = SharedID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\colinfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       colinfo.cxx
//
//  Contents:   Column information for rowsets
//
//  Classes:    CColumnsInfo
//
//  Notes:      Designed as an aggregated class of an IRowset or an
//              IQuery implementation.
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <colinfo.hxx>
#include <query.hxx>
#include <tblvarnt.hxx>

#include "tblrowal.hxx"
#include "tabledbg.hxx"

// Always bind as DBTYPE_VARIANT, so we can use provider-owned memory

#define ALWAYS_USE_VARIANT_BINDING

ULONG CColumnsInfo::_nUnique = 0;

const static GUID guidBmk = DBBMKGUID;

//+-------------------------------------------------------------------------
//
//  Method:     CColumnsInfo::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on controlling unknown object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CColumnsInfo::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    return _rUnknown.QueryInterface(riid,ppvObject);
} //QueryInterface


//+-------------------------------------------------------------------------
//
//  Method:     CColumnsInfo::AddRef, public
//
//  Synopsis:   Invokes AddRef on controlling unknown object
//
//  Returns:    ULONG
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CColumnsInfo::AddRef()
{
    return _rUnknown.AddRef();
} //AddRef


//+-------------------------------------------------------------------------
//
//  Method:     CColumnsInfo::Release, public
//
//  Synopsis:   Invokes Release on controlling unknown object
//
//  Returns:    ULONG
//
//  History:    04 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CColumnsInfo::Release()
{
    return _rUnknown.Release();
} //Release


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::CColumnsInfo, public
//
//  Synopsis:   Creates a column information class
//
//  Arguments:  [cols]        -- a reference to the output column set, pidmapped
//              [pidmap]      -- property IDs and names for the columns
//              [ErrorObject] -- a reference to enclosing object's error obj.
//              [rUnknown]    -- a reference to the controlling IUnknown
//              [fSequential] -- TRUE if the query is sequential
//
//  Notes:
//
//  History:    04 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CColumnsInfo::CColumnsInfo(
        CColumnSet const & cols,
        CPidMapperWithNames const & pidmap,
        CCIOleDBError & ErrorObject,
        IUnknown &  rUnknown,
        BOOL        fSequential ) :
        _idUnique(0),
        _rUnknown(rUnknown),
        _fSequential(fSequential),
        _fChaptered(FALSE),
        _cbRowWidth(0),
        _cColumns( cols.Count() ),
        _cBoundColumns(0),
        _iColRowId(pidInvalid),
        _pColumns(0),
        _pidmap( cols.Count()+1 ),
        _ErrorObject( ErrorObject ),
        _fNotPrepared(FALSE)
{
    _SetColumns(cols, pidmap, fSequential);
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::CColumnsInfo, public
//
//  Synopsis:   Creates an empty column information class
//
//  Arguments:  [rUnknown]    -- a reference to the controlling IUnknown
//              [ErrorObject] -- a reference to enclosing object's error obj.
//
//  Notes:      Used in the command object where column information may
//              change, depending upon the command.
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

CColumnsInfo::CColumnsInfo(
        IUnknown &  rUnknown,
        CCIOleDBError & ErrorObject,
        BOOL fNotPrepared) :
        _idUnique(_GetNewId()),
        _rUnknown(rUnknown),
        _fSequential(FALSE),
        _fChaptered(FALSE),
        _cbRowWidth(0),
        _cColumns( 0 ),
        _cBoundColumns(0),
        _iColRowId(pidInvalid),
        _pColumns(0),
        _pidmap( 0 ),
        _ErrorObject( ErrorObject ),
        _fNotPrepared(fNotPrepared)
{

}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::~CColumnsInfo, public
//
//  Synopsis:   Destroys a column information class
//
//  Notes:
//
//  History:    12 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CColumnsInfo::~CColumnsInfo( )
{
    delete _pColumns;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::InitColumns, public
//
//  Synopsis:   Initializes or reinitializes columns.
//
//  Arguments:  [cols]        -- a reference to the output column set, pidmapped
//              [pidmap]      -- property IDs and names for the columns
//              [fSequential] -- TRUE if the query is sequential
//
//  Notes:
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void CColumnsInfo::InitColumns (
        CColumnSet const & cols,
        CPidMapperWithNames const & pidmap,
        BOOL        fSequential )
{
    _pidmap.Clear();
    _cColumns = cols.Count();
    _fSequential = fSequential;
    _SetColumns(cols, pidmap, fSequential);
    _fChaptered = FALSE;
    _fNotPrepared = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::InitColumns, public
//
//  Synopsis:   Reinitializes columns to be null.
//
//  Arguments:  [fNotPrepared]  - TRUE if GetColumnInfo and MapColumnIDs should
//                                return DB_E_NOTPREPARED for a command object
//
//  Notes:
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void CColumnsInfo::InitColumns ( BOOL fNotPrepared )
{
    _pidmap.Clear();
    _cColumns = 0;
    _fSequential = FALSE;
    _fChaptered = FALSE;
    _fNotPrepared = fNotPrepared;
}

//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::_SetColumns, private
//
//  Synopsis:   Initializes or reinitializes columns.
//
//  Arguments:  [cols]        -- a reference to the output column set, pidmapped
//              [pidmap]      -- property IDs and names for the columns
//              [fSequential] -- TRUE if the query is sequential
//
//  Notes:
//
//  History:    11 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void CColumnsInfo::_SetColumns (
        CColumnSet const & cols,
        CPidMapperWithNames const & pidmap,
        BOOL        fSequential )
{
    Win4Assert( 0 == _pColumns && 0 == _cbRowWidth );
    _idUnique = _GetNewId();

    //
    //  We want the PidMapper to give back 1-based column numbers;
    //  add either a null propspec or the bookmark column as its first element.
    //

    if (fSequential)
    {
        CFullPropSpec nullCol;
        _pidmap.NameToPid( nullCol );
    }
    else
    {
        CFullPropSpec bmkCol( guidBmk, PROPID_DBBMK_BOOKMARK );
        _pidmap.NameToPid( bmkCol );
    }

    for (unsigned i = 0; i < _cColumns; i++)
    {
        PROPID pidTmp = cols.Get(i);
        const CFullPropSpec & ColId = *pidmap.Get(pidTmp);

        if (ColId.IsPropertyPropid() &&
            ColId.GetPropSet() == guidBmk)
        {
            Win4Assert( !fSequential );
            if (ColId.GetPropertyPropid() == PROPID_DBBMK_BOOKMARK)
            {
                if (0 != pidmap.GetFriendlyName(pidTmp))
                {
                    _pidmap.SetFriendlyName( 0, pidmap.GetFriendlyName(pidTmp) );
                }
                continue;
            }
            else if (ColId.GetPropertyPropid() == PROPID_DBBMK_CHAPTER)
            {
                _fChaptered = TRUE;
            }
        }
        PROPID pidNew = _pidmap.NameToPid( ColId );
        if (0 != pidmap.GetFriendlyName(pidTmp))
        {
            _pidmap.SetFriendlyName( pidNew, pidmap.GetFriendlyName(pidTmp) );
        }
    }

    //  In case of duplicate columns, _cColumns needs to be adjusted.
    Win4Assert( _pidmap.Count() > 1 );
    _cColumns = _pidmap.Count() - 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::MapColumnID, private
//
//  Synopsis:   Map a column identifier to its column number in the
//              cursor.
//
//  Arguments:  [pColumnId] - A pointer to the column identifier.
//
//  Returns:    The column number (1-based).  Returns DB_INVALIDCOLUMN
//              on error.
//
//  History:    04 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

ULONG CColumnsInfo::MapColumnID(
    const DBID *      pColumnId
) {
    PROPID pid = pidInvalid;

    if (pColumnId->eKind == DBKIND_PGUID_PROPID ||
        pColumnId->eKind == DBKIND_PGUID_NAME)
    {
        DBID dbcolMapped = *pColumnId;
        dbcolMapped.uGuid.guid = *pColumnId->uGuid.pguid;

        if (pColumnId->eKind == DBKIND_PGUID_PROPID)
            dbcolMapped.eKind = DBKIND_GUID_PROPID;
        else
            dbcolMapped.eKind = DBKIND_GUID_NAME;

        pid = _pidmap.NameToPid(dbcolMapped);
    }
    else
    {
        pid = _pidmap.NameToPid(*pColumnId);
    }

    tbDebugOut(( DEB_ITRACE, "pid: 0x%x, _cColumns: %d\n",
                 pid, _cColumns ));

    if (pid == pidInvalid || pid > _cColumns || (pid == 0 && _fSequential) )
        return (ULONG) DB_INVALIDCOLUMN;

    return pid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::MapColumnIDs, public
//
//  Synopsis:   Map a column identifier to its column number in the
//              rowset.
//
//  Arguments:  [cColumnIDs] -- # of elements in the arrays
//              [rgColumnIDs]  -- A pointer to the column identifiers
//              [rgColumns] -- an array in which to return the column numbers.
//
//  Returns:    SCODE - DB_S_ERRORSOCCURRED, an element of rgColumnIDs was
//                      invalid
//
//  Notes:      Column numbers are 1-based.
//
//----------------------------------------------------------------------------

STDMETHODIMP CColumnsInfo::MapColumnIDs(
    DBORDINAL           cColumnIDs,
    const DBID          rgColumnIDs[],
    DBORDINAL           rgColumns[])
{
    _ErrorObject.ClearErrorInfo();

    SCODE sc = S_OK;

    if ((0 != cColumnIDs && 0 == rgColumnIDs) ||
         0 == rgColumns)
        return _ErrorObject.PostHResult(E_INVALIDARG, IID_IColumnsInfo);

    if ( 0 == cColumnIDs )
        return S_OK;

    if ( _fNotPrepared )
        return _ErrorObject.PostHResult(DB_E_NOTPREPARED, IID_IColumnsInfo);

    if ( 0 == _cColumns )
        return _ErrorObject.PostHResult(DB_E_NOCOMMAND, IID_IColumnsInfo);

    unsigned cBadMapping = 0;
    TRY
    {
        for (ULONG i = 0; i < cColumnIDs; i++)
        {
            ULONG ulColID = MapColumnID( &rgColumnIDs[i] );
            rgColumns[i] = ulColID;
            if (ulColID == DB_INVALIDCOLUMN)
                cBadMapping++;
        }
    }
    CATCH( CException, e )
    {
        _ErrorObject.PostHResult(e.GetErrorCode(), IID_IColumnsInfo);
        sc = GetOleError(e);
    }
    END_CATCH;

    if (SUCCEEDED(sc) && cBadMapping)
        sc = (cBadMapping == cColumnIDs) ? DB_E_ERRORSOCCURRED :
                                           DB_S_ERRORSOCCURRED;

    return sc;
} //MapColumnIDs


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::GetColumnInfo, public
//
//  Synopsis:   Return information about the columns in the rowset.
//
//  Arguments:  [pcColumns] - A pointer to where the number of columns
//                            will be returned.
//              [prgInfo] -   A pointer to where a pointer to an array of
//                            DBCOLUMNINFO structures describing the columns
//                            will be returned.  This must be freed by the
//                            caller.
//              [ppStringsBuffer] - A pointer to where extra data for strings
//                            will be returned.  This must be freed by the
//                            caller if non-null.
//
//  Returns:    SCODE
//
//  Notes:      Some columns are standard columns available for all file
//              stores.  For these columns, full information about data
//              type and sizes can be returned.  For any other columns,
//              we can only say that it has a variant type.
//
//  History:    07 Nov 1994     AlanW   Created
//              04 Feb 1995     AlanW   Moved to CColumnsInfo and rewritten
//
//----------------------------------------------------------------------------

STDMETHODIMP CColumnsInfo::GetColumnInfo(
    DBORDINAL *             pcColumns,
    DBCOLUMNINFO * *    prgInfo,
    WCHAR * *           ppStringsBuffer)
{
    _ErrorObject.ClearErrorInfo();

    SCODE scResult = S_OK;

    //
    // Initialize arguments before returning errors
    //
    if ( pcColumns)
        *pcColumns = 0;
    if ( prgInfo )
        *prgInfo = 0;
    if (ppStringsBuffer )
        *ppStringsBuffer = 0;

    if (0 == pcColumns ||
        0 == prgInfo ||
        0 == ppStringsBuffer)
        return _ErrorObject.PostHResult(E_INVALIDARG, IID_IColumnsInfo);

    if ( _fNotPrepared )
        return _ErrorObject.PostHResult(DB_E_NOTPREPARED, IID_IColumnsInfo);

    if ( 0 == _cColumns )
        return _ErrorObject.PostHResult(DB_E_NOCOMMAND, IID_IColumnsInfo);

    TRY
    {
        unsigned iFirstCol = _fSequential ? 1 : 0;
        unsigned cColumns = GetColumnCount() + 1 - iFirstCol;

        //
        //  The total size required for the output array depends upon
        //  the size of variable data discovered in the column information.
        //  Although we could reallocate the memory we'll be writing into,
        //  we'll just run through the loop twice, once to compute the
        //  needed space, and the second time to copy the data out after
        //  doing our allocation.
        //
        ULONG cchNames = 0;

        for (unsigned iCol = iFirstCol; iCol <= GetColumnCount(); iCol++)
        {
            const CFullPropSpec & ColId = *_pidmap.Get(iCol);

            if (ColId.IsPropertyName())
            {
                cchNames += wcslen(ColId.GetPropertyName()) + 1;
            }

            WCHAR const * pwszColName = _pidmap.GetFriendlyName(iCol);
            if (0 == pwszColName)
                pwszColName = _FindColumnInfo(ColId).pwszName;

            if (pwszColName)
            {
                cchNames += wcslen(pwszColName) + 1;
            }
        }

        XArrayOLE<DBCOLUMNINFO> ColumnInfo( cColumns );
        XArrayOLE<WCHAR> StringBuf( cchNames );

        DBCOLUMNINFO *pColInfo = ColumnInfo.GetPointer();
        WCHAR * pwcNames = StringBuf.GetPointer();

        for (iCol = iFirstCol; iCol <= GetColumnCount(); iCol++, pColInfo++)
        {
            const CFullPropSpec & ColId = *_pidmap.Get(iCol);
            const DBCOLUMNINFO & rColumnInfo = _FindColumnInfo( ColId );

            //
            //  Copy the prototype column information, then update
            //  specific fields in the column info:
            //      column number
            //      column ID
            //      copies of strings
            //
            *pColInfo = rColumnInfo;

            pColInfo->iOrdinal = iCol;

            pColInfo->columnid.uGuid.guid = ColId.GetPropSet();
            if (ColId.IsPropertyName())
            {
                pColInfo->columnid.eKind = DBKIND_GUID_NAME;
                ULONG cch = wcslen(ColId.GetPropertyName()) + 1;
                RtlCopyMemory(pwcNames, ColId.GetPropertyName(),
                                cch * sizeof (WCHAR));
                pColInfo->columnid.uName.pwszName = pwcNames;
                pwcNames += cch;
            }
            else
            {
                Win4Assert(ColId.IsPropertyPropid());
                pColInfo->columnid.eKind = DBKIND_GUID_PROPID;
                pColInfo->columnid.uName.ulPropid = ColId.GetPropertyPropid();
            }

            WCHAR const * pwszColName = _pidmap.GetFriendlyName(iCol);
            if (0 == pwszColName)
                pwszColName = _FindColumnInfo(ColId).pwszName;

            if (pwszColName)
            {
                ULONG cch = wcslen(pwszColName) + 1;
                RtlCopyMemory(pwcNames, pwszColName, cch * sizeof (WCHAR));
                pColInfo->pwszName = pwcNames;
                pwcNames += cch;
            }
        }

        Win4Assert( (unsigned)(pColInfo - ColumnInfo.GetPointer()) == cColumns );

        *prgInfo = ColumnInfo.Acquire();
        if (cchNames > 0)
            *ppStringsBuffer = StringBuf.Acquire();

        *pcColumns = cColumns;
    }
    CATCH( CException, e )
    {
        scResult = e.GetErrorCode();
        _ErrorObject.PostHResult(scResult, IID_IColumnsInfo);
        if (scResult != E_OUTOFMEMORY)
            scResult = E_FAIL;
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::SetColumnBindings, public
//
//  Synopsis:   Set current column bindings on the cursor.  Save in
//              member variables.  Workid is always added to the
//              bindings for movable rowsets for use with bookmarks
//              and hRows.  Space for a USHORT reserved for row buffer
//              refcounting is always allocated.
//
//  Arguments:  [rpQuery] - a reference to the PQuery for the query
//              [hCursor] - a reference to the hCursor to have column
//                              bindings set on.
//              [obRowRefcount] - on return, offset into the row buffer
//                              where a USHORT reference count can be stored.
//              [obRowId] - on return, offset into the row buffer where
//                              the row identifier is stored.  Not valid for
//                              sequential rowsets.
//
//  Returns:    Nothing.  Throws on errors.
//
//  Notes:      Initializes the private members _cbRowWidth and _pColumns.
//
//  History:    04 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void    CColumnsInfo::SetColumnBindings(
    PQuery &    rpQuery,
    ULONG       hCursor,
    ULONG       &obRowRefcount,
    ULONG       &obRowId,
    ULONG       &obChaptRefcount,
    ULONG       &obChaptId
) {
    CTableRowAlloc RowMap( 0 );
    USHORT maxAlignment = sizeof (USHORT);

    obRowRefcount = RowMap.AllocOffset( sizeof (USHORT),
                                        sizeof (USHORT),
                                        TRUE );

    if (_fChaptered)
        obChaptRefcount = RowMap.AllocOffset( sizeof (USHORT),
                                              sizeof (USHORT),
                                              TRUE );
    else
        obChaptRefcount = 0xFFFFFFFF;

    obRowId = 0xFFFFFFFF;
    obChaptId = 0xFFFFFFFF;
    BOOL fAddedWorkId = FALSE;
    BOOL fMayDefer = FALSE;

    // +1 In case WorkID or Path is added for rowid

    XPtr<CTableColumnSet> XColumns( new CTableColumnSet( GetColumnCount() + 1 ));

    unsigned cBoundColumns = 0;

    tbDebugOut(( DEB_ITRACE, "original column count: %d\n", GetColumnCount() ));
    for (unsigned iCol = 1; iCol <= GetColumnCount(); iCol++)
    {
        const CFullPropSpec & ColId = *_pidmap.Get( iCol );
        const DBCOLUMNINFO & rColumnInfo = _FindColumnInfo( ColId );

        tbDebugOut(( DEB_ITRACE, "colinfo::set, top of loop, cBoundColumns: %d\n",
                     cBoundColumns ));
        tbDebugOut(( DEB_ITRACE, "adding '%ws'\n", rColumnInfo.pwszName ));

        //
        //  If this is bookmark column, it will be mapped to the row ID
        //  column.  It's only valid for locatable rowsets.
        //
        if ( (rColumnInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) &&
             ColId.IsPropertyPropid() &&
             ColId.GetPropertyPropid() == PROPID_DBBMK_BOOKMARK)
        {
            tbDebugOut(( DEB_ITRACE, "skipping bookmark column\n" ));

            Win4Assert(! _fSequential );
            if (_fSequential)
                THROW(CException(E_FAIL));
            continue;
        }

        // the self columns is resolved in the accessor -- no binding needed

        if ( ( ColId.IsPropertyPropid() ) &&
             ( ColId.GetPropertyPropid() == PROPID_DBSELF_SELF ) &&
             ( ColId.GetPropSet() == DBCOL_SELFCOLUMNS ) )
        {
            continue;
        }

        //
        //  Create the new column.  Note that its PropID is the
        //  1-based column ID.
        //
        XPtr<CTableColumn> TableCol(new CTableColumn( iCol ));

#ifndef ALWAYS_USE_VARIANT_BINDING
        VARTYPE vt = rColumnInfo.wType;

        switch (vt)
        {
        case DBTYPE_VARIANT:
        {
#endif // ndef ALWAYS_USE_VARIANT_BINDING

            fMayDefer = TRUE;

            TableCol->SetValueField( DBTYPE_VARIANT,
                                     RowMap.AllocOffset( sizeof (PROPVARIANT),
                                                         sizeof (LONGLONG),
                                                         TRUE ),
                                     sizeof (PROPVARIANT));

            // The status column is interesting for all columns

            TableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                          sizeof (BYTE),
                                                          TRUE ),
                                      sizeof (BYTE));

            // Length is interesting, especially when the value is deferred

            TableCol->SetLengthField( RowMap.AllocOffset( sizeof (ULONG),
                                                          sizeof (ULONG),
                                                          TRUE ),
                                      sizeof (ULONG));

            USHORT cbData, cbAlignment, rgfFlags;
            CTableVariant::VartypeInfo(DBTYPE_VARIANT, cbData, cbAlignment, rgfFlags);

            if ( cbAlignment > maxAlignment)
                maxAlignment = cbAlignment;

#ifndef ALWAYS_USE_VARIANT_BINDING
            break;
        }

        case DBTYPE_DATE:
        case DBTYPE_WSTR:
        case DBTYPE_STR:
            //
            //  Adjust DBTYPEs from the column info into ones that are
            //  better for binding.
            //
            if (vt == DBTYPE_DATE)
                vt = VT_FILETIME;
            else if (vt == DBTYPE_WSTR)
                vt = VT_LPWSTR;
            else if (vt == DBTYPE_STR)
                vt = VT_LPSTR;

            // NOTE: fall through

        default:

            USHORT cbData, cbAlignment, rgfFlags;
            CTableVariant::VartypeInfo(vt, cbData, cbAlignment, rgfFlags);

            if (rgfFlags & CTableVariant::MultiSize)
                cbData = (USHORT) rColumnInfo.ulColumnSize;

            Win4Assert(cbData != 0 || vt == VT_EMPTY);

            if (cbData == 0 && vt != VT_EMPTY)
            {
                tbDebugOut(( DEB_WARN,
                        "CColumnInfo::SetColumnBindings - Unknown variant type %4x\n",
                        vt));
            }

            if (cbAlignment)
            {
                if (cbAlignment > maxAlignment)
                {
                    maxAlignment = cbAlignment;
                }
            }
            else
            {
                cbAlignment = 1;
            }

            if (cbData != 0)
            {
                TableCol->SetValueField( vt,
                                         RowMap.AllocOffset( cbData,
                                                             cbAlignment,
                                                             TRUE ),
                                         cbData);

                Win4Assert( 0 == ( (TableCol->GetValueOffset()) % cbAlignment ) );

                //
                // The status column is interesting for almost all columns,
                // even inline columns, since a summary catalog might have
                // VT_EMPTY data for these columns (eg storage props).
                //
                TableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                              sizeof (BYTE),
                                                              TRUE ),
                                          sizeof (BYTE));
            }
        }
#endif // ndef ALWAYS_USE_VARIANT_BINDING

        //
        //  If this is the row ID column, save its offset in the row.
        //
        if (rColumnInfo.dwFlags & DBCOLUMNFLAGS_ISROWID)
        {
#ifdef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_VARIANT &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (PROPVARIANT));
            PROPVARIANT prop;
            obRowId = TableCol->GetValueOffset() +
                       (DWORD)((BYTE *) &prop.lVal - (BYTE *)&prop);
#else // ndef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_I4 &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (ULONG));
            obRowId = TableCol->GetValueOffset();
#endif // ndef ALWAYS_USE_VARIANT_BINDING
            _iColRowId = iCol;
            fAddedWorkId = TRUE;
        }

        //
        //  If this is the chapter column, save its offset in the row.
        //
        if (rColumnInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER)
        {
            Win4Assert( _fChaptered );
#ifdef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_VARIANT &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (PROPVARIANT));
            PROPVARIANT prop;
            obChaptId = TableCol->GetValueOffset() +
                       (DWORD)((BYTE *) &prop.lVal - (BYTE *)&prop);
#else // ndef ALWAYS_USE_VARIANT_BINDING
            Win4Assert(TableCol->GetStoredType() == VT_I4 &&
                       TableCol->IsValueStored() &&
                       TableCol->GetValueSize() == sizeof (ULONG));
            obChaptId = TableCol->GetValueOffset();
#endif // ndef ALWAYS_USE_VARIANT_BINDING
        }

        XColumns->Add(TableCol.GetPointer(), cBoundColumns++);
        TableCol.Acquire();
    }

    tbDebugOut(( DEB_ITRACE, "colinfo::set, after loop, cBoundColumns: %d\n",
                 cBoundColumns ));

    // Need to add workid for non-sequential queries so that bookmarks
    // work, and either workid or path so that deferred values work.

    if ( ( ( !_fSequential ) ||
           ( fMayDefer && rpQuery.CanDoWorkIdToPath() ) ) &&
         ( !fAddedWorkId ) )
    {
        tbDebugOut(( DEB_ITRACE, "colinfo::set, adding WID column\n" ));

        //
        // Need to add the row ID column to the bindings, so that bookmarks
        // work, and deferred values can be loaded.
        //
        const DBCOLUMNINFO & rColumnInfo = _GetRowIdColumnInfo( );

        unsigned iCol = _pidmap.NameToPid( rColumnInfo.columnid );
        XPtr<CTableColumn> TableCol(new CTableColumn( iCol ));
        _iColRowId = iCol;

        Win4Assert (VT_I4 == rColumnInfo.wType);

        if (sizeof (ULONG) > maxAlignment)
            maxAlignment = sizeof (ULONG);

        TableCol->SetValueField( VT_I4,
                                 RowMap.AllocOffset( sizeof (ULONG),
                                                     sizeof (ULONG),
                                                     TRUE ),
                                 sizeof (ULONG));
        obRowId = TableCol->GetValueOffset();

        TableCol->SetStatusField( RowMap.AllocOffset( sizeof (BYTE),
                                                      sizeof (BYTE),
                                                      TRUE ),
                                  sizeof (BYTE));

        XColumns->Add(TableCol.GetPointer(), cBoundColumns++);
        TableCol.Acquire();
    }

    ULONG rem = RowMap.GetRowWidth() % maxAlignment;

    if ( 0 == rem )
        _cbRowWidth = RowMap.GetRowWidth();
    else
        _cbRowWidth = RowMap.GetRowWidth() + maxAlignment - rem;

    rpQuery.SetBindings( hCursor,
                         _cbRowWidth,
                         XColumns.GetReference(),
                         _pidmap );

    tbDebugOut(( DEB_ITRACE, "colinfo::set, old # cols %d, new # cols %d\n",
                 _cColumns, cBoundColumns ));

    _cBoundColumns = cBoundColumns;
    _pColumns = XColumns.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::Get1ColumnInfo, public
//
//  Synopsis:   Return information about a single column in the rowset.
//
//  Arguments:  [iColumn] - the column number whose column info is to be
//                              returned.
//
//  Returns:    DBCOLUMNINFO & - a pointer to column info for the column
//
//  Notes:
//
//  History:    29 Mar 1995     AlanW   Created
//
//----------------------------------------------------------------------------

const DBCOLUMNINFO & CColumnsInfo::Get1ColumnInfo(
    ULONG iColumn
) /*const*/
{
    const CFullPropSpec & ColId = *_pidmap.Get(iColumn);

    return _FindColumnInfo( ColId );
}


#ifdef  INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION
STDMETHODIMP CRowset::GetColumnsRowset(
    ULONG         cSelections,
    DBID          rgColumnSelection[],
    IRowset **    ppColCursor
) /*const*/ {
    _ErrorObject.ClearErrorInfo();
    return _ErrorObject.PostHResult(E_NOTIMPL, IID_IColumnsRowset);
}

STDMETHODIMP CRowset::GetAvailableColumns(
    ULONG *       pcSelections,
    DBID **       rgColumnSelection
) /*const*/ {
    _ErrorObject.ClearErrorInfo();
    return _ErrorObject.PostHResult(E_NOTIMPL, IID_IColumnsRowset);
}
#endif // INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION



////////////////////////////////////////////////////////////
//
//  Data declarations for _FindColumnInfo
//
//  Notes:      These arrays of structures are prototype column info.
//              structures returned by _FindColumnInfo.
//
////////////////////////////////////////////////////////////

static const DBCOLUMNINFO aStoragePropDescs[] = {
    {   L"FileDirectoryName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH, // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_DIRECTORY )  }
     },

    {   L"ClassID", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (GUID),
        DBTYPE_GUID, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_CLASSID ) }
    },

    {   L"FileStorageType", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (ULONG),
        DBTYPE_UI4, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_STORAGETYPE ) }
    },

    {   L"FileIndex", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_I8, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_FILEINDEX ) }
    },

    {   L"FileUSN", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_I8, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_LASTCHANGEUSN ) }
    },

    {   L"FileName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH, // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_NAME ) }
    },

    {   L"FilePathName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH, // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_PATH ) }
     },

    {   L"FileSize", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_I8, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_SIZE ) }
    },

    {   L"FileAttributes", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (ULONG),
        DBTYPE_UI4, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_ATTRIBUTES ) }
    },

// NOTE:  file times are typed as DBTYPE_DATE, but are bound to the
//          table as VT_FILETIME.
    {   L"FileWriteTime", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_DATE, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_WRITETIME ) }
    },

    {   L"FileCreateTime", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_DATE, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_CREATETIME ) }
    },

    {   L"FileAccessTime", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONGLONG),
        DBTYPE_DATE, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_ACCESSTIME ) }
    },

    {   L"FileShortName", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, 13,   // storage props are never deferred
        DBTYPE_WSTR, 0xff, 0xff,
      { PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PID_STG_SHORTNAME ) }
    },
};

const ULONG cStoragePropDescs =
                          sizeof aStoragePropDescs /
                          sizeof aStoragePropDescs[0];


//
//  Standard query properties.
//  Does not include pidAll or pidContent, those are used only in restrictions.
//

static const DBCOLUMNINFO aQueryPropDescs[] = {
    {   L"QueryRankvector", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof(PROPVARIANT),
        DBTYPE_VARIANT, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_RANKVECTOR ) }
    },

    {   L"QueryRank", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_RANK ) }
    },

    {   L"QueryHitCount", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_HITCOUNT ) }
    },

    {   L"WorkID", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH|DBCOLUMNFLAGS_ISROWID, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_WORKID ) }
    },

    {   L"QueryUnfiltered", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof(BOOL),
        DBTYPE_BOOL, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_UNFILTERED ) }
    },

    {   L"QueryVirtualPath", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE, MAX_PATH,
        DBTYPE_WSTR, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_VIRTUALPATH ) }
    },

#if defined( DISPID_QUERY_NLIRRANK )
    {   L"NLIRRank", 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE|DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBQUERYGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( DISPID_QUERY_NLIRRANK ) }
    },
#endif // defined( DISPID_QUERY_NLIRRANK )
};

const ULONG cQueryPropDescs =
                          sizeof aQueryPropDescs /
                          sizeof aQueryPropDescs[0];


static DBCOLUMNINFO const aBmkPropDescs[] = {
    {   L"Bookmark", 0, 0,
        DBCOLUMNFLAGS_ISBOOKMARK|DBCOLUMNFLAGS_ISFIXEDLENGTH,
        sizeof (CI_TBL_BMK),
        DBTYPE_BYTES, 0xff, 0xff,
      { DBBMKGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PROPID_DBBMK_BOOKMARK ) }
    },
    {   L"Chapter", 0, 0,
        DBCOLUMNFLAGS_ISCHAPTER|DBCOLUMNFLAGS_ISBOOKMARK|DBCOLUMNFLAGS_ISFIXEDLENGTH,
        sizeof (CI_TBL_CHAPT),
        DBTYPE_BYTES, 0xff, 0xff,
      { DBBMKGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PROPID_DBBMK_CHAPTER ) }
    },
};

const ULONG cBmkPropDescs =
                          sizeof aBmkPropDescs /
                          sizeof aBmkPropDescs[0];


// CLEANCODE: ole-db spec bug #1271 - const GUID init. less than useful

#ifndef DBSELFGUID
#define DBSELFGUID {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#endif // ndef DBSELFGUID

static DBCOLUMNINFO const aSelfPropDescs[] = {
    {   L"Self", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH,
        sizeof( int ),
        DBTYPE_I4, 0xff, 0xff,
      { DBSELFGUID, DBKIND_GUID_PROPID, (LPWSTR) UIntToPtr( PROPID_DBSELF_SELF ) }
    },
};

const ULONG cSelfPropDescs =
                          sizeof aSelfPropDescs /
                          sizeof aSelfPropDescs[0];

#ifdef  INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION

static const DBCOLUMNINFO aColInfoPropDescs[] = {

    {   L"ColumnId", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, 3 * sizeof(PROPVARIANT),
        DBTYPE_VARIANT|DBTYPE_VECTOR, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)1 }
    },

    {   L"ColumnName", 0, 0,
        0, 20,
        DBTYPE_WSTR, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)2 }
    },

    {   L"ColumnNumber", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)3 }
    },

    {   L"ColumnType", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof(USHORT),
        DBTYPE_I2, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)4 }
    },

    {   L"ColumnLength", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)5 }
    },

    {   L"ColumnPrecision", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)6 }
    },

    {   L"ColumnScale", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)7 }
    },

    {   L"ColumnFlags", 0, 0,
        DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (LONG),
        DBTYPE_I4, 0xff, 0xff,
      { DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)8 }
    },
};

const ULONG cColInfoPropDescs =
                          sizeof aColInfoPropDescs /
                          sizeof aColInfoPropDescs[0];
#endif // INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION

//
//  Array of column descriptions per known propset
//  Each referenced array must have the same Guid for each element in
//  the array.
//

const CColumnsInfo::SPropSetInfo CColumnsInfo::aPropSets [ ] = {
#define IPROPSET_STORAGE        0       // Storage property set index
        { cStoragePropDescs,    aStoragePropDescs },
        { cQueryPropDescs,      aQueryPropDescs },
        { cBmkPropDescs,        aBmkPropDescs },
        { cSelfPropDescs,       aSelfPropDescs },

#ifdef  INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION
        { cColInfoPropDescs,    aColInfoPropDescs },
#endif // INCLUDE_COLUMNS_ROWSET_IMPLEMENTATION
};

const ULONG CColumnsInfo::cPropSets =
                          sizeof CColumnsInfo::aPropSets /
                          sizeof CColumnsInfo::aPropSets[0];

DBCOLUMNINFO const DefaultColumnInfo = {
        0, 0, 0,
        DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYDEFER | DBCOLUMNFLAGS_ISFIXEDLENGTH, sizeof (PROPVARIANT),
        DBTYPE_VARIANT, 0xff, 0xff,
      { {0,0,0,{0,0,0,0,0,0,0,0}}, DBKIND_GUID_PROPID, (LPWSTR)0 }
    };

//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::_FindColumnInfo, static
//
//  Synopsis:   Return information about a particular column ID.
//
//  Arguments:  [ColId] -     Column ID to be looked up.
//
//  Returns:    DBCOLUMNINFO - the column information for the row looked up.
//
//  Notes:      Some columns are standard columns available for all file
//              stores.  For these columns, full information about data
//              type and sizes can be returned.  For any other columns,
//              a generic column information structure is returned.
//
//  History:    10 Feb 1995     AlanW   Created
//
//----------------------------------------------------------------------------

DBCOLUMNINFO const & CColumnsInfo::_FindColumnInfo(
    const CFullPropSpec & ColId
) {
    DBCOLUMNINFO const * pColInfo = &DefaultColumnInfo;

    //
    //  All custom information we return has propids, not prop names.
    //  Valid property IDs start at 2
    //

    if (ColId.IsPropertyPropid())
    {
        for (unsigned iPropSet = 0; iPropSet < cPropSets; iPropSet++)
        {
            if (ColId.GetPropSet() ==
                aPropSets[iPropSet].aPropDescs[0].columnid.uGuid.guid)
            {
                //
                //  Found the guid for the propset, now try to find the
                //  propid.
                //
                ULONG ulPropId = ColId.GetPropertyPropid();

                Win4Assert( ulPropId != PID_CODEPAGE &&
                            ulPropId != PID_DICTIONARY);

                for (unsigned iDesc = 0;
                     iDesc < aPropSets[iPropSet].cProps;
                     iDesc++)
                {
                    if (ulPropId ==
                        aPropSets[iPropSet].aPropDescs[iDesc].columnid.uName.ulPropid)
                    {
                        pColInfo = &aPropSets[iPropSet].aPropDescs[iDesc];
                        break;
                    }
                }
                break;
            }
        }
    }
    return *pColInfo;
}


//+---------------------------------------------------------------------------
//
//  Member:     CColumnsInfo::_GetRowIdColumnInfo, static
//
//  Synopsis:   Return information about the row ID column
//
//  Arguments:  - None -
//
//  Returns:    DBCOLUMNINFO - the column information for the row looked up.
//
//  Notes:      It is assumed that there is only one row ID column in the
//              standard column info.  This may need to change for chaptered
//              rowsets.
//
//  History:    15 Mar 1995     AlanW   Created
//
//----------------------------------------------------------------------------

DBCOLUMNINFO const & CColumnsInfo::_GetRowIdColumnInfo(
) {
    DBCOLUMNINFO const * pColInfo = 0;

    for (unsigned iPropSet = 0;
         iPropSet < cPropSets && pColInfo == 0;
         iPropSet++)
    {
        for (unsigned iDesc = 0;
             iDesc < aPropSets[iPropSet].cProps;
             iDesc++)
        {
            if ( aPropSets[iPropSet].aPropDescs[iDesc].dwFlags &
                                     DBCOLUMNFLAGS_ISROWID)
            {
                pColInfo = &aPropSets[iPropSet].aPropDescs[iDesc];
                break;
            }
        }
    }

    Win4Assert(pColInfo != 0);
    return *pColInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\dberror.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       DBERROR.CXX
//
//  Contents:   Ole DB Error implementation for CI
//
//  History:    28-Apr-97   KrishnaN  Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mssql.h>      // parser errors
#include <parserr.h>    // IDS_ values of parser errors (mc generated header)

//#include <initguid.h>
#define DBINITCONSTANTS
#include <msdaguid.h>


#define ERROR_MESSAGE_SIZE 512

extern long           gulcInstances;

// Implementation of CCIOleDBError

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::CCIOleDBError, public
//
//  Synopsis:   Constructor. Gets the class factory for error object.
//
//  Arguments:  [rUnknown] - Controlling unknown.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------
//
CCIOleDBError::CCIOleDBError ( IUnknown & rUnknown, CMutexSem & mutex ) :
    _mutex( mutex ),
    _rUnknown(rUnknown),
    _pErrClassFact (0)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::~CCIOleDBError, public
//
//  Synopsis:   Releases class factory.
//
//  Arguments:
//
//  History:    05-May-97   KrishnaN   Created
//----------------------------------------------------------------------------

CCIOleDBError::~CCIOleDBError()
{
    if ( 0 != _pErrClassFact )
        _pErrClassFact->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::QueryInterface, public
//
//  Synopsis:   Supports IID_IUnknown and IID_ISupportErrorInfo
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CCIOleDBError::QueryInterface(REFIID riid, void **ppvObject)
{
    return _rUnknown.QueryInterface(riid, ppvObject);

} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::AddRef, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCIOleDBError::AddRef()
{
    return _rUnknown.AddRef();
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::Release, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCIOleDBError::Release()
{
    return _rUnknown.Release();

}  //Release

// ISupportErrorInfo method

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::InterfaceSupportsErrorInfo, public
//
//  Synopsis:   Checks if error reporting on the specified interface is supported
//
//  Arguments:  [riid] - The interface in question
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CCIOleDBError::InterfaceSupportsErrorInfo(REFIID riid)
{
    ULONG ul;

    // See if the interface asked about, actually
    // creates an error object.
    for(ul=0; ul < _cErrInt; ul++)
    {
        if( *(_rgpErrInt[ul]) == riid )
            return S_OK;
    }

    return S_FALSE;
} // InterfaceSupportsErrorInfo


//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::GetErrorInterfaces, private
//
//  Synopsis:   Gets the error interfaces, IErrorInfo and IErrorRecords.
//
//  Arguments:  [ppIErrorInfo]    - Pointer to hold IErrorInfo i/f pointer
//              [ppIErrorRecords] - Pointer to hold IErrorRecords i/f pointer
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------
//
HRESULT CCIOleDBError::GetErrorInterfaces(IErrorInfo** ppIErrorInfo,
                                          IErrorRecords** ppIErrorRecords)
{
    if (0 == ppIErrorInfo || 0 == ppIErrorRecords)
        return E_INVALIDARG;

    *ppIErrorInfo = 0;
    *ppIErrorRecords = 0;

    if FAILED(_GetErrorClassFact())
        return E_NOINTERFACE;

    //
    // Do we have a class factory on CLSID_EXTENDEDERROR ?
    //
    if (0 == _pErrClassFact)
        return E_NOINTERFACE;

    HRESULT hr = S_OK;

    //
    // Obtain the error object or create a new one if none exists
    //

    GetErrorInfo(0, ppIErrorInfo);
    if ( !*ppIErrorInfo )
    {
        if( FAILED(hr = _pErrClassFact->CreateInstance(NULL,
                        IID_IErrorInfo, (LPVOID*)ppIErrorInfo)) )
            return hr;
    }

    //
    // Obtain the IErrorRecord Interface
    //

    hr = (*ppIErrorInfo)->QueryInterface(IID_IErrorRecords,
                                         (LPVOID*)ppIErrorRecords);

    //
    // On a failure retrieving IErrorRecords, we need to release
    // the IErrorInfo interface
    //

    if( FAILED(hr) && *ppIErrorInfo )
    {
        (*ppIErrorInfo)->Release();
        *ppIErrorInfo = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostHResult, public
//
//  Synopsis:   Post an HRESULT to be looked up in ole-db sdk's error
//              collection OR CI provided error lookup service.
//
//  Arguments:  [hrErr] - Code returned by the method that caused the error.
//              [piid]  - Interface where the error occurred.
//
//  Returns:    The incoming hrErr is echoed back to simplify error reporting
//              in the calling code. So the caller can simply say something like
//              "return PostHResult(E_INVALIDARG, &IID_ICommand);" instead of:
//              "PostHResult(E_INVALIDARG, &IID_ICommand); return E_INVALIDARG;".
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

HRESULT CCIOleDBError::PostHResult(HRESULT hrErr, const IID & refiid)
{
    SCODE hr = S_OK;
    ERRORINFO ErrorInfo;

    //
    // Obtain the error object or create a new one if none exists
    //

    XInterface<IErrorInfo> xErrorInfo;
    XInterface<IErrorRecords> xErrorRecords;
    hr = GetErrorInterfaces((IErrorInfo **)xErrorInfo.GetQIPointer(),
                            (IErrorRecords **)xErrorRecords.GetQIPointer());
    if (FAILED(hr))
        return hrErr;

    //
    // Content Index methods sometimes throw NTSTATUS errors. So check for
    // those and translate them to HRESULTs, just as is done in GetOleError()
    //

    switch (hrErr)
    {
    case STATUS_NO_MEMORY:
    case HRESULT_FROM_WIN32( ERROR_COMMITMENT_LIMIT ):
    case HRESULT_FROM_WIN32( ERROR_NO_SYSTEM_RESOURCES ):
    case STG_E_TOOMANYOPENFILES:
    case STG_E_INSUFFICIENTMEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        hrErr = E_OUTOFMEMORY;
        break;

    case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
    case HRESULT_FROM_WIN32( ERROR_PIPE_BUSY ):
        hrErr = CI_E_TIMEOUT;
        break;

    case HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ):
        hrErr = CI_E_NOT_RUNNING;
        break;

    case STATUS_NOT_FOUND:
        hrErr = CI_E_NOT_FOUND;
        break;

    case STATUS_INVALID_PARAMETER:
        hrErr = E_INVALIDARG;
        break;

    case STATUS_ACCESS_DENIED:
        hrErr = E_ACCESSDENIED;
        break;

    case STATUS_INVALID_PARAMETER_MIX:
    default:
        break;
    }

    //
    // Check to see if we have already posted this error
    //

    if ( NeedToSetError(hrErr, xErrorInfo.GetPointer(), xErrorRecords.GetPointer()) )
    {
        //
        // Assign static information across each error record added
        //

        ErrorInfo.clsid = CLSID_CI_PROVIDER;
        ErrorInfo.dispid = NULL;
        ErrorInfo.hrError = hrErr;
        ErrorInfo.iid = refiid;
        ErrorInfo.dwMinor = 0;

        //
        // If this is a CI error, then add it with the lookup code IDENTIFIER_CI_ERROR
        // If not, then it must be a Ole DB error or a Windows error. In either
        // case, the default Ole DB sdk error lookup service will handle it. So
        // post non-CI errors with IDENTIFIER_SDK_ERROR lookup id.
        //

        DWORD dwLookupId = IsCIError(hrErr) ? IDENTIFIER_CI_ERROR : IDENTIFIER_SDK_ERROR;

        //
        // Add the record to the Error Service Object
        //

        hr = xErrorRecords->AddErrorRecord(&ErrorInfo, dwLookupId, NULL, NULL, 0);

        //
        // Pass the error object to the Ole Automation DLL
        //

        if (SUCCEEDED(hr))
        {
            hr = SetErrorInfo(0, xErrorInfo.GetPointer());
        }
    }

    //
    // Release the interfaces to transfer ownership to
    // the Ole Automation DLL. This will happen when
    // xErrorInfo and xErrorRecords destruct, at the
    // exit point of this method.
    //

    return hrErr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostHResult, public
//
//  Synopsis:   Post an HRESULT to be looked up in ole-db sdk's error
//              collection OR CI provided error lookup service.
//
//  Arguments:  [e]     - CException object containing error code.
//              [piid]  - Interface where the error occurred.
//
//  Returns:    The incoming hrErr is echoed back to simplify error reporting
//              in the calling code. So the caller can simply say something like
//              "return PostHResult(E_INVALIDARG, &IID_ICommand);" instead of:
//              "PostHResult(E_INVALIDARG, &IID_ICommand); return E_INVALIDARG;".
//
//              This override allows for posting two error records in the case
//              where the SCODE is converted into a less informative error code
//              such as E_FAIL.
//
//  History:    01-04-97    DanLeg      Created
//----------------------------------------------------------------------------

HRESULT CCIOleDBError::PostHResult(CException &e, const IID & refiid)
{
    SCODE sc = e.GetErrorCode();
    SCODE scOLE = GetOleError(e);

    if ( sc != scOLE )
    {
        PostHResult( sc, refiid );
        sc = scOLE;
    }

    PostHResult( sc, refiid );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostParserError, public
//
//  Synopsis:   This method is used to post static strings and DISPPARAMS to
//              the error objects. The static strings are stored in the resource
//              fork, and thus an id needs to be specified. This method receives
//              in dwIds Monarch's error ids. Needs to change them to our
//              resource ids (dwIdPostError). dwIdPost error is marked with flag
//              (ERR_MONARCH_STATIC), so that GetErrorDescription may take the
//              proper parameters.
//
//              NOTE: If the error object is not our implementation of IID_IErrorInfo,
//              we will not be able to load IErrorRecord and add our records.
//
//  Arguments:  [hrErr]         - HRESULT to associate
//              [dwIds]         - string ID
//              [ppdispparams]  - dispatch params
//
//  Returns:    HResult indicating status
//              S_OK    | Success
//              E_FAIL  | OLE DB Error service object missing
//
//
//  History:    11-03-97    danleg      Created from Monarch
//----------------------------------------------------------------------------

HRESULT CCIOleDBError::PostParserError
    (
    HRESULT hrErr,              //@parm IN | HResult to associate
    DWORD dwIds,                //@parm IN | String id
    DISPPARAMS **ppdispparams   //@parm IN/OUT | Dispatch Params
    )
{
    SCODE               sc = S_OK;
    DWORD               dwIdPostError;

// Translation array from MONSQL values to IDS values
static const UINT s_rgTranslate[] = {
    IDS_MON_PARSE_ERR_2_PARAM,          // MONSQL_PARSE_ERROR w/ 2 parameter
    IDS_MON_PARSE_ERR_1_PARAM,          // MONSQL_PARSE_ERROR w/ 1 parameter
    IDS_MON_ILLEGAL_PASSTHROUGH,        // MONSQL_CITEXTTOSELECTTREE_FAILED
    IDS_MON_DEFAULT_ERROR,              // MONSQL_PARSE_STACK_OVERFLOW
    IDS_MON_DEFAULT_ERROR,              // MONSQL_CANNOT_BACKUP_PARSER
    IDS_MON_SEMI_COLON,                 // MONSQL_SEMI_COLON
    IDS_MON_ORDINAL_OUT_OF_RANGE,       // MONSQL_ORDINAL_OUT_OF_RANGE
    IDS_MON_VIEW_NOT_DEFINED,           // MONSQL_VIEW_NOT_DEFINED
    IDS_MON_BUILTIN_VIEW,               // MONSQL_BUILTIN_VIEW
    IDS_MON_COLUMN_NOT_DEFINED,         // MONSQL_COLUMN_NOT_DEFINED
    IDS_MON_OUT_OF_MEMORY,              // MONSQL_OUT_OF_MEMORY
    IDS_MON_SELECT_STAR,                // MONSQL_SELECT_STAR
    IDS_MON_OR_NOT,                     // MONSQL_OR_NOT
    IDS_MON_CANNOT_CONVERT,             // MONSQL_CANNOT_CONVERT
    IDS_MON_OUT_OF_RANGE,               // MONSQL_OUT_OF_RANGE
    IDS_MON_RELATIVE_INTERVAL,          // MONSQL_RELATIVE_INTERVAL
    IDS_MON_NOT_COLUMN_OF_VIEW,         // MONSQL_NOT_COLUMN_OF_VIEW
    IDS_MON_BUILTIN_PROPERTY,           // MONSQL_BUILTIN_PROPERTY
    IDS_MON_WEIGHT_OUT_OF_RANGE,        // MONSQL_WEIGHT_OUT_OF_RANGE
    IDS_MON_MATCH_STRING,               // MONSQL_MATCH_STRING
    IDS_MON_PROPERTY_NAME_IN_VIEW,      // MONSQL_PROPERTY_NAME_IN_VIEW
    IDS_MON_VIEW_ALREADY_DEFINED,       // MONSQL_VIEW_ALREADY_DEFINED
    IDS_MON_INVALID_CATALOG,            // MONSQL_INVALID_CATALOG
    };


    Win4Assert( ppdispparams );

    // special fixup for MONSQL_PARSE_ERROR
    if ( dwIds == MONSQL_PARSE_ERROR )
    {
        Win4Assert( *ppdispparams && (((*ppdispparams)->cArgs == 1) || ((*ppdispparams)->cArgs == 2)) );

        if ( ((*ppdispparams) != NULL) &&
             ((*ppdispparams)->cArgs == 2) )
        {
            dwIds = 0;  //Change to point to index of 2 parameter parse error
        }
    }

    if ( dwIds < NUMELEM( s_rgTranslate ) )
        dwIdPostError = s_rgTranslate[dwIds];
    else
        dwIdPostError= IDS_MON_DEFAULT_ERROR;

    sc = PostError(hrErr, IID_ICommandText, dwIdPostError, *ppdispparams);

    // free dispparams in case of error
    if ( (*ppdispparams) != NULL )
    {
        if ( ((*ppdispparams)->cArgs > 0) &&
             ((*ppdispparams)->rgvarg!= NULL) )
        {
            for (ULONG ul=0; ul<(*ppdispparams)->cArgs; ul++)
                VariantClear(&((*ppdispparams)->rgvarg[ul]));

            CoTaskMemFree(((*ppdispparams)->rgvarg));
            (*ppdispparams)->rgvarg= NULL;
            (*ppdispparams)->cArgs = 0;
        };

        CoTaskMemFree((*ppdispparams));
        *ppdispparams = NULL;
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::PostError, public
//
//  Synopsis:   This method is used to post static strings to the error objects.
//              The static strings are stored in the resource fork, and thus an
//              id needs to be specified.
//
//              @devnote If the error object is not our implementation of
//              IID_IErrorInfo, we will not be able to load IErrorRecord and add
//              our records.
//
//
//  Arguments:  [hrErr]         - HRESULT to associate
//              [refiid]        - IID of interface with error.
//              [dwIds]         - String id
//              [pdispparams]   - Parameters for the static string
//
//  Returns:    HResult indicating status
//              S_OK    | Success
//              E_FAIL  | OLE DB Error service object missing
//
//
//  History:    11-03-97    danleg      Created from Monarch
//----------------------------------------------------------------------------//-----------------------------------------------------------------------------
//
// @mfunc
// @rdesc HResult indicating status
//      @flags S_OK | Success
//      @flags E_FAIL | OLE DB Error service object missing
//
HRESULT CCIOleDBError::PostError
    (
    HRESULT     hrErr,
    const IID & refiid,
    DWORD       dwIds,
    DISPPARAMS* pdispparams
    )
{
    SCODE               sc = S_OK;
    ERRORINFO           ErrorInfo;
    IErrorInfo*         pIErrorInfo = NULL;
    IErrorRecords*      pIErrorRecords = NULL;

    // Obtain the error object or create a new one if none exists
    sc = GetErrorInterfaces( &pIErrorInfo, &pIErrorRecords );
    if ( FAILED(sc) )
        goto EXIT_PROCESS_ERRORS;

    // Assign static information across each error record added
    ErrorInfo.clsid = CLSID_CI_PROVIDER;
    ErrorInfo.hrError = hrErr;
    ErrorInfo.iid = refiid;
    ErrorInfo.dispid = NULL;
    ErrorInfo.dwMinor = 0;

    // Add the record to the Error Service Object
    sc = pIErrorRecords->AddErrorRecord( &ErrorInfo,
                                         dwIds,
                                         pdispparams,
                                         NULL,
                                         0 );
    if ( FAILED(sc) )
        goto EXIT_PROCESS_ERRORS;

    // Pass the error object to the Ole Automation DLL
    sc = SetErrorInfo(0, pIErrorInfo);

    // Release the interfaces to transfer ownership to
    // the Ole Automation DLL
EXIT_PROCESS_ERRORS:
    if ( pIErrorRecords )
        pIErrorRecords->Release();
    if ( pIErrorInfo )
        pIErrorInfo->Release();
    return sc;
}

//-----------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::NeedToSetError - private
//
//  Synopsis:   Determine if error needs to be set.
//
//  Arguments:  [scError]         - Error code to look for
//
//  Returns:    TRUE if the error needs to be set. FALSE, if it already
//              exists and has a valid description string.
//
//  Notes:
//
//  History:    15 Jan 1998     KrishnaN    Created
//              03-01-98        danleg      adopted from ixsso with few changes
//
//-----------------------------------------------------------------------------

BOOL CCIOleDBError::NeedToSetError
    (
    SCODE           scError,
    IErrorInfo *    pErrorInfo,
    IErrorRecords * pErrorRecords
    )
{
    BOOL fFound = FALSE;

    if ( 0 == pErrorInfo )
        return TRUE;

    XBStr xDescription;
    BSTR pDescription = xDescription.GetPointer();

    if (0 == pErrorRecords)
    {
        // No error records. Do we at least have the top level description set?
        // If so, that indicates an automation client called SetErrorInfo before us
        // and we should not overwrite them.
        pErrorInfo->GetDescription(&pDescription);
        fFound = (BOOL)(pDescription != 0);
    }
    else
    {
        ULONG cErrRecords;
        SCODE sc = pErrorRecords->GetRecordCount(&cErrRecords);
        Win4Assert(!fFound);

        // look for the target error code. stop when one is found
        ERRORINFO ErrorInfo;
        for (ULONG i = 0; i < cErrRecords; i++)
        {
            sc = pErrorRecords->GetBasicErrorInfo(i, &ErrorInfo);
            Win4Assert(S_OK == sc);

            if (scError == ErrorInfo.hrError)
            {
                pErrorInfo->GetDescription(&pDescription);
                fFound = (BOOL)(pDescription != 0);
                break;
            }
        }
    }

    if (!fFound)
        return TRUE;

    // we found the error code and it has a description.
    // no need to set this error again, but we have to
    // put this error info back so the client can find it.
    SetErrorInfo(0, pErrorInfo);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCIOleDBError::_GetErrorClassFact, private
//
//  Synopsis:   Initializes error class factory.
//
//  Returns:    Success code.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

SCODE CCIOleDBError::_GetErrorClassFact()
{
    SCODE sc = S_OK;

    CLock lck( _mutex );
    //
    // If we have failed once, we should not be
    // attempting again. No point in doing that.
    //

    if ( 0 == _pErrClassFact )
    {
        //
        // We don't have an error class factory.
        //

        sc = CoGetClassObject(CLSID_EXTENDEDERRORINFO,
                              CLSCTX_INPROC_SERVER,
                              NULL,
                              IID_IClassFactory,
                              (void **) &_pErrClassFact);

        if (FAILED(sc))
        {
            vqDebugOut((DEB_ITRACE, "No class factory is available "
                                    " for CLSID_EXTENDEDERROR.\n"));
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::QueryInterface, public
//
//  Synopsis:   Supports IID_IUnknown and IID_IErrorLookup
//
//  History:    28-Apr-97   KrishnaN    Created
//              01-30-98    danleg      E_INVALIDARG if ppvObject is bad
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::QueryInterface(REFIID riid, void **ppvObject)
{
    if ( !ppvObject )
        return E_INVALIDARG;

    if (IID_IUnknown == riid)
    {
        *ppvObject = (void *)((IUnknown *)this);
        AddRef();
        return S_OK;
    }
    else if (IID_IErrorLookup == riid)
    {
        *ppvObject = (void *)((IErrorLookup *)this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::AddRef, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CErrorLookup::AddRef()
{
    InterlockedIncrement(&_cRefs);

    return _cRefs;
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::Release, public
//
//  History:    17-Mar-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CErrorLookup::Release()
{
    Win4Assert(_cRefs > 0);
    LONG refCount = InterlockedDecrement(&_cRefs);

    if ( refCount <= 0 )
        delete this;

    return refCount;

}  //Release

// IErrorLookup methods

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::GetErrorDescription, public
//
//  Synopsis:   Composes the error description for the specifed error.
//
//  Arguments:  [hrError]         - Code returned by the method that caused
//                                  the error.
//              [dwLookupId]      - Provider-specific number of the error.
//              [pdispparams]     - Params of the error. If there are no
//                                  params, this is a NULL pointer.
//              [lcid]            - Locale ID for which to return the
//                                  description and the sources.
//              [pbstrSource]     - Pointer to memory in which to return a
//                                  pointer to the name of the component
//                                  that generated the error.
//              [pbstrDescription]- Pointer to memory in which to return a
//                                  string that describes the error.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::GetErrorDescription (HRESULT hrError,
                                                DWORD dwLookupId,
                                                DISPPARAMS* pdispparams,
                                                LCID lcid,
                                                BSTR* pbstrSource,
                                                BSTR* pbstrDescription)
{
    SCODE sc = S_OK;

    // Check the Arguments
    if( 0 == pbstrSource || 0 == pbstrDescription )
        return E_INVALIDARG;

    *pbstrSource = *pbstrDescription = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        //
        // If we encounter IDENTIFIER_SDK_ERROR, make sure we return S_OK;
        //
        BOOL fGetDescription = (IDENTIFIER_SDK_ERROR != dwLookupId);
        BOOL fGetSource = TRUE;

        XBStr xbstrDescription;
        XBStr xbstrSource;


        // We only support lookup of CI generated errors and those handled
        // by the default error lookup service!

        if ( (IDENTIFIER_SDK_ERROR != dwLookupId) && !IsCIError(hrError) )
        {
            if( IsParserError(dwLookupId) )
            {
                hrError = dwLookupId;
            }
            else
            {
                fGetDescription = fGetSource = FALSE;
                sc = DB_E_BADHRESULT;
            }
        }

        if (fGetSource)
        {

            // Fix for bug# 83593: Set source string even when the default
            // lookup service is providing the description

            xbstrSource.SetText( L"Microsoft OLE DB Provider for Indexing Service" );
        }


        if (fGetDescription)
        {
            DWORD_PTR rgdwArguments[2];
            DWORD dwFlags = FORMAT_MESSAGE_FROM_HMODULE;

            if (pdispparams)
            {
                dwFlags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
                Win4Assert(pdispparams->cArgs == 2 || pdispparams->cArgs == 1 || pdispparams->cArgs == 0);
                for (UINT c=0; c < pdispparams->cArgs; c++)
                {
                    rgdwArguments[c] = (DWORD_PTR)(LPWSTR)pdispparams->rgvarg[c].bstrVal;
                }
            }
            else
            {
                RtlZeroMemory( rgdwArguments, sizeof(rgdwArguments) );
            }

            //
            // Load the error string from the appropriate DLL
            //

            WCHAR wszBuffer[ERROR_MESSAGE_SIZE];

            //
            // Don't pass a specific lang id to FormatMessage since it will
            // fail if there's no message in that language. Instead set
            // the thread locale, which will get FormatMessage to use a search
            // algorithm to find a message of the appropriate language or
            // use a reasonable fallback msg if there's none.
            //

            LCID SaveLCID = GetThreadLocale();
            SetThreadLocale(lcid);

            // CLEANCODE: Since we could have differently named dlls (query.dll
            // or oquery.dll) we should be able to look up in the registry
            // and determine which one to get.  Or just get the module name.

            // All messages are in querymsg.mc, which is in query.dll.

            HMODULE hModule = GetModuleHandle(L"query.dll");

            if (! FormatMessage( dwFlags | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                                 hModule,
                                 hrError,
                                 0,
                                 wszBuffer,
                                 ERROR_MESSAGE_SIZE,
                                 (va_list*) rgdwArguments ) )
            {
                vqDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

                swprintf( wszBuffer,
                          L"Unable to format message for error 0x%X caught in Indexing Service.\n",
                          hrError );
            }

            SetThreadLocale(SaveLCID);

            //
            // Convert the loaded string to a BSTR
            //

            xbstrDescription.SetText(wszBuffer);
        }

        *pbstrSource = xbstrSource.GetPointer();
        *pbstrDescription = xbstrDescription.GetPointer();

        xbstrSource.Acquire();
        xbstrDescription.Acquire();
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "Exception %08x in CCIOleDBError::GetErrorDescription \n",
                     e.GetErrorCode() ));
        sc = GetOleError(e);
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::GetHelpInfo, public
//
//  Synopsis:   Composes the error description for the specifed error.
//
//  Arguments:  [hrError]       - Code returned by the method that caused
//                                the error.
//              [dwLookupId]    - Provider-specific number of the error.
//              [lcid]          - Locale Id for which to return the Help
//                                file path and Context ID.
//              [pbstrHelpFile] - Pointer to memory in which to return a
//                                pointer the fully path of the Help file.
//
//              [pdwHelpContext]- Pointer to memory in which to return the
//                                Help Context ID for the error.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::GetHelpInfo (HRESULT hrError,
                                        DWORD dwLookupId,
                                        LCID lcid,
                                        BSTR* pbstrHelpFile,
                                        DWORD* pdwHelpContext)
{
    if ( 0 == pbstrHelpFile || 0 == pdwHelpContext )
        return E_INVALIDARG;

    *pbstrHelpFile = 0;
    *pdwHelpContext = 0;

    //
    // Currently we do not return any help file
    // context or names, so we will just return S_OK
    //

    // NEWFEATURE: We can, if we choose to, return help file
    // and context for the query project.

    if ( lcid != GetUserDefaultLCID() )
        return DB_E_NOLOCALE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CErrorLookup::ReleaseErrors, public
//
//  Synopsis:   Releases dynamic errors.
//
//  Arguments:  [dwDynamicErrorId] - ID of the dynamic error info to release.
//
//  History:    28-Apr-97   KrishnaN   Created
//----------------------------------------------------------------------------

STDMETHODIMP CErrorLookup::ReleaseErrors (const DWORD dwDynamicErrorId)
{
    Win4Assert(!"Currently we don't support dynamic errors.");

    if (0 == dwDynamicErrorId)
        return E_INVALIDARG;

    //
    // We don't support dynamic errors, so nothing to do.
    //

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::CErrorLookupCF, public
//
//  Synopsis:   CErrorLookup class factory constructor
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

CErrorLookupCF::CErrorLookupCF()
        : _cRefs( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::~CErrorLookupCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

CErrorLookupCF::~CErrorLookupCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::QueryInterface, public
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    25-Mar-1997     KrishnaN    Created
//              01-31-98        danleg      E_INVALIDARG for bad ppvObject
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CErrorLookupCF::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    SCODE sc = S_OK;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOINTERFACE;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::AddRef, public
//
//  Synopsis:   Increments refcount
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CErrorLookupCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::Release, public
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CErrorLookupCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::CreateInstance, public
//
//  Synopsis:   Creates new CIndexer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CErrorLookupCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CErrorLookup *  pIUnk = 0;
    SCODE sc = S_OK;

    TRY
    {
        pIUnk = new CErrorLookup();
        sc = pIUnk->QueryInterface( riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH( CException, e )
    {
        Win4Assert( 0 == pIUnk );
        sc = GetOleError(e);
    }
    END_CATCH

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CErrorLookupCF::LockServer, public
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    25-Mar-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CErrorLookupCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\odbvarnt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       odbvarnt.cxx
//
//  Contents:   Helper class for PROPVARIANTs, OLE-DB variant types and
//              Automation variant types in tables
//
//  Classes:    COLEDBVariant - derives from CTableVariant
//
//  Functions:
//
//  History:    09 Jan 1998     VikasMan    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>
#include <odbvarnt.hxx>

#include <initguid.h>
#define DBINITCONSTANTS
#include <msdadc.h>     // oledb data conversion (IDataConvert) interface
#include <msdaguid.h>

#include "tabledbg.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     COLEDBVariant::OLEDBConvert, public.
//
//  Synopsis:   Data conversion routine, which uses the OLEDB data
//              conversion library (MSDADC.DLL) to do the conversion.
//
//  Arguments:  [pbDstBuf]     -- the Destination data buffer
//              [cbDstBuf]     -- the size of Dst. buffer
//              [vtDst]        -- the Destination type.
//              [rPool]        -- pool to use for destination buffers
//              [rcbDstLength] -- size of destination data
//              [xDataConvert] -- the OLEDB IDataConvert interface
//              [bPrecision]   -- The precision of the output data in bytes,
//                                if applicable. This argument is used when 
//                                converting to DBTYPE_NUMERIC data only.
//              [bScale]       -- The scale of the output data in bytes,
//                                if applicable. This argument is used when 
//                                converting to DBTYPE_NUMERIC data only.
//
//  Returns:    DBSTATUS_S_OK if conversion is successful, 
//              else other DBSTATUS values.
//
//  Notes:      pbDstBuf should have (enough) memory allocated, else
//              truncation can happen.
//
//              This routine is subdivided into 3 parts:
//                  - It checks first if we are dealing with Automation Vars.
//                  - Then it calls CTableVaraint::CopyOrCoerce to the job
//                  - If unsuccessful, it uses the OLE-DB library
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::OLEDBConvert(
                        BYTE *            pbDstBuf,
                        DBLENGTH          cbDstBuf,
                        VARTYPE           vtDst,
                        PVarAllocator &   rPool,
                        DBLENGTH &        rcbDstLength,
                        XInterface<IDataConvert>& xDataConvert,
                        BOOL             fExtTypes,  /* = TRUE */
                        BYTE             bPrecision, /* = 0 */
                        BYTE             bScale      /* = 0 */ ) const
{
    void* pbSrcBuf;
    ULONG cbSrcSize;
    DBTYPE dbtypeSrc, dbtypeDst;
    DBLENGTH cbDstBufNeeded;
    DBSTATUS DstStatus = DBSTATUS_E_CANTCONVERTVALUE;

    // Check if fExtTypes is false and we are dealing with automation variants
    if ( VT_VARIANT == vtDst || DBTYPE_PROPVARIANT == vtDst )
    {
        Win4Assert(cbDstBuf == sizeof PROPVARIANT);

        rcbDstLength = sizeof (PROPVARIANT);
        if ( ! IsArray( vt) && 
             ( fExtTypes || DBTYPE_PROPVARIANT == vtDst ||
               VT_BSTR == vt || (IsSimpleOAType( vt ) && ! IsVector( vt )) ) )
        {
            Copy( (CTableVariant*) pbDstBuf, rPool, (USHORT) VarDataSize() );
            DstStatus = DBSTATUS_S_OK;
        }
        else
        {
            DstStatus = _CopyToOAVariant( (VARIANT *) pbDstBuf, rPool );
        }

        if ( VT_EMPTY == vt )
            DstStatus = DBSTATUS_S_ISNULL;
    }
    else
    {
        // try converting using CTableVariant's CopyOrCoerce
        DstStatus = CopyOrCoerce( pbDstBuf,
                                cbDstBuf,
                                vtDst,
                                rcbDstLength,
                                rPool );
    }

    if ( DBStatusOK( DstStatus ))
    {
        // we are done here
        return DstStatus;
    }

    if (DBTYPE_HCHAPTER == vtDst)
    {
        if (VT_I4 == vt || VT_UI4 == vt)
        {
            * (ULONG *) pbDstBuf = lVal;
            DstStatus = DBSTATUS_S_OK;
        }

        return DstStatus;
    }

    // WORKAROUND: The following switch stmt is needed only until
    // OLEDB library supports VT_FILETIME. Once it does that,
    // we can get rid of this.

    switch ( vtDst )
    {
    case VT_DATE:
        // allow coercions from I8, UI8, R8, and FILETIME

        if (VT_I8 == vt || VT_UI8 == vt)
        {
            * (LONGLONG *) pbDstBuf = hVal.QuadPart;
        }
        else if (VT_R8 == vt)
        {
            * (DATE *) pbDstBuf = dblVal;
        }
        else
        {
            DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        }
        rcbDstLength = sizeof (DATE);
        break;

    case VT_FILETIME:
        // allow coercions from I8, UI8, and DATE

        if (VT_I8 == vt || VT_UI8 == vt)
        {
            * (LONGLONG *) pbDstBuf = hVal.QuadPart;
        }
        else
        {
            DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        }
        rcbDstLength = sizeof (FILETIME);
        break;

    case DBTYPE_DBDATE:
        DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        rcbDstLength = sizeof (DBDATE);
        break;

    case DBTYPE_DBTIME:
        DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        rcbDstLength = sizeof (DBTIME);
        break;

    case DBTYPE_DBTIMESTAMP:
        DstStatus = _StoreDate(pbDstBuf, cbDstBuf, vtDst);
        rcbDstLength = sizeof (DBTIMESTAMP);
        break;
    }

    if ( DBStatusOK( DstStatus ))
    {
        // we are done here
        return DstStatus;
    }

    tbDebugOut(( DEB_ITRACE, "COLEDBVaraint::OLEDBConvert - Using OLEDB library for conversion\n" ));

    // this looks like a job for ole-db

    // check if we have the IDataConvert interface
    if ( xDataConvert.IsNull( ) )
    {
        // let's get it then
        if ( !_GetIDataConvert( xDataConvert ) )
        {
            // for some reason we could not get the IDataConvert interface
            return DBSTATUS_E_CANTCONVERTVALUE;
        }
    }

    // get the source data pointer
    pbSrcBuf = _GetDataPointer();
    if ( 0 == pbSrcBuf )
    {
        tbDebugOut(( DEB_ERROR, "OLEDBConvert - _GetDataPointer returned NULL\n" ));

        return DBSTATUS_E_CANTCONVERTVALUE;
    }

    // get the source data size
    cbSrcSize = VarDataSize();

    // get the OLEDB source type
    SCODE sc = _GetOLEDBType( vt, dbtypeSrc );
    if ( S_OK != sc )
    {
        // can't use the OLEDB Conversion library
        tbDebugOut(( DEB_ERROR,
                     "OLEDBConvert - _GetOLEDBType returned error 0x%x for type %x\n",
                     sc, vt ));
        return DBSTATUS_E_CANTCONVERTVALUE;
    }


    // the destination type has to be an OLE-DB type
    dbtypeDst = vtDst;

    // get the needed Destination size
    sc = xDataConvert->GetConversionSize( dbtypeSrc,
                                          dbtypeDst,
                                          0,
                                          &cbDstBufNeeded,
                                          pbSrcBuf );

    if ( sc != S_OK )
    {
        tbDebugOut(( DEB_ITRACE,
                     "OLEDBConvert - GetConversionSize returned error 0x%x\n",
                     sc ));
        return DBSTATUS_E_CANTCONVERTVALUE;
    }

    BYTE* pbDest = 0;

    // we need to allocate memory if ...

    if ( ( IsLPWSTR( dbtypeDst ) ) ||
         ( IsLPSTR( dbtypeDst ) ) ||
         ( (DBTYPE_BYREF | DBTYPE_WSTR) == dbtypeDst ) ||
         ( (DBTYPE_BYREF | DBTYPE_STR) == dbtypeDst )
       )
    {
        // If we hit this assert, then we got a few things to think about

        Win4Assert( !(IsLPWSTR( dbtypeDst ) || IsLPSTR( dbtypeDst )) );

        pbDest = (BYTE*) rPool.Allocate( (ULONG) cbDstBufNeeded );
    }
    else if ( DBTYPE_BSTR == dbtypeDst )
    {
        pbDest = (BYTE*) rPool.AllocBSTR( (ULONG) cbDstBufNeeded );
    }
    else
    {
        // bogus assert
        // Win4Assert ( (dbtypeDst & DBTYPE_BYREF) == 0 );

        // memory is already allocated
        // use the size which is less
        // if cbDstBuf is less than cbDstBufNeeded, truncation might happen
        cbDstBufNeeded = ( cbDstBufNeeded < cbDstBuf ? cbDstBufNeeded : cbDstBuf );
    }

    // do the conversion
    sc = xDataConvert->DataConvert( dbtypeSrc,
                                      dbtypeDst,
                                      cbSrcSize,
                                      &rcbDstLength,
                                      pbSrcBuf,
                                      pbDest ? (void*)&pbDest : pbDstBuf,
                                      cbDstBufNeeded,
                                      DstStatus,
                                      &DstStatus,
                                      bPrecision,
                                      bScale,
                                      DBDATACONVERT_DEFAULT); 

    if ( sc != S_OK )
    {
        tbDebugOut(( DEB_ITRACE,
                     "OLEDBConvert - DataConvert returned error 0x%x\n",
                     sc ));
        return DBSTATUS_E_CANTCONVERTVALUE;
    }

    // if memory was allocated, put that ptr in pbDstBuf
    if ( pbDest )
    {
        *((BYTE**)(pbDstBuf)) = pbDest;
    }

    return DstStatus;
}

//+-------------------------------------------------------------------------
//
//  Method:     COLEDBVariant::GetDstLength, public.
//
//  Synopsis:   Returns the length required after the conversion without
//              actually doing the conversion.
//
//  History:    10-12-98        DanLeg      Created
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::GetDstLength( 
                         XInterface<IDataConvert>& xDataConvert, 
                         DBTYPE                    dbtypeDst,
                         DBLENGTH &                   rcbDstLen )
{
    SCODE sc = S_OK;
    DBTYPE dbtypeSrc;
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    sc = _GetOLEDBType( vt, dbtypeSrc );
    
    if ( S_OK == sc )
    {
        if ( xDataConvert.IsNull( ) )
        {
            if ( !_GetIDataConvert( xDataConvert ) )
                sc = S_FALSE;
        }

        if ( S_OK == sc )
        {
            void * pbSrcBuf = _GetDataPointer();
            sc = xDataConvert->GetConversionSize( dbtypeSrc,
                                                  dbtypeDst, 
                                                  0,
                                                  &rcbDstLen,
                                                  pbSrcBuf );
        }
    }

    if ( S_OK != sc )
    {
        tbDebugOut(( DEB_ITRACE,
                     "OLEDBConvert - GetConversionSize returned error 0x%x\n",
                     sc ));
        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
    }

    return DstStatus;
}
                                      

//+-------------------------------------------------------------------------
//
//  Method:     COLEDBVariant::_GetOLEDBType, private.
//
//  Synopsis:   Returns the OLEDB type equivalent of Variant type.
//
//  Arguments:  [vt] -- the source varaint type.
//              [dbtype] -- the equivalent oledb type.
//
//  Returns:    S_OK if equivalent OLE DB type exists, 
//              else S_FALSE.
//
//  Notes:      Does not handle vectors
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------

inline SCODE COLEDBVariant::_GetOLEDBType( VARTYPE vt, DBTYPE& dbtype ) const
{
    SCODE sc = S_OK;

    switch ( vt & ~VT_BYREF )
    {
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_FILETIME:   // WORKAROUND: Waiting on OLE DB Conv lib to handle this case - 01.12.98
    case VT_BOOL:
    case VT_ERROR:
    case VT_CLSID:
    case VT_VARIANT:
    case VT_DECIMAL:

    case VT_VECTOR | VT_I1:
    case VT_VECTOR | VT_UI1:
    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_FILETIME:   // WORKAROUND: Waiting on OLE DB Conv lib to handle this case - 01.12.98
    case VT_VECTOR | VT_BOOL:
    case VT_VECTOR | VT_ERROR:
    case VT_VECTOR | VT_CLSID:
    case VT_VECTOR | VT_VARIANT:

    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_I8:
    case VT_ARRAY | VT_UI8:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_DECIMAL:

        // In all the above cases, the DBTYPE has same value as
        // VARIANT type
    case DBTYPE_NUMERIC:
    case DBTYPE_DBDATE:
    case DBTYPE_DBTIME:
    case DBTYPE_DBTIMESTAMP:
    case DBTYPE_HCHAPTER:
    case DBTYPE_BYTES:
    case DBTYPE_VARNUMERIC:
        // The above are OLEDB types only. So no conversion needed.
        dbtype = vt;
        break;

    case VT_LPSTR:
    case DBTYPE_STR:
        dbtype = DBTYPE_STR;
        break;

    case VT_LPWSTR:
    case DBTYPE_WSTR:
        dbtype = DBTYPE_WSTR;
        break;

    case VT_BLOB:
        dbtype = VT_VECTOR | VT_UI1;
        break;

    case VT_INT:
        dbtype = VT_I4;
        break;

    case VT_UINT:
        dbtype = VT_UI4;
        break;

    case VT_ARRAY | VT_INT:
        dbtype = VT_ARRAY | VT_I4;
        break;

    case VT_ARRAY | VT_UINT:
        dbtype = VT_ARRAY | VT_UI4;
        break;

    // SPECDEVIATION: What about VT_CF ??? (handled partially in base class)

    default:
        // default case: all types for which there is no equivalent
        // OLE DB type - VT_CF, VT_BLOBOBJECT,
        // VT_STREAM, VT_STREAMED_OBJECT, VT_STORAGE, VT_STORED_OBJECT,
        // VT_DISPATCH, VT_UNKNOWN,
        sc = S_FALSE;
        break;
    }
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_GetDataPointer, private
//
//  Synopsis:   Depending on the type of vt, returns the data pointer
//
//  Arguments:  -none-
//
//  Returns:    Returns the pointer to data in the PropVariant
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------
inline void* COLEDBVariant::_GetDataPointer() const
{
    if (vt & VT_VECTOR)
        return (void*)&cal;

    if (vt & VT_ARRAY)
        return (void*) parray;

    void* pDataPtr = 0;

    switch ( vt )
    {
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_CLSID:
    case VT_CF:
        // all pointer values
        pDataPtr = (void*) pszVal;
        break;

    case VT_BSTR:
        // need address of bstr ptr
        pDataPtr = (void*) &bstrVal;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        pDataPtr = (void*) &blob;
        break;

    case VT_DECIMAL:
        pDataPtr = (void*) this;
        break;

    // cases which we do not handle
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:
    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_DISPATCH:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_VOID:
        pDataPtr = 0;
        break;

    // Rest of the stuff
    default:
        pDataPtr = (void*) &bVal;
        break;
    }

    return pDataPtr;
}


//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_CopyToOAVariant, private
//
//  Synopsis:   Copy table data between a table variant structure and
//              an Ole automation variant.  Automation variants have a
//              restricted set of usable types and vectors must be converted
//              to safearrays.
//
//  Arguments:  [pDest]    -- pointer to destination variant
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  History:    09 Jan 1998     VikasMan  Created
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_CopyToOAVariant( VARIANT *         pDest,
                                          PVarAllocator &   rPool) const
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    switch (vt)
    {
    case VT_LPSTR:
    case VT_LPWSTR:
    {
        DBLENGTH ulTemp;
        pDest->vt = VT_BSTR;
        DstStatus = _StoreString( (BYTE *)&(pDest->bstrVal),
                                  sizeof (BSTR),
                                  VT_BSTR,
                                  ulTemp,
                                  rPool);
        break;
    }

    case VT_I8:
    case VT_UI8:
        DstStatus = _StoreDecimal( &(pDest->decVal) );
        pDest->vt = VT_DECIMAL;
        break;

    case VT_I1:
        DstStatus = _StoreIntegerSignedToUnSigned( VT_UI1, &(pDest->bVal) );
        pDest->vt = VT_UI1;
        break;

    case VT_UI2:
        if (uiVal <= SHRT_MAX)
        {
            DstStatus = _StoreIntegerUnSignedToSigned( VT_I2, (BYTE*)&(pDest->iVal) );
            pDest->vt = VT_I2;
        }
        else
        {
            DstStatus = _StoreIntegerUnSignedToSigned( VT_I4, (BYTE*)&(pDest->lVal) );
            pDest->vt = VT_I4;
        }
        break;

    case VT_UI4:
        if (ulVal <= LONG_MAX)
        {
            DstStatus = _StoreIntegerUnSignedToSigned( VT_I4, (BYTE*)&(pDest->lVal) );
            pDest->vt = VT_I4;
        }
        else
        {
            DstStatus = _StoreDecimal( &(pDest->decVal) );
            pDest->vt = VT_DECIMAL;
        }
        break;

    case VT_FILETIME:
        DstStatus = _StoreDate( (BYTE*)&(pDest->date),
                                sizeof pDest->date,
                                VT_DATE );
        pDest->vt = VT_DATE;
        break;

    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):
    case (VT_VECTOR | VT_ERROR): 
    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_DECIMAL):
        Win4Assert( IsSimpleOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreSimpleTypeArray( &(pDest->parray));
        pDest->vt = (vt & VT_TYPEMASK) | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_UI4):  // could step thru to see if I4 is big enough
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI8):
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreDecimalArray( &(pDest->parray));
        pDest->vt = VT_DECIMAL | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_UI2):  // could step thru to detect if I2 is big enough
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreIntegerArray( VT_I4, &(pDest->parray));
        pDest->vt = VT_I4 | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_I1):  // should step thru to detect if UI1 is big enough
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreIntegerArray( VT_UI1, &(pDest->parray));
        pDest->vt = VT_UI1 | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_LPSTR):  // byref/vector mutually exclusive
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreLPSTRArray( &(pDest->parray), rPool );
        pDest->vt = VT_BSTR | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_LPWSTR):
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreLPWSTRArray( &(pDest->parray), rPool );
        pDest->vt = VT_BSTR | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_BSTR):
        Win4Assert( IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreBSTRArray( &(pDest->parray), rPool );
        pDest->vt = VT_BSTR | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_VARIANT):
        Win4Assert( IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreVariantArray( &(pDest->parray), rPool );
        pDest->vt = VT_VARIANT | VT_ARRAY;
        break;

    case (VT_VECTOR | VT_FILETIME):
        Win4Assert( !IsOAType(vt & VT_TYPEMASK));
        Win4Assert( CanBeVectorType(vt & VT_TYPEMASK));
        DstStatus = _StoreDateArray( &(pDest->parray) );
        pDest->vt = VT_DATE | VT_ARRAY;
        break;

    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_I8:
    case VT_ARRAY | VT_UI8:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_VARIANT:
    case VT_ARRAY | VT_DECIMAL:
      {
        SAFEARRAY * psa = 0;
        SCODE sc = SafeArrayCopy( parray, &psa );
        Win4Assert( E_INVALIDARG != sc );
        Win4Assert( E_OUTOFMEMORY == sc || psa != 0 );
        if (S_OK != sc)
        {
            THROW(CException(E_OUTOFMEMORY));
        }
        else
        {
            pDest->vt = vt;
            pDest->parray = psa;
        }
      }
        break;

    case VT_CLSID:   // no equivalent in OA variant
    case VT_CF:      // no equivalent in OA variant
    default:
        Win4Assert( !(VT_ARRAY & vt) ); // should be handled elsewhere
        Win4Assert( !IsOAType(vt) );    // should be handled elsewhere
        Win4Assert(CanBeVectorType(vt & VT_TYPEMASK) || !(VT_VECTOR & vt));
        tbDebugOut(( DEB_WARN, "COLEDBVariant::CopyToOAVariant - bad variant type %d \n", vt ));

        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
    }

    if ( !StatusSuccess(DstStatus) ||
         (DBSTATUS_S_ISNULL == DstStatus && pDest->vt != VT_NULL) )
        pDest->vt = VT_EMPTY;

    return DstStatus;
}


//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreSimpleTypeArray, private
//
//  Synopsis:   Copy vector of simple OA types to safearray of same type
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      None of the simple types require memory allocation.
//              Throws if safearray itself cannot be alloc'd
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreSimpleTypeArray(SAFEARRAY **  pbDstBuf) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY *sa = SafeArrayCreateVector(vt & VT_TYPEMASK, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    USHORT cbSize, cbAlign, rgFlags;
    VartypeInfo(vt & VT_TYPEMASK, cbSize, cbAlign, rgFlags);
    BYTE * pBase = (BYTE *)&(caul.pElems[0]);
    for (LONG lElem = 0; lElem < (LONG)(caul.cElems); lElem++)
    {
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, pBase + (cbSize * lElem));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();

    return DBSTATUS_S_OK;

}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreDecimalArray, private
//
//  Synopsis:   Copy vector to decimal safearray
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_UI4|VT_VECTOR, 
//              VT_I8|VT_VECTOR, or VT_UI8|VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreDecimalArray( SAFEARRAY ** pbDstBuf ) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK; // status of last conversion
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
                                           // or if no errors, DBSTATUS_S code
                                           // of last item with any trouble converting.

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_DECIMAL, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)caul.cElems && StatusSuccess(dbStatus); lElem++)
    {
        DECIMAL dec;
        dbStatus = _StoreDecimal( &dec, lElem);
        if (DBSTATUS_S_OK != dbStatus)
            dbStatusRet = dbStatus;  // save last non-zero status
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, &dec);
        Win4Assert ( SUCCEEDED(sc) );
    }
    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreIntegerArray, private
//
//  Synopsis:   Copy vector of integers to safearray of integers
//
//  Arguments:  [vtDst]         -- destination safearray type
//              [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be an int type | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------
DBSTATUS COLEDBVariant::_StoreIntegerArray(VARTYPE          vtDst,
                                           SAFEARRAY **     pbDstBuf) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
    // or if no errors, DBSTATUS_S code
    // of last item with any trouble converting.

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(vtDst, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)caul.cElems && StatusSuccess(dbStatus); lElem++)
    {
        LONGLONG iInt; // size of longest int - to use as buffer
        dbStatus = _StoreInteger( vtDst, (BYTE *)&iInt, lElem);
        if (DBSTATUS_S_OK != dbStatus)
            dbStatusRet = dbStatus;  // save last non-zero status
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, &iInt); 
        Win4Assert ( SUCCEEDED(sc) );
    }
    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreLPSTRArray, private
//
//  Synopsis:   Copy LPSTR vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreLPSTRArray(
                                        SAFEARRAY **            pbDstBuf,
                                        PVarAllocator &  rPool) const
{
    if ( 0 == calpstr.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;

    // CLEANCODE - add to PVarAllocator?

    SAFEARRAY * sa = SafeArrayCreateVector(VT_BSTR, 0, calpstr.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));

    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)(calpstr).cElems && StatusSuccess(dbStatus); lElem++)
    {
        int cwc = MultiByteToWideChar(ulCoercionCodePage,0,
                                      calpstr.pElems[lElem],-1,0,0);
        if (0 == cwc)
        {
            dbStatus = DBSTATUS_E_CANTCONVERTVALUE; // something odd...
        }
        else
        {
            XArray<WCHAR> wcsDest( cwc );
            MultiByteToWideChar(ulCoercionCodePage, 0,
                                calpstr.pElems[lElem], -1,  wcsDest.Get(), cwc);

            BSTR bstrDest = (BSTR) rPool.CopyBSTR((cwc-1)*sizeof (OLECHAR),
                                                  wcsDest.Get());

            SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, (void *)rPool.PointerToOffset(bstrDest));
            rPool.FreeBSTR(bstrDest);

            if (E_OUTOFMEMORY == sc)
                THROW(CException(E_OUTOFMEMORY));
            Win4Assert ( SUCCEEDED(sc) );
        }
    }

    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }


    return dbStatus;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreLPWSTRArray, private
//
//  Synopsis:   Copy LPWSTR vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreLPWSTRArray(
                                         SAFEARRAY **          pbDstBuf,
                                         PVarAllocator &  rPool) const
{
    if ( 0 == calpwstr.cElems )
        return DBSTATUS_S_ISNULL;

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_BSTR, 0, calpwstr.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));

    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)(calpwstr.cElems); lElem++)
    {
        BSTR bstrDest = (BSTR) rPool.CopyBSTR( wcslen(calpwstr.pElems[lElem])  * sizeof(WCHAR),
                                               calpwstr.pElems[lElem] );
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, (void *)rPool.PointerToOffset(bstrDest));
        rPool.FreeBSTR(bstrDest);

        if (E_OUTOFMEMORY == sc)
            THROW(CException(E_OUTOFMEMORY));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();
    return DBSTATUS_S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreBSTRArray, private
//
//  Synopsis:   Copy BSTR vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_BSTR | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreBSTRArray(
                                       SAFEARRAY **           pbDstBuf,
                                       PVarAllocator &  rPool) const
{
    if ( 0 == cabstr.cElems )
        return DBSTATUS_S_ISNULL;

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_BSTR, 0, cabstr.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));

    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)cabstr.cElems; lElem++)
    {
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, cabstr.pElems[lElem]);
        if (E_OUTOFMEMORY == sc)
            THROW(CException(E_OUTOFMEMORY));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();

    return DBSTATUS_S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreVariantArray, private
//
//  Synopsis:   Copy variant vector to safearray 
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [rPool]    -- pool to use for destination buffers
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_VARIANT | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreVariantArray(
                                          SAFEARRAY **           pbDstBuf,
                                          PVarAllocator &  rPool) const
{
    if ( 0 == capropvar.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
    // or if no errors, DBSTATUS_S code
    // of last item with any trouble converting.

    Win4Assert(vt == (VT_VECTOR | VT_VARIANT));

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_VARIANT, 0, capropvar.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);

    for (LONG lElem = 0; lElem < (LONG)(capropvar.cElems) && StatusSuccess(dbStatus); lElem++)
    {
        COLEDBVariant tblVariant;
        if (IsOAType(capropvar.pElems[lElem].vt))
        {
            ((CTableVariant &)capropvar.pElems[lElem]).Copy(&tblVariant,
                                                            rPool,
                                                            (USHORT)((CTableVariant &)capropvar.pElems[lElem]).VarDataSize(),
                                                            0); 
        }
        else  // convert variant to an OA type
        {
            dbStatus = ((COLEDBVariant &)capropvar.pElems[lElem])._CopyToOAVariant( (VARIANT *)&tblVariant, rPool);
            if (DBSTATUS_S_OK != dbStatus)
                dbStatusRet = dbStatus;  // save last non-zero status

        }
        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, (PROPVARIANT *)&tblVariant);
        if (E_OUTOFMEMORY == sc)
            THROW(CException(E_OUTOFMEMORY));
        Win4Assert ( SUCCEEDED(sc) );
    }

    *pbDstBuf = xsa.Acquire();
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreDateArray, private
//
//  Synopsis:   Copy date vector to safearray of dates
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be VT_DATE | VT_VECTOR.
//
//  History:    09 Apr 1997     EmilyB      Created
//              09 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreDateArray(SAFEARRAY **  pbDstBuf) const
{
    if ( 0 == caul.cElems )
        return DBSTATUS_S_ISNULL;

    DBSTATUS dbStatus = DBSTATUS_S_OK;
    DBSTATUS dbStatusRet  = DBSTATUS_S_OK; // error code of last conversion, 
    // or if no errors, DBSTATUS_S code
    // of last item with any trouble converting.

    // CLEANCODE - add to PVarAllocator?
    SAFEARRAY * sa = SafeArrayCreateVector(VT_DATE, 0, caul.cElems);
    if (0 == sa)
        THROW(CException(E_OUTOFMEMORY));
    XSafeArray xsa(sa);


    for (LONG lElem = 0; lElem < (LONG)(caul.cElems) && StatusSuccess(dbStatus); lElem++)
    {
        DATE date;
        dbStatus = _StoreDate( (BYTE *)&date, sizeof(date), VT_DATE, lElem);
        if (DBSTATUS_S_OK != dbStatus)
            dbStatusRet = dbStatus;  // save last non-zero status

        SCODE sc = SafeArrayPutElement(xsa.Get(), &lElem, &date);
        Win4Assert ( SUCCEEDED(sc) );
    }
    if (StatusSuccess(dbStatus))
    {
        *pbDstBuf = xsa.Acquire();
    }
    return dbStatusRet;
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_StoreDate, private
//
//  Synopsis:   Copy variant date/time data, coerce if possible
//
//  Arguments:  [pbDstBuf]      -- destination buffer
//              [cbDstBuf]      -- size of destination buffer
//              [vtDst]         -- data type of the dest
//              [lElem]         -- element of vector to convert
//
//  Returns:    status for copy
//
//  Notes:      Expects the 'this' data type to be either VT_FILETIME or
//              VT_DATE.  Expects the vtDst to be VT_FILETIME, VT_DATE,
//              DBTYPE_DBDATE, DBTYPE_DBTIME or DBTYPE_DBTIMESTAMP.
//
//  History:    31 Jan 1997     AlanW       Created
//              13 Jan 1998     VikasMan    Moved from CTableVariant class 
//                                          to here
//
//--------------------------------------------------------------------------

DBSTATUS COLEDBVariant::_StoreDate(
                                  BYTE *           pbDstBuf,
                                  DBLENGTH         cbDstBuf,
                                  VARTYPE          vtDst, 
                                  LONG             lElem) const
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    SYSTEMTIME stUTC;

    //
    // Convert the input date into a common form: GMT SYSTEMTIME.
    //
    if (VT_DATE == vt)
    {
        if (! VariantTimeToSystemTime(date, &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else if ((VT_DATE|VT_VECTOR)== vt)
    {
        if (! VariantTimeToSystemTime(cadate.pElems[lElem], &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else if (VT_FILETIME == vt)
    {
        // do not do local time conversion
        if (! FileTimeToSystemTime((LPFILETIME) &hVal.QuadPart, &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else if ((VT_FILETIME|VT_VECTOR) == vt)
    {
        // do not do local time conversion
        if (! FileTimeToSystemTime(&cafiletime.pElems[lElem], &stUTC) )
            return DBSTATUS_E_DATAOVERFLOW;
    }
    else
        return DBSTATUS_E_CANTCONVERTVALUE;

    switch (vtDst)
    {
    case VT_DATE:
        DATE dosDate;
        if (! SystemTimeToVariantTime(&stUTC, &dosDate) )
            return DBSTATUS_E_DATAOVERFLOW;

        Win4Assert( cbDstBuf >= sizeof DATE );
        RtlCopyMemory(pbDstBuf, &dosDate, sizeof DATE);
        break;

    case VT_FILETIME:
        FILETIME ftUTC;
        if (! SystemTimeToFileTime(&stUTC, &ftUTC) )
            return DBSTATUS_E_DATAOVERFLOW;

        Win4Assert( cbDstBuf >= sizeof FILETIME );
        RtlCopyMemory(pbDstBuf, &ftUTC, sizeof FILETIME);
        break;

    case DBTYPE_DBTIMESTAMP:
        {
            // does not use local time
            DBTIMESTAMP dbUTC;
            dbUTC.year =  stUTC.wYear;
            dbUTC.month = stUTC.wMonth;
            dbUTC.day =   stUTC.wDay;
            dbUTC.hour =  stUTC.wHour;
            dbUTC.minute = stUTC.wMinute;
            dbUTC.second = stUTC.wSecond;
            dbUTC.fraction = stUTC.wMilliseconds * 1000000;

            Win4Assert( cbDstBuf >= sizeof dbUTC );
            RtlCopyMemory(pbDstBuf, &dbUTC, sizeof dbUTC);
        }
        break;

    case DBTYPE_DBDATE:
        {
            DBDATE dbUTC;
            dbUTC.year =  stUTC.wYear;
            dbUTC.month = stUTC.wMonth;
            dbUTC.day =   stUTC.wDay;

            Win4Assert( cbDstBuf >= sizeof dbUTC );
            RtlCopyMemory(pbDstBuf, &dbUTC, sizeof dbUTC);
        }
        break;

    case DBTYPE_DBTIME:
        {
            DBTIME dbUTC;
            dbUTC.hour =  stUTC.wHour;
            dbUTC.minute = stUTC.wMinute;
            dbUTC.second = stUTC.wSecond;

            Win4Assert( cbDstBuf >= sizeof dbUTC );
            RtlCopyMemory(pbDstBuf, &dbUTC, sizeof dbUTC);
        }
        break;

    default:
        DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        tbDebugOut(( DEB_WARN,
                     "_StoreDate - Unexpected dest storage type %4x\n",
                     vtDst));
        break;
    }

    return DstStatus;
} //_StoreDate

//+---------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::CanConvertType, static public
//
//  Synopsis:   Indicate whether a type conversion is valid. Uses the OLEDB
//              Data Conversion Library.
//
//  Arguments:  [wFromType]  -- source type
//              [wToType]    -- destination type
//              [xDataConvert] --   OLEDB IDataConvert interface pointer
//
//  Returns:    TRUE if the conversion is available, FALSE otherwise.
//
//  History:    13 Jan 98      VikasMan Created
//
//----------------------------------------------------------------------------

BOOL COLEDBVariant::CanConvertType(
    DBTYPE wFromType,
    DBTYPE wToType,
    XInterface<IDataConvert>& xDataConvert)
{
    if ( xDataConvert.IsNull( ) )
    {
        // use COLEDBVariant's helper function to get the IDataConvert ptr
        if ( !_GetIDataConvert( xDataConvert ) )
        {
            // bail out
            return FALSE;
        }
    }

    SCODE sc = xDataConvert->CanConvert( wFromType, wToType );
    if ( sc != S_OK && sc != S_FALSE )
    {
        QUIETTHROW(CException(sc));   // bad type
    }

    return ( sc == S_OK );
}


//+---------------------------------------------------------------------------
//
//  Member:     COLEDBVariant::_GetIDataConvert, static private
//
//  Synopsis:   Gets the IDataConvert interface
//
//  Arguments:  [xDataConvert] --   OLEDB IDataConvert interface pointer
//
//  Returns:    TRUE if the successful, else FALSE
//
//  Notes:      Make sure thet xDataConvert is null before calling this func.
//
//  History:    13 Jan 98      VikasMan Created
//
//----------------------------------------------------------------------------

inline
BOOL COLEDBVariant::_GetIDataConvert( XInterface<IDataConvert>& xDataConvert )
{
    Win4Assert( xDataConvert.IsNull( ) );

    SCODE sc = CoCreateInstance( CLSID_OLEDB_CONVERSIONLIBRARY,
                                 NULL,
                                 CLSCTX_SERVER,
                                 IID_IDataConvert,
                                 xDataConvert.GetQIPointer( ) );

    if ( FAILED(sc) )
    {
        // for some reason we could not get the IDataConvert interface
        tbDebugOut(( DEB_ERROR,
              "_GetIDataConvert - Couldn't get IDataConvert interface %x\n", sc ));
        return FALSE;
    }

    // Set the OLEDB ver to 2.00

    XInterface<IDCInfo> xIDCInfo;
    DCINFO rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0200}}};

    sc = xDataConvert->QueryInterface( IID_IDCInfo, xIDCInfo.GetQIPointer( ) );
    if ( SUCCEEDED(sc) )
    {
        sc = xIDCInfo->SetInfo( NUMELEM(rgInfo), rgInfo );
    }

    if ( FAILED(sc) )
    {
        tbDebugOut(( DEB_ERROR,
            "_GetIDataConvert - Can't set OLEDB ver to 2.0. Error: 0x%x\n",
                     sc));
        Win4Assert( ! "Failed to set OLEDB conversion library version!" );
        xDataConvert.Free();
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\conpt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       conpt.cxx
//
//  Contents:   connection point / notification code for cursors
//
//  Classes:    CConnectionPointBase, CConnectionPointContainer
//
//  History:      7 Oct 1994    Dlee    Created
//               12 Feb 1998    AlanW   Generalized
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <conpt.hxx>

#include "tabledbg.hxx"

// Max. connections per connection point. Should be enough for any application!
const maxConnections = 20;

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on container object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IConnectionPoint == riid )
    {
        *ppvObject = (void *) (IConnectionPoint *) this;
    }
    else if ( IID_IUnknown == riid )
    {
        *ppvObject = (void *) (IUnknown *) this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::AddRef, public
//
//  Synopsis:   Increments ref. count, or delegates to containing object
//
//  Returns:    ULONG
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointBase::AddRef()
{
    if (_pIContrUnk)
        return _pIContrUnk->AddRef( );
    else
    {
        tbDebugOut(( DEB_NOTIFY, "conpt: addref\n" ));
        return InterlockedIncrement( (long *) &_cRefs );
    }
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Release, public
//
//  Synopsis:   Decrements ref. count, or delegates to containing object
//
//  Returns:    ULONG
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointBase::Release()
{
    if (_pIContrUnk)
        return _pIContrUnk->Release( );
    else
    {
        long cRefs = InterlockedDecrement((long *) &_cRefs);
    
        tbDebugOut(( DEB_NOTIFY, "conpt: release, new crefs: %lx\n", _cRefs ));
    
        // If no references, make sure container doesn't know about me anymore
    
        if ( 0 == cRefs )
        {
            Win4Assert( 0 == _pContainer );

            #if 0 // Note: no sense trying to avoid an AV for bad client code
                if ( 0 != _pContainer )
                {
                    // need to have been disconnected; must be an excess release
                    // from client
                    Disconnect();
                }
            #endif // 0
            delete this;
        }
    
        return cRefs;
    }
} //Release

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::GetConnectionInterface, public
//
//  Synopsis:   returns the IID of the callback notification object
//
//  Arguments:  [piid]        -- interface ID
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::GetConnectionInterface(IID * piid)
{
    if ( 0 == piid )
        return E_POINTER;

    *piid = _iidSink;
    return S_OK;
} //GetConnectionInterface

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::GetConnectionPointContainer, public
//
//  Synopsis:   returns the container that spawned the connection point
//
//  Arguments:  [ppCPC]        -- returns the container
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    if ( 0 == ppCPC )
        return E_POINTER;

    *ppCPC = 0;
    // if disconnected from container, can't do it.
    if (0 == _pContainer)
        return E_UNEXPECTED;
    
    _pContainer->AddRef();
    *ppCPC = _pContainer;

    return S_OK;
} //GetConnectionPointContainer


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Advise, public
//
//  Synopsis:   Passes in the client's notification object
//
//  Arguments:  [pIUnk]        -- client's notification object
//              [pdwCookie]    -- returned pseudo-id for this advise
//
//  Returns:    SCODE
//
//  Notes:      
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::Advise(
    IUnknown * piunkNotify,
    DWORD * pdwCookie)
{
    SCODE sc = S_OK;

    if ( 0 != pdwCookie )
        *pdwCookie = 0;
    
    if ( 0 == piunkNotify ||
         0 == pdwCookie )
        return E_POINTER;

    XInterface<IUnknown> piSink;

    sc = piunkNotify->QueryInterface( _iidSink, piSink.GetQIPointer() );
    if (! SUCCEEDED(sc))
        return CONNECT_E_CANNOTCONNECT;

    // If disconnected from the container, can't call GetMutex.
    if (0 == _pContainer)
        return CONNECT_E_ADVISELIMIT;

    CLock lock( GetMutex() );
    CConnectionContext * pConnCtx = LokFindConnection( 0 );

    if (0 == pConnCtx && _xaConns.Count() < maxConnections)
        pConnCtx = &_xaConns[_xaConns.Count()];

    if (0 == pConnCtx)
        sc = CONNECT_E_ADVISELIMIT;
    else
    {
        _dwCookieGen++;
        Win4Assert( 0 != _dwCookieGen && 0 == LokFindConnection( _dwCookieGen ) );
        pConnCtx->Set( piSink.Acquire(), _dwCookieGen, _dwDefaultSpare );
        if (_pAdviseHelper)
            (*_pAdviseHelper) (_pAdviseHelperContext, this, pConnCtx);
        *pdwCookie = _dwCookieGen;
    }

    return sc;
} //Advise

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Unadvise, public
//
//  Synopsis:   Turns off an advise previously turned on with Advise()
//
//  Arguments:  [dwCookie] -- pseudo-id for this advise
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::Unadvise(
    DWORD dwCookie)
{
    SCODE sc = S_OK;
    CConnectionContext * pConnCtx = 0;

    CReleasableLock lock( GetMutex(), ( 0 != _pContainer ) );

    pConnCtx = LokFindConnection( dwCookie );
    if (pConnCtx)
    {
        if (_pUnadviseHelper)
            (*_pUnadviseHelper) ( _pUnadviseHelperContext, this, pConnCtx, lock );
        pConnCtx->Release();
    }


    if (0 == pConnCtx)
    {
        tbDebugOut(( DEB_WARN, "conpt: unknown advise cookie %x\n", dwCookie ));
        sc = CONNECT_E_NOCONNECTION;
    }

    return sc;
} //Unadvise


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::EnumConnections, public
//
//  Synopsis:   Returns an enumerator of advises open in this connection
//
//  Arguments:  [ppEnum]       -- returned enumerator
//
//  Returns:    SCODE
//
//  Notes:      The spec permits E_NOTIMPL to be returned for this.  If
//              we chose to implement it, it's a straightforward matter of
//              iterating over the _xaConns array.
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointBase::EnumConnections(
    IEnumConnections ** ppEnum)
{
    if ( 0 == ppEnum )
        return E_POINTER;

    *ppEnum = 0;
    return E_NOTIMPL;
} //EnumConnections


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::Disconnect, private
//
//  Synopsis:   Disconnect from the connection point container
//
//  Arguments:  [dwCookie]    -- pseudo-id for this advise
//
//  Returns:    CConnectionContext* - a connection matching the [dwCookie] or 0
//
//  Notes:      Should be called with the CPC lock held.  Might be called
//              without the lock for an Unadvise after the CPC is diconnected.
//
//  History:    30 Mar 1998     AlanW      Created
//
//--------------------------------------------------------------------------

void CConnectionPointBase::Disconnect( )
{
    Win4Assert( 0 != _pContainer );
    CLock lock(GetMutex());

    _pContainer->RemoveConnectionPoint( this );
    _pContainer = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::LokFindConnection, private
//
//  Synopsis:   Find a connection matching an advise cookie
//
//  Arguments:  [dwCookie]    -- pseudo-id for this advise
//
//  Returns:    CConnectionContext* - a connection matching the [dwCookie] or 0
//
//  Notes:      Should be called with the CPC lock held.  Might be called
//              without the lock for an Unadvise after the CPC is diconnected.
//
//  History:    10 Mar 1998     AlanW      Created
//
//--------------------------------------------------------------------------

CConnectionPointBase::CConnectionContext *
   CConnectionPointBase::LokFindConnection( DWORD dwCookie )
{
    for (unsigned i=0; i<_xaConns.Count(); i++)
    {
        CConnectionContext & rConnCtx = _xaConns[i];

        if (rConnCtx._dwAdviseCookie == dwCookie)
            return &rConnCtx;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointBase::LokFindActiveConnection, private
//
//  Synopsis:   Find an active advise by indexing
//
//  Arguments:  [riConn]   -- index into conn. context array, updated on return
//
//  Returns:    CConnectionContext* - pointer to an active connection context,
//                                    or NULL.
//
//  Notes:      Should be called with the CPC lock held.
//
//  History:    10 Mar 1998     AlanW      Created
//
//--------------------------------------------------------------------------

CConnectionPointBase::CConnectionContext *
    CConnectionPointBase::LokFindActiveConnection( unsigned & riConn )
{
    while (riConn < _xaConns.Count())
    {
        CConnectionContext & rCtx = _xaConns[riConn];

        if (rCtx._dwAdviseCookie != 0)
            return &rCtx;

        riConn++;
    }
    return 0;
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on cursor object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointContainer::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    return _rControllingUnk.QueryInterface(riid, ppvObject);
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::AddRef, public
//
//  Synopsis:   Invokes AddRef on cursor object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointContainer::AddRef()
{
    tbDebugOut(( DEB_NOTIFY, "conptcontainer: addref\n" ));
    return _rControllingUnk.AddRef();
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::Release, public
//
//  Synopsis:   Invokes Release on cursor object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPointContainer::Release()
{
    tbDebugOut(( DEB_NOTIFY, "conptcontainer: release\n" ));
    return _rControllingUnk.Release();
} //Release

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::CConnectionPointContainer, public
//
//  Synopsis:   Constructor for connection point container class.
//
//  Arguments:  [maxConnPt] -- maximum number of connection points supported
//              [rUnknown]  -- controlling unknown
//              [ErrorObject] -- reference to error object
//
//  Notes:      After construction, use AddConnectionPoint to add a connection
//              point into the container.
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CConnectionPointContainer::CConnectionPointContainer(
            unsigned maxConnPt,
            IUnknown &rUnknown,
            CCIOleDBError & ErrorObject )
   : _rControllingUnk(rUnknown),
     _ErrorObject( ErrorObject ),
     _cConnPt( 0 )
{
    Win4Assert( maxConnPt <= maxConnectionPoints );
} //CConnectionPointContainer

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::~CConnectionPointContainer, public
//
//  Synopsis:   Destructor for connection point container class.
//
//  Notes:      It is expected that all connection points are relased by this
//              time.
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CConnectionPointContainer::~CConnectionPointContainer()
{
    CLock lock( _mutex );

    //
    // Release all connection points
    //

    for (unsigned i = 0; i < _cConnPt; i++)
    {
        IConnectionPoint * pIConnPt = _aConnPt[i]._pIConnPt;
        if ( 0 != pIConnPt )
        {
            _aConnPt[i]._pIConnPt = 0;
            pIConnPt->Release();
        }
    }
} //~CConnectionPointContainer

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::FindConnectionPoint, public
//
//  Synopsis:   Finds a connection point object that supports the given
//              interface for callback to the client
//
//  Arguments:  [riid]        -- interface ID for proposed callback
//              [ppPoint]     -- returned connection interface pointer
//
//  Returns:    SCODE
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointContainer::FindConnectionPoint(
    REFIID riid,
    IConnectionPoint ** ppPoint)
{
    _ErrorObject.ClearErrorInfo();

    if ( 0 == ppPoint )
        return E_POINTER;

    *ppPoint = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lock( _mutex );

        for (unsigned i = 0; i < _cConnPt; i++)
        {
            if ( riid == _aConnPt[i]._iidConnPt )
                break;
        }

        if ( i<_cConnPt )
        {
            Win4Assert(_aConnPt[i]._pIConnPt != 0);
            IConnectionPoint * pIConnPt = _aConnPt[i]._pIConnPt;
            *ppPoint = pIConnPt;
            pIConnPt->AddRef();
        }
        else
        {
            sc = CONNECT_E_NOCONNECTION;
        }

        if (FAILED(sc))
            _ErrorObject.PostHResult(sc, IID_IConnectionPointContainer);
    }
    CATCH(CException,e)
    {
        _ErrorObject.PostHResult(e.GetErrorCode(), IID_IConnectionPointContainer);
        sc = E_UNEXPECTED;
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //FindConnectionPoint

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::EnumConnectionPoints, public
//
//  Synopsis:   Enumerates all connection points currently in use
//
//  Arguments:  [ppEnum]      -- returned enumerator
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CConnectionPointContainer::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    _ErrorObject.ClearErrorInfo();

    if ( 0 == ppEnum )
        return E_POINTER;

    *ppEnum = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lock( _mutex );

        XInterface<IEnumConnectionPoints> pEnumCp( new CEnumConnectionPoints( *this ) );
        *ppEnum = pEnumCp.GetPointer();
        pEnumCp.Acquire();
    }
    CATCH(CException,e)
    {
        _ErrorObject.PostHResult(e.GetErrorCode(), IID_IConnectionPointContainer);
        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //EnumConnectionPoints



//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::QueryInterface, public
//
//  Synopsis:   Invokes QueryInterface on connection point enumerator object
//
//  Arguments:  [riid]        -- interface ID
//              [ppvObject]   -- returned interface pointer
//
//  Returns:    SCODE
//
//  History:    10 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IEnumConnectionPoints == riid )
    {
        *ppvObject = (void *) (IEnumConnectionPoints *) this;
    }
    else if ( IID_IUnknown == riid )
    {
        *ppvObject = (void *) (IUnknown *) this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
        AddRef();

    return sc;
} //QueryInterface


//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::AddRef, public
//
//  Synopsis:   Invokes AddRef on container object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumConnectionPoints::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Release, public
//
//  Synopsis:   Invokes Release on container object
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumConnectionPoints::Release()
{
    long cRefs = InterlockedDecrement((long *) &_cRefs);

    tbDebugOut(( DEB_NOTIFY, "enumconpt: release, new crefs: %lx\n", _cRefs ));

    // If no references, delete.

    if ( 0 == cRefs )
    {
        delete this;
    }

    return cRefs;
} //Release


//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Clone, public
//
//  Synopsis:   Clone a connection point enumerator
//
//  Arguments:  [ppEnum]      -- returned enumerator
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Clone (
    IEnumConnectionPoints **ppEnum)
{
    //_ErrorObject.ClearErrorInfo();

    if ( 0 == ppEnum )
        return E_POINTER;

    *ppEnum = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        XInterface<CEnumConnectionPoints> pEnumCp( new CEnumConnectionPoints( _rContainer ) );
        pEnumCp->_iConnPt = _iConnPt;
        *ppEnum = pEnumCp.GetPointer();
        pEnumCp.Acquire();
    }
    CATCH(CException,e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //Clone

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Reset, public
//
//  Synopsis:   Reset a connection point enumerator
//
//  Arguments:  -NONE-
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Reset ( )
{
    _iConnPt = 0;
    return S_OK;
} //Reset

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Skip, public
//
//  Synopsis:   Skip some connection points
//
//  Arguments:  [cConnections] - number of connection points to skip
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Skip ( ULONG cConnections )
{
    SCODE sc = S_OK;

    if ( _iConnPt+cConnections < _rContainer._cConnPt )
        _iConnPt += cConnections;
    else
        sc = S_FALSE;
    return sc;
} //Skip

//+-------------------------------------------------------------------------
//
//  Method:     CEnumConnectionPoints::Next, public
//
//  Synopsis:   Return some connection points
//
//  Arguments:  [cConnections] - number of connection points to return, at most
//              [rgpcm]  - array of IConnectionPoint* to be returned
//              [pcFetched] - on return, number of connection points in [rgpcm]
//
//  Returns:    SCODE
//
//  History:    09 Mar 1998     AlanW    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CEnumConnectionPoints::Next ( ULONG cConnections,
                                           IConnectionPoint **rgpcm,
                                           ULONG * pcFetched )
{
    SCODE sc = S_OK;

    if ( 0 != pcFetched )
        *pcFetched = 0;

    if ( 0 == rgpcm ||
         0 == pcFetched )
        return E_POINTER;

    for (ULONG i=0; i<cConnections; i++)
        rgpcm[i] = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        ULONG cRet = 0;
        CLock lock(_rContainer._mutex);

        // Note: There could be leakage of CP pointers if there are exceptions
        //       generated by the code below.
        while ( _iConnPt < _rContainer._cConnPt &&
                cRet < cConnections )
        {
            XInterface<IConnectionPoint> xCP( _rContainer._aConnPt[_iConnPt]._pIConnPt );
            xCP->AddRef();   
            rgpcm[cRet] = xCP.GetPointer();
            cRet++;
            _iConnPt++;
            *pcFetched = cRet;
            xCP.Acquire();
        }
        sc = (cConnections == cRet) ? S_OK : S_FALSE;
    }
    CATCH(CException,e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //Next


//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::AddConnectionPoint, public
//
//  Synopsis:   Adds a connection point to the container.
//              Called by the connection point itself.
//
//  Arguments:  [riid]    --- IID of notification interface for CP
//              [pConnPt] --- connection point to be removed
//
//  Notes:      The back pointer from the connection point to the connection
//              point container does not contribute to the container's ref.
//              count so that the CPC <-> CP structure is not self-referential
//              and can be deleted when no longer needed.
//
//  History:    10 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

void CConnectionPointContainer::AddConnectionPoint(
    REFIID riid,
    CConnectionPointBase *pConnPt)
{
    Win4Assert( _cConnPt < maxConnectionPoints );

    XInterface<IConnectionPoint> xConnPt;
    SCODE sc = pConnPt->QueryInterface( IID_IConnectionPoint,
                                        xConnPt.GetQIPointer());
    if (!SUCCEEDED(sc))
        THROW( CException(sc) );

    CLock lock(_mutex);

    CConnectionPointContext * pConnPtCtx = &_aConnPt[_cConnPt];
    pConnPtCtx->_pIConnPt = xConnPt.Acquire();
    pConnPtCtx->_iidConnPt = riid;
    _cConnPt++;
} //AddConnectionPoint

//+-------------------------------------------------------------------------
//
//  Method:     CConnectionPointContainer::RemoveConnectionPoint, public
//
//  Synopsis:   Removes a connection point from the container.
//              Called by the connection point itself.
//
//  Arguments:  [pConnPt]  --- connection point to be removed
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

void CConnectionPointContainer::RemoveConnectionPoint(
    IConnectionPoint *pConnPt)
{
    CLock lock(_mutex);

    for (unsigned i = 0; i < _cConnPt; i++)
    {
        if ( _aConnPt[i]._pIConnPt == pConnPt )
        {
            _aConnPt[i]._pIConnPt = 0;
            pConnPt->Release();
        }
    }
} //RemoveConnectionPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\hraccess.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       hraccess.cxx
//
//  Contents:   OLE DB HRow accessor helper class
//
//  Classes:    CAccessor
//              CRowDataAccessor
//              CRowDataAccessorByRef
//
//  History:    21 Nov 94       dlee   Created from AlanW's tblwindo code
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rowset.hxx>
#include <query.hxx>
#include "tabledbg.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::Destroy, private
//
//  Synopsis:   Removes an accessor from the bag and deletes it
//
//  History:    12 Jan 1995     dlee   Created
//
//--------------------------------------------------------------------------

void CAccessorBag::Destroy(
    CAccessorBase * pAccessor )
{
    pAccessor->SetInvalid();
    Remove(pAccessor);

    TRY
    {
        while (pAccessor->GetRefcount() > 0)
            pAccessor->Release();  // this can throw - we'll toss away error
    }
    CATCH( CException, e )
    {
        SCODE sc = GetOleError(e);
        tbDebugOut(( DEB_ERROR, "CAccessorBase::Release threw 0x%x\n", sc ));
    }
    END_CATCH;

    if (0 == pAccessor->GetInheritorCount() )
        delete pAccessor;
} //Destroy

//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::~CAccessorBag, private
//
//  Synopsis:   Removes accessors the user forgot to free
//
//  History:    16 Jan 1997     dlee   Created
//
//--------------------------------------------------------------------------

CAccessorBag::~CAccessorBag()
{
    CAccessorBase *p;
    while ( p = First() )
    {
        tbDebugOut(( DEB_ITRACE,
                     "App bug: Deleting an accessor that wasn't freed\n" ));
        Destroy( p );
    }
} //~CAccessorBag

//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::Release, public
//
//  Synopsis:   Dereference an accessor; delete it if refcount goes to 0
//
//  History:    18 Sep 1996    Alanw    Created
//
//--------------------------------------------------------------------------

void CAccessorBag::Release(HACCESSOR hAccessor, ULONG * pcRef)
{
    CAccessorBase *pAccessor = Convert(hAccessor);  // will throw if accessor invalid
                                                    // caught by ReleaseAccessor
    if (0 == pAccessor->Release())
    {
        Destroy(pAccessor);
        if (pcRef)
            *pcRef = 0;
    }
    else
    {
        if (pcRef)
            *pcRef = pAccessor->GetRefcount();
    }
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     CAccessorBag::AddRef, public
//
//  Synopsis:   Adds a reference to an accessor
//
//  History:    18 Sep 1996    Alanw    Created
//
//--------------------------------------------------------------------------

void CAccessorBag::AddRef(HACCESSOR hAccessor, ULONG * pcRef)
{
    CAccessorBase *pAccessor = Convert(hAccessor);

    ULONG cRef = pAccessor->AddRef();
    if (pcRef)
        *pcRef = cRef;
} //AddRef

// This pool has no private data -- it just calls the OLE allocator, so
// it can be static.

CAccessorAllocator CAccessor::_Pool;

//+-------------------------------------------------------------------------
//
//  Function:   isVariableLength
//
//  Synopsis:   TRUE if the type is one of the odd oledb types that can
//              have variable length inline data
//
//  Arguments:  [type]     -- oledb data type
//
//  History:    6 Feb 95       dlee   created
//
//--------------------------------------------------------------------------

static BOOL isVariableLength( DWORD type )
{
    type &= VT_TYPEMASK;

    return type == DBTYPE_STR    ||
           type == DBTYPE_BYTES  ||
           type == DBTYPE_WSTR;
} //isVariableLength

//+-------------------------------------------------------------------------
//
//  Function:   isValidByRef
//
//  Synopsis:   TRUE if the type is one of the odd oledb types that can
//              be combined with DBTYPE_BYREF
//
//  Arguments:  [type]     -- oledb data type
//
//  History:    9 Aug 95       dlee   created
//
//--------------------------------------------------------------------------

static BOOL isValidByRef( DWORD type )
{
    type &= ~DBTYPE_BYREF;

    return type == DBTYPE_STR    ||
           type == DBTYPE_WSTR   ||
           type == DBTYPE_BYTES  ||
           type == DBTYPE_GUID   ||
           type == VT_CF         ||
           type == DBTYPE_VARIANT;
} //isValidByref

//+-------------------------------------------------------------------------
//
//  Function:   isEquivalentType
//
//  Synopsis:   TRUE if the types are interchangable between OLE-DB and
//              PROPVARIANT.  Unfortunately, several of the types are
//              equivalent but have different representations.
//
//  Arguments:  [vtDst]    -- OLE-DB destination type
//              [vtSrc]    -- PROPVARIANT source type
//
//  History:    9 Aug 95       dlee   created
//
//--------------------------------------------------------------------------

static BOOL isEquivalentType( VARTYPE vtDst, VARTYPE vtSrc )
{
    return ( ( vtDst == vtSrc ) ||
             ( ( ( DBTYPE_WSTR | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_LPWSTR == vtSrc ) ) ||
             ( ( ( DBTYPE_STR | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_LPSTR == vtSrc ) ) ||
             ( ( ( DBTYPE_WSTR | DBTYPE_BYREF | DBTYPE_VECTOR ) == vtDst ) &&
               ( ( VT_LPWSTR | VT_VECTOR ) == vtSrc ) ) ||
             ( ( ( DBTYPE_STR | DBTYPE_BYREF | DBTYPE_VECTOR ) == vtDst ) &&
               ( ( VT_LPSTR | VT_VECTOR ) == vtSrc ) ) ||
             ( ( ( DBTYPE_GUID | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_CLSID == vtSrc ) ) ||
             ( ( ( VT_CF | DBTYPE_BYREF ) == vtDst ) &&
               ( VT_CF == vtSrc ) ) );
} //isEquivalentType

//+-------------------------------------------------------------------------
//
//  Function:   NullOrCantConvert, inline
//
//  Synopsis:   Returns DBSTATUS_S_ISNULL if [type] is one of the types which
//              represent null data, DBSTATUS_E_CANTCONVERTVALUE otherwise.
//
//  Arguments:  [type]     -- variant data type
//
//  History:    24 Feb 98      AlanW   created
//
//--------------------------------------------------------------------------

inline DBSTATUS NullOrCantConvert( VARTYPE type )
{
    if ( type == VT_EMPTY || type == VT_NULL )
        return DBSTATUS_S_ISNULL;
    else
        return DBSTATUS_E_CANTCONVERTVALUE;
} //NullOrCantConvert


//+---------------------------------------------------------------------------
//
//  Function:   ConvertBackslashToSlash, inline
//
//  Synopsis:   Converts '\' characters to '/' in a string inplace.
//
//  Arguments:  [pwszPath] -- string to be converted
//
//  History:    24 Feb 98      AlanW   Added header
//
//----------------------------------------------------------------------------

inline void ConvertBackslashToSlash( LPWSTR pwszPath )
{
    Win4Assert( 0 != pwszPath );

    while ( 0 != *pwszPath )
    {
        if ( L'\\' == *pwszPath )
        {
            *pwszPath = L'/';
        }
        pwszPath++;
    }
} //ConvertBackslashToSlash

// DBGP - a debug parameter, only available on checked builds
#ifndef DBGP
    #if DBG == 1
        #define DBGP(a) , a
    #else
        #define DBGP(a)
    #endif // DBG
#endif // ndef DBGP

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::_BindingFailed, private
//
//  Synopsis:   Stores a binding status for an individual binding error.
//              The caller should continue processing with the next binding.
//
//  Arguments:  [BindStat]        -- what when wrong?
//              [iBinding]        -- which binding was bad?
//              [pBindStatus]     -- where to indicate bad binding
//
//  History:    6 Feb 95       dlee   created
//
//--------------------------------------------------------------------------

void CAccessor::_BindingFailed(
    DBBINDSTATUS  BindStat,
    DBORDINAL     iBinding,
    DBBINDSTATUS* pBindStatus
    DBGP(char*    pszExplanation)
)
{
    tbDebugOut(( DEB_TRACE,
                 "CAccessor: construction failed, bindstatus=%x, binding %d\n",
                 BindStat, iBinding ));
#if DBG == 1
    if (pszExplanation)
    {
        tbDebugOut(( DEB_TRACE|DEB_NOCOMPNAME, "\t%s\n", pszExplanation ));
    }
#endif // DBG

    if (pBindStatus != 0)
    {
        pBindStatus[iBinding] = BindStat;
    }
    _scStatus = DB_E_ERRORSOCCURRED;
} //_BindingFailed

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::_ConstructorFailed, private
//
//  Synopsis:   Indicate an error with parameters other than an individual
//              binding.  Throw an exception for the error.
//
//  Arguments:  [scFailure]       -- what when wrong?
//
//  History:    16 Sep 1996    AlanW   created
//
//--------------------------------------------------------------------------

void CAccessor::_ConstructorFailed(
    SCODE         scFailure
    DBGP(char*    pszExplanation)
)
{
    tbDebugOut(( DEB_TRACE,
                 "CAccessor: construction failed, sc=%x\n",
                 scFailure ));
#if DBG == 1
    if (pszExplanation)
    {
        tbDebugOut(( DEB_TRACE|DEB_NOCOMPNAME, "\t%s\n", pszExplanation ));
    }
#endif // DBG

    _scStatus = scFailure;

    QUIETTHROW(CException(scFailure));
} //_ConstructorFailed


static const GUID s_guidStorage = PSGUID_STORAGE;
static const GUID s_guidQuery = DBQUERYGUID;
const DBORDINAL colInvalid = -1;

//+---------------------------------------------------------------------------
//
//  Member:     CAccessor::_Initialize
//
//  Synopsis:   Initializes the object without verifying the coercions.
//
//  Arguments:  [dwAccessorFlags] - accessor flags, read/write, etc.
//              [cBindings]     - count of bindings
//              [rgBindings]    - array of binding structures
//              [pBindStat] - on return, pointer to first binding in error
//
//  History:    21 Nov 94       dlee       created
//              11-07-95        srikants   Moved from constructor
//
//  Notes:
//
//----------------------------------------------------------------------------

void CAccessor::_Initialize(
    DBACCESSORFLAGS   dwAccessorFlags,
    DBORDINAL         cBindings,
    const DBBINDING * rgBindings,
    DBBINDSTATUS *    pBindStat)
{
    // Invalid accessor flag?
    if ( dwAccessorFlags & ~ ( DBACCESSOR_PASSBYREF |
                               DBACCESSOR_ROWDATA |
                               DBACCESSOR_PARAMETERDATA |
                               DBACCESSOR_OPTIMIZED) )
        _ConstructorFailed(DB_E_BADACCESSORFLAGS
                           DBGP("bad dwAccessorFlags bits"));

    if ( (dwAccessorFlags & ( DBACCESSOR_ROWDATA | DBACCESSOR_PARAMETERDATA ) )
          == 0)
        _ConstructorFailed(DB_E_BADACCESSORFLAGS
                           DBGP("bad dwAccessorFlags type"));

    if ( dwAccessorFlags & DBACCESSOR_PARAMETERDATA )
        _ConstructorFailed(DB_E_BADACCESSORFLAGS
                           DBGP("parameter accessors are not supported"));

    // byref accessors are not supported
    if ( dwAccessorFlags & ( DBACCESSOR_PASSBYREF) )
        _ConstructorFailed(DB_E_BYREFACCESSORNOTSUPPORTED
                           DBGP("byref accessors are not supported"));

    // null accessors are not supported
    if ( 0 == _cBindings )
        _ConstructorFailed(DB_E_NULLACCESSORNOTSUPPORTED
                           DBGP("null accessors are not supported"));

    // verify each binding is ok and save it
    for (DBORDINAL iBinding = 0; iBinding < _cBindings; iBinding++)
    {
        CDataBinding DataBinding (rgBindings[iBinding]);
        DBPART cp = DataBinding.Binding().dwPart;
        DBTYPE wType = DataBinding.Binding().wType;

        if (0 != pBindStat)
            pBindStat[iBinding] = DBBINDSTATUS_OK;

        // check for invalid bits in the column parts

        if (cp &
            ~(DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS))
             _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                            DBGP("bad dwPart bits"));

        // at least one of value, length or status flags must be on

        if (0 == (cp & (DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS)))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("zero dwPart"));

        // we don't support abstract data types

        if (0 != DataBinding.Binding().pTypeInfo)
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad pTypeInfo"));

        if (0 != DataBinding.Binding().pBindExt)
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad pBindExt"));

        if (0 != (DataBinding.Binding().dwFlags & DBBINDFLAG_HTML))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("no HTML binding support"));
        else if (0 != DataBinding.Binding().dwFlags)
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad dwFlags"));

        //
        // Verify size and alignment of output buffer.  Set cbWidth in local
        // copy of binding to handle length of fixed-width types correctly.
        //
        if ( 0 != ( wType & DBTYPE_BYREF ) )
        {
            if ( ! isValidByRef( wType ) )
                _BindingFailed( DBBINDSTATUS_BADBINDINFO,
                                    iBinding,
                                    pBindStat
                                    DBGP("byref on non-byref type") );

            // byref data: client's cbMaxLen is noise
            DataBinding.SetMaxLen(sizeof LPWSTR);
        }
        else if ( 0 != ( wType & DBTYPE_VECTOR ) )
        {
            USHORT cbWidth = sizeof ( DBVECTOR );
            USHORT cbAlign = sizeof ( DBVECTOR );

            #if CIDBG==1
                tbDebugOut(( DEB_ACCESSOR,
                             "type %d, obValue %d, alignment needed: %d\n",
                             (int) wType,
                             (int) DataBinding.Binding().obValue,
                             (int) cbAlign ));

                //Win4Assert( (0 == (DBPART_VALUE & cp)) ||
                //            ( (0 != cbAlign) &&
                //              (0 == (DataBinding.Binding().obValue % cbAlign)) ) );

                if ( (DBPART_VALUE & cp) &&
                     (0 != (DataBinding.Binding().obValue % cbAlign)) )
                {
                    tbDebugOut(( DEB_ERROR,
                                 "bad value alignment for DBVECTOR, obValue %d, alignment needed: %d\n",
                                 (int) DataBinding.Binding().obValue,
                                 (int) cbAlign ));
                }
            #endif // CIDBG==1

            // Fixed-length data types needn't have their width set, per
            // the Nile spec.  So we set it to the default for the type.

            DataBinding.SetMaxLen( cbWidth );
        }
        else if ( 0 != ( wType & VT_ARRAY ) )
        {
           DataBinding.SetMaxLen( sizeof( SAFEARRAY * ) );
        }
        else
        {
            USHORT cbWidth,cbAlign,gfFlags;

            CTableVariant::VartypeInfo( wType,
                                        cbWidth,
                                        cbAlign,
                                        gfFlags );

            #if CIDBG==1
                tbDebugOut(( DEB_ACCESSOR,
                             "type %d, obValue %d, alignment needed: %d\n",
                             (int) wType,
                             (int) DataBinding.Binding().obValue,
                             (int) cbAlign ));

                //Win4Assert( (0 == (DBPART_VALUE & cp)) ||
                //            ( (0 != cbAlign) &&
                //              (0 == (DataBinding.Binding().obValue % cbAlign)) ) );

                if ( (DBPART_VALUE & cp) &&
                     (0 != (DataBinding.Binding().obValue % cbAlign)) )
                {
                    tbDebugOut(( DEB_ERROR,
                                 "bad value alignment for type %d, obValue %d, alignment needed: %d\n",
                                 (int) wType,
                                 (int) DataBinding.Binding().obValue,
                                 (int) cbAlign ));
                }
            #endif // CIDBG==1
            // Fixed-length data types needn't have their width set, per
            // the Nile spec.  So we set it to the default for the type.

            if (! isVariableLength( wType ) )
                DataBinding.SetMaxLen( cbWidth );
        }

        if (DataBinding.Binding().dwMemOwner & ~(DBMEMOWNER_PROVIDEROWNED))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad dwMemOwner bits"));

        if (DBTYPE_EMPTY == (wType & VT_TYPEMASK) ||
            DBTYPE_NULL  == (wType & VT_TYPEMASK) ||
            0 != (wType & VT_RESERVED))
        {
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad wType"));
        }

        if ((wType & ~VT_TYPEMASK) != 0 &&
            (wType & ~VT_TYPEMASK) != DBTYPE_ARRAY &&
            (wType & ~VT_TYPEMASK) != DBTYPE_VECTOR &&
            (wType & ~VT_TYPEMASK) != DBTYPE_BYREF )
        {
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad wType modifier combination"));
        }

        // SPECDEVIATION - this is bogus; DBTYPE_VARIANT must be supported!

        if ((DataBinding.Binding().dwMemOwner & DBMEMOWNER_PROVIDEROWNED) &&
            (wType != DBTYPE_BSTR) &&
            !(wType & (DBTYPE_BYREF | DBTYPE_VECTOR | DBTYPE_ARRAY )))
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("bad provider-owned mem type"));

        if ( (DataBinding.Binding().dwMemOwner & DBMEMOWNER_PROVIDEROWNED) &&
             (wType == (DBTYPE_BYREF|DBTYPE_VARIANT)) &&
             ! _fExtendedTypes )
            _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStat
                           DBGP("provider-owned mem without extended types"));

        _aBindings[ iBinding] = DataBinding;

        if ( DataBinding.Binding().pObject )
        {
            _aBindings[iBinding].Binding().pObject = new DBOBJECT;

            RtlCopyMemory( _aBindings[(unsigned)iBinding].Binding().pObject, 
                           DataBinding.Binding().pObject,
                           sizeof( DBOBJECT ) );
        }
    }

    // Verify that none of the output offsets and lengths overlap with
    // any others.  This must be run after the above loop so cbMaxLength
    // fields are properly initialized.

    if (_scStatus == S_OK)
        _ValidateOffsets( pBindStat );
} //_Initialize


//+---------------------------------------------------------------------------
//
//  Member:     CAccessor::Validate
//
//  Synopsis:   Validates the coercions with respect to the ColumnsInfo.
//
//  Arguments:  [rColumnsInfo] - The column info. for the rowset
//              [pBindStat]    - Binding status array (optional)
//
//  History:    21 Nov 94   dlee        created
//              11-08-95    srikants    Created
//              01-15-98    VikasMan    Removed call to checkcoercion here
//                                      Checking done only in GetData now
//
//----------------------------------------------------------------------------

void CAccessor::Validate(
    CColumnsInfo & rColumnsInfo,
    DBBINDSTATUS * pBindStatus )
{
    _pColumnsInfo = &rColumnsInfo;
    Win4Assert( 0 != _pColumnsInfo );

    for (DBORDINAL iBinding = 0; iBinding < _cBindings; iBinding++)
    {
        CDataBinding & DataBinding = _aBindings[iBinding];
        DBTYPE wType = (DBTYPE) DataBinding.Binding().wType;

        //
        // Make sure the column id is valid.  Remember, column numbers are
        // 1-based.  Map columnid 0 to the row ID column for the bookmark.
        //
        DBORDINAL iColumnId = DataBinding.Binding().iOrdinal;

        if ( ! _pColumnsInfo->IsValidColumnId( (ULONG) iColumnId ) )
        {
            _BindingFailed(DBBINDSTATUS_BADORDINAL, iBinding, pBindStatus
                           DBGP("invalid iOrdinal"));
            continue;
        }

        const DBCOLUMNINFO & rColInfo =
                _pColumnsInfo->Get1ColumnInfo( (ULONG) iColumnId );


        if ( DBTYPE_HCHAPTER == wType &&
             !(rColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER) )
        {
            _BindingFailed(DBBINDSTATUS_UNSUPPORTEDCONVERSION, iBinding, pBindStatus
                           DBGP("Chapter type binding to non-chapter column"));
            continue;
        }

        //
        // The only IUNKNOWN binding we currently support is for the
        // DBCOL_SELFCOLUMNS guid, with propid PROPID_DBSELF_SELF.
        // We don't yet support binding to a particular column, just
        // to the row (file) as a whole, and only if the client is FSCI.
        //

        if ( DBTYPE_IUNKNOWN == wType )
        {
            // Map self to the rowid column

            if ( ( DBCOL_SELFCOLUMNS == rColInfo.columnid.uGuid.guid ) &&
                 ( PROPID_DBSELF_SELF == rColInfo.columnid.uName.ulPropid ) )
                DataBinding.SetDataColumn( _pColumnsInfo->GetRowIdColumn() );
            else
                _BindingFailed(DBBINDSTATUS_BADBINDINFO,iBinding,pBindStatus
                               DBGP("bad IUNKNOWN binding"));
        }

        // If it's the path column, save the column # for possible use later
        // when doing deferred or self loads

        if ( rColInfo.columnid.uGuid.guid == s_guidStorage &&
             rColInfo.columnid.uName.ulPropid == PID_STG_PATH )
            _iPathColumn = DataBinding.GetDataColumn();

        // If it's the vpath column, save the column # for later use.  We
        // need to translate '\' to '/' in the vpath column.

        if ( rColInfo.columnid.uGuid.guid == s_guidQuery &&
             rColInfo.columnid.uName.ulPropid == DISPID_QUERY_VIRTUALPATH )
            _iVpathBinding = iBinding;


        // If it's a bookmark column, map it to the corresponding row ID
        // column for retrieval.

        if ( (rColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) &&
             ! ( rColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER ) )
            DataBinding.SetDataColumn( _pColumnsInfo->GetRowIdColumn() );

        // If it's a chapter column, mark it to Addref the chapter on retrieval

        if ( (rColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER) &&
             (DBPART_VALUE & DataBinding.Binding().dwPart) )
            DataBinding.SetChapter( TRUE );
    }

    // look for pathname -- it may be in the rowbuffer columns, but not
    // in the accessor's bindings.

    if ( colInvalid == _iPathColumn )
    {
        for ( ULONG x = 0; x < rColumnsInfo.GetHiddenColumnCount(); x++ )
        {
            CFullPropSpec const &spec = *rColumnsInfo.GetPropSpec( x+1 );

            tbDebugOut(( DEB_ACCESSOR,
                         "spec 0x%x IsPropid %d, propid 0x%x, pathpropid: 0x%x\n",
                         &spec,
                         spec.IsPropertyPropid(),
                         spec.GetPropertyPropid(),
                         PID_STG_PATH ));

            if ( spec.IsPropertyPropid() &&
                 PID_STG_PATH == spec.GetPropertyPropid() &&
                 s_guidStorage == spec.GetPropSet() )
            {
                _iPathColumn = x+1;
                break;
            }
        }
    }

    _idColInfo = _pColumnsInfo->GetId();
} //Validate

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::CAccessor, public
//
//  Synopsis:   Constructs an accessor object
//
//  Arguments:  [dwAccessorFlags] -- accessor flags
//              [cBindings]       -- # of bindings specified
//              [rgBindings]      -- array of bindings
//              [pBindStat]       -- returns index of bad binding (if any)
//              [fExtTypes]       -- TRUE if extended variants are supported
//              [pColumns]        -- column info for early checking of column
//                                   coercions
//              [type]            -- type of accessor
//              [pCreator]        -- 
//
//  History:    21 Nov 94       dlee   created
//
//--------------------------------------------------------------------------

CAccessor::CAccessor(
    DBACCESSORFLAGS   dwAccessorFlags,
    DBCOUNTITEM       cBindings,
    const DBBINDING * rgBindings,
    DBBINDSTATUS *    pBindStat,
    BOOL              fExtTypes,
    CColumnsInfo *    pColumns,
    EAccessorType     type,
    void *            pCreator
) :
    CAccessorBase(pCreator, type),
    _dwAccessorFlags(dwAccessorFlags),
    _scStatus(S_OK),
    _aBindings( (unsigned) cBindings),
    _cBindings(cBindings),
    _idColInfo(0),
    _pColumnsInfo(0),
    _iPathColumn( colInvalid ),
    _iVpathBinding( colInvalid ),
    _fExtendedTypes( fExtTypes )
{
    _Initialize( dwAccessorFlags, cBindings, rgBindings, pBindStat );

    if ( 0 != pColumns && _scStatus == S_OK )
        Validate( *pColumns, pBindStat );
    if (_scStatus != S_OK)
        QUIETTHROW(CException(_scStatus));
} //CAccessor

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::~CAccessor, public
//
//  Synopsis:   Destructs an accessor object
//
//  History:    19 Apr 2000       dlee   added header
//
//--------------------------------------------------------------------------

CAccessor::~CAccessor()
{
    // Delete DBOBJECTs

    for ( unsigned iBinding = 0; iBinding < _cBindings; iBinding++ )
    {
        if ( 0 != _aBindings[iBinding].Binding().pObject )
            delete _aBindings[iBinding].Binding().pObject;

        // These are for future use according to OLE-DB 2.0 and should be NULL

        Win4Assert( 0 == _aBindings[iBinding].Binding().pTypeInfo &&
                    0 == _aBindings[iBinding].Binding().pBindExt );
    }

    CAccessorBase * pParent = GetParent();

    if ( 0 != pParent )
    {
       if ( 0 == pParent->DecInheritors() && 0 == pParent->GetRefcount() )
          delete pParent;
    }
} //~CAccessor

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::_ValidateOffsets, private
//
//  Synopsis:   Checks a binding for overlapping output fields
//
//  Arguments:  [pBindStat] -- where to indicate bad binding
//
//  History:    18 May 1995     dlee   Created
//
//--------------------------------------------------------------------------

void CAccessor::_ValidateOffsets( DBBINDSTATUS * pBindStatus )
{
    for ( DBORDINAL iBinding = 0; iBinding < _cBindings; iBinding++ )
    {
        CDataBinding & DataBinding = _aBindings[ iBinding];

        COffsetLengthPair aPairs[3];
        ULONG cPairs = 0;
        DataBinding.CollectOutputPairs( aPairs, cPairs );

        // Check for overlap with data/length/status in this binding

        for ( DBORDINAL i = 0; i < cPairs; i++ )
        {
            for ( DBORDINAL j = i + 1; j < cPairs; j++)
            {
                if ( aPairs[i].isInConflict( aPairs[j] ) )
                {
                    _BindingFailed( DBBINDSTATUS_BADBINDINFO,
                                    iBinding,
                                    pBindStatus
                                    DBGP("intra-binding field overlap") );
                    continue;
                }
            }
        }

        // Check for overlap with other bindings

        for ( i = iBinding + 1; i < _cBindings; i++ )
        {
            CDataBinding &binding = _aBindings[i];
            COffsetLengthPair aTestPairs[3];
            ULONG cTestPairs = 0;
            binding.CollectOutputPairs( aTestPairs, cTestPairs );

            for (ULONG iPair = 0; iPair < cPairs; iPair++)
            {
                for (ULONG iTestPair = 0; iTestPair < cTestPairs; iTestPair++)
                {
                    if ( aPairs[iPair].isInConflict( aTestPairs[iTestPair] ) )
                    {
                        _BindingFailed( DBBINDSTATUS_BADBINDINFO,
                                        i,
                                        pBindStatus
                                        DBGP("inter-binding field overlap") );
                        continue;
                    }
                }
            }
        }
    }
} //_ValidateOffsets

//+---------------------------------------------------------------------------
//
//  Member:     CAccessor::CanConvertType, static public
//
//  Synopsis:   Indicate whether a type conversion is valid.
//
//  Arguments:  [wFromType]  -- source type
//              [wToType]    -- destination type
//              [fExTypes]   -- TRUE if extended types allowed
//              [xDataConvert] --   OLEDB IDataConvert interface pointer
//
//  Returns:    TRUE if the conversion is available, FALSE otherwise.
//              Throws E_FAIL or E_INVALIDARG on errors.
//
//  History:    20 Nov 96      AlanW    Created
//              14 Jan 98      VikasMan Add xDataConvert parameter
//
//----------------------------------------------------------------------------

BOOL CAccessor::CanConvertType(
    DBTYPE wFromType,
    DBTYPE wToType,
    BOOL   fExTypes,
    XInterface<IDataConvert>& xDataConvert)
{
    USHORT cbData, cbAlignFrom, rgfFlagsFrom;
    CTableVariant::VartypeInfo(wFromType, cbData, cbAlignFrom, rgfFlagsFrom);

    USHORT cbAlignTo, rgfFlagsTo;
    CTableVariant::VartypeInfo(wToType, cbData, cbAlignTo, rgfFlagsTo);

    if (0 == cbAlignFrom || 0 == cbAlignTo)
        QUIETTHROW(CException(E_INVALIDARG));   // bad type

    if ( ((wToType & ~VT_TYPEMASK) != 0 &&
          (wToType & ~VT_TYPEMASK) != DBTYPE_ARRAY &&
          (wToType & ~VT_TYPEMASK) != DBTYPE_VECTOR &&
          (wToType & ~VT_TYPEMASK) != DBTYPE_BYREF ) ||
         0 != (wToType & VT_RESERVED) )
    {
        tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to invalid type"));
        QUIETTHROW(CException(E_INVALIDARG));
    }

    if ( ((wFromType & ~VT_TYPEMASK) != 0 &&
          (wFromType & ~VT_TYPEMASK) != DBTYPE_ARRAY &&
          (wFromType & ~VT_TYPEMASK) != DBTYPE_VECTOR &&
          (wFromType & ~VT_TYPEMASK) != DBTYPE_BYREF ) ||
         0 != (wFromType & VT_RESERVED) )
    {
        tbDebugOut(( DEB_IERROR, "CanConvertType: conversion from invalid type"));
        QUIETTHROW(CException(E_INVALIDARG));
    }


    //
    // check for conversions _Initialize() does not allow
    //
    // check if byref request for "short" type
    if ( (wToType & DBTYPE_BYREF) && !isValidByRef(wToType) )
    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to byref type for short type"));
       return FALSE;
    }

    if ( DBTYPE_EMPTY == (wToType & VT_TYPEMASK) ||
         DBTYPE_NULL  == (wToType & VT_TYPEMASK) )

    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to empty or null type"));
       return FALSE;
    }

    //
    // check extended type conversions
    //

    // NEWFEATURE: - vector ==> array conversion?

    if ((wToType & DBTYPE_ARRAY) && (wToType != wFromType))
    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to array"));
       return FALSE;
    }
    if ((wToType & DBTYPE_VECTOR) &&
             !(isEquivalentType(wToType,wFromType) || wFromType == VT_VARIANT))
    {
       tbDebugOut(( DEB_IERROR, "CanConvertType: conversion to vector"));
       return FALSE;
    }

    //
    // VARIANT conversions depend upon whether extended types are supported
    //
    if (wToType == DBTYPE_VARIANT)
    {
        if (fExTypes)
            return TRUE;

        if ( (wFromType & ~(DBTYPE_BYREF)) == DBTYPE_GUID)
            return FALSE;

        return TRUE;
    }

    //
    //  Anything can coerce into DBTYPE_BYTES
    //
    if (wToType == DBTYPE_BYTES)
       return TRUE;

    // now use OLEDB to check if  conversion is possible
    return COLEDBVariant::CanConvertType( wFromType, wToType, xDataConvert );

} //CanConvertType

//+-------------------------------------------------------------------------
//
//  Member:     CAccessor::GetBindings, public
//
//  Synopsis:   Fetches a copy of the bindings used by the accessor
//
//  Arguments:  [pAccessorFlags]  -- accessor flags
//              [pcBindings]      -- # of bindings returned
//              [ppBindings]      -- array of bindings returned.  the user
//                                   must IMalloc::Free this memory.
//
//  Returns:    SCODE - S_OK.  Return value required by base class
//                             CAccessorBase
//
//  History:    21 Nov 94       dlee   created
//              05 May 97       emilyb switched first 2 params from
//                                     references to pointers so that
//                                     this can be a virtual member of
//                                     CAccessorBase.  (CDistributedAccessor
//                                     cannot use references).
//
//--------------------------------------------------------------------------

SCODE CAccessor::GetBindings(
    DBACCESSORFLAGS * pAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING **      ppBindings)
{
    // in case of an error later, init the count to a good state

    *pcBindings = 0;

    // verify this pointer is good

    *ppBindings = 0;

    // allocate room for the bindings and copy them

    *ppBindings = (DBBINDING *) _Pool.Allocate( (ULONG) _cBindings * sizeof DBBINDING );

    *pAccessorFlags = _dwAccessorFlags;
    *pcBindings = _cBindings;

    for ( DBORDINAL i = 0; i < _cBindings; i++ )
    {
        (*ppBindings)[i] = _aBindings[ i].Binding();

        if ( _aBindings[i].Binding().pObject )
        {
            (*ppBindings)[i].pObject = (DBOBJECT*) _Pool.Allocate( sizeof( DBOBJECT ) );

            RtlCopyMemory( (*ppBindings)[i].pObject, 
                           _aBindings[i].Binding().pObject,
                           sizeof( DBOBJECT ) );
        }

        // These are for future use according to OLE-DB 2.0 and should be NULL
        Win4Assert( 0 == _aBindings[i].Binding().pTypeInfo &&
                    0 == _aBindings[i].Binding().pBindExt );
    }

    return S_OK;
} //GetBindings

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_LoadPath, private
//
//  Synopsis:   Loads the path of the object represented by the row
//
//  Arguments:  [rSrcSet]       -- set of source columns
//              [pbSrc]         -- source row buffer
//              [funnyPath]     -- where to put the path
//
//  History:    30 May 95       dlee   created
//
//--------------------------------------------------------------------------

void CRowDataAccessor::_LoadPath(
    CTableColumnSet & rSrcSet,
    BYTE *            pbSrc,
    CFunnyPath &      funnyPath )
{
    // either path or workid must be available -- it's added by ColInfo
    // when the query is created.

    if ( colInvalid != _iPathColumn )
    {
        // pathname happened to be one of the columns -- this is faster than
        // doing a wid translation

        CTableColumn *pPathCol = rSrcSet.Find( (ULONG) _iPathColumn );

        WCHAR *pwc = 0;
        if (pPathCol->GetStoredType() == VT_LPWSTR)
        {
            pwc = * ( (WCHAR **) (pbSrc + pPathCol->GetValueOffset()) );
        }
        else
        {
            Win4Assert(pPathCol->GetStoredType() == VT_VARIANT);
            CTableVariant & varnt = * ( (CTableVariant *) (pbSrc + pPathCol->GetValueOffset()) );
            if (varnt.vt == VT_LPWSTR)
                pwc = varnt.pwszVal;
        }

        if (pwc)
        {
            funnyPath.SetPath( pwc );
        }
    }
    else
    {
        // translate the wid for the row into a pathname

        Win4Assert( colInvalid != _pColumnsInfo->GetRowIdColumn() );
        _pQuery->WorkIdToPath( _RowWid( rSrcSet, pbSrc ), funnyPath );
    }
} //_LoadPath

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_BindToObject, private
//
//  Synopsis:   Binds to an object and returns an interface pointer
//
//  Arguments:  [pbDst]         -- destination row buffer
//              [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [rSrcSet]       -- set of source columns
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    10 Apr 95       dlee   created
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_BindToObject(
    BYTE *            pbDst,
    CDataBinding &    rDstBinding,
    BYTE *            pbSrc,
    CTableColumn &    rSrcColumn,
    CTableColumnSet & rSrcSet)
{
    //
    // CLEANCODE: This is all wrong.  StgOpenStorage doesn't belong in
    // framework code!  Though fixing this would be hard -- we'd have to
    // remote the object binding from the server process.  And we only
    // try this for the path column -- if it doesn't exist this code won't
    // be executed.
    //

    DBSTATUS DstStatus = 0;

    // get the pathname for ole to open the storage

    CFunnyPath funnyPath;
    _LoadPath( rSrcSet, pbSrc, funnyPath );

    // bind to the file and return interface pointer requested

    if ( 0 != funnyPath.GetActualLength() )
    {
        // WORKAROUND: StgOpenStorage AVs for paths > MAX_PATH currently
        // So till it is fixed, make sure we do not pass a path > MAX_PATH

        if ( funnyPath.GetLength() < MAX_PATH )
        {
            XInterface<IStorage> xStorage;
            SCODE sc = StgOpenStorage( funnyPath.GetPath(),
                                       0,
                                       rDstBinding.Binding().pObject->dwFlags,
                                       0, 0,
                                       xStorage.GetPPointer() );
    
            if ( SUCCEEDED( sc ) )
                sc = xStorage->QueryInterface( rDstBinding.Binding().pObject->iid,
                                               (void **) pbDst );
    
            if ( FAILED( sc ) )
                DstStatus = DBSTATUS_E_CANTCREATE;
        }
        else
        {
            ciDebugOut(( DEB_WARN, "Not calling StgOpenStorage in CRowDataAccessor::_BindToObject for paths > MAX_PATH: \n(%ws)\n",
                                   funnyPath.GetPath() ));
            DstStatus = DBSTATUS_E_CANTCREATE;
        }
    }
    else
        DstStatus = DBSTATUS_S_ISNULL;

    return DstStatus;
} //_BindToObject

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_LoadDeferred, private
//
//  Synopsis:   Loads a non-storage property value.  Only called if the
//              value is large, hence not already loaded.
//
//  Arguments:  [rSrcVar]    -- where the value is written
//              [pbSrc]      -- pointer to the row data (to get the wid)
//              [iColumn]    -- column being copied
//              [rSrcSet]    -- set of source columns
//
//  Returns:    DBSTATUS  -- status of the load
//
//  History:    1 Jun 95       dlee   created
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_LoadDeferred(
    CTableVariant &                   rSrcVar,
    BYTE *                            pbSrc,
    DBORDINAL                         iColumn,
    CTableColumnSet &                 rSrcSet)
{
    // If the property set storage has not yet been opened for this object,
    // load it now.

    tbDebugOut(( DEB_ACCESSOR, "loading deferred value\n" ));

    rSrcVar.vt = VT_EMPTY; // just in case we can't load anything

    CFullPropSpec const *ps = _pColumnsInfo->GetPropSpec( (ULONG)
                                  _aBindings[iColumn].GetDataColumn() );

    //
    // Try loading from the property cache/docfile if the workid column is
    // available.
    //

    DBORDINAL rowIdCol = _pColumnsInfo->GetRowIdColumn();
    if ( ( colInvalid == rowIdCol ) ||
         ( !_pQuery->FetchDeferredValue( _RowWid( rSrcSet, pbSrc ), *ps, rSrcVar ) ) )
    {
        return DBSTATUS_S_ISNULL;
    }

    tbDebugOut(( DEB_ACCESSOR, "successfully loaded deferred value\n" ));

    return DBSTATUS_S_OK;
} //_LoadDeferred

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_ComplexCopy, private
//
//  Synopsis:   Do a complex copy of the value to the client's buffer
//
//  Arguments:  [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [iColumn]       -- column being copied
//              [vtSrc]         -- type of the source
//              [cbDstLength]   -- on exit, size of destination data
//              [pbSrcData]     -- pointer to source data
//              [vtDst]         -- type of the destination value
//              [pbDstData]     -- where to write the value
//              [rSrcSet]       -- set of source columns
//              [rRowBuffer]    -- row buffer
//              [hrow]          -- hrow being retrieved
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    01 Jun 1995   dlee        created
//              09 Jan 1998   vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_ComplexCopy(
    CDataBinding &                    rDstBinding,
    BYTE *                            pbSrc,
    CTableColumn &                    rSrcColumn,
    DBORDINAL                         iColumn,
    VARTYPE                           vtSrc,
    DBLENGTH &                        cbDstLength,
    BYTE *                            pbSrcData,
    VARTYPE                           vtDst,
    BYTE *                            pbDstData,
    CTableColumnSet &                 rSrcSet,
    CRowBuffer &                      rRowBuffer,
    HROW                              hrow,
    XInterface<IDataConvert>&         xDataConvert)
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;

    // Convert to a COLEDBVariant, then copy it using the OLEDBConvert
    // method.  This allows coercions and variant to nonvariant, etc.
    // conversions to occur.

    COLEDBVariant SrcVar;
    BOOL fDoCopy = TRUE;
    BOOL fFreeDeferredSrc = FALSE;

    if ( VT_VARIANT == vtSrc )
    {
        Win4Assert(rSrcColumn.GetValueSize() == sizeof PROPVARIANT);

        if ( ( rSrcColumn.IsDeferred( pbSrc ) ) )
        {
            DstStatus = _LoadDeferred( SrcVar,
                                       pbSrc,
                                       iColumn,
                                       rSrcSet );

            if ( DBStatusOK ( DstStatus ) )
            {
                // Attempt to store the data without using OLEDBConvert

                if ( (VT_VARIANT == vtDst && _fExtendedTypes) ||
                     DBTYPE_PROPVARIANT == vtDst )
                {
                    fDoCopy = FALSE;
                    * (PROPVARIANT *) pbDstData = SrcVar;
                    cbDstLength = sizeof (PROPVARIANT);
                }
                else if ( (VT_VARIANT|DBTYPE_BYREF) == vtDst ||
                          (DBTYPE_PROPVARIANT|DBTYPE_BYREF) == vtDst )
                {
                    fDoCopy = FALSE;

                    // Slam the variant into the src data row buffer, then
                    // hand out a pointer to that variant.
                    // We need a home for the variant portion, and that
                    // place should do fine.
                    // The value portion of the variant will still be
                    // owned by the row buffer as a normal deferred value.

                    * (PROPVARIANT *) pbSrcData = SrcVar;
                    * (PROPVARIANT **) pbDstData = (PROPVARIANT *) pbSrcData;
                    cbDstLength = sizeof (PROPVARIANT);
                }
                else if ( isEquivalentType( vtDst, SrcVar.vt ) &&
                          SrcVar.VariantPointerInFirstWord() )
                {
                    // Grab the pointer value out of the variant; any ptr will do
                    fDoCopy = FALSE;
                    * ( (LPWSTR *) pbDstData ) = SrcVar.pwszVal;

                    if ( SrcVar.vt & VT_ARRAY )
                    {
                        cbDstLength = sizeof (SAFEARRAY *);
                    }
                    else
                    {
                        switch (SrcVar.vt )
                        {
                        case VT_LPWSTR:
                            cbDstLength = wcslen(SrcVar.pwszVal) * sizeof (WCHAR);
                            break;
                        case VT_LPSTR:
                            cbDstLength = strlen(SrcVar.pszVal) * sizeof (char);
                            break;
                        case VT_BSTR:
                            cbDstLength = sizeof (BSTR);
                            break;
                        case VT_CLSID:
                            cbDstLength = sizeof (GUID);
                            break;
                        case VT_CF:
                            cbDstLength = sizeof (CLIPDATA);
                            break;
                        default:
                            tbDebugOut(( DEB_ERROR, "SrcVar.vt = 0x%x\n", SrcVar.vt ));
                            Win4Assert( SrcVar.vt != VT_EMPTY &&
                                         !"unexpected variant type!" );
                        }
                    }
                }
                else if ( SrcVar.vt == vtDst )
                {
                    Win4Assert( vtDst & DBTYPE_VECTOR );
                    Win4Assert( vtDst != VT_VARIANT );
                    fDoCopy = FALSE;
                    * (CAL *) pbDstData = SrcVar.cal;
                    cbDstLength = 0;    // vectors defined to be 0 len
                }
                else
                    fFreeDeferredSrc = TRUE;
            }
            else
                fDoCopy = FALSE;
        }
        else
        {
            RtlCopyMemory( &SrcVar, pbSrcData, sizeof SrcVar );
        }
    }
    else
        SrcVar.Init( vtSrc, pbSrcData, rSrcColumn.GetValueSize() );

    if ( fDoCopy )
    {
        DstStatus = SrcVar.OLEDBConvert( pbDstData,
                                         rDstBinding.GetMaxLen(),
                                         vtDst,
                                         _Pool,
                                         cbDstLength,
                                         xDataConvert,
                                         _fExtendedTypes,
                                         ((DBBINDING&)rDstBinding).bPrecision,
                                         ((DBBINDING&)rDstBinding).bScale );

        // Free the deferred value that was in a format that couldn't be
        // used directly (and had to be converted).

        if ( fFreeDeferredSrc )
        {
            PropVariantClear( &SrcVar );
        }
    }

    // If accessor is byref and we had to allocate memory to return a
    // deferred value, we have to tell the row buffer to let go of
    // the memory when the HROW is released.

    if ( ( DBSTATUS_S_OK == DstStatus ) &&
         ( rSrcColumn.IsDeferred( pbSrc ) ) &&
         ( rDstBinding.Binding().dwMemOwner == DBMEMOWNER_PROVIDEROWNED ) &&
         ( ( vtDst & (DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR) ) ||
           ( vtDst == VT_LPWSTR )  ||
           ( vtDst == VT_LPSTR )  ||
           ( vtDst == DBTYPE_BSTR ) ) )
    {
        PROPVARIANT var;
        var.vt = vtDst;

        if ( ( DBTYPE_VARIANT | DBTYPE_BYREF ) == vtDst ||
             ( DBTYPE_PROPVARIANT | DBTYPE_BYREF ) == vtDst )
            var = ** (PROPVARIANT **) pbDstData;
        else if ( vtDst & DBTYPE_VECTOR )
            RtlCopyMemory( &var.calpwstr,
                           pbDstData,
                           sizeof DBVECTOR );
        else
            var.pwszVal = * (WCHAR **) pbDstData;

        tbDebugOut(( DEB_ITRACE, "save away type %x, val %x\n",
                     (int) vtDst,
                     ( vtDst & DBTYPE_VECTOR ) ?
                           (WCHAR *) var.calpwstr.pElems :
                           var.pwszVal ) );

        CDeferredValue value( hrow, var );
        rRowBuffer.AddDeferredValue( value );
        rRowBuffer.SetByrefData( pbSrc );
    }

    return DstStatus;
} //_ComplexCopy

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_ByRefCopy, private
//
//  Synopsis:   Copy a ByRef value.  This hands out a live pointer into the
//              row buffer's storage that the client can read from but not
//              write to or try to free.
//
//  Arguments:  [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [vtSrc]         -- type of the source
//              [rSrcVar]       -- variant to fill as a copy of the source
//                                 data in variant form if the source data
//                                 is not already a variant (and thus has
//                                 a length column in the row buffer)
//              [pbSrcData]     -- pointer to source data
//              [vtDst]         -- type of the destination value
//              [pbDstData]     -- where to write the value
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  Notes:      Coercions are not supported.  This makes sense -- if you
//              want slow coercions you shouldn't be binding byref in the
//              first place.
//
//  History:    25 Jul 95       dlee   created
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_ByRefCopy(
    CDataBinding &  rDstBinding,
    BYTE *          pbSrc,
    CTableColumn &  rSrcColumn,
    VARTYPE         vtSrc,
    CTableVariant & rSrcVar,
    BYTE *          pbSrcData,
    VARTYPE         vtDst,
    BYTE *          pbDstData )
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    RtlZeroMemory( &rSrcVar, sizeof CTableVariant );

    if ( VT_EMPTY == vtSrc )
        return DBSTATUS_S_ISNULL;

    if ( rDstBinding.Binding().wType & DBTYPE_VECTOR )
    {
        if ( DBTYPE_VARIANT == vtSrc )
        {
            CTableVariant & varnt = * ( (CTableVariant *) pbSrcData );

            tbDebugOut(( DEB_ACCESSOR, "byref copy, vtDst 0x%x varnt.vt 0x%x\n",
                         vtDst, varnt.vt ));

            if ( isEquivalentType( vtDst, varnt.vt ) )
                RtlCopyMemory( pbDstData, &(varnt.caub), sizeof DBVECTOR );
            else
                DstStatus = NullOrCantConvert( varnt.vt );
        }
        else if ( isEquivalentType( vtDst, vtSrc ) )
        {
            RtlCopyMemory( pbDstData, pbSrcData, sizeof DBVECTOR );

            // Make a variant in case length is bound for this column

            rSrcVar.vt = vtSrc;
            RtlCopyMemory( &(rSrcVar.caub), pbSrcData, sizeof DBVECTOR );
        }
        else
        {
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        }
    }
    else if ( rDstBinding.Binding().wType & DBTYPE_ARRAY )
    {
        if ( DBTYPE_VARIANT == vtSrc )
        {
            CTableVariant & varnt = * ( (CTableVariant *) pbSrcData );

            tbDebugOut(( DEB_ACCESSOR, "byref copy, vtDst 0x%x varnt.vt 0x%x\n",
                         vtDst, varnt.vt ));

            if ( isEquivalentType( vtDst, varnt.vt ) )
                RtlCopyMemory( pbDstData, &(varnt.parray), sizeof (SAFEARRAY *) );
            else
                DstStatus = NullOrCantConvert( varnt.vt );
        }
        else if ( isEquivalentType( vtDst, vtSrc ) )
        {
            RtlCopyMemory( pbDstData, pbSrcData, sizeof (SAFEARRAY *) );

            // Make a variant in case length is bound for this column

            rSrcVar.vt = vtSrc;
            RtlCopyMemory( &(rSrcVar.parray), pbSrcData, sizeof (SAFEARRAY *) );
        }
        else
        {
            DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
        }
    }
    else
    {
        Win4Assert( (rDstBinding.Binding().wType & DBTYPE_BYREF) ||
                    (rDstBinding.Binding().wType == DBTYPE_BSTR) );

        if ( DBTYPE_VARIANT == vtSrc )
        {
            CTableVariant & varnt = * ( (CTableVariant *) pbSrcData );

            tbDebugOut(( DEB_ACCESSOR, "byref non-vector copy, vtDst 0x%x, varnt.vt 0x%x\n",
                         vtDst, varnt.vt ));

            if ((rDstBinding.Binding().wType & ~DBTYPE_BYREF) == DBTYPE_VARIANT)
            {
                // Just return a pointer to the stored variant
                * (VARIANT **) pbDstData = (VARIANT *) pbSrcData;
            }
            else if ( ( varnt.VariantPointerInFirstWord() ) &&
                      ( isEquivalentType( vtDst, varnt.vt ) ) )
            {
                // Grab the pointer value out of the variant; any ptr will do

                * ( (LPWSTR *) pbDstData ) = varnt.pwszVal;

                // Make a variant in case length is bound for this column

                rSrcVar.vt = varnt.vt;
                rSrcVar.pwszVal = varnt.pwszVal;
            }
            else
            {
                * ( (LPWSTR *) pbDstData ) = 0;
                DstStatus = NullOrCantConvert( varnt.vt );
            }
        }
        else
        {
            // The constructor verified everything is fine -- copy the ptr

            * (void **) pbDstData = * (void **) pbSrcData;

            // Make a variant in case length is bound for this column

            rSrcVar.vt = vtSrc;
            rSrcVar.pwszVal =  * (WCHAR **) pbSrcData;
        }
    }

    if ( rSrcColumn.IsNull( pbSrc ) )
    {
        tbDebugOut(( DEB_ITRACE, "byref column status IsNull\n" ));
        DstStatus = DBSTATUS_S_ISNULL;
    }
    return DstStatus;
} //_ByRefCopy

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::_CopyColumn, private
//
//  Synopsis:   Return a set of row data to the caller
//
//  Arguments:  [pbDst]         -- destination row buffer
//              [rDstBinding]   -- binding for the destination
//              [pbSrc]         -- source row buffer
//              [rSrcColumn]    -- source column description
//              [rSrcSet]       -- set of source columns
//              [iColumn]       -- column being copied
//              [rRowBuffer]    -- row buffer
//              [hrow]          -- hrow being retrieved
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  Returns:    DBSTATUS  -- status of the column copy
//
//  History:    21 Nov 1994       dlee        created
//              09 Jan 1998       vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

DBSTATUS CRowDataAccessor::_CopyColumn(
    BYTE *                            pbDst,
    CDataBinding &                    rDstBinding,
    BYTE *                            pbSrc,
    CTableColumn &                    rSrcColumn,
    CTableColumnSet &                 rSrcSet,
    DBORDINAL                         iColumn,
    CRowBuffer &                      rRowBuffer,
    HROW                              hrow,
    XInterface<IDataConvert>&         xDataConvert)
{
    DBSTATUS DstStatus = DBSTATUS_S_OK;
    DBLENGTH cbDstLength = 0;
    CTableVariant varLen;
    BOOL fVariantValid = FALSE;
    BOOL fLengthValid = FALSE;
    BOOL fStatusValid = FALSE;

    // pull out the data types for clarity below

    VARTYPE vtDst = (VARTYPE) rDstBinding.Binding().wType;
    VARTYPE vtSrc = rSrcColumn.GetStoredType();

    if (DBPART_VALUE & rDstBinding.Binding().dwPart)
    {
        // the row buffer promises NOT to set the byref bit for these.
        // we'll break elsewhere if this is not true.

        Win4Assert(vtSrc != ( VT_LPWSTR | VT_BYREF ) );
        Win4Assert(vtSrc != ( VT_LPSTR  | VT_BYREF ) );

        BYTE *pbSrcData = pbSrc + rSrcColumn.GetValueOffset();
        BYTE *pbDstData = pbDst + rDstBinding.Binding().obValue;

        tbDebugOut(( DEB_ACCESSOR, "copying column %d, vtsrc 0x%x, vtdst 0x%x\n",
                     iColumn, vtSrc, vtDst ));

        // vpath can be null if not an IIS root

        if ( ( iColumn == _iVpathBinding ) &&
             ( !rSrcColumn.IsNull( pbSrc ) ) )
        {
            Win4Assert(VT_VARIANT == vtSrc ||
                       VT_LPWSTR == vtSrc ||
                       VT_BSTR == vtSrc);
            LPWSTR pwszPath = (LPWSTR) pbSrcData;
            if (VT_VARIANT == vtSrc)
                pwszPath = ((PROPVARIANT *)pbSrcData)->pwszVal;
            if (pwszPath)
                ConvertBackslashToSlash(pwszPath);
        }

        if ( DBTYPE_IUNKNOWN == vtDst )
        {
            DstStatus = _BindToObject( pbDstData,
                                       rDstBinding,
                                       pbSrc,
                                       rSrcColumn,
                                       rSrcSet );
        }
        else
        {
            // Transfer a data value

            USHORT cbData, cbAlignment, rgfFlags;
            CTableVariant::VartypeInfo(vtSrc, cbData, cbAlignment, rgfFlags);

            if ( rSrcColumn.IsNull( pbSrc ) && (vtDst & DBTYPE_BYREF) == 0 )
            {
                tbDebugOut(( DEB_ITRACE,
                             "column %d status IsNull -> VT_EMPTY\n",
                             iColumn ));

                RtlZeroMemory( pbDstData, rDstBinding.GetMaxLen() );
                DstStatus = DBSTATUS_S_ISNULL;
            }
            else if ( ( vtDst == vtSrc )                          &&
                      ( vtDst != VT_VARIANT )                     &&
                      ( 0 == (rgfFlags & CTableVariant::ByRef ) ) &&
                      ( 0 != (rgfFlags & CTableVariant::StoreDirect ) ) )
            {
                // Data column equivalent and not indirect, so just copy it.
                // Storage props (except filename/path) will do this.

                cbDstLength = rSrcColumn.GetValueSize();
                fLengthValid = TRUE;
                RtlCopyMemory( pbDstData, pbSrcData, cbDstLength );
            }
            else if ( ( rDstBinding.Binding().dwMemOwner ==
                            DBMEMOWNER_PROVIDEROWNED ) &&
                      ( ! rSrcColumn.IsDeferred( pbSrc ) )  &&
                      ( ( vtDst & DBTYPE_BYREF ) ||
                        ( vtDst & DBTYPE_VECTOR ) ||
                        ( vtDst & VT_ARRAY ) ||
                        ( vtDst == DBTYPE_BSTR ) ) )
            {
                // Efficiently bound filename/path, etc. will do this

                DstStatus = _ByRefCopy( rDstBinding,
                                        pbSrc,
                                        rSrcColumn,
                                        vtSrc,
                                        varLen,
                                        pbSrcData,
                                        vtDst,
                                        pbDstData );

                if ( DBSTATUS_S_OK == DstStatus )
                    rRowBuffer.SetByrefData( pbSrc );
                fVariantValid = TRUE;
            }
            else if (vtDst == DBTYPE_BYTES &&
                     rDstBinding.GetMaxLen() > 1 &&
                     CTableVariant::TableIsStoredInline( rgfFlags, vtSrc ))
            {
                // Special case for small fixed-length fields

                DBLENGTH cbCopy = rSrcColumn.GetValueSize();
                if (rDstBinding.GetMaxLen() < cbCopy)
                {
                    cbCopy = rDstBinding.GetMaxLen();
                    DstStatus = DBSTATUS_S_TRUNCATED;
                }

                RtlCopyMemory(pbDstData, pbSrcData, cbCopy);
                cbDstLength = cbCopy;
                fLengthValid = TRUE;
            }
            else if (vtDst == DBTYPE_BYTES &&
                     rDstBinding.GetMaxLen() > 1 &&
                     vtSrc == VT_VARIANT)
            {
                // Special case for small fixed-length fields from a variant
                CTableVariant * pVarnt = (CTableVariant *)pbSrcData;
                pVarnt->VartypeInfo(pVarnt->vt, cbData, cbAlignment, rgfFlags);

                if (rgfFlags & CTableVariant::SimpleType)
                {
                    DBLENGTH cbCopy = cbData;
                    if (rDstBinding.GetMaxLen() < cbCopy)
                    {
                        cbCopy = rDstBinding.GetMaxLen();
                        DstStatus = DBSTATUS_S_TRUNCATED;
                    }
                    RtlCopyMemory(pbDstData, &(pVarnt->lVal), cbCopy);
                    cbDstLength = cbCopy;
                    fLengthValid = TRUE;
                }
                else
                {
                    DstStatus = DBSTATUS_E_CANTCONVERTVALUE;
                }
            }
            else
            {
                // Copying to/from a variant or a coercion is required.

                DstStatus = _ComplexCopy( rDstBinding,
                                          pbSrc,
                                          rSrcColumn,
                                          iColumn,
                                          vtSrc,
                                          cbDstLength,
                                          pbSrcData,
                                          vtDst,
                                          pbDstData,
                                          rSrcSet,
                                          rRowBuffer,
                                          hrow,
                                          xDataConvert);

                fLengthValid = TRUE;
            }
        }

        // indicate status has been validated
        fStatusValid = TRUE;

        // bump the chapter reference count if we successfully transferred
        // a chapter value
        if ( DBSTATUS_S_OK == DstStatus && rDstBinding.IsChapter() )
            rRowBuffer.ReferenceChapter( pbSrc );
    }

    // fill-in the length if the client asked for it

    if (DBPART_LENGTH & rDstBinding.Binding().dwPart)
    {
        DBLENGTH *pcbDst = (DBLENGTH *) (pbDst + rDstBinding.Binding().obLength);

        if ( ( DBSTATUS_S_ISNULL == DstStatus ) ||
             ( DBSTATUS_E_CANTCONVERTVALUE == DstStatus ) ||
             ( 0 != ( vtDst & DBTYPE_VECTOR ) ) )  // ole-db spec says so
        {
            *pcbDst = 0;
        }
        else if ( fLengthValid )
        {
            *pcbDst = cbDstLength;
        }
        else if (! isVariableLength( vtDst ) )
        {
            if ( vtDst & VT_BYREF )
            {
                USHORT cbWidth, cbAlign, fFlags;
                CTableVariant::VartypeInfo( vtDst & ~VT_BYREF, cbWidth, cbAlign, fFlags );

                *pcbDst = cbWidth;
            }
            else
            {
                *pcbDst = rDstBinding.GetMaxLen();
            }
        }
        else
        {
            DBLENGTH cbLen = 0;

            if (fVariantValid)
            {
                Win4Assert ( varLen.vt != VT_EMPTY );
                cbLen = varLen.VarDataSize();
            }
            else
            {
                //
                // DBBINDING doesn't want DBPART_VALUE
                //

                SCODE sc = S_OK;
                ULONG cbDstBufNeeded = 0;
                DBTYPE dbtypeSrc;
                COLEDBVariant SrcVar;

                BYTE *pbSrcData = pbSrc + rSrcColumn.GetValueOffset();
                RtlCopyMemory( &SrcVar, pbSrcData, sizeof SrcVar );
                
                SrcVar.GetDstLength( xDataConvert, 
                                     rDstBinding.Binding().wType,
                                     cbLen );
            }

            // WSTR and STR lengths shouldn't include the terminating NULL
            if ( (vtDst & VT_TYPEMASK) == DBTYPE_WSTR ||
                 vtDst == VT_LPWSTR )
                cbLen -= sizeof (WCHAR);
            else if ( (vtDst & VT_TYPEMASK) == DBTYPE_STR ||
                 vtDst == VT_LPSTR )
                cbLen -= sizeof (char);
            else if (vtDst == DBTYPE_BSTR)
                cbLen = sizeof (BSTR);

            *pcbDst = cbLen;
        }
    }

    if (! fStatusValid)
    {
        if ( rSrcColumn.IsStatusStored() &&
             rSrcColumn.GetStatus( pbSrc ) == CTableColumn::StoreStatusNull )
            DstStatus = DBSTATUS_S_ISNULL;
    }

    if (DBPART_STATUS & rDstBinding.Binding().dwPart)
    {
        * (DBSTATUS *) (pbDst + rDstBinding.Binding().obStatus) = DstStatus;
    }

    return DstStatus;
} //_CopyColumn

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessor::GetData, public
//
//  Synopsis:   Copies data into the buffer as specified when the accessor
//              was created
//
//  Arguments:  [hRow]          -- row whose data is copied
//              [pData]         -- where data is written
//              [rBufferSet]    -- object useful for transforming an HROW
//                                 into a buffer and a column layout
//              [rQuery]        -- query to use for this getdata
//              [colInfo]       -- info about the columns
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  History:    21 Nov 1994       dlee        created
//              09 Jan 1998       vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

void CRowDataAccessor::GetData(
    HROW            hRow,
    void *          pData,
    CRowBufferSet & rBufferSet,
    PQuery &        rQuery,
    CColumnsInfo &  colInfo,
    XInterface<IDataConvert>&         xDataConvert)
{

    if ( _idColInfo != colInfo.GetId() )
    {
        // We have a different columnsInfo with which we must validate.

        Validate( colInfo, 0 );
    }

    _pQuery = &rQuery;  // query to be used for this data retrieval

    // first find the source data buffer and its layout

    CLock lock( rBufferSet.GetBufferLock() );

    CTableColumnSet *pRowBufColSet;
    BYTE *pbSrc;

    CRowBuffer &rRowBuffer = rBufferSet.Lookup( hRow,
                                                &pRowBufColSet,
                                                (void **) &pbSrc );

    // now copy the data from the internal buffer to the user's buffer

    ULONG cCopied = 0;

    // We need to determine whether all the conversions failed or
    // all of them succeeded or some failed/some passed
    ULONG cSuccess = 0;

    TRY
    {
        for ( cCopied = 0; cCopied < _cBindings; cCopied++ )
        {
            CTableColumn *pSrcCol = rRowBuffer.Find( (ULONG)
                                      _aBindings[cCopied].GetDataColumn() );

            if ( 0 == pSrcCol )
            {
                // Somehow, the row buffer doesn't have a column that's in
                // the accessor.  This is an internal error.

                Win4Assert(!"CRowDataAccessor::GetData couldn't find column binding");
            }

            DBSTATUS DstStatus = _CopyColumn( (BYTE *) pData,
                                              _aBindings[cCopied],
                                              pbSrc,
                                              *pSrcCol,
                                              *pRowBufColSet,
                                              cCopied,
                                              rRowBuffer,
                                              hRow,
                                              xDataConvert);

            tbDebugOut(( DEB_ITRACE, "GetData column %d, status 0x%x\n",
                         cCopied, DstStatus ));

            // see if we have a coercion error.  any other column status will
            // not result in a special return code from GetData -- it's just
            // reflected in the column status field (if the user asks for it)

            if ( DBStatusOK( DstStatus ) )
            {
                // Success
                cSuccess++;
            }
        }
    }
    CATCH( CException, e )
    {
        // fatal error -- free the data allocated so far for return to the
        // client, then rethrow the error condition

        for ( ULONG i = 0; i < cCopied; i++ )
            if ( _aBindings[i].Binding().dwMemOwner != DBMEMOWNER_PROVIDEROWNED )
                CTableVariant::Free( (BYTE *) pData + _aBindings[i].Binding().obValue,
                                     (VARTYPE) _aBindings[i].Binding().wType,
                                     _Pool );

        RETHROW();
    }
    END_CATCH;

    if ( cSuccess == _cBindings )   // takes care of _cBindings == 0 case
    {
        // AllSuccess
        ; // do nothing
    }
    else if ( cSuccess == 0 )
    {
        // AllFail
        QUIETTHROW( CException( DB_E_ERRORSOCCURRED ) );
    }
    else
    {
        // SomeSuccess/SomeFail
        QUIETTHROW( CException( DB_S_ERRORSOCCURRED ) );
    }

} //GetData

//+-------------------------------------------------------------------------
//
//  Member:     CRowDataAccessorByRef::GetData, public
//
//  Synopsis:   Copies data into the buffer as specified when the accessor
//              was created.  For provider-owned memory with variant byref
//              binding.
//
//  Arguments:  [hRow]          -- row whose data is copied
//              [pData]         -- where data is written
//              [rBufferSet]    -- object useful for transforming an HROW
//                                 into a buffer and a column layout
//              [rQuery]        -- query to use for this getdata
//              [colInfo]       -- info about the columns
//              [xDataConvert]  -- smart pointer to IDataConvert interface.
//                                 this is to be passed along and used finally
//                                 in COLEDBVariant::CopyOrCoerce
//
//  History:    09 Apr 1996       dlee        created
//              09 Jan 1998       vikasman    added xDataConvert parameter
//
//--------------------------------------------------------------------------

void CRowDataAccessorByRef::GetData(
    HROW                       hRow,
    void *                     pData,
    CRowBufferSet &            rBufferSet,
    PQuery &                   rQuery,
    CColumnsInfo &             colInfo,
    XInterface<IDataConvert> & xDataConvert)
{
    // we validated the column info on construction

    Win4Assert ( _idColInfo == colInfo.GetId() );

    // first find the source data buffer and its layout

    CLock lock( rBufferSet.GetBufferLock() );

    CTableColumnSet *pRowBufColSet;
    BYTE *pbSrc;

    CRowBuffer &rRowBuffer = rBufferSet.Lookup( hRow,
                                                &pRowBufColSet,
                                                (void **) &pbSrc );

    // now copy the data from the internal buffer to the user's buffer

    for ( unsigned iCol = 0; iCol < _cBindings; iCol++ )
    {
        CDataBinding & dstDataBinding = _aBindings[ iCol ];
        CTableColumn & rSrcCol = * rRowBuffer.Find( (ULONG)
                                   dstDataBinding.GetDataColumn() );

        Win4Assert( 0 != &rSrcCol &&
                    "CRowDataAccessorByRef::GetData couldn't find column binding");

        BYTE *pbSrcData = pbSrc + rSrcCol.GetValueOffset();
        DBBINDING & DstBinding = dstDataBinding.Binding();

        Win4Assert( (DBTYPE_VARIANT|DBTYPE_BYREF) == DstBinding.wType ||
                    (DBTYPE_PROPVARIANT|DBTYPE_BYREF) == DstBinding.wType );
        Win4Assert( DBPART_VALUE == DstBinding.dwPart );
        Win4Assert( VT_VARIANT == rSrcCol.GetStoredType() );

        PROPVARIANT **ppDstVar = (PROPVARIANT **) ( ( (BYTE*) pData ) +
                                                    DstBinding.obValue );

        if ( !rSrcCol.IsDeferred( pbSrc ) )
        {
            // Convert '\' to '/' if this is the vpath.
            // Vpath can be null if the file is not in an indexed IIS vroot.

            if ( ( iCol == _iVpathBinding ) &&
                 ( !rSrcCol.IsNull( pbSrc ) ) )
            {
                Win4Assert( VT_LPWSTR == ((PROPVARIANT *)pbSrcData)->vt ||
                            VT_BSTR == ((PROPVARIANT *)pbSrcData)->vt );

                LPWSTR pwszPath = ((PROPVARIANT *)pbSrcData)->pwszVal;
                if (pwszPath)
                    ConvertBackslashToSlash(pwszPath);
            }

            *ppDstVar = (PROPVARIANT *) pbSrcData;

            #if CIDBG==1
                if ( rSrcCol.IsNull( pbSrc ) )
                {
                    Win4Assert( VT_EMPTY == (*ppDstVar)->vt );
                }
            #endif // CIDBG==1
        }
        else
        {
            // deferred copies can go through this slow code path

            _pQuery = &rQuery;  // query to be used for this data retrieval

            DBLENGTH cbDstLen;

            _ComplexCopy( _aBindings[iCol],
                          pbSrc,
                          rSrcCol,
                          iCol,
                          rSrcCol.GetStoredType(),
                          cbDstLen,
                          pbSrcData,
                          DBTYPE_PROPVARIANT | DBTYPE_BYREF,
                          (BYTE *) ppDstVar,
                          *pRowBufColSet,
                          rRowBuffer,
                          hRow,
                          xDataConvert);
        }

        // bump the chapter reference count if we transferred
        // a chapter value
        if ( dstDataBinding.IsChapter() )
            rRowBuffer.ReferenceChapter( pbSrc );
    }
    rRowBuffer.SetByrefData( pbSrc );
} //GetData

//+-------------------------------------------------------------------------
//
//  Function:   CreateAnAccessor
//
//  Synopsis:   Creates an accessor object deriving from CAccessor that is
//              best-suited to handling the binding flags.
//
//  Arguments:  [dwAccessorFlags] -- read/write access requested
//              [cBindings]       -- # of bindings in rgBindings
//              [rgBindings]      -- array of bindings
//              [rgBindStatus]    -- array of binding statuses
//              [fExtTypes]       -- TRUE if extended variants are supported
//              [pColumns]        -- column info, may be 0
//
//  History:    9 Apr 96       dlee   created
//
//--------------------------------------------------------------------------

CAccessor * CreateAnAccessor(
    DBACCESSORFLAGS   dwAccessorFlags,
    DBCOUNTITEM       cBindings,
    const DBBINDING * rgBindings,
    DBBINDSTATUS *    rgBindStatus,
    BOOL              fExtTypes,
    void *            pCreator,
    CColumnsInfo *    pColumns )
{
    BOOL fByRefCandidate = TRUE;

    // CRowDataAccessorByRef candidates must:
    //    - have a non-0 pColumns
    //    - allow extended variant types (PROPVARIANT)
    //    - only bind to VALUE, not STATUS or LENGTH
    //    - only bind as DBTYPE_PROPVARIANT or DBTYPE_VARIANT byref
    //    - only bind with DBMEMOWNER_PROVIDEROWNED
    //
    // Accessors that don't meet these criteria go through the slower
    // CRowDataAccessor.

    if ( ( 0 == pColumns ) ||
         ( dwAccessorFlags != DBACCESSOR_ROWDATA ) ||
         ! fExtTypes )
        fByRefCandidate = FALSE;

    for ( DBORDINAL iBinding = 0;
          fByRefCandidate && iBinding < cBindings;
          iBinding++ )
    {
        DBBINDING const & b = rgBindings[ iBinding ];

        if ( b.dwPart != DBPART_VALUE ||
             b.dwMemOwner != DBMEMOWNER_PROVIDEROWNED ||
             (( b.wType != (DBTYPE_PROPVARIANT|DBTYPE_BYREF) ) &&
                (! fExtTypes ||
                   b.wType != (DBTYPE_VARIANT|DBTYPE_BYREF) ) ) )
            fByRefCandidate = FALSE;
    }

    tbDebugOut(( DEB_ITRACE, "accessor can be byref: %d\n", fByRefCandidate ));

    if ( fByRefCandidate )
        return new CRowDataAccessorByRef( dwAccessorFlags,
                                          cBindings,
                                          rgBindings,
                                          rgBindStatus,
                                          TRUE,
                                          pCreator,
                                          pColumns );

    return new CRowDataAccessor( dwAccessorFlags,
                                 cBindings,
                                 rgBindings,
                                 rgBindStatus,
                                 fExtTypes,
                                 pCreator,
                                 pColumns );
} //CreateAnAccessor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\query.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       query.cxx
//
//  Contents:   Class encapsulating all the context for a running
//              query, including the query execution context, the
//              cached query results, and all cursors over the
//              results.
//              Dispatches requests to the appropriate subobject.
//
//  Classes:    CAsyncQuery
//              CGetRowsParams
//
//  History:    31 May 94       AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <srequest.hxx>
#include <rowseek.hxx>
#include <tbrowkey.hxx>
#include <oleprop.hxx>

#include "tabledbg.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CGetRowsParams::GetRowBuffer, public inline
//
//  Synopsis:   Return a pointer to the row buffer.  If this is the first
//              reference, get it from the fixed allocator.
//
//  Arguments:  - none -
//
//  Returns:    PBYTE - a pointer to the row buffer.
//
//  Notes:      We don't put this in query.hxx since we don't want to
//              have to refer to PFixedVarAllocator there.
//
//--------------------------------------------------------------------------

PBYTE   CGetRowsParams::GetRowBuffer( void )
{
    if (0 == _pData)
        _pData = _rAllocator.AllocFixed();
    return (PBYTE) _pData;
}

PBYTE   CGetRowsParams::GetBuffer( ) const
                    { return _rAllocator.BufferAddr(); }


//+---------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::CAsyncQuery, public
//
//  Synopsis:   Creates a locally accessible Query
//
//  Arguments:  [qopt]         - Query optimizer
//              [col]          - Initial set of columns to return
//              [sort]         - Initial sort
//              [categ]        - Categorization specification
//              [cCursors]     - # of cursors to create
//              [aCursors]     - array of cursors returned
//              [pidremap]     - prop ID mapping
//              [fEnableNotification] - if TRUE, allow watches
//              [pDocStore]    - client doc store
//              [pEvtComplete] - completion event
//
//----------------------------------------------------------------------------

CAsyncQuery::CAsyncQuery( XQueryOptimizer & qopt,
                          XColumnSet & col,
                          XSortSet & sort,
                          XCategorizationSet &categ,
                          unsigned cCursors,
                          ULONG * aCursors,
                          XInterface<CPidRemapper> & pidremap,
                          BOOL fEnableNotification,
                          ICiCDocStore *pDocStore,
                          CRequestServer * pQuiesce
                        )
        : _fCanDoWorkidToPath( !qopt->IsWorkidUnique() ),
          PQuery( ),
          _ref( 1 ),
          _pidremap( pidremap.Acquire() ),
          _Table( col,
                  sort,
                  cCursors - 1,
                  _mutex,
                  !_fCanDoWorkidToPath,
                  pQuiesce ),
          _cRowsLastAsked (0),
          _aCursors( ),
          _aCategorize( cCursors - 1 )

{
    //
    // Get ci manager and translator interfaces
    //
    ICiManager *pCiManager = 0;
    SCODE sc = pDocStore->GetContentIndex( &pCiManager );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support GetContentIndex interface" );

        THROW( CException( sc ) );
    }
    _xCiManager.Set( pCiManager );

    ICiCDocNameToWorkidTranslator *pNameToWidTranslator;
    sc = pDocStore->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                    (void **) &pNameToWidTranslator );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support translator QI" );

        THROW( CException( sc ) );
    }
    _xNameToWidTranslator.Set( pNameToWidTranslator );

    Win4Assert( 0 != cCursors );

    // make a cursor for the main table and each categorization level

    for (unsigned cursor = 0; cursor < cCursors; cursor++)
        aCursors[cursor] = _CreateRowCursor();

    // the last cursor is associated with the main table

    _aCursors.Lookup(aCursors[cCursors - 1]).SetSource( &_Table );

    if (cCursors > 1)
    {
        //
        //  NOTE:  pidWorkid is always added to the sort set in the table,
        //         so it should always be sorted.  That's why it's sort count-1
        //  SPECDEVIATION - if workid was already in the sort, this test
        //         is incorrect. Who would want to categorize on workid though?
        //
        if ( ! _Table.IsSorted() ||
             cCursors-1 > _Table.GetSortSet()->Count()-1 )
        {
            // CLEANCODE: Should this check be handled in the categorizers?
            //            Is it specific to the unique categorization?

            tbDebugOut(( DEB_WARN, "Query contains too few sort specs "
                                   "for categorization spec\n" ));
            THROW( CException( E_INVALIDARG ) );
        }

        // this is a categorized table, so set up the categorizers

        for ( unsigned cat = 0; cat < (cCursors - 1); cat++ )
        {
            _aCategorize[cat] = new CCategorize( * (categ->Get(cat)),
                                                 cat + 1,
                                                 cat ? _aCategorize[cat-1] : 0,
                                                 _mutex );
            _aCursors.Lookup(aCursors[cat]).SetSource( _aCategorize[cat] );
        }

        _Table.SetCategorizer(_aCategorize[cCursors - 2]);

        // now tell each categorizer what it is categorizing over

        for ( cat = 0; cat < (cCursors - 2); cat++ )
            _aCategorize[cat]->SetChild( _aCategorize[ cat + 1 ] );

        _aCategorize[ cCursors - 2 ]->SetChild( & _Table );
    }

    // Without the lock, the query can be complete and destructed
    // BEFORE the constructor finishes

    CLock lock( _mutex );

    //
    // Since we can be swapping rows, we may need singleton cursor(s)
    //

    qopt->EnableSingletonCursors();

    if ( 0 != pQuiesce )
        pQuiesce->SetPQuery( (PQuery *) this );

    _QExec.Set( new CQAsyncExecute( qopt, fEnableNotification, _Table, pDocStore ) );
    _Table.SetQueryExecute( _QExec.GetPointer() );

    ciDebugOut(( DEB_USER1, "Using an asynchronous cursor.\n" ));

    END_CONSTRUCTION( CAsyncQuery );
}

//+---------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::~CAsyncQuery, public
//
//  Synopsis:   Destroy the query
//
//----------------------------------------------------------------------------

CAsyncQuery::~CAsyncQuery()
{
    CLock lock( _mutex );

    //Win4Assert( _ref == 0 );  This isn't true when queries are aborted

    _Table.ReleaseQueryExecute();
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::AddRef, public
//
//  Synopsis:   Reference the query.
//
//--------------------------------------------------------------------------

ULONG CAsyncQuery::AddRef(void)
{
    return InterlockedIncrement( &_ref );
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::Release, public
//
//  Synopsis:   De-Reference the query.
//
//  Effects:    If the ref count goes to 0 then the query is deleted.
//
//--------------------------------------------------------------------------

ULONG CAsyncQuery::Release(void)
{
    long l = InterlockedDecrement( &_ref );
    if ( l <= 0 )
    {
        tbDebugOut(( DEB_ITRACE, "CAsyncQuery unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::_CreateRowCursor, private
//
//  Synopsis:   Create a new CTableCursor, return a handle to it.
//
//  Arguments:  - none -
//
//  Returns:    ULONG - handle associated with the new cursor.  Will
//                      be zero if the cursor could not be created.
//
//  Notes:      There needs to be a subsequent call to SetBindings prior
//              to any call to GetRows.
//
//--------------------------------------------------------------------------

ULONG CAsyncQuery::_CreateRowCursor( )
{
    CTableCursor * pCursor = new CTableCursor;

    ULONG hCursor = 0;

    _aCursors.Add(pCursor, hCursor);

    // By default, make the cursor refer to the real table,
    // not categorization

    pCursor->SetSource(&_Table);

    Win4Assert(hCursor != 0);

    return hCursor;
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::FreeCursor, public
//
//  Synopsis:   Free a handle to a CTableCursor
//
//  Arguments:  [hCursor] - handle to the cursor to be freed
//
//  Returns:    # of cursors left
//
//--------------------------------------------------------------------------

unsigned CAsyncQuery::FreeCursor(
    ULONG       hCursor )
{
    Win4Assert( hCursor != 0 );

    _aCursors.Release(hCursor);

    return _aCursors.Count();
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::SetBindings, public
//
//  Synopsis:   Set column bindings into a cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to set bindings on
//              [cbRowLength] - the width of an output row
//              [cols] - a description of column bindings to be set
//              [pids] - a PID mapper which maps fake pids in cols to
//                      column IDs.
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void
CAsyncQuery::SetBindings(
    ULONG             hCursor,
    ULONG             cbRowLength,
    CTableColumnSet & cols,
    CPidMapper &      pids )
{
    CTableCursor& rCursor = _aCursors.Lookup(hCursor);

    if (0 == cols.Count() ||
        0 == cbRowLength || cbRowLength >= USHRT_MAX)
        THROW( CException( E_INVALIDARG ));

    XPtr<CTableColumnSet> outset(new CTableColumnSet( cols.Count() ));

    for (unsigned iCol = 0; iCol < cols.Count(); iCol++)
    {
        CTableColumn * pCol = cols.Get( iCol );

        CFullPropSpec * propspec = pids.Get( pCol->PropId );

        //
        //  Convert the DBID to a PROPID
        //
//      Win4Assert( iCol+1 == pCol->PropId );   // therefore pids is useless

        PROPID prop = _pidremap->NameToReal(propspec);

        if ( prop == pidInvalid || _Table.IsColumnInTable(prop) == FALSE )
        {
            tbDebugOut(( DEB_ERROR, "Column unavailable: prop = 0x%x\n", prop ));
            THROW( CException( DB_E_BADCOLUMNID ));
        }

        if (pCol->IsCompressedCol())
            THROW( CException( E_INVALIDARG ));

        XPtr<CTableColumn> xpOutcol ( new CTableColumn( prop, pCol->GetStoredType() ) );

        if (pCol->IsValueStored())
            xpOutcol->SetValueField(pCol->GetStoredType(),
                                    pCol->GetValueOffset(),
                                    pCol->GetValueSize());

        Win4Assert( pCol->IsStatusStored() );
        xpOutcol->SetStatusField(pCol->GetStatusOffset(),
                                 (USHORT)pCol->GetStatusSize());

        if (pCol->IsLengthStored())
            xpOutcol->SetLengthField(pCol->GetLengthOffset(),
                                     (USHORT)pCol->GetLengthSize());

        outset->Add(xpOutcol, iCol);
    }

    SCODE sc = rCursor.SetBindings( cbRowLength, outset );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //SetBindings


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [hCursor]      - the handle of the cursor to fetch data for
//              [rSeekDesc]    - row seek operation to be done before fetch
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - row seek description for restart
//
//  Returns:    SCODE - the status of the operation.  E_HANDLE
//                      is returned if hCursor cannot be looked up,
//                      presumably an internal error.
//
//  History:    24 Jan 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CAsyncQuery::GetRows(
    ULONG                       hCursor,
    const CRowSeekDescription & rSeekDesc,
    CGetRowsParams&             rFetchParams,
    XPtr<CRowSeekDescription> & pSeekDescOut)
{
    CTableCursor & rCursor = _aCursors.Lookup(hCursor);
    rCursor.ValidateBindings();

    CTableSource & rSource = rCursor.GetSource();

    Win4Assert(rCursor.GetRowWidth() == rFetchParams.GetRowWidth());

    return rSeekDesc.GetRows( rCursor,
                              rSource,
                              rFetchParams,
                              pSeekDescOut );
} //GetRows

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::RestartPosition, public
//
//  Synopsis:   Reset fetch position for chapter to the start
//
//  Arguments:  [hCursor]      - the handle of the cursor to restart
//              [chapter]      - the chapter to restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    17 Apr 1997     EmilyB    Created
//
//--------------------------------------------------------------------------

void
CAsyncQuery::RestartPosition(
                             ULONG          hCursor,
                             CI_TBL_CHAPT   chapter)
{
   CTableCursor & rCursor = _aCursors.Lookup(hCursor);
   CTableSource & rSource = rCursor.GetSource();

   rSource.RestartPosition ( chapter );
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator] - on return, numerator of fraction
//              [rcRows] - on return, number of rows in cursor
//              [rfNewRows] - on return, TRUE if new rows available
//
//  Returns:    nothing
//
//  Notes:      A handle of zero can be passed for use with sequential
//              cursors to check completion before a handle exists.
//
//--------------------------------------------------------------------------

void       CAsyncQuery::RatioFinished(
    ULONG         hCursor,
    DBCOUNTITEM & rulDenominator,
    DBCOUNTITEM & rulNumerator,
    DBCOUNTITEM & rcRows,
    BOOL &        rfNewRows
) {
    if (hCursor != 0)
        CTableCursor& rCursor = _aCursors.Lookup(hCursor); // For error check

    rulDenominator = 1;
    rulNumerator = 0;
    rfNewRows = FALSE;

    unsigned status = QUERY_FILL_STATUS(_Table.Status());

    //
    // SPECDEVIATION: should do something more meaningful with STAT_ERROR
    // RatioFinished should probably fail in this case.
    //

    if (STAT_DONE    == status  ||
        STAT_ERROR   == status  ||
        STAT_REFRESH == status)
    {
        rulNumerator = 1;
        rcRows = _Table.RowCount();

        if (rcRows != _cRowsLastAsked)
        {
            _cRowsLastAsked = rcRows;
            rfNewRows = TRUE;
        }
        return;
    }

    _Table.RatioFinished (rulDenominator, rulNumerator, rcRows);

    if (rcRows != _cRowsLastAsked)
    {
        _cRowsLastAsked = rcRows;
        rfNewRows = TRUE;
    }
    Win4Assert( rulDenominator >= rulNumerator );
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::Compare, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to compare bmks from
//              [bmkFirst] - First bookmark to compare
//              [bmkSecond] - Second bookmark to compare
//              [rdwComparison] - on return, comparison value
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void       CAsyncQuery::Compare(
    ULONG       hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK bmkFirst,
    CI_TBL_BMK bmkSecond,
    DWORD &     rdwComparison
) {
    rdwComparison = DBCOMPARE_NOTCOMPARABLE;
    CTableCursor& rCursor = _aCursors.Lookup(hCursor);
    CTableSource & rSource = rCursor.GetSource();

    DBCOUNTITEM ulNum1, ulDen1;
    SCODE scRet = rSource.GetApproximatePosition( chapt,
                                                  bmkFirst,
                                                  &ulNum1,
                                                  &ulDen1);

    DBCOUNTITEM ulNum2, ulDen2;
    if (SUCCEEDED(scRet))
    {
        scRet = rSource.GetApproximatePosition( chapt,
                                                bmkSecond,
                                                &ulNum2,
                                                &ulDen2);
    }

    if (SUCCEEDED(scRet))
    {
        Win4Assert(ulDen1 == ulDen2);
        if (ulNum1 < ulNum2)
            rdwComparison = DBCOMPARE_LT;
        else if (ulNum1 > ulNum2)
            rdwComparison = DBCOMPARE_GT;
        else // ulNum1 == ulNum2
            rdwComparison = DBCOMPARE_EQ;
    }

    // CLEANCODE - have the source table THROW if errors in GetApproximatePosition
    if (scRet != S_OK)
        THROW(CException(scRet));
}


//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetApproximatePosition, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to retrieve info. from
//              [bmk]     - bookmark of row to get position of
//              [pulNumerator] - on return, numerator of fraction
//              [pulDenominator] - on return, denominator of fraction
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void
CAsyncQuery::GetApproximatePosition(
    ULONG       hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK bmk,
    DBCOUNTITEM * pulNumerator,
    DBCOUNTITEM * pulDenominator 
) {
    CTableCursor& rCursor = _aCursors.Lookup(hCursor);
    CTableSource & rSource = rCursor.GetSource();

    SCODE scRet = rSource.GetApproximatePosition( chapt,
                                           bmk,
                                           pulNumerator,
                                           pulDenominator);

    // CLEANCODE - have the source table THROW if errors in GetApproximatePosition
    if (scRet != S_OK)
        THROW(CException(scRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetNotifications, private
//
//  Synopsis:   Retrieves the notification info from the query object
//              row data.
//
//  Arguments:  [rSync]    -- notification synchronization info
//              [rParams]  -- notification data info
//
//  Returns:    SCODE
//
//  History:    10-24-94     dlee      created
//
//----------------------------------------------------------------------------

SCODE
CAsyncQuery::GetNotifications(
    CNotificationSync & rSync,
    DBWATCHNOTIFY     & changeType )
{
    return _Table.GetNotifications(rSync,changeType);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::SetWatchMode
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [phRegion] -- handle to watch region
//              [mode] -- watch mode
//
//  History:    May-2-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::SetWatchMode (
    HWATCHREGION* phRegion,
    ULONG mode)
{
    if (*phRegion == watchRegionInvalid)
        _Table.CreateWatchRegion (mode, phRegion);
    else
        _Table.ChangeWatchMode (*phRegion, mode);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetWatchInfo
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion] -- handle to watch region
//              [pMode] -- watch mode
//              [pChapter] -- chapter
//              [pBookmark] -- bookmark
//              [pcRows] -- number of rows
//
//  History:    May-2-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::GetWatchInfo (
    HWATCHREGION hRegion,
    ULONG* pMode,
    CI_TBL_CHAPT*   pChapter,
    CI_TBL_BMK*     pBookmark,
    DBCOUNTITEM*    pcRows)
{
    _Table.GetWatchRegionInfo (hRegion, pChapter, pBookmark, (DBROWCOUNT *)pcRows);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::ShrinkWatchRegion
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion] -- handle to watch region
//              [pChapter] -- chapter
//              [pBookmark] -- bookmark
//              [cRows] -- number of rows
//
//  History:    May-2-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::ShrinkWatchRegion (
    HWATCHREGION hRegion,
    CI_TBL_CHAPT   chapter,
    CI_TBL_BMK     bookmark,
    LONG cRows )
{
    if (cRows == 0)
        _Table.DeleteWatchRegion (hRegion);
    else
        _Table.ShrinkWatchRegion (hRegion, chapter, bookmark, cRows);
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::Refresh
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [] --
//
//  History:    Arp-4-95   BartoszM    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::Refresh()
{
    _Table.Refresh();
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetQueryStatus, public
//
//  Synopsis:   Return the query status
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rdwStatus] - on return, the query status
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void       CAsyncQuery::GetQueryStatus(
    ULONG           hCursor,
    DWORD &         rdwStatus)
{
    rdwStatus = _Table.Status();
}

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::GetQueryStatusEx, public
//
//  Synopsis:   Return the query status plus bonus information.  It's kind
//              of an odd assortment of info, but it saves net trips.
//
//  Arguments:  [hCursor] - handle of the cursor to check completion for
//              [rdwStatus] - returns the query status
//              [rcFilteredDocuments] - returns # of filtered docs
//              [rcDocumentsToFilter] - returns # of docs to filter
//              [rdwRatioFinishedDenominator] - ratio finished denom
//              [rdwRatioFinishedNumerator]   - ratio finished num
//              [bmk]                         - bmk to find
//              [riRowBmk]                    - index of bmk row
//              [rcRowsTotal]                 - # of rows in table
//
//  History:    Nov-9-96   dlee    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::GetQueryStatusEx(
    ULONG         hCursor,
    DWORD       & rdwStatus,
    DWORD       & rcFilteredDocuments,
    DWORD       & rcDocumentsToFilter,
    DBCOUNTITEM & rdwRatioFinishedDenominator,
    DBCOUNTITEM & rdwRatioFinishedNumerator,
    CI_TBL_BMK    bmk,
    DBCOUNTITEM & riRowBmk,
    DBCOUNTITEM & rcRowsTotal )
{
    rdwStatus = _Table.Status();

    CIF_STATE state;
    state.cbStruct = sizeof state;

    SCODE sc = _xCiManager->GetStatus( &state );
    if ( SUCCEEDED( sc ) )
    {
        rcFilteredDocuments = state.cFilteredDocuments;
        rcDocumentsToFilter = state.cDocuments;
    }
    else
    {
        ciDebugOut(( DEB_ERROR, "CAsyncQuery::GetQueryStatusEx, get status failed, 0x%x\n", sc ));

        rcFilteredDocuments = 0;
        rcDocumentsToFilter = 0;
    }

    DBCOUNTITEM cRows;
    BOOL fNewRows;
    RatioFinished( hCursor,
                   rdwRatioFinishedDenominator,
                   rdwRatioFinishedNumerator,
                   cRows,
                   fNewRows );

    GetApproximatePosition( hCursor,
                            0,
                            bmk,
                            & riRowBmk,
                            & rcRowsTotal );
} //GetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::WorkIdToPath
//
//  Synopsis:   Converts a wid to a path
//
//  Arguments:  [wid]       -- of the file to be translated
//              [funnyPath] -- resulting path
//
//  History:    Jun-1-95   dlee    Created
//
//--------------------------------------------------------------------------

void CAsyncQuery::WorkIdToPath( WORKID wid, CFunnyPath & funnyPath )
{
    if ( _fCanDoWorkidToPath )
    {
        ULONG cbBuf = MAX_PATH * sizeof WCHAR; // first guess -- it may be more
        XArray<BYTE> xBuf( cbBuf );
        CInlineVariant * pVariant = (CInlineVariant *) xBuf.GetPointer();

        if (! _Table.WorkIdToPath( wid, *pVariant, cbBuf ) )
        {
            if ( 0 != cbBuf )
            {
                BYTE *pb = xBuf.Acquire();
                delete [] pb;
                cbBuf += sizeof CInlineVariant;
                xBuf.Init( cbBuf );
                _Table.WorkIdToPath( wid, *pVariant, cbBuf );
            }
        }

        if ( 0 != cbBuf )
        {
            WCHAR *pwc = (WCHAR *) pVariant->GetVarBuffer();
            funnyPath.SetPath( pwc );
        }
    }
    else
    {
        ICiCDocName *pDocName;
        SCODE sc = _xNameToWidTranslator->QueryDocName( &pDocName );
        if ( SUCCEEDED( sc ) )
        {
            XInterface<ICiCDocName> xDocName( pDocName );

            sc = _xNameToWidTranslator->WorkIdToDocName( wid,
                                                         xDocName.GetPointer() );
            if ( SUCCEEDED( sc ) && sc != CI_S_WORKID_DELETED )
            {
                // PERFFIX: Here we are using two buffers XGrowable and CFunnyPath.
                // This can be avoided if xDocName->Get can take in CFunnyPath instead of WCHAR*

                XGrowable<WCHAR> xBuf(MAX_PATH);
                ULONG cb = xBuf.SizeOf();

                sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
                if ( CI_E_BUFFERTOOSMALL == sc )
                {
                    xBuf.SetSizeInBytes( cb );
                    sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
                }

                if ( SUCCEEDED( sc ) )
                {
                    funnyPath.SetPath( xBuf.Get() );
                }
            }
        }
    }
} //WorkIdToPath

BOOL CAsyncQuery::CanDoWorkIdToPath()
{
    return _fCanDoWorkidToPath;
} //CanDoWorkIdToPath

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::FetchDeferredValue
//
//  Synopsis:   Fetch deferred value from property cache
//
//  Arguments:  [wid] -- Workid.
//              [ps]  -- Property to be fetched.
//              [var] -- Property returned here.
//
//  History:    Jun-1-95   KyleP   Created
//
//--------------------------------------------------------------------------

BOOL CAsyncQuery::FetchDeferredValue(
    WORKID                wid,
    CFullPropSpec const & ps,
    PROPVARIANT &         var )
{
    //
    // If using a NULL catalog, assume a file system and go get the value.
    // The NULL catalog case is only supported by fsci, anyway, so it's
    // ok to do this hack.
    //

    if ( _fCanDoWorkidToPath )
    {
        CFunnyPath funnyPath;
        WorkIdToPath( wid, funnyPath );

        COLEPropManager propMgr;
        propMgr.Open( funnyPath );
        return propMgr.ReadProperty( ps, var );
    }

    return _QExec->FetchDeferredValue( wid, ps, var );
} //FetchDeferredValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\propdata.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       propdata.cxx
//
//  Contents:   Declaration of static data about property types.
//
//  Classes:    VARNT_DATA - size and allignment constraints of variant types
//              CTableVariant - Wrapper around PROPVARIANT
//
//  Functions:
//
//  History:    25 Jan 1994     AlanW    Created
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>

#include "propdata.hxx"

//
//  Standard properties known to Query and whose type cannot vary.
//

const PROP_TYPE aPropType [] = {
    { pidWorkId, TYPE_WORKID },
    { pidInvalid, VT_EMPTY },

    // Standard storage properties
    { pidDirectory,     VT_LPWSTR },
    { pidClassId,       VT_CLSID },
    { pidStorageType,   VT_UI4 },
    { pidFileIndex,     VT_UI8 },
    { pidLastChangeUsn, VT_I8 },
    { pidName,          VT_LPWSTR },
    { pidPath,          VT_LPWSTR },
    { pidSize,          VT_I8 },
    { pidAttrib,        VT_UI4 },
    { pidWriteTime,     VT_FILETIME },
    { pidCreateTime,    VT_FILETIME },
    { pidAccessTime,    VT_FILETIME },
//  { pidContents,      ??? },          // No point
    { pidShortName,     VT_LPWSTR },

    // Standard query properties
    { pidRank,          VT_I4 },
//    { pidRankVector,    VT_VECTOR|VT_UI4 },  // no point
    { pidHitCount,      VT_I4 },

    // Special columns for OLE-DB
    { pidBookmark,      VT_EMPTY },     // maps to pidWorkid
    { pidChapter,       VT_I4 },

    { pidRowStatus,     VT_I1 },
    { pidSelf,          VT_EMPTY },     // maps to pidWorkid

    // web-server-specific pids
    { pidVirtualPath,   VT_LPWSTR },
};

const unsigned cPropType = sizeof aPropType / sizeof aPropType[0];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\regtrans.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       regtrans.cxx
//
//  Contents:   Watch Region Transformer
//
//  Classes:    CRegionTransformer
//
//  History:    20-Jul-95   BartoszM    Created
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <seglist.hxx>
#include <wregion.hxx>

#include "tabledbg.hxx"
#include "regtrans.hxx"
#include "tblwindo.hxx"
#include "tputget.hxx"


BOOL CRegionTransformer::Validate()
{

    tbDebugOut(( DEB_REGTRANS, "CRegionTransformer::Validate\n" ));
    DumpState();

    _iFetch = _iFetchBmk + _offFetch;
    if (_cFetch < 0)
    {
        // for negative row count, we swap the start
        // of the fetch region with its end
        _iFetch += _cFetch + 1;
        _cFetch = - _cFetch;
    }

    if  (_pRegion != 0)
    {
        _cWatch = _pRegion->RowCount();

        if (_iFetch < _iWatch)
        {
            _isExtendBackward = TRUE;
        }
        if (_iFetch + _cFetch > _iWatch + _cWatch)
        {
            _isExtendForward = TRUE;
        }

        if ( !_pRegion->IsInit() )
        {
            //
            // BootStrap - creating a watch region for the first time.
            //
            _iWatchNew = _iFetch;
            _cWatchNew = _cFetch;
            _isContiguous = FALSE;
            return TRUE;
        }
        else if (_pRegion->Mode() & DBWATCHMODE_EXTEND)
        {
            return ValidateExtend();
        }
        else if (_pRegion->Mode() & DBWATCHMODE_MOVE)
        {
            return ValidateMove();
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CRegionTransformer::ValidateMove ()
{

    tbDebugOut(( DEB_REGTRANS,
        "CRegionTransformer::ValidateMove\n" ));

    Win4Assert( 0 != _pRegion );

    if (_isExtendForward && _isExtendBackward)
        return FALSE;


    _cWatchNew = _cWatch;

    if (_isExtendForward)
    {
        _iWatchNew = _iFetch + _cFetch - _cWatchNew;
    }
    else
    {
        _iWatchNew = _iFetch;
    }

    // For the new region to be contiguous with the
    // old region we require that the fetch bookmark
    // be within the old region and that there be overlap
    // between the old and the new regions. In any other case
    // the client cannot be sure of contiguity and we are
    // free to skip any buckets between the two regions.

    // Is the Fetch Bookmark inside the watch region?
    if (_iFetchBmk >= _iWatch && _iFetchBmk < _iWatch + _cWatch)
    {
        // Do the regions overlap?
        if  ( _isExtendBackward  && _iWatchNew + _cWatchNew > _iWatch
         ||  !_isExtendBackward  && _iWatchNew < _iWatch + _cWatch )
        {
            _isContiguous = TRUE;
        }
    }

    DumpState();


    if (!_isContiguous && _cFetch != _cWatchNew)
        return FALSE;

//    if ( !_isContiguous && _cFetch > _cWatchNew )
//        return FALSE;

    return TRUE;
}

BOOL CRegionTransformer::ValidateExtend ()
{

    tbDebugOut(( DEB_REGTRANS,
        "CRegionTransformer::ValidateExtend\n" ));

    _iWatchNew = _iWatch;
    _cWatchNew = _cWatch;

    if (_isExtendBackward)
    {
        // is there a gap?
        if (_iFetch + _cFetch < _iWatch)
            return FALSE;

        _iWatchNew = _iFetch;
        _cWatchNew += _iWatch - _iFetch;
    }

    if (_isExtendForward)
    {
        // is there a gap?
        if (_iFetch > _iWatch + _cWatch)
            return FALSE;

        _cWatchNew += _iFetch + _cFetch - (_iWatch + _cWatch);
    }

    _isContiguous = TRUE;

    return TRUE;
}

void CRegionTransformer::Transform (CTableSegList& segList, CWatchList& watchList)
{

    tbDebugOut(( DEB_REGTRANS, "++++++ CRegionTransformer::Transform - Entering \n" ));

    if (!_isContiguous)
    {

        tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "Not Contiguous\n" ));

        // Delete old region, create new region
        watchList.ShrinkRegionToZero (_pRegion->Handle());
        watchList.BuildRegion (  _pRegion->Handle(),
                        _pSegmentLowFetch,
                        0,  // NEWFEATURE: no watch regions for chapters
                        ((CTableWindow*)_pSegmentLowFetch)->GetBookMarkAt((ULONG)_offLowFetchInSegment),
                        (LONG) _cWatchNew );
        return;
    }

    tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                    "   Chapter=0x%X \tBookMark=0x%X \tcRows=%d \tSegment=0x%X \n",
                    _pRegion->Chapter(), _pRegion->Bookmark(),
                    _pRegion->RowCount(), _pRegion->Segment() ));
    DumpState();

    Win4Assert( _iWatch >= 0 && _iWatchNew >= 0 );

    CTableSegment* pSegment;
    if (_isExtendBackward)
    {
        pSegment = _pSegmentLowFetch;
    }
    else
    {
        pSegment = _pRegion->Segment();
    }

    // Create a state machine that will transform
    // watch regions window by window

    CDoubleTableSegIter iter (pSegment);

    enum State
    {
        stStart, stInOld, stInNew, stInBoth, stEnd
    };

    State state = stStart;
    CTableWindow* pWindow = iter.GetWindow();
    DBROWCOUNT cRowsInWindow  = pWindow->RowCount();
    BOOL isLast = segList.IsLast(iter);
    DBROWCOUNT  offset = 0;

    DBROWCOUNT  cWatchLeft = _cWatchNew;

    Win4Assert( _cWatchNew >= _cWatch );
    DBROWCOUNT  iBeginInWindow = 0;

    tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "Doing State Change\n" ));

    do
    {
        BOOL fAdvance = FALSE;
        switch (state)
        {
            case stStart:

                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stStart\n" ));

                if (HasNewRegion( offset, cRowsInWindow))
                {
                    iBeginInWindow = _iWatchNew - offset;

                    // NEWFEATURE no watches for chaptered tables
                    _pRegion->Set (0, pWindow->GetBookMarkAt((ULONG) iBeginInWindow), (LONG) _cWatchNew);
                    _pRegion->SetSegment (pWindow);

                    //Win4Assert( pWindow->HasWatch( _pRegion->Handle() ) );

                    state = stInNew;
                }

                if (HasOldRegion( (long) offset, (long) cRowsInWindow))
                {
                    if (state == stInNew)
                        state = stInBoth;
                    else
                        state = stInOld;
                }

                break;
            case stInOld:

                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stInOld\n" ));

                if (HasNewRegion( offset, cRowsInWindow))
                {
                    iBeginInWindow = _iWatchNew - offset;
                    // NEWFEATURE no watches for chaptered tables
                    _pRegion->Set (0, pWindow->GetBookMarkAt((ULONG)iBeginInWindow), (LONG)_cWatchNew);
                    _pRegion->SetSegment (pWindow);
                    Win4Assert( pWindow->HasWatch( _pRegion->Handle() ) );
                    state = stInBoth;
                }
                else if (HasEndOldRegion(offset, cRowsInWindow))
                {
                    pWindow->DeleteWatch (_pRegion->Handle());
                    state = stEnd;
                }   
                else
                {
                    pWindow->DeleteWatch (_pRegion->Handle());
                    fAdvance = !isLast;
                }

                break;

            case stInNew:
                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stInNew\n" ));

                if (HasOldRegion(offset, cRowsInWindow))
                {
                    state = stInBoth;
                }
                else if (HasEndNewRegion(offset, cRowsInWindow))
                {
                    cWatchLeft -= pWindow->AddWatch (
                                        _pRegion->Handle(),
                                        (LONG) iBeginInWindow,
                                        (LONG) cWatchLeft,
                                        isLast );
                    // in all subsequent windows the watch
                    // will start at offset zero
                    iBeginInWindow = 0;
                    state = stEnd;
                }
                else
                {
                    Win4Assert( cWatchLeft > 0 );

                    cWatchLeft -= pWindow->AddWatch (
                                        _pRegion->Handle(),
                                        (LONG) iBeginInWindow,
                                        (LONG) cWatchLeft,
                                        isLast );
                    // in all subsequent windows the watch
                    // will start at offset zero
                    iBeginInWindow = 0;
                    fAdvance = !isLast;
                }
                break;
            case stInBoth:

                tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME, "stInBoth\n" ));

                cWatchLeft -= pWindow->ModifyWatch (
                                    _pRegion->Handle(),
                                    (LONG) iBeginInWindow,
                                    (LONG) cWatchLeft,
                                    isLast );

                if ( !isLast )
                {
                    // in all subsequent windows the watch
                    // will start at offset zero
                    iBeginInWindow = 0;
                    fAdvance = TRUE;
                    if (HasEndNewRegion(offset, cRowsInWindow))
                    {
                        state = stInOld;
                    }
                    else
                    {
                        Win4Assert( cWatchLeft > 0 || isLast );
                    }
    
                    if (HasEndOldRegion(offset, cRowsInWindow))
                    {
                        if (state == stInOld)
                        {
                            fAdvance = FALSE;
                            state = stEnd;
                        }
                        else
                        {
                            state = stInNew;
                        }
                    }                    
                }
                else
                {
                    state = stEnd;
                }


                break;
            case stEnd:
                break;
        }

        if ( fAdvance)
        {

            tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                "--- BEFORE ADVANCING offset=%d cRowsInWindow=%d isLast=%d\n",
                offset, cRowsInWindow, isLast ));

            Win4Assert (!isLast);

            offset += cRowsInWindow;

            segList.Advance(iter);
            Win4Assert( iter.GetSegment()->IsWindow() );
            
            pWindow = iter.GetWindow();
            cRowsInWindow  = pWindow->RowCount();

            isLast = segList.IsLast(iter);

            tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                "--- AFTER ADVANCING offset=%d cRowsInWindow=%d isLast=%d\n",
                offset, cRowsInWindow, isLast ));
        }

    } while ( state != stEnd && !segList.AtEnd(iter) );

    tbDebugOut(( DEB_REGTRANS, "------ CRegionTransformer::Transform - Leaving \n" ));

    tbDebugOut(( DEB_REGTRANS | DEB_NOCOMPNAME,
                    "   Chapter=0x%X \tBookMark=0x%X \tcRows=%d \tSegment=0x%X \n",
                    _pRegion->Chapter(), _pRegion->Bookmark(),
                    _pRegion->RowCount(), _pRegion->Segment() ));

    DumpState();

}


//+---------------------------------------------------------------------------
//
//  Function:   MoveOrigin
//
//  Synopsis:   The co-ordinate origin is WRT to the lower of the two:
//              a. Watch Segment
//              b. The "anchor" segment.
//
//              When the "fetch" segment is before this origin, then some of
//              the co-ordinates like the _iWatchNew and _iFetch will be < 0.
//              In-order to have all our co-ordinates always postive, we will
//              the origin to the "fetch" segment.
//
//  Arguments:  [cDelta] - The number of rows to move the origin by.
//              This MUST be -ve.
//
//  History:    9-05-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CRegionTransformer::MoveOrigin( DBROWCOUNT cDelta )
{

    Win4Assert( cDelta < 0 );
    Win4Assert( _iFetch < 0 );
    Win4Assert( _iWatchNew < 0 );

    cDelta = -cDelta;

    Win4Assert( cDelta >= -_iFetch );

    _iWatchNew += cDelta;
    _iWatch += cDelta;
    _iFetch += cDelta;

    Win4Assert( _iWatchNew >= 0 && _iWatch >= 0 && _iFetch >= 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegionTransformer::DecrementFetchCount
//
//  Synopsis:
//
//  Arguments:  [rowLocator] -
//              [iter]       -
//              [list]       -
//
//  Returns:
//
//  Modifies:
//
//  History:    7-26-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRegionTransformer::DecrementFetchCount( CTableRowLocator & rowLocator,
                                              CFwdTableSegIter & iter,
                                              CTableSegList & list )
{

    Win4Assert( list.AtEnd(iter) );

    DBROWCOUNT cDiff = rowLocator.GetBeyondTableCount();

    tbDebugOut(( DEB_REGTRANS,
             "CRegionTransformer::DecrementFetchCount - cDiff %d\n", cDiff ));

    if ( (_cFetch <= 0 && cDiff <= 0) || (_cFetch >= 0  && cDiff >= 0) )
    {
        tbDebugOut(( DEB_REGTRANS, "Beyond End of Table\n" ));
        _cFetch = 0;
    }
    else if ( _cFetch < 0 )
    {
        //
        // We are doing a reverse retrieval of rows. We must decrease the
        // number of rows to be retrieved by the amount we overshot.
        //

        Win4Assert( cDiff > 0 );
        _cFetch += cDiff;

        if ( _cFetch >= 0 )
        {
            _cFetch = 0;
            _cWatchNew = 0;
        }
        else
        {

            Win4Assert( _cWatchNew >= _cFetch );

            Win4Assert( !"The logic here is not clear. Check it properly" );

            rowLocator.SeekAndSetFetchBmk( WORKID_TBLLAST, iter );
            DBROWCOUNT iOffset = (DBROWCOUNT) iter.GetSegment()->RowCount();

            if ( iOffset > 0 )
            {
                iOffset--;
            }
            _iFetch = iOffset;
        }

    }
    else
    {

        Win4Assert( cDiff < 0 );
        Win4Assert( !IsWatched() || _iWatchNew <= 0 );

        _cFetch += cDiff;
        _iWatchNew = 0;

        if ( _cFetch <= 0 )
        {
            _cFetch = 0;
            _cWatchNew = 0;
        }
        else
        {
            Win4Assert( !IsWatched() || _cWatchNew >= _cFetch );
            rowLocator.SeekAndSetFetchBmk( WORKID_TBLFIRST, iter );
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\rowbuf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       rowbuf.cxx
//
//  Contents:   Declaration of the row buffer classes, used for HROW
//              buffering at the interface level.
//
//  Classes:    CRowBuffer
//              CRowBufferSet
//              CDeferredValue
//
//  History:    22 Nov 1994     AlanW   Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <hraccess.hxx>

#include "tabledbg.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet constructor, public
//
//  Synopsis:   Create a row buffer set
//
//  Arguments:  [fSequential] - if TRUE, sequential rowset; obRowId
//                      is not required.
//              [obRowRefcount] - offset in row data reserved for a
//                      USHORT reference count.
//              [obRowId] - offset in row data of a ULONG row
//                      identifier field, used for bookmarks and HROW
//                      identity tests.
//              [obChaptRefcount] - offset in row data reserved for a
//                      USHORT reference count for chapters.
//              [obChaptId] - offset in row data of a ULONG chapter
//                      identifier field.  0xFFFFFFFF if the rowset is not
//                      chaptered.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CRowBufferSet::CRowBufferSet(
    BOOL        fSequential,
    ULONG       obRowRefcount,
    ULONG       obRowId,
    ULONG       obChaptRefcount,
    ULONG       obChaptId
) :
    _mutex( ),
    _fSequential( fSequential ),
    _obRowRefcount( obRowRefcount ),
    _obRowId( obRowId ),
    _obChaptRefcount( obChaptRefcount ),
    _obChaptId( obChaptId ),
    _cRowBufs( 0 ),
    _iBufHint( 0 ),
    _iRowHint( 0 )
#ifdef _WIN64
    , _ArrayAlloc (FALSE, FALSE, sizeof (void *), 0)
#endif
    #if CIDBG
    , _cHintHits( 0 ),
      _cHintMisses( 0 )
    #endif
{
    // Lots of code in this file assumes the refcount is at offset 0, and
    // occupies a USHORT
    Win4Assert( _obRowRefcount == 0 &&
                sizeof (CRBRefCount) == sizeof (USHORT));

    Win4Assert( _obRowId != 0xFFFFFFFF || fSequential );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::~CRowBufferSet, public
//
//  Synopsis:   Destroy a row buffer set
//
//  Returns:    - nothing -
//
//--------------------------------------------------------------------------


CRowBufferSet::~CRowBufferSet( )
{
    CLock   lock(_mutex);

    #if CIDBG
        tbDebugOut(( DEB_ROWBUF,
                     " hint hits / misses: %d %d\n",
                     _cHintHits,
                     _cHintMisses ));
    #endif

    for (unsigned i = 0; i < Size(); i++) {
        if (Get(i) != 0)
        {
            tbDebugOut(( DEB_WARN,
                "CRowBufferSet::~CRowBufferSet, unreleased row buffer %x\n",
                        Get(i) ));

            delete Acquire(i);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_FindRowBuffer, private
//
//  Synopsis:   Find a row buffer given an HROW
//
//  Arguments:  [hRow]        - the row to be looked up
//              [riBuf]       - index to the buffer in the buffer set
//              [riRow]       - index to the row in the buffer
//
//  Returns:    CRowBuffer* - pointer to the row buffer if found, 0 otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

CRowBuffer* CRowBufferSet::_FindRowBuffer(
    HROW        hRow,
    unsigned &  riBuf,
    unsigned &  riRow )
{
    CRowBuffer* pBuffer = 0;
    if (IsHrowRowId())
    {
        // Check the hints.  This assumes that most hrow lookups
        // will be either the same as the last requested hrow, one after the
        // last requested hrow, or one before the last requested row

        if ( _iBufHint < Size() && 0 != ( pBuffer = Get(_iBufHint) ) )
        {
            if ( pBuffer->IsRowOkAndHRow( _iRowHint, hRow ) )
            {
                #if CIDBG
                    _cHintHits++;
                #endif

                riBuf = _iBufHint;
                riRow = _iRowHint;
                return pBuffer;
            }
            else if ( pBuffer->IsRowOkAndHRow( _iRowHint + 1, hRow ) )
            {
                #if CIDBG
                    _cHintHits++;
                #endif

                _iRowHint++;
                riBuf = _iBufHint;
                riRow = _iRowHint;
                return pBuffer;
            }
            else if ( ( _iRowHint > 0 ) &&
                      ( pBuffer->IsRowOkAndHRow( _iRowHint - 1, hRow ) ) )
            {
                #if CIDBG
                    _cHintHits++;
                #endif

                _iRowHint--;
                riBuf = _iBufHint;
                riRow = _iRowHint;
                return pBuffer;
            }
        }

        //  Lookup HROW by row id via a linear search.

        for (riBuf = 0; riBuf < Size(); riBuf++)
        {
            pBuffer = Get(riBuf);

            if ( ( 0 != pBuffer ) &&
                 ( pBuffer->FindHRow( riRow, hRow ) ) )
            {
                #if CIDBG
                    _cHintMisses++;
                #endif

                _iBufHint = riBuf;
                _iRowHint = riRow;
                return pBuffer;
            }
        }

        pBuffer = 0;    // Buffer not found
    }
    else
    {
        //
        //  Row handle contains the buffer and row indices.  Just unpack
        //  them.
        //
        riBuf = ((ULONG) hRow >> 20 & 0xFFF) - 1;        // get buffer index
        riRow = ((ULONG) hRow & 0xFFFFF) - 1;            // get row index
        pBuffer = Get(riBuf);
    }

    return pBuffer;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_FindRowBufferByChapter, private
//
//  Synopsis:   Find a row buffer given an HCHAPTER
//
//  Arguments:  [hChapter] - the chapter to be looked up
//              [riBuf]    - index to the buffer in the buffer set
//              [riRow]    - index to the row in the buffer
//
//  Returns:    CRowBuffer* - pointer to the row buffer if found, 0 otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

CRowBuffer* CRowBufferSet::_FindRowBufferByChapter(
    HCHAPTER    hChapter,
    unsigned &  riBuf,
    unsigned &  riRow )
{
    CRowBuffer* pBuffer = 0;

    Win4Assert( IsHrowRowId() && _obChaptId != 0xFFFFFFFF );
    Win4Assert( DB_NULL_HCHAPTER != hChapter );

    // Check the hints.  This assumes that most HCHAPTER lookups
    // will be either the same as the last requested HROW, one after the
    // last requested HROW, or one before the last requested HROW.

    if ( _iBufHint < Size() && 0 != ( pBuffer = Get(_iBufHint) ) )
    {
        if ( pBuffer->IsRowOkAndHChapt( _iRowHint, hChapter ) )
        {
            #if CIDBG
                _cHintHits++;
            #endif

            riBuf = _iBufHint;
            riRow = _iRowHint;
            return pBuffer;
        }
        else if ( pBuffer->IsRowOkAndHChapt( _iRowHint + 1, hChapter ) )
        {
            #if CIDBG
                _cHintHits++;
            #endif

            _iRowHint++;
            riBuf = _iBufHint;
            riRow = _iRowHint;
            return pBuffer;
        }
        else if ( ( _iRowHint > 0 ) &&
                  ( pBuffer->IsRowOkAndHChapt( _iRowHint - 1, hChapter ) ) )
        {
            #if CIDBG
                _cHintHits++;
            #endif

            _iRowHint--;
            riBuf = _iBufHint;
            riRow = _iRowHint;
            return pBuffer;
        }
    }

    //  Lookup HCHAPTER via a linear search.

    for (riBuf = 0; riBuf < Size(); riBuf++)
    {
        pBuffer = Get(riBuf);

        if ( ( 0 != pBuffer ) &&
             ( pBuffer->FindHChapter( riRow, hChapter ) ) )
        {
            #if CIDBG
                _cHintMisses++;
            #endif

            // NOTE: row hint not updated for this chapter lookup
            //_iBufHint = riBuf;
            //_iRowHint = riRow;
            return pBuffer;
        }
    }

    return 0;    // Buffer not found
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::Add, public
//
//  Synopsis:   Add a row buffer to the set
//
//  Arguments:  [pBuf]    - a smart pointer to the buffer to be added.
//              [fPossibleDuplicateHRows] - TRUE if some of the hrows may be
//                                          duplicated in this buffer
//              [pahRows] - optional pointer to array of row handles to
//                          be returned.
//
//  Returns:    Nothing, thows on error.
//
//  Notes:      Acquires the row buffer if successful
//
//--------------------------------------------------------------------------

VOID CRowBufferSet::Add(
    XPtr<CRowBuffer> & pBuf,
    BOOL               fPossibleDuplicateHRows,
    HROW *             pahRows
) {
    CLock   lock(_mutex);

    tbDebugOut(( DEB_ROWBUF,
            "CRowBufferSet::Add - new row buffer = %x\n",
            pBuf.GetPointer() ));

    unsigned iRowBuf;
    if ( _cRowBufs == Size() )
        iRowBuf = Size();          // There is no free element
    else
    {
        for (iRowBuf = 0; iRowBuf < Size(); iRowBuf++)
        {
            if (Get(iRowBuf) == 0)
                break;              // found a free array element.
        }
    }

#if CIDBG
    if ( iRowBuf == Size() )
    {
        tbDebugOut(( DEB_ROWBUF,
                "CRowBufferSet::Add, growing row buffer array, new entry = %d\n",
                iRowBuf ));
    }
#endif // CIDBG

    pBuf->SetRowIdOffset( _obRowId );
    if ( IsChaptered() )
        pBuf->SetChapterVars( _obChaptId, _obChaptRefcount );

    //
    //  Refcount the rows in the buffer.  If there is no row identifier
    //  in the buffer, generate the HROW from a combination of the
    //  buffer number and the row index within the buffer.
    //  Otherwise, dereference any other occurance of the row, and
    //  collapse the references to the newly fetched row.  Generate
    //  the HROW from the row identifier.
    //
    ULONG hRowGen = (iRowBuf+1) << 20;
    for (unsigned iRow = 0; iRow < pBuf->GetRowCount(); iRow++)
    {
        if (IsHrowRowId())
        {
            HROW hRowId = pBuf->GetRowId(iRow);

            CRBRefCount RowRefCount(0);
            CRBRefCount ChapterRefCount(0);

            if ( _cRowBufs != 0 )
            {
                unsigned iOldBuf = 0, iOldRow = 0;
                CRowBuffer * pOldRowBuf = _FindRowBuffer( hRowId,
                                                          iOldBuf,
                                                          iOldRow );
                
                if (pOldRowBuf)
                {
                    CRBRefCount OldRowRefCount;
                    OldRowRefCount = pOldRowBuf->DereferenceRow( iOldRow );
                    RowRefCount.AddRefs( OldRowRefCount );

                    if ( IsChaptered() )
                    {
                        CRBRefCount & OldChaptRefCount =
                            pOldRowBuf->_GetChaptRefCount(iOldRow);
                        ChapterRefCount.AddRefs( OldChaptRefCount );
                    }

                    if (pOldRowBuf->RefCount() <= 0)
                    {
                        //
                        //  Deleted the last reference to the buffer.  Now free
                        //  it and its location in the array.
                        //
                        pOldRowBuf = Acquire( iOldBuf );
                        delete pOldRowBuf;
                        _cRowBufs--;
                    }
                }
            }

            //
            //  Search for the row handle in the portion of the buffer
            //  already processed.  This should only occur for rows which
            //  were fetched with GetRowsByBookmark.
            //
            //  Chapter refcounts doen't need to be updated in this loop
            //  because the duplicate rows don't add to their ref. counts.
            //
            if ( fPossibleDuplicateHRows )
            {
                for (unsigned iOldRow = 0; iOldRow < iRow; iOldRow++)
                {
                    if ( pBuf->IsRowHRow( iOldRow, hRowId ) )
                    {
                        tbDebugOut(( DEB_ROWBUF,
                                "CRowBufferSet::Add - duplicate row: %x\n",
                                hRowId ));

                        CRBRefCount OldRowRefCount;
                        OldRowRefCount = pBuf->DereferenceRow( iOldRow );
                        RowRefCount.AddRefs( OldRowRefCount );
                        break;
                    }
                }
            }

            pBuf->InitRowRefcount(iRow, RowRefCount);
            if (IsChaptered())
                pBuf->_GetChaptRefCount(iRow).SetRefCount( ChapterRefCount );

            if (pahRows)
            {
                *pahRows++ = hRowId;
            }
        }
        else
        {
            CRBRefCount RowRefCount(0);
            pBuf->InitRowRefcount(iRow, RowRefCount);
            if (pahRows)
            {
                *pahRows++ = (HROW) (++hRowGen);
            }
        }
    }

    CRowBufferArray::Add(pBuf.GetPointer(), iRowBuf);
    pBuf.Acquire();

    _cRowBufs++;       // A row buffer has been added

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::Lookup, public
//
//  Synopsis:   Lookup a row by its HROW.  Return data about it.
//
//  Arguments:  [hRow] - handle of row to be looked up
//              [ppColumns] - on return, a description of the row columns
//              [ppbRowData] - on return, points to row data
//
//  Returns:    Reference to the row buffer in which row was found.
//
//  Notes:      THROWs on errors.
//              The row buffer set is locked only while doing the
//              lookup.  According to the spec, it is the responsibility
//              of the consumer to ensure that only one thread will be
//              using any one HROW at any one time.
//
//--------------------------------------------------------------------------

CRowBuffer & CRowBufferSet::Lookup(
    HROW                hRow,
    CTableColumnSet **  ppColumns,
    void **             ppbRowData )
{
    CLock   lock(_mutex);

    unsigned iBuffer, iRow;
    CRowBuffer* pRowBuf = _FindRowBuffer(hRow, iBuffer, iRow);

    if (pRowBuf == 0)
        QUIETTHROW( CException(DB_E_BADROWHANDLE) );

    SCODE sc = pRowBuf->Lookup(iRow, ppColumns, ppbRowData );
    if (FAILED(sc))
        THROW( CException(sc) );

    return *pRowBuf;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_LokAddRefRow, private
//
//  Synopsis:   Reference an individual HROW.
//
//  Arguments:  [hRow] - the handle of the row to be ref. counted
//              [rRefCount] - reference to location where remaining ref.
//                      count will be stored.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                      stored.
//
//  Returns:    Nothing
//
//  History:    21 Nov 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::_LokAddRefRow(
    HROW            hRow,
    ULONG &         rRefCount,
    DBROWSTATUS &   rRowStatus
) {
    unsigned iBuffer, iRow;

    rRowStatus = DBROWSTATUS_S_OK;
    rRefCount = 0; 

    CRowBuffer* pRowBuf = _FindRowBuffer(hRow, iBuffer, iRow);

    if (pRowBuf == 0)
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        return;
    }

    pRowBuf->AddRefRow( hRow, iRow, rRefCount, rRowStatus );
    Win4Assert (pRowBuf->RefCount() > 0);

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::AddRefRows, public
//
//  Synopsis:   De-reference an array of HROWs.
//
//  Arguments:  [cRows]   - the number of rows to be ref. counted
//              [rghRows] - the handle of the row to be ref. counted
//              [rgRefCounts] - optional array where remaining row ref.
//                      counts will be stored.
//              [rgRowStatus] -- optional array for status of each row 
//
//  Returns:    Nothing - throws on error
//
//  History:    21 Nov 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::AddRefRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[]
) {
    CLock   lock(_mutex);

    ULONG cError = 0;

    if (rghRows == 0 && cRows != 0)
        THROW( CException( E_INVALIDARG ));

    for (unsigned i=0; i<cRows; i++)
    {
        TRY
        {

            ULONG ulRefCount;
            DBROWSTATUS RowStatus;

            _LokAddRefRow(rghRows[i], ulRefCount, RowStatus);
            if (rgRefCounts)
                rgRefCounts[i] = ulRefCount;

            if (rgRowStatus)
                rgRowStatus[i] = RowStatus;

            if (DBROWSTATUS_S_OK != RowStatus)
                cError++;
        }
        CATCH( CException, e )
        {
           if (DB_E_BADROWHANDLE == e.GetErrorCode()) 
           {
              if (rgRowStatus)
                  rgRowStatus[i] = DBROWSTATUS_E_INVALID;

              if (rgRefCounts)
                  rgRefCounts[i] = 0;

              cError++;
           }
           else
           {
              RETHROW();
           }  
        }
        END_CATCH;



    }
    if (cError)
        THROW( CException( (cError==cRows) ? DB_E_ERRORSOCCURRED :
                                             DB_S_ERRORSOCCURRED ));

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::_LokReleaseRow, private
//
//  Synopsis:   De-reference an individual HROW.
//
//  Arguments:  [hRow] - the handle of the row to be released
//              [rRefCount] - reference to location where remaining ref.
//                      count will be stored.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                      stored.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CRowBufferSet::_LokReleaseRow(
    HROW            hRow,
    ULONG &         rRefCount,
    DBROWSTATUS &   rRowStatus
) {
    unsigned iBuffer, iRow;
    CRowBuffer* pRowBuf = _FindRowBuffer(hRow, iBuffer, iRow);

    rRowStatus = DBROWSTATUS_S_OK;
    rRefCount = 0;

    if (pRowBuf == 0)
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        return;
    }

    BOOL fRemoveCopies =
            pRowBuf->ReleaseRow( hRow, iRow, rRefCount, rRowStatus );

    if (pRowBuf->RefCount() <= 0)
    {
        //
        //  Deleted the last reference to the buffer.  Now free it
        //  and its location in the array.
        //
        Win4Assert( pRowBuf == Get( iBuffer ) );
        pRowBuf = Acquire( iBuffer );
        Win4Assert( 0 == Get( iBuffer ) );
        delete pRowBuf;

        _cRowBufs--;      // A row buffer has been removed
    }

    if (fRemoveCopies)
    {
        //
        //  The last reference to a row which also exists in other row
        //  buffers was released.  Finally get rid of the row in the
        //  other buffer(s).
        //
        Win4Assert(IsHrowRowId());

        //  Lookup HROW by row id via a linear search.

        for (unsigned iBuf = Size(); iBuf > 0; iBuf--)
        {
            unsigned iRow;
            CRowBuffer* pBuffer = Get(iBuf-1);

            if ( ( 0 != pBuffer ) &&
                 ( pBuffer->FindHRow( iRow, hRow, TRUE ) ) )
            {
                ULONG cRefs;
                DBROWSTATUS RowStat;

                pBuffer->ReleaseRow( hRow, iRow, cRefs, RowStat );
                if (pBuffer->RefCount() <= 0)
                {
                    //
                    //  Deleted the last reference to the buffer.  Now free it
                    //  and its location in the array.
                    //
                    pBuffer = Acquire( iBuf-1);
                    delete pBuffer;
            
                    _cRowBufs--;      // A row buffer has been removed

                    //
                    // Start scanning buffers again
                    //
                    iBuf = Size() + 1;
                }
            }
        }
    }
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::ReleaseRows, public
//
//  Synopsis:   De-reference an array of HROWs.
//
//  Arguments:  [cRows]   - the number of rows to be released
//              [rghRows] - the handle of the row to be released
//              [rgRefCounts] - optional array where remaining row ref.
//                      counts will be stored.
//              [rgRowStatus] -- optional array for status of each row 
//
//  Returns:    SCODE - result status, usually one of S_OK,
//                      DB_S_ERRORSOCCURRED, or DB_E_ERRORSOCCURRED
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CRowBufferSet::ReleaseRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[]
) {
    CLock   lock(_mutex);

    ULONG cError = 0;

    if (rghRows == 0 && cRows != 0)
        THROW( CException( E_INVALIDARG ));

    for (unsigned i=0; i<cRows; i++)
    {
        TRY
        {
            ULONG ulRefCount;
            DBROWSTATUS RowStatus;

            _LokReleaseRow(rghRows[i], ulRefCount, RowStatus);

            if (rgRefCounts)
                rgRefCounts[i] = ulRefCount;

            if (rgRowStatus)
                rgRowStatus[i] = RowStatus;

            if (DBROWSTATUS_S_OK != RowStatus)
                cError++;
            }
        CATCH( CException, e )
        {
           if (DB_E_BADROWHANDLE == e.GetErrorCode()) 
           {
              if (rgRowStatus)
                  rgRowStatus[i] = DBROWSTATUS_E_INVALID;

              if (rgRefCounts)
                  rgRefCounts[i] = 0;

              cError++;
           }
           else
           {
              RETHROW();
           }  
        }
        END_CATCH;
    }

    SCODE scResult = cError ?
                     ( (cError==cRows) ? DB_E_ERRORSOCCURRED :
                                         DB_S_ERRORSOCCURRED ) :
                     S_OK;

    return scResult;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::CheckAllHrowsReleased, public
//
//  Synopsis:   Check that there are no outstanding HROWs.  Used by
//              the sequential rowset to check its strict sequential
//              semantics.
//
//  Arguments:  - none -
//
//  Returns:    Nothing
//
//  Notes:      THROWs DB_E_ROWSNOTRELEASED if any row buffers are
//              still held.
//
//--------------------------------------------------------------------------

VOID CRowBufferSet::CheckAllHrowsReleased( )
{
    CLock   lock(_mutex);

    if ( _cRowBufs != 0 )
    {
        tbDebugOut(( DEB_WARN,
                     "CRowBufferSet::CheckAllHrowsReleased, unreleased row buffer(s)\n" ));

        QUIETTHROW( CException(DB_E_ROWSNOTRELEASED) );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::AddRefChapter, private
//
//  Synopsis:   Reference an individual HCHAPTER.
//
//  Arguments:  [hChapter] - the handle of the Chapter to be ref. counted
//              [pcRefCount] - optional pointer where remaining ref.
//                      count will be stored.
//
//  Returns:    Nothing - throws on error
//
//  History:    16 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::AddRefChapter(
    HCHAPTER        hChapter,
    ULONG *         pcRefCount
) {
    CLock   lock(_mutex);

    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    unsigned iBuffer, iRow;

    CRowBuffer* pRowBuf = _FindRowBufferByChapter(hChapter, iBuffer, iRow);

    if (pRowBuf == 0)
    {
        THROW(CException( DB_E_BADCHAPTER ));
        return;
    }

    ULONG cRefCount = 0; 

    pRowBuf->AddRefChapter( iRow, cRefCount );
    if ( 0 != pcRefCount )
        *pcRefCount = cRefCount;

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBufferSet::ReleaseChapter, private
//
//  Synopsis:   Release an individual HCHAPTER.
//
//  Arguments:  [hChapter] - the handle of the Chapter to be released
//              [pcRefCount] - optional pointer where remaining ref.
//                      count will be stored.
//
//  Returns:    Nothing - throws on error
//
//  History:    16 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBufferSet::ReleaseChapter(
    HCHAPTER        hChapter,
    ULONG *         pcRefCount
) {
    CLock   lock(_mutex);

    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    unsigned iBuffer, iRow;

    CRowBuffer* pRowBuf = _FindRowBufferByChapter(hChapter, iBuffer, iRow);

    if (pRowBuf == 0)
    {
        THROW(CException( DB_E_BADCHAPTER ));
        return;
    }

    ULONG cRefCount = 0; 

    pRowBuf->ReleaseChapter( iRow, cRefCount );
    if ( 0 != pcRefCount )
        *pcRefCount = cRefCount;

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer constructor, public
//
//  Synopsis:   Create a row buffer
//
//  Arguments:  [rColumns]   - a description of the row columns
//              [cbRowWidth] - row data length per row
//              [cRows]      - number of rows represented in the row data
//              [rAlloc]     - allocator xptr to be acquired
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CRowBuffer::CRowBuffer(
    CTableColumnSet& rColumns,
    ULONG cbRowWidth,
    ULONG cRows,
    XPtr<CFixedVarAllocator> & rAlloc
) :
        _cRows( cRows ),
        _cReferences( 0 ),
        _cbRowWidth( cbRowWidth ),
        _Columns( rColumns ),
        _fQuickPROPID(TRUE),
        _pbRowData( rAlloc->FirstRow() ),
        _obRowId( 0 ),
        _Alloc( rAlloc.Acquire() ),
        _aDeferredValues( 0 )
{
    //
    // OPTIMIZATION - See if we can support a quick lookup of PROPIDs.
    //
    for ( unsigned i = 0; i < _Columns.Count(); i++ )
    {
        CTableColumn * pCol = _Columns.Get(i);
        if ( pCol && i != pCol->GetPropId()-1 )
        {
            _fQuickPROPID = FALSE;
            break;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer destructor, public
//
//  Synopsis:   Destroy a row buffer
//
//+-------------------------------------------------------------------------

CRowBuffer::~CRowBuffer( )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::_IndexRow, private
//
//  Synopsis:   Find a row in a row buffer given its index
//
//  Arguments:  [iRow] - the index of the row to be looked up
//              [fVerifyRefcnt] - if TRUE, the row's refcount will be
//                      checked for non-zero.
//
//  Returns:    BYTE* - the address of the row's data
//
//  Notes:      Throws DB_E_BADROWHANDLE if the row index is out of
//              range, or if the row is not referenced.
//
//--------------------------------------------------------------------------

BYTE* CRowBuffer::_IndexRow(
    unsigned    iRow,
    int         fVerifyRefcnt ) const
{
    if (iRow >= _cRows)
        QUIETTHROW( CException( DB_E_BADROWHANDLE ) );

    BYTE* pbRow = _pbRowData + (iRow * _cbRowWidth);

    //  Is the row still referenced?
    if ( fVerifyRefcnt &&
         ((CRBRefCount *) (pbRow))->GetRefCount() == 0)
        QUIETTHROW( CException( DB_E_BADROWHANDLE ) );

    return pbRow;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::_GetRowRefCount, private
//
//  Synopsis:   Return a reference to the refcount of a row.
//
//  Arguments:  [iRow] - the index of the row to be looked up
//
//  Returns:    CRBRefCount& - the address of the row's refcount
//
//  Notes:      Throws DB_E_BADROWHANDLE if the row index is out of
//              range.
//
//--------------------------------------------------------------------------

inline CRBRefCount & CRowBuffer::_GetRowRefCount( unsigned iRow ) const
{
    CRBRefCount * pbRowRefCount = (CRBRefCount *)_IndexRow( iRow, FALSE );

    return *pbRowRefCount;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::_GetChaptRefCount, private
//
//  Synopsis:   Return a reference to the refcount of a row.
//
//  Arguments:  [iRow] - the index of the row to be looked up
//
//  Returns:    CRBRefCount& - the address of the row's refcount
//
//  Notes:      Throws DB_E_BADROWHANDLE if the row index is out of
//              range.
//
//--------------------------------------------------------------------------

inline CRBRefCount & CRowBuffer::_GetChaptRefCount( unsigned iRow ) const
{
    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    CRBRefCount * pbRowRefCount =
        (CRBRefCount *) (_IndexRow( iRow, FALSE ) + _obChaptRefcount);

    return *pbRowRefCount;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::GetRowId, public
//
//  Synopsis:   Lookup a row's ID.
//
//  Arguments:  [iRow] - index of row to be looked up
//
//  Returns:    HROW - the row's Row ID.
//
//  Notes:      _IndexRow is called without ref. count verification
//              for the case of CRowBufferSet::Add where new buffer
//              has its ref. counts initialized.
//
//--------------------------------------------------------------------------

inline HROW CRowBuffer::GetRowId( unsigned iRow ) const
{
    Win4Assert( _obRowId <= _cbRowWidth - sizeof (ULONG) );
    HROW* phRowId = (HROW *) ( _IndexRow(iRow, FALSE) + _obRowId );
    return *(HROW UNALIGNED *) phRowId;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::Lookup, public
//
//  Synopsis:   Lookup a row by its HROW.  Return data about it.
//
//  Arguments:  [iRow] - index of row to be looked up
//              [ppColumns] - on return, a description of the row columns
//              [ppbRowData] - on return, points to row data
//              [fValidate] - whether IndexRow should validate the refcount
//
//  Returns:    SCODE - status of lookup, DB_E_BADROWHANDLE for
//                      an HROW that could not be found in the buffer
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CRowBuffer::Lookup(
    unsigned            iRow,
    CTableColumnSet **  ppColumns,
    void **             ppbRowData,
    BOOL                fValidate ) const
{
    *ppbRowData = _IndexRow( iRow, fValidate );
    *ppColumns = &_Columns;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::AddRefRow, public
//
//  Synopsis:   Reference an HROW.
//
//  Arguments:  [hRow]       - hrow of row to be ref. counted
//              [iRow]       - the index of the row to be ref. counted
//              [rcRef]      - on return, remaining ref. count
//                             of the row.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                             stored.
//
//  Returns:    Nothing - throws DB_E_BADROWHANDLE if row couldn't be
//                      found.
//
//  History:    21 Nov 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::AddRefRow(
    HROW            hRow,
    unsigned        iRow,
    ULONG &         rcRef,
    DBROWSTATUS &   rRowStatus
)
{
    CRBRefCount & rRefCount = _GetRowRefCount(iRow);

    if (rRefCount.GetRefCount() == 0)
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        rcRef = 0;
    }
    else
    {
        rRefCount.IncRefCount();
        rcRef = rRefCount.GetRefCount();
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::ReleaseRow, public
//
//  Synopsis:   De-reference an HROW.
//
//  Arguments:  [hRow]       - hrow of row to be released
//              [iRow]       - the index of the row to be released
//              [rcRef]      - on return, remaining ref. count
//                             of the row.
//              [rRowStatus] - reference to DBROWSTATUS where status will be
//                             stored.
//
//  Returns:    BOOL -  if TRUE on return, there are copies of the HROW
//                      with byref data.  Delete those as well
//                      since this is the last reference to the HROW.
//
//  Notes:
//
//  History:    20 Feb 1995     Alanw       Added individual row refcounts
//
//--------------------------------------------------------------------------

BOOL CRowBuffer::ReleaseRow(
    HROW            hRow,
    unsigned        iRow,
    ULONG &         rcRef,
    DBROWSTATUS &   rRowStatus
)
{
    BOOL fRemoveCopies = FALSE;
    CRBRefCount & rRefCount = _GetRowRefCount(iRow);

    if ( rRefCount.GetRefCount() == 0 &&
         ! rRefCount.HasByrefData() )
    {
        rRowStatus = DBROWSTATUS_E_INVALID;
        rcRef = 0;
    }
    else
    {
        //
        // This might be a zero ref-count row with the ByrefData bit set.
        //
        if (rRefCount.GetRefCount() > 0)
        {
            rRefCount.DecRefCount();
        }

        if (rRefCount.GetRefCount() == 0)
        {
            if (rRefCount.HasByrefCopy())
                fRemoveCopies = TRUE;

            // Free any deferred values hanging around for this row.
            // Better now than at row buffer destruction time.

            for ( unsigned x = 0; x < _aDeferredValues.Count(); x++ )
            {
                if ( hRow == _aDeferredValues[ x ].GetHRow() )
                {
                    Win4Assert(rRefCount.HasByrefData());
                    _aDeferredValues[ x ].Release();
                }
            }

            _cReferences--;
            CRBRefCount ZeroRefCount(0);
            rRefCount = ZeroRefCount;
        }
        rcRef = rRefCount.GetRefCount();
    }
    return fRemoveCopies;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::ReferenceChapter, public
//
//  Synopsis:   Reference a chapter handle.  Used by accessors.
//
//  Arguments:  [pbRow] - pointer to the row within the row buffer
//
//  Returns:    Nothing
//
//  History:    17 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::ReferenceChapter(
    BYTE *          pbRow
)
{
    Win4Assert( _obChaptRefcount != 0xFFFFFFFF );
    CRBRefCount & rRefCount = *(CRBRefCount *) (pbRow + _obChaptRefcount);

    Win4Assert( ! rRefCount.HasByrefCopy() &&
                ! rRefCount.HasByrefData() );

    rRefCount.IncRefCount();
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::AddRefChapter, public
//
//  Synopsis:   Reference a chapter handle
//
//  Arguments:  [iRow]  - the index of the row with chapter to be released
//              [rcRef] - on return, remaining ref. count of the chapter.
//
//  Returns:    Nothing
//
//  History:    17 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::AddRefChapter(
    unsigned        iRow,
    ULONG &         rcRef
)
{
    CRBRefCount & rRefCount = _GetChaptRefCount(iRow);

    Win4Assert( rRefCount.GetRefCount() > 0 &&
                ! rRefCount.HasByrefCopy() &&
                ! rRefCount.HasByrefData() );
    if (rRefCount.GetRefCount() == 0)
    {
        rcRef = 0;
    }
    else
    {
        rRefCount.IncRefCount();
        rcRef = rRefCount.GetRefCount();
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::ReleaseChapter, public
//
//  Synopsis:   De-reference a chapter handle
//
//  Arguments:  [iRow]  - the index of the row with chapter to be released
//              [rcRef] - on return, remaining ref. count of the chapter.
//
//  Returns:    Nothing
//
//  History:    17 Mar 1999     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::ReleaseChapter(
    unsigned        iRow,
    ULONG &         rcRef
)
{
    CRBRefCount & rRefCount = _GetChaptRefCount(iRow);

    if ( rRefCount.GetRefCount() == 0 )
    {
        rcRef = 0;
        THROW( CException( DB_E_BADCHAPTER ) );
    }
    else
    {
        rRefCount.DecRefCount();
        rcRef = rRefCount.GetRefCount();
    }
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::InitRowRefcount, public
//
//  Synopsis:   Set initial reference count on an HROW.
//
//  Arguments:  [iRow] - the index of the row within the buffer
//              [OtherRefs] - reference count transferred from
//                      another row.
//
//  Returns:    Nothing
//
//  Notes:
//
//  History:    20 Feb 1995     Alanw       Created
//
//--------------------------------------------------------------------------

void CRowBuffer::InitRowRefcount(
    unsigned        iRow,
    CRBRefCount &  OtherRefs
)
{
    CRBRefCount RefCount( OtherRefs.GetRefCount() );
    RefCount.IncRefCount();

    if ( OtherRefs.HasByrefData() || OtherRefs.HasByrefCopy() )
        RefCount.SetByrefCopy();

    CRBRefCount & rRef = _GetRowRefCount(iRow);

    rRef = RefCount;
    _cReferences++;
    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::DereferenceRow, public
//
//  Synopsis:   Remove all references from a row
//
//  Arguments:  [iRow] - the index of the row within the buffer
//
//  Returns:    CRBRefCount - reference count of row
//
//  Notes:      If the client had retrieved a pointer into the rowbuffer,
//              the row stays around with a zero ref. count and will
//              be finally dereferenced when all references to all copies
//              of the row are released.
//
//  History:    22 Mar 1995     Alanw       Created
//
//--------------------------------------------------------------------------

CRBRefCount CRowBuffer::DereferenceRow(
    unsigned        iRow
)
{
    CRBRefCount & rRef = _GetRowRefCount(iRow);
    CRBRefCount OldRef = rRef;
    CRBRefCount NewRef(0);

    Win4Assert(OldRef.GetRefCount() != 0 && _cReferences > 0);

    if ( OldRef.HasByrefData() )
        NewRef.SetByrefData();
    else
        _cReferences--;

    rRef = NewRef;
    return OldRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::FindHRow, public
//
//  Synopsis:   Looks for an hrow in the row buffer and returns its index
//
//  Arguments:  [riRow] - returns the index of hRow's row if found
//              [hRow]  - HROW to be found
//              [fFindByrefData] - if TRUE, zero ref. rows with byref data
//                        are found.
//
//  Returns:    BOOL    - TRUE if found, FALSE otherwise
//
//  History:    16 Aug 1995     dlee       Created
//
//--------------------------------------------------------------------------

BOOL CRowBuffer::FindHRow(
    unsigned & riRow,
    HROW       hRow,
    BOOL       fFindByrefData ) const
{
    BYTE* pbRow = _pbRowData;

    for ( unsigned iRow = 0;
          iRow < GetRowCount();
          iRow++, pbRow += _cbRowWidth )
    {
        // refcount is the first USHORT in each row
        CRBRefCount * pRefCount = (CRBRefCount *) pbRow;

        //
        // HROW == 64 bits on Sundown, but we know HROWs are just
        // workids that fit in a ULONG.
        //

        if ( (ULONG) hRow == ( * (ULONG *) ( pbRow + _obRowId ) ) )
        {
            if ( ( 0 != pRefCount->GetRefCount() ) ||
                 (fFindByrefData && pRefCount->HasByrefData()) )
            {
                riRow = iRow;
                return TRUE;
            }
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowBuffer::FindHChapter, public
//
//  Synopsis:   Looks for an HCHAPTER in the row buffer and returns its index
//
//  Arguments:  [riRow] - returns the index of hChapter's row if found
//              [hChapter]  - HCHAPTER to be found
//
//  Returns:    BOOL    - TRUE if found, FALSE otherwise
//
//  History:    17 Mar 1999     AlanW      Created
//              10 Nov 1999     KLam       Changed HCHAPTER cast to CI_TBL_CHAPT
//
//--------------------------------------------------------------------------

BOOL CRowBuffer::FindHChapter( unsigned & riRow, HCHAPTER   hChapter ) const
{
    BYTE* pbRow = _pbRowData;

    Win4Assert( IsChaptered() );
    for ( unsigned iRow = 0;
          iRow < GetRowCount();
          iRow++, pbRow += _cbRowWidth )
    {
        // refcount is the first USHORT in each row
        CRBRefCount * pRefCount = (CRBRefCount *) pbRow;

        if ( hChapter == ( * (CI_TBL_CHAPT *) ( pbRow + _obChaptId ) ) )
        {
            if ( ( 0 != pRefCount->GetRefCount() )
//               || (fFindByrefData && pRefCount->HasByrefData()) 
                )
            {
                riRow = iRow;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDeferredValue::Release, public
//
//  Synopsis:   Frees a deferred value
//
//  History:    4 Aug 1995     dlee       Created
//
//--------------------------------------------------------------------------

void CDeferredValue::Release()
{
    if ( 0 != _hrow )
    {
        PropVariantClear( &_var );
        _hrow = 0;
    }
} //Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\rowindex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rowindex.cxx
//
//  Contents:   Implementation of CRowIndex
//
//  Classes:    CRowIndex
//
//  History:    23 Aug 1994     dlee    Created
//              30 Nov 1996     dlee    Converted to use dynarrayinplace
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "rowindex.hxx"
#include "tabledbg.hxx"

inline BOOL isOdd(ULONG x) { return 0 != (x & 1); }

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::_FindInsertionPoint, private
//
//  Synopsis:   Binary search to find insertion point for a row.
//              Returns one past the last row or the first row >=
//              to the given row
//
//  Arguments:  [Value] -- value of the row -- internally an offset
//
//  History:    23 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

ULONG CRowIndex::_FindInsertionPoint(
    TBL_OFF Value ) const
{
    ULONG cRows = _aRows.Count();
    ULONG iLo = 0;
    ULONG iHi = cRows - 1;

    do
    {
        ULONG cHalf = cRows / 2;

        if (0 != cHalf)
        {
            ULONG iMid = isOdd(cRows) ? cHalf : (cHalf - 1);
            iMid += iLo;
            int i = _pRowCompare->Compare( Value, _aRows[iMid] );

            if (0 == i)
            {
                return iMid;
            }
            else if (i < 0)
            {
                iHi = iMid - 1;
                cRows = isOdd(cRows) ? cHalf : (cHalf - 1);
            }
            else
            {
                iLo = iMid + 1;
                cRows = cHalf;
            }
        }
        else if (0 != cRows)
        {
            int i = _pRowCompare->Compare( Value, _aRows[iLo] );

            if (i <= 0)
                return iLo;
            else
                return iLo + 1;
        }
        else return iLo;
    }
    while (TRUE);

    Win4Assert(! "Invalid CRowIndex::_Find function exit point");
    return 0;
} //_FindInsertionPoint

//+---------------------------------------------------------------------------
//
//  Function:   _FindRowByLinearSearch, private
//
//  Synopsis:   Given the offset of a row in the table window, this method
//              searches for the entry in the row index which points to that
//              row.
//
//  Arguments:  [oTableRow] -- Offset of the row in the table window.
//              [iRowIndex] -- On output, will have the index of the entry
//              in the row index which points to oTableRow.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    11-22-94   srikants   Created
//
//  Notes:      The row index is searched linearly. This must be used only
//              if there is no row comparator.
//
//----------------------------------------------------------------------------

inline BOOL CRowIndex::_FindRowByLinearSearch(
    TBL_OFF oTableRow,
    ULONG &   iRowIndex ) const
{
    for ( ULONG iCurr = 0; iCurr < _aRows.Count(); iCurr++ )
    {
        if ( _aRows[iCurr] == oTableRow )
        {
            iRowIndex = iCurr;
            return TRUE;
        }
    }

    return FALSE;
} // _FindRowByLinearSearch

#if 0

//+---------------------------------------------------------------------------
//
//  Function:   _FindRowByBinarySearch, private
//
//  Synopsis:   Using a binary search, this method locates the entry in the
//              row index which is same as the row indicated by oTableRow.
//              As duplicates are allowed, it is possible that there is more
//              than one entry in the row index, which will match the row in
//              the table window indicated by the oTableRow.
//
//  Arguments:  [oTableRow] -- Offset of the row in the table window.
//              [iRowIndex] -- On output, will contain the index of the entry
//              in the row index which has the same key as the "oTableRow"
//
//  Returns:    TRUE if found successfully. FALSE o/w
//
//  History:    11-22-94   srikants   Created
//
//  Notes:      NOT TESTED OR REVIEWED
//
//----------------------------------------------------------------------------

inline BOOL CRowIndex::_FindRowByBinarySearch(
    TBL_OFF oTableRow,
    ULONG &   iRowIndex ) const
{

    Win4Assert( 0 != _pRowCompare );

    ULONG *pBase = _Base();

    ULONG cRows = _aRows.Count();
    ULONG iLo = 0;
    ULONG iHi = _aRows.Count() - 1;

    ULONG cHalf = 0;

    do
    {
        cHalf = cRows / 2;

        if (0 != cHalf)
        {
            ULONG iMid = isOdd(cRows) ? cHalf : (cHalf - 1);
            iMid += iLo;

            int i = _pRowCompare->Compare(oTableRow, pBase[iMid]);

            if (0 == i)
            {
                iRowIndex = iMid;
                return TRUE;
            }
            else if (i < 0)
            {
                iHi = iMid - 1;
                cRows = isOdd(cRows) ? cHalf : (cHalf - 1);
            }
            else
            {
                iLo = iMid + 1;
                cRows = cHalf;
            }
        }
        else if (0 != cRows)
        {
            Win4Assert( 1 == cRows );
            int i = _pRowCompare->Compare(oTableRow, pBase[iLo]);

            if ( 0 == i )
            {
                iRowIndex = iLo;
                return TRUE;
            }
        }
    }
    while ( 0 != cHalf );

    Win4Assert( !_FindRowByLinearSearch( oTableRow, iRowIndex ) );
    return FALSE;

} // FindRowByBinarySearch

#endif


//+---------------------------------------------------------------------------
//
//  Function:   FindRow, public
//
//  Synopsis:   Given an offset of a row in the table window, this method
//              locates the entry in the row index, which points to the
//              row in the table window.
//
//  Arguments:  [oTableRow] -- (IN) The offset of the row in the table window.
//              [iRowIndex] --  (OUT) The index of the entry in the row index
//              which points to the oTableRow.
//
//  Returns:    TRUE if search successful; FALSE O/W
//
//  History:    11-22-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL  CRowIndex::FindRow( TBL_OFF oTableRow, ULONG &iRowIndex ) const
{
    return _FindRowByLinearSearch( oTableRow, iRowIndex );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::AddRow, public
//
//  Synopsis:   Adds a row in sort order to the index
//
//  Arguments:  [Value] -- Value to insert in the index, represents a row
//
//  Returns:    Index of the newly added row
//
//  History:    23 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

ULONG CRowIndex::AddRow(TBL_OFF Value)
{
    Win4Assert( 0 != _pRowCompare );

    ULONG cRows = _aRows.Count();

    // Find the insertion point for the new row.

    if ( 0 == cRows )
    {
        // No rows yet

        _aRows[0] = Value;
        return 0;
    }
    else if ( ( _pRowCompare->Compare( _aRows[cRows - 1], Value ) ) <= 0 )
    {
        // append a row to the end

        _aRows[ cRows ] = Value;
        return cRows;
    }

    // insert a row.

    ULONG iInsertionPoint = _FindInsertionPoint( Value );

    _aRows.Insert( Value, iInsertionPoint );

    return iInsertionPoint;
} //AddRow

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::DeleteRow, public
//
//  Synopsis:   Deletes a row from the index and moves the following rows
//              up a notch in the array.
//
//  Arguments:  [iRow] -- row to be deleted
//
//  History:    29 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

void CRowIndex::DeleteRow(ULONG iRow)
{
    Win4Assert( iRow < _aRows.Count() );

    _aRows.Remove( iRow );
} //DeleteRow

//+-------------------------------------------------------------------------
//
//  Member:     CRowIndex::ResortRow, public
//
//  Synopsis:   Bubbles the given row up or down based on the sort key.
//              Useful for when a file property is updated after being
//              added to the table.
//
//  Arguments:  [iRow] -- row to be resorted
//
//  Returns:    ULONG - new index of the row
//
//  PERFFIX:    should probably do a binary search, not a linear one
//
//  History:    29 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

ULONG CRowIndex::ResortRow(ULONG iRow)
{
    Win4Assert(iRow < _aRows.Count());

    Win4Assert( 0 != _pRowCompare );

    // Get the start of the array of offsets

    TBL_OFF *pBase = _Base();
    Win4Assert(0 != pBase);

    // Bubble toward row 0
    
    while ((iRow > 0) &&
           (_pRowCompare->Compare(pBase[iRow], pBase[iRow - 1]) < 0))
    {
        TBL_OFF iTmp = pBase[iRow];
        pBase[iRow] = pBase[iRow - 1];
        iRow--;
        pBase[iRow] = iTmp;
    }
    
    // Bubble toward the last row
    
    while ((iRow < (_aRows.Count() - 1)) &&
           (_pRowCompare->Compare(pBase[iRow], pBase[iRow + 1]) > 0))
    {
        TBL_OFF iTmp = pBase[iRow];
        pBase[iRow] = pBase[iRow + 1];
        iRow++;
        pBase[iRow] = iTmp;
    }

    return iRow;
} //ResortRow


//+---------------------------------------------------------------------------
//
//  Member:     CRowIndex::ResizeAndInit
//
//  Synopsis:   Resizes the current row index to be the same size as
//              specified.
//
//  Arguments:  [cNewRows] -  Number of rows in the new row index.
//
//  History:    7-31-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CRowIndex::ResizeAndInit( ULONG cNewRows )
{
    _aRows.Clear();
}

//+---------------------------------------------------------------------------
//
//  Function:   SyncUp
//
//  Synopsis:   Synchronizes the permutation (rowindex contents) with that
//              of the new index.
//
//  Arguments:  [newIndex] -- The newIndex whose permutation must be copied
//              to our permutation.
//
//  History:    11-29-94   srikants   Created
//              11-30-96   dlee       converted to dynarrayinplace
//
//  Notes:      The implementation is optimized by doing a block copy of the
//              contents of the source row index. That is much faster than
//              adding individual entries from the source row index.
//
//----------------------------------------------------------------------------

void CRowIndex::SyncUp( CRowIndex & newIndex )
{
    _aRows.Duplicate( newIndex._aRows );
}

//+---------------------------------------------------------------------------
//
//  Function:   FindSplitPoint
//
//  Synopsis:   Given a row whose offset in the table is "oTableRow", this
//              method finds out the highest row in the rowIndex which is <=
//              "oTableRow".  This method is used during a window split to
//              determine the split-position of a rowIndex.
//
//  Arguments:  [oTableRow] - Offset of the row to compare with.
//
//  Returns:    The first row that belongs to the RHS.
//
//  History:    1-08-95   srikants   Created
//
//  Notes:      This method is used to find a split point in the client
//              row index during a window split. After determining the split
//              point in the query row index, we have to find a point in the
//              client row index which will split the client row index also
//              in the same manner as the query row index.
//
//----------------------------------------------------------------------------

LONG CRowIndex::FindSplitPoint( TBL_OFF oTableRow ) const
{

#if DBG==1
//    CheckSortOrder();
#endif  // DBG==1

    // Get the start of the array of offsets

    LONG iSplitRow = LONG_MAX;

    int iComp = 0;

    if ( 0 == _pRowCompare || 0 == _aRows.Count() )
    {
        iSplitRow = 0;
    }
    else if ( _pRowCompare->Compare( oTableRow, _aRows[0] ) < 0 )
    {
        //
        // The given row is < the smallest row in the row index.
        //
        iSplitRow = 0;
    }
    else if ( (iComp =
              _pRowCompare->Compare( oTableRow, _aRows[_aRows.Count()-1] )) >= 0  )
    {
        //
        // The given row is >= the biggest row in the row index.
        //
        iSplitRow = _aRows.Count();
    }
    else
    {

        ULONG oSplitRow = _FindInsertionPoint( oTableRow );
        Win4Assert( oSplitRow < _aRows.Count() );

        iSplitRow = (LONG) _aRows.Count();
        for ( unsigned i = oSplitRow; i < _aRows.Count(); i++ )
        {
            int iComp = _pRowCompare->Compare( oTableRow, _aRows[i] );
            Win4Assert( iComp <= 0 );
            if ( iComp < 0 )
            {
                iSplitRow = (LONG) i;
                break;
            }
        }
    }

    Win4Assert( LONG_MAX != iSplitRow );
    return iSplitRow;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMidSplitPoint
//
//  Synopsis:   Finds out a point in the row index which can serve as a split
//              point during a window split. The split point is such that
//              all rows in the rowindex from 0..SplitPoint are <= the row
//              in the SplitPoint and all rows SplitPoint+1.._aRows.Count()-1 are
//              > the row in the SplitPoint.
//
//  Arguments:  [riSplitPoint] - (output) The split point, if one exists.
//
//  Returns:    TRUE if a split point satisfying the above requirement is
//              found. FALSE o/w
//
//  History:    1-25-95   srikants   Created
//
//  Notes:      This method is used during a window split to determine a
//              split point in the query row index (if one exists).
//
//----------------------------------------------------------------------------

BOOL CRowIndex::FindMidSplitPoint( ULONG & riSplitPoint ) const
{

#if DBG==1
//    CheckSortOrder();
#endif  // DBG==1

    BOOL fFound = FALSE;

    if ( 0 != _aRows.Count() && 0 != _pRowCompare )
    {
        ULONG oMidPoint = _aRows.Count()/2;

        //
        // Find the first row to the RHS which is > the middle row.
        //
        for ( ULONG j =  oMidPoint+1; j < _aRows.Count(); j++ )
        {
            int iComp;
            if ( 0 != ( iComp =
                        _pRowCompare->Compare( _aRows[oMidPoint],
                                               _aRows[j]) ) )
            {
                Win4Assert( iComp < 0 );
                fFound = TRUE;
                riSplitPoint = j-1;
                break;
            }
        }

        if ( !fFound )
        {
            //
            // All rows to the right of oMidPoint are equal. We should now
            // try the LHS.
            //
            for ( int i = (int) oMidPoint-1; i >= 0; i-- )
            {
                int iComp;
                if ( 0 != (iComp = _pRowCompare->Compare( _aRows[i], _aRows[oMidPoint] )) )
                {
                    Win4Assert( iComp < 0 );
                    fFound = TRUE;
                    riSplitPoint = (ULONG) i;
                    break;
                }
            }
        }

        //
        // PERFFIX - this algorithm can be modified to find the split point
        // which is as close to the mid point as possible. That would mean
        // looking the LHS even if we find a split point in the RHS and the
        // split point != the oMidPoint. That will involve more comparisons.
        //
    }

    return fFound;
}

#if CIDBG==1 || DBG==1

void CRowIndex::CheckSortOrder() const
{
    if ( _aRows.Count() <= 1 || 0 == _pRowCompare )
    {
        return;    
    }

    for ( unsigned i = 0; i < _aRows.Count()-1 ; i++ )
    {
        int iComp = _pRowCompare->Compare( _aRows[i], _aRows[i+1] );
        Win4Assert( iComp <= 0 );
    }
}

#endif  // CIDBG==1 || DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\pathstor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       pathstor.cxx
//
//  Classes:    CSplitPath, CSplitPathCompare, CPathStore
//
//  Functions:
//
//  History:    5-02-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "pathstor.hxx"
#include "pathcomp.hxx"
#include "tabledbg.hxx"


const WCHAR CSplitPath::_awszPathSep[] = L"\\";

//+---------------------------------------------------------------------------
//
//  Function:   CSplitPath
//
//  Synopsis:   ~ctor for CSplitPath which can be initialized given the
//              "pathId".
//
//  Arguments:  [pathStore] - Reference to the path store.
//              [pathid]    - PathId to be used for initialization.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

CSplitPath::CSplitPath( CPathStore & pathStore, PATHID pathid )
{
    const CShortPath & path = pathStore.GetShortPath( pathid );

    CStringStore & strStore = pathStore.GetStringStore();

    if ( stridInvalid != path.GetParent() )
    {
        _pParent =  strStore.GetCountedWStr( path.GetParent(), _cwcParent );
    }
    else
    {
        _pParent = 0;
        _cwcParent = 0;
    }

    if ( stridInvalid != path.GetFileName() )
    {
        _pFile = strStore.GetCountedWStr( path.GetFileName(), _cwcFile );
    }
    else
    {
        _pFile = 0;
        _cwcParent = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CSplitPath
//
//  Synopsis:   ~ctor - initialized using a NULL terminated path.
//
//  Arguments:  [pwszPath] - The null terminated path.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

CSplitPath::CSplitPath( const WCHAR * pwszPath )
{
    const ULONG cwcPath = wcslen( pwszPath );
    Win4Assert( 0 != cwcPath );

    const WCHAR * pwszFinalComponent = wcsrchr(pwszPath, wchPathSep);

    if ( 0 == pwszFinalComponent )
    {
        _pParent = 0;
        _cwcParent = 0;

        _pFile = pwszPath;
        _cwcFile = cwcPath;
    }
    else
    {
        _pParent = pwszPath;
        _cwcParent = (DWORD)(pwszFinalComponent - pwszPath);

        _cwcFile = cwcPath - ( _cwcParent + 1 );    // skip over the path separator

        if ( 0 != _cwcFile )
        {
            _pFile = pwszPath + ( _cwcParent + 1 );
        }
        else
        {
            //
            // There is a path separator at the end of the string.
            //
            _pFile = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Advance
//
//  Synopsis:   Advances the current pointer by "cwc" characters during
//              comparison of split paths.
//
//  Arguments:  [cwc] - Number of characters to advance by.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

inline void CSplitPath::Advance( ULONG cwc )
{
    Win4Assert( cwc <= _cwcCurr );
    Win4Assert( !IsDone() );

    _cwcCurr -= cwc;

    if ( 0 == _cwcCurr )
    {
        //
        // We must go to the next step.
        //
        switch ( _step )
        {
            case eUseParent:

                if ( 0 != _pParent )
                {
                    _SetUsePathSep();
                }
                else
                {
                    if ( 0 != _pFile )
                    {
                        _SetUseFile();
                    }
                    else
                    {
                        _SetUsePathSep();
                    }
                }

                break;

            case eUsePathSep:

                if ( 0 == _pFile )
                {
                    _SetDone();
                }
                else
                {
                    _SetUseFile();
                }

                break;

            case eUseFile:

                _SetDone();
                break;

            default:
                Win4Assert( !"Impossible Case Condition" );
                break;
        }
    }
    else
    {
        _pCurr += cwc;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFullPathLen
//
//  Synopsis:   Determines the length of the fully path (in characters)
//              INCLUDING the NULL terminator.
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CSplitPath::GetFullPathLen() const
{
    ULONG cwcTotal = 0;

    if ( 0 != _cwcParent )
    {
        cwcTotal += (_cwcParent+1); // extra 1 is for the path separator
    }

    cwcTotal += GetFileNameLen();
    Win4Assert( cwcTotal > 1 );

    return cwcTotal;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormFullPath
//
//  Synopsis:   Forms the full path and copies it to pwszPath. It will
//              be NULL terminated.
//
//  Arguments:  [pwszPath] -  OUTPUT buffer for the path
//              [cwcPath]  -  INPUT  max. length of the buffer
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSplitPath::FormFullPath( WCHAR * pwszPath, ULONG cwcPath ) const
{
    ULONG cwcParent;

    Win4Assert( cwcPath >= GetFullPathLen() );

    if ( 0 != _pParent )
    {
        cwcParent = _cwcParent;
        RtlCopyMemory( pwszPath, _pParent, cwcParent * sizeof(WCHAR) );
        //
        // Append a backslash after the parent's part.
        //
        Win4Assert( cwcParent < cwcPath );
        pwszPath[cwcParent++] = wchPathSep;  // Append a backslash
        pwszPath += cwcParent;
    }

    ULONG cwcFileName = _cwcFile;
    if ( 0 != _pFile )
    {
        Win4Assert( 0 != _cwcFile );
        RtlCopyMemory( pwszPath, _pFile, _cwcFile * sizeof(WCHAR) );
    }

    pwszPath[cwcFileName] = L'\0';
}

//+---------------------------------------------------------------------------
//
//  Function:   FormFileName
//
//  Synopsis:   Fills just the "FileName" component of the path in the
//              given buffer.
//
//  Arguments:  [pwszPath]    -  OUTPUT buffer - will contain the NULL
//                               terminated filename.
//              [cwcFileName] -  MAXLEN of pwszPath
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------
inline
void CSplitPath::FormFileName( WCHAR * pwszPath, ULONG cwcFileName ) const
{
    Win4Assert( cwcFileName >= GetFileNameLen() );

    if ( 0 != _pFile )
    {
        RtlCopyMemory( pwszPath, _pFile, sizeof(WCHAR)*_cwcFile );
    }

    pwszPath[_cwcFile] = L'\0';
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   _Compare
//
//  Synopsis:   Compars the lhs and rhs split paths.
//
//  Returns:    -1, 0, +1 depending on whether lhs <, =, > rhs
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSplitPathCompare::_Compare()
{
    int iComp = 0;
    while ( !_IsDone() )
    {
        iComp = _lhs.CompareCurr( _rhs );
        if ( 0 != iComp )
        {
            return iComp;
        }

        ULONG cwcMin = min ( _lhs.GetCurrLen(), _rhs.GetCurrLen() );
        _lhs.Advance( cwcMin );
        _rhs.Advance( cwcMin );
    }

    iComp = _rhs.GetStep() - _lhs.GetStep();
    if ( iComp > 0 )
    {
        iComp = 1;
    }
    else if ( iComp < 0 )
    {
        iComp = -1;
    }

    return iComp;

}

//+---------------------------------------------------------------------------
//
//  Function:   ComparePaths
//
//  Synopsis:   Compares the two paths.
//
//  Returns:    0  if equal
//              -1 if lhs < rhs
//              +1 if lhs > rhs
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSplitPathCompare::ComparePaths()
{
    _lhs.InitForPathCompare();
    _rhs.InitForPathCompare();

    return _Compare();

}

//+---------------------------------------------------------------------------
//
//  Function:   CompareNames
//
//  Synopsis:   Compares the "Name" component of two paths.
//
//  Returns:    0  if equal
//              -1 if lhs < rhs
//              +1 if lhs > rhs
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSplitPathCompare::CompareNames()
{
    _lhs.InitForNameCompare();
    _rhs.InitForNameCompare();

    return _Compare();
}

//+---------------------------------------------------------------------------
//
//  Function:  Constructor for the CStringStore
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

CStringStore::CStringStore() : _pStrHash(0)
{
    _pStrHash = new CCompressedColHashString( FALSE );
                                                // Don't optimize for ascii
    END_CONSTRUCTION( CStringStore );
}

//+---------------------------------------------------------------------------
//
//  Function:   CStringStore
//
//  Synopsis:   Destructor for CStringStore.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

CStringStore::~CStringStore()
{
    delete _pStrHash;
}

//+---------------------------------------------------------------------------
//
//  Function:   Add
//
//  Synopsis:   Adds the NULL terminated pwszStr to the string store.
//
//  Arguments:  [pwszStr] - NULL terminated string to be added.
//
//  Returns:    The STRINGID of the string in the store.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

STRINGID CStringStore::Add( const WCHAR * pwszStr )
{

   ULONG    strId;
   GetValueResult   gvr;
   _pStrHash->AddData( pwszStr, strId, gvr );
    Win4Assert( GVRSuccess == gvr );

    return strId;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddCountedWStr
//
//  Synopsis:   Adds a "counted" string to the store.
//
//  Arguments:  [pwszStr] - Pointer to the string to be added.
//              [cwcStr]  - Number of WCHARS in the string.
//
//  Returns:    The ID of the string.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

STRINGID CStringStore::AddCountedWStr( const WCHAR * pwszStr, ULONG cwcStr )
{

   ULONG    strId;
   GetValueResult   gvr;
   _pStrHash->AddCountedWStr( pwszStr, cwcStr, strId, gvr );
    Win4Assert( GVRSuccess == gvr );

    return strId;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindCountedWStr
//
//  Synopsis:   Finds a "counted" string in the store.
//
//  Arguments:  [pwszStr] - Pointer to the string to be added.
//              [cwcStr]  - Number of WCHARS in the string.
//
//  Returns:    The ID of the string.
//
//  History:    7-17-95   dlee   Created
//
//----------------------------------------------------------------------------

STRINGID CStringStore::FindCountedWStr( const WCHAR * pwszStr, ULONG cwcStr )
{

   if ( 0 != pwszStr )
       return _pStrHash->FindCountedWStr( pwszStr, cwcStr );
   else
       return stridInvalid;
}

//+---------------------------------------------------------------------------
//
//  Function:   StrLen
//
//  Synopsis:   Length of the String associated with strId EXCLUDING the
//              terminating NULL.
//
//  Arguments:  [strId] -  Id of the string whose length is needed.
//
//  Returns:
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CStringStore::StrLen( STRINGID strId )
{
    return _pStrHash->DataLength( strId )-1;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCountedWStr
//
//  Synopsis:   Gets the string identified by the "strId.
//
//  Arguments:  [strId]  -  The id of the string to lookup.
//              [cwcStr] -  On output, will have the count of the chars
//                          in the string.
//
//
//  Returns:    Pointer to the string - NOT NULL terminated.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

const WCHAR * CStringStore::GetCountedWStr( STRINGID strId, ULONG & cwcStr )
{
    return _pStrHash->GetCountedWStr( strId, cwcStr );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetString
//
//  Synopsis:   Returns the string identified by the strId.
//
//  Arguments:  [strId]    -  ID of the string to retrieve
//              [pwszPath] -  Pointer to the buffer to hold the string
//              [cwcPath]  -  On input, the max capacity of pwszPath. On
//                            output, it will have the count of the chars
//                            in the string, excluding the terminating NULL.
//
//  Returns:
//
//  Modifies:
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

GetValueResult
CStringStore::GetString( STRINGID strId, WCHAR * pwszPath, ULONG & cwcPath )
{
    return _pStrHash->GetData( strId, pwszPath, cwcPath );
}



CPathStore::~CPathStore()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   FindData
//
//  Synopsis:   Finds the given data (pidPath/pidName) in the path store.
//
//  Arguments:  [pVarnt]      - string to look for
//              [rKey]        - returns key
//
//  Returns:    TRUE if found, FALSE otherwise
//
//  History:    7-3-95   dlee   Created
//
//----------------------------------------------------------------------------

BOOL CPathStore::FindData(
    PROPVARIANT const * const pvarnt,
    ULONG &                   rKey )
{
    Win4Assert(pvarnt->vt == VT_LPWSTR);
    WCHAR * pwszData = pvarnt->pwszVal;

    CSplitPath  path( pwszData );

    STRINGID idParent = _strStore.FindCountedWStr( path._pParent, path._cwcParent );
    STRINGID idName = _strStore.FindCountedWStr( path._pFile, path._cwcFile );

    CShortPath shortPath( idParent, idName );

    for ( unsigned i = 0; i < _aShortPath.Count(); i++ )
    {
        if ( shortPath.IsSame( _aShortPath[ i ] ) )
        {
            rKey = i + 1;  // keys are 1-based
            return TRUE;
        }
    }

    return FALSE;
} //FindData

//+---------------------------------------------------------------------------
//
//  Function:   AddData
//
//  Synopsis:   Adds the given data (pidPath/pidName) to the path store.
//
//  Arguments:  [pVarnt]      -
//              [pKey]        -
//              [reIndicator] -
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

void CPathStore::AddData( PROPVARIANT const * const pVarnt,
                          ULONG* pKey,
                          GetValueResult& reIndicator
                        )
{
    //
    //  Specially handle the VT_EMPTY case
    //
    if (pVarnt->vt == VT_EMPTY)
    {
        *pKey = 0;
        reIndicator = GVRSuccess;
        return;
    }

    Win4Assert(pVarnt->vt == VT_LPWSTR);
    WCHAR * pwszData = pVarnt->pwszVal;

    *pKey = AddPath( pwszData );
    reIndicator = GVRSuccess;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetData
//
//  Synopsis:
//
//  Arguments:  [pVarnt]        -   OUTPUT- Variant to hold the data.
//              [PreferredType] -   UNUSED
//              [ulKey]         -   The "Key" (PathId) of the path to be
//                                  retrieved.
//              [PropId]        -   pidPath/pidWorkId/pidName
//
//  Returns:    GVRSuccess if successful.
//              a GVR* failure code o/w.
//
//  History:    5-09-95   srikants   Created
//
//  Notes:      FreeVariant MUST be called.
//
//----------------------------------------------------------------------------

GetValueResult
CPathStore::GetData( PROPVARIANT * pVarnt,
                     VARTYPE PreferredType,
                     ULONG ulKey,
                     PROPID PropId )
{
    if (ulKey == 0)
    {
        pVarnt->vt = VT_EMPTY;
        return GVRNotAvailable;
    }

    Win4Assert( _IsValid( ulKey ) );

    if ( pidWorkId == PropId )
    {
        pVarnt->vt = VT_I4;
        pVarnt->lVal = (LONG) ulKey;
        return GVRSuccess;
    }

    CSplitPath path( *this, ulKey );

    if ( pidName == PropId )
    {
        ULONG cwcFileName = path.GetFileNameLen();
        Win4Assert( cwcFileName > 0 );

        WCHAR * pwszFileName = _GetPathBuffer( cwcFileName );
        path.FormFileName( pwszFileName, cwcFileName );

        pVarnt->vt = VT_LPWSTR;
        pVarnt->pwszVal = pwszFileName;

        return GVRSuccess;
    }
    else
    {
        Win4Assert( pidPath == PropId );

        //
        //  Retrieve entire path name.
        //
        //  First, compute the required size of the return buffer.
        //
        ULONG  cwcPathLen = path.GetFullPathLen( );
        WCHAR * pwszDest = _GetPathBuffer( cwcPathLen );

        pVarnt->vt = VT_LPWSTR;
        pVarnt->pwszVal = pwszDest;

        path.FormFullPath( pwszDest, cwcPathLen );
        return GVRSuccess;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeVariant
//
//  Synopsis:   Frees the variant created in the "GetData" call.
//
//  Arguments:  [pVarnt] -  Pointer to the variant to be freed.
//
//  History:    5-09-95   srikants   Created
//
//----------------------------------------------------------------------------

void CPathStore::FreeVariant(PROPVARIANT * pVarnt)
{
    if ( pVarnt->vt != VT_EMPTY && pVarnt->vt != VT_I4 )
    {
        Win4Assert(pVarnt->vt == VT_LPWSTR);
        _strStore.FreeVariant( pVarnt );
        pVarnt->pwszVal = 0;            // To prevent accidental re-use
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _AddPath
//
//  Synopsis:   Adds the given path to the store.
//
//  Arguments:  [path] -
//
//  Returns:    ID of the path.
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

PATHID CPathStore::_AddPath( CSplitPath & path )
{

    STRINGID    idParent = stridInvalid;
    STRINGID    idName = stridInvalid;

    if ( 0 != path._pParent )
    {
        idParent = _strStore.AddCountedWStr( path._pParent, path._cwcParent );
    }

    if ( 0 != path._pFile )
    {
        idName = _strStore.AddCountedWStr( path._pFile, path._cwcFile );
    }

    return _AddEntry( idParent, idName );

}

//+---------------------------------------------------------------------------
//
//  Function:   AddPath
//
//  Synopsis:   Adds the given path to the path store.
//
//  Arguments:  [pwszPath] - Pointer to the path to be added.
//
//  Returns:    An ID for the path.
//
//  History:    5-03-95   srikants   Created
//
//  Notes:      There is NO duplicate detection for paths. A new ID is given
//              everytime this method is called.
//
//----------------------------------------------------------------------------

PATHID CPathStore::AddPath( WCHAR * pwszPath )
{
    Win4Assert( 0 != pwszPath );
    CSplitPath  path( pwszPath );
    PATHID pathId = _AddPath( path );

    tbDebugOut(( DEB_BOOKMARK,
                 "WorkId=0x%8X  Path=%ws\n", pathId, pwszPath ));

    return pathId;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddPath
//
//  Synopsis:   Given a source path store and an id in the source pathstore,
//              this method adds the path from the source pathstore to this
//              store.
//
//  Arguments:  [srcStore]  - Reference to the source path store.
//              [srcPathId] - Id in the source path store.
//
//  Returns:    PATHID for the path added.
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

PATHID CPathStore::AddPath( CPathStore & srcStore, PATHID srcPathId )
{

    CSplitPath  srcPath( srcStore, srcPathId );
    return _AddPath( srcPath );
}

//+---------------------------------------------------------------------------
//
//  Function:   PathLen
//
//  Synopsis:   Length of the path (INCLUDING terminating NULL) given the
//              pathid.
//
//  Arguments:  [pathId] -  Id of the path whose length is requested.
//
//  Returns:    Length of the path including terminating null.
//
//  History:    5-03-95   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CPathStore::PathLen( PATHID pathId )
{

    CSplitPath  path( *this, pathId );
    return path.GetFullPathLen();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetPath
//
//  Synopsis:   Given a pathId, it returns the path for that pathid.
//
//  Arguments:  [pathId]  - Id of the path to be retrieved
//              [vtPath]  - Variant to hold the output
//              [cbVarnt] - On Input, the maximum length of the variant.
//                          On output, the actual length of the variant.
//
//  Returns:    GVRSuccess if successful
//              GVRNotEnoughSpace if the length of the variant is less
//              than needed.
//
//  History:    5-08-95   srikants   Created
//
//----------------------------------------------------------------------------

GetValueResult
CPathStore::GetPath( PATHID pathId, PROPVARIANT & vtPath, ULONG & cbVarnt )
{
    CSplitPath  splitPath( *this, pathId );

    const ULONG cbPath = splitPath.GetFullPathLen() * sizeof(WCHAR);
    const ULONG cbHeader = sizeof(PROPVARIANT);
    const ULONG cbTotal = cbHeader + cbPath;

    if ( cbVarnt < cbTotal )
    {
        cbVarnt = cbTotal;
        return GVRNotEnoughSpace;
    }

    const ULONG cwcPath = (cbTotal-cbHeader)/sizeof(WCHAR);

    WCHAR * pwszPath = (WCHAR *) ( ((BYTE*) &vtPath) + cbHeader );
    splitPath.FormFullPath( pwszPath, cwcPath );

    vtPath.vt = VT_LPWSTR;
    vtPath.pwszVal = pwszPath;

    cbVarnt = cbTotal;
    return GVRSuccess;
}

//+---------------------------------------------------------------------------
//
//  Function:   Get
//
//  Synopsis:   Retrieves the path specified by the pathId into a buffer
//              allocated from the dstPool.
//
//  Arguments:  [pathId]  -   Id of the path to be retrieved.
//              [propId]  -   pidName/pidPath
//              [dstPool] -   Pool from which to allocate memory.
//
//  Returns:    Pointer to a WCHAR * containing the requested data
//              (NULL Terminated).
//
//  History:    5-23-95   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR *
CPathStore::Get( PATHID pathId, PROPID propId, PVarAllocator & dstPool )
{
    // summary catalogs can have empty paths

    if ( 0 == pathId )
        return 0;

    CSplitPath  path( *this, pathId );

    WCHAR * pwszDest = 0;

    if ( pidName == propId )
    {
        ULONG cwcFileName = path.GetFileNameLen();
        ULONG cbDst = cwcFileName * sizeof(WCHAR);
        Win4Assert( cwcFileName > 0 );
        pwszDest = (WCHAR *) dstPool.Allocate( cbDst );
        path.FormFileName( pwszDest, cwcFileName );
    }
    else
    {
        Win4Assert( pidPath == propId );

        //
        //  Retrieve entire path name.
        //
        //  First, compute the required size of the return buffer.
        //
        ULONG  cwcPathLen = path.GetFullPathLen();
        Win4Assert( cwcPathLen > 0 );
        ULONG cbDst = cwcPathLen * sizeof(WCHAR);
        pwszDest = (WCHAR *) dstPool.Allocate( cbDst );
        path.FormFullPath( pwszDest, cwcPathLen );
    }

    return pwszDest;
}

//+---------------------------------------------------------------------------
//
//  Function:   _AddEntry
//
//  Synopsis:   Adds an entry consisting of a ParentId and a FileId to the
//              store and returns a PATHID representing this short path.
//
//  Arguments:  [idParent]   - Id of the parent in the path
//              [idFileName] - Id of the file in the path.
//
//  History:    5-10-95   srikants   Created
//
//----------------------------------------------------------------------------

PATHID CPathStore::_AddEntry( STRINGID idParent, STRINGID idFileName )
{
    CShortPath  path( idParent, idFileName );
    _aShortPath.Add( path, _aShortPath.Count() );
    return _aShortPath.Count();
}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two paths given their pathids.
//
//  Arguments:  [pathid1] -
//              [pathid2] -
//              [propId]  -  pidName/pidFile
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CPathStore::Compare( PATHID pathid1, PATHID pathid2,
                         PROPID propId
                         )
{
    // summary catalogs can have empty paths

    if ( 0 == pathid1 || 0 == pathid2 )
        return pathid1 - pathid2;

    Win4Assert( pidName == propId || pidPath == propId );

    CSplitPath  path1( *this, pathid1 );
    CSplitPath  path2( *this, pathid2 );

    CSplitPathCompare   comp( path1, path2 );

    if ( pidName == propId )
    {
        return comp.CompareNames();
    }
    else
    {
        return comp.ComparePaths();
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares a NULL terminated path with a pathid.
//
//  Arguments:  [pwszPath1] - NULL terminated path.
//              [pathid2]   - Id of the second path.
//              [propId]    - pidName/pidPath
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CPathStore::Compare( const WCHAR * pwszPath1, PATHID pathid2,
                         PROPID propId )
{
    if ( 0 == pathid2 )
        return 0;

    Win4Assert( pidName == propId || pidPath == propId );

    CSplitPath  path1( pwszPath1 );
    CSplitPath  path2( *this, pathid2 );

    CSplitPathCompare   comp( path1, path2 );

    if ( pidName == propId )
    {
        return comp.CompareNames();
    }
    else
    {
        return comp.ComparePaths();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares a path in the variant form to a pathId.
//
//  Arguments:  [varnt]   -
//              [pathid2] -
//              [propId]  -
//
//  History:    5-11-95   srikants   Created
//
//----------------------------------------------------------------------------

int CPathStore::Compare( PROPVARIANT &varnt, PATHID pathid2,
                         PROPID propId )
{
    Win4Assert( pidName == propId || pidPath == propId );

    Win4Assert( varnt.vt == VT_LPWSTR );
    const WCHAR * pwszPath1 = varnt.pwszVal;

    return Compare( pwszPath1, pathid2, propId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\rowcomp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       rowcomp.cxx
//
//  Contents:   Implementation of CRowIndex
//
//  Classes:    CRowCompareVariant
//
//  History:    23 Aug 1994     dlee    Created
//
//  Notes:      All of these routines assume the caller (in this case the
//              table window) is locked, so they don't do their own locking
//              to protect data.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <bigtable.hxx>
#include <tblalloc.hxx>         // for CFixedVarAllocator
#include <objcur.hxx>
#include <compare.hxx>

#include "tabledbg.hxx"
#include "rowindex.hxx"
#include "rowcomp.hxx"
#include "tblwindo.hxx"
#include "colcompr.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::CRowCompareVariant, public
//
//  Synopsis:   Constructor for comparator object.  Basically just
//              invokes the PropSet comparator.
//
//  Arguments:  [TableWindow]  -- table window object
//
//  History:    29 Aug 1994     dlee   Created
//
//--------------------------------------------------------------------------

CRowCompareVariant::CRowCompareVariant(CTableWindow &TableWindow)
    : _TableWindow(TableWindow),
      _cProps(TableWindow.SortOrder().Count()),
      _aComparator(_cProps),
      _aVar1(_cProps),
      _aVar2(_cProps),
      _apVar1(_cProps),
      _apVar2(_cProps),
      _apColumn(_cProps),
      _aVarFlags1(_cProps),
      _aVarFlags2(_cProps),
      _pPathStore(0),
      _sharedBuf(TableWindow._sharedBuf),
      _xBuffer(),
      _widCached(widInvalid)
{
    //
    // Initialize an array of pointers to the variants, which is what
    // the comparison routine wants (and needs because some variants are
    // larger than a variant -- their out of line data is in the same
    // block after the variant-proper data).
    //
    // Also make an array of sort column data
    //

    for (unsigned i = 0; i < _cProps; i++)
    {
        _aVarFlags1[i] = eNone;
        _aVarFlags2[i] = eNone;

        _apVar1[i] = &(_aVar1[i]);
        _apVar2[i] = &(_aVar2[i]);

        BOOL fFound = FALSE;
        SSortKey Key = _TableWindow.SortOrder().Get( i );
        _apColumn[i] = _TableWindow._Columns.Find( Key.pidColumn, fFound );
        Win4Assert(fFound);
    }

    _InitComparators( _TableWindow.SortOrder() );
} //CRowCompareVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::~CRowCompareVariant, public
//
//  Synopsis:   Destructor for comparator object.  Frees allocated variants
//              left around after an exception or those that are buffered
//              for variant set 1.
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

CRowCompareVariant::~CRowCompareVariant()
{
    _Cleanup1();
    _Cleanup2();
} //~CRowCompareVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_FreeVariant, private
//
//  Synopsis:   Frees allocated variant depending on its source
//
//  Arguments:  [pColumn]  -- column needed to get compressor
//              [pVar]     -- variant to free
//              [eSource]  -- source of the variant allocation
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_FreeVariant(
    CTableColumn *  pColumn,
    CTableVariant * pVar,
    EVariantSource  eSource)
{
    switch (eSource)
    {
        case eCompressor :
            (pColumn->GetCompressor())->FreeVariant( pVar );
            break;
        case eNewx :
            delete pVar;
            break;
        case eBuffer:
            _xBuffer.Release();
            break;
        default :
            Win4Assert(! "CRowCompareVariant::_FreeVariant() bad");
            break;
    }
} //_FreeVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_Cleanup1, private
//
//  Synopsis:   Frees allocated variants
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_Cleanup1()
{
    for (unsigned i = 0; i < _cProps; i++)
    {
        if (eNone != _aVarFlags1[i])
        {
            _FreeVariant( _apColumn[i], _apVar1[i], _aVarFlags1[i] );
            _aVarFlags1[i] = eNone;
            _apVar1[i] = &(_aVar1[i]);
        }
    }
} //_Cleanup1

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_Cleanup2, private
//
//  Synopsis:   Frees allocated variants
//
//  History:    12 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_Cleanup2()
{
    for (unsigned i = 0; i < _cProps; i++)
    {
        if (eNone != _aVarFlags2[i])
        {
            _FreeVariant( _apColumn[i], _apVar2[i], _aVarFlags2[i] );
            _aVarFlags2[i] = eNone;

            // Don't have to restore this pointer -- never changes for 2

            Win4Assert( _apVar2[i] == &(_aVar2[i]) );
            //_apVar2[i] = &(_aVar2[i]);
        }
    }
} //_Cleanup2

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_MakeVariant, private
//
//  Synopsis:   Makes variants from raw row data.  Variants are needed
//              by the comparator.
//
//  Arguments:  [pColumn] -- column description
//              [pbRow]   -- pointer to raw row data for row (source)
//              [pVar]    -- variant pointer (destination)
//              [rSource] -- source of the variant's allocation,
//                           only touched if not eNone
//
//  History:    1 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

void CRowCompareVariant::_MakeVariant(
    CTableColumn *   pColumn,
    BYTE *           pbRow,
    CTableVariant *  pVar,
    EVariantSource & rSource)
{
    pbRow += pColumn->GetValueOffset();

    if (pColumn->IsCompressedCol())
    {
        //
        // Get the compressed data into a variant.  Ignore the return
        // code.  Assume that if GetData() is unable to find data it sets
        // the variant to VT_EMPTY, which the comparator is expecting.
        //

        (pColumn->GetCompressor())->GetData( pVar,
                                             pColumn->GetStoredType(),
                                             pColumn->GetValueSize() ?
                                                 * ((ULONG *) pbRow) : 0,
                                             pColumn->PropId );
        rSource = eCompressor;
    }
    else
    {
        // Create variants from non-compressed data

        Win4Assert( pColumn->IsValueStored() );

        pVar->Init( pColumn->GetStoredType(),
                    pbRow,
                    pColumn->GetValueSize() );

        // Convert out of line data from offset to pointer

        pVar->OffsetsToPointers( _TableWindow._DataAllocator );
    }
} //_MakeVariant

//+-------------------------------------------------------------------------
//
//  Member:     CRowCompareVariant::_MakeVariant, private
//
//  Synopsis:   Makes variants from raw row data.  Variants are needed
//              by the comparator.  Always puts variants in Var1, never
//              in Var2.
//
//  Arguments:  [pColumn]       -- column description
//              [rObject] -- object accessor for variant construction
//              [iProp]         -- index of variant to which data is written
//
//  Notes:      inline -- only called once
//
//  History:    1 Sep 1994     dlee   Created
//
//--------------------------------------------------------------------------

inline void CRowCompareVariant::_MakeVariant(
    CTableColumn *  pColumn,
    CRetriever & rObject,
    unsigned        iProp)
{
    ULONG cbBuf = sizeof CTableVariant;

    GetValueResult eGvr = rObject.GetPropertyValue( pColumn->PropId,
                                                    _apVar1[iProp],
                                                    &cbBuf );

    //
    // If the data won't fit in a normal variant, either use the built-in
    // buffer or allocate a large one which will be freed after the
    // comparison.
    //

    if (eGvr == GVRNotEnoughSpace)
    {
        CTableVariant *pvar;

        if (!_xBuffer.InUse() && maxcbBuffer >= cbBuf)
        {
            if (0 == _xBuffer.GetPointer())
                _xBuffer.Init(maxcbBuffer);
            else
                _xBuffer.AddRef();

            pvar = (CTableVariant *) _xBuffer.GetPointer();
            _aVarFlags1[iProp] = eBuffer;
        }
        else
        {
            pvar = (CTableVariant*) new BYTE[cbBuf];
            _aVarFlags1[iProp] = eNewx;
        }

        eGvr = rObject.GetPropertyValue( pColumn->PropId, pvar, &cbBuf );
        _apVar1[iProp] = pvar;
    }

    if ( GVRNotAvailable == eGvr ||
         GVRSharingViolation == eGvr )
    {
        // No value for this property -- make an empty variant
        _apVar1[iProp]->vt = VT_EMPTY;
    }

    else if ( GVRSuccess != eGvr )
    {
        THROW( CException( CRetriever::NtStatusFromGVR(eGvr)) );
    }

} //_MakeVariant

//+---------------------------------------------------------------------------
//
//  Function:   _InitComparators
//
//  Synopsis:   Initializes the comparators methods for each of the columns
//              which need to be compared.
//
//  Arguments:  [sortSet] - The columns that need to be sorted on.
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRowCompareVariant::_InitComparators( CSortSet const & sortSet )
{
    for ( unsigned i = 0; i < _cProps; i++ )
    {
        _aComparator[i].Init( sortSet.Get(i).dwOrder );

        if ( 0 == _pPathStore && 0 != _apColumn[i]->GetCompressor() )
        {
            _pPathStore = _apColumn[i]->GetCompressor()->GetPathStore();
            if ( 0 != _pPathStore )
            {
                Win4Assert( _apColumn[i]->PropId == pidName ||
                            _apColumn[i]->PropId == pidPath ||
                            _apColumn[i]->PropId == pidWorkId );
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _GetPathId
//
//  Synopsis:   Returns the "pathId" stored in the row that the path compressor
//              can understand.
//
//  Arguments:  [col]   - The column description.
//              [pbRow] - Row in the window.
//
//  Returns:    PATHID in the row.
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PATHID CRowCompareVariant::_GetPathId( const CTableColumn & col , BYTE * pbRow )
{
    return _TableWindow.RowWorkid( pbRow );
}

//+---------------------------------------------------------------------------
//
//  Function:   _MakeVariant
//
//  Synopsis:   Creates a variant and is optimized to use the sharedBuf
//              if possible.
//
//  Arguments:  [iCol]      -  Index of the column
//              [sharedBuf] -  Global shared buffer
//              [obj]       -  The object retriever
//
//  Returns:    A pointer to the variant (if successful)
//
//  History:    5-22-95   srikants   Created
//
//  Notes:      This is optimized to avoid doing a memory allocation in
//              case the column is bigger than a simple variant. It
//              will use the global shared memory (sharedBuf) if it has
//              been acquired by the caller.
//
//----------------------------------------------------------------------------

// inline
PROPVARIANT * CRowCompareVariant::_MakeVariant( unsigned iCol,
                                            XUseSharedBuffer &sharedBuf,
                                            CRetriever & obj )
{
    PROPVARIANT * pVarnt = 0;

    if ( sharedBuf.IsAcquired() )
    {
        //
        // The shared buffer has been acquired by the caller and so we
        // can use it to get the variant.
        //
        pVarnt = (PROPVARIANT *) sharedBuf.LokGetBuffer();
        ULONG cbBuf = sharedBuf.LokGetSize();
        ULONG propId = _apColumn[iCol]->PropId;

        GetValueResult gvr = obj.GetPropertyValue( propId,
                                                   pVarnt,
                                                   &cbBuf );
        if ( GVRNotEnoughSpace == gvr )
        {
            pVarnt = 0;
        }
        else if ( GVRNotAvailable == gvr ||
                  GVRSharingViolation == gvr )
        {
            // No value for this property -- make an empty variant

            _apVar1[iCol]->vt = VT_EMPTY;
            pVarnt = _apVar1[iCol];
        }
        else if ( GVRSuccess != gvr )
        {
            THROW( CException( CRetriever::NtStatusFromGVR(gvr) ) );
        }
    }

    if ( 0 == pVarnt )
    {
        //
        // Either the sharedBuf was not acquired by the caller or the
        // buffer is not enough to hold the data.
        //
        if ( eNone == _aVarFlags1[iCol] )
        {
            _MakeVariant( _apColumn[iCol], obj, iCol );
        }
        pVarnt = _apVar1[iCol];
    }

    Win4Assert( 0 != pVarnt );
    return pVarnt;
}

//+---------------------------------------------------------------------------
//
//  Function:   _FastCompare
//
//  Synopsis:   A fast comparator for two rows in the window. It does a
//              quick compare on pidWorkId, pidPath and pidName.
//
//  Arguments:  [iCol]   -  Index of the column to be compared.
//              [pbRow1] -  Pointer to the window row 1
//              [pbRow2] -  Pointer to the window row 2
//              [iComp]  -  (OUTPUT) result of comparison.
//
//               0  - if equal
//              +1  - if row1 > row2
//              -1 - if row1 < row2
//
//  Returns:    TRUE if a fast compare was done. FALSE o/w
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

// inline
BOOL CRowCompareVariant::_FastCompare( unsigned iCol,
                                       BYTE *pbRow1, BYTE *pbRow2,
                                       int & iComp )
{
    ULONG propId = _apColumn[iCol]->PropId;


    switch ( propId )
    {
        case pidWorkId:
            {
                WORKID widRow1 = _TableWindow.RowWorkid( pbRow1 );
                WORKID widRow2 = _TableWindow.RowWorkid( pbRow2 );
                iComp = widRow1 - widRow2;
            }
            break;

        case pidName:
        case pidPath:

            if ( 0 == _apColumn[iCol]->GetCompressor() )
                return FALSE;

            Win4Assert( _apColumn[iCol]->GetValueSize() == sizeof(PATHID) );

            {
                PATHID pathid1 =  _GetPathId( *_apColumn[iCol], pbRow1 );
                PATHID pathid2 =  _GetPathId( *_apColumn[iCol], pbRow2 );
                iComp = _pPathStore->Compare( pathid1, pathid2, propId );
            }

            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _FastCompare
//
//  Synopsis:   Same as above except that it compares an object retriever to
//              a row in the window.
//
//  Arguments:  [iCol]   -
//              [obj]    -
//              [pbRow2] -
//              [iComp]  -
//
//  Returns:    TRUE if a fast compare was done; FALSE o/w
//
//  Modifies:
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
// inline
BOOL CRowCompareVariant::_FastCompare( unsigned iCol,
                                       CRetriever & obj,
                                       XUseSharedBuffer & sharedBuf,
                                       BYTE * pbRow2,
                                       int & iComp )
{
    ULONG propId = _apColumn[iCol]->PropId;

    switch ( propId )
    {
        case pidWorkId:
            {
                WORKID widRow1 = obj.WorkId();
                WORKID widRow2 = _TableWindow.RowWorkid( pbRow2 );
                iComp = widRow1 - widRow2;
            }
            break;

        case pidName:
        case pidPath:

            if ( 0 == _apColumn[iCol]->GetCompressor() )
                return FALSE;

            Win4Assert( _apColumn[iCol]->GetValueSize() == sizeof(PATHID) );

            {
                PATHID pathid2 =  _GetPathId( *_apColumn[iCol], pbRow2 );
                PROPVARIANT * pVarnt = _MakeVariant( iCol, sharedBuf, obj );
                iComp = _pPathStore->Compare( *pVarnt, pathid2, propId );
            }

            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two rows in the window.
//
//  Arguments:  [oRow1] -  Offset of row1
//              [oRow2] -  Offset of row2
//
//  Returns:    0 if the rows are the same,
//              positive column # of first column of row1 greater than row2
//              negative column # of first column of row1 less than row2
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

int CRowCompareVariant::Compare( TBL_OFF oRow1, TBL_OFF oRow2 )
{

    BYTE *pbRow1 = (BYTE *) _TableWindow.
                            _DataAllocator.FixedPointer( oRow1 );

    BYTE *pbRow2 = (BYTE *) _TableWindow.
                            _DataAllocator.FixedPointer( oRow2 );


    WORKID widRow1 = _TableWindow.RowWorkid( pbRow1 );
    WORKID widRow2 = _TableWindow.RowWorkid( pbRow2 );

    if ( widRow1 != _widCached )
    {
        _Cleanup1();
        _widCached = widRow1;
    }

    int iComp = 0 ;

    for ( unsigned i = 0;  ( 0 == iComp ) && (i < _cProps) ; i++ )
    {
        if ( _FastCompare( i, pbRow1, pbRow2, iComp ) )
        {
            iComp *= _aComparator[i].GetDirMult();
        }
        else
        {
            if ( eNone == _aVarFlags1[i] )
            {
                _MakeVariant( _apColumn[i], pbRow1, _apVar1[i], _aVarFlags1[i] );
            }

            _MakeVariant( _apColumn[i], pbRow2, _apVar2[i], _aVarFlags2[i] );
            iComp = _aComparator[i].Compare( _apVar1[i], _apVar2[i] );
        }
    }

    _Cleanup2();

    if ( 0 == iComp )
        return 0;
    else if ( iComp > 0 )
        return i;
    else
        return - (int) i;
} //Compare

//+---------------------------------------------------------------------------
//
//  Function:   CompareObject
//
//  Synopsis:   Compares an object retriever to a row in the window.
//
//  Arguments:  [obj]   -
//              [oRow2] -
//
//  Returns:
//
//  History:    5-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

int CRowCompareVariant::CompareObject( CRetriever & obj , TBL_OFF oRow2 )
{

    BYTE *pbRow2 = (BYTE *) _TableWindow.
                            _DataAllocator.FixedPointer( oRow2 );

    WORKID widRow1 = obj.WorkId();

    if ( widRow1 != _widCached )
    {
        _Cleanup1();
        _widCached = widRow1;
    }

    XUseSharedBuffer    xSharedBuf(_sharedBuf, FALSE);
    if ( !_sharedBuf.IsInUse() )
    {
        xSharedBuf.LokAcquire();
    }

    int iComp = 0;
    for ( unsigned i = 0;  ( 0 == iComp ) && (i < _cProps) ; i++ )
    {
        if ( _FastCompare( i, obj, xSharedBuf, pbRow2, iComp ) )
        {
            iComp *= _aComparator[i].GetDirMult();
        }
        else
        {
            if ( eNone == _aVarFlags1[i] )
            {
                _MakeVariant( _apColumn[i], obj, i );
            }

            _MakeVariant( _apColumn[i], pbRow2, _apVar2[i], _aVarFlags2[i] );
            iComp = _aComparator[i].Compare( _apVar1[i], _apVar2[i] );
        }
    }

    _Cleanup2();

    if ( 0 == iComp )
        return 0;
    else if ( iComp > 0 )
        return i;
    else
        return - (int) i;
} //CompareObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\rownotfy.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000
//
//  File:        rownotfy.cxx
//
//  Contents:    Rowset notification connection points
//
//  Classes:     CRowsetNotification
//               CRowsetAsynchNotification
//
//  History:     16 Feb 1998    AlanW   Created from conpt.cxx
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <rownotfy.hxx>
#include <query.hxx>

#include "tabledbg.hxx"


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//////////////// CRowsetAsynchNotification methods ///////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::CRowsetAsynchNotification, public
//
//  Synopsis:   Constructor for connection point container class.
//
//  Arguments:  [query]       -- query object with notify info
//              [pRowset]     -- Rowset pointer
//              [ErrorObject] -- OLE-DB error object
//              [fWatch]      -- TRUE if watch notification to be done
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CRowsetAsynchNotification::CRowsetAsynchNotification(
            PQuery & query,
            ULONG hCursor,
            IRowset * pRowset,
            CCIOleDBError & ErrorObject,
            BOOL fWatch)
   : _query(query),
     _hCursor(hCursor),
     CRowsetNotification( ),
     _AsynchConnectionPoint ( IID_IDBAsynchNotify ),
     _WatchConnectionPoint ( IID_IRowsetWatchNotify ),
     _fDoWatch (fWatch),
     _fPopulationComplete (FALSE),
     _cAdvise( 0 ),
     _pRowset(pRowset),
     _threadNotify(0),
     _threadNotifyId( 0 )
{
     _AsynchConnectionPoint.SetContrUnk( (IUnknown *)this );
     if (_fDoWatch)
     {
         _WatchConnectionPoint.SetContrUnk( (IUnknown *)this );
     }
} //CRowsetAsynchNotification

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::~CRowsetAsynchNotification, public
//
//  Synopsis:   Destructor for rowset watch notification class
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

CRowsetAsynchNotification::~CRowsetAsynchNotification()
{
    Win4Assert( _cRefs == 0 && _pContainer == 0 );
    Win4Assert( _cAdvise == 0 );

    if ( 0 != _pContainer )
        StopNotifications();

} //~CRowsetAsynchNotification


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::AddRef, public
//
//  Synopsis:   Increments aggregated object ref. count.
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowsetAsynchNotification::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::Release, public
//
//  Synopsis:   Decrements aggregated obj. ref. count, deletes on final release.
//
//  Returns:    ULONG
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowsetAsynchNotification::Release()
{
    long cRefs = InterlockedDecrement((long *) &_cRefs);

    tbDebugOut(( DEB_NOTIFY, "conpt: release, new crefs: %lx\n", _cRefs ));

    // If no references, make sure container doesn't know about me anymore
    if ( 0 == cRefs )
    {
        Win4Assert( 0 == _pContainer );

        if ( 0 != _pContainer )
        {
            // must have gotten here through excess client release
            StopNotifications();
        }

        delete this;
    }

    return cRefs;
} //Release


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::StopNotifications
//
//  Synopsis:   Shuts down the notification thread (if any)
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::StopNotifications()
{
    if ( GetCurrentThreadId() == _threadNotifyId )
    {
        Win4Assert( !"Notification thread used illegally" );
        return;
    }

    _EndNotifyThread();

    Disconnect();
    _AsynchConnectionPoint.Disconnect( );

    if (_fDoWatch)
        _WatchConnectionPoint.Disconnect( );
}


//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_EndNotifyThread
//
//  Synopsis:   Shuts down the notification thread (if any)
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::_EndNotifyThread()
{
    //
    // Is there a thread out there to close?
    //

    if (0 != _threadNotify)
    {
        // Signal the thread to die and wait for it to do so, or just kill
        // the thread if it looks like it might be lost in client code.

        tbDebugOut(( DEB_NOTIFY,
                     "set notify thread die event %lx\n",
                     _evtEndNotifyThread.GetHandle() ));

        _evtEndNotifyThread.Set();

        DWORD dw = WaitForSingleObject( _threadNotify, INFINITE );

        BOOL fCloseWorked = CloseHandle( _threadNotify );

        Win4Assert( fCloseWorked && "CloseHandle of notify thread failed" );

        _threadNotify = 0;

        tbDebugOut(( DEB_NOTIFY, "notify thread is history \n"));
    }
} //_EndNotifyThread

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_StartNotifyThread
//
//  Synopsis:   Starts the notification thread
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

inline void CRowsetAsynchNotification::_StartNotifyThread()
{
    tbDebugOut(( DEB_NOTIFY, "starting rowset notify thread\n" ));

    // First advise, create the thread
    Win4Assert(0 == _threadNotify);
    _threadNotify = CreateThread( 0, 65536,
                                  (LPTHREAD_START_ROUTINE) _NotifyThread,
                                  this, 0, & _threadNotifyId );

    if (0 == _threadNotify)
        THROW( CException() );
}

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_NotifyThread, private
//
//  Synopsis:   Entry point for notification thread
//
//  Arguments:  [self]             -- a container to call to do the work
//
//  Returns:    Thread exit code
//
//  Notes:      this function is "static"
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

DWORD CRowsetAsynchNotification::_NotifyThread(
    CRowsetAsynchNotification *self)
{
    TRANSLATE_EXCEPTIONS;

    DWORD dw = self->_DoNotifications();

    UNTRANSLATE_EXCEPTIONS;

    return dw;
} //_NotifyThread

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_DoNotifications, private
//
//  Synopsis:   Collects notifications and passes them out to clients.
//              Loops sending notifications until event to end thread
//              arrives.
//
//  Returns:    Thread exit code
//
//  History:    07-Oct-1994     dlee
//
//--------------------------------------------------------------------------

DWORD CRowsetAsynchNotification::_DoNotifications()
{
    BOOL fContinue = TRUE;

    do
    {
        TRY
        {
            if (fContinue && _AsynchConnectionPoint.GetAdviseCount() )
                fContinue = _DoAsynchNotification();

            if (fContinue && _fDoWatch &&
                _WatchConnectionPoint.GetAdviseCount() )
                fContinue = _DoWatchNotification();

            if (_fPopulationComplete && !_fDoWatch)
                fContinue = FALSE;
        }
        CATCH( CException, e )
        {
            // don't want to 'break' out of a catch block, use variable

            fContinue = FALSE;
        }
        END_CATCH;

        // Sleep for a bit, but wake up if the thread is to go away,

        ULONG x = _evtEndNotifyThread.Wait( defNotificationSleepDuration,
                                            FALSE );

        if ( STATUS_WAIT_0 == x )
            fContinue = FALSE;
    } while ( fContinue );

    return 0;
} //_DoNotifications

//+-------------------------------------------------------------------------
//
//  Function:   IsLowResources
//
//  Synopsis:   Returns TRUE if it looks like the error is resource related.
//
//  Returns:    BOOL - TRUE if low on resources
//
//  History:    9  May 1999   dlee
//
//--------------------------------------------------------------------------

BOOL IsLowResources( SCODE sc )
{
    return E_OUTOFMEMORY == sc ||
           STATUS_NO_MEMORY == sc ||
           STATUS_COMMITMENT_LIMIT == sc ||
           STATUS_INSUFFICIENT_RESOURCES == sc ||
           HRESULT_FROM_WIN32( ERROR_COMMITMENT_LIMIT ) == sc ||
           HRESULT_FROM_WIN32( ERROR_NO_SYSTEM_RESOURCES ) == sc ||
           STG_E_INSUFFICIENTMEMORY == sc;
} //IsLowResources

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_DoAsynchNotification, private
//
//  Synopsis:   Collects asynch notifications and passes them out to clients.
//              Tracks whether rowset population is completed, after which
//              no more notifications are given (except for completion
//              notifications for new advises).
//
//  Returns:    BOOL - TRUE if notification thread should continue
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

inline DWORD MapAsynchPhaseAndOp( ULONG op, ULONG phase )
{
    Win4Assert( op == 0 && phase < 4 );
    return (((op+1) << 4) | (1 << phase));
}

#define ASYNC_PHASE_MASK 0x0F
#define ASYNC_OP_MASK    0xF0

BOOL CRowsetAsynchNotification::_DoAsynchNotification()
{
    DBCOUNTITEM ulDenominator = 0, ulNumerator = 0;
    DBCOUNTITEM cRows = 0;
    BOOL fNewRows = FALSE;
    SCODE sc = S_OK;

    TRY
    {
        CNotificationSync Sync( _evtEndNotifyThread.GetHandle() );
        sc = _query.RatioFinished( Sync,
                                   _hCursor,
                                   ulDenominator,
                                   ulNumerator,
                                   cRows,
                                   fNewRows );
    
        // Did the main thread tell this thread to go away?
    
        if ( SUCCEEDED( sc ) )
        {
            Win4Assert( ulDenominator > 0 && ulNumerator <= ulDenominator );
    
            if (fNewRows)
                OnRowChange( _pRowset, 0, 0, DBREASON_ROW_ASYNCHINSERT,
                             DBEVENTPHASE_DIDEVENT, TRUE );
    
            if (!_fPopulationComplete && (ulNumerator == ulDenominator))
            {
                OnRowsetChange( _pRowset, DBREASON_ROWSET_POPULATIONCOMPLETE,
                                DBEVENTPHASE_DIDEVENT, TRUE );
    
                _fPopulationComplete = TRUE;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    if ( STATUS_CANCELLED == sc )
        return FALSE;

    BOOL fLowResources = IsLowResources( sc );

    if ( !fLowResources && !SUCCEEDED( sc ) )
        return FALSE;

    // Give notice to all active advises.
    // Need to be careful here to avoid deadlock.  The enumerator
    // grabs the CPC's mutex.  This limits what the client can do.

    ULONG ulAsynchPhase = DBASYNCHPHASE_POPULATION;
    if (_fPopulationComplete)
        ulAsynchPhase = DBASYNCHPHASE_COMPLETE;
    ULONG dwOpMask = MapAsynchPhaseAndOp( DBASYNCHOP_OPEN, ulAsynchPhase );

    CEnumConnectionsLite Enum( _AsynchConnectionPoint );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( 0 != pConnCtx )
    {
        IDBAsynchNotify *pNotifyAsynch = (IDBAsynchNotify *)(pConnCtx->_pIUnk);
        tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging asynch client %x\n", pNotifyAsynch ));
        SCODE sc = S_OK;

        if ( fLowResources )
        {
            //
            // Let the client know we're really wedged and they might not
            // get more notifications consistently.
            //

            sc = pNotifyAsynch->OnLowResource( 0 );
        }
        else
        {
            if ( 0 == (pConnCtx->_dwSpare & dwOpMask) )
            {
                sc = pNotifyAsynch->OnProgress( DB_NULL_HCHAPTER,
                                                DBASYNCHOP_OPEN,
                                                ulNumerator, ulDenominator,
                                                ulAsynchPhase, 0);
            }

            BOOL fOnStop = FALSE;
            if ( _fPopulationComplete && S_OK == sc )
            {
                sc = DB_S_UNWANTEDPHASE;
                fOnStop = TRUE;
            }
    
            if (DB_S_UNWANTEDPHASE == sc)
                pConnCtx->_dwSpare |= (dwOpMask & ASYNC_PHASE_MASK);
            else if (DB_S_UNWANTEDOPERATION == sc)
                pConnCtx->_dwSpare |= (dwOpMask & ASYNC_OP_MASK);
            else if (E_NOTIMPL == sc)
                pConnCtx->_dwSpare |= (ASYNC_PHASE_MASK | ASYNC_OP_MASK);

            if ( fOnStop )
                pNotifyAsynch->OnStop( DB_NULL_HCHAPTER,
                                       DBASYNCHOP_OPEN,
                                       S_OK,
                                       0 );
        }

        tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging asynch client\n" ));
        pConnCtx = Enum.Next();
    }

    // Keep trying to get notifications even if fLowResources is TRUE

    return TRUE;
} //_DoAsynchNotification

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::_DoWatchNotification, private
//
//  Synopsis:   Collects watch notifications and passes them out to clients.
//
//  Returns:    BOOL - TRUE if notification thread should continue
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

BOOL CRowsetAsynchNotification::_DoWatchNotification()
{
    // get notification information from the cursor

    CNotificationSync Sync( _evtEndNotifyThread.GetHandle() );
    DBWATCHNOTIFY changeType;

    SCODE sc = _query.GetNotifications( Sync, changeType );

    // Did the main thread tell this thread to go away?

    if (STATUS_CANCELLED == sc)
        return FALSE;

    if (!SUCCEEDED(sc))
        return FALSE;

    // got some, give them to all active advises
    // Need to be careful here to avoid deadlock.  The enumerator
    // grabs the CPC's mutex.  We need to break out of the loop
    // if the notify thread needs to go away...

    tbDebugOut(( DEB_NOTIFY, "rownotfy: watch type %d\n", changeType ));
    CEnumConnectionsLite Enum( _WatchConnectionPoint );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( pConnCtx )
    {
        IRowsetWatchNotify *pNotifyWatch =
                (IRowsetWatchNotify *)(pConnCtx->_pIUnk);
        tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging watch client %x\n", pNotifyWatch ));
        pNotifyWatch->OnChange( _pRowset, changeType);
        tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging watch client\n" ));
        pConnCtx = Enum.Next();
    }

    return TRUE;
} //_DoWatchNotification

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::AdviseHelper, private static
//
//  Synopsis:   Starts the notification thread if this is the first advise.
//
//  Arguments:  [pHelperContext] - "this" pointer
//              [pConnPt] - the connection point, either Async or Watch CP
//              [pConnCtx] - pointer to connection context
//
//  Notes:      CPC critical section is assumed to be held.
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::AdviseHelper( PVOID pHelperContext,
                                             CConnectionPointBase * pConnPt,
                                             CConnectionContext * pConnCtx )
{
    CRowsetAsynchNotification * pSelf =
        (CRowsetAsynchNotification *) pHelperContext;

    pSelf->_cAdvise++;
    if (1 == pSelf->_cAdvise)
    {
        // First advise, create the notification thread
        pSelf->_StartNotifyThread();
        Win4Assert(0 != pSelf->_threadNotify);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetAsynchNotification::UnadviseHelper, private static
//
//  Synopsis:   Stops the notification thread if this is the last active advise.
//
//  Arguments:  [pHelperContext] -- "this" pointer
//              [pConnPt]        -- the connection point, either Async or
//                                  Watch CP
//              [pConnCtx]       -- pointer to connection context
//              [lock]           -- CPC lock
//
//  Notes:      CPC critical section is assumed to be held.
//
//  History:    17 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

void CRowsetAsynchNotification::UnadviseHelper(
    PVOID pHelperContext,
    CConnectionPointBase * pConnPt,
    CConnectionContext * pConnCtx,
    CReleasableLock & lock )
{
    CRowsetAsynchNotification * pSelf =
        (CRowsetAsynchNotification *) pHelperContext;

    Win4Assert( pSelf->_cAdvise > 0 );
    if ( --pSelf->_cAdvise == 0 )
    {
        // Release the lock so the notify thread has a change to end
        // when we tell it to end.

        lock.Release();

        pSelf->_EndNotifyThread();
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MapPhaseAndReason, inline local
//
//  Synopsis:   Encode IRowsetNotify phase and reason into a bit mask
//              for supported phases and reasons.  Luckily, most supported
//              reasons have only a single phase.  Multi-phase reasons take
//              5 bits.
//
//  Returns:    DWORD - bit mask for the reason/phase combination
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

const maxSinglePhaseReasons = 8;
const maxMultiPhaseReasons = 4;
const maxPhases = 5;
const bitDidNotifyVote = 0x80000000;

inline DWORD MapPhaseAndReason( ULONG phase, ULONG reason )
{
    Win4Assert( reason <= 21 && phase <= 4 );

    BOOL fSinglePhase = TRUE;
    DWORD dwMappedReason = 0;

    switch (reason)
    {
    // single-phase reasons
    case DBREASON_ROW_ASYNCHINSERT:
        dwMappedReason = 0;     break;
    case DBREASON_ROWSET_RELEASE:
        dwMappedReason = 1;     break;
    case DBREASON_ROW_ACTIVATE:
        dwMappedReason = 2;     break;
    case DBREASON_ROW_RELEASE:
        dwMappedReason = 3;     break;
    case DBREASON_ROWSET_POPULATIONCOMPLETE:
        dwMappedReason = 4;     break;
    case DBREASON_ROWSET_POPULATIONSTOPPED:
        dwMappedReason = 5;     break;

    // multi-phase reasons
    case DBREASON_ROWSET_FETCHPOSITIONCHANGE:
        dwMappedReason = 0;     fSinglePhase = FALSE;   break;

    default:
        tbDebugOut(( DEB_ERROR, "MapPhaseAndReason - reason: %d phase: %d\n",
                     reason, phase ));
        Win4Assert( !"MapPhaseAndReason: unhandled reason" );
    }

    Win4Assert( FALSE == fSinglePhase || phase == DBEVENTPHASE_DIDEVENT );
    if (fSinglePhase)
    {
        Win4Assert( dwMappedReason < maxSinglePhaseReasons );
        dwMappedReason = (1 << dwMappedReason);
    }
    else
    {
        dwMappedReason = dwMappedReason*maxPhases + phase + maxSinglePhaseReasons;
        Win4Assert( dwMappedReason <= 30 );
        dwMappedReason = (1 << dwMappedReason);
    }

    return dwMappedReason;
}

//+-------------------------------------------------------------------------
//
//  Function:   MapAllPhases, inline local
//
//  Synopsis:   Return a bit mask that includes all bits for all supported
//              phases of the encoded reason.
//
//  Arguments:  [dwMappedReasonAndPhase] - a bit mask returned by
//                                         MapPhaseAndReason.
//
//  Returns:    DWORD - bit mask for all phases
//
//  History:    18 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

inline DWORD MapAllPhases( DWORD dwMappedReasonAndPhase )
{
    Win4Assert( dwMappedReasonAndPhase != 0 );

    if (dwMappedReasonAndPhase < (1<<maxSinglePhaseReasons))
        return dwMappedReasonAndPhase;

    // dwMask == 0x00001F00
    DWORD dwMask = (((1<<maxPhases)-1) << maxSinglePhaseReasons);
    for (unsigned i=0; i<maxMultiPhaseReasons; i++)
    {
        if (dwMask & dwMappedReasonAndPhase)
            return (dwMappedReasonAndPhase | dwMask);

        dwMask = dwMask << maxPhases;
    }
    Win4Assert(! "MapAllPhases - fell out of loop!" );
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     IRowsetNotify::OnXxxxChange
//
//  Synopsis:   Dispatches CRowsetNotification notifications to clients.
//
//  Returns:    SCODE
//
//  History:    11 Mar 1998     AlanW
//
//--------------------------------------------------------------------------

SCODE CRowsetNotification::OnFieldChange (
    IRowset *    pRowset,
    HROW         hRow,
    DBORDINAL    cColumns,
    DBORDINAL    rgColumns[],
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    SCODE sc = S_OK;

    //  NOTE:  OnFieldChange is not generated by our rowsets.  This code
    //         doesn't handle unwanted phases or reasons.

    CEnumConnectionsLite Enum( *this );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( pConnCtx )
    {
        IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
        tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x\n", pNotify ));
        SCODE sc1 = pNotify->OnFieldChange( pRowset,
                                             hRow,
                                             cColumns,
                                             rgColumns,
                                             eReason,
                                             ePhase,
                                             fCantDeny );
        tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client\n" ));
        pConnCtx = Enum.Next();
    }
    return sc;
}

SCODE CRowsetNotification::OnRowChange (
    IRowset *    pRowset,
    DBCOUNTITEM  cRows,
    const HROW   rghRows[],
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    // Note:  we don't generate any row notifications which can be denied.
    Win4Assert( fCantDeny && DBEVENTPHASE_DIDEVENT == ePhase );

    DWORD dwMask = MapPhaseAndReason( ePhase, eReason );
    CEnumConnectionsLite Enum( *this );
    CConnectionPointBase::CConnectionContext *pConnCtx = Enum.First();

    while ( pConnCtx )
    {
        if (0 == (pConnCtx->_dwSpare & dwMask))
        {
            IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
            tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x\n", pNotify ));
            SCODE sc1 = pNotify->OnRowChange( pRowset,
                                              cRows,
                                              rghRows,
                                              eReason,
                                              ePhase,
                                              fCantDeny );
            tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client\n" ));
            if (DB_S_UNWANTEDPHASE == sc1)
                pConnCtx->_dwSpare |= dwMask;
            else if (DB_S_UNWANTEDREASON == sc1)
                pConnCtx->_dwSpare |= MapAllPhases(dwMask);
        }
        pConnCtx = Enum.Next();
    }
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRowsetNotification::DoRowsetChangeCallout, private
//
//  Synopsis:   Issues an OnRowsetChange notification to all active
//              advises.  If [fCantDeny] is FALSE, tracks which advises
//              were successfully notified and checks the votes.
//
//  Arguments:  [Enum]      - a connection context enumeration
//              [pRowset]   - the rowset issuing the notification
//              [eReason]   - the notification reason
//              [ePhase]    - the notification phase
//              [fCantDeny] - if TRUE, notification can't be denied
//
//  Notes:      CPC critical section is assumed to be held.
//
//  History:    08 Apr 1998     AlanW
//
//--------------------------------------------------------------------------

BOOL CRowsetNotification::DoRowsetChangeCallout (
    CEnumConnectionsLite & Enum,
    IRowset *    pRowset,
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    DWORD dwMask = MapPhaseAndReason( ePhase, eReason );
    CConnectionPointBase::CConnectionContext *pConnCtx;
    BOOL fVeto = FALSE;

    for ( pConnCtx = Enum.First(); pConnCtx; pConnCtx = Enum.Next() )
    {
        if ( 0 == (pConnCtx->_dwSpare & dwMask) )
        {
            IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
            tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x\n", pNotify ));
            SCODE sc1 = pNotify->OnRowsetChange( pRowset,
                                                 eReason,
                                                 ePhase,
                                                 fCantDeny );

            if ( !fCantDeny )
            {
                if (S_FALSE == sc1)
                {
                    tbDebugOut(( DEB_NOTIFY, "rownotfy: notify client veto'ed\n" ));
                    fVeto = TRUE;
                    break;
                }
                pConnCtx->_dwSpare |= bitDidNotifyVote;
            }
            if (DB_S_UNWANTEDPHASE == sc1)
                pConnCtx->_dwSpare |= dwMask;
            else if (DB_S_UNWANTEDREASON == sc1)
                pConnCtx->_dwSpare |= MapAllPhases(dwMask);

            tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client\n" ));
        }
    }
    return fVeto;
}


SCODE CRowsetNotification::OnRowsetChange (
    IRowset *    pRowset,
    DBREASON     eReason,
    DBEVENTPHASE ePhase,
    BOOL         fCantDeny )
{
    // Note: we don't use SYNCHAFTER, and ABOUTTODO is done here after voting
    Win4Assert( DBEVENTPHASE_ABOUTTODO != ePhase &&
                DBEVENTPHASE_SYNCHAFTER != ePhase );

    BOOL fVeto = FALSE;
    CEnumConnectionsLite Enum( *this );

    if ( DBEVENTPHASE_OKTODO == ePhase )
    {
        Win4Assert( !fCantDeny );

        fVeto = DoRowsetChangeCallout( Enum, pRowset, eReason,
                                            DBEVENTPHASE_OKTODO, FALSE );
        if ( ! fVeto )
            fVeto = DoRowsetChangeCallout( Enum, pRowset, eReason,
                                                DBEVENTPHASE_ABOUTTODO, FALSE );

        DWORD dwMask = MapPhaseAndReason( DBEVENTPHASE_FAILEDTODO, eReason );
        CConnectionPointBase::CConnectionContext *pConnCtx;

        for ( pConnCtx = Enum.First(); pConnCtx; pConnCtx = Enum.Next() )
        {
            if (fVeto &&
                0 == (pConnCtx->_dwSpare & dwMask) &&
                0 != (pConnCtx->_dwSpare & bitDidNotifyVote) )
            {
                IRowsetNotify *pNotify = (IRowsetNotify *)(pConnCtx->_pIUnk);
                tbDebugOut(( DEB_NOTIFY, "rownotfy: pinging notify client %x for FAIL\n", pNotify ));
                SCODE sc1 = pNotify->OnRowsetChange( pRowset,
                                                     eReason,
                                                     DBEVENTPHASE_FAILEDTODO,
                                                     TRUE );
                tbDebugOut(( DEB_NOTIFY, "rownotfy:(end) pinging notify client for FAIL\n" ));

                if (DB_S_UNWANTEDPHASE == sc1)
                    pConnCtx->_dwSpare |= dwMask;
                else if (DB_S_UNWANTEDREASON == sc1)
                    pConnCtx->_dwSpare |= MapAllPhases(dwMask);
            }
            pConnCtx->_dwSpare &= ~bitDidNotifyVote;
        }
    }
    else
    {
        // a non-vetoable notification; just send the notifies
        Win4Assert( fCantDeny );
        DoRowsetChangeCallout( Enum, pRowset, eReason, ePhase, TRUE );
    }
    return fVeto ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\seglist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       seglist.cxx
//
//  Contents:   List of CTableSegment objects
//
//  Classes:    CTableSegList
//
//  History:    1-15-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <seglist.hxx>

#include "tblwindo.hxx"
#include "tblbuket.hxx"

CTableSegList::~CTableSegList()
{
    for ( CTableSegment * pSegment = RemoveTop();
          0 != pSegment;
          pSegment = RemoveTop() )
    {
        delete pSegment;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveTop
//
//  Synopsis:   Removes the top most element from the list and returns it.
//
//  Returns:    A pointer to the top most element from the list.
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableSegment * CTableSegList::RemoveTop()
{
    // tbDebugOut (( DEB_ITRACE, "TableSegList::RemoveTop\n" ));

    CTableSegment* pSegment = (CTableSegment*) _Pop();
    if ( pSegment )
        _DecrementCount( *pSegment );
    return pSegment;
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveFromList
//
//  Synopsis:   Removes the indicated node from the list.
//
//  Arguments:  [pNodeToRemove] -
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::RemoveFromList( CTableSegment * pNodeToRemove )
{
    Win4Assert( _IsNodeInList( pNodeToRemove ) &&
                "CTableSegList::pNodeToRemove not is list" );

    pNodeToRemove->Unlink();
    _DecrementCount( *pNodeToRemove );
}

//+---------------------------------------------------------------------------
//
//  Function:   InsertAfter
//
//  Synopsis:   Inserts "pNew" node after "pBefore" node.
//
//  Arguments:  [pBefore] -  The node already in list.
//              [pNew]    -  The new node to be inserted.
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::InsertAfter( CTableSegment * pBefore, CTableSegment * pNew )
{
    Win4Assert( 0 != pBefore && 0 != pNew );
    pNew->InsertAfter( pBefore );
    _IncrementCount( *pNew );
}

//+---------------------------------------------------------------------------
//
//  Function:   InsertBefore
//
//  Synopsis:   Inserts "pNew" node before "pAfter" node.
//
//  Arguments:  [pAfter] - The node already in the list.
//              [pNew]   - The new node to be inserted.
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::InsertBefore( CTableSegment * pAfter, CTableSegment * pNew )
{
    Win4Assert( 0 != pAfter && 0 != pNew );
    pNew->InsertBefore( pAfter );
    _IncrementCount( *pNew );
}

//+---------------------------------------------------------------------------
//
//  Function:   Replace
//
//  Synopsis:   Replaces the current entry in the iterator with the new
//              entry. It also replaces it in the list.
//
//  Arguments:  [it]   - Iterator
//              [pNew] - The new entry that replaces the entry in the
//              iterator.
//
//  Returns:    The old segment that was replaced in the list.
//
//  History:    4-10-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTableSegment* CTableSegList::Replace( CDoubleIter & it, CTableSegment * pNew )
{
    Win4Assert( 0 != pNew );
    CTableSegment * pCurr = (CTableSegment *) _Replace( it, pNew );

    _DecrementCount( *pCurr );
    _IncrementCount( *pNew );

    return pCurr;
}


//+---------------------------------------------------------------------------
//
//  Function:   _IncrementCount
//
//  Synopsis:   Increments the appropriate count depending upon the type of the
//              segment (node)
//
//  Arguments:  [node] -
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::_IncrementCount( const CTableSegment & node )
{
    switch( node.GetSegmentType() )
    {
    case CTableSegment::eWindow :
        _cWindows++;
        break;

    case CTableSegment::eBucket :
        _cBuckets++;
        break;
    };
}

//+---------------------------------------------------------------------------
//
//  Function:   _DecrementCount
//
//  Synopsis:   Decrements the count of the given node type.
//
//  Arguments:  [node] -
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTableSegList::_DecrementCount( const CTableSegment & node )
{
    switch( node.GetSegmentType() )
    {
        case CTableSegment::eWindow :
         Win4Assert( _cWindows > 0 );
        _cWindows--;
        break;

        case CTableSegment::eBucket :
         Win4Assert( _cBuckets > 0 );
        _cBuckets--;
        break;
    };

}

//+---------------------------------------------------------------------------
//
//  Function:   _IsNodeInList
//
//  Synopsis:   Determines if a given node is in the list.
//
//  Arguments:  [pNode] -  Node whose existence in the list is being tested.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    1-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CTableSegList::_IsNodeInList( CTableSegment * pNode )
{
    for (  CFwdTableSegIter iter(*this); !AtEnd(iter); Advance(iter) )
    {
        if ( iter.GetSegment() == pNode )
        {
            return TRUE;
        }
    }

    return FALSE;
}

CTableWindow * CDoubleTableSegIter::GetWindow()
{
    Win4Assert( GetSegment()->GetSegmentType() == CTableSegment::eWindow );
    return (CTableWindow *) _pLinkCur;
}

CTableBucket * CDoubleTableSegIter::GetBucket()
{
    Win4Assert( GetSegment()->GetSegmentType() == CTableSegment::eBucket );
    return (CTableBucket *) _pLinkCur;
}


//+---------------------------------------------------------------------------
//
//  Function:   ~CSegListMgr
//
//  Synopsis:   Destroys all the segments in the list.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSegListMgr::~CSegListMgr()
{
    for ( CTableSegment * pSegment = _list.RemoveTop();
          0 != pSegment;
          pSegment = _list.RemoveTop() )
    {
        delete pSegment;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   _InvalidateIfCached
//
//  Synopsis:   If the given segment's pointer is cached, invalidate it.
//
//  Arguments:  [pSeg] -  The segment which is going to go away and so must
//              be invalidated.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CSegListMgr::_InvalidateIfCached( const CTableSegment * const pSeg )
{
    Win4Assert( 0 != pSeg );

    if ( _pCachedPutRowSeg == pSeg )
    {
        _pCachedPutRowSeg = 0;
    }

    _clientSegs.Invalidate( pSeg );
    _bucketSegs.Invalidate( pSeg );
}

//+---------------------------------------------------------------------------
//
//  Function:   _UpdateSegsInUse
//
//  Synopsis:   Updates the wid->Segment mapping for wids that are cached.
//              For such wids, if they are present in the new segment, the
//              mapping is updated.
//
//  Arguments:  [list] - The list to update in.
//              [pSeg] - Pointer to the segment which is the new segment
//
//  History:    5-30-95   srikants   Created
//
//  Notes:      Helper function for UpdateSegsInUse()
//
//----------------------------------------------------------------------------

void CSegListMgr::_UpdateSegsInUse( CWidSegMapList & list,
                                    CTableSegment * pSeg )
{
    for ( CFwdWidSegMapIter iter(list); !list.AtEnd(iter);
          list.Advance(iter) )
    {
        WORKID  wid = iter->GetWorkId();
        if ( widInvalid != wid &&
             pSeg->IsRowInSegment( wid ) )
        {
            Win4Assert( 0 == iter->GetSegment() );
            iter->Set( pSeg );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateSegsInUse
//
//  Synopsis:   Updates the wid->Segment mapping for wids that are cached.
//              For such wids, if they are present in the new segment, the
//              mapping is updated.
//
//  Arguments:  [pSeg] - Pointer to a new segment that is coming into
//              existence.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CSegListMgr::UpdateSegsInUse( CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );

    CWidSegMapList & clientList = _clientSegs.GetList();
    _UpdateSegsInUse( clientList, pSeg );


    if ( !_bucketSegs.IsEmpty() )
    {
        CWidSegMapList & bktList = _bucketSegs.GetList();
        _UpdateSegsInUse( bktList, pSeg );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegListMgr::Replace
//
//  Synopsis:   Replaces the given segment in the _list with the new segments
//              passed in the list.
//
//  Arguments:  [pSeg] -  The segment to replace 
//              [list] -  The new list of segments.
//
//  History:    10-20-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CTableSegment * CSegListMgr::Replace( CTableSegment * pSeg, CTableSegList & list )
{

    _lookupArray.Replace( pSeg, list );

    CTableSegment * pCurr = pSeg;
    CTableSegment * pFirst = list.RemoveTop();

    while ( 0 != pFirst )
    {
        _list.InsertAfter( pCurr, pFirst );
        pCurr = pFirst;
        pFirst = list.RemoveTop();
    }

    _list.RemoveFromList( pSeg );
    _InvalidateIfCached( pSeg );

    _lookupArray.TestInSync( _list );

    return pSeg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\seqquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       seqquery.cxx
//
//  Contents:   Declarations of classes which implement sequential ICursor
//              and related OLE DB interfaces over file stores.
//
//  Classes:    CSeqQuery - container of table/query for a set of seq cursors
//
//  History:    09-Jan-95       DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tblalloc.hxx>
#include <rowseek.hxx>
#include <tblvarnt.hxx>

#include "tabledbg.hxx"
#include "seqquery.hxx"

//+---------------------------------------------------------------------------
//
//  Class:      CSeqQuery
//
//  Purpose:    Encapsulates a sequential query execution context, and PID
//              mapper for use by a row cursor.
//
//  Arguments:  [qopt]         - Query optimizer
//              [col]          - Initial set of columns to return
//              [pulCursors]   - cursor returned
//              [pidremap]     - prop ID mapping
//              [pDocStore]    - client doc store
//
//  History:    09 Jan 95       DwightKr    Created
//
//----------------------------------------------------------------------------

CSeqQuery::CSeqQuery( XQueryOptimizer & qopt,
                      XColumnSet & col,
                      ULONG *pulCursor,
                      XInterface<CPidRemapper> & pidremap,
                      ICiCDocStore *pDocStore
                    )
        : PQuery( ),
          _ref( 1 ),
          _pidremap( pidremap.Acquire() ),
          _QExec( 0 )
{
    //
    // Get ci manager and translator interfaces
    //
    ICiManager *pCiManager = 0;
    SCODE sc = pDocStore->GetContentIndex( &pCiManager );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support GetContentIndex interface" );

        THROW( CException( sc ) );
    }
    _xCiManager.Set( pCiManager );

    ICiCDocNameToWorkidTranslator *pNameToWidTranslator;
    sc = pDocStore->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                    (void **) &pNameToWidTranslator );
    if ( FAILED( sc ) )
    {
        Win4Assert( !"Need to support translator QI" );

        THROW( CException( sc ) );
    }
    _xNameToWidTranslator.Set( pNameToWidTranslator );

    _QExec.Set( new CQSeqExecute( qopt ) );
    *pulCursor = _CreateRowCursor();

    ciDebugOut(( DEB_USER1, "Using a sequential cursor.\n" ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::AddRef, public
//
//  Synopsis:   Reference the query.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
ULONG CSeqQuery::AddRef(void)
{
    return InterlockedIncrement( &_ref );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::Release, public
//
//  Synopsis:   De-Reference the query.
//
//  Effects:    If the ref count goes to 0 then the query is deleted.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
ULONG CSeqQuery::Release(void)
{
    long l = InterlockedDecrement( &_ref );
    if ( l <= 0 )
    {
        tbDebugOut(( DEB_ITRACE, "CSeqQuery unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::FetchDeferredValue
//
//  Synopsis:   Fetch value from property cache
//
//  Arguments:  [wid] -- Workid.
//              [ps]  -- Property to be fetched.
//              [var] -- Property returned here.
//
//  History:    Jun-1-95   KyleP   Created
//
//--------------------------------------------------------------------------

BOOL CSeqQuery::FetchDeferredValue( WORKID wid,
                                    CFullPropSpec const & ps,
                                    PROPVARIANT & var )
{
    return _QExec->FetchDeferredValue( wid, ps, var );
}

//
//  Methods supporting IRowset
//
//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::SetBindings, public
//
//  Synopsis:   Set column bindings into a cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to set bindings on
//              [cbRowLength] - the width of an output row
//              [cols] - a description of column bindings to be set
//              [pids] - a PID mapper which maps fake pids in cols to
//                      column IDs.
//
//  Returns:    nothing - failures are thrown.  E_FAIL
//                      is thrown if hCursor cannot be looked up,
//                      presumably an internal error.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQuery::SetBindings(
    ULONG             hCursor,
    ULONG             cbRowLength,
    CTableColumnSet & cols,
    CPidMapper &      pids )
{
    _VerifyHandle(hCursor);

    if (0 == cols.Count() ||
        0 == cbRowLength || cbRowLength >= USHRT_MAX)
        THROW( CException( E_INVALIDARG ));

    XPtr<CTableColumnSet> outset(new CTableColumnSet( cols.Count() ));

    for (unsigned iCol = 0; iCol < cols.Count(); iCol++)
    {
        CTableColumn * pCol = cols.Get( iCol );

        CFullPropSpec * propspec = pids.Get( pCol->PropId );

        //
        //  Convert the DBID to a PROPID
        //

//      Win4Assert( iCol+1 == pCol->PropId );   // Therefore pids is useless

        PROPID prop = _pidremap->NameToReal(propspec);

        if ( prop == pidInvalid )
            THROW( CException( DB_E_BADCOLUMNID ));

        if (pCol->IsCompressedCol())
            THROW( CException( E_INVALIDARG ));

        XPtr<CTableColumn> xpOutcol ( new CTableColumn( prop, pCol->GetStoredType() ) );

        if (pCol->IsValueStored())
            xpOutcol->SetValueField(pCol->GetStoredType(),
                                    pCol->GetValueOffset(),
                                    pCol->GetValueSize());

        Win4Assert( pCol->IsStatusStored() );
        xpOutcol->SetStatusField(pCol->GetStatusOffset(),
                                 (USHORT)pCol->GetStatusSize());

        if (pCol->IsLengthStored())
            xpOutcol->SetLengthField(pCol->GetLengthOffset(),
                                     (USHORT)pCol->GetLengthSize());

        outset->Add(xpOutcol, iCol);
    }

    SCODE sc = _cursor.SetBindings( cbRowLength, outset );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //SetBindings


//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator] - on return, numerator of fraction
//              [rcRows] - on return, number of rows in cursor
//              [rfNewRows] - on return, TRUE if new rows available
//
//  Returns:    nothing
//
//  Notes:      A value of 0 for hCursor is allowed so that completion
//              can be checked before a handle exists.
//
//--------------------------------------------------------------------------

void  CSeqQuery::RatioFinished(
                                ULONG   hCursor,
                                DBCOUNTITEM & rulDenominator,
                                DBCOUNTITEM & rulNumerator,
                                DBCOUNTITEM & rcRows,
                                BOOL &  rfNewRows
                               )
{
    if ( 0 != hCursor )
        _VerifyHandle(hCursor);

    rulDenominator = 1;
    rulNumerator   = 1;
    rcRows = 0;                 // we don't know how many there are...
    rfNewRows      = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQuery::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to fetch data for
//              [rSeekDesc] - row seek operation to be done before fetch
//              [rFetchParams] - row fetch parameters and buffer pointers
//
//  Returns:    SCODE - the status of the operation.  E_FAIL
//                      is thrown if hCursor cannot be looked up,
//                      presumably an internal error.
//
//  History:    19-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------
SCODE CSeqQuery::GetRows(
                         ULONG hCursor,
                         const CRowSeekDescription& rSeekDesc,
                         CGetRowsParams& rFetchParams,
                         XPtr<CRowSeekDescription>& pSeekDescOut
                        )
{
    _VerifyHandle( hCursor );

    if ( ! rSeekDesc.IsCurrentRowSeek() )
        THROW( CException( E_FAIL ) );

    CRowSeekNext* pRowSeek = (CRowSeekNext*) &rSeekDesc;

    unsigned cRowsToSkip = pRowSeek->GetSkip();
    _cursor.ValidateBindings();

    SCODE scRet = _QExec->GetRows( _cursor.GetBindings(),
                                   cRowsToSkip,
                                   rFetchParams );

    if (FAILED(scRet))
    {
        tbDebugOut(( DEB_WARN, "CSeqQuery::GetRows got sc=%x\n",
                           scRet ));
    }

    if (DB_S_BLOCKLIMITEDROWS == scRet)
        pSeekDescOut.Set( new CRowSeekNext(pRowSeek->GetChapter(), 0) );

    return scRet;
} //GetRows


//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::GetQueryStatus, public
//
//  Synopsis:   Return the query status
//
//  Arguments:  [hCursor] - the handle of the cursor to check completion for
//              [rdwStatus] - on return, the query status
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void        CSeqQuery::GetQueryStatus(
    ULONG           hCursor,
    DWORD &         rdwStatus)
{
    _VerifyHandle( hCursor );

    rdwStatus = _QExec->Status();
}

//+-------------------------------------------------------------------------
//
//  Member:     CSeqQuery::GetQueryStatusEx, public
//
//  Synopsis:   Return the query status plus bonus information.  It's kind
//              of an odd assortment of info, but it saves net trips.
//
//  Arguments:  [hCursor] - handle of the cursor to check completion for
//              [rdwStatus] - returns the query status
//              [rcFilteredDocuments] - returns # of filtered docs
//              [rcDocumentsToFilter] - returns # of docs to filter
//              [rdwRatioFinishedDenominator] - ratio finished denom
//              [rdwRatioFinishedNumerator]   - ratio finished num
//              [bmk]                         - bmk to find
//              [riRowBmk]                    - index of bmk row
//              [rcRowsTotal]                 - # of rows in table
//
//  History:    Nov-9-96   dlee    Created
//
//--------------------------------------------------------------------------

void CSeqQuery::GetQueryStatusEx(
     ULONG           hCursor,
     DWORD &         rdwStatus,
     DWORD &         rcFilteredDocuments,
     DWORD &         rcDocumentsToFilter,
     DBCOUNTITEM &   rdwRatioFinishedDenominator,
     DBCOUNTITEM &   rdwRatioFinishedNumerator,
     CI_TBL_BMK      bmk,
     DBCOUNTITEM &   riRowBmk,
     DBCOUNTITEM &   rcRowsTotal )
{
    GetQueryStatus( hCursor, rdwStatus );

    CIF_STATE state;
    state.cbStruct = sizeof state;
    SCODE sc = _xCiManager->GetStatus( &state );
    if ( SUCCEEDED( sc ) )
    {
        rcFilteredDocuments = state.cFilteredDocuments;
        rcDocumentsToFilter = state.cDocuments;
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CSeqQuery::GetQueryStatusEx, get status failed, 0x%x\n", sc ));

        rcFilteredDocuments = 0;
        rcDocumentsToFilter = 0;
    }

    // sequential query -- it's done

    rdwRatioFinishedDenominator = 1;
    rdwRatioFinishedNumerator = 1;

    // sequential query -- this info isn't available

    riRowBmk = 0;
    rcRowsTotal = 0;
} //GetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CAsyncQuery::WorkIdToPath
//
//  Synopsis:   Converts a wid to a path
//
//  Arguments:  [wid]       -- of the file to be translated
//              [funnyPath] -- resulting path
//
//  History:    Oct-5-96   dlee    Created
//
//--------------------------------------------------------------------------

void CSeqQuery::WorkIdToPath(
    WORKID          wid,
    CFunnyPath & funnyPath )
{
    ICiCDocName *pDocName;
    SCODE sc = _xNameToWidTranslator->QueryDocName( &pDocName );
    if ( SUCCEEDED( sc ) )
    {
        XInterface<ICiCDocName> xDocName( pDocName );

        sc = _xNameToWidTranslator->WorkIdToDocName( wid,
                                                     xDocName.GetPointer() );
        if ( SUCCEEDED( sc ) && sc != CI_S_WORKID_DELETED )
        {

            // PERFFIX: Here we are using two buffers XGrowable and
            // CFunnyPath.  This can be avoided if xDocName->Get can take
            // in CFunnyPath instead of WCHAR*

            XGrowable<WCHAR> xBuf(MAX_PATH);
            ULONG cb = xBuf.SizeOf();

            sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
            if ( CI_E_BUFFERTOOSMALL == sc )
            {
                xBuf.SetSizeInBytes( cb );
                sc = xDocName->Get( (BYTE *) xBuf.Get(), &cb );
            }

            if ( SUCCEEDED( sc ) )
                funnyPath.SetPath( xBuf.Get() );
        }
    }
} //WorkIdToPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\rowseek.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1994-1997, Microsoft Corporation.
//
//  File:       rowseek.cxx
//
//  Contents:   Classes which encapsulate a positioning operation
//              for a table.
//
//  Classes:    CRowSeekDescription
//              CRowSeekNext
//              CRowSeekAt
//              CRowSeekAtRatio
//              CRowSeekByBookmark
//
//  History:    06 Apr 1995     AlanW   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <sizeser.hxx>

#include "tabledbg.hxx"
#include "rowseek.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekDescription::MarshalledSize, public
//
//  Synopsis:   Return Serialized size of a CRowSeekDescription structure
//
//  Arguments:  - none -
//
//  Returns:    unsigned - size in bytes of serialized structure.
//
//  Notes:      The returned size should be the maximum of the serialized
//              size on input and output.  None of the seek descriptions
//              grow on output, so the input size may be larger than the
//              output size.
//
//  History:    02 May 1995     AlanW   Created
//
//----------------------------------------------------------------------------

unsigned
CRowSeekDescription::MarshalledSize(
) const {
    //
    //  Determine the size of the serialized seek description
    //
    CSizeSerStream stmSize;
    Marshall(stmSize);

    return stmSize.Size();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekDescription::MarshallBase, public
//
//  Synopsis:   Serialize the base CRowSeekDescription structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//              [eType] -- type descriminator for derived class
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void
CRowSeekDescription::MarshallBase(
    PSerStream & stm,
    DWORD eType
) const {
    stm.PutULong(eType);
    stm.PutULong(GetChapter());
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekNext::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekNext structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void
CRowSeekNext::Marshall(
    PSerStream & stm
) const {
    CRowSeekDescription::MarshallBase( stm, eRowSeekCurrent );
    stm.PutULong(GetSkip());
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAt::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekAt structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void
CRowSeekAt::Marshall(
    PSerStream & stm
) const {
    CRowSeekDescription::MarshallBase( stm, eRowSeekAt );

    stm.PutULong(Bmk());
    stm.PutLong(Offset());
    stm.PutULong(ULONG(_hRegion));
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAtRatio::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekAtRatio structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void CRowSeekAtRatio::Marshall( PSerStream & stm) const
{
    CRowSeekDescription::MarshallBase( stm, eRowSeekAtRatio );
    stm.PutULong(RatioNumerator());
    stm.PutULong(RatioDenominator());
    stm.PutULong(ULONG(_hRegion));
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::Marshall, public
//
//  Synopsis:   Serialize a CRowSeekByBookmark structure
//
//  Arguments:  [stm]  -- stream structure is serialized into
//
//  Returns:    nothing
//
//  Notes:      When serializing ByBookmarks, we only do bookmarks
//              or statuses, not both.  Only one must exist in the structure.
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

void CRowSeekByBookmark::Marshall(PSerStream & stm) const
{
    Win4Assert(_cBookmarks == 0 || _cValidRet == 0);

    CRowSeekDescription::MarshallBase( stm, eRowSeekByBookmark );

    stm.PutULong(_cBookmarks);
    for (unsigned i = 0; i < _cBookmarks; i++)
        stm.PutULong(_aBookmarks[i]);

    stm.PutULong(_cValidRet);
    for (i = 0; i < _cValidRet; i++)
        stm.PutULong(_ascRet[i]);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekNext::CRowSeekNext, public
//
//  Synopsis:   DeSerialize a CRowSeekNext structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//              [iVersion]  -- input stream version
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekNext::CRowSeekNext( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekCurrent, 0 )
{
    SetChapter( stm.GetULong() );
    SetSkip( stm.GetULong() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAt::CRowSeekAt, public
//
//  Synopsis:   DeSerialize a CRowSeekAt structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekAt::CRowSeekAt( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekAt, 0 )
{
    SetChapter( stm.GetULong() );
    _bmkOffset = stm.GetULong();
    _cRowsOffset = stm.GetLong();
    _hRegion = (HWATCHREGION) stm.GetULong();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekAtRatio::CRowSeekAtRatio, public
//
//  Synopsis:   DeSerialize a CRowSeekAtRatio structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekAtRatio::CRowSeekAtRatio( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekAtRatio, 0 )
{
    SetChapter( stm.GetULong() );
    _ulNumerator = stm.GetULong();
    _ulDenominator = stm.GetULong();
    _hRegion = (HWATCHREGION) stm.GetULong();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::CRowSeekByBookmark, public
//
//  Synopsis:   DeSerialize a CRowSeekByBookmark structure
//
//  Arguments:  [stm]  -- input stream structure is read from
//
//  Returns:    nothing
//
//  History:    06 Apr 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekByBookmark::CRowSeekByBookmark( PDeSerStream & stm, int iVersion ) :
    CRowSeekDescription( eRowSeekByBookmark, 0 ),
    _aBookmarks( 0 ),
    _ascRet( 0 )
{
    SetChapter( stm.GetULong() );

    _cBookmarks = stm.GetULong();
    if (_cBookmarks)
    {
        // Protect agains unreasonable requests, which probably are attacks

        if ( _cBookmarks >= 65536 )
            THROW( CException( E_INVALIDARG ) );

        _aBookmarks = new CI_TBL_BMK [ _cBookmarks ];

        for (unsigned i = 0; i < _cBookmarks; i++)
            _aBookmarks[i] = stm.GetULong();
    }

    _maxRet = _cValidRet = stm.GetULong();

    if (_cValidRet)
    {
        // Protect against unreasonable requests, which probably are attacks

        if ( _cValidRet >= 65536 )
            THROW( CException( E_INVALIDARG ) );

        _ascRet = new SCODE [ _cValidRet ];

        for (unsigned i = 0; i < _cValidRet; i++)
            _ascRet[i] = stm.GetULong();
    }

    //
    // We don't expect both bookmarks and statuses.
    //
    Win4Assert(_cBookmarks == 0 || _cValidRet == 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::~CRowSeekByBookmark, public
//
//  Synopsis:   Destroy a CRowSeekByBookmark structure
//
//  Returns:    nothing
//
//  History:    29 Jan 1995     AlanW   Created
//
//----------------------------------------------------------------------------

CRowSeekByBookmark::~CRowSeekByBookmark( )
{
    delete _aBookmarks;
    delete _ascRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekNext::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekNext::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    LONG cRowsToSkip = GetSkip();

    if (cRowsToSkip)
    {
        tbDebugOut(( DEB_IWARN, "CRowSeekNext::GetRows - non-zero skip count %d\n",
                            cRowsToSkip ));
    }

    WORKID widStart;
    if ( rTable.IsFirstGetNextRows() )
    {
        //
        // For the first GetNextRows call, the start position is
        // beginning of table if cRowsToSkip is positive, and end
        // of table if its negative. For subsequent calls, the
        // current position is the start position.
        //

        if ( cRowsToSkip >= 0 )
            widStart = WORKID_TBLBEFOREFIRST;
        else
            widStart = WORKID_TBLAFTERLAST;
    }
    else
        widStart = rTable.GetCurrentPosition( GetChapter() );

    WORKID widEnd = widStart;

    //
    // OffsetSameDirFetch implements the skip of one row that
    // Oledb::GetNextRows requires on the first fetch
    // when scrolling and fetching are in the same direction,
    // and for subsequent fetches when the fetch is in the
    // same direction as previous fetch. When the direction is
    // reversed the first wid fetched is same as the last wid
    // returned from the previous call, and offsetSameDirFetch
    // is 0 in this case.
    //
    LONG offsetSameDirFetch = 0;
    if ( rTable.IsFirstGetNextRows() )
    {
        if ( cRowsToSkip >= 0 && rFetchParams.GetFwdFetch() )
            offsetSameDirFetch = 1;
        else if ( cRowsToSkip < 0 && !rFetchParams.GetFwdFetch() )
            offsetSameDirFetch = -1;
    }
    else
    {
        if ( rFetchParams.GetFwdFetch() == rTable.GetFwdFetchPrev() )
        {
            if ( rFetchParams.GetFwdFetch() )
                offsetSameDirFetch = 1;
            else
                offsetSameDirFetch = -1;
        }
    }

    SCODE scRet = rTable.GetRowsAt( 0,  // no watch region
                                    widStart,
                                    GetChapter(),
                                    cRowsToSkip + offsetSameDirFetch,
                                    rCursor.GetBindings(),
                                    rFetchParams,
                                    widEnd );

    //
    //  Don't attempt to save the widEnd if the positioning
    //  operation got us past the end of the table.  Storing
    //  widEnd in rCursor will cause us to be stuck at the
    //  end, with no way to get any more rows.  In this situation,
    //  we don't expect to have successfully transferred any rows.
    //
    // NOTE: don't throw, the error may need to be seen by caller
    //      in CRowset::_FetchRows
    //
    if ( WORKID_TBLAFTERLAST == widEnd ||
         WORKID_TBLBEFOREFIRST == widEnd ||
         ( scRet == DB_E_BADSTARTPOSITION && cRowsToSkip == 0 ) )
    {
        Win4Assert(rFetchParams.RowsTransferred() == 0);
        return DB_S_ENDOFROWSET;
    }

    if (SUCCEEDED(scRet))
    {
        rTable.SetCurrentPosition( GetChapter(), widEnd );
        rTable.SetFwdFetchPrev( rFetchParams.GetFwdFetch() );
        rTable.ResetFirstGetNextRows();
    }
    else
    {
        tbDebugOut(( DEB_WARN, "CRowSeekNext::GetRows failed, sc=%x\n",
                               scRet ));
    }


    if (DB_S_BLOCKLIMITEDROWS == scRet)
    {
        Win4Assert(rFetchParams.RowsTransferred() > 0);
        pSeekDescOut.Set(new CRowSeekNext(GetChapter(), 0) );
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekAt::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekAt::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    WORKID widStart = Bmk();
    LONG iRowOffset = Offset();

    SCODE scRet = rTable.GetRowsAt( _hRegion,
                                    widStart,
                                    GetChapter(),
                                    iRowOffset,
                                    rCursor.GetBindings(),
                                    rFetchParams,
                                    widStart );

    // The first fetch took care of the hRegion manipulation
    // set the new seek descriptor's hRegion to 0
    if (DB_S_BLOCKLIMITEDROWS == scRet)
    {
        Win4Assert(rFetchParams.RowsTransferred() > 0);
        pSeekDescOut.Set(new CRowSeekAt(0,
                                        GetChapter(),
                                        rFetchParams.GetFwdFetch() ? 1 : -1,
                                        widStart) );
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekAtRatio::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekAtRatio::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    WORKID widRestart = widInvalid;
    SCODE scRet = rTable.GetRowsAtRatio( _hRegion,
                                         RatioNumerator(),
                                         RatioDenominator(),
                                         GetChapter(),
                                         rCursor.GetBindings(),
                                         rFetchParams,
                                         widRestart );

    // The first fetch took care of the hRegion manipulation
    // set the new seek descriptor's hRegion to 0
    if (DB_S_BLOCKLIMITEDROWS == scRet)
    {
        Win4Assert(rFetchParams.RowsTransferred() > 0);
        pSeekDescOut.Set(new CRowSeekAt(0, GetChapter(), 1, widRestart) );
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [rCursor] - the cursor to fetch data for
//              [rTable] - the table from which data is fetched
//              [rFetchParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - pointer to seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//
//  History:    07 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

SCODE
CRowSeekByBookmark::GetRows(
    CTableCursor& rCursor,
    CTableSource& rTable,
    CGetRowsParams& rFetchParams,
    XPtr<CRowSeekDescription>& pSeekDescOut) const
{
    unsigned cFailed = 0;
    ULONG cSavedRowsReq = rFetchParams.RowsToTransfer();

    Win4Assert(_cBookmarks > 0);
    Win4Assert(cSavedRowsReq <= _cBookmarks);
    Win4Assert(0 == rFetchParams.RowsTransferred() && cSavedRowsReq > 0);

    rFetchParams.SetRowsRequested(0);

    SCODE scRet = S_OK;

    TRY
    {
        XPtr<CRowSeekByBookmark> pSeekOut(
                    new CRowSeekByBookmark(GetChapter(), _cBookmarks) );

        BOOL fFailed = FALSE;
        // Iterate over bookmarks, calling rTable.GetRowsAt for each
        for (unsigned i = 0; i < cSavedRowsReq; i++)
        {
            if (! fFailed)
                rFetchParams.IncrementRowsRequested( );

            WORKID widNext = _aBookmarks[i];
            if (widNext == widInvalid)
            {
                scRet = DB_E_BADBOOKMARK;
            }
            else
            {
                TRY
                {
                    scRet = rTable.GetRowsAt( 0,   // no watch region
                                              widNext,
                                              GetChapter(),
                                              0,
                                              rCursor.GetBindings(),
                                              rFetchParams,
                                              widNext );
                }
                CATCH( CException, e )
                {
                    scRet = e.GetErrorCode();
                    Win4Assert( scRet != STATUS_ACCESS_VIOLATION &&
                                scRet != STATUS_NO_MEMORY );
                }
                END_CATCH;

                if (! SUCCEEDED(scRet) && scRet != STATUS_BUFFER_TOO_SMALL )
                    scRet = DB_E_BOOKMARKSKIPPED;
            }

            if (scRet == DB_S_ENDOFROWSET)
                scRet = S_OK;

            if ( STATUS_BUFFER_TOO_SMALL == scRet ||
                 DB_S_BLOCKLIMITEDROWS == scRet )
            {
                scRet = DB_S_BLOCKLIMITEDROWS;
                break;
            }

            //
            // set per-row error status
            //
            pSeekOut->_SetStatus(i, scRet);
            if (FAILED(scRet))
            {
                cFailed++;
                fFailed = TRUE;
            }
            else
                fFailed = FALSE;
        }
        pSeekDescOut.Set( pSeekOut.Acquire() );
    }
    CATCH( CException, e )
    {
        scRet = e.GetErrorCode();
    }
    END_CATCH;

    if (cFailed)
        return DB_S_ERRORSOCCURRED;
    else if (0 == rFetchParams.RowsTransferred())
        return STATUS_BUFFER_TOO_SMALL;
    else
        return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::_SetStatus, private
//
//  Synopsis:   Set row status for a bookmark lookup
//
//  Arguments:  [iBmk] - index of bookmark to set status for
//              [scRet] - the status to be saved
//
//  Returns:    Nothing
//
//  History:    12 Apr 1995     Alanw   Created
//
//--------------------------------------------------------------------------

void
CRowSeekByBookmark::_SetStatus(
    unsigned    iBmk,
    SCODE       scRet
) {
    Win4Assert( iBmk < _maxRet );

    if (_ascRet == 0)
        _ascRet = new SCODE[_maxRet];

    _ascRet[iBmk] = scRet;
    if (iBmk >= _cValidRet)
    {
        Win4Assert( iBmk == _cValidRet );
        _cValidRet = iBmk + 1;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekDescription::MergeResults, public
//
//  Synopsis:   Update seek description state after a transfer
//
//  Arguments:  [pRowSeek] - row seek description after transfer
//
//  Returns:    Nothing
//
//  Notes:      Used only in user mode.  Does nothing for CRowSeekNext,
//              CRowSeekAt and CRowSeekAtRatio.
//
//  History:    02 May 1995     Alanw   Created
//
//--------------------------------------------------------------------------

void
CRowSeekDescription::MergeResults(
    CRowSeekDescription * pRowSeek )
{
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowSeekByBookmark::MergeResults, public
//
//  Synopsis:   Update seek description state after a transfer
//
//  Arguments:  [pRowSeek] - row seek description after transfer
//
//  Returns:    Nothing
//
//  Notes:      Used only in user mode.  Transfers statuses into
//              original rowseek and bookmarks from original to
//              result rowseek.
//
//  History:    02 May 1995     Alanw   Created
//
//--------------------------------------------------------------------------

void
CRowSeekByBookmark::MergeResults(
    CRowSeekDescription * pRowSeekDesc)
{
    Win4Assert(pRowSeekDesc->IsByBmkRowSeek());

    CRowSeekByBookmark* pRowSeek = (CRowSeekByBookmark*) pRowSeekDesc;

    Win4Assert(_cBookmarks > 0 &&
               pRowSeek->_cValidRet > 0 && pRowSeek->_cBookmarks == 0);

    //
    // Transfer return statuses to this object from the other
    //
    unsigned iBaseRet = _cValidRet;

    for (unsigned i=0; i < pRowSeek->_cValidRet; i++)
    {
        _SetStatus( i+iBaseRet, pRowSeek->_ascRet[i] );
    }

    delete [] pRowSeek->_ascRet;
    pRowSeek->_ascRet = 0;
    pRowSeek->_cValidRet = pRowSeek->_maxRet = 0;

    //
    //  Transfer bookmarks from this object to the other.
    //
    if (_cBookmarks - _cValidRet > 0)
    {
        pRowSeek->_cBookmarks = _cBookmarks - _cValidRet;
        pRowSeek->_aBookmarks = new CI_TBL_BMK[ pRowSeek->_cBookmarks ];

        for (unsigned i=0; i<pRowSeek->_cBookmarks; i++)
        {
            pRowSeek->_aBookmarks[i] = _aBookmarks[ i+_cValidRet ];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\seqexec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
// File:        SeqExec.cxx
//
// Contents:    Sequential Query execution class
//
// Classes:     CQSeqExecute
//
// History:     22-Jan-95       DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>

#include "seqexec.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::CQSeqExecute, public
//
//  Synopsis:   Start a query
//
//  Arguments:  [qopt]  -- Query optimizer
//
//  History:    20-Jan-95   DwightKr    Created
//
//----------------------------------------------------------------------------

CQSeqExecute::CQSeqExecute( XQueryOptimizer & xOpt )
    : _status(STAT_BUSY),
      _fCursorOnNewObject( TRUE ),
      _fAbort( FALSE ),
      _TimeLimit( xOpt->GetTimeLimit() ),
      _cRowsToReturnMax( xOpt->MaxResults() ),
      _xOpt( xOpt )
{
    Win4Assert( !_xOpt->IsMultiCursor() && _xOpt->IsFullySorted() );

    if ( 0 != _xOpt->FirstRows() )
        _cRowsToReturnMax = _xOpt->FirstRows();

    if (_cRowsToReturnMax == 0)
        _cRowsToReturnMax = 0xFFFFFFFF;

    TRY
    {
        _objs.Set( _xOpt->QueryNextCursor( _status, _fAbort ) );
    }
    CATCH(CException, e)
    {
        if ( e.GetErrorCode() == QUERY_E_TIMEDOUT )
        {
            //
            // Execution time limit has been exceeded, not a catastrophic error
            //
            _status = ( STAT_DONE |
                        QUERY_RELIABILITY_STATUS( Status() ) |
                        STAT_TIME_LIMIT_EXCEEDED );

            //
            // Update local copy of execution time
            //
            _TimeLimit.SetExecutionTime( 0 );
        }
        else
            RETHROW();
    }
    END_CATCH

    if ( !_objs.IsNull() )
    {
        _objs->Quiesce();
        _objs->SwapOutWorker();
    }
} //CQSeqExecute

//+---------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::GetRows, public
//
//  Synopsis:   Get the next set of rows from a query
//
//  History:    20-Jan-95   DwightKr    Created.
//
//----------------------------------------------------------------------------

SCODE CQSeqExecute::GetRows( CTableColumnSet const & OutColumns,
                             unsigned &cRowsToSkip,
                             CGetRowsParams & GetParams )
{
    if ( _TimeLimit.IsTimedOut() )
        return DB_S_STOPLIMITREACHED;

    if ( ( STAT_DONE == QUERY_FILL_STATUS( _status ) ) ||
         _objs.IsNull() )
        return DB_S_ENDOFROWSET;

    _TimeLimit.SetBaselineTime( );
    SCODE scResult = S_OK;

    TRY
    {
        //
        // If this is not the first call to GetRows, then advance to the
        // next object.  We've already seen the current object.
        //

        if ( !_fCursorOnNewObject )
            _objs->NextWorkId();

        //
        //  Skip the # of rows specified
        //

        for ( WORKID widEnd = _objs->WorkId();
              cRowsToSkip > 0 && widEnd != widInvalid;
              widEnd = _objs->NextWorkId() )
        {
            cRowsToSkip--;

            if (_cRowsToReturnMax == 0)
            {
                vqDebugOut(( DEB_IWARN,
                             "Query row limit exceeded for %08x\n",
                             this ));

                scResult = DB_S_ENDOFROWSET;
                widEnd = widInvalid;
                break;
            }
            _cRowsToReturnMax--;

            if ( CheckExecutionTime() )
            {
                scResult = DB_S_STOPLIMITREACHED;
                widEnd = widInvalid;
                break;
            }
        }

        //
        //  Get the # of rows requested
        //

        BYTE * pbBuf = 0;

        while ( widEnd != widInvalid )
        {
            if ( _cRowsToReturnMax == 0 )
            {
                vqDebugOut(( DEB_IWARN,
                             "Query row limit exceeded for %08x\n",
                             this ));

                scResult = DB_S_ENDOFROWSET;
                break;
            }
            if ( ( 0 == ( GetParams.RowsTransferred() % 5 ) ) &&
                 ( CheckExecutionTime() ) )
            {
                scResult = DB_S_STOPLIMITREACHED;
                break;
            }

            if ( 0 == pbBuf )
                pbBuf = (BYTE *) GetParams.GetFixedVarAllocator().AllocFixed();

            scResult = GetRowInfo( OutColumns, GetParams, pbBuf );

            //
            //  If object is deleted, just skip to the next one and re-use
            //  the row buffer space from the GetParam's allocator.
            //

            if (scResult == S_OK)
            {
                // fetched a row -- record that fact

                GetParams.IncrementRowCount();
                Win4Assert(_cRowsToReturnMax != 0);
                _cRowsToReturnMax--;
                pbBuf = 0;
            }
            else
            {
                if ( scResult == STATUS_FILE_DELETED )
                    scResult = S_OK;
                else
                    break;
            }

            // Do we need to get another?

            if ( 0 == GetParams.RowsToTransfer() )
                break;

            widEnd = _objs->NextWorkId();
        }

        if ( widEnd == widInvalid )
        {
            scResult = cRowsToSkip ? DB_E_BADSTARTPOSITION : DB_S_ENDOFROWSET;
            _status = STAT_DONE | QUERY_RELIABILITY_STATUS(_status);
        }
    }
    CATCH( CException, e )
    {
        _fCursorOnNewObject = TRUE;

        //
        //  A common error returned here is E_OUTOFMEMORY.  This needs
        //  to be translated and passed back to the caller to be
        //  handled appropriately.  It is a non-fatal error.
        //

        if ( STATUS_BUFFER_TOO_SMALL == e.GetErrorCode() )
        {
            if ( GetParams.RowsTransferred() > 0 )
                scResult = DB_S_BLOCKLIMITEDROWS;
            else
                scResult = STATUS_BUFFER_TOO_SMALL;
        }
        else if ( QUERY_E_TIMEDOUT == e.GetErrorCode() )
        {
            //
            // Execution time limit has been exceeded, not a catastrophic error
            //
            _status = ( STAT_DONE |
                        QUERY_RELIABILITY_STATUS( Status() ) |
                        STAT_TIME_LIMIT_EXCEEDED );
            scResult = DB_S_STOPLIMITREACHED;

            //
            // Update local copy of execution time
            //
            _TimeLimit.SetExecutionTime( 0 );
        }
        else
        {
            vqDebugOut(( DEB_ERROR,
                         "Exception 0x%x caught in CQSeqExecute::GetRows\n",
                         e.GetErrorCode() ));

            scResult = e.GetErrorCode();
        }
    }
    END_CATCH

    _objs->Quiesce();

    _objs->SwapOutWorker();

    if ( S_OK == scResult )
        _fCursorOnNewObject = FALSE;

    return scResult;
} //GetRows

//+---------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::GetRowInfo, private
//
//  Synopsis:   Get the next row from a query without advancing the cursor
//
//  History:    20-Jan-95   DwightKr    Created.
//
//----------------------------------------------------------------------------
SCODE CQSeqExecute::GetRowInfo(
    CTableColumnSet const & OutColumns,
    CGetRowsParams &        GetParams,
    BYTE *                  pbBuf )
{
    SCODE scResult = S_OK;

    //
    //  Get the current row from the cursor
    //

    Win4Assert( !_objs.IsNull() );
    CRetriever & obj = _objs.GetReference();

    //
    //  Transfer each of the columns to the output buffer
    //
    for ( unsigned iColumn=0;
          iColumn < OutColumns.Size();
          iColumn++ )
    {
        CTableColumn & rColumn = *OutColumns.Get(iColumn);

        Win4Assert( VT_EMPTY != rColumn.GetStoredType() );

        ULONG cbBuf = sizeof _abValueBuf;
        CTableVariant* pVarnt = (CTableVariant *) &_abValueBuf;
        RtlZeroMemory( pVarnt, sizeof CTableVariant );

        GetValueResult eGvr = obj.GetPropertyValue( rColumn.PropId,
                                                    pVarnt,
                                                    &cbBuf );

        CTableColumn::StoreStatus stat = CTableColumn::StoreStatusOK;
        XPtr<CTableVariant> sVarnt(0);

        // Really large values must be deferred in cisvc due to the limit on
        // the size of named pipe buffers.
    
        if ( ( GVRNotEnoughSpace == eGvr ) &&
             ( cbBuf <= cbMaxNonDeferredValueSize ) )
        {
            sVarnt.Set( (CTableVariant *) new BYTE[cbBuf] ); // Smart pointer
            pVarnt = sVarnt.GetPointer();
            eGvr = obj.GetPropertyValue( rColumn.PropId, pVarnt, &cbBuf );
        }
    
        if ( GVRSuccess != eGvr )
        {
            if ( GVRNotAvailable == eGvr )
            {
                pVarnt->vt = VT_EMPTY;
                stat = CTableColumn::StoreStatusNull;
            }
            else if ( GVRSharingViolation == eGvr )
            {
                pVarnt->vt = VT_EMPTY;
                stat = CTableColumn::StoreStatusNull;
    
                // don't set this until it's implemented everywhere
                //_status |= STAT_SHARING_VIOLATION;
            }
            else if ( GVRNotEnoughSpace == eGvr )
            {
                stat = CTableColumn::StoreStatusDeferred;
            }
        }

        if ( rColumn.IsLengthStored() )
            rColumn.SetLength( pbBuf, cbBuf );

        Win4Assert( rColumn.IsValueStored() );

        if ( ( GVRSuccess == eGvr ) ||
             ( GVRNotAvailable == eGvr ) ||
             ( GVRSharingViolation == eGvr ) )
        {
            BYTE *pRowColDataBuf = pbBuf + rColumn.GetValueOffset();
            DBLENGTH ulTemp;

            DBSTATUS dbStatus = pVarnt->CopyOrCoerce(
                                          pRowColDataBuf,
                                          rColumn.GetValueSize(),
                                          rColumn.GetStoredType(),
                                          ulTemp,
                                          GetParams.GetVarAllocator() );

            if ( DBSTATUS_S_OK != dbStatus )
            {
                vqDebugOut(( DEB_ITRACE,
                             "Sequential query column 0x%x copy failed "
                             "srcvt 0x%x, workid 0x%x, dbstat 0x%x\n",
                             iColumn,
                             pVarnt->vt,
                             _objs->WorkId(),
                             dbStatus ));

                stat = CTableColumn::StoreStatusNull;
            }
        }
        else if ( GVRNotEnoughSpace != eGvr ) // deferred
        {
            vqDebugOut(( DEB_WARN,
                         "Sequential fetch of property for row (wid = 0x%x) failed %d\n",
                         _objs->WorkId(), eGvr ));
            scResult = E_FAIL;
            break;
        }

        Win4Assert( rColumn.IsStatusStored() );
        rColumn.SetStatus( pbBuf, stat );
    }

    return scResult;
} //GetRowInfo

//+-------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::CheckExecutionTime, private
//
//  Synopsis:   Check for CPU time limit exceeded
//
//  Arguments:  NONE
//
//  Returns:    TRUE if execution time limit exceeded.
//
//  Notes:      The CPU time spent executing a query since the last
//              check is computed and compared with the remaining time
//              in the CPU time limit.  If the time limit is exceeded,
//              the query is aborted and a status bit is set indicating
//              that.  Otherwise, the remaining time and the input time
//              snapshots are updated.
//
//  History:    08 Apr 96    AlanW        Created
//
//--------------------------------------------------------------------------

BOOL CQSeqExecute::CheckExecutionTime( void )
{
    if ( _TimeLimit.CheckExecutionTime() )
    {
        vqDebugOut(( DEB_IWARN,
                     "Execution time limit exceeded for %08x\n",
                     this ));

        _status = ( STAT_DONE |
                    QUERY_RELIABILITY_STATUS( Status() ) |
                    STAT_TIME_LIMIT_EXCEEDED );

        return TRUE;
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CQSeqExecute::FetchDeferredValue
//
//  Synopsis:   Checks if read access is permitted
//
//  Arguments:  [wid] - Workid
//              [ps]  -- Property to be fetched
//              [var] -- Property returned here
//
//  History:    12-Jan-97    SitaramR        Created
//
//--------------------------------------------------------------------------

BOOL CQSeqExecute::FetchDeferredValue( WORKID wid,
                                       CFullPropSpec const & ps,
                                       PROPVARIANT & var )
{
    return _xOpt->FetchDeferredValue( wid, ps, var );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\rowset.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       rowset.cxx
//
//  Contents:   OLE DB IRowset implementation for file stores.
//              Runs entirely in user space at the client machine.
//
//  Classes:    CRowset
//
//  History:    07 Nov 94       AlanW      Created
//              07 May 97       KrishnaN   Added Ole-DB error support
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <initguid.h>       // needed for IServiceProperties
#include <rowset.hxx>
#include <query.hxx>
#include <rownotfy.hxx>
#include <tgrow.hxx>

#include "tabledbg.hxx"

const unsigned MAX_ROW_FETCH = 1000;

inline DBROWSTATUS ScodeToRowstatus( SCODE sc )
{
    switch (sc)
    {
    case S_OK:
        return DBROWSTATUS_S_OK;

    case E_INVALIDARG:
    case DB_E_BADBOOKMARK:
        return DBROWSTATUS_E_INVALID;

    case E_OUTOFMEMORY:
        return DBROWSTATUS_E_OUTOFMEMORY;

    default:
        tbDebugOut(( DEB_ERROR, "ScodeToRowStatus: missing conversion for %x\n", sc ));
        Win4Assert( FAILED( sc ) );
        return DBROWSTATUS_E_INVALID;
    }
}

// Rowset object Interfaces that support Ole DB error objects
static const IID * apRowsetErrorIFs[] =
{
        &IID_IAccessor,
        &IID_IChapteredRowset,
        &IID_IColumnsInfo,
        &IID_IColumnsRowset,
        &IID_IConnectionPointContainer,
        &IID_IConvertType,
        &IID_IDBAsynchStatus,
        &IID_IRowset,
        //&IID_IRowsetAsynch,
        &IID_IRowsetIdentity,
        &IID_IRowsetInfo,
        &IID_IRowsetLocate,
        &IID_IRowsetQueryStatus,
        //&IID_IRowsetResynch,
        &IID_IRowsetScroll,
        //&IID_IRowsetUpdate,
        &IID_IRowsetWatchAll,
        &IID_IRowsetWatchRegion,
        //&IID_ISupportErrorInfo,
        &IID_IServiceProperties,
};

static const ULONG cRowsetErrorIFs  = sizeof(apRowsetErrorIFs)/sizeof(apRowsetErrorIFs[0]);

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::CRowset, public
//
//  Synopsis:   Creates a locally accessible Table
//
//  Arguments:  [pUnkOuter] - Outer unknown
//              [ppMyUnk] - OUT:  filled in with pointer to non-delegated
//                          IUnknown on return
//              [cols]    - A reference to the output column set
//              [pidmap]  - a pid mapper for column IDs and names in cols
//              [rQuery]  - A reference to an instantiated query
//              [rControllingQuery] - OLE controlling unknown (IQuery)
//              [fIsCategorized]  - TRUE if not the highest-level rowset
//              [xProps]  - Rowset properties, indicates special semantics,
//                          such as sequential cursor, use CI for prop
//                          queries.
//              [hCursor] - table cursor handle.
//              [aAccessors]   -- Bag of accessors which rowsets need to inherit
//
//  Notes:      Ownership of the output column set may be transferred to
//              the table cursor.
//
//----------------------------------------------------------------------------

CRowset::CRowset(
    IUnknown *            pUnkOuter,
    IUnknown **           ppMyUnk,
    CColumnSet const &    cols,
    CPidMapperWithNames   const & pidmap,
    PQuery &              rQuery,
    IUnknown &            rControllingQuery,
    BOOL                  fIsCategorized,
    XPtr<CMRowsetProps> & xProps,
    ULONG                 hCursor,
    CAccessorBag &        aAccessors,
    IUnknown *            pUnkCreator )
        :_rQuery( rQuery ),
         _xProperties( xProps.Acquire() ),
         _hCursor( hCursor ),
         _pRowBufs(0),
         _pConnectionPointContainer( 0 ),
         _pRowsetNotification( 0 ),
         _pAsynchNotification( 0 ),
         _fForwardOnly( (_xProperties->GetPropertyFlags() & eLocatable) == 0),
#pragma warning(disable : 4355) // 'this' in a constructor
         _ColumnsInfo( cols,
                       pidmap,
                       _DBErrorObj,
                       * ((IUnknown *) (IRowsetScroll *) this),
                       _fForwardOnly ),
         _aAccessors( (IUnknown *) (IRowset *)this ),
         _DBErrorObj( * ((IUnknown *) (IRowset *) this), _mutex ),
         _impIUnknown(rControllingQuery, this),
#pragma warning(default : 4355)    // 'this' in a constructor
         _PropInfo(),
         _fIsCategorized( fIsCategorized ),
         _fExtendedTypes( (_xProperties->GetPropertyFlags() & eExtendedTypes) != 0 ),
         _fHoldRows( (_xProperties->GetPropertyFlags() & eHoldRows) != 0 ),
         _fAsynchronous( (_xProperties->GetPropertyFlags() & eAsynchronous) != 0),
         _pRelatedRowset( 0 ),
         _pChapterRowbufs( 0 )
{
    Win4Assert(_hCursor != 0);
    if (_hCursor == 0)
        THROW(CException(E_NOINTERFACE));

    if (pUnkOuter)
        _pControllingUnknown = pUnkOuter;
    else
        _pControllingUnknown = (IUnknown * )&_impIUnknown;

    _DBErrorObj.SetInterfaceArray(cRowsetErrorIFs, apRowsetErrorIFs);

    ULONG obRowRefcount, obRowWorkId;
    ULONG obChaptRefcount, obChaptId;
    _ColumnsInfo.SetColumnBindings( rQuery, _hCursor,
                                    obRowRefcount, obRowWorkId,
                                    obChaptRefcount, obChaptId );

    //
    // GetBindings for each accessor in bag, and use them to create accessor
    // in IRowset
    //
    // only CAccessors can be used by commands

    CAccessorBase * pAccBase = (CAccessorBase *)aAccessors.First();
    while ( 0 != pAccBase )
    {
        DBCOUNTITEM cBindings;
        DBBINDING * rgBindings;
        DBACCESSORFLAGS dwAccessorFlags;
        SCODE sc = pAccBase->GetBindings( &dwAccessorFlags, &cBindings, &rgBindings);

        if ( FAILED( sc ) )
            THROW( CException( sc ) );
  
        HACCESSOR hAccessor;
        sc = CreateAccessor(dwAccessorFlags, cBindings, rgBindings, 0, &hAccessor, 0);
        CoTaskMemFree(rgBindings); //cleanup from GetBindings
        if (FAILED(sc))
            THROW( CException( sc ) );
  
        //
        // inherited accessors are accessed through same hAccessor as original.
        // Set parent of newly created accessor so that we can link the 2 copies.
        // Client never knows the direct HACESSOR for the inherited accessor.
        // All accessor methods check bag for an accessor with a match on
        // the parent or the creator.
        //
        ((CAccessorBase *)hAccessor)->SetParent(pAccBase);
  
        //
        // Increment inheritor count for parent accessor
        //
        pAccBase->IncInheritors();
  
        pAccBase = (CAccessor *)aAccessors.Next();
    }

    _pRowBufs = new CRowBufferSet( _fForwardOnly,
                                   obRowRefcount,
                                   obRowWorkId,
                                   obChaptRefcount,
                                   obChaptId );

    *ppMyUnk = ((IUnknown *)&_impIUnknown);

    // can't fail after this or _pRowBufs will leak

    (*ppMyUnk)->AddRef();
    rQuery.AddRef();

    if ( 0 != pUnkCreator )
    {
        _xUnkCreator.Set( pUnkCreator );        
        _xUnkCreator->AddRef();
    }

} //CRowset


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::~CRowset, public
//
//  Synopsis:   Destroy the rowset and its component objects
//
//----------------------------------------------------------------------------

CRowset::~CRowset()
{
    Win4Assert( _impIUnknown._ref == 0 );
    Win4Assert( _hCursor != 0 );

    delete _pRowBufs;

    // free cursor will fail if the pipe is broken

    TRY
    {
        if ( !_pRowsetNotification.IsNull() )
            _pRowsetNotification->OnRowsetChange( this,
                                                  DBREASON_ROWSET_RELEASE,
                                                  DBEVENTPHASE_DIDEVENT,
                                                  TRUE);
        _rQuery.FreeCursor( _hCursor );
    }
    CATCH( CException, e )
    {
    }
    END_CATCH;

    if ( !_pRowsetNotification.IsNull() )
        _pRowsetNotification->StopNotifications();
    delete _pConnectionPointContainer;

    _rQuery.Release();
} //~CRowset

//+-------------------------------------------------------------------------
//
//  Member:     CRowset::RealQueryInterface, public
//
//  Synopsis:   Get a reference to another interface on the cursor
//
//  Notes:      ref count is incremented inside QueryInterface
//
//--------------------------------------------------------------------------

SCODE CRowset::RealQueryInterface(
    REFIID ifid,
    void * *ppiuk )
{
    SCODE sc = S_OK;

    *ppiuk = 0;

    // note -- IID_IUnknown covered in QueryInterface

    if ( IID_IRowset == ifid )
    {
        *ppiuk = (void *) (IRowset *) this;
    }
    else if ( IID_IAccessor == ifid )
    {
        *ppiuk = (void *) (IAccessor *) this;
    }
    else if ( IID_IRowsetInfo == ifid )
    {
        *ppiuk = (void *) (IRowsetInfo *) this;
    }
    else if ( IID_IColumnsInfo == ifid )
    {
        *ppiuk = (void *) (IColumnsInfo *) &_ColumnsInfo;
    }
    else if (IID_ISupportErrorInfo == ifid)
    {
        *ppiuk = (void *) ((IUnknown *) (ISupportErrorInfo *) &_DBErrorObj);
    }
    else if ( IID_IConvertType == ifid )
    {
        *ppiuk = (void *) (IConvertType *) this;
    }
#if 0   // NEWFEATURE - not implemented now.
    else if ( IID_IColumnsRowset == ifid )
    {
        *ppiuk = (void *) (IColumnsRowset *) &_ColumnsInfo;
    }
#endif // 0     // NEWFEATURE - not implemented now.
    else if ( IID_IRowsetQueryStatus == ifid )
    {
        *ppiuk = (void *) (IRowsetQueryStatus *) this;
    }
    else if ( IID_IServiceProperties == ifid )
    {
        *ppiuk = (void *) (IServiceProperties *) this;
    }
    else if ( IID_IConnectionPointContainer == ifid )
    {
        // Watch notifications are only supported over the
        // bottom-most of a hierarchical rowset (the one with real rows)

        BOOL fWatchable = ! _pRowBufs->IsChaptered() &&
                          (_xProperties->GetPropertyFlags() & eWatchable) != 0;

        if ( 0 == _pConnectionPointContainer )
        {
            TRY
            {
                XPtr<CConnectionPointContainer> xCPC(
                    new CConnectionPointContainer(
                        _fAsynchronous ? 3 : 1,
                        * ((IUnknown *) (IRowsetScroll *) this),
                        _DBErrorObj) );

                if (_fAsynchronous)
                {
                    _pAsynchNotification =
                        new CRowsetAsynchNotification(
                            _rQuery, _hCursor, this, _DBErrorObj, 
                            fWatchable );
                    _pRowsetNotification.Set( _pAsynchNotification );
                }
                else
                {
                    _pRowsetNotification.Set ( new CRowsetNotification( ) );
                }

                _pRowsetNotification->AddConnectionPoints( xCPC.GetPointer() );
                _pConnectionPointContainer = xCPC.Acquire();
            }
            CATCH( CException, e )
            {
                sc = GetOleError( e );
            }
            END_CATCH;
        }

        if ( S_OK == sc )
        {
            Win4Assert( 0 != _pConnectionPointContainer );
            *ppiuk = (void *) (IConnectionPointContainer *)
                     _pConnectionPointContainer;
        }
    }
    else if (! _fForwardOnly)
    {
        if ( IID_IRowsetScroll == ifid )
        {
            *ppiuk = (void *) (IRowsetScroll *) this;
        }
        else if ( IID_IRowsetExactScroll == ifid )
        {
            *ppiuk = (void *) (IRowsetExactScroll *) this;
        }
        else if ( IID_IRowsetLocate == ifid )
        {
            *ppiuk = (void *) (IRowsetLocate *) this;
        }
        else if ( IID_IRowsetIdentity == ifid )
        {
            *ppiuk = (void *) (IRowsetIdentity *) this;
        }
        else if ( IID_IChapteredRowset == ifid )
        {
            Win4Assert( (_pChapterRowbufs != 0) == _fIsCategorized );
            if (_pChapterRowbufs)
            {
                *ppiuk = (void *) (IChapteredRowset *) this;
            }
        }
        else if ( _fAsynchronous )
        {
            if ( IID_IDBAsynchStatus == ifid )
            {
                *ppiuk = (void *) (IDBAsynchStatus *) this;
            }
            else if ( IID_IRowsetAsynch == ifid )
            {
                *ppiuk = (void *) (IRowsetAsynch *) this;
            }
            else if (IID_IRowsetWatchRegion == ifid)
            {
                *ppiuk = (void *) (IRowsetWatchRegion *) this;
            }
            else if (IID_IRowsetWatchAll == ifid)
            {
                *ppiuk = (void *) (IRowsetWatchAll *) this;
            }
        }
    }

    if ( 0 == *ppiuk )
    {
        sc = E_NOINTERFACE;
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRowset::CImpIUnknown::AddRef, public
//
//  Synopsis:   Reference the cursor.
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowset::CImpIUnknown::AddRef(void)
{
    long ref = InterlockedIncrement( &_ref );

    if ( ref > 0 )
        _rControllingQuery.AddRef();

    return ref ;
} //AddRef

//+-------------------------------------------------------------------------
//
//  Member:     CRowset::CImpIUnknown::Release, public
//
//  Synopsis:   De-Reference the cursor.
//
//  Effects:    If the ref count goes to 0 then the cursor is deleted.
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CRowset::CImpIUnknown::Release(void)
{
    long ref = InterlockedDecrement( &_ref );

    if ( ref >= 0 )
        _rControllingQuery.Release(); // may cause a delete of the rowset

    return ref;
} //Release


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetProperties, public
//
//  Synopsis:   Return information about the capabilities of the rowset
//
//  Arguments:  [cPropertyIDSets]  - number of property ID sets or zero
//              [rgPropertyIDSets] - array of desired property ID sets or NULL
//              [pcPropertySets]   - number of DBPROPSET structures returned
//              [prgPropertySets]  - array of returned DBPROPSET structures
//
//
//  Returns:    SCODE
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetProperties(
    const ULONG         cPropertyIDSets,
    const DBPROPIDSET   rgPropertyIDSets[],
    ULONG *             pcPropertySets,
    DBPROPSET **        prgPropertySets)
{
    _DBErrorObj.ClearErrorInfo();

    if ( (0 != cPropertyIDSets && 0 == rgPropertyIDSets) ||
         0 == pcPropertySets ||
         0 == prgPropertySets )
    {
        if (pcPropertySets)
           *pcPropertySets = 0;
        if (prgPropertySets)
           *prgPropertySets = 0;
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetInfo);
    }


    SCODE scResult = S_OK;
    *pcPropertySets = 0;
    *prgPropertySets = 0;


    TRY
    {
        //
        // Update ROWSETQUERYSTATUS property
        //
        DWORD dwStatus;
        _rQuery.GetQueryStatus( _hCursor, dwStatus );

        _xProperties->SetValLong( CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                                  CMRowsetProps::eid_MSIDXSPROPVAL_ROWSETQUERYSTATUS,
                                  dwStatus );

        scResult = _xProperties->GetProperties( cPropertyIDSets,
                                                rgPropertyIDSets,
                                                pcPropertySets,
                                                prgPropertySets );
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetInfo);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetInfo);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
// Member:      CRowset::RatioFinished, public
//
// Synopsis:    Returns the completion status of the query.
//
// Arguments:   [pulDenominator] - on return, denominator of fraction
//              [pulNumerator]   - on return, numerator of fraction
//              [pcRows]         - on return, number of rows
//              [pfNewRows]      - on return, TRUE if new rows in the table
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::RatioFinished(
    DBCOUNTITEM *     pulDenominator,
    DBCOUNTITEM *     pulNumerator,
    DBCOUNTITEM *     pcRows,
    BOOL *      pfNewRows) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if (0 == pulDenominator ||
        0 == pulNumerator ||
        0 == pcRows ||
        0 == pfNewRows)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetAsynch);

    TRY
    {
        *pcRows = 0;
        _rQuery.RatioFinished( _hCursor,
                               *pulDenominator,
                               *pulNumerator,
                               *pcRows,
                               *pfNewRows );

#if CIDBG
        if ( _fForwardOnly )
            Win4Assert( *pulDenominator == *pulNumerator );
        else
            Win4Assert( *pulDenominator >= *pulNumerator );
#endif // CIDBG
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetAsynch);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::AddRefRows, public
//
//  Synopsis:   Increment the ref. count of a set of row handles
//
//  Arguments:  [cRows]       -- Number of row handles in rghRows
//              [rghRows]     -- Array of HROWs to be ref. counted
//              [rgRefCounts] -- Remaining reference counts on rows (optional)
//              [rgRowStatus] -- Status for each row (optional)
//
//  Returns:    SCODE, DB_E_BADROWHANDLE if a bad row handle is passed in.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::AddRefRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pRowBufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IRowset);

    SCODE scResult = S_OK;
    TRY
    {
        _pRowBufs->AddRefRows(cRows, rghRows, rgRefCounts, rgRowStatus);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::ReleaseRows, public
//
//  Synopsis:   Release a set of row handles
//
//  Arguments:  [cRows] -- Number of row handles in rghRows
//              [rghRows] -- Array of HROWs to be released
//              [rgRowOptions] -- Reserved for future use (optional)
//              [rgRefCounts] -- Remaining reference counts on rows (optional)
//              [rgRowStatus] -- Status for each row (optional)
//
//  Returns:    SCODE, DB_E_BADROWHANDLE if a bad row handle is passed in.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::ReleaseRows(
    DBCOUNTITEM         cRows,
    const HROW          rghRows [],
    DBROWOPTIONS        rgRowOptions[],
    DBREFCOUNT          rgRefCounts[],
    DBROWSTATUS         rgRowStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pRowBufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IRowset);

//    if (0 != rgRowOptions)
//        return E_FAIL;

    SCODE scResult = S_OK;
    TRY
    {
        BOOL fNotify = FALSE;
        ULONG * pRefCounts = rgRefCounts;
        DBROWSTATUS * pRowStatus = rgRowStatus;

        XArray<ULONG> xrgRefCounts;
        XArray<DBROWSTATUS> xrgRowStatus;

        if ( !_pRowsetNotification.IsNull() &&
             _pRowsetNotification->IsNotifyActive() )
        {
            fNotify = TRUE;
            if ( 0 == pRefCounts )
            {
                xrgRefCounts.Init( (unsigned) cRows);
                pRefCounts = xrgRefCounts.GetPointer();
            }
            if ( 0 == pRowStatus )
            {
                xrgRowStatus.Init( (unsigned) cRows);
                pRowStatus = xrgRowStatus.GetPointer();
            }
        }

        scResult = _pRowBufs->ReleaseRows(cRows, rghRows, pRefCounts, pRowStatus);

        if ( fNotify )
        {
            ULONG cRowsToNotify = 0;
            for (ULONG i=0; i<cRows; i++)
                if ( 0 == pRefCounts[i] && DBROWSTATUS_S_OK == pRowStatus[i] )
                    cRowsToNotify++;

            if (cRowsToNotify)
            {
                XGrowable<HROW,20> xrghRows(cRowsToNotify);

                for (cRowsToNotify=0, i=0; i<cRows; i++)
                    if ( 0 == pRefCounts[i] && DBROWSTATUS_S_OK == pRowStatus[i] )
                    {
                        xrghRows[cRowsToNotify] = rghRows[i];
                        cRowsToNotify++;
                    }

                _pRowsetNotification->OnRowChange( this,
                                                   cRowsToNotify,
                                                   xrghRows.Get(),
                                                   DBREASON_ROW_RELEASE,
                                                   DBEVENTPHASE_DIDEVENT,
                                                   TRUE);
            }
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Macro:      CheckCrowsArgs
//
//  Synopsis:   Check common error conditions on cRows and pcRowsObtained
//              for GetRowsXxxx methods.
//
//  Arguments:  [cRows]          -- Number of rows to return
//              [pcRowsObtained] -- On return, number of rows actually
//                                  fetched
//
//  Returns:    SCODE
//
//  Notes:      Needs to be a macro instead of an inline function because
//              it returns from the calling method.
//
//--------------------------------------------------------------------------

#define CheckCrowsArgs(cRows, pcRowsObtained)  \
    if (0 == pcRowsObtained)                   \
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);  \
    *pcRowsObtained = 0;                       \
    if (cRows == 0)                            \
        return S_OK;


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetRowsAt, public
//
//  Synopsis:   Fetch data starting at some starting bookmark
//
//  Arguments:  [hRegion]        -- handle to watch region
//              [hChapter]       -- Chapter in a multiset cursor
//              [cbBookmark]     -- Size of bookmark for starting position
//              [pBookmark]      -- Pointer to bookmark for starting position
//              [lRowsOffset]    -- Number of row handles in rghRows
//              [cRows]          -- Number of rows to return
//              [pcRowsObtained] -- On return, number of rows actually
//                                  fetched
//              [prghRows]       -- Array of HROWs to be returned
//
//  Returns:    SCODE, E_INVALIDARG for bad parameters, DB_E_BADBOOKMARK
//              if the starting bookmark is invalid
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetRowsAt(
    HWATCHREGION        hRegion,
    HCHAPTER            hChapter,
    DBBKMARK            cbBookmark,
    const BYTE*         pBookmark,
    DBROWOFFSET         lRowsOffset,
    DBROWCOUNT          cRows,
    DBCOUNTITEM *       pcRowsObtained,
    HROW * *            prghRows
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    CheckCrowsArgs( cRows, pcRowsObtained );

    TRY
    {
        CI_TBL_BMK bmk = _MapBookmark(cbBookmark, pBookmark);
        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        CRowSeekAt rowSeek( hRegion, chapt, (LONG) lRowsOffset, bmk );

        scResult = _FetchRows(rowSeek, cRows, pcRowsObtained, prghRows);
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetLocate);
        else if ( !_pRowsetNotification.IsNull() &&
                  *pcRowsObtained != 0 &&
                  _pRowsetNotification->IsNotifyActive() )
        {
            _pRowsetNotification->OnRowChange( this,
                                               *pcRowsObtained,
                                               *prghRows,
                                               DBREASON_ROW_ACTIVATE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetRowsByBookmark, public
//
//  Synopsis:   Fetch data from a set of bookmarks
//
//  Arguments:  [hChapter]       -- Chapter in a multiset cursor
//              [cRows]          -- Number of input bookmarks and rows to return
//              [rgcbBookmark]   -- Array of bookmark sizes
//              [ppBookmarks]    -- Array of pointers to bookmarks
//              [rghRows]        -- Array of HROWs returned
//              [rgRowStatus]    -- Array for per-row status (optional)
//
//  Returns:    SCODE, E_INVALIDARG for bad parameters, DB_E_BADBOOKMARK
//              if the starting bookmark is invalid
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetRowsByBookmark(
    HCHAPTER            hChapter,
    DBCOUNTITEM         cRows,
    const DBBKMARK      rgcbBookmark[],
    const BYTE *        ppBookmarks[],
    HROW                rghRows[],
    DBROWSTATUS         rgRowStatus[]
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if (0 == ppBookmarks ||
        0 == rgcbBookmark ||
        0 == rghRows)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);

    if (cRows == 0)
        return scResult;

    TRY
    {
        //
        //  Map the input bookmarks to work IDs.  If we see an invalid
        //  bookmark, it will get turned into widInvalid, and its lookup
        //  will fail.
        //
        XArray<CI_TBL_BMK> paBmk( (unsigned) cRows );

        for (unsigned i=0; i < cRows; i++)
        {
            DBROWSTATUS sc = _MapBookmarkNoThrow( rgcbBookmark[i],
                                                  ppBookmarks[i],
                                                  paBmk[i] );
        }

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        CRowSeekByBookmark rowSeek( chapt, (ULONG) cRows, paBmk.Acquire() );

        DBCOUNTITEM cRowsObtained;
        TRY
        {
            scResult = _FetchRows(rowSeek, cRows, &cRowsObtained, &rghRows);
        }
        CATCH( CException, e )
        {
            scResult = e.GetErrorCode();
        }
        END_CATCH

        //
        // Return the array of row statuses
        //
        unsigned cErrors = 0;
        for (i=0; i < rowSeek.GetValidStatuses(); i++)
        {
            SCODE scTemp = rowSeek.GetStatus(i);
            if (0 != rgRowStatus)
                rgRowStatus[i] = ScodeToRowstatus( scTemp );

            if (S_OK != scTemp)
            {
                //
                //  The HROW array returned by _FetchRows is compressed,
                //  skipping entries for rows that had errors.  Insert
                //  a DB_NULL_HROW entry for this row.
                //
                if ( i != cRows-1 )
                {
                    memmove( &rghRows[i+1], &rghRows[i], (unsigned) ((cRows-i)-1) * sizeof (HROW));
                }
                rghRows[i] = DB_NULL_HROW;

                //
                //  If the returned error is DB_E_BADBOOKMARK,
                //  call MapBookmarkNoThrow again to distinguish
                //  E_INVALIDARG cases.
                //
                if (DB_E_BADBOOKMARK == scTemp && 0 != rgRowStatus)
                {
                    CI_TBL_BMK bmkTemp;
                    DBROWSTATUS rsTemp = _MapBookmarkNoThrow(rgcbBookmark[i],
                                                             ppBookmarks[i],
                                                             bmkTemp);
                    if (rsTemp != DBROWSTATUS_S_OK)
                    {
                        rgRowStatus[i] = rsTemp;
                    }
                }
                cErrors++;
            }
        }
        Win4Assert( rowSeek.GetValidStatuses() == cRows );

        if (SUCCEEDED(scResult) && cErrors > 0)
            scResult = (cErrors == cRows) ? DB_E_ERRORSOCCURRED :
                                            DB_S_ERRORSOCCURRED;

        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetLocate);
        else if ( !_pRowsetNotification.IsNull() &&
                  _pRowsetNotification->IsNotifyActive() )
            _pRowsetNotification->OnRowChange( this,
                                               cRows,
                                               rghRows,
                                               DBREASON_ROW_ACTIVATE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
    }

    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        scResult = GetOleError(e);
        Win4Assert(FAILED(scResult));
    }
    END_CATCH;

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::Compare, public
//
//  Synopsis:   Compare two bookmarks
//
//  Arguments:  [hChapter]   -- chapter
//              [cbBookmark1] -- Size of first bookmark
//              [pBookmark1] -- Pointer to first bookmark
//              [cbBookmark2] -- Size of second bookmark
//              [pBookmark2] -- Pointer to second bookmark
//              [pdwComparison] - on return, hased value of bookmark
//
//  Returns:    SCODE, E_INVALIDARG if cbBookmark is zero or if pBookmark or
//              pdwComparison is NULL, DB_E_BADBOOKMARK for other invalid
//              bookmarks.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::Compare(
    HCHAPTER            hChapter,
    DBBKMARK            cbBookmark1,
    const BYTE*         pBookmark1,
    DBBKMARK            cbBookmark2,
    const BYTE*         pBookmark2,
    DBCOMPARE *         pdwComparison) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == pdwComparison)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);

    TRY
    {
        ULONG dwHash1 = _MapBookmark(cbBookmark1, pBookmark1);
        ULONG dwHash2 = _MapBookmark(cbBookmark2, pBookmark2);

        //
        //  Set to non-comparable.  This is used later to see if we've
        //  successfully determined the relative order.
        //
        *pdwComparison = DBCOMPARE_NOTCOMPARABLE;

        if (dwHash1 == dwHash2)
        {
            *pdwComparison = DBCOMPARE_EQ;
        }
        else if ( 1 == cbBookmark1 || 1 == cbBookmark2 )
        {
            *pdwComparison = DBCOMPARE_NE;
        }
        else
        {
            CI_TBL_CHAPT chapt = _MapChapter(hChapter);
            _rQuery.Compare( _hCursor,
                             chapt,
                             dwHash1,
                             dwHash2,
                             (DWORD) (*pdwComparison) );
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_MapChapter, private
//
//  Synopsis:   Map a chapter mark to a ULONG internal chapter mark.
//
//  Arguments:  [hChapter] -- handle of chapter
//
//  Returns:    Chapter as an I4
//
//  Notes:      A null chapter on a categorized rowset means to operate
//              over the entire rowset, not an individual chapter.
//
//--------------------------------------------------------------------------

CI_TBL_CHAPT CRowset::_MapChapter(
    HCHAPTER            hChapter
) const
{
    CI_TBL_CHAPT chapt = (CI_TBL_CHAPT) hChapter;
    Win4Assert (DB_NULL_HCHAPTER == 0);

    if ( !_fIsCategorized && DB_NULL_HCHAPTER != hChapter )
    {
        THROW( CException( DB_E_BADCHAPTER ));
    }

    return chapt;
} //_MapChapter


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_MapBookmarkNoThrow, private
//
//  Synopsis:   Return a 32 bit hash value for a particular bookmark.
//              Don't throw on errors.
//
//  Arguments:  [cbBookmark] -- Size of bookmark
//              [pBookmark] -- Pointer to bookmark
//
//  Notes:      For IRowsetLocate::Hash and IRowsetLocate::GetRowsByBookmark
//              which want to continue processing on bookmark errors.  Unlike
//              _MapBookmark, DBBMK_FIRST and DBBMK_LAST are invalid.
//
//  Returns:    DBROWSTATUS, hash value (identity function, also the workid
//                      value for the table) is returned in rBmk
//
//--------------------------------------------------------------------------

DBROWSTATUS CRowset::_MapBookmarkNoThrow(
    DBBKMARK            cbBookmark,
    const BYTE*         pBookmark,
    CI_TBL_BMK &        rBmk) const
{
    Win4Assert( !_fForwardOnly );

    rBmk = widInvalid;

    if (0 == cbBookmark || 0 == pBookmark)
        return DBROWSTATUS_E_INVALID;

    if (cbBookmark == 1)
    {
        if (*(BYTE *)pBookmark == DBBMK_FIRST ||
            *(BYTE *)pBookmark == DBBMK_LAST ||
            *(BYTE *)pBookmark == DBBMK_INVALID)
            return DBROWSTATUS_E_INVALID;
        else
            return DBROWSTATUS_E_INVALID; //DB_E_BADBOOKMARK ???
    }
    else if (cbBookmark == sizeof (CI_TBL_BMK))
    {
        rBmk = *(UNALIGNED CI_TBL_BMK *) pBookmark;

        if (rBmk == WORKID_TBLFIRST || rBmk == WORKID_TBLLAST)
            return DBROWSTATUS_E_INVALID;
        return DBROWSTATUS_S_OK;
    }

    return DBROWSTATUS_E_INVALID; //DB_E_BADBOOKMARK ???
} //_MapBookmarkNoThrow

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_MapBookmark, private
//
//  Synopsis:   Convert a bookmark into an internal form.
//
//  Arguments:  [cbBookmark] -- Size of bookmark
//              [pBookmark] -- Pointer to bookmark
//
//  Returns:    ULONG, hash value (identity function, also the workid
//                      value for the table)
//
//--------------------------------------------------------------------------

CI_TBL_BMK CRowset::_MapBookmark(
    DBBKMARK            cbBookmark,
    const BYTE*         pBookmark) const
{
    Win4Assert( !_fForwardOnly );

    WORKID WorkID = widInvalid;
    Win4Assert( sizeof WORKID == sizeof CI_TBL_BMK );

    if (0 == cbBookmark || 0 == pBookmark)
        THROW(CException(E_INVALIDARG));

    if (cbBookmark == 1)
    {
        if (*(BYTE *)pBookmark == DBBMK_FIRST)
            WorkID = WORKID_TBLFIRST;

        else if (*(BYTE *)pBookmark == DBBMK_LAST)
            WorkID = WORKID_TBLLAST;
    }
    else if (cbBookmark == sizeof (CI_TBL_BMK))
    {
        WorkID = *(UNALIGNED CI_TBL_BMK *) pBookmark;
    }

    if (WorkID == widInvalid)
        THROW(CException(DB_E_BADBOOKMARK));

    return WorkID;
} //_MapBookmark

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::Hash, public
//
//  Synopsis:   Returns an array of 32 bit hash values for bookmarks
//
//  Arguments:  [hChapter]       -- chapter
//              [cBookmarks]     -- # of bmks to hash
//              [rgcbBM]         -- Sizes of each bookmark
//              [ppBM]           -- Pointers to each bookmark
//              [rgHashedValues] -- on return, hashed values of bookmarks
//              [rgBookmarkStatus] -- per-bookmark status (optional)
//
//  Returns:    SCODE, E_INVALIDARG if any cbBookmark is zero,
//              DB_E_BADBOOKMARK for other invalid bookmarks.
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::Hash(
    HCHAPTER            hChapter,
    DBBKMARK            cBookmarks,
    const DBBKMARK      rgcbBM[],
    const BYTE *        ppBM[],
    DBHASHVALUE         rgHashedValues[],
    DBROWSTATUS         rgBookmarkStatus[]
    )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    ULONG cErrors = 0;

    if (0 == rgcbBM || 0 == ppBM || 0 == rgHashedValues)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);

    TRY
    {
        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        for (ULONG i = 0; i < cBookmarks; i++)
        {
            CI_TBL_BMK bmk;
            DBROWSTATUS rs = _MapBookmarkNoThrow( rgcbBM[i], ppBM[i], bmk );
            rgHashedValues[i] = bmk;

            if (rs != DBROWSTATUS_S_OK)
            {
                rgHashedValues[i] = 0;
                cErrors++;
            }
            if (0 != rgBookmarkStatus)
                rgBookmarkStatus[i] = rs;
        }

        if (cErrors)
            scResult = (cErrors == cBookmarks) ? DB_E_ERRORSOCCURRED :
                                                 DB_S_ERRORSOCCURRED;

        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetLocate);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetLocate);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
} //Hash


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetApproximatePosition, public
//
//  Synopsis:   Returns the approximate position of a bookmark
//
//  Arguments:  [hChapter]    -- chapter
//              [cbBookmark]  -- size of bookmark
//              [pBookmark]   -- bookmark
//              [pulPosition] -- return approx row number of bookmark
//              [pulRows]     -- returns approx # of rows in cursor or
//                               1 + approx rows if not at quiescence
//
//  Returns:    SCODE - the status of the operation.
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetApproximatePosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE *  pBookmark,
    DBCOUNTITEM * pulPosition,
    DBCOUNTITEM * pulRows) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    Win4Assert( !_fForwardOnly );

    SCODE sc = S_OK;

    TRY
    {
        DBCOUNTITEM ulNumerator, ulDenominator;

        CI_TBL_BMK bmk = WORKID_TBLFIRST;

        if (cbBookmark != 0)
            bmk = _MapBookmark(cbBookmark, pBookmark);

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);
        _rQuery.GetApproximatePosition( _hCursor,
                                        chapt,
                                        bmk,
                                        &ulNumerator,
                                        &ulDenominator );

        if (cbBookmark)
            *pulPosition = ulNumerator;
        if (pulRows)
            *pulRows = ulDenominator;
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetScroll);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetExactPosition, public
//
//  Synopsis:   Returns the exact position of a bookmark
//
//  Arguments:  [hChapter]    -- chapter
//              [cbBookmark]  -- size of bookmark
//              [pBookmark]   -- bookmark
//              [pulPosition] -- return approx row number of bookmark
//              [pulRows]     -- returns approx # of rows in cursor or
//                               1 + approx rows if not at quiescence
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:      We don't distinguish between exact and approximate position.
//              IRowsetExactScroll is implemented only because ADO 1.5
//              started QI'ing for it.
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetExactPosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE *  pBookmark,
    DBCOUNTITEM * pulPosition,
    DBCOUNTITEM * pulRows) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    Win4Assert( !_fForwardOnly );

    SCODE sc = S_OK;

    TRY
    {
        DBCOUNTITEM ulNumerator, ulDenominator;

        CI_TBL_BMK bmk = WORKID_TBLFIRST;

        if (cbBookmark != 0)
            bmk = _MapBookmark(cbBookmark, pBookmark);

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);
        _rQuery.GetApproximatePosition( _hCursor,
                                        chapt,
                                        bmk,
                                        &ulNumerator,
                                        &ulDenominator );

        if (cbBookmark)
            *pulPosition = ulNumerator;
        if (pulRows)
            *pulRows = ulDenominator;
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetScroll);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetRowsAtRatio, public
//
//  Synopsis:   Fetch data starting at some ratio in the cursor.
//
//  Arguments:  [hRegion]   -- handle to watch region
//              [hChapter]  -- Chapter in a multiset cursor
//              [ulNumerator] -- numerator or ratio fraction
//              [ulDenominator] -- denominator or ratio fraction
//              [cRows] -- Number of rows to return
//              [pcRowsObtained] -- On return, number of rows actually
//                      fetched.
//              [prghRows] -- Array of HROWs to be released
//
//  Returns:    SCODE, E_INVALIDARG for bad parameters, DB_E_BADBOOKMARK
//              if the starting bookmark is invalid
//
//  Notes:
//
//  History:    14 Dec 1994     Alanw   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRowset::GetRowsAtRatio(
    HWATCHREGION        hRegion,
    HCHAPTER            hChapter,
    DBCOUNTITEM         ulNumerator,
    DBCOUNTITEM         ulDenominator,
    DBROWCOUNT          cRows,
    DBCOUNTITEM *       pcRowsObtained,
    HROW * *            prghRows
) {
    _DBErrorObj.ClearErrorInfo();

    CheckCrowsArgs( cRows, pcRowsObtained );

    SCODE scResult = S_OK;

    TRY
    {
        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        CRowSeekAtRatio rowSeek( hRegion, chapt, (ULONG) ulNumerator, (ULONG) ulDenominator );
        scResult = _FetchRows(rowSeek, cRows, pcRowsObtained, prghRows);
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowsetScroll);
        else if ( !_pRowsetNotification.IsNull() &&
                  *pcRowsObtained != 0 &&
                  _pRowsetNotification->IsNotifyActive() )
        {
            _pRowsetNotification->OnRowChange( this,
                                               *pcRowsObtained,
                                               *prghRows,
                                               DBREASON_ROW_ACTIVATE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
        }
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetScroll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

#ifdef _WIN64

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_ConvertOffsetsToPointers, private
//
//  Synopsis:   Runs through a row buffer converting offsets to pointers
//
//  Arguments:  [pbRows]  -- Buffer with row data
//              [pbBias]  -- Bias for offsets to pointers
//              [cRows]   -- Number of rows in the buffer
//              [pArrayAlloc] -- buffer to hold extra array pointers
//
//  History:    2 Aug 95     dlee       created
//              1 Sep 99     KLam       Reinstated
//
//----------------------------------------------------------------------------

void CRowset::_ConvertOffsetsToPointers(
    BYTE *   pbRows,
    BYTE *   pbBias,
    unsigned cRows,
    CFixedVarAllocator *pArrayAlloc )
{
    if ( !_fPossibleOffsetConversions )
        return;

    BOOL fAnyOffsets = FALSE;

    CTableColumnSet const & rCols = _ColumnsInfo.GetColumnBindings();
    unsigned cbRowWidth = _ColumnsInfo.GetRowWidth();

    for ( unsigned col = 0; col < rCols.Count(); col++ )
    {
        CTableColumn const & rColumn = *rCols.Get( col );

        // if this assert isn't true someday, add an if on this condition

        Win4Assert( rColumn.IsValueStored() );

        VARTYPE vt = rColumn.GetStoredType();

        if ( ( CTableVariant::IsByRef( vt ) ) && ( VT_CLSID != vt ) )
        {
            fAnyOffsets = TRUE;
            BYTE *pbRow = pbRows;
            BYTE *pbData = pbRow + rColumn.GetValueOffset();

            for ( unsigned row = 0;
                  row < cRows;
                  row++, pbData += cbRowWidth, pbRow += cbRowWidth )
            {
                // Even stat props can be null if they came from a
                // summary catalog.

                tbDebugOut(( DEB_TRACE, 
                             "CRowset::_ConvertOffsetsToPointer, Bias: 0x%I64x Row: 0x%I64x Data: 0x%I64x Type: %d New Alloc: 0x%I64x\n",
                             pbBias, pbRow, pbData, vt, pArrayAlloc ));

                if (! rColumn.IsNull( pbRow ) )
                {
                    if ( VT_VARIANT == vt )
                    {
                        if (! rColumn.IsDeferred( pbRow ) )
                            ((CTableVariant *) pbData)->FixDataPointers( pbBias, pArrayAlloc );
                    }
                    else
                    {
                        Win4Assert( 0 == ( vt & VT_VECTOR ) );
                        * (BYTE **) pbData = pbBias + (* (ULONG *) pbData );
                    }
                }
            }
        }
    }

    _fPossibleOffsetConversions = fAnyOffsets;
} //_ConvertOffsetsToPointers

#endif // _WIN64

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::_FetchRows, private
//
//  Synopsis:   Return handles to rows in the table
//
//  Effects:    Rows are read from the table and buffered locally.  An
//              array of handles to the rows is returned.
//
//  Arguments:  [rSeekDesc] - seek method and parameters
//              [cRows] - number of rows desired
//              [pcRowsReturned] - pointer to where number of rows is returned
//              [prghRows] - pointer to pointer to where row handles are
//                              returned, or pointer to zero if row handle
//                              array should be allocated
//
//  Returns:    error code
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CRowset::_FetchRows(
    CRowSeekDescription & rSeekDesc,
    DBROWCOUNT            cRows,
    DBCOUNTITEM *         pcRowsReturned,
    HROW * *              prghRows
) {
    SCODE scResult = S_OK;

    Win4Assert( 0 != pcRowsReturned );

    if (0 == prghRows)
    {
        THROW(CException(E_INVALIDARG));
    }

    if (0 == cRows)
    {
        *pcRowsReturned = 0;
        return scResult;
    }

    BOOL fFwdFetch = TRUE;
    if ( cRows < 0 )
    {
        fFwdFetch = FALSE;
        cRows = -cRows;    // cRows now has its absolute value
    }

    Win4Assert( cRows > 0 );

    BOOL fRowCountTrimmed = FALSE;

    if (cRows > MAX_ROW_FETCH)
    {
        cRows = MAX_ROW_FETCH;
        fRowCountTrimmed = TRUE;
    }

    XArrayOLE<HROW> ahRows;
    HROW *pHRows;
    if ( 0 == *prghRows )
    {
        ahRows.Init( (unsigned) cRows );
        pHRows = ahRows.GetPointer();
    }
    else
    {
        pHRows = *prghRows;
    }

    DBCOUNTITEM cRowsSoFar = 0;       // number of rows successfully transferred.
    CRowSeekDescription * pNextSeek = &rSeekDesc;

    TRY
    {
        XPtr<CRowSeekDescription> pRowSeekPrevious(0);
        ULONG cbRowWidth = _ColumnsInfo.GetRowWidth();

        do
        {
            XPtr<CFixedVarAllocator> xAlloc( new
                                     CFixedVarAllocator( FALSE,
                                                         FALSE,
                                                         cbRowWidth,
                                                         0 ));

            CGetRowsParams FetchParams( (ULONG) (cRows - cRowsSoFar),
                                        fFwdFetch,
                                        cbRowWidth,
                                        xAlloc.GetReference() );

            // Get the row data

            XPtr<CRowSeekDescription> xRowSeekOut(0);
            scResult = _rQuery.GetRows( _hCursor,
                                        *pNextSeek,
                                        FetchParams,
                                        xRowSeekOut );
            if (FAILED(scResult))
            {
#if CIDBG
                if (E_FAIL == scResult)
                    tbDebugOut((DEB_WARN,
                         "CRowset::_FetchRows - E_FAIL ret'd by GetRows\n"));
#endif // CIDBG
                break;
            }

            if ( 0 != FetchParams.RowsTransferred() )
            {
                Win4Assert( !xAlloc->IsBasedMemory() );

                XPtr<CRowBuffer> xRowBuf ( new
                                 CRowBuffer( _ColumnsInfo.GetColumnBindings(),
                                             cbRowWidth,
                                             FetchParams.RowsTransferred(),
                                             xAlloc ));

#ifdef _WIN64
                // if this is a Win64 client talking with a Win32 server
                // then we need to fix the row buffer since we passed in 0
                // as the base address.
                if ( FetchParams.GetReplyBase() != 0 )
                {
                    _fPossibleOffsetConversions = TRUE;
                    void *pvRows;
                    CTableColumnSet *pCol;
                    SCODE sc = xRowBuf->Lookup( (unsigned)cRowsSoFar, 
                                                &pCol, 
                                                &pvRows,
                                                FALSE );

                    _ConvertOffsetsToPointers ( (BYTE *)pvRows,
                                                FetchParams.GetReplyBase(),
                                                FetchParams.RowsTransferred(),
                                                _pRowBufs->GetArrayAlloc() );
                }
#endif

                _pRowBufs->Add( xRowBuf,
                                rSeekDesc.IsByBmkRowSeek(),
                                pHRows + cRowsSoFar );

                cRowsSoFar += FetchParams.RowsTransferred();
            }
            else
            {
                // One row didn't fit into an fsctl buffer.

                if (! ( scResult == DB_S_ENDOFROWSET ||
                        scResult == DB_S_STOPLIMITREACHED ||
                        ( scResult == DB_S_ERRORSOCCURRED &&
                          rSeekDesc.IsByBmkRowSeek() ) ) )
                {
                    tbDebugOut(( DEB_WARN,
                                 "CRowset::_FetchRows, 0 rows, sc 0x%x\n",
                                  scResult ));
                }

                Win4Assert( scResult == DB_S_ENDOFROWSET ||
                            scResult == DB_S_STOPLIMITREACHED ||
                            ( scResult == DB_S_ERRORSOCCURRED &&
                              rSeekDesc.IsByBmkRowSeek() ) );
            }

            if ( 0 != xRowSeekOut.GetPointer() )
            {
                //
                //  Transfer results from the returned seek description
                //  (for the ByBookmark case), and update for the next
                //  transfer.
                //

                rSeekDesc.MergeResults( xRowSeekOut.GetPointer() );
                delete pRowSeekPrevious.Acquire();
                pRowSeekPrevious.Set( xRowSeekOut.Acquire() );
                pNextSeek = pRowSeekPrevious.GetPointer();
            }

            Win4Assert( cRows >= 0 );

        } while ( (DBCOUNTITEM) cRows > cRowsSoFar &&
                  0 != pNextSeek &&
                  !pNextSeek->IsDone() &&
                  (S_OK == scResult || DB_S_BLOCKLIMITEDROWS == scResult ) );
    }
    CATCH( CException, e )
    {
        scResult = e.GetErrorCode();
#if CIDBG
        if (E_FAIL == scResult)
            tbDebugOut((DEB_WARN, "CRowset::_FetchRows - E_FAIL from exception\n"));
#endif // CIDBG
    }
    END_CATCH;

    if (DB_E_BADSTARTPOSITION == scResult)
        scResult = DB_S_ENDOFROWSET;

    if ( fRowCountTrimmed && scResult == S_OK )
         scResult = DB_S_ROWLIMITEXCEEDED;

    if ( FAILED(scResult))
    {
        ReleaseRows(cRowsSoFar, pHRows, 0, 0, 0);
        *pcRowsReturned = 0;

        tbDebugOut((DEB_ITRACE, "CRowset::_FetchRows - error %x thrown\n", scResult));
        QUIETTHROW( CException( scResult ) );
    }
    else
    {
        if ( ( cRowsSoFar > 0 ) && ( 0 == *prghRows ) )
            *prghRows = ahRows.Acquire();

        *pcRowsReturned = cRowsSoFar;
    }

    return( scResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::CreateAccessor, public
//
//  Synopsis:   Makes an accessor that a client can use to get data.
//
//  Arguments:  [dwAccessorFlags]  -- read/write access requested
//              [cBindings]    -- # of bindings in rgBindings
//              [rgBindings]   -- array of bindings for the accessor to support
//              [cbRowSize]    -- ignored for IRowset
//              [phAccessor]   -- returns created accessor if all is ok
//              [rgBindStatus] -- array of binding statuses
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::CreateAccessor(
    DBACCESSORFLAGS     dwAccessorFlags,
    DBCOUNTITEM         cBindings,
    const DBBINDING     rgBindings[],
    DBLENGTH            cbRowSize,
    HACCESSOR *         phAccessor,
    DBBINDSTATUS        rgBindStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == phAccessor || (0 != cBindings && 0 == rgBindings))
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);

    // Make sure pointer is good while zeroing in case of a later error

    *phAccessor = 0;

    TRY
    {
        XPtr<CAccessor> Accessor( CreateAnAccessor( dwAccessorFlags,
                                                    cBindings,
                                                    rgBindings,
                                                    rgBindStatus,
                                                    _fExtendedTypes,
                                                    (IUnknown *) (IRowset *)this,
                                                    &_ColumnsInfo ) );

        CLock lock( _mutex );

        _aAccessors.Add( Accessor.GetPointer() );

        *phAccessor = (Accessor.Acquire())->Cast();
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
} //CreateAccessor

//+---------------------------------------------------------------------------
//
//  Member:     IsValidFromVariantType
//
//  Synopsis:   If DBCONVERTFLAGS_FROMVARIANT is requested, the source type
//              has to be a valid VARIANT type.
//
//  Arguments:  [wTypeIn] -- the source type
//
//  Returns:    TRUE  -- the type is a valid VARIANT type
//              FALSE -- otherwise
//
//----------------------------------------------------------------------------

inline BOOL IsValidFromVariantType( DBTYPE wTypeIn )
{
    DBTYPE wType = wTypeIn & VT_TYPEMASK;

    return (! ((wType > VT_DECIMAL && wType < VT_I1) ||
               (wType > VT_LPWSTR && wType < VT_FILETIME && wType != VT_RECORD) ||
               (wType > VT_CLSID)) );
}

//+---------------------------------------------------------------------------
//
//  Member:     IsVariableLengthType
//
//  Synopsis:   checks to see DBCONVERTFLAGS_ISLONG is appropriate
//
//  Arguments:  [wTypeIn] -- the source type
//
//  Returns:    TRUE  -- the type is variable length
//              FALSE -- otherwise
//
//----------------------------------------------------------------------------

inline BOOL IsVariableLengthType( DBTYPE  wTypeIn )
{
    DBTYPE wType = wTypeIn & VT_TYPEMASK;

    return wType == DBTYPE_STR       ||
           wType == DBTYPE_BYTES     ||
           wType == DBTYPE_WSTR      ||
           wType == DBTYPE_VARNUMERIC;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::CanConvert, public
//
//  Synopsis:   Indicate whether a type conversion is valid.
//
//  Arguments:  [wFromType]      -- source type
//              [wToType]        -- destination type
//              [dwConvertFlags] -- read/write access requested
//
//  Returns:    S_OK if the conversion is available, S_FALSE otherwise.
//              E_FAIL, E_INVALIDARG or DB_E_BADCONVERTFLAG on errors.
//
//  History:    20 Nov 96      AlanW   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::CanConvert(
    DBTYPE wFromType,
    DBTYPE wToType,
    DBCONVERTFLAGS dwConvertFlags )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        if (((dwConvertFlags & DBCONVERTFLAGS_COLUMN) &&
             (dwConvertFlags & DBCONVERTFLAGS_PARAMETER)) ||
            (dwConvertFlags & ~(DBCONVERTFLAGS_COLUMN |
                                DBCONVERTFLAGS_PARAMETER |
                                DBCONVERTFLAGS_ISFIXEDLENGTH |
                                DBCONVERTFLAGS_ISLONG |
                                DBCONVERTFLAGS_FROMVARIANT)))
        {
            sc = DB_E_BADCONVERTFLAG;
        }
        else if ( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT &&
                   !IsValidFromVariantType(wFromType) )
        {
            sc = DB_E_BADTYPE;
        }
        else
        {
            BOOL fOk = CAccessor::CanConvertType( wFromType,
                                                  wToType,
                                                  _fExtendedTypes, _xDataConvert );
            sc = fOk ? S_OK : S_FALSE;
        }
        if (FAILED(sc))
            _DBErrorObj.PostHResult(sc, IID_IConvertType);
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IConvertType);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetBindings, public
//
//  Synopsis:   Returns an accessor's bindings
//
//  Arguments:  [hAccessor]   -- accessor being queried
//              [dwBindIO]    -- returns read/write access of accessor
//              [pcBindings]  -- returns # of bindings in rgBindings
//              [prgBindings] -- returns array of bindings
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwBindIO,
    DBCOUNTITEM *     pcBindings,
    DBBINDING * *     prgBindings) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == pdwBindIO ||
        0 == pcBindings ||
        0 == prgBindings)
    {
        // fill in error values where possible
        if (pdwBindIO)
           *pdwBindIO = DBACCESSOR_INVALID;
        if (pcBindings)
           *pcBindings = 0;
        if (prgBindings)
           *prgBindings = 0;

        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);
    }

    *pdwBindIO = DBACCESSOR_INVALID;
    *pcBindings = 0;
    *prgBindings = 0;

    TRY
    {
        CLock lock( _mutex );
        CAccessor * pAccessor = (CAccessor *)_aAccessors.Convert( hAccessor );
        pAccessor->GetBindings(pdwBindIO, pcBindings, prgBindings);
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::AddRefAccessor, public
//
//  Synopsis:   Frees an accessor
//
//  Arguments:  [hAccessor]   -- accessor being freed
//              [pcRefCount]  -- pointer to residual refcount (optional)
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::AddRefAccessor(
    HACCESSOR   hAccessor,
    ULONG *     pcRefCount
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        CLock lock( _mutex );
        _aAccessors.AddRef( hAccessor, pcRefCount );
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::ReleaseAccessor, public
//
//  Synopsis:   Frees an accessor
//
//  Arguments:  [hAccessor]   -- accessor being freed
//              [pcRefCount]  -- pointer to residual refcount (optional)
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::ReleaseAccessor(
    HACCESSOR   hAccessor,
    ULONG *     pcRefCount )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        CLock lock( _mutex );
        _aAccessors.Release( hAccessor, pcRefCount );
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IAccessor);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
} //ReleaseAccessor

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetData, public
//
//  Synopsis:   Returns row data using an accessor
//
//  Arguments:  [hRow]        -- handle of row whose data is returned
//              [hAccessor]   -- accessor used to retrieve the data
//              [pData]       -- where the data is written
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetData(
    HROW                hRow,
    HACCESSOR           hAccessor,
    void*               pData) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    // NOTE: Null accessors are not supported, so don't need to worry about
    //       special casing for that.
    if ( 0 == pData )
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);

    TRY
    {
        CLock lock( _mutex );
        CAccessor * pAccessor = (CAccessor *)_aAccessors.Convert( hAccessor );

        Win4Assert( pAccessor->IsRowDataAccessor() );
        pAccessor->GetData(hRow, pData, *_pRowBufs, _rQuery, _ColumnsInfo, _xDataConvert );
    }
    CATCH(CException, e)
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        sc = GetOleError(e);
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetNextRows, public
//
//  Synopsis:   Return row data from the table
//
//  Arguments:  [hChapter]       -- chapter to start at
//              [cRowsToSkip]    -- # of rows to skip
//              [cRows]          -- # of rows to try to return
//              [pcRowsObtained] -- returns # of rows obtained
//              [prghRows]       -- returns array of rows
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetNextRows(
    HCHAPTER       hChapter,
    DBROWOFFSET    cRowsToSkip,
    DBROWCOUNT     cRows,
    DBCOUNTITEM *  pcRowsObtained,
    HROW * *       prghRows
)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    BOOL fNotified = FALSE;

    CheckCrowsArgs( cRows, pcRowsObtained );

    if (_fForwardOnly && cRowsToSkip < 0)
        return _DBErrorObj.PostHResult(DB_E_CANTSCROLLBACKWARDS, IID_IRowset);
    if (_fForwardOnly && cRows < 0 )
        return _DBErrorObj.PostHResult(DB_E_CANTFETCHBACKWARDS, IID_IRowset);

    TRY
    {
        if (! _fHoldRows)
            _pRowBufs->CheckAllHrowsReleased();

        CI_TBL_CHAPT chapt = _MapChapter(hChapter);

        if ( !_pRowsetNotification.IsNull() &&
             _pRowsetNotification->IsNotifyActive() )
        {
            scResult = _pRowsetNotification->OnRowsetChange(
                                         this,
                                         DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                         DBEVENTPHASE_OKTODO,
                                         FALSE);

            if ( S_FALSE == scResult )
                THROW(CException(DB_E_CANCELED));
            fNotified = TRUE;
        }

        CRowSeekNext rowSeek( chapt, (LONG) cRowsToSkip );

        scResult = _FetchRows(rowSeek, cRows, pcRowsObtained, prghRows);

        if ( fNotified )
        {
            if (SUCCEEDED(scResult))
            {
                if ( *pcRowsObtained != 0 )
                    _pRowsetNotification->OnRowChange( this,
                                                       *pcRowsObtained,
                                                       *prghRows,
                                                       DBREASON_ROW_ACTIVATE,
                                                       DBEVENTPHASE_DIDEVENT,
                                                       TRUE);
                _pRowsetNotification->OnRowsetChange( this,
                                                      DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                                      DBEVENTPHASE_DIDEVENT,
                                                      TRUE);
            }
        }
        if (FAILED(scResult))
            _DBErrorObj.PostHResult(scResult, IID_IRowset);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;

    if ( fNotified && FAILED(scResult) )
        _pRowsetNotification->OnRowsetChange( this,
                                              DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                              DBEVENTPHASE_FAILEDTODO,
                                              TRUE);

    Win4Assert( cRowsToSkip != 0 ||
                DB_E_BADSTARTPOSITION != scResult );
    return scResult;
}


//
// IRowsetIdentity methods
//

SCODE CRowset::IsSameRow ( HROW hThisRow, HROW hThatRow )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        CTableColumnSet *pRowBufferColumns;
        BYTE *pbSrc;

        //
        // Lookup the HROWs to validate them
        //

        _pRowBufs->Lookup( hThisRow,
                           &pRowBufferColumns,
                           (void **) &pbSrc );

        _pRowBufs->Lookup( hThatRow,
                           &pRowBufferColumns,
                           (void **) &pbSrc );

        if (hThisRow != hThatRow)
           scResult = S_FALSE;

    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetIdentity);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//
// IRowsetWatchAll methods
//

SCODE CRowset::Acknowledge ( )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scResult = S_OK;
    TRY
    {
        // Just use Refresh to acknowledge the notification.
        _rQuery.Refresh();
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchAll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::Start ( )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.StartWatching(_hCursor);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchAll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::StopWatching ( )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.StopWatching(_hCursor);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchAll);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;

}


//
// IRowsetWatchRegion methods
//

SCODE CRowset::ChangeWatchMode (
    HWATCHREGION hRegion,
    DBWATCHMODE mode)
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);;

    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.SetWatchMode(&hRegion, mode);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::CreateWatchRegion (
    DBWATCHMODE mode,
    HWATCHREGION* phRegion)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    *phRegion = watchRegionInvalid;
    TRY
    {
        _rQuery.SetWatchMode(phRegion, mode);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}

SCODE CRowset::DeleteWatchRegion (
    HWATCHREGION hRegion)
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);

    SCODE scResult = S_OK;
    TRY
    {
        _rQuery.ShrinkWatchRegion (hRegion, 0, 0, 0);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


SCODE CRowset::GetWatchRegionInfo (
    HWATCHREGION hRegion,
    DBWATCHMODE * pMode,
    HCHAPTER * phChapter,
    DBBKMARK * pcbBookmark,
    BYTE ** ppBookmark,
    DBROWCOUNT * pcRows)
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);;

    SCODE scResult = S_OK;
    // test pointers and prepare for failure
    *phChapter = 0;
    *pcbBookmark = 0;
    *ppBookmark = 0;
    *pcRows = 0;

    TRY
    {
        CI_TBL_CHAPT chapter;
        CI_TBL_BMK   bookmark;

        _rQuery.GetWatchInfo( hRegion, pMode, &chapter, &bookmark, (DBCOUNTITEM *)pcRows);

        if (chapter != 0)
        {
            *phChapter = (HCHAPTER)chapter;
        }
        if (bookmark != 0)
        {
            XArrayOLE<CI_TBL_BMK> pOutBookmark (1);
            *pcbBookmark = sizeof CI_TBL_BMK;
            memcpy ( pOutBookmark.GetPointer(), &bookmark, sizeof CI_TBL_BMK);
            *ppBookmark = (BYTE*) pOutBookmark.Acquire();
        }

    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


SCODE CRowset::ShrinkWatchRegion (
    HWATCHREGION hRegion,
    HCHAPTER     hChapter,
    DBBKMARK cbBookmark,
    BYTE * pBookmark,
    DBROWCOUNT cRows )
{
    _DBErrorObj.ClearErrorInfo();

    if (hRegion == watchRegionInvalid)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetWatchRegion);;

    SCODE scResult = S_OK;

    TRY
    {

        CI_TBL_BMK bookmark = _MapBookmark(cbBookmark, pBookmark);
        CI_TBL_CHAPT chapter = _MapChapter(hChapter);

        _rQuery.ShrinkWatchRegion ( hRegion, chapter, bookmark, (LONG) cRows);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}



SCODE CRowset::Refresh (
    DBCOUNTITEM* pCount,
    DBROWWATCHCHANGE** ppRowChange )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        // prepare the buffers
        // fetch the script and
        // a bunch of rows.
        // If not all rows fit in
        // the buffer, call again.
        _rQuery.Refresh();
        *pCount = 0;
        scResult = DB_S_TOOMANYCHANGES;
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetWatchRegion);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetStatus, public
//
//  Synopsis:   Return query status
//
//  Arguments:  [pdwStatus]      -- pointer to where query status is returned
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetStatus(
    DWORD *        pdwStatus
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        *pdwStatus = 0;

        _rQuery.GetQueryStatus( _hCursor, *pdwStatus );
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetQueryStatus);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetStatusEx, public
//
//  Synopsis:   Return query status
//
//  Arguments:  [pdwStatus]           - returns query status
//              [pcFilteredDocuments] - # of documents filtered
//              [pcDocumentsToFilter] - # of docsuments yet to filter
//              [pdwRatioFinishedDenominator] - ratio finished denominator
//              [pdwRatioFinishedNumerator]   - ratio finished numerator
//              [cbBmk]               - # of bytes in pBmk
//              [pBmk]                - bookmark for piRowBmk
//              [piRowBmk]            - returns index of bookmark in table
//              [pcRowsTotal]         - current # of rows in table
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetStatusEx(
    DWORD * pdwStatus,
    DWORD * pcFilteredDocuments,
    DWORD * pcDocumentsToFilter,
    DBCOUNTITEM * pdwRatioFinishedDenominator,
    DBCOUNTITEM * pdwRatioFinishedNumerator,
    DBBKMARK      cbBmk,
    const BYTE *  pBmk,
    DBCOUNTITEM * piRowBmk,
    DBCOUNTITEM * pcRowsTotal )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    TRY
    {
        *pdwStatus = 0;

        CI_TBL_BMK bmk = WORKID_TBLFIRST;

        if ( cbBmk != 0 )
            bmk = _MapBookmark( cbBmk, pBmk );
        _rQuery.GetQueryStatusEx( _hCursor,
                                  *pdwStatus,
                                  *pcFilteredDocuments,
                                  *pcDocumentsToFilter,
                                  *pdwRatioFinishedDenominator,
                                  *pdwRatioFinishedNumerator,
                                  bmk,
                                  *piRowBmk,
                                  *pcRowsTotal );
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowsetQueryStatus);
        scResult = GetOleError(e);
    }
    END_CATCH;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetReferencedRowset, public
//
//  Synopsis:   Return the related rowset for a hierarchical query.
//
//  Arguments:  [iOrdinal]           -- ordinal of column for bookmark
//              [riid]               -- IID of desired interface
//              [ppReferencedRowset] -- interface pointer returned here
//
//  Returns:    SCODE error code
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetReferencedRowset(
    DBORDINAL iOrdinal,
    REFIID riid,
    IUnknown ** ppReferencedRowset
) /*const*/ {
    _DBErrorObj.ClearErrorInfo();

    if (0 == ppReferencedRowset)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetInfo);

    *ppReferencedRowset = 0;

    if ( iOrdinal > _ColumnsInfo.GetColumnCount() ||
         (0 == _pRelatedRowset && 0 == iOrdinal && _fForwardOnly))
        return _DBErrorObj.PostHResult(DB_E_BADORDINAL, IID_IRowsetInfo);

    if ( 0 == _pRelatedRowset && 0 != iOrdinal )
        return _DBErrorObj.PostHResult(DB_E_NOTAREFERENCECOLUMN, IID_IRowsetInfo);

    //
    //  If it's the bookmark column, it's like a QI on this rowset.
    //
    if (0 == iOrdinal)
        return QueryInterface( riid, (void **)ppReferencedRowset );

    //
    // Make sure the column is a valid chapter column.
    //
    const DBCOLUMNINFO & rColInfo = _ColumnsInfo.Get1ColumnInfo( (ULONG) iOrdinal );

    if ( (rColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0 ||
         (rColInfo.dwFlags & DBCOLUMNFLAGS_ISROWID) != 0 )
        return _DBErrorObj.PostHResult(DB_E_NOTAREFERENCECOLUMN, IID_IRowsetInfo);

    return _pRelatedRowset->QueryInterface( riid, (void **)ppReferencedRowset );
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::RestartPosition, public
//
//  Synopsis:   Set up CRowset so next GetNextRows will restart from beginning
//
//  Arguments:  [hChapter]           -- chapter which should restart
//
//  Returns:    SCODE error code
//
//  Notes:
//
//  History:    16-Apr-97  emilyb   wrote
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::RestartPosition(
    HCHAPTER            hChapter
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    BOOL fNotified = FALSE;

    TRY
    {
        if (! _fHoldRows)
            _pRowBufs->CheckAllHrowsReleased();

        CI_TBL_CHAPT chapter = _MapChapter(hChapter); // is chapter valid?

        if ( !_pRowsetNotification.IsNull() &&
             _pRowsetNotification->IsNotifyActive() )
        {
            scResult = _pRowsetNotification->OnRowsetChange(
                                         this,
                                         DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                         DBEVENTPHASE_OKTODO,
                                         FALSE);

            if ( S_FALSE == scResult )
                THROW(CException(DB_E_CANCELED));
            fNotified = TRUE;
        }

        _rQuery.RestartPosition(_hCursor, chapter);

        if ( fNotified )
            _pRowsetNotification->OnRowsetChange( this,
                                                  DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                                  DBEVENTPHASE_DIDEVENT,
                                                  TRUE);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IRowset);
        scResult = GetOleError(e);

        if (E_NOTIMPL == scResult)
        {
           scResult = DB_E_CANNOTRESTART;
        }
    }
    END_CATCH;

    if ( fNotified && FAILED(scResult) )
        _pRowsetNotification->OnRowsetChange( this,
                                              DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                              DBEVENTPHASE_FAILEDTODO,
                                              TRUE);
    return scResult;
}


//
//  IDbAsynchStatus methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::Abort, public
//
//  Synopsis:   Cancels an asynchronously executing operation.
//
//  Arguments:  [hChapter]    -- chapter which should restart
//              [ulOperation] -- operation for which status is being requested
//
//  Returns:    SCODE error code
//
//  Notes:
//
//  History:    09 Feb 1998    AlanW    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::Abort(
    HCHAPTER            hChapter,
    ULONG               ulOperation
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if ( DBASYNCHOP_OPEN != ulOperation )
    {
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IDBAsynchStatus);
    }

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CI_TBL_CHAPT chapter = _MapChapter(hChapter); // is chapter valid?
        _rQuery.StopAsynch(_hCursor);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IDBAsynchStatus);
        scResult = GetOleError(e);

        if (E_NOTIMPL == scResult)
        {
           scResult = DB_E_CANTCANCEL;
           _DBErrorObj.PostHResult(scResult, IID_IDBAsynchStatus);
        }
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetStatus, public
//
//  Synopsis:   Returns the status of an asynchronously executing operation.
//
//  Arguments:  [hChapter]    -- chapter which should restart
//              [ulOperation] -- operation for which status is being requested
//
//  Returns:    SCODE error code
//
//  Notes:
//
//  History:    09 Feb 1998    AlanW    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetStatus(
    HCHAPTER          hChapter,
    DBASYNCHOP        ulOperation,
    DBCOUNTITEM *     pulProgress,
    DBCOUNTITEM *     pulProgressMax,
    DBASYNCHPHASE *   pulAsynchPhase,
    LPOLESTR *        ppwszStatusText
) {
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if ( DBASYNCHOP_OPEN != ulOperation )
    {
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IDBAsynchStatus);
    }

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // NOTE: we don't support getting the status of chapters
        //       independently.
         
        // CI_TBL_CHAPT chapter = _MapChapter(hChapter); // is chapter valid?
        if (DB_NULL_HCHAPTER != hChapter)
            THROW( CException( DB_E_BADCHAPTER ));

        DBCOUNTITEM ulNumerator = 0;
        DBCOUNTITEM ulDenominator = 0;
        DBCOUNTITEM cRows;
        BOOL fNewRows;

        _rQuery.RatioFinished( _hCursor,
                               ulDenominator,
                               ulNumerator,
                               cRows,
                               fNewRows );

        if (pulProgress)
            *pulProgress = ulNumerator;
        if (pulProgressMax)
            *pulProgressMax = ulDenominator;
        if (pulAsynchPhase)
            *pulAsynchPhase = (ulDenominator == ulNumerator) ?
                                  DBASYNCHPHASE_COMPLETE :
                                  DBASYNCHPHASE_POPULATION;
        if (ppwszStatusText)
            *ppwszStatusText = 0;

#if CIDBG
        if ( _fForwardOnly )
            Win4Assert( ulDenominator == ulNumerator );
        else
            Win4Assert( ulDenominator >= ulNumerator );
#endif // CIDBG
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IDBAsynchStatus);
        scResult = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRowset::GetSpecification, public
//
//  Synopsis:   Return the session or command object used to create this rowset
//
//  Arguments:  [hChapter]           -- chapter which should restart
//
//  Notes:
//
//  History:    01-28-98    danleg      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::GetSpecification(
    REFIID riid,
    IUnknown ** ppvSpecification
) {
    _DBErrorObj.ClearErrorInfo();

    if  ( 0 == ppvSpecification )
        return _DBErrorObj.PostHResult( E_INVALIDARG, IID_IRowsetInfo );
        
    SCODE sc = S_OK;
    TRANSLATE_EXCEPTIONS;
    TRY 
    {
        *ppvSpecification = 0;

        if ( _xUnkCreator.IsNull() )
            return S_FALSE;

        sc = _xUnkCreator->QueryInterface( riid, (void ** )ppvSpecification );
        if ( FAILED(sc) )
            THROW( CException(sc) );

    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_IRowsetInfo );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;
    
    return sc;
}


//
//  IServiceProperties methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CRowset::GetPropertyInfo, public
//
//  Synopsis:   Get rowset properties
//
//  Arguments:  [cPropertySetIDs]    - number of desired properties or 0
//              [rgPropertySetIDs]   - array of desired properties or NULL
//              [pcPropertySets]     - number of property sets returned
//              [prgPropertySets]    - array of returned property sets
//              [ppwszDesc]          - if non-zero, property descriptions are
//                                     returneed
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRowset::GetPropertyInfo(
    const ULONG            cPropertySetIDs,
    const DBPROPIDSET      rgPropertySetIDs[],
    ULONG *                pcPropertySets,
    DBPROPINFOSET **       prgPropertySets,
    WCHAR **               ppwszDesc)
{
    _DBErrorObj.ClearErrorInfo();

    if ( (0 != cPropertySetIDs && 0 == rgPropertySetIDs) ||
          0 == pcPropertySets ||
          0 == prgPropertySets )
    {
        if (pcPropertySets)
           *pcPropertySets = 0;
        if (prgPropertySets)
           *prgPropertySets = 0;
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);
    }

    SCODE sc = S_OK;
    *pcPropertySets = 0;
    *prgPropertySets = 0;
    if (ppwszDesc)
       *ppwszDesc = 0;


    TRANSLATE_EXCEPTIONS;
    TRY
    {
        sc = _PropInfo.GetPropertyInfo( cPropertySetIDs,
                                        rgPropertySetIDs,
                                        pcPropertySets,
                                        prgPropertySets,
                                        ppwszDesc );

        // Don't PostHResult here -- it's a good chance it's a scope
        // property that we're expecting to fail.  Spare the expense.
        // The child object will post the error for us.
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IServiceProperties);
        sc = GetOleError(e);

    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRowset::SetRequestedProperties, public
//
//  Synopsis:   Set rowset properties via IServiceProperties (not supported)
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRowset::SetRequestedProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    _DBErrorObj.ClearErrorInfo();

    if ( 0 != cPropertySets && 0 == rgPropertySets)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);;

    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IServiceProperties);;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRowset::SetSuppliedProperties, public
//
//  Synopsis:   Set rowset properties via IServiceProperties (not supported)
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRowset::SetSuppliedProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    _DBErrorObj.ClearErrorInfo();

    if ( 0 != cPropertySets && 0 == rgPropertySets)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);;

    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IServiceProperties);;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRowset::AddRefChapter, public
//
//  Synopsis:   Increment the ref. count to a chapter
//
//  Arguments:  [hChapter]   - handle to chapter
//              [pcRefCount] - pointer to chapter ref. count
//
//  Notes:      Chapter references are obtained via an accessor from the
//              parent rowset, but they are addref'ed in the child rowset.
//
//  History:    15 Mar 99   AlanW       Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::AddRefChapter(
    HCHAPTER            hChapter,
    ULONG *             pcRefCount
) {
    tbDebugOut(( DEB_TRACE, "CRowset::AddRefChapter called!\n" ));
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pChapterRowbufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IChapteredRowset);

    if (DB_NULL_HCHAPTER == hChapter)
        return _DBErrorObj.PostHResult(DB_E_BADCHAPTER, IID_IChapteredRowset);

    SCODE scResult = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _pChapterRowbufs->AddRefChapter(hChapter, pcRefCount);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IChapteredRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRowset::ReleaseChapter, public
//
//  Synopsis:   Decrement the ref. count to a chapter
//
//  Arguments:  [hChapter]   - handle to chapter
//              [pcRefCount] - pointer to chapter ref. count
//
//  Notes:      Chapter references are obtained via an accessor from the
//              parent rowset, but they are released in the child rowset.
//
//  History:    15 Mar 99   AlanW       Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRowset::ReleaseChapter(
    HCHAPTER            hChapter,
    ULONG *             pcRefCount
) {
    tbDebugOut(( DEB_TRACE, "CRowset::ReleaseChapter called!\n" ));
    _DBErrorObj.ClearErrorInfo();

    if (0 == _pChapterRowbufs)
        return _DBErrorObj.PostHResult(E_FAIL, IID_IChapteredRowset);

    if (DB_NULL_HCHAPTER == hChapter)
        return _DBErrorObj.PostHResult(DB_E_BADCHAPTER, IID_IChapteredRowset);

    SCODE scResult = S_OK;
    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _pChapterRowbufs->ReleaseChapter(hChapter, pcRefCount);
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IChapteredRowset);
        scResult = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return scResult;
}


STDMETHODIMP CRowset::Stop( )
{
   SCODE scResult = S_OK;
   TRY
   {
       _rQuery.StopAsynch(_hCursor);
   }
   CATCH( CException, e )
   {
       scResult = GetOleError(e);
   }
   END_CATCH;

   return scResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\sglookup.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       sglookup.cxx
//
//  Contents:   A class for doing a quick lookup of a segment based on the
//              key. It will do a binary search and locate the segment.
//              This is useful for doing row insertions into a large table
//              when keys are not coming in any specific order.
//
//  Classes:    CSegmentArrray
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <sglookup.hxx>
#include <seglist.hxx>

#include "tabledbg.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray consructor 
//
//  Synopsis:   Initializes the segment array 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

CSegmentArray::CSegmentArray()
: CDynArrayInPlace<CTableSegment *>(eMinSegments),
  _pComparator(0),
  _iHint(0)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::_FindSegment
//
//  Synopsis:   Given a segment pointer, it searches for the segment in the
//              array and returns the index in the array.
//
//  Arguments:  [pSeg] - Segment to look for.
//
//  Returns:    Index in the array if the segment is located.
//              -1 otherwise.
//
//  History:    10-25-95   srikants   Created
//
//----------------------------------------------------------------------------

int CSegmentArray::_FindSegment( const CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );

    //
    // Optimization - use the last returned segment index as a hint
    //

    if ( _iHint < Count() && Get(_iHint) == pSeg )
        return (int) _iHint;    

    for ( unsigned i = 0; i < Count(); i++ )
    {
        if ( Get(i) == pSeg )
        {
            _iHint = i;
            return (int) i;
        }
    }

    //
    // The segment could not be located.
    //
    _iHint = 0;
    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::LookUp
//
//  Synopsis:   Looks up the segment which is likely to contain the given
//              key or is a candidate to insert the given key.
//
//  Arguments:  [key] -  Key to look up.
//
//  Returns:    The segment pointer where to look for/insert the given key.
//              0 if there are no segments
//
//  History:    10-20-95   srikants   Created
//
//  Notes:      Please note that each segment has only the "smallest" key in
//              that segment. We don't know anything about the highest key in
//              that segment. if we two adjacent segments with lowest keys
//              k1 and k3 and a new key if k1 < k2 < k3,
//              k2 will end up in segment 1
//
//----------------------------------------------------------------------------

CTableSegment * CSegmentArray::LookUp( CTableRowKey & key )
{

    Win4Assert( 0 != _pComparator );

    int cSegs = (int) Count();

    if ( 0 == cSegs )
        return 0;    

    int iLow = 0;
    int iHigh = cSegs - 1;
    int iMid = iHigh/2;

    int iComp = 0;

    while ( iLow <= iHigh )
    {
        iMid = (iLow + iHigh)/2;

        CTableSegment * pCurrSeg = Get( (unsigned) iMid );

        iComp = _pComparator->Compare( key, pCurrSeg->GetLowestKey() );

        if ( 0 == iComp )
            return pCurrSeg;    

        if ( iComp > 0 )    // key is bigger than the smallest key in the seg
            iLow = iMid+1;
        else                // key is < the smallest key in the seg
            iHigh = iMid-1;
    }

    Win4Assert( iLow > iHigh );

    int iGet = 0;

    if ( iMid > iHigh )
    {
        Win4Assert( iLow == iMid );
        Win4Assert( iComp < 0 );

        iGet = iHigh >= 0 ? iHigh : 0;
    }
    else
    {
        Win4Assert( iMid == iHigh );
        Win4Assert( iMid < iLow && iMid < cSegs );
        iGet = iMid;
    }

    return Get( (unsigned) iGet );

}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::Append
//
//  Synopsis:   Adds the given segment to the end of the array.
//
//  Arguments:  [pSeg] -  Segment to be appended.
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::Append( CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );
    Win4Assert( !IsFound(pSeg) );

    Add( pSeg, Count() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::InsertAfter
//
//  Synopsis:   Inserts the given segment after the marker segment
//
//  Arguments:  [pMarker] -  Segment already present in the array.
//              [pSeg]    -  New segment to be inserted.
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::InsertAfter( const CTableSegment * pMarker,
                                 CTableSegment * pSeg )
{

    Win4Assert( 0 != pSeg );
    Win4Assert( !IsFound(pSeg) );
    Win4Assert( 0 != pMarker );

    int iMarker = _FindSegment( pMarker );
    Win4Assert( iMarker >= 0 );
    Insert( pSeg, (unsigned)iMarker+1 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::InsertBefore
//
//  Synopsis:   Inserts the given segment "before" the marker segment
//
//  Arguments:  [pMarker] - The segment before which the new segment must
//              be inserted. If NULL, the given segment will be added as
//              the first segment in the array.
//
//              [pSeg]    - The new segment
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::InsertBefore( const CTableSegment * pMarker,
                                  CTableSegment * pSeg )
{
    Win4Assert( 0 != pSeg );
    Win4Assert( !IsFound(pSeg) );

    if ( 0 != pMarker )
    {
        int iPos = _FindSegment( pMarker );
        Win4Assert( iPos >= 0 );
        Insert( pSeg, (unsigned) iPos );
    }
    else
    {
        Insert( pSeg, 0 );  // make this the first in the array
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::Replace
//
//  Synopsis:   Replaces the old segment with the new segment
//
//  Arguments:  [pOld] - 
//              [pNew] - 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::Replace( const CTableSegment * pOld, CTableSegment * pNew )
{
    Win4Assert( 0 != pOld && 0 != pNew );
    int iPos = _FindSegment( pOld );
    Win4Assert( iPos >= 0 );

    Win4Assert( !IsFound( pNew ) );

    Add( pNew, (unsigned) iPos );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::_MoveEntries
//
//  Synopsis:   Moves entries from the specified offset by the given number
//              of entries..
//
//  Arguments:  [iStart]   -  Starting offset to move
//              [cEntries] -  Number of entries to move by.
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::_MoveEntries( unsigned iStart, unsigned cEntries )
{
    Win4Assert( iStart < _count );

    if ( 0 == cEntries )
        return;

    Win4Assert( cEntries + _count <= Size() );

    unsigned iNewPos = iStart + cEntries;

    memmove( _aItem + iNewPos, _aItem + iStart,
             (_count - iStart) * sizeof(CTableSegment *) );

    _count += cEntries;

#if CIDBG==1
    //
    // The caller can asser that the moved entries are all NULL.
    //
    for ( unsigned i = iStart; i < iNewPos; i++ )
    {
        _aItem[i] = 0;    
    }
#endif  // CIDBG==1

}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::Replace
//
//  Synopsis:   Removes "pOld" from the list and inserts the new list of
//              segments in its place.
//
//  Arguments:  [pOld]    - 
//              [segList] - 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::Replace( const CTableSegment * pOld,
                             CTableSegList & segList )
{
    unsigned cSegsToInsert = segList.GetSegmentsCount();

    if ( cSegsToInsert == 0 )
    {
        RemoveEntry( pOld );
        return;
    }

    int iSeg = _FindSegment( pOld );
    Win4Assert( iSeg >= 0 );

    unsigned iInsert = (unsigned) iSeg;

    //
    // Replace the current segment with the first one in the list
    //
    CFwdTableSegIter iter( segList );

    Win4Assert ( !segList.AtEnd(iter) );

    _aItem[iInsert++] = iter.GetSegment();
    segList.Advance(iter);
    cSegsToInsert--;

    if ( !segList.AtEnd(iter) )
    {
        Win4Assert( cSegsToInsert > 0 );

        //
        // There is more than one segment to replace with. We should
        // iterate and move them.
        //

        unsigned cTotalSegs = _count + cSegsToInsert;

        //
        // Grow the array if necessary.
        //
        if ( (cTotalSegs-1) >= _size )
            _GrowToSize( cTotalSegs-1 );

        if ( iInsert != _count )
        {
            Win4Assert( iInsert < _count );
            _MoveEntries( iInsert, cSegsToInsert );
        }
        else
        {
            //
            // We are just appending at the end. No need to move anything
            //
#if CIDBG==1
            for ( unsigned i = _count; i < cTotalSegs; i++ )
            {
                _aItem[i] = 0;    
            }
#endif  // CIDBG==1

            _count +=cSegsToInsert;
            Win4Assert( _count == cTotalSegs );
        }

        for ( ; !segList.AtEnd(iter); segList.Advance(iter) )
        {

#if CIDBG==1
            //
            // We are either appending to the end or the entries got moved
            // and nullified.
            //
            Win4Assert( 0 == _aItem[iInsert]  );
#endif  // CIDBG==1

            Win4Assert( !IsFound(iter.GetSegment()) );
            _aItem[iInsert++] = iter.GetSegment();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::RemoveEntry
//
//  Synopsis:   Removes the specified segment from the array.
//
//  Arguments:  [pSeg] - 
//
//  History:    10-20-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::RemoveEntry( const CTableSegment * pSeg )
{
    int iSeg = _FindSegment( pSeg );
    Win4Assert( iSeg >= 0 );

    Remove( (unsigned) iSeg );
}

#if CIDBG==1

//+---------------------------------------------------------------------------
//
//  Member:     CSegmentArray::TestInSync
//
//  Synopsis:   Tests that the list and the array are fully in sync.
//
//  Arguments:  [list] - The global list of segments
//
//  History:    10-25-95   srikants   Created
//
//----------------------------------------------------------------------------

void CSegmentArray::TestInSync( CTableSegList & list )
{
    if ( Count() != list.GetSegmentsCount() )
    {
        tbDebugOut(( DEB_ERROR, "Array Count = 0x%X ListCount = 0x%X \n",
                     Count(), list.GetSegmentsCount() ));
        Win4Assert( !"Array Count and List Count Not In Sync" );
        return;
    }

    unsigned i = 0;
    for ( CFwdTableSegIter iter(list); !list.AtEnd(iter); list.Advance(iter) )
    {
        if ( iter.GetSegment() != Get(i) )
        {
            tbDebugOut(( DEB_ERROR, "iter.GetSegment() = 0x%X : i = 0x%X : Array[i] = 0x%X\n",
                         iter.GetSegment(), i, Get(i) ));
            Win4Assert( !"List and Array are not in sync" );
        }
        i++;
    }
}

#endif  // CIDBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\segmru.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       segmru.cxx
//
//  Contents:   Most Recently Used segments management.
//
//  Classes:    CMRUSegments
//
//  History:    4-11-95   srikants   Created
//
//
//  Notes  :    All methods in this are assumed to be under a larger
//              lock (like the bigtable lock).
//
//----------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include <segmru.hxx>
#include <tableseg.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   CMRUSegments
//
//  Synopsis:   Destructor for the most recently used segments list.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CMRUSegments::~CMRUSegments()
{
    for ( CWidSegmentMap * pEntry = _list.RemoveLast();
          0 != pEntry;
          pEntry = _list.RemoveLast() )
    {
        delete pEntry;    
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSegmentInUse
//
//  Synopsis:   Tests if the given segment is currently in use or not.
//
//  Arguments:  [pSegment] - Segment to test.
//
//  Returns:    TRUE if the segment is in use. FALSE o/w
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CMRUSegments::IsSegmentInUse( CTableSegment * pSegment )
{
    Win4Assert( 0 != pSegment );

    for ( CFwdWidSegMapIter iter(_list); !_list.AtEnd(iter);
          _list.Advance(iter) )
    {
        if ( iter->GetWorkId() != widInvalid )
        {
            if ( iter->GetSegment() == pSegment ||
                 pSegment->IsRowInSegment( iter->GetWorkId()) )
            {
                return TRUE;    
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddReplace
//
//  Synopsis:   Add/Replaces the wid/segment mapping entry in the MRU list.
//
//  Arguments:  [wid]  - Workid of the new entry
//              [pSeg] - Pointer to the segment in which the wid is present.
//                       If it is set to NULL, it just means that the wid
//                       is going to be used but we don't know in which segment
//                       it is present (during Bucket->Window conversion)
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CMRUSegments::AddReplace( WORKID wid, CTableSegment * pSeg )
{
    Win4Assert( widInvalid != wid );

    //
    // Determine if the workid already exists in the list of MRU wids.
    // If so, just move it to the top of the list.
    //
    for ( CFwdWidSegMapIter iter(_list); !_list.AtEnd(iter);
          _list.Advance(iter) )
    {
        if ( wid == iter->GetWorkId() )
        {
            CWidSegmentMap * pCurrent = iter.GetEntry();
            _list.MoveToFront( pCurrent );
            pCurrent->Set( pSeg );
            return;
        }
    }

    //
    // We either need to remove an entry from the end or create a new one
    // and add
    //
    CWidSegmentMap * pEntry = 0;
    if ( _list.Count() < _nMaxEntries )
    {
        pEntry = new CWidSegmentMap( wid, pSeg );
    }
    else
    {
        //
        // Remove the last entry from the list and re-use it for
        // the new entry.
        //
        pEntry = _list.RemoveLast();
    }

    Win4Assert( 0 != pEntry );

    pEntry->Set( wid, pSeg );
    _list.Push(pEntry);

    return;
    
}

//+---------------------------------------------------------------------------
//
//  Function:   Invalidate
//
//  Synopsis:   Invalidate all cached pointers that are same as the given
//              one.
//
//  Arguments:  [pSegment] - The segment that is going to be invalid.
//
//  History:    4-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CMRUSegments::Invalidate( const CTableSegment * const pSegment )
{
    Win4Assert( 0 != pSegment );

    for ( CFwdWidSegMapIter iter(_list); !_list.AtEnd(iter);
          _list.Advance(iter) )
    {
        if ( iter->GetSegment() == pSegment )
        {
            iter->Set(0);    
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Remove
//
//  Synopsis:   
//
//  Arguments:  [wid] - 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    5-30-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CMRUSegments::Remove( WORKID wid )
{
    Win4Assert( widInvalid != wid );

    //
    // Determine if the workid already exists in the list of MRU wids.
    // If so, just move it to the top of the list.
    //
    CFwdWidSegMapIter iter(_list);
    while ( !_list.AtEnd(iter) )
    {
        CWidSegmentMap * pCurrent = iter.GetEntry();
        //
        // Because we may destroy the current node, we must skip ahead
        // before destorying it.
        //
        _list.Advance(iter);

        if ( wid == pCurrent->GetWorkId() )
        {
            _list.RemoveFromList( pCurrent );
            delete pCurrent;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\strhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       strhash.cxx
//
//  Contents:   Hash table compressions of strings for large tables.
//
//  Classes:    CCompressedColHashString
//
//  Functions:
//
//  History:    03 May 1994     AlanW    Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <tblvarnt.hxx>

#include "strhash.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   HashWSTR
//
//  Synopsis:   Hashes a WSTR and returns a value according to the format
//              explained in the HashString call.
//
//  Arguments:  [pwszStr] -  Pointer to the string.
//              [nChar]   -  Number of characters in the string.
//
//  Returns:    A HashValue (formatted according to notes in HashString)
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
ULONG CCompressedColHashString::HashWSTR( WCHAR const * pwszStr,
                                          USHORT nChar )
{
    ULONG ulRet = 0;

    for ( ULONG i = 0; i < nChar ; i++)
    {
        WCHAR wch = pwszStr[i];
        ulRet = (ulRet << 1) ^ wch;
    }

    ulRet = (ulRet >> 16) ^ ulRet;
    ulRet = (ulRet & 0xFFFF) | (i << 17);
    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashSTR
//
//  Synopsis:   Hashes an ASCII string.
//
//  Arguments:  [pszStr] -
//              [nChar]  -
//
//  Returns:    (Same as HashWSTR)
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
ULONG CCompressedColHashString::HashSTR( CHAR const * pszStr, USHORT nChar )
{
    ULONG ulRet = 0;

    for ( ULONG i = 0; i < nChar ; i++)
    {
        BYTE ch = (BYTE) pszStr[i];
        ulRet = (ulRet << 1) ^ ch;
    }

    ulRet = (ulRet >> 16) ^ ulRet;
    ulRet = (ulRet & 0xFFFF) | (i << 17) | (1 << 16);  // is an ascii string
    return ulRet;
}

//const ULONG CCompressedColHashString::_cbDataWidth = sizeof (HashEntry);

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::HashString, public static
//
//  Synopsis:   Generic hash function for strings
//
//  Arguments:  [pbData] - pointer to the value to be hashed.
//              [cbData] - size of pbData (may be some arbitrary large
//                      value if string is NUL terminated.
//              [vtDataType] - type of string, VT_LPWSTR, or VT__LPSTR
//              [fNullTerminated ] - Set to TRUE if the string is a NULL
//              terminted string. FALSE o/w.
//
//  Returns:    ULONG - Hash value for the input data
//
//  Notes:      The returned hash value encodes the string length in
//              characters and string format in the upper half of the
//              returned DWORD.  The format of the returned value is:
//
//              +15                                           00+
//              +-----------------------------------------------+
//              |      hash value (xor,shift of char values)    |
//              +--------------------------------------------+--+
//              |      character count                       | F|
//              +--------------------------------------------+--+
//               31                                        17+16+
//
//              where F = 0 if Unicode string, F = 1 if ASCII string
//
//              As a side-effect, the string is copied to local storage,
//              and a key to that storage is returned in rulCopyKey.
//
//--------------------------------------------------------------------------

ULONG CCompressedColHashString::HashString(
    BYTE *pbData,
    USHORT cbData,
    VARTYPE vtDataType,
    BOOL   fNullTerminated
)
{

    ULONG ulRet = 0;

    switch (vtDataType)
    {

    case VT_LPWSTR:


        {
            UNICODE_STRING ustr;

            if ( fNullTerminated )
            {
                RtlInitUnicodeString(&ustr, (PWSTR)pbData);
            }
            else
            {
                Win4Assert( ( cbData & (USHORT) 0x1 ) == 0 );    // must be an even number
                ustr.Buffer = (PWSTR) pbData;
                ustr.MaximumLength = ustr.Length = cbData;
            }

            ulRet = HashWSTR( ustr.Buffer, ustr.Length/sizeof(WCHAR) );
        }

        break;

    case VT_LPSTR:

        {
            ANSI_STRING astr;

            if ( fNullTerminated )
            {
                RtlInitAnsiString(&astr, (PSZ)pbData);
            }
            else
            {
                astr.Buffer = (CHAR *) pbData;
                astr.MaximumLength = astr.Length = cbData;
            }

            ulRet = HashSTR( astr.Buffer, astr.Length );
        }

        break;

    default:    // PERFFIX - need to support VT_BSTR also?
        Win4Assert(!"CCompressedColHashString::HashString called with bad type");
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    return ulRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::AddData, public
//
//  Synopsis:   Add a data entry to the hash table if it is not
//              already there.
//
//  Arguments:  [pVarnt] - pointer to data item
//              [pKey] - pointer to lookup key value
//              [reIndicator] - returns an indicator variable for
//                      problems
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.  reIndicator is filled with an indication
//              of problems.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHashString::AddData(
    PROPVARIANT const * const pVarnt,
    ULONG* pKey,
    GetValueResult& reIndicator
)
{
    //
    //  Specially handle the VT_EMPTY case
    //
    if (pVarnt->vt == VT_EMPTY) {
        *pKey = 0;
        reIndicator = GVRSuccess;
        return;
    }

    CTableVariant *pVar = (CTableVariant *)pVarnt;
    Win4Assert((pVar->vt == VT_LPWSTR || pVar->vt == VT_LPSTR) &&
             pVar->VariantPointerInFirstWord( ));

    BYTE *pbData ;
    USHORT cbData = (USHORT) pVar->VarDataSize();
    pbData = (BYTE *) pVar->pwszVal;

    Win4Assert(cbData != 0 && pbData != NULL);

    _AddData( pbData, cbData, pVar->vt, pKey, TRUE );  // NULL Terminated
    reIndicator = GVRSuccess;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindCountedWStr
//
//  Synopsis:   Findss the given string to the string store. It is assumed
//              that there is no terminating NULL in the string. Instead,
//              its length is passed.
//
//  Arguments:  [pwszStr]     - Pointer to the string to be added.
//              [cwcStr]      - Count of the characters in the string.
//
//  Returns:    ULONG key or stridInvalid
//
//  History:    7-17-95   dlee   Created
//
//----------------------------------------------------------------------------

ULONG CCompressedColHashString::FindCountedWStr(
    WCHAR const *pwszStr,
    ULONG cwcStr )
{
    Win4Assert( !_fOptimizeAscii );

    BYTE *pbData = (BYTE *) pwszStr ;
    USHORT cbData = (USHORT) cwcStr * sizeof(WCHAR);

    Win4Assert(cbData != 0 && pbData != NULL);

    return _FindData( pbData, cbData, VT_LPWSTR, FALSE );
} //FindCountedWStr

//+---------------------------------------------------------------------------
//
//  Function:   AddCountedWStr
//
//  Synopsis:   Adds the given string to the string store. It is assumed
//              that there is no terminating NULL in the string. Instead,
//              its length is passed.
//
//  Arguments:  [pwszStr]     - Pointer to the string to be added.
//              [cwcStr]      - Count of the characters in the string.
//              [key]         - OUTPUT - Id of the string
//              [reIndicator] - GVRSuccess if successful. Failure code o/w
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CCompressedColHashString::AddCountedWStr(
    WCHAR const *pwszStr,
    ULONG cwcStr,
    ULONG & key,
    GetValueResult & reIndicator
)
{

    Win4Assert( !_fOptimizeAscii );

    BYTE *pbData = (BYTE *) pwszStr ;
    USHORT cbData = (USHORT) cwcStr * sizeof(WCHAR);

    Win4Assert(cbData != 0 && pbData != NULL);

    _AddData( pbData, cbData, VT_LPWSTR, &key, FALSE );
    reIndicator = GVRSuccess;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddData
//
//  Synopsis:   Adds a NULL terminated string to the string store.
//
//  Arguments:  [pwszStr]     -  Pointer to a NULL terminated string.
//              [key]         -  OUTPUT - key of the added string.
//              [reIndicator] -  Status indicator.
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID    CCompressedColHashString::AddData(
    WCHAR const *pwszStr,
    ULONG & key,
    GetValueResult & reIndicator
)
{
    ULONG cwcStr = wcslen( pwszStr );
    AddCountedWStr( pwszStr, cwcStr, key, reIndicator );
    return;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::_AddData, private
//
//  Synopsis:   Private helper for the public AddData method.  Adds
//              a data entry to the hash table (if it does not already
//              exist).
//
//  Arguments:  [pbData] - pointer to data item
//              [cbDataSize] - size of data item
//              [pKey] - pointer to lookup key value
//
//  Returns:    pKey is filled in with the index of the data item in
//              the data array.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID    CCompressedColHashString::_AddData(
    BYTE *pbData,
    USHORT cbDataSize,
    VARTYPE vt,
    ULONG* pKey,
    BOOL   fNullTerminated
) {
    if ( 0 == _cDataItems )
    {
        _GrowHashTable();
    }

    ULONG ulHash = HashString( pbData, cbDataSize, vt, fNullTerminated );
    USHORT usSizeFmt = (USHORT) (ulHash >> 16);
    ULONG cbString = usSizeFmt & 1? usSizeFmt >> 1 : usSizeFmt;

    ulHash %= _cHashEntries;

    HASHKEY* pulHashChain = &(((HASHKEY *)_pAlloc->BufferAddr())[ulHash]);
    HashEntry* pNextData;
    USHORT cChainLength = 0;

    while (*pulHashChain != 0)
    {
        cChainLength++;
        pNextData = _IndexHashkey( *pulHashChain );

        if (usSizeFmt == pNextData->usSizeFmt)
        {
            BYTE* pbNextString = (BYTE*)_pAlloc->OffsetToPointer(pNextData->ulStringKey);
            if (memcmp(pbNextString, pbData, cbString) == 0)
            {

                //
                //  Found the data item.  Return its index.
                //
                *pKey = *pulHashChain;
                return;
            }
        }
        pulHashChain = &pNextData->ulHashChain;
    }

    //
    // Allocate memory for the new string and copy the contents from
    // the source buffer.
    //
    BYTE * pbNewData = (BYTE *) _pAlloc->Allocate( cbString );
    TBL_OFF ulKey = _pAlloc->PointerToOffset(pbNewData);
    RtlCopyMemory( pbNewData, pbData, cbString );

    //  The table may move in memory when we call AllocFixed.
    //  Be sure we can address pulHashChain after that.
    //
    ULONG ulHashChainBase = (ULONG)((BYTE*)pulHashChain - _pAlloc->BufferAddr());
    pNextData = (struct HashEntry*) _pAlloc->AllocFixed();
    pulHashChain = (HASHKEY *) (_pAlloc->BufferAddr() + ulHashChainBase);

    //
    //  NOTE:  The fixed hash table at this point decides if it wants
    //          to grow the fixed area, with a possible rehash of the
    //          table to grow the number of buckets.  With the code
    //          below, the string hash table has no opportunity to
    //          grow the number of hash buckets.
    //

    //
    //  Now add the new data item.  The data item consists of a HASHKEY
    //  for the hash chain, followed by the size and format indicator,
    //  and the key for the string in the variable data.
    //

    *pKey = *pulHashChain = ++_cDataItems;
    Win4Assert(_cDataItems != 0);               // check for overflow
    pNextData->ulHashChain = 0;
    pNextData->usSizeFmt = usSizeFmt;
    pNextData->ulStringKey = ulKey;
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::_FindData, private
//
//  Synopsis:   Finds a data entry in the hash table.
//
//  Arguments:  [pbData] - pointer to data item
//              [cbDataSize] - size of data item
//              [pKey] - pointer to lookup key value
//
//  Returns:    The key of the string or stridInvalid
//
//  History:    7-17-95   dlee   Created
//
//--------------------------------------------------------------------------

ULONG CCompressedColHashString::_FindData(
    BYTE *   pbData,
    USHORT   cbDataSize,
    VARTYPE  vt,
    BOOL     fNullTerminated )
{
    if ( 0 == _pAlloc )
        _GrowHashTable();

    ULONG ulHash = HashString( pbData, cbDataSize, vt, fNullTerminated );
    USHORT usSizeFmt = (USHORT) (ulHash >> 16);
    ULONG cbString = usSizeFmt & 1? usSizeFmt >> 1 : usSizeFmt;
    ulHash %= _cHashEntries;

    HASHKEY* pulHashChain = &(((HASHKEY *)_pAlloc->BufferAddr())[ulHash]);

    while ( 0 != *pulHashChain )
    {
        HashEntry* pNextData = _IndexHashkey( *pulHashChain );

        if ( usSizeFmt == pNextData->usSizeFmt )
        {
            BYTE* pbNext = (BYTE*)_pAlloc->OffsetToPointer(pNextData->ulStringKey);
            if ( memcmp( pbNext, pbData, cbString ) == 0 )
            {
                // Found the data item.  Return its index.

                return *pulHashChain;
            }
        }
        pulHashChain = &pNextData->ulHashChain;
    }

    // couldn't find the string in the table

    return stridInvalid;
} //_FindData


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::GetData, public
//
//  Synopsis:   Retrieve a data value from the hash table.
//
//  Arguments:  [pVarnt] - pointer to a variant structure in which to
//                      return a pointer to the data
//              [PreferredType] - preferred type of the result.
//              [ulKey] - the lookup key value
//              [PropId] - (unused) property id being retrieved.
//
//  Returns:    pVarnt is filled in with the data item from the hash table.
//
//  Notes:      The FreeVariant method must be called with the pVarnt
//              structure as an argument when it is no longer needed.
//
//--------------------------------------------------------------------------


GetValueResult  CCompressedColHashString::GetData(
    PROPVARIANT * pVarnt,
    VARTYPE PreferredType,
    ULONG ulKey,
    PROPID PropId
    )
{
    Win4Assert(ulKey <= _cDataItems);

    if (ulKey == 0) {
        pVarnt->vt = VT_EMPTY;
        return GVRNotAvailable;
    }

    HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + ulKey - 1;
    BOOL fAscii = (pData->usSizeFmt & 1) != 0;
    ULONG cchSize = (pData->usSizeFmt >> 1) + 1;
    ULONG cbSize = PreferredType == VT_LPWSTR ? cchSize * sizeof (WCHAR) :
                        !fAscii ?               cchSize * sizeof (WCHAR) :
                                                cchSize;
    BYTE* pbBuf = (BYTE*)_GetStringBuffer((cbSize+1) / sizeof (WCHAR));
    BYTE* pbSource = (BYTE*)_pAlloc->OffsetToPointer(pData->ulStringKey);

    //
    //  Give out the data as an LPSTR only if that's what the caller
    //  desires, and it's in the ascii range.
    //

    if (PreferredType == VT_LPSTR && fAscii)
    {
        RtlCopyMemory(pbBuf, pbSource, cbSize - 1);
        ((CHAR *)pbBuf)[cchSize - 1] = '\0';
        pVarnt->vt = VT_LPSTR;
        pVarnt->pszVal = (PSZ)pbBuf;
    }
    else
    {
        if (!fAscii) {
            RtlCopyMemory(pbBuf, pbSource, cbSize - sizeof(WCHAR));
        } else {
            for (unsigned i=0; i<cchSize-1; i++) {
                ((WCHAR*)pbBuf)[i] = ((CHAR*)pbSource)[i];
            }
        }
        ((WCHAR *)pbBuf)[cchSize - 1] = L'\0';
        pVarnt->vt = VT_LPWSTR;
        pVarnt->pwszVal = (PWSTR)pbBuf;
    }
    return GVRSuccess;

}

//+---------------------------------------------------------------------------
//
//  Function:   GetData
//
//  Synopsis:   Copies a NULL terminated string into the pwszStr by looking
//              up the string identified by "ulKey".
//
//  Arguments:  [ulKey]   - Key of the string to lookup.
//              [pwszStr] - Pointer to the buffer to copy to.
//              [cwcStr]  - On input, it contains the length of the buffer in
//                          WCHARs. On output, it has the length of the string
//                          copied INCLUDING the terminating NULL.
//
//  Returns:    GVR* code
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
GetValueResult
CCompressedColHashString::GetData( ULONG ulKey,
                                   WCHAR * pwszStr,
                                   ULONG & cwcStr
                                 )
{
    Win4Assert(ulKey <= _cDataItems);

    if (ulKey == 0)
    {
        return GVRNotAvailable;
    }

    HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + ulKey - 1;
    BOOL fAscii = (pData->usSizeFmt & 1) != 0;
    Win4Assert( !fAscii );
    ULONG cchSize = (pData->usSizeFmt >> 1) + 1;
    ULONG cbSize =  cchSize * sizeof (WCHAR);

    if ( cwcStr < cchSize )
    {
        return GVRNotEnoughSpace;
    }

    BYTE* pbSource = (BYTE*)_pAlloc->OffsetToPointer(pData->ulStringKey);
    RtlCopyMemory( pwszStr, pbSource, cbSize - sizeof(WCHAR) );
    pwszStr[cchSize - 1] = L'\0';
    cwcStr = cchSize;

    return GVRSuccess;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCountedWStr
//
//  Synopsis:   Returns a pointer to a string which is NOT null terminated.
//              The length of the string (in characters) is returned in
//              cwcStr.
//
//  Arguments:  [ulKey]  -  String to lookup
//              [cwcStr] -  OUTPUT - length of the string in WCHARs.
//
//  History:    5-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

const WCHAR *
CCompressedColHashString::GetCountedWStr( ULONG ulKey,
                                          ULONG & cwcStr
                                        )
{
    Win4Assert(ulKey <= _cDataItems);

    if (ulKey == 0)
        return 0;

    HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + ulKey - 1;
    BOOL fAscii = (pData->usSizeFmt & 1) != 0;
    Win4Assert( !fAscii );
    ULONG cchSize = (pData->usSizeFmt >> 1);

    BYTE* pbSource = (BYTE*)_pAlloc->OffsetToPointer(pData->ulStringKey);
    Win4Assert( ( (TBL_OFF)pbSource & (TBL_OFF) 0x1 ) == 0 );    // properly aligned on word.

    cwcStr = cchSize;

    return (const WCHAR *) pbSource;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashStr::_GetStringBuffer, private
//
//  Synopsis:   Private helper for the public GetData method.  Gets
//              a string buffer of sufficient size to accomodate the
//              request.
//
//  Arguments:  [cchString] - number of characters required in buffer
//
//  Returns:    pointer to a buffer of sufficient size
//
//  Notes:
//
//  History:    03 Mar 1995     Alanw   Created
//
//--------------------------------------------------------------------------

PWSTR   CCompressedColHashString::_GetStringBuffer( unsigned cchString )
{
    if (! _Buf1.InUse())
        return _Buf1.Alloc(cchString);
    else if (! _Buf2.InUse())
        return _Buf2.Alloc(cchString);
    else
        return new WCHAR [ cchString ];
}

//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::FreeVariant, public
//
//  Synopsis:   Free private data associated with a variant which had
//              been filled in by the GetData method.
//
//  Arguments:  [pVarnt] - pointer to the variant
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

void    CCompressedColHashString::FreeVariant(PROPVARIANT * pVarnt)
{
    if (pVarnt->vt != VT_EMPTY) {

        Win4Assert(pVarnt->vt == VT_LPWSTR || pVarnt->vt == VT_LPSTR);

        if (! _Buf1.FreeConditionally( pVarnt->pwszVal ) &&
            ! _Buf2.FreeConditionally( pVarnt->pwszVal ) )
        {
            delete [] pVarnt->pwszVal;
        }

        pVarnt->pwszVal = 0;            // To prevent accidental re-use
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::DataLength, public
//
//  Synopsis:   Free private data associated with a variant which had
//              been filled in by the GetData method.
//
//  Arguments:  [kData] - key to the data
//
//  Returns:    USHORT number of characters in the data item.  Includes
//                      space for a terminating character.  Scale
//                      this by the size of a character for byte count.
//
//  Notes:
//
//--------------------------------------------------------------------------

USHORT  CCompressedColHashString::DataLength(ULONG kData)
{
    if (kData == 0)
        return 0;
    else
    {
        HashEntry* pData = ((HashEntry*) _pAlloc->FirstRow()) + kData - 1;
        return (pData->usSizeFmt >> 1) + 1;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CCompressedColHashString::_GrowHashTable, private
//
//  Synopsis:   Grow the space allocated to the hash table and data
//              items.
//
//  Arguments:  - none -
//
//  Returns:    Nothing
//
//  Notes:      Called to allocate the initial data area.  Unlike the
//              like-named method in the fixed hash table, this is
//              called only for the initial allocation of data.  Data
//              Items are not re-hashed after being added to the table.
//
//--------------------------------------------------------------------------

const unsigned HASH_TABLE_SIZE = 174;   // Minimum hash table size
                                        // avg. chain length is about
                                        // 3 for a one-page table.
                                        //  NOTE: should be even to
                                        //      assure DWORD allignment of
                                        //      fixed data.

VOID CCompressedColHashString::_GrowHashTable( void )
{
    int fRehash = FALSE;

    _cHashEntries = HASH_TABLE_SIZE;

    Win4Assert(_cDataItems == 0 && _pAlloc == NULL); // only called to initialize.
    Win4Assert(_cbDataWidth == sizeof (HashEntry));
    _pAlloc = new CFixedVarAllocator( TRUE,
                                      TRUE,
                                      _cbDataWidth,
                                      HASH_TABLE_SIZE*sizeof (HASHKEY) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\svcproxy.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       svcproxy.cxx
//
//  Contents:   Proxy to cisvc encapsulating all the context for a
//              running query, including the query execution context, the
//              cached query results, and all cursors over the results.
//
//  Classes:    CSvcQueryProxy
//
//  History:    13 Sept 96  dlee created (mostly copied) from queryprx.cxx
//              22 Aug  99  KLam Win64->Win32 support
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <pickle.hxx>
#include <memser.hxx>
#include <sizeser.hxx>
#include <propvar.h>
#include <proxymsg.hxx>
#include <tblvarnt.hxx>
#include <tgrow.hxx>
#include <pmalloc.hxx>

#include "tabledbg.hxx"
#include "rowseek.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::CSvcQueryProxy, public
//
//  Synopsis:   Creates a locally accessible Query
//
//  Arguments:  [client]     - Proxy for talking to remote process
//              [cols]       - Columns that may be bound to
//              [rst]        - Query restriction
//              [pso]        - Sort order of the query
//              [pcateg]     - Categorization specification
//              [RstProp]    - Rowset properties for rowset(s) created
//              [pidmap]     - Property ID mapper
//              [cCursors]   - count of cursors expected to be created
//              [aCursors]   - returns handles to cursors created
//
//  History:    13 Sept 96  dlee created
//
//----------------------------------------------------------------------------

CSvcQueryProxy::CSvcQueryProxy(
    CRequestClient &           client,
    CColumnSet const &         cols,
    CRestriction const &       rst,
    CSortSet const *           pso,
    CCategorizationSet const * pcateg,
    CRowsetProperties const &  RstProp,
    CPidMapper const &         pidmap ,
    ULONG                      cCursors,
    ULONG *                    aCursors )
        : _ref( 0 ),
          _client( client ),
          _fTrueSequential( FALSE ),
          _fWorkIdUnique( FALSE ),
          _xQuery( ),
          _xBindings( )
{
    tbDebugOut(( DEB_PROXY, "CSvcQueryProxy\n" ));

    // DSO property IDs change with version 5

    if ( _client.GetServerVersion() < 5 )
       THROW( CException( STATUS_INVALID_PARAMETER_MIX ) );

    _aCursors.Init( cCursors );

    ULONG cbIn = PickledSize( _client.GetServerVersion(),
                              &cols,
                              &rst,
                              pso,
                              pcateg,
                              &RstProp,
                              &pidmap );
    cbIn = AlignBlock( cbIn, sizeof ULONG );
    XArray<BYTE> xQuery( cbIn + sizeof CPMCreateQueryIn );
    BYTE * pbPickledQuery = xQuery.GetPointer() + sizeof CPMCreateQueryIn;
    Pickle( _client.GetServerVersion(),
            &cols,
            &rst,
            pso,
            pcateg,
            &RstProp,
            &pidmap,
            pbPickledQuery,
            cbIn );

    CPMCreateQueryIn & request = * ( new( xQuery.Get() ) CPMCreateQueryIn );

    request.SetCheckSum( xQuery.SizeOf() );

    const unsigned cbCursors = sizeof ULONG * cCursors;
    const unsigned cbReply = sizeof CPMCreateQueryOut + cbCursors;
    XGrowable<BYTE, 200> xReply( cbReply );
    CPMCreateQueryOut * pReply = new( xReply.Get() ) CPMCreateQueryOut();

    ULONG cbRead;
    _client.DataWriteRead( &request,
                           xQuery.SizeOf(),
                           pReply,
                           cbReply,
                           cbRead );

    // DataWriteRead throws both connection problems and request problems

    Win4Assert( SUCCEEDED( pReply->GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || cbReply == cbRead );

    _fTrueSequential = pReply->IsTrueSequential();
    _fWorkIdUnique = pReply->IsWorkIdUnique();
    _ulServerCookie = pReply->GetServerCookie();

    RtlCopyMemory( aCursors, pReply->GetCursors(), cbCursors );

    //
    // Preserve xQuery for RestartPosition on sequential queries
    //
    if ( _fTrueSequential )
    {
        unsigned cElems = xQuery.Count();
        _xQuery.Set( cElems, xQuery.Acquire() );

        // The assumption here is that for a seq query the cursor does not
        // change.  If this becomes different at a later date, the rowset
        // will have an old cursor after RestartPosition.

        RtlCopyMemory( _aCursors.Get(), aCursors, cbCursors );
    }

    #if CIDBG == 1
        for ( ULONG i = 0; i < cCursors; i++ )
            Win4Assert( 0 != aCursors[i] );
    #endif // CIDBG == 1

    AddRef();
} //CSvcQueryProxy

//+---------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::~CSvcQueryProxy, public
//
//  Synopsis:   Destroy the query.  Nothing to do -- all of the cursors
//              have been freed by now.
//
//  History:    13 Sept 96  dlee created
//
//----------------------------------------------------------------------------

CSvcQueryProxy::~CSvcQueryProxy()
{
    tbDebugOut(( DEB_PROXY, "~CSvcQueryProxy\n\n" ));
    Win4Assert( 0 == _ref );

    // don't _client.Disconnect() here -- keep it open for more queries

} //~CSvcQueryProxy

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::AddRef, public
//
//  Synopsis:   Reference the query.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

ULONG CSvcQueryProxy::AddRef()
{
    return InterlockedIncrement( & _ref );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::Release, public
//
//  Synopsis:   De-Reference the query.
//
//  Effects:    If the ref count goes to 0 then the query is deleted.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

ULONG CSvcQueryProxy::Release()
{
    long l = InterlockedDecrement( & _ref );

    if ( l <= 0 )
    {
        tbDebugOut(( DEB_PROXY, "CSvcQueryProxy unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::FreeCursor, public
//
//  Synopsis:   Free a handle to a CTableCursor
//
//  Arguments:  [hCursor] - handle to the cursor to be freed
//
//  Returns:    # of cursors remaining
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

unsigned CSvcQueryProxy::FreeCursor(
    ULONG hCursor )
{
    tbDebugOut(( DEB_PROXY, "FreeCursor\n" ));
    Win4Assert( 0 != hCursor );

    // If FreeCursor fails (likely because the system is out of memory),
    // terminate the connection with cisvc so query resources are freed.

    TRY
    {
        CPMFreeCursorIn request( hCursor );
        CPMFreeCursorOut reply;
        ULONG cbRead;
        _client.DataWriteRead( &request,
                               sizeof request,
                               &reply,
                               sizeof reply,
                               cbRead );

        Win4Assert( SUCCEEDED( reply.GetStatus() ) );
        Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

        return reply.CursorsRemaining();
    }
    CATCH( CException, e )
    {
        prxDebugOut(( DEB_IWARN,
                      "freecursor failed 0x%x, rudely terminating connection\n",
                      e.GetErrorCode() ));

        _client.TerminateRudelyNoThrow();

        RETHROW();
    }
    END_CATCH

    return 0;
} //FreeCursor

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetRows, public
//
//  Synopsis:   Retrieve row data for a table cursor
//
//  Arguments:  [hCursor] - the handle of the cursor to fetch data for
//              [rSeekDesc] - row seek operation to be done before fetch
//              [pGetRowsParams] - row fetch parameters and buffer pointers
//              [pSeekDescOut] - row seek description for restart
//
//  Returns:    SCODE - the status of the operation.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

SCODE CSvcQueryProxy::GetRows(
    ULONG                       hCursor,
    const CRowSeekDescription & rSeekDesc,
    CGetRowsParams &            rGetRowsParams,
    XPtr<CRowSeekDescription> & pSeekDescOut)
{
    tbDebugOut(( DEB_PROXY,
                 "GetRows 0x%x\n",
                 rGetRowsParams.RowsToTransfer() ));

    unsigned cbSeek = rSeekDesc.MarshalledSize();
    unsigned cbInput = sizeof CPMGetRowsIn + cbSeek;
    unsigned cbReserved = AlignBlock( sizeof CPMGetRowsOut + cbSeek,
                                      sizeof LONGLONG );
    XArray<BYTE> xIn( cbInput );
    CPMGetRowsIn *pRequest = new( xIn.Get() )
                             CPMGetRowsIn( hCursor,
                                           rGetRowsParams.RowsToTransfer(),
                                           rGetRowsParams.GetFwdFetch(),
                                           rGetRowsParams.GetRowWidth(),
                                           cbSeek,
                                           cbReserved );
    // serialize the seek description

    CMemSerStream stmMem( pRequest->GetDesc(), cbSeek );
    rSeekDesc.Marshall( stmMem );

    // Make an allocator for the output.  Scale the buffer size based
    // on the # of rows to be retrieved (just a heuristic).  Large buffers
    // are more expensive since the entire buffer must be sent over the
    // pipe (since var data grows down from the end of the buffer).

    // For 10 rows in a typical web query, it takes about 7-10k.  Any way
    // to squeeze it so it always fits in 8k?  Eg:
    // filename,size,characterization,vpath,doctitle,write
    // filename -- 20
    // abstract -- 640
    // props+variants -- 16*6
    // vpath -- 100
    // title -- 80
    // total: 936 * 10 rows = 9360 bytes

    const unsigned cbGetRowsGranularity = 512;
    const unsigned cbBigRow = 1000;
    const unsigned cbNormalRow = 300;
    unsigned cbOut = rGetRowsParams.RowsToTransfer() * cbBigRow;
    cbOut = __max( rGetRowsParams.GetRowWidth(), cbOut );
    cbOut = __min( cbOut, cbMaxProxyBuffer );
    XArray<BYTE> xOut;

    // loop until at least 1 row fits in a buffer

    CPMGetRowsOut *pReply = 0;
    NTSTATUS Status = 0;
    DWORD cbRead;
    do
    {
        cbOut = AlignBlock( cbOut, cbGetRowsGranularity );
        Win4Assert( cbOut <= cbMaxProxyBuffer );
        xOut.ReSize( cbOut );

        pReply = (CPMGetRowsOut *) xOut.GetPointer();
        pRequest->SetReadBufferSize( cbOut );

#ifdef _WIN64
        //
        // If a Win64 client is talking to a Win32 server set the base in the sent
        // buffer to 0 so that the values returned are offsets and remember what the
        // real pointer is.
        // Otherwise, be sure to set the reply base pointer to zero to indicate to the
        // rowset that no munging has to be done.
        //
       if ( !_client.IsServer64() )
       {
            pRequest->SetClientBase ( 0 );
            rGetRowsParams.SetReplyBase ( (BYTE *) pReply );
       }
       else
       {
            pRequest->SetClientBase( (ULONG_PTR) pReply );
       }
#else 
        pRequest->SetClientBase( (ULONG_PTR) pReply );
#endif

        pRequest->SetCheckSum( cbInput );

        TRY
        {
            _client.DataWriteRead( pRequest,
                                   cbInput,
                                   pReply,
                                   cbOut,
                                   cbRead );

            Status = pReply->GetStatus();
        }
        CATCH( CException, e )
        {
            Status = e.GetErrorCode();
        }
        END_CATCH;
    } while ( ( Status == STATUS_BUFFER_TOO_SMALL ) &&
              ( cbOut++ < cbMaxProxyBuffer ) );

    prxDebugOut(( DEB_ITRACE, "Status at end of getrows: 0x%x\n", Status ));
    Win4Assert( pReply == (CPMGetRowsOut *) xOut.GetPointer() );

    SCODE scResult = 0;

    if ( NT_SUCCESS( Status ) )
    {
        rGetRowsParams.SetRowsTransferred( pReply->RowsReturned() );

        CMemDeSerStream stmDeser( pReply->GetSeekDesc(), cbReserved );
        UnmarshallRowSeekDescription( stmDeser,
                                      _client.GetServerVersion(),
                                      pSeekDescOut,
                                      TRUE );

        // Hand off the block to the allocator made in CRowset

        Win4Assert( pReply == (CPMGetRowsOut *) xOut.GetPointer() );
        PFixedVarAllocator & rAlloc = rGetRowsParams.GetFixedVarAllocator();
        rAlloc.ReInit( TRUE, cbReserved, xOut.Acquire(), cbOut );

        // we have pointers already, not offsets

        rAlloc.SetBase( 0 );

        scResult = Status;  // ok, endOfRowset, blockLimitedRows, etc.
    }
    else
    {
        if ( DB_E_BADRATIO != Status && DB_E_BADSTARTPOSITION != Status) {
            prxDebugOut(( DEB_ERROR, "GetRows returned 0x%x\n", Status ));
        }

        if ( NT_WARNING( Status ) )
            scResult = Status;      // presumably, status is an SCODE
        else
            scResult = E_FAIL;
    }

    return scResult;
} //GetRows

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::ReExecuteSequentialQuery, private
//
//  Synopsis:   Simulates re-execution of a sequential query by shutting down
//              the query object on the server, recreating it and setting up
//              the bindings from cached values
//
//  Arguments:
//
//  History:    02-28-98    danleg      Created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::ReExecuteSequentialQuery()
{
    tbDebugOut(( DEB_PROXY, "ReExecuteSequentialQuery\n" ));

    // SPECDEVIATION: if we have heirarchical rowsets, all current positions
    // will be reset.

    //
    // Shutdown the existing PQuery on the server first
    //
    for ( unsigned i=0; i<_aCursors.Count(); i++ )
        FreeCursor( _aCursors[i] );

    //
    // Recreate PQuery on the server
    //
    CPMCreateQueryIn * pCreateReq =  (CPMCreateQueryIn *) _xQuery.Get();

    const unsigned cbCursors = sizeof ULONG * _aCursors.Count();
    const unsigned cbReply = sizeof CPMCreateQueryOut + cbCursors;

    XGrowable<BYTE, 200> xReply( cbReply );
    CPMCreateQueryOut * pReply = new( xReply.Get() ) CPMCreateQueryOut();

    ULONG cbRead;
    _client.DataWriteRead( pCreateReq,
                           _xQuery.SizeOf(),
                           pReply,
                           cbReply,
                           cbRead );

    // DataWriteRead throws both connection problems and request problems
    Win4Assert( SUCCEEDED( pReply->GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || cbReply == cbRead );

    _fTrueSequential = pReply->IsTrueSequential();
    _fWorkIdUnique = pReply->IsWorkIdUnique();
    _ulServerCookie = pReply->GetServerCookie();

    RtlCopyMemory( _aCursors.Get(), pReply->GetCursors(), _aCursors.Count() );

    //
    // Recreate bindings
    //
    CProxyMessage reply;
    CPMSetBindingsIn *pBindReq = (CPMSetBindingsIn *) _xBindings.Get();

    ULONG cbRequest = sizeof CPMSetBindingsIn + pBindReq->GetBindingDescLength();
    cbRequest = AlignBlock( cbRequest, sizeof ULONG );

    _client.DataWriteRead( pBindReq,
                           cbRequest,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

} // ReExecuteSequentialQuery

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::RestartPosition, public
//
//  Synopsis:   Reset the fetch position for the chapter back to the start
//
//  Arguments:  [hCursor]       - handle of the cursor
//              [chapt]         - chapter
//
//  History:    17 Apr 97   emilyb      created
//              02-01-98    danleg      restart for seq queries
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::RestartPosition(
    ULONG        hCursor,
    CI_TBL_CHAPT chapt )
{
    tbDebugOut(( DEB_PROXY, "RestartPosition\n" ));

    //
    // If sequential, re-execute the query
    //
    if ( _fTrueSequential )
        ReExecuteSequentialQuery();
    else
    {
        CPMRestartPositionIn request( hCursor, chapt );
        CProxyMessage reply;
        DWORD cbRead;
        _client.DataWriteRead( &request,
                               sizeof request,
                               &reply,
                               sizeof reply,
                               cbRead );

        Win4Assert( SUCCEEDED( reply.GetStatus() ) );
        Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
    }
} //RestartPosition

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::StopAsync, public
//
//  Synopsis:   Stop processing of async rowset
//
//  Arguments:  [hCursor]       - handle of the cursor
//
//  History:    17 Apr 97  emilyb   created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::StopAsynch(
    ULONG        hCursor )
{
    tbDebugOut(( DEB_PROXY, "Stop\n" ));

    CPMStopAsynchIn request( hCursor );
    CProxyMessage reply;
    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //StopAsynch

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::StartWatching, public
//
//  Synopsis:   Start watch all behavior for rowset
//
//  Arguments:  [hCursor]       - handle of the cursor
//
//  History:    17 Apr 97  emilyb   created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::StartWatching(
    ULONG        hCursor )
{
    tbDebugOut(( DEB_PROXY, "StartWatching\n" ));

    CPMStartWatchingIn request( hCursor );
    CProxyMessage reply;
    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //StartWatching

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::StopWatching, public
//
//  Synopsis:   Stop watch all behavior for rowset
//
//  Arguments:  [hCursor]       - handle of the cursor
//
//  History:    17 Apr 97  emilyb   created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::StopWatching(
    ULONG        hCursor )
{
    tbDebugOut(( DEB_PROXY, "StopWatching\n" ));

    CPMStopWatchingIn request( hCursor );
    CProxyMessage reply;
    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //StopWatching

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [hCursor]        - handle of the cursor to check
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator]   - on return, numerator of fraction
//              [rcRows]         - on return, number of rows in cursor
//              [rfNewRows]      - on return, TRUE if new rows available
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::RatioFinished(
    ULONG   hCursor,
    DBCOUNTITEM & rulDenominator,
    DBCOUNTITEM & rulNumerator,
    DBCOUNTITEM & rcRows,
    BOOL &  rfNewRows )
{
    tbDebugOut(( DEB_PROXY, "RatioFinished\n" ));
    SCODE sc = S_OK;

    CPMRatioFinishedIn request( hCursor, TRUE );
    CPMRatioFinishedOut reply;
    DWORD cbReply;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbReply );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbReply );

    rulDenominator = reply.Denominator();
    rulNumerator = reply.Numerator();
    rcRows = reply.RowCount();
    rfNewRows = reply.NewRows();

    // the values must be good by now or we would have thrown

    Win4Assert( 0 != rulDenominator );
    Win4Assert( rulDenominator >= rulNumerator );
} //RatioFinished

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::RatioFinished, public
//
//  Synopsis:   Return the completion status as a fraction
//
//  Arguments:  [rSync]          - notification synchronization info
//              [hCursor]        - handle of the cursor to check
//              [rulDenominator] - on return, denominator of fraction
//              [rulNumerator]   - on return, numerator of fraction
//              [rcRows]         - on return, number of rows in cursor
//              [rfNewRows]      - on return, TRUE if new rows available
//
//  Returns:    S_OK or STATUS_CANCELLED if rSync's cancel event signalled.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

SCODE CSvcQueryProxy::RatioFinished(
    CNotificationSync & rSync,
    ULONG   hCursor,
    DBCOUNTITEM & rulDenominator,
    DBCOUNTITEM & rulNumerator,
    DBCOUNTITEM & rcRows,
    BOOL &  rfNewRows )
{
    tbDebugOut(( DEB_PROXY, "RatioFinished\n" ));
    SCODE sc = S_OK;

    CPMRatioFinishedIn request( hCursor, TRUE );
    CPMRatioFinishedOut reply;
    DWORD cbReply;
    if ( _client.NotifyWriteRead( rSync.GetCancelEvent(),
                                  &request,
                                  sizeof request,
                                  &reply,
                                  sizeof reply,
                                  cbReply ) )
        sc = STATUS_CANCELLED;
    else
    {
        Win4Assert( SUCCEEDED( reply.GetStatus() ) );
        Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbReply );

        rulDenominator = reply.Denominator();
        rulNumerator = reply.Numerator();
        rcRows = reply.RowCount();
        rfNewRows = reply.NewRows();

        // the values must be good by now or we would have thrown

        Win4Assert( 0 != rulDenominator );
        Win4Assert( rulDenominator >= rulNumerator );
    }
    return sc;
} //RatioFinished (notify version)

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::Compare, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor]       - handle of the cursor used to compare
//              [chapt]         - chapter of bookmarks
//              [bmkFirst]      - First bookmark to compare
//              [bmkSecond]     - Second bookmark to compare
//              [rdwComparison] - on return, comparison value
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::Compare(
    ULONG        hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmkFirst,
    CI_TBL_BMK   bmkSecond,
    DWORD &      rdwComparison )
{
    tbDebugOut(( DEB_PROXY, "Compare\n" ));

    CPMCompareBmkIn request( hCursor, chapt, bmkFirst, bmkSecond );
    CPMCompareBmkOut reply;

    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    rdwComparison = reply.Comparison();
} //Compare

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetApproximatePosition, public
//
//  Synopsis:   Return the approximate current position as a fraction
//
//  Arguments:  [hCursor]        - cursor handle used to retrieve info
//              [chapt]          - chapter requested
//              [bmk]            - table bookmark for position
//              [pulNumerator]   - on return, numerator of fraction
//              [pulDenominator] - on return, denominator of fraction
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetApproximatePosition(
    ULONG        hCursor,
    CI_TBL_CHAPT chapt,
    CI_TBL_BMK   bmk,
    DBCOUNTITEM * pulNumerator,
    DBCOUNTITEM * pulDenominator )
{
    tbDebugOut(( DEB_PROXY, "GAP\n" ));

    CPMGetApproximatePositionIn request( hCursor, chapt, bmk );
    CPMGetApproximatePositionOut reply;

    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    *pulNumerator = reply.Numerator();
    *pulDenominator = reply.Denominator();
} //GetApproximatePosition

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::SetBindings, public
//
//  Synopsis:   Set column bindings into a cursor
//
//  Arguments:  [hCursor]     - handle of the cursor to set bindings on
//              [cbRowLength] - the width of an output row
//              [cols]        - a description of column bindings to be set
//              [pids]        - a PID mapper which maps fake pids in cols to
//                              column IDs.
//
//  History:    13 Sept 96  dlee created
//              22 Aug 99   klam Win64 client -> Win32 server
//              09 Feb 2000 KLam Win64: Reset variant size when done
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::SetBindings(
    ULONG             hCursor,
    ULONG             cbRowLength,
    CTableColumnSet & cols,
    CPidMapper &      pids )
{
    tbDebugOut(( DEB_PROXY, "SetBindings\n" ));

#ifdef _WIN64

    // WIN64 client and servers mark the low bit of the hi-word of the
    // version to indicate it is a 64 bit machine.

    if ( !_client.IsServer64() )
    {
        tbDebugOut(( DEB_PROXY, "64bit client querying 32bit server!\n" ));

        // If there is a PROPVARIANT stored, adjust its size
      
        for (unsigned i = 0; i < cols.Count(); i++)
        {
            CTableColumn *pColumn = cols.Get(i);
            tbDebugOut(( DEB_PROXY, "\tFound type: %d width: %d\n",pColumn->GetStoredType(), pColumn->GetValueSize())); 
            if ( VT_VARIANT == pColumn->GetStoredType() )
            {
                pColumn->SetValueField( VT_VARIANT,
                                        pColumn->GetValueOffset(),
                                        SizeOfWin32PROPVARIANT );

                tbDebugOut(( DEB_PROXY, "\tReplacing variant with size %d and offset 0x%x \n", 
                             SizeOfWin32PROPVARIANT, pColumn->GetValueOffset() ));
            }
        }
    }

#endif

    // determine the size of the serialized column set

    CSizeSerStream stmSize;
    cols.Marshall( stmSize, pids );
    ULONG cbRequest = sizeof CPMSetBindingsIn + stmSize.Size();
    cbRequest = AlignBlock( cbRequest, sizeof ULONG );

    XArray<BYTE> xIn( cbRequest );
    CPMSetBindingsIn *pRequest = new( xIn.Get() )
                                 CPMSetBindingsIn( hCursor,
                                                   cbRowLength,
                                                   stmSize.Size() );

    // serialize the column set

    CMemSerStream stmMem( pRequest->GetDescription(), stmSize.Size() );
    cols.Marshall( stmMem, pids );

    pRequest->SetCheckSum( cbRequest );

    CProxyMessage reply;
    DWORD cbRead;

    _client.DataWriteRead( pRequest,
                           cbRequest,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

#ifdef _WIN64

    if ( !IsCi64(_client.GetServerVersion()) )
    {
        tbDebugOut(( DEB_PROXY, "...64bit client finished querying 32bit server.\n" ));

        //
        // If there is a PROPVARIANT stored, readjust its size back to its original size
        //
        for (unsigned i = 0; i < cols.Count(); i++)
        {
            CTableColumn *pColumn = cols.Get(i);
            tbDebugOut(( DEB_PROXY, "\tFound type: %d width: %d\n",pColumn->GetStoredType(), pColumn->GetValueSize())); 
            if ( VT_VARIANT == pColumn->GetStoredType() )
            {
                pColumn->SetValueField( VT_VARIANT,
                                        pColumn->GetValueOffset(),
                                        sizeof ( PROPVARIANT ) );

                tbDebugOut(( DEB_PROXY, "\tReseting variant with size %d and offset 0x%x \n", 
                             sizeof ( PROPVARIANT ), pColumn->GetValueOffset() ));
            }
        }
    }

#endif

    //
    // Preserve binding stream if sequential for RestartPosition
    //
    if ( _fTrueSequential )
    {
        unsigned cElems = xIn.Count();
        _xBindings.Set( cElems, xIn.Acquire() );
    }

} //SetBindings

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetNotifications, public
//
//  Synopsis:   Gets notification information, when available.
//
//  Arguments:  [rSync]      -- notification synchronization info
//              [changeType] -- returns notification data info
//
//  Returns:    S_OK or STATUS_CANCELLED if rSync's cancel event signalled.
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

SCODE CSvcQueryProxy::GetNotifications(
    CNotificationSync & rSync,
    DBWATCHNOTIFY     & changeType)
{
    tbDebugOut(( DEB_PROXY, "GetNotifications\n" ));
    SCODE sc = S_OK;

    CProxyMessage request( pmGetNotify );
    CPMSendNotifyOut reply(0);
    DWORD cbReply;

    if ( _client.NotifyWriteRead( rSync.GetCancelEvent(),
                                  &request,
                                  sizeof request,
                                  &reply,
                                  sizeof reply,
                                  cbReply ) )
        sc = STATUS_CANCELLED;
    else
        changeType = reply.WatchNotify();

    tbDebugOut(( DEB_PROXY, "GetNotifications %d, sc %lx\n", changeType, sc ));
    return sc;
} //GetNotifications

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::SetWatchMode
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [phRegion] - in/out region handle
//              [mode]     - watch mode
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::SetWatchMode(
    HWATCHREGION * phRegion,
    ULONG          mode )
{
    tbDebugOut (( DEB_PROXY, "Calling SetWatchMode\n" ));

    CPMSetWatchModeIn request( *phRegion, mode );
    CPMSetWatchModeOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    *phRegion = reply.Region();
} //SetWatchMode

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetWatchInfo
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion]   -- handle to watch region
//              [pMode]     -- watch mode
//              [pChapter]  -- chapter
//              [pBookmark] -- bookmark
//              [pcRows]    -- number of rows
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetWatchInfo (
    HWATCHREGION   hRegion,
    ULONG *        pMode,
    CI_TBL_CHAPT * pChapter,
    CI_TBL_BMK *   pBookmark,
    DBCOUNTITEM *  pcRows)
{
    tbDebugOut (( DEB_PROXY, "Calling GetWatchInfo\n" ));

    // prepare for failure

    *pBookmark = 0;
    *pChapter = 0;
    *pMode = 0;
    *pcRows = 0;

    CPMGetWatchInfoIn request( hRegion );
    CPMGetWatchInfoOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    *pMode = reply.Mode();
    *pChapter = reply.Chapter();
    *pBookmark = reply.Bookmark();
    *pcRows = reply.RowCount();
} //GetWatchInfo

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::ShrinkWatchRegion
//
//  Synopsis:   Stub implementation
//
//  Arguments:  [hRegion]  -- handle to watch region
//              [chapter]  -- chapter
//              [bookmark] -- size of bookmark
//              [cRows]    -- number of rows
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::ShrinkWatchRegion (
    HWATCHREGION hRegion,
    CI_TBL_CHAPT chapter,
    CI_TBL_BMK   bookmark,
    LONG         cRows )
{
    tbDebugOut (( DEB_PROXY, " Calling ShrinkWatchRegion\n" ));

    CPMShrinkWatchRegionIn request( hRegion, chapter, bookmark, cRows );
    CProxyMessage reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
} //ShrinkWatchRegion

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::Refresh
//
//  Synopsis:   Stub implementation
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::Refresh()
{
    tbDebugOut(( DEB_PROXY, "Refresh\n" ));

    CProxyMessage request( pmRefresh );
    CProxyMessage reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );
    tbDebugOut(( DEB_PROXY, "Refresh (end)\n" ));
} //Refresh

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetQueryStatus, public
//
//  Synopsis:   Return the query status
//
//  Arguments:  [hCursor]   - handle of the cursor to check
//              [rdwStatus] - on return, the query status
//
//  History:    13 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetQueryStatus(
    ULONG   hCursor,
    DWORD & rdwStatus )
{
    tbDebugOut(( DEB_PROXY, "GetQueryStatus\n" ));

    CPMGetQueryStatusIn request( hCursor );
    CPMGetQueryStatusOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    rdwStatus = reply.QueryStatus();
} //GetQueryStatus

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::GetQueryStatusEx, public
//
//  Synopsis:   Return the query status plus bonus information.  It's kind
//              of an odd assortment of info, but it saves net trips.
//
//  Arguments:  [hCursor] - handle of the cursor to check completion for
//              [rdwStatus] - returns the query status
//              [rcFilteredDocuments] - returns # of filtered docs
//              [rcDocumentsToFilter] - returns # of docs to filter
//              [rdwRatioFinishedDenominator] - ratio finished denom
//              [rdwRatioFinishedNumerator]   - ratio finished num
//              [bmk]                         - bmk to find
//              [riRowBmk]                    - index of bmk row
//              [rcRowsTotal]                 - # of rows in table
//
//  History:    Nov-9-96   dlee    Created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::GetQueryStatusEx(
    ULONG            hCursor,
    DWORD &          rdwStatus,
    DWORD &          rcFilteredDocuments,
    DWORD &          rcDocumentsToFilter,
    DBCOUNTITEM &    rdwRatioFinishedDenominator,
    DBCOUNTITEM &    rdwRatioFinishedNumerator,
    CI_TBL_BMK       bmk,
    DBCOUNTITEM &    riRowBmk,
    DBCOUNTITEM &    rcRowsTotal )
{
    tbDebugOut(( DEB_PROXY, "GetQueryStatusEx\n" ));

    CPMGetQueryStatusExIn request( hCursor, bmk );
    CPMGetQueryStatusExOut reply;
    DWORD cbRead;

    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           sizeof reply,
                           cbRead );

    Win4Assert( SUCCEEDED( reply.GetStatus() ) );
    Win4Assert( _client.IsPipeTracingEnabled() || sizeof reply == cbRead );

    rdwStatus = reply.QueryStatus();
    rcFilteredDocuments = reply.FilteredDocuments();
    rcDocumentsToFilter = reply.DocumentsToFilter();
    rdwRatioFinishedDenominator = reply.RatioFinishedDenominator();
    rdwRatioFinishedNumerator = reply.RatioFinishedNumerator();
    riRowBmk = reply.RowBmk();
    rcRowsTotal = reply.RowsTotal();
} //GetQueryStatusEx

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::FetchDeferredValue, public
//
//  Synopsis:   Returns a property value for a workid from the property cache
//
//  Arguments:  [wid] - workid for which property value is retrieved
//              [ps]] - prop spec identifying value to be retrieved
//              [var] - returns the value if available
//
//  Returns:    TRUE if a value was retrieved or FALSE otherwise
//
//  History:    30 Sept 96  dlee created
//
//--------------------------------------------------------------------------

BOOL CSvcQueryProxy::FetchDeferredValue(
    WORKID                wid,
    CFullPropSpec const & ps,
    PROPVARIANT &         var )
{
    tbDebugOut(( DEB_PROXY, "FetchValue\n" ));
    CLock lock( _mutexFetchValue );

    XArray<BYTE> xValue;
    XArray<BYTE> xResult( cbMaxProxyBuffer );

    // cbChunk is the size of the output buffer including CPMFetchValueOut

    const DWORD cbChunk = cbMaxProxyBuffer;

    // Since the value might be large and each proxy buffer is limited to
    // cbMaxProxyBuffer, iterate until the entire value is retrieved.

    do
    {
        // only send the propspec once

        DWORD cbPropSpec = 0;
        if ( 0 == xValue.SizeOf() )
        {
            CSizeSerStream stmSize;
            ps.Marshall( stmSize );
            cbPropSpec = stmSize.Size();
        }

        ULONG cbRequest = AlignBlock( sizeof CPMFetchValueIn + cbPropSpec,
                                      sizeof ULONG );
        XArray<BYTE> xRequest( cbRequest );
        CPMFetchValueIn *pRequest = new( xRequest.Get() )
            CPMFetchValueIn( wid, xValue.SizeOf(), cbPropSpec, cbChunk );

        if ( 0 == xValue.SizeOf() )
        {
            CMemSerStream stmMem( pRequest->GetPS(), cbPropSpec );
            ps.Marshall( stmMem );
        }

        pRequest->SetCheckSum( xRequest.SizeOf() );

        DWORD cbReply;
        _client.DataWriteRead( pRequest,
                               xRequest.SizeOf(),
                               xResult.Get(),
                               xResult.SizeOf(),
                               cbReply );
        CPMFetchValueOut &result = * (CPMFetchValueOut *) xResult.Get();

        if ( !result.ValueExists() )
            return FALSE;

        // append the next portion of the value

        DWORD cbOld = xValue.SizeOf();
        Win4Assert( 0 != result.ValueSize() );
        xValue.ReSize( cbOld + result.ValueSize() );
        RtlCopyMemory( xValue.Get() + cbOld,
                       result.Value(),
                       result.ValueSize() );

        // all done?

        if ( !result.MoreExists() )
            break;
    } while ( TRUE );

    CCoTaskMemAllocator tbaAlloc;

    StgConvertPropertyToVariant( (SERIALIZEDPROPERTYVALUE *) xValue.Get(),
                                 CP_WINUNICODE,
                                 &var,
                                 &tbaAlloc );
    Win4Assert( (var.vt & 0x0fff) <= VT_CLSID );

    return TRUE;
} //FetchValue

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQueryProxy::WorkIdToPath, public
//
//  Synopsis:   Converts a wid to a path
//
//  Arguments:  [wid]       -- wid to convert
//              [funnyPath] -- resulting path
//
//  History:    30 Sept 96  dlee created
//
//--------------------------------------------------------------------------

void CSvcQueryProxy::WorkIdToPath(
    WORKID          wid,
    CFunnyPath & funnyPath )
{
    tbDebugOut(( DEB_PROXY, "WorkIdToPath\n" ));

    CPMWorkIdToPathIn request( wid );
    XArray<WCHAR> xReply( cbMaxProxyBuffer );
    CPMWorkIdToPathOut &reply = * (CPMWorkIdToPathOut *) xReply.Get();

    DWORD cbRead;
    _client.DataWriteRead( &request,
                           sizeof request,
                           &reply,
                           cbMaxProxyBuffer,
                           cbRead );
    Win4Assert( SUCCEEDED( reply.GetStatus() ) );

    if ( reply.Any() )
    {
        funnyPath.SetPath( reply.Path() );
    }
} //WorkIdToPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tablecur.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1994.
//
//  File:       tablecur.cxx
//
//  Contents:   Large table row cursor
//
//  Classes:    CTableCursor - basic row cursor
//              CTableCursorSet - set of row cursors
//
//  Functions:
//
//  History:    16 Jun 1994     AlanW    Created
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <query.hxx>            // SBindSizes
#include <tblvarnt.hxx>

#include "tblrowal.hxx"
#include "tabledbg.hxx"

//
//  Generate the implementation of the cursor set base class
//
IMPL_DYNARRAY( CTableCursorArray, CTableCursor )


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursor::CTableCursor, public
//
//  Synopsis:   Constructor for a table cursor
//
//  Notes:      
//
//--------------------------------------------------------------------------

CTableCursor::CTableCursor( void ) :
    _hUnique( 0 ),
    _cbRowWidth( 0 ),
    _BoundColumns( 0 )
{
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursor::~CTableCursor, public
//
//  Synopsis:   Destructor for a table cursor
//
//  Notes:      
//
//--------------------------------------------------------------------------

CTableCursor::~CTableCursor( void )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableCursor::SetBindings, public
//
//  Synopsis:   Set new column bindings on the cursor
//
//  Arguments:  [cbRowLength] - width of output rows
//              [NewColumns] - CTableColumnSet giving new bindings
//
//  Returns:    SCODE - S_OK if succeeded, E_FAIL if cbRowLength exceeds
//                      length we're willing to transfer, otherwise according
//                      to spec.
//
//  Notes:      
//
//----------------------------------------------------------------------------

SCODE
CTableCursor::SetBindings(
    ULONG                   cbRowLength,
    XPtr<CTableColumnSet> & NewColumns
) {
    //
    //  Do some simple checks first
    //
    if (0 == cbRowLength || cbRowLength > TBL_MAX_OUTROWLENGTH)
        return E_INVALIDARG;            // provider-specific error

    //
    // Check bindings in case they have been hacked.  Ordinarily, it would
    // be a bug if they were wrong.
    // Check that each column is valid and doesn't overlap some other
    // column.
    //
    {
        CTableRowAlloc RowMap(cbRowLength);

        SCODE scResult = _CheckBindings(NewColumns.GetReference(),
                                        RowMap,
                                        (USHORT) cbRowLength);
         
        if (FAILED(scResult))
            return scResult;
    }

    //
    //  All the proposed bindings check out.  Set them as the
    //  currently bound columns, and delete any old bindings.
    //
    unsigned iNewCol = 0;

    CTableColumnSet * pOldCols = _BoundColumns.Acquire();
    _BoundColumns.Set( NewColumns.Acquire() );
    delete pOldCols;

    _cbRowWidth = (USHORT) cbRowLength;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursor::_CheckBinding, public
//              CTableCursor::_CheckBindings, public
//
//  Synopsis:   Check that a column binding is legal.  _CheckBindings does
//              the same for an entire set of column bindings.
//
//  Arguments:  [rCol] - A reference to the column binding to be checked
//              [rRowAlloc] - a reference to a row allocation map
//              [maxRow] - maximum allowed size of a row
//
//  Returns:    SCODE - S_OK if no problems, otherwise the appropriate
//                      error code for the failure.
//
//  Notes:      
//
//--------------------------------------------------------------------------


SCODE   CTableCursor::_CheckBinding(
    CTableColumn const & rCol,
    CTableRowAlloc& rRowAlloc,
    USHORT maxRow
) {

    //
    //  Check some static things about the binding structure
    //
    if (0 == rCol.IsValueStored() &&
        0 == rCol.IsStatusStored() &&
        0 == rCol.IsLengthStored() )
    {
        tbDebugOut((DEB_IWARN,
          "CTableCursor::_CheckBinding - no value, length or status stored\n"));
        return DB_E_BADBINDINFO;
    }

    ULONG cbData = rCol.GetValueSize();

    USHORT cbWidth, cbAlign, gfFlags;

    //
    //  Look up required width of field.
    //
    CTableVariant::VartypeInfo(rCol.GetStoredType(), cbWidth, cbAlign, gfFlags);
    if (cbData != cbWidth && !(gfFlags & CTableVariant::MultiSize))
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - incorrect field width\n"));
        return DB_E_BADBINDINFO;
    }

    if ( rCol.GetStoredType() & VT_VECTOR )
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - direct vector\n"));
        return DB_E_BADBINDINFO;
    }

    if (rCol.GetValueOffset() + cbData > maxRow)
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - bad data offset\n"));
        return DB_E_BADBINDINFO;
    }

    if (rCol.IsStatusStored() &&
        rCol.GetStatusOffset() + rCol.GetStatusSize() > maxRow)
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - bad status offset\n"));
        return DB_E_BADBINDINFO;
    }

    if (rCol.IsLengthStored() &&
        rCol.GetLengthOffset() + rCol.GetLengthSize() > maxRow)
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - bad length offset\n"));
        return DB_E_BADBINDINFO;
    }

    //
    //  Check to see if any fields overlap with previously allocated ones
    //
    if (rCol.IsValueStored() &&
        ! rRowAlloc.ReserveRowSpace( rCol.GetValueOffset(), cbData ))
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - value data overlap\n"));
        return DB_E_BADBINDINFO;
    }

    if (rCol.IsStatusStored() &&
        ! rRowAlloc.ReserveRowSpace( rCol.GetStatusOffset(), rCol.GetStatusSize() ))
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - status data overlap\n"));
        return DB_E_BADBINDINFO;
    }

    if (rCol.IsLengthStored() &&
        ! rRowAlloc.ReserveRowSpace( rCol.GetLengthOffset(), rCol.GetLengthSize() ))
    {
        tbDebugOut((DEB_IWARN, "CTableCursor::_CheckBinding - length data overlap\n"));
        return DB_E_BADBINDINFO;
    }

    return S_OK;
}

SCODE   CTableCursor::_CheckBindings(
    CTableColumnSet const & rCols,
    CTableRowAlloc& rRowAlloc,
    USHORT maxRow
) {
    Win4Assert(maxRow > 0);

    for (unsigned i = 0; i < rCols.Count(); i++)
    {
        SCODE sc = _CheckBinding(*rCols.Get(i), rRowAlloc, maxRow);
        if (FAILED(sc))
            return sc;
    }
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursorSet::~CTableCursorSet, public
//
//  Synopsis:   Destroy a table cursor set
//
//  Arguments:  [hCursor] -- The handle of the cursor to be looked up
//
//  Returns:    - nothing -
//
//  Notes:      
//
//--------------------------------------------------------------------------


CTableCursorSet::~CTableCursorSet( )
{
#if CIDBG
    for (unsigned i = 0; i < Size(); i++) {
        if (Get(i) && Get(i)->_hUnique != 0) {
            tbDebugOut((DEB_WARN, "Unreleased table cursor\n"));
        }
    }
#endif // CIDBG
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursorSet::Lookup, public
//
//  Synopsis:   Find a table cursor given its handle
//
//  Arguments:  [hCursor] -- The handle of the cursor to be looked up
//
//  Returns:    CTableCursor& - reference to cursor
//
//  Signals:    Throws E_FAIL if error.
//
//  Notes:      
//
//--------------------------------------------------------------------------

CTableCursor&
CTableCursorSet::Lookup( ULONG hCursor )
{
    USHORT iCursor = (USHORT) (hCursor & 0xFFFF);
    USHORT hUnique = (USHORT) (hCursor >> 16);

    Win4Assert(hUnique > 0 && iCursor < Size());

    if (hUnique == 0 || iCursor >= Size()) {
        THROW(CException(E_FAIL));
    }

    if (Get(iCursor) == 0 || Get(iCursor)->_hUnique != hUnique)
        THROW(CException(E_FAIL));
    
    return *Get(iCursor);
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursorSet::Add, public
//
//  Synopsis:   Add a table cursor to a table cursor set. 
//
//  Arguments:  [pCursorIn] -- A pointer to the cursor description to be
//                              added.
//              [rhCursor] -- on return, the handle value assigned to the
//                              cursor.
//
//  Returns:    -Nothing-
//
//  Notes:      
//
//--------------------------------------------------------------------------

void
CTableCursorSet::Add( CTableCursor * const pCursorIn, ULONG &rhCursor )
{
    //
    //  Find an unused handle uniquifier.  The for loop may be
    //  overkill since we also use the array index in the real handle.
    //
    USHORT hUnique;

    do {
        hUnique = ++_hKeyGenerator;
        if (hUnique == 0)
            continue;

        for (unsigned j = 0; j < Size(); j++) {
            if (Get(j) && hUnique == Get(j)->_hUnique) {
                hUnique = 0;
                break;          // break for, continue do-while
            }
        }
    } while (hUnique == 0);

    unsigned i;

    for (i = 0; i < Size(); i++) {
        if ( Get(i) == 0 )
            break;
    }

    //
    //  Add the new entry to the set.  
    //

    pCursorIn->_hUnique = hUnique;
    CTableCursorArray::Add(pCursorIn, i);

    Win4Assert( i < 0x10000 );
    rhCursor = (hUnique << 16) | i;

    return;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTableCursorSet::Release, public
//
//  Synopsis:   Free an allocated table cursor
//
//  Arguments:  [hCursor] -- The handle of the cursor to be released
//
//  Returns:    SCODE - S_OK if lookup succeeded, E_FAIL if problems.
//
//  Notes:      
//
//--------------------------------------------------------------------------

SCODE
CTableCursorSet::Release(ULONG hCursor)
{
    USHORT iCursor = (USHORT) (hCursor & 0xFFFF);
    USHORT hUnique = (USHORT) (hCursor >> 16);

    Win4Assert(hUnique > 0 && iCursor < Size());

    if (hUnique == 0 || iCursor >= Size() || Get(iCursor) == 0) {
        return E_FAIL;
    }

    CTableCursor * pCursor = Get(iCursor);
    if (pCursor->_hUnique != hUnique)
        return E_FAIL;
    
    //
    //  Found the cursor, now free it and its location in the array.
    //
    pCursor = CTableCursorArray::Acquire( iCursor );
    delete pCursor;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CTableCursorSet::Count, public
//
//  Synopsis:   Counts the number of cursors in the set
//
//  Returns:    # of cursors in the set
//
//--------------------------------------------------------------------------

unsigned CTableCursorSet::Count()
{
    unsigned cCursors = 0;

    for ( unsigned i = 0; i < Size(); i++)
    {
        if ( 0 != Get(i) )
            cCursors++;
    }

    return cCursors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\bigtable\tblalloc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000
//
//  File:       tblalloc.cxx
//
//  Contents:   Memory allocation wrappers for large tables
//
//  Classes:    CWindowDataAllocator - data allocator for window var data
//              CFixedVarAllocator - data allocator for fixed and var data
//
//  Functions:  TblPageAlloc - Allocate page-alligned memory
//              TblPageRealloc - reallocate page-alligned memory to new size
//              TblPageDealloc - deallocate page-alligned memory
//
//  History:    14 Mar 1994     AlanW    Created
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include <tblalloc.hxx>

#include "tabledbg.hxx"


//+-------------------------------------------------------------------------
//
//  Function:   TblPageAlloc, public
//
//  Synopsis:   Allocate page-alligned memory
//
//  Effects:    The memory allocation counter is incremented.
//              rcbSizeNeeded is adjusted on return to indicate the
//              size of the allocated memory.
//
//  Arguments:  [rcbSizeNeeded] - required size of memory area
//              [rcbPageAllocTracker] - memory allocation counter
//              [ulSig] - signature of the memory (optional)
//
//  Returns:    PVOID - pointer to the allocated memory.  Throws
//                      E_OUTOFMEMORY on allocation failure.
//
//  Notes:      rcbSizeNeeded is set to the minimum required size
//              needed.  TblPageGrowSize can be called to grow an
//              existing memory region.
//
//              If ulSig is non-zero, the beginning of the allocated
//              block is initialized with a signature block which
//              identifies the caller, and which gives the size of the
//              memory block.  In this case, the returned pointer is
//              advanced beyond the signature block.
//
//--------------------------------------------------------------------------

PVOID   TblPageAlloc(
    ULONG&      rcbSizeNeeded,
    ULONG&      rcbPageAllocTracker,
    ULONG const ulSig
) {
    ULONG       cbSize = rcbSizeNeeded +
                         (ulSig != 0) * sizeof (TBL_PAGE_SIGNATURE);
    BYTE*       pbAlloc = 0;

    Win4Assert(cbSize && (cbSize & TBL_PAGE_MASK) == 0);

    if (cbSize == 0)
        cbSize++;
    if ((cbSize & TBL_PAGE_MASK) != 0) {
        cbSize = (cbSize + TBL_PAGE_MASK) & ~TBL_PAGE_MASK;
    }

    if (cbSize < TBL_PAGE_MAX_SEGMENT_SIZE)
    {
        pbAlloc = (BYTE *)VirtualAlloc( 0,
                                        TBL_PAGE_MAX_SEGMENT_SIZE,
                                        MEM_RESERVE,
                                        PAGE_READWRITE);
        if ( 0 == pbAlloc )
            THROW(CException(E_OUTOFMEMORY));

        pbAlloc = (BYTE *)VirtualAlloc( pbAlloc,
                                        cbSize,
                                        MEM_COMMIT,
                                        PAGE_READWRITE);
    }
    else
    {
        pbAlloc = (BYTE *)VirtualAlloc( 0,
                                        cbSize,
                                        MEM_COMMIT,
                                        PAGE_READWRITE);
    }

    if (pbAlloc == 0)
        THROW(CException(E_OUTOFMEMORY));

    Win4Assert( (((ULONG_PTR)pbAlloc) & TBL_PAGE_MASK) == 0 );
    rcbPageAllocTracker += cbSize;

    if (ulSig)
    {
        TBL_PAGE_SIGNATURE * pSigStruct = (TBL_PAGE_SIGNATURE *) pbAlloc;

        pSigStruct->ulSig = ulSig;
        pSigStruct->cbSize = cbSize;
        pSigStruct->pbAddr = pbAlloc;
#if CIDBG
        PVOID CallersCaller;
        RtlGetCallersAddress(&pSigStruct->pCaller, &CallersCaller);
#else
        pSigStruct->pCaller = 0;
#endif // CIDBG

        pbAlloc = (BYTE *) ++pSigStruct;
        cbSize -= sizeof (TBL_PAGE_SIGNATURE);
    }
    rcbSizeNeeded = cbSize;

    return pbAlloc;
}


//+-------------------------------------------------------------------------
//
//  Function:   TblPageRealloc, public
//
//  Synopsis:   Re-allocate page-alligned memory
//
//  Effects:    The memory allocation counter is incremented.
//              Memory is committed or decommitted to the required size.
//
//  Arguments:  [rcbSizeNeeded] - required size of memory area
//              [rcbPageAllocTracker] - memory allocation counter
//              [cbNewSize] - required size of memory area
//              [cbOldSize] - current size of memory area
//
//  Returns:    PVOID - pointer to the allocated memory.  Throws
//                      E_OUTOFMEMORY on allocation failure.
//
//  Notes:      cbOldSize need not be supplied if the memory area
//              begins with a signature block.  In this case, the
//              pbMem passed in should point to beyond the signature
//              block, and the cbNewSize should not include the size
//              of the signature block.
//
//              Not available in Kernel.  Although VirtualAlloc
//              functionality is not available in the kernel, we
//              could do a poor man's realloc by optimistically
//              assuming that a page allocation would be contiguous
//              with the existing page, then setting some mark in
//              the page header that multiple frees need to be done
//              on the segment.
//
//--------------------------------------------------------------------------

PVOID   TblPageRealloc(
    PVOID       pbMem,
    ULONG&      rcbPageAllocTracker,
    ULONG       cbNewSize,
    ULONG       cbOldSize
) {
    BYTE* pbAlloc = (BYTE *)pbMem;
    TBL_PAGE_SIGNATURE * pSigStruct = 0;

    ULONG cbPageOffset = (ULONG)(((ULONG_PTR)pbMem) & TBL_PAGE_MASK);

    Win4Assert(cbPageOffset == 0 ||
               cbPageOffset == sizeof (TBL_PAGE_SIGNATURE));

    if (cbPageOffset == sizeof (TBL_PAGE_SIGNATURE))
    {
        pSigStruct = (TBL_PAGE_SIGNATURE *)
                ((BYTE*)pbMem - sizeof (TBL_PAGE_SIGNATURE));

        Win4Assert (pSigStruct->ulSig != 0 &&
                pSigStruct->cbSize >= TBL_PAGE_ALLOC_MIN &&
                pSigStruct->pbAddr == (BYTE *)pSigStruct &&
                cbOldSize == 0);

        cbOldSize = pSigStruct->cbSize;

        Win4Assert(((cbNewSize + sizeof (TBL_PAGE_SIGNATURE)) & TBL_PAGE_MASK) ==
                                0);
        cbNewSize += sizeof (TBL_PAGE_SIGNATURE);
        pbAlloc -= sizeof (TBL_PAGE_SIGNATURE);
    }

    if (cbNewSize > cbOldSize)
    {
        if (0 == VirtualAlloc(pbAlloc + cbOldSize,
                              cbNewSize - cbOldSize,
                              MEM_COMMIT,
                              PAGE_READWRITE))
            THROW(CException(E_OUTOFMEMORY));

        rcbPageAllocTracker += (cbNewSize - cbOldSize);
    }
    else
    {
        VirtualFree(pbAlloc + cbNewSize, cbOldSize-cbNewSize, MEM_DECOMMIT);
        rcbPageAllocTracker -= (cbOldSize - cbNewSize);
    }

    if (pSigStruct) {
        pSigStruct->cbSize = cbNewSize;
        pbAlloc += sizeof (TBL_PAGE_SIGNATURE);
    }
    return (PVOID)pbMem;
}

//+-------------------------------------------------------------------------
//
//  Function:   TblPageDealloc, public
//
//  Synopsis:   Deallocate page-alligned memory
//
//  Effects:    The memory allocation counter is decremented
//
//  Arguments:  [pbMem] - pointer to the memory to be deallocated
//              [rcbPageAllocTracker] - memory allocation counter
//              [cbSize] - optional size of memory segment
//
//  Requires:   memory to be deallocated must have previously been
//              allocated by TblPageAlloc.
//
//  Returns:    nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

void    TblPageDealloc(
    PVOID       pbMem,
    ULONG&      rcbPageAllocTracker,
    ULONG       cbSize
) {
    ULONG cbPageOffset = (ULONG)(((ULONG_PTR)pbMem) & TBL_PAGE_MASK);

    Win4Assert(cbPageOffset == 0 ||
           cbPageOffset == sizeof (TBL_PAGE_SIGNATURE));

    if (cbPageOffset == sizeof (TBL_PAGE_SIGNATURE)) {
        TBL_PAGE_SIGNATURE * pSigStruct =
                (TBL_PAGE_SIGNATURE *) ((BYTE*)pbMem - sizeof (TBL_PAGE_SIGNATURE));

        Win4Assert (pSigStruct->ulSig != 0 &&
                pSigStruct->cbSize >= TBL_PAGE_ALLOC_MIN &&
                pSigStruct->pbAddr == (BYTE *)pSigStruct);

        cbSize = pSigStruct->cbSize;
        pbMem = (BYTE *)pSigStruct;
    } else {
        Win4Assert(cbSize != 0);
    }

    BOOL fOK = VirtualFree(pbMem, 0, MEM_RELEASE);

    Win4Assert( fOK && "virtual free failed!" );

    rcbPageAllocTracker -= cbSize;
}

//
//  Default memory tracking variable
//
ULONG CWindowDataAllocator::_cbPageTracker = 0;


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::~CWindowDataAllocator, public
//
//  Synopsis:   Destroys a window data allocator
//
//  Notes:
//
//--------------------------------------------------------------------------

CWindowDataAllocator::~CWindowDataAllocator ()
{
    CSegmentHeader* pSegHdr = (CSegmentHeader*) _pBaseAddr;

    while (pSegHdr) {
        _pBaseAddr = pSegHdr->pNextSegment;

        TblPageDealloc(pSegHdr, *_pcbPageUsed);

        pSegHdr = _pBaseAddr;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CWindowDataAllocator::_SetArena, private
//
//  Synopsis:   Creates the initial memory arena in a memory segment
//
//  Arguments:  [pBufBase] - start of memory area
//              [cbBuf] - total size of memory area
//              [pHeap] - optional pointer to previously set up heap
//                      Assumed to be entirely within pBufBase.
//              [oBuf] - buffer offset assigned to segment
//
//  Returns:    nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

void CWindowDataAllocator::_SetArena (PVOID pBufBase,
                                     size_t cbBuf,
                                     CHeapHeader* pHeap,
                                     ULONG oBuf
) {
    CSegmentHeader* pSegHdr = (